<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2012, 2020 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 //
   25 
   26 //
   27 // PPC64 Architecture Description File
   28 //
   29 
   30 //----------REGISTER DEFINITION BLOCK------------------------------------------
   31 // This information is used by the matcher and the register allocator to
   32 // describe individual registers and classes of registers within the target
   33 // architecture.
   34 register %{
   35 //----------Architecture Description Register Definitions----------------------
   36 // General Registers
   37 // &quot;reg_def&quot;  name (register save type, C convention save type,
   38 //                  ideal register type, encoding);
   39 //
   40 // Register Save Types:
   41 //
   42 //   NS  = No-Save:     The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method, &amp;
   44 //                      that they do not need to be saved at call sites.
   45 //
   46 //   SOC = Save-On-Call: The register allocator assumes that these registers
   47 //                      can be used without saving upon entry to the method,
   48 //                      but that they must be saved at call sites.
   49 //                      These are called &quot;volatiles&quot; on ppc.
   50 //
   51 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, but they do not need to be saved at call
   54 //                      sites.
   55 //                      These are called &quot;nonvolatiles&quot; on ppc.
   56 //
   57 //   AS  = Always-Save:   The register allocator assumes that these registers
   58 //                      must be saved before using them upon entry to the
   59 //                      method, &amp; that they must be saved at call sites.
   60 //
   61 // Ideal Register Type is used to determine how to save &amp; restore a
   62 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   63 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   64 //
   65 // The encoding number is the actual bit-pattern placed into the opcodes.
   66 //
   67 // PPC64 register definitions, based on the 64-bit PowerPC ELF ABI
   68 // Supplement Version 1.7 as of 2003-10-29.
   69 //
   70 // For each 64-bit register we must define two registers: the register
   71 // itself, e.g. R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   72 // e.g. R3_H, which is needed by the allocator, but is not used
   73 // for stores, loads, etc.
   74 
   75 // ----------------------------
   76 // Integer/Long Registers
   77 // ----------------------------
   78 
   79   // PPC64 has 32 64-bit integer registers.
   80 
   81   // types: v = volatile, nv = non-volatile, s = system
   82   reg_def R0   ( SOC, SOC, Op_RegI,  0, R0-&gt;as_VMReg()         );  // v   used in prologs
   83   reg_def R0_H ( SOC, SOC, Op_RegI, 99, R0-&gt;as_VMReg()-&gt;next() );
   84   reg_def R1   ( NS,  NS,  Op_RegI,  1, R1-&gt;as_VMReg()         );  // s   SP
   85   reg_def R1_H ( NS,  NS,  Op_RegI, 99, R1-&gt;as_VMReg()-&gt;next() );
   86   reg_def R2   ( SOC, SOC, Op_RegI,  2, R2-&gt;as_VMReg()         );  // v   TOC
   87   reg_def R2_H ( SOC, SOC, Op_RegI, 99, R2-&gt;as_VMReg()-&gt;next() );
   88   reg_def R3   ( SOC, SOC, Op_RegI,  3, R3-&gt;as_VMReg()         );  // v   iarg1 &amp; iret
   89   reg_def R3_H ( SOC, SOC, Op_RegI, 99, R3-&gt;as_VMReg()-&gt;next() );
   90   reg_def R4   ( SOC, SOC, Op_RegI,  4, R4-&gt;as_VMReg()         );  //     iarg2
   91   reg_def R4_H ( SOC, SOC, Op_RegI, 99, R4-&gt;as_VMReg()-&gt;next() );
   92   reg_def R5   ( SOC, SOC, Op_RegI,  5, R5-&gt;as_VMReg()         );  // v   iarg3
   93   reg_def R5_H ( SOC, SOC, Op_RegI, 99, R5-&gt;as_VMReg()-&gt;next() );
   94   reg_def R6   ( SOC, SOC, Op_RegI,  6, R6-&gt;as_VMReg()         );  // v   iarg4
   95   reg_def R6_H ( SOC, SOC, Op_RegI, 99, R6-&gt;as_VMReg()-&gt;next() );
   96   reg_def R7   ( SOC, SOC, Op_RegI,  7, R7-&gt;as_VMReg()         );  // v   iarg5
   97   reg_def R7_H ( SOC, SOC, Op_RegI, 99, R7-&gt;as_VMReg()-&gt;next() );
   98   reg_def R8   ( SOC, SOC, Op_RegI,  8, R8-&gt;as_VMReg()         );  // v   iarg6
   99   reg_def R8_H ( SOC, SOC, Op_RegI, 99, R8-&gt;as_VMReg()-&gt;next() );
  100   reg_def R9   ( SOC, SOC, Op_RegI,  9, R9-&gt;as_VMReg()         );  // v   iarg7
  101   reg_def R9_H ( SOC, SOC, Op_RegI, 99, R9-&gt;as_VMReg()-&gt;next() );
  102   reg_def R10  ( SOC, SOC, Op_RegI, 10, R10-&gt;as_VMReg()        );  // v   iarg8
  103   reg_def R10_H( SOC, SOC, Op_RegI, 99, R10-&gt;as_VMReg()-&gt;next());
  104   reg_def R11  ( SOC, SOC, Op_RegI, 11, R11-&gt;as_VMReg()        );  // v   ENV / scratch
  105   reg_def R11_H( SOC, SOC, Op_RegI, 99, R11-&gt;as_VMReg()-&gt;next());
  106   reg_def R12  ( SOC, SOC, Op_RegI, 12, R12-&gt;as_VMReg()        );  // v   scratch
  107   reg_def R12_H( SOC, SOC, Op_RegI, 99, R12-&gt;as_VMReg()-&gt;next());
  108   reg_def R13  ( NS,  NS,  Op_RegI, 13, R13-&gt;as_VMReg()        );  // s   system thread id
  109   reg_def R13_H( NS,  NS,  Op_RegI, 99, R13-&gt;as_VMReg()-&gt;next());
  110   reg_def R14  ( SOC, SOE, Op_RegI, 14, R14-&gt;as_VMReg()        );  // nv
  111   reg_def R14_H( SOC, SOE, Op_RegI, 99, R14-&gt;as_VMReg()-&gt;next());
  112   reg_def R15  ( SOC, SOE, Op_RegI, 15, R15-&gt;as_VMReg()        );  // nv
  113   reg_def R15_H( SOC, SOE, Op_RegI, 99, R15-&gt;as_VMReg()-&gt;next());
  114   reg_def R16  ( SOC, SOE, Op_RegI, 16, R16-&gt;as_VMReg()        );  // nv
  115   reg_def R16_H( SOC, SOE, Op_RegI, 99, R16-&gt;as_VMReg()-&gt;next());
  116   reg_def R17  ( SOC, SOE, Op_RegI, 17, R17-&gt;as_VMReg()        );  // nv
  117   reg_def R17_H( SOC, SOE, Op_RegI, 99, R17-&gt;as_VMReg()-&gt;next());
  118   reg_def R18  ( SOC, SOE, Op_RegI, 18, R18-&gt;as_VMReg()        );  // nv
  119   reg_def R18_H( SOC, SOE, Op_RegI, 99, R18-&gt;as_VMReg()-&gt;next());
  120   reg_def R19  ( SOC, SOE, Op_RegI, 19, R19-&gt;as_VMReg()        );  // nv
  121   reg_def R19_H( SOC, SOE, Op_RegI, 99, R19-&gt;as_VMReg()-&gt;next());
  122   reg_def R20  ( SOC, SOE, Op_RegI, 20, R20-&gt;as_VMReg()        );  // nv
  123   reg_def R20_H( SOC, SOE, Op_RegI, 99, R20-&gt;as_VMReg()-&gt;next());
  124   reg_def R21  ( SOC, SOE, Op_RegI, 21, R21-&gt;as_VMReg()        );  // nv
  125   reg_def R21_H( SOC, SOE, Op_RegI, 99, R21-&gt;as_VMReg()-&gt;next());
  126   reg_def R22  ( SOC, SOE, Op_RegI, 22, R22-&gt;as_VMReg()        );  // nv
  127   reg_def R22_H( SOC, SOE, Op_RegI, 99, R22-&gt;as_VMReg()-&gt;next());
  128   reg_def R23  ( SOC, SOE, Op_RegI, 23, R23-&gt;as_VMReg()        );  // nv
  129   reg_def R23_H( SOC, SOE, Op_RegI, 99, R23-&gt;as_VMReg()-&gt;next());
  130   reg_def R24  ( SOC, SOE, Op_RegI, 24, R24-&gt;as_VMReg()        );  // nv
  131   reg_def R24_H( SOC, SOE, Op_RegI, 99, R24-&gt;as_VMReg()-&gt;next());
  132   reg_def R25  ( SOC, SOE, Op_RegI, 25, R25-&gt;as_VMReg()        );  // nv
  133   reg_def R25_H( SOC, SOE, Op_RegI, 99, R25-&gt;as_VMReg()-&gt;next());
  134   reg_def R26  ( SOC, SOE, Op_RegI, 26, R26-&gt;as_VMReg()        );  // nv
  135   reg_def R26_H( SOC, SOE, Op_RegI, 99, R26-&gt;as_VMReg()-&gt;next());
  136   reg_def R27  ( SOC, SOE, Op_RegI, 27, R27-&gt;as_VMReg()        );  // nv
  137   reg_def R27_H( SOC, SOE, Op_RegI, 99, R27-&gt;as_VMReg()-&gt;next());
  138   reg_def R28  ( SOC, SOE, Op_RegI, 28, R28-&gt;as_VMReg()        );  // nv
  139   reg_def R28_H( SOC, SOE, Op_RegI, 99, R28-&gt;as_VMReg()-&gt;next());
  140   reg_def R29  ( SOC, SOE, Op_RegI, 29, R29-&gt;as_VMReg()        );  // nv
  141   reg_def R29_H( SOC, SOE, Op_RegI, 99, R29-&gt;as_VMReg()-&gt;next());
  142   reg_def R30  ( SOC, SOE, Op_RegI, 30, R30-&gt;as_VMReg()        );  // nv
  143   reg_def R30_H( SOC, SOE, Op_RegI, 99, R30-&gt;as_VMReg()-&gt;next());
  144   reg_def R31  ( SOC, SOE, Op_RegI, 31, R31-&gt;as_VMReg()        );  // nv
  145   reg_def R31_H( SOC, SOE, Op_RegI, 99, R31-&gt;as_VMReg()-&gt;next());
  146 
  147 
  148 // ----------------------------
  149 // Float/Double Registers
  150 // ----------------------------
  151 
  152   // Double Registers
  153   // The rules of ADL require that double registers be defined in pairs.
  154   // Each pair must be two 32-bit values, but not necessarily a pair of
  155   // single float registers. In each pair, ADLC-assigned register numbers
  156   // must be adjacent, with the lower number even. Finally, when the
  157   // CPU stores such a register pair to memory, the word associated with
  158   // the lower ADLC-assigned number must be stored to the lower address.
  159 
  160   // PPC64 has 32 64-bit floating-point registers. Each can store a single
  161   // or double precision floating-point value.
  162 
  163   // types: v = volatile, nv = non-volatile, s = system
  164   reg_def F0   ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg()         );  // v   scratch
  165   reg_def F0_H ( SOC, SOC, Op_RegF, 99, F0-&gt;as_VMReg()-&gt;next() );
  166   reg_def F1   ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg()         );  // v   farg1 &amp; fret
  167   reg_def F1_H ( SOC, SOC, Op_RegF, 99, F1-&gt;as_VMReg()-&gt;next() );
  168   reg_def F2   ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg()         );  // v   farg2
  169   reg_def F2_H ( SOC, SOC, Op_RegF, 99, F2-&gt;as_VMReg()-&gt;next() );
  170   reg_def F3   ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg()         );  // v   farg3
  171   reg_def F3_H ( SOC, SOC, Op_RegF, 99, F3-&gt;as_VMReg()-&gt;next() );
  172   reg_def F4   ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg()         );  // v   farg4
  173   reg_def F4_H ( SOC, SOC, Op_RegF, 99, F4-&gt;as_VMReg()-&gt;next() );
  174   reg_def F5   ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg()         );  // v   farg5
  175   reg_def F5_H ( SOC, SOC, Op_RegF, 99, F5-&gt;as_VMReg()-&gt;next() );
  176   reg_def F6   ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg()         );  // v   farg6
  177   reg_def F6_H ( SOC, SOC, Op_RegF, 99, F6-&gt;as_VMReg()-&gt;next() );
  178   reg_def F7   ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg()         );  // v   farg7
  179   reg_def F7_H ( SOC, SOC, Op_RegF, 99, F7-&gt;as_VMReg()-&gt;next() );
  180   reg_def F8   ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg()         );  // v   farg8
  181   reg_def F8_H ( SOC, SOC, Op_RegF, 99, F8-&gt;as_VMReg()-&gt;next() );
  182   reg_def F9   ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg()         );  // v   farg9
  183   reg_def F9_H ( SOC, SOC, Op_RegF, 99, F9-&gt;as_VMReg()-&gt;next() );
  184   reg_def F10  ( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg()        );  // v   farg10
  185   reg_def F10_H( SOC, SOC, Op_RegF, 99, F10-&gt;as_VMReg()-&gt;next());
  186   reg_def F11  ( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg()        );  // v   farg11
  187   reg_def F11_H( SOC, SOC, Op_RegF, 99, F11-&gt;as_VMReg()-&gt;next());
  188   reg_def F12  ( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg()        );  // v   farg12
  189   reg_def F12_H( SOC, SOC, Op_RegF, 99, F12-&gt;as_VMReg()-&gt;next());
  190   reg_def F13  ( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg()        );  // v   farg13
  191   reg_def F13_H( SOC, SOC, Op_RegF, 99, F13-&gt;as_VMReg()-&gt;next());
  192   reg_def F14  ( SOC, SOE, Op_RegF, 14, F14-&gt;as_VMReg()        );  // nv
  193   reg_def F14_H( SOC, SOE, Op_RegF, 99, F14-&gt;as_VMReg()-&gt;next());
  194   reg_def F15  ( SOC, SOE, Op_RegF, 15, F15-&gt;as_VMReg()        );  // nv
  195   reg_def F15_H( SOC, SOE, Op_RegF, 99, F15-&gt;as_VMReg()-&gt;next());
  196   reg_def F16  ( SOC, SOE, Op_RegF, 16, F16-&gt;as_VMReg()        );  // nv
  197   reg_def F16_H( SOC, SOE, Op_RegF, 99, F16-&gt;as_VMReg()-&gt;next());
  198   reg_def F17  ( SOC, SOE, Op_RegF, 17, F17-&gt;as_VMReg()        );  // nv
  199   reg_def F17_H( SOC, SOE, Op_RegF, 99, F17-&gt;as_VMReg()-&gt;next());
  200   reg_def F18  ( SOC, SOE, Op_RegF, 18, F18-&gt;as_VMReg()        );  // nv
  201   reg_def F18_H( SOC, SOE, Op_RegF, 99, F18-&gt;as_VMReg()-&gt;next());
  202   reg_def F19  ( SOC, SOE, Op_RegF, 19, F19-&gt;as_VMReg()        );  // nv
  203   reg_def F19_H( SOC, SOE, Op_RegF, 99, F19-&gt;as_VMReg()-&gt;next());
  204   reg_def F20  ( SOC, SOE, Op_RegF, 20, F20-&gt;as_VMReg()        );  // nv
  205   reg_def F20_H( SOC, SOE, Op_RegF, 99, F20-&gt;as_VMReg()-&gt;next());
  206   reg_def F21  ( SOC, SOE, Op_RegF, 21, F21-&gt;as_VMReg()        );  // nv
  207   reg_def F21_H( SOC, SOE, Op_RegF, 99, F21-&gt;as_VMReg()-&gt;next());
  208   reg_def F22  ( SOC, SOE, Op_RegF, 22, F22-&gt;as_VMReg()        );  // nv
  209   reg_def F22_H( SOC, SOE, Op_RegF, 99, F22-&gt;as_VMReg()-&gt;next());
  210   reg_def F23  ( SOC, SOE, Op_RegF, 23, F23-&gt;as_VMReg()        );  // nv
  211   reg_def F23_H( SOC, SOE, Op_RegF, 99, F23-&gt;as_VMReg()-&gt;next());
  212   reg_def F24  ( SOC, SOE, Op_RegF, 24, F24-&gt;as_VMReg()        );  // nv
  213   reg_def F24_H( SOC, SOE, Op_RegF, 99, F24-&gt;as_VMReg()-&gt;next());
  214   reg_def F25  ( SOC, SOE, Op_RegF, 25, F25-&gt;as_VMReg()        );  // nv
  215   reg_def F25_H( SOC, SOE, Op_RegF, 99, F25-&gt;as_VMReg()-&gt;next());
  216   reg_def F26  ( SOC, SOE, Op_RegF, 26, F26-&gt;as_VMReg()        );  // nv
  217   reg_def F26_H( SOC, SOE, Op_RegF, 99, F26-&gt;as_VMReg()-&gt;next());
  218   reg_def F27  ( SOC, SOE, Op_RegF, 27, F27-&gt;as_VMReg()        );  // nv
  219   reg_def F27_H( SOC, SOE, Op_RegF, 99, F27-&gt;as_VMReg()-&gt;next());
  220   reg_def F28  ( SOC, SOE, Op_RegF, 28, F28-&gt;as_VMReg()        );  // nv
  221   reg_def F28_H( SOC, SOE, Op_RegF, 99, F28-&gt;as_VMReg()-&gt;next());
  222   reg_def F29  ( SOC, SOE, Op_RegF, 29, F29-&gt;as_VMReg()        );  // nv
  223   reg_def F29_H( SOC, SOE, Op_RegF, 99, F29-&gt;as_VMReg()-&gt;next());
  224   reg_def F30  ( SOC, SOE, Op_RegF, 30, F30-&gt;as_VMReg()        );  // nv
  225   reg_def F30_H( SOC, SOE, Op_RegF, 99, F30-&gt;as_VMReg()-&gt;next());
  226   reg_def F31  ( SOC, SOE, Op_RegF, 31, F31-&gt;as_VMReg()        );  // nv
  227   reg_def F31_H( SOC, SOE, Op_RegF, 99, F31-&gt;as_VMReg()-&gt;next());
  228 
  229 // ----------------------------
  230 // Special Registers
  231 // ----------------------------
  232 
  233 // Condition Codes Flag Registers
  234 
  235   // PPC64 has 8 condition code &quot;registers&quot; which are all contained
  236   // in the CR register.
  237 
  238   // types: v = volatile, nv = non-volatile, s = system
  239   reg_def CCR0(SOC, SOC, Op_RegFlags, 0, CCR0-&gt;as_VMReg());  // v
  240   reg_def CCR1(SOC, SOC, Op_RegFlags, 1, CCR1-&gt;as_VMReg());  // v
  241   reg_def CCR2(SOC, SOC, Op_RegFlags, 2, CCR2-&gt;as_VMReg());  // nv
  242   reg_def CCR3(SOC, SOC, Op_RegFlags, 3, CCR3-&gt;as_VMReg());  // nv
  243   reg_def CCR4(SOC, SOC, Op_RegFlags, 4, CCR4-&gt;as_VMReg());  // nv
  244   reg_def CCR5(SOC, SOC, Op_RegFlags, 5, CCR5-&gt;as_VMReg());  // v
  245   reg_def CCR6(SOC, SOC, Op_RegFlags, 6, CCR6-&gt;as_VMReg());  // v
  246   reg_def CCR7(SOC, SOC, Op_RegFlags, 7, CCR7-&gt;as_VMReg());  // v
  247 
  248   // Special registers of PPC64
  249 
  250   reg_def SR_XER(    SOC, SOC, Op_RegP, 0, SR_XER-&gt;as_VMReg());     // v
  251   reg_def SR_LR(     SOC, SOC, Op_RegP, 1, SR_LR-&gt;as_VMReg());      // v
  252   reg_def SR_CTR(    SOC, SOC, Op_RegP, 2, SR_CTR-&gt;as_VMReg());     // v
  253   reg_def SR_VRSAVE( SOC, SOC, Op_RegP, 3, SR_VRSAVE-&gt;as_VMReg());  // v
  254   reg_def SR_SPEFSCR(SOC, SOC, Op_RegP, 4, SR_SPEFSCR-&gt;as_VMReg()); // v
  255   reg_def SR_PPR(    SOC, SOC, Op_RegP, 5, SR_PPR-&gt;as_VMReg());     // v
  256 
  257 // ----------------------------
  258 // Vector-Scalar Registers
  259 // ----------------------------
  260   reg_def VSR0 ( SOC, SOC, Op_VecX, 0, NULL);
  261   reg_def VSR1 ( SOC, SOC, Op_VecX, 1, NULL);
  262   reg_def VSR2 ( SOC, SOC, Op_VecX, 2, NULL);
  263   reg_def VSR3 ( SOC, SOC, Op_VecX, 3, NULL);
  264   reg_def VSR4 ( SOC, SOC, Op_VecX, 4, NULL);
  265   reg_def VSR5 ( SOC, SOC, Op_VecX, 5, NULL);
  266   reg_def VSR6 ( SOC, SOC, Op_VecX, 6, NULL);
  267   reg_def VSR7 ( SOC, SOC, Op_VecX, 7, NULL);
  268   reg_def VSR8 ( SOC, SOC, Op_VecX, 8, NULL);
  269   reg_def VSR9 ( SOC, SOC, Op_VecX, 9, NULL);
  270   reg_def VSR10 ( SOC, SOC, Op_VecX, 10, NULL);
  271   reg_def VSR11 ( SOC, SOC, Op_VecX, 11, NULL);
  272   reg_def VSR12 ( SOC, SOC, Op_VecX, 12, NULL);
  273   reg_def VSR13 ( SOC, SOC, Op_VecX, 13, NULL);
  274   reg_def VSR14 ( SOC, SOC, Op_VecX, 14, NULL);
  275   reg_def VSR15 ( SOC, SOC, Op_VecX, 15, NULL);
  276   reg_def VSR16 ( SOC, SOC, Op_VecX, 16, NULL);
  277   reg_def VSR17 ( SOC, SOC, Op_VecX, 17, NULL);
  278   reg_def VSR18 ( SOC, SOC, Op_VecX, 18, NULL);
  279   reg_def VSR19 ( SOC, SOC, Op_VecX, 19, NULL);
  280   reg_def VSR20 ( SOC, SOC, Op_VecX, 20, NULL);
  281   reg_def VSR21 ( SOC, SOC, Op_VecX, 21, NULL);
  282   reg_def VSR22 ( SOC, SOC, Op_VecX, 22, NULL);
  283   reg_def VSR23 ( SOC, SOC, Op_VecX, 23, NULL);
  284   reg_def VSR24 ( SOC, SOC, Op_VecX, 24, NULL);
  285   reg_def VSR25 ( SOC, SOC, Op_VecX, 25, NULL);
  286   reg_def VSR26 ( SOC, SOC, Op_VecX, 26, NULL);
  287   reg_def VSR27 ( SOC, SOC, Op_VecX, 27, NULL);
  288   reg_def VSR28 ( SOC, SOC, Op_VecX, 28, NULL);
  289   reg_def VSR29 ( SOC, SOC, Op_VecX, 29, NULL);
  290   reg_def VSR30 ( SOC, SOC, Op_VecX, 30, NULL);
  291   reg_def VSR31 ( SOC, SOC, Op_VecX, 31, NULL);
  292   reg_def VSR32 ( SOC, SOC, Op_VecX, 32, NULL);
  293   reg_def VSR33 ( SOC, SOC, Op_VecX, 33, NULL);
  294   reg_def VSR34 ( SOC, SOC, Op_VecX, 34, NULL);
  295   reg_def VSR35 ( SOC, SOC, Op_VecX, 35, NULL);
  296   reg_def VSR36 ( SOC, SOC, Op_VecX, 36, NULL);
  297   reg_def VSR37 ( SOC, SOC, Op_VecX, 37, NULL);
  298   reg_def VSR38 ( SOC, SOC, Op_VecX, 38, NULL);
  299   reg_def VSR39 ( SOC, SOC, Op_VecX, 39, NULL);
  300   reg_def VSR40 ( SOC, SOC, Op_VecX, 40, NULL);
  301   reg_def VSR41 ( SOC, SOC, Op_VecX, 41, NULL);
  302   reg_def VSR42 ( SOC, SOC, Op_VecX, 42, NULL);
  303   reg_def VSR43 ( SOC, SOC, Op_VecX, 43, NULL);
  304   reg_def VSR44 ( SOC, SOC, Op_VecX, 44, NULL);
  305   reg_def VSR45 ( SOC, SOC, Op_VecX, 45, NULL);
  306   reg_def VSR46 ( SOC, SOC, Op_VecX, 46, NULL);
  307   reg_def VSR47 ( SOC, SOC, Op_VecX, 47, NULL);
  308   reg_def VSR48 ( SOC, SOC, Op_VecX, 48, NULL);
  309   reg_def VSR49 ( SOC, SOC, Op_VecX, 49, NULL);
  310   reg_def VSR50 ( SOC, SOC, Op_VecX, 50, NULL);
  311   reg_def VSR51 ( SOC, SOC, Op_VecX, 51, NULL);
  312   reg_def VSR52 ( SOC, SOC, Op_VecX, 52, NULL);
  313   reg_def VSR53 ( SOC, SOC, Op_VecX, 53, NULL);
  314   reg_def VSR54 ( SOC, SOC, Op_VecX, 54, NULL);
  315   reg_def VSR55 ( SOC, SOC, Op_VecX, 55, NULL);
  316   reg_def VSR56 ( SOC, SOC, Op_VecX, 56, NULL);
  317   reg_def VSR57 ( SOC, SOC, Op_VecX, 57, NULL);
  318   reg_def VSR58 ( SOC, SOC, Op_VecX, 58, NULL);
  319   reg_def VSR59 ( SOC, SOC, Op_VecX, 59, NULL);
  320   reg_def VSR60 ( SOC, SOC, Op_VecX, 60, NULL);
  321   reg_def VSR61 ( SOC, SOC, Op_VecX, 61, NULL);
  322   reg_def VSR62 ( SOC, SOC, Op_VecX, 62, NULL);
  323   reg_def VSR63 ( SOC, SOC, Op_VecX, 63, NULL);
  324 
  325 // ----------------------------
  326 // Specify priority of register selection within phases of register
  327 // allocation. Highest priority is first. A useful heuristic is to
  328 // give registers a low priority when they are required by machine
  329 // instructions, like EAX and EDX on I486, and choose no-save registers
  330 // before save-on-call, &amp; save-on-call before save-on-entry. Registers
  331 // which participate in fixed calling sequences should come last.
  332 // Registers which are used as pairs must fall on an even boundary.
  333 
  334 // It&#39;s worth about 1% on SPEC geomean to get this right.
  335 
  336 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  337 // in adGlobals_ppc.hpp which defines the &lt;register&gt;_num values, e.g.
  338 // R3_num. Therefore, R3_num may not be (and in reality is not)
  339 // the same as R3-&gt;encoding()! Furthermore, we cannot make any
  340 // assumptions on ordering, e.g. R3_num may be less than R2_num.
  341 // Additionally, the function
  342 //   static enum RC rc_class(OptoReg::Name reg )
  343 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  344 // and its current implementation relies on chunk0 and chunk1 having a
  345 // size of 64 each.
  346 
  347 // If you change this allocation class, please have a look at the
  348 // default values for the parameters RoundRobinIntegerRegIntervalStart
  349 // and RoundRobinFloatRegIntervalStart
  350 
  351 alloc_class chunk0 (
  352   // Chunk0 contains *all* 64 integer registers halves.
  353 
  354   // &quot;non-volatile&quot; registers
  355   R14, R14_H,
  356   R15, R15_H,
  357   R17, R17_H,
  358   R18, R18_H,
  359   R19, R19_H,
  360   R20, R20_H,
  361   R21, R21_H,
  362   R22, R22_H,
  363   R23, R23_H,
  364   R24, R24_H,
  365   R25, R25_H,
  366   R26, R26_H,
  367   R27, R27_H,
  368   R28, R28_H,
  369   R29, R29_H,
  370   R30, R30_H,
  371   R31, R31_H,
  372 
  373   // scratch/special registers
  374   R11, R11_H,
  375   R12, R12_H,
  376 
  377   // argument registers
  378   R10, R10_H,
  379   R9,  R9_H,
  380   R8,  R8_H,
  381   R7,  R7_H,
  382   R6,  R6_H,
  383   R5,  R5_H,
  384   R4,  R4_H,
  385   R3,  R3_H,
  386 
  387   // special registers, not available for allocation
  388   R16, R16_H,     // R16_thread
  389   R13, R13_H,     // system thread id
  390   R2,  R2_H,      // may be used for TOC
  391   R1,  R1_H,      // SP
  392   R0,  R0_H       // R0 (scratch)
  393 );
  394 
  395 // If you change this allocation class, please have a look at the
  396 // default values for the parameters RoundRobinIntegerRegIntervalStart
  397 // and RoundRobinFloatRegIntervalStart
  398 
  399 alloc_class chunk1 (
  400   // Chunk1 contains *all* 64 floating-point registers halves.
  401 
  402   // scratch register
  403   F0,  F0_H,
  404 
  405   // argument registers
  406   F13, F13_H,
  407   F12, F12_H,
  408   F11, F11_H,
  409   F10, F10_H,
  410   F9,  F9_H,
  411   F8,  F8_H,
  412   F7,  F7_H,
  413   F6,  F6_H,
  414   F5,  F5_H,
  415   F4,  F4_H,
  416   F3,  F3_H,
  417   F2,  F2_H,
  418   F1,  F1_H,
  419 
  420   // non-volatile registers
  421   F14, F14_H,
  422   F15, F15_H,
  423   F16, F16_H,
  424   F17, F17_H,
  425   F18, F18_H,
  426   F19, F19_H,
  427   F20, F20_H,
  428   F21, F21_H,
  429   F22, F22_H,
  430   F23, F23_H,
  431   F24, F24_H,
  432   F25, F25_H,
  433   F26, F26_H,
  434   F27, F27_H,
  435   F28, F28_H,
  436   F29, F29_H,
  437   F30, F30_H,
  438   F31, F31_H
  439 );
  440 
  441 alloc_class chunk2 (
  442   // Chunk2 contains *all* 8 condition code registers.
  443 
  444   CCR0,
  445   CCR1,
  446   CCR2,
  447   CCR3,
  448   CCR4,
  449   CCR5,
  450   CCR6,
  451   CCR7
  452 );
  453 
  454 alloc_class chunk3 (
  455   VSR0,
  456   VSR1,
  457   VSR2,
  458   VSR3,
  459   VSR4,
  460   VSR5,
  461   VSR6,
  462   VSR7,
  463   VSR8,
  464   VSR9,
  465   VSR10,
  466   VSR11,
  467   VSR12,
  468   VSR13,
  469   VSR14,
  470   VSR15,
  471   VSR16,
  472   VSR17,
  473   VSR18,
  474   VSR19,
  475   VSR20,
  476   VSR21,
  477   VSR22,
  478   VSR23,
  479   VSR24,
  480   VSR25,
  481   VSR26,
  482   VSR27,
  483   VSR28,
  484   VSR29,
  485   VSR30,
  486   VSR31,
  487   VSR32,
  488   VSR33,
  489   VSR34,
  490   VSR35,
  491   VSR36,
  492   VSR37,
  493   VSR38,
  494   VSR39,
  495   VSR40,
  496   VSR41,
  497   VSR42,
  498   VSR43,
  499   VSR44,
  500   VSR45,
  501   VSR46,
  502   VSR47,
  503   VSR48,
  504   VSR49,
  505   VSR50,
  506   VSR51,
  507   VSR52,
  508   VSR53,
  509   VSR54,
  510   VSR55,
  511   VSR56,
  512   VSR57,
  513   VSR58,
  514   VSR59,
  515   VSR60,
  516   VSR61,
  517   VSR62,
  518   VSR63
  519 );
  520 
  521 alloc_class chunk4 (
  522   // special registers
  523   // These registers are not allocated, but used for nodes generated by postalloc expand.
  524   SR_XER,
  525   SR_LR,
  526   SR_CTR,
  527   SR_VRSAVE,
  528   SR_SPEFSCR,
  529   SR_PPR
  530 );
  531 
  532 //-------Architecture Description Register Classes-----------------------
  533 
  534 // Several register classes are automatically defined based upon
  535 // information in this architecture description.
  536 
  537 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  538 // 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
  539 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  540 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  541 //
  542 
  543 // ----------------------------
  544 // 32 Bit Register Classes
  545 // ----------------------------
  546 
  547 // We specify registers twice, once as read/write, and once read-only.
  548 // We use the read-only registers for source operands. With this, we
  549 // can include preset read only registers in this class, as a hard-coded
  550 // &#39;0&#39;-register. (We used to simulate this on ppc.)
  551 
  552 // 32 bit registers that can be read and written i.e. these registers
  553 // can be dest (or src) of normal instructions.
  554 reg_class bits32_reg_rw(
  555 /*R0*/              // R0
  556 /*R1*/              // SP
  557   R2,               // TOC
  558   R3,
  559   R4,
  560   R5,
  561   R6,
  562   R7,
  563   R8,
  564   R9,
  565   R10,
  566   R11,
  567   R12,
  568 /*R13*/             // system thread id
  569   R14,
  570   R15,
  571 /*R16*/             // R16_thread
  572   R17,
  573   R18,
  574   R19,
  575   R20,
  576   R21,
  577   R22,
  578   R23,
  579   R24,
  580   R25,
  581   R26,
  582   R27,
  583   R28,
  584 /*R29,*/             // global TOC
  585   R30,
  586   R31
  587 );
  588 
  589 // 32 bit registers that can only be read i.e. these registers can
  590 // only be src of all instructions.
  591 reg_class bits32_reg_ro(
  592 /*R0*/              // R0
  593 /*R1*/              // SP
  594   R2                // TOC
  595   R3,
  596   R4,
  597   R5,
  598   R6,
  599   R7,
  600   R8,
  601   R9,
  602   R10,
  603   R11,
  604   R12,
  605 /*R13*/             // system thread id
  606   R14,
  607   R15,
  608 /*R16*/             // R16_thread
  609   R17,
  610   R18,
  611   R19,
  612   R20,
  613   R21,
  614   R22,
  615   R23,
  616   R24,
  617   R25,
  618   R26,
  619   R27,
  620   R28,
  621 /*R29,*/
  622   R30,
  623   R31
  624 );
  625 
  626 reg_class rscratch1_bits32_reg(R11);
  627 reg_class rscratch2_bits32_reg(R12);
  628 reg_class rarg1_bits32_reg(R3);
  629 reg_class rarg2_bits32_reg(R4);
  630 reg_class rarg3_bits32_reg(R5);
  631 reg_class rarg4_bits32_reg(R6);
  632 
  633 // ----------------------------
  634 // 64 Bit Register Classes
  635 // ----------------------------
  636 // 64-bit build means 64-bit pointers means hi/lo pairs
  637 
  638 reg_class rscratch1_bits64_reg(R11_H, R11);
  639 reg_class rscratch2_bits64_reg(R12_H, R12);
  640 reg_class rarg1_bits64_reg(R3_H, R3);
  641 reg_class rarg2_bits64_reg(R4_H, R4);
  642 reg_class rarg3_bits64_reg(R5_H, R5);
  643 reg_class rarg4_bits64_reg(R6_H, R6);
  644 // Thread register, &#39;written&#39; by tlsLoadP, see there.
  645 reg_class thread_bits64_reg(R16_H, R16);
  646 
  647 reg_class r19_bits64_reg(R19_H, R19);
  648 
  649 // 64 bit registers that can be read and written i.e. these registers
  650 // can be dest (or src) of normal instructions.
  651 reg_class bits64_reg_rw(
  652 /*R0_H,  R0*/     // R0
  653 /*R1_H,  R1*/     // SP
  654   R2_H,  R2,      // TOC
  655   R3_H,  R3,
  656   R4_H,  R4,
  657   R5_H,  R5,
  658   R6_H,  R6,
  659   R7_H,  R7,
  660   R8_H,  R8,
  661   R9_H,  R9,
  662   R10_H, R10,
  663   R11_H, R11,
  664   R12_H, R12,
  665 /*R13_H, R13*/   // system thread id
  666   R14_H, R14,
  667   R15_H, R15,
  668 /*R16_H, R16*/   // R16_thread
  669   R17_H, R17,
  670   R18_H, R18,
  671   R19_H, R19,
  672   R20_H, R20,
  673   R21_H, R21,
  674   R22_H, R22,
  675   R23_H, R23,
  676   R24_H, R24,
  677   R25_H, R25,
  678   R26_H, R26,
  679   R27_H, R27,
  680   R28_H, R28,
  681 /*R29_H, R29,*/
  682   R30_H, R30,
  683   R31_H, R31
  684 );
  685 
  686 // 64 bit registers used excluding r2, r11 and r12
  687 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
  688 // r2, r11 and r12 internally.
  689 reg_class bits64_reg_leaf_call(
  690 /*R0_H,  R0*/     // R0
  691 /*R1_H,  R1*/     // SP
  692 /*R2_H,  R2*/     // TOC
  693   R3_H,  R3,
  694   R4_H,  R4,
  695   R5_H,  R5,
  696   R6_H,  R6,
  697   R7_H,  R7,
  698   R8_H,  R8,
  699   R9_H,  R9,
  700   R10_H, R10,
  701 /*R11_H, R11*/
  702 /*R12_H, R12*/
  703 /*R13_H, R13*/   // system thread id
  704   R14_H, R14,
  705   R15_H, R15,
  706 /*R16_H, R16*/   // R16_thread
  707   R17_H, R17,
  708   R18_H, R18,
  709   R19_H, R19,
  710   R20_H, R20,
  711   R21_H, R21,
  712   R22_H, R22,
  713   R23_H, R23,
  714   R24_H, R24,
  715   R25_H, R25,
  716   R26_H, R26,
  717   R27_H, R27,
  718   R28_H, R28,
  719 /*R29_H, R29,*/
  720   R30_H, R30,
  721   R31_H, R31
  722 );
  723 
  724 // Used to hold the TOC to avoid collisions with expanded DynamicCall
  725 // which uses r19 as inline cache internally and expanded LeafCall which uses
  726 // r2, r11 and r12 internally.
  727 reg_class bits64_constant_table_base(
  728 /*R0_H,  R0*/     // R0
  729 /*R1_H,  R1*/     // SP
  730 /*R2_H,  R2*/     // TOC
  731   R3_H,  R3,
  732   R4_H,  R4,
  733   R5_H,  R5,
  734   R6_H,  R6,
  735   R7_H,  R7,
  736   R8_H,  R8,
  737   R9_H,  R9,
  738   R10_H, R10,
  739 /*R11_H, R11*/
  740 /*R12_H, R12*/
  741 /*R13_H, R13*/   // system thread id
  742   R14_H, R14,
  743   R15_H, R15,
  744 /*R16_H, R16*/   // R16_thread
  745   R17_H, R17,
  746   R18_H, R18,
  747 /*R19_H, R19*/
  748   R20_H, R20,
  749   R21_H, R21,
  750   R22_H, R22,
  751   R23_H, R23,
  752   R24_H, R24,
  753   R25_H, R25,
  754   R26_H, R26,
  755   R27_H, R27,
  756   R28_H, R28,
  757 /*R29_H, R29,*/
  758   R30_H, R30,
  759   R31_H, R31
  760 );
  761 
  762 // 64 bit registers that can only be read i.e. these registers can
  763 // only be src of all instructions.
  764 reg_class bits64_reg_ro(
  765 /*R0_H,  R0*/     // R0
  766   R1_H,  R1,
  767   R2_H,  R2,       // TOC
  768   R3_H,  R3,
  769   R4_H,  R4,
  770   R5_H,  R5,
  771   R6_H,  R6,
  772   R7_H,  R7,
  773   R8_H,  R8,
  774   R9_H,  R9,
  775   R10_H, R10,
  776   R11_H, R11,
  777   R12_H, R12,
  778 /*R13_H, R13*/   // system thread id
  779   R14_H, R14,
  780   R15_H, R15,
  781   R16_H, R16,    // R16_thread
  782   R17_H, R17,
  783   R18_H, R18,
  784   R19_H, R19,
  785   R20_H, R20,
  786   R21_H, R21,
  787   R22_H, R22,
  788   R23_H, R23,
  789   R24_H, R24,
  790   R25_H, R25,
  791   R26_H, R26,
  792   R27_H, R27,
  793   R28_H, R28,
  794 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
  795   R30_H, R30,
  796   R31_H, R31
  797 );
  798 
  799 
  800 // ----------------------------
  801 // Special Class for Condition Code Flags Register
  802 
  803 reg_class int_flags(
  804 /*CCR0*/             // scratch
  805 /*CCR1*/             // scratch
  806 /*CCR2*/             // nv!
  807 /*CCR3*/             // nv!
  808 /*CCR4*/             // nv!
  809   CCR5,
  810   CCR6,
  811   CCR7
  812 );
  813 
  814 reg_class int_flags_ro(
  815   CCR0,
  816   CCR1,
  817   CCR2,
  818   CCR3,
  819   CCR4,
  820   CCR5,
  821   CCR6,
  822   CCR7
  823 );
  824 
  825 reg_class int_flags_CR0(CCR0);
  826 reg_class int_flags_CR1(CCR1);
  827 reg_class int_flags_CR6(CCR6);
  828 reg_class ctr_reg(SR_CTR);
  829 
  830 // ----------------------------
  831 // Float Register Classes
  832 // ----------------------------
  833 
  834 reg_class flt_reg(
  835   F0,
  836   F1,
  837   F2,
  838   F3,
  839   F4,
  840   F5,
  841   F6,
  842   F7,
  843   F8,
  844   F9,
  845   F10,
  846   F11,
  847   F12,
  848   F13,
  849   F14,              // nv!
  850   F15,              // nv!
  851   F16,              // nv!
  852   F17,              // nv!
  853   F18,              // nv!
  854   F19,              // nv!
  855   F20,              // nv!
  856   F21,              // nv!
  857   F22,              // nv!
  858   F23,              // nv!
  859   F24,              // nv!
  860   F25,              // nv!
  861   F26,              // nv!
  862   F27,              // nv!
  863   F28,              // nv!
  864   F29,              // nv!
  865   F30,              // nv!
  866   F31               // nv!
  867 );
  868 
  869 // Double precision float registers have virtual `high halves&#39; that
  870 // are needed by the allocator.
  871 reg_class dbl_reg(
  872   F0,  F0_H,
  873   F1,  F1_H,
  874   F2,  F2_H,
  875   F3,  F3_H,
  876   F4,  F4_H,
  877   F5,  F5_H,
  878   F6,  F6_H,
  879   F7,  F7_H,
  880   F8,  F8_H,
  881   F9,  F9_H,
  882   F10, F10_H,
  883   F11, F11_H,
  884   F12, F12_H,
  885   F13, F13_H,
  886   F14, F14_H,    // nv!
  887   F15, F15_H,    // nv!
  888   F16, F16_H,    // nv!
  889   F17, F17_H,    // nv!
  890   F18, F18_H,    // nv!
  891   F19, F19_H,    // nv!
  892   F20, F20_H,    // nv!
  893   F21, F21_H,    // nv!
  894   F22, F22_H,    // nv!
  895   F23, F23_H,    // nv!
  896   F24, F24_H,    // nv!
  897   F25, F25_H,    // nv!
  898   F26, F26_H,    // nv!
  899   F27, F27_H,    // nv!
  900   F28, F28_H,    // nv!
  901   F29, F29_H,    // nv!
  902   F30, F30_H,    // nv!
  903   F31, F31_H     // nv!
  904 );
  905 
  906 // ----------------------------
  907 // Vector-Scalar Register Class
  908 // ----------------------------
  909 
  910 reg_class vs_reg(
  911   // Attention: Only these ones are saved &amp; restored at safepoint by RegisterSaver.
  912   VSR32,
  913   VSR33,
  914   VSR34,
  915   VSR35,
  916   VSR36,
  917   VSR37,
  918   VSR38,
  919   VSR39,
  920   VSR40,
  921   VSR41,
  922   VSR42,
  923   VSR43,
  924   VSR44,
  925   VSR45,
  926   VSR46,
  927   VSR47,
  928   VSR48,
  929   VSR49,
  930   VSR50,
  931   VSR51
  932   // VSR52-VSR63 // nv!
  933 );
  934 
  935  %}
  936 
  937 //----------DEFINITION BLOCK---------------------------------------------------
  938 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  939 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  940 // Format:
  941 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  942 // Generated Code in ad_&lt;arch&gt;.hpp
  943 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  944 //        // value == &lt;int_value&gt;
  945 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  946 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  947 //
  948 definitions %{
  949   // The default cost (of an ALU instruction).
  950   int_def DEFAULT_COST_LOW        (     30,      30);
  951   int_def DEFAULT_COST            (    100,     100);
  952   int_def HUGE_COST               (1000000, 1000000);
  953 
  954   // Memory refs
  955   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
  956   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
  957 
  958   // Branches are even more expensive.
  959   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
  960   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
  961 %}
  962 
  963 
  964 //----------SOURCE BLOCK-------------------------------------------------------
  965 // This is a block of C++ code which provides values, functions, and
  966 // definitions necessary in the rest of the architecture description.
  967 source_hpp %{
  968   // Header information of the source block.
  969   // Method declarations/definitions which are used outside
  970   // the ad-scope can conveniently be defined here.
  971   //
  972   // To keep related declarations/definitions/uses close together,
  973   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  974 
  975 #include &quot;opto/convertnode.hpp&quot;
  976 
  977   // Returns true if Node n is followed by a MemBar node that
  978   // will do an acquire. If so, this node must not do the acquire
  979   // operation.
  980   bool followed_by_acquire(const Node *n);
  981 %}
  982 
  983 source %{
  984 
  985 void PhaseOutput::pd_perform_mach_node_analysis() {
  986 }
  987 
  988 int MachNode::pd_alignment_required() const {
  989   return 1;
  990 }
  991 
  992 int MachNode::compute_padding(int current_offset) const {
  993   return 0;
  994 }
  995 
  996 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?
  997 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {
  998   return false;
  999 }
 1000 
 1001 // Should the Matcher clone shifts on addressing modes, expecting them
 1002 // to be subsumed into complex addressing expressions or compute them
 1003 // into registers?
 1004 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1005   return clone_base_plus_offset_address(m, mstack, address_visited);
 1006 }
 1007 
 1008 void Compile::reshape_address(AddPNode* addp) {
 1009 }
 1010 
 1011 // Optimize load-acquire.
 1012 //
 1013 // Check if acquire is unnecessary due to following operation that does
 1014 // acquire anyways.
 1015 // Walk the pattern:
 1016 //
 1017 //      n: Load.acq
 1018 //           |
 1019 //      MemBarAcquire
 1020 //       |         |
 1021 //  Proj(ctrl)  Proj(mem)
 1022 //       |         |
 1023 //   MemBarRelease/Volatile
 1024 //
 1025 bool followed_by_acquire(const Node *load) {
 1026   assert(load-&gt;is_Load(), &quot;So far implemented only for loads.&quot;);
 1027 
 1028   // Find MemBarAcquire.
 1029   const Node *mba = NULL;
 1030   for (DUIterator_Fast imax, i = load-&gt;fast_outs(imax); i &lt; imax; i++) {
 1031     const Node *out = load-&gt;fast_out(i);
 1032     if (out-&gt;Opcode() == Op_MemBarAcquire) {
 1033       if (out-&gt;in(0) == load) continue; // Skip control edge, membar should be found via precedence edge.
 1034       mba = out;
 1035       break;
 1036     }
 1037   }
 1038   if (!mba) return false;
 1039 
 1040   // Find following MemBar node.
 1041   //
 1042   // The following node must be reachable by control AND memory
 1043   // edge to assure no other operations are in between the two nodes.
 1044   //
 1045   // So first get the Proj node, mem_proj, to use it to iterate forward.
 1046   Node *mem_proj = NULL;
 1047   for (DUIterator_Fast imax, i = mba-&gt;fast_outs(imax); i &lt; imax; i++) {
 1048     mem_proj = mba-&gt;fast_out(i);      // Runs out of bounds and asserts if Proj not found.
 1049     assert(mem_proj-&gt;is_Proj(), &quot;only projections here&quot;);
 1050     ProjNode *proj = mem_proj-&gt;as_Proj();
 1051     if (proj-&gt;_con == TypeFunc::Memory &amp;&amp;
 1052         !Compile::current()-&gt;node_arena()-&gt;contains(mem_proj)) // Unmatched old-space only
 1053       break;
 1054   }
 1055   assert(mem_proj-&gt;as_Proj()-&gt;_con == TypeFunc::Memory, &quot;Graph broken&quot;);
 1056 
 1057   // Search MemBar behind Proj. If there are other memory operations
 1058   // behind the Proj we lost.
 1059   for (DUIterator_Fast jmax, j = mem_proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 1060     Node *x = mem_proj-&gt;fast_out(j);
 1061     // Proj might have an edge to a store or load node which precedes the membar.
 1062     if (x-&gt;is_Mem()) return false;
 1063 
 1064     // On PPC64 release and volatile are implemented by an instruction
 1065     // that also has acquire semantics. I.e. there is no need for an
 1066     // acquire before these.
 1067     int xop = x-&gt;Opcode();
 1068     if (xop == Op_MemBarRelease || xop == Op_MemBarVolatile) {
 1069       // Make sure we&#39;re not missing Call/Phi/MergeMem by checking
 1070       // control edges. The control edge must directly lead back
 1071       // to the MemBarAcquire
 1072       Node *ctrl_proj = x-&gt;in(0);
 1073       if (ctrl_proj-&gt;is_Proj() &amp;&amp; ctrl_proj-&gt;in(0) == mba) {
 1074         return true;
 1075       }
 1076     }
 1077   }
 1078 
 1079   return false;
 1080 }
 1081 
 1082 #define __ _masm.
 1083 
 1084 // Tertiary op of a LoadP or StoreP encoding.
 1085 #define REGP_OP true
 1086 
 1087 // ****************************************************************************
 1088 
 1089 // REQUIRED FUNCTIONALITY
 1090 
 1091 // !!!!! Special hack to get all type of calls to specify the byte offset
 1092 //       from the start of the call to the point where the return address
 1093 //       will point.
 1094 
 1095 // PPC port: Removed use of lazy constant construct.
 1096 
 1097 int MachCallStaticJavaNode::ret_addr_offset() {
 1098   // It&#39;s only a single branch-and-link instruction.
 1099   return 4;
 1100 }
 1101 
 1102 int MachCallDynamicJavaNode::ret_addr_offset() {
 1103   // Offset is 4 with postalloc expanded calls (bl is one instruction). We use
 1104   // postalloc expanded calls if we use inline caches and do not update method data.
 1105   if (UseInlineCaches)
 1106     return 4;
 1107 
 1108   int vtable_index = this-&gt;_vtable_index;
 1109   if (vtable_index &lt; 0) {
 1110     // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 1111     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 1112     return 12;
 1113   } else {
 1114     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 1115     return 24;
 1116   }
 1117 }
 1118 
 1119 int MachCallRuntimeNode::ret_addr_offset() {
 1120 #if defined(ABI_ELFv2)
 1121   return 28;
 1122 #else
 1123   return 40;
 1124 #endif
 1125 }
 1126 
 1127 //=============================================================================
 1128 
 1129 // condition code conversions
 1130 
 1131 static int cc_to_boint(int cc) {
 1132   return Assembler::bcondCRbiIs0 | (cc &amp; 8);
 1133 }
 1134 
 1135 static int cc_to_inverse_boint(int cc) {
 1136   return Assembler::bcondCRbiIs0 | (8-(cc &amp; 8));
 1137 }
 1138 
 1139 static int cc_to_biint(int cc, int flags_reg) {
 1140   return (flags_reg &lt;&lt; 2) | (cc &amp; 3);
 1141 }
 1142 
 1143 //=============================================================================
 1144 
 1145 // Compute padding required for nodes which need alignment. The padding
 1146 // is the number of bytes (not instructions) which will be inserted before
 1147 // the instruction. The padding must match the size of a NOP instruction.
 1148 
 1149 // Currently not used on this platform.
 1150 
 1151 //=============================================================================
 1152 
 1153 // Indicate if the safepoint node needs the polling page as an input.
 1154 bool SafePointNode::needs_polling_address_input() {
 1155   // The address is loaded from thread by a seperate node.
 1156   return true;
 1157 }
 1158 
 1159 //=============================================================================
 1160 
 1161 // Emit an interrupt that is caught by the debugger (for debugging compiler).
 1162 void emit_break(CodeBuffer &amp;cbuf) {
 1163   C2_MacroAssembler _masm(&amp;cbuf);
 1164   __ illtrap();
 1165 }
 1166 
 1167 #ifndef PRODUCT
 1168 void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1169   st-&gt;print(&quot;BREAKPOINT&quot;);
 1170 }
 1171 #endif
 1172 
 1173 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1174   emit_break(cbuf);
 1175 }
 1176 
 1177 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
 1178   return MachNode::size(ra_);
 1179 }
 1180 
 1181 //=============================================================================
 1182 
 1183 void emit_nop(CodeBuffer &amp;cbuf) {
 1184   C2_MacroAssembler _masm(&amp;cbuf);
 1185   __ nop();
 1186 }
 1187 
 1188 static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
 1189   *((int*)(cbuf.insts_end())) = value;
 1190   cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);
 1191 }
 1192 
 1193 //=============================================================================
 1194 
 1195 %} // interrupt source
 1196 
 1197 source_hpp %{ // Header information of the source block.
 1198 
 1199 //--------------------------------------------------------------
 1200 //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
 1201 //--------------------------------------------------------------
 1202 
 1203 class C2_MacroAssembler;
 1204 
 1205 class CallStubImpl {
 1206 
 1207  public:
 1208 
 1209   // Emit call stub, compiled java to interpreter.
 1210   static void emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);
 1211 
 1212   // Size of call trampoline stub.
 1213   // This doesn&#39;t need to be accurate to the byte, but it
 1214   // must be larger than or equal to the real size of the stub.
 1215   static uint size_call_trampoline() {
 1216     return MacroAssembler::trampoline_stub_size;
 1217   }
 1218 
 1219   // number of relocations needed by a call trampoline stub
 1220   static uint reloc_call_trampoline() {
 1221     return 5;
 1222   }
 1223 
 1224 };
 1225 
 1226 %} // end source_hpp
 1227 
 1228 source %{
 1229 
 1230 // Emit a trampoline stub for a call to a target which is too far away.
 1231 //
 1232 // code sequences:
 1233 //
 1234 // call-site:
 1235 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1236 //
 1237 // Related trampoline stub for this call-site in the stub section:
 1238 //   load the call target from the constant pool
 1239 //   branch via CTR (LR/link still points to the call-site above)
 1240 
 1241 void CallStubImpl::emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {
 1242   address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
 1243   if (stub == NULL) {
 1244     ciEnv::current()-&gt;record_out_of_memory_failure();
 1245   }
 1246 }
 1247 
 1248 //=============================================================================
 1249 
 1250 // Emit an inline branch-and-link call and a related trampoline stub.
 1251 //
 1252 // code sequences:
 1253 //
 1254 // call-site:
 1255 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1256 //
 1257 // Related trampoline stub for this call-site in the stub section:
 1258 //   load the call target from the constant pool
 1259 //   branch via CTR (LR/link still points to the call-site above)
 1260 //
 1261 
 1262 typedef struct {
 1263   int insts_call_instruction_offset;
 1264   int ret_addr_offset;
 1265 } EmitCallOffsets;
 1266 
 1267 // Emit a branch-and-link instruction that branches to a trampoline.
 1268 // - Remember the offset of the branch-and-link instruction.
 1269 // - Add a relocation at the branch-and-link instruction.
 1270 // - Emit a branch-and-link.
 1271 // - Remember the return pc offset.
 1272 EmitCallOffsets emit_call_with_trampoline_stub(C2_MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {
 1273   EmitCallOffsets offsets = { -1, -1 };
 1274   const int start_offset = __ offset();
 1275   offsets.insts_call_instruction_offset = __ offset();
 1276 
 1277   // No entry point given, use the current pc.
 1278   if (entry_point == NULL) entry_point = __ pc();
 1279 
 1280   // Put the entry point as a constant into the constant pool.
 1281   const address entry_point_toc_addr   = __ address_constant(entry_point, RelocationHolder::none);
 1282   if (entry_point_toc_addr == NULL) {
 1283     ciEnv::current()-&gt;record_out_of_memory_failure();
 1284     return offsets;
 1285   }
 1286   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 1287 
 1288   // Emit the trampoline stub which will be related to the branch-and-link below.
 1289   CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);
 1290   if (ciEnv::current()-&gt;failing()) { return offsets; } // Code cache may be full.
 1291   __ relocate(rtype);
 1292 
 1293   // Note: At this point we do not have the address of the trampoline
 1294   // stub, and the entry point might be too far away for bl, so __ pc()
 1295   // serves as dummy and the bl will be patched later.
 1296   __ bl((address) __ pc());
 1297 
 1298   offsets.ret_addr_offset = __ offset() - start_offset;
 1299 
 1300   return offsets;
 1301 }
 1302 
 1303 //=============================================================================
 1304 
 1305 // Factory for creating loadConL* nodes for large/small constant pool.
 1306 
 1307 static inline jlong replicate_immF(float con) {
 1308   // Replicate float con 2 times and pack into vector.
 1309   int val = *((int*)&amp;con);
 1310   jlong lval = val;
 1311   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
 1312   return lval;
 1313 }
 1314 
 1315 //=============================================================================
 1316 
 1317 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
 1318 int ConstantTable::calculate_table_base_offset() const {
 1319   return 0;  // absolute addressing, no offset
 1320 }
 1321 
 1322 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
 1323 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1324   iRegPdstOper *op_dst = new iRegPdstOper();
 1325   MachNode *m1 = new loadToc_hiNode();
 1326   MachNode *m2 = new loadToc_loNode();
 1327 
 1328   m1-&gt;add_req(NULL);
 1329   m2-&gt;add_req(NULL, m1);
 1330   m1-&gt;_opnds[0] = op_dst;
 1331   m2-&gt;_opnds[0] = op_dst;
 1332   m2-&gt;_opnds[1] = op_dst;
 1333   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1334   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1335   nodes-&gt;push(m1);
 1336   nodes-&gt;push(m2);
 1337 }
 1338 
 1339 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1340   // Is postalloc expanded.
 1341   ShouldNotReachHere();
 1342 }
 1343 
 1344 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1345   return 0;
 1346 }
 1347 
 1348 #ifndef PRODUCT
 1349 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1350   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1351 }
 1352 #endif
 1353 
 1354 //=============================================================================
 1355 
 1356 #ifndef PRODUCT
 1357 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1358   Compile* C = ra_-&gt;C;
 1359   const long framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1360 
 1361   st-&gt;print(&quot;PROLOG\n\t&quot;);
 1362   if (C-&gt;output()-&gt;need_stack_bang(framesize)) {
 1363     st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
 1364   }
 1365 
 1366   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
 1367     st-&gt;print(&quot;save return pc\n\t&quot;);
 1368     st-&gt;print(&quot;push frame %ld\n\t&quot;, -framesize);
 1369   }
 1370 }
 1371 #endif
 1372 
 1373 // Macro used instead of the common __ to emulate the pipes of PPC.
 1374 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
 1375 // micro scheduler to cope with &quot;hand written&quot; assembler like in the prolog. Though
 1376 // still no scheduling of this code is possible, the micro scheduler is aware of the
 1377 // code and can update its internal data. The following mechanism is used to achieve this:
 1378 // The micro scheduler calls size() of each compound node during scheduling. size() does a
 1379 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
 1380 #if 0 // TODO: PPC port
 1381 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1382                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
 1383                 _masm.
 1384 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1385                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
 1386 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
 1387                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
 1388 #else
 1389 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
 1390                   Unimplemented();                                                    \
 1391                 _masm.
 1392 #define ___stop if (UsePower6SchedulerPPC64)                                          \
 1393                   Unimplemented()
 1394 #define ___advance if (UsePower6SchedulerPPC64)                                       \
 1395                   Unimplemented()
 1396 #endif
 1397 
 1398 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1399   Compile* C = ra_-&gt;C;
 1400   C2_MacroAssembler _masm(&amp;cbuf);
 1401 
 1402   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();
 1403   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1404 
 1405   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1406 
 1407   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1408   const Register callers_sp           = R21;
 1409   const Register push_frame_temp      = R22;
 1410   const Register toc_temp             = R23;
 1411   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1412 
 1413   if (method_is_frameless) {
 1414     // Add nop at beginning of all frameless methods to prevent any
 1415     // oop instructions from getting overwritten by make_not_entrant
 1416     // (patching attempt would fail).
 1417     ___(nop) nop();
 1418   } else {
 1419     // Get return pc.
 1420     ___(mflr) mflr(return_pc);
 1421   }
 1422 
 1423   if (C-&gt;clinit_barrier_on_entry()) {
 1424     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 1425 
 1426     Label L_skip_barrier;
 1427     Register klass = toc_temp;
 1428 
 1429     // Notify OOP recorder (don&#39;t need the relocation)
 1430     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1431     __ load_const_optimized(klass, md.value(), R0);
 1432     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
 1433 
 1434     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
 1435     __ mtctr(klass);
 1436     __ bctr();
 1437 
 1438     __ bind(L_skip_barrier);
 1439   }
 1440 
 1441   // Calls to C2R adapters often do not accept exceptional returns.
 1442   // We require that their callers must bang for them. But be
 1443   // careful, because some VM calls (such as call site linkage) can
 1444   // use several kilobytes of stack. But the stack safety zone should
 1445   // account for that. See bugs 4446381, 4468289, 4497237.
 1446 
 1447   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
 1448   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
 1449   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
 1450     // Unfortunately we cannot use the function provided in
 1451     // assembler.cpp as we have to emulate the pipes. So I had to
 1452     // insert the code of generate_stack_overflow_check(), see
 1453     // assembler.cpp for some illuminative comments.
 1454     const int page_size = os::vm_page_size();
 1455     int bang_end = JavaThread::stack_shadow_zone_size();
 1456 
 1457     // This is how far the previous frame&#39;s stack banging extended.
 1458     const int bang_end_safe = bang_end;
 1459 
 1460     if (bangsize &gt; page_size) {
 1461       bang_end += bangsize;
 1462     }
 1463 
 1464     int bang_offset = bang_end_safe;
 1465 
 1466     while (bang_offset &lt;= bang_end) {
 1467       // Need at least one stack bang at end of shadow zone.
 1468 
 1469       // Again I had to copy code, this time from assembler_ppc.cpp,
 1470       // bang_stack_with_offset - see there for comments.
 1471 
 1472       // Stack grows down, caller passes positive offset.
 1473       assert(bang_offset &gt; 0, &quot;must bang with positive offset&quot;);
 1474 
 1475       long stdoffset = -bang_offset;
 1476 
 1477       if (Assembler::is_simm(stdoffset, 16)) {
 1478         // Signed 16 bit offset, a simple std is ok.
 1479         if (UseLoadInstructionsForStackBangingPPC64) {
 1480           ___(ld) ld(R0,  (int)(signed short)stdoffset, R1_SP);
 1481         } else {
 1482           ___(std) std(R0, (int)(signed short)stdoffset, R1_SP);
 1483         }
 1484       } else if (Assembler::is_simm(stdoffset, 31)) {
 1485         // Use largeoffset calculations for addis &amp; ld/std.
 1486         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
 1487         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
 1488 
 1489         Register tmp = R11;
 1490         ___(addis) addis(tmp, R1_SP, hi);
 1491         if (UseLoadInstructionsForStackBangingPPC64) {
 1492           ___(ld) ld(R0, lo, tmp);
 1493         } else {
 1494           ___(std) std(R0, lo, tmp);
 1495         }
 1496       } else {
 1497         ShouldNotReachHere();
 1498       }
 1499 
 1500       bang_offset += page_size;
 1501     }
 1502     // R11 trashed
 1503   } // C-&gt;output()-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging
 1504 
 1505   unsigned int bytes = (unsigned int)framesize;
 1506   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
 1507   ciMethod *currMethod = C-&gt;method();
 1508 
 1509   // Optimized version for most common case.
 1510   if (UsePower6SchedulerPPC64 &amp;&amp;
 1511       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
 1512       !(false /* ConstantsALot TODO: PPC port*/)) {
 1513     ___(or) mr(callers_sp, R1_SP);
 1514     ___(std) std(return_pc, _abi(lr), R1_SP);
 1515     ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1516     return;
 1517   }
 1518 
 1519   if (!method_is_frameless) {
 1520     // Get callers sp.
 1521     ___(or) mr(callers_sp, R1_SP);
 1522 
 1523     // Push method&#39;s frame, modifies SP.
 1524     assert(Assembler::is_uimm(framesize, 32U), &quot;wrong type&quot;);
 1525     // The ABI is already accounted for in &#39;framesize&#39; via the
 1526     // &#39;out_preserve&#39; area.
 1527     Register tmp = push_frame_temp;
 1528     // Had to insert code of push_frame((unsigned int)framesize, push_frame_temp).
 1529     if (Assembler::is_simm(-offset, 16)) {
 1530       ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1531     } else {
 1532       long x = -offset;
 1533       // Had to insert load_const(tmp, -offset).
 1534       ___(addis)  lis( tmp, (int)((signed short)(((x &gt;&gt; 32) &amp; 0xffff0000) &gt;&gt; 16)));
 1535       ___(ori)    ori( tmp, tmp, ((x &gt;&gt; 32) &amp; 0x0000ffff));
 1536       ___(rldicr) sldi(tmp, tmp, 32);
 1537       ___(oris)   oris(tmp, tmp, (x &amp; 0xffff0000) &gt;&gt; 16);
 1538       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
 1539 
 1540       ___(stdux) stdux(R1_SP, R1_SP, tmp);
 1541     }
 1542   }
 1543 #if 0 // TODO: PPC port
 1544   // For testing large constant pools, emit a lot of constants to constant pool.
 1545   // &quot;Randomize&quot; const_size.
 1546   if (ConstantsALot) {
 1547     const int num_consts = const_size();
 1548     for (int i = 0; i &lt; num_consts; i++) {
 1549       __ long_constant(0xB0B5B00BBABE);
 1550     }
 1551   }
 1552 #endif
 1553   if (!method_is_frameless) {
 1554     // Save return pc.
 1555     ___(std) std(return_pc, _abi(lr), callers_sp);
 1556   }
 1557 
 1558   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
 1559 }
 1560 #undef ___
 1561 #undef ___stop
 1562 #undef ___advance
 1563 
 1564 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1565   // Variable size. determine dynamically.
 1566   return MachNode::size(ra_);
 1567 }
 1568 
 1569 int MachPrologNode::reloc() const {
 1570   // Return number of relocatable values contained in this instruction.
 1571   return 1; // 1 reloc entry for load_const(toc).
 1572 }
 1573 
 1574 //=============================================================================
 1575 
 1576 #ifndef PRODUCT
 1577 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1578   Compile* C = ra_-&gt;C;
 1579 
 1580   st-&gt;print(&quot;EPILOG\n\t&quot;);
 1581   st-&gt;print(&quot;restore return pc\n\t&quot;);
 1582   st-&gt;print(&quot;pop frame\n\t&quot;);
 1583 
 1584   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1585     st-&gt;print(&quot;touch polling page\n\t&quot;);
 1586   }
 1587 }
 1588 #endif
 1589 
 1590 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1591   Compile* C = ra_-&gt;C;
 1592   C2_MacroAssembler _masm(&amp;cbuf);
 1593 
 1594   const long framesize = ((long)C-&gt;output()-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;
 1595   assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
 1596 
 1597   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
 1598   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1599   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
 1600   const Register polling_page     = R12;
 1601 
 1602   if (!method_is_frameless) {
 1603     // Restore return pc relative to callers&#39; sp.
 1604     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
 1605   }
 1606 
 1607   if (method_needs_polling) {
 1608     __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);
 1609   }
 1610 
 1611   if (!method_is_frameless) {
 1612     // Move return pc to LR.
 1613     __ mtlr(return_pc);
 1614     // Pop frame (fixed frame-size).
 1615     __ addi(R1_SP, R1_SP, (int)framesize);
 1616   }
 1617 
 1618   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1619     __ reserved_stack_check(return_pc);
 1620   }
 1621 
 1622   if (method_needs_polling) {
 1623     // We need to mark the code position where the load from the safepoint
 1624     // polling page was emitted as relocInfo::poll_return_type here.
 1625     __ relocate(relocInfo::poll_return_type);
 1626     __ load_from_polling_page(polling_page);
 1627   }
 1628 }
 1629 
 1630 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1631   // Variable size. Determine dynamically.
 1632   return MachNode::size(ra_);
 1633 }
 1634 
 1635 int MachEpilogNode::reloc() const {
 1636   // Return number of relocatable values contained in this instruction.
 1637   return 1; // 1 for load_from_polling_page.
 1638 }
 1639 
 1640 const Pipeline * MachEpilogNode::pipeline() const {
 1641   return MachNode::pipeline_class();
 1642 }
 1643 
 1644 #if 0 // TODO: PPC port
 1645 void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1646   C2_MacroAssembler _masm(&amp;cbuf);
 1647   if (LoadPollAddressFromThread) {
 1648     _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
 1649   } else {
 1650     _masm.nop();
 1651   }
 1652 }
 1653 
 1654 uint MachLoadPollAddrLateNode::size(PhaseRegAlloc* ra_) const {
 1655   if (LoadPollAddressFromThread) {
 1656     return 4;
 1657   } else {
 1658     return 4;
 1659   }
 1660 }
 1661 
 1662 #ifndef PRODUCT
 1663 void MachLoadPollAddrLateNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1664   st-&gt;print_cr(&quot; LD R11, PollAddressOffset, R16_thread \t// LoadPollAddressFromThread&quot;);
 1665 }
 1666 #endif
 1667 
 1668 const RegMask &amp;MachLoadPollAddrLateNode::out_RegMask() const {
 1669   return RSCRATCH1_BITS64_REG_mask();
 1670 }
 1671 #endif // PPC port
 1672 
 1673 // =============================================================================
 1674 
 1675 // Figure out which register class each belongs in: rc_int, rc_float, rc_vs or
 1676 // rc_stack.
 1677 enum RC { rc_bad, rc_int, rc_float, rc_vs, rc_stack };
 1678 
 1679 static enum RC rc_class(OptoReg::Name reg) {
 1680   // Return the register class for the given register. The given register
 1681   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
 1682   // enumeration in adGlobals_ppc.hpp.
 1683 
 1684   if (reg == OptoReg::Bad) return rc_bad;
 1685 
 1686   // We have 64 integer register halves, starting at index 0.
 1687   if (reg &lt; 64) return rc_int;
 1688 
 1689   // We have 64 floating-point register halves, starting at index 64.
 1690   if (reg &lt; 64+64) return rc_float;
 1691 
 1692   // We have 64 vector-scalar registers, starting at index 128.
 1693   if (reg &lt; 64+64+64) return rc_vs;
 1694 
 1695   // Between float regs &amp; stack are the flags regs.
 1696   assert(OptoReg::is_stack(reg) || reg &lt; 64+64+64, &quot;blow up if spilling flags&quot;);
 1697 
 1698   return rc_stack;
 1699 }
 1700 
 1701 static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,
 1702                         bool do_print, Compile* C, outputStream *st) {
 1703 
 1704   assert(opcode == Assembler::LD_OPCODE   ||
 1705          opcode == Assembler::STD_OPCODE  ||
 1706          opcode == Assembler::LWZ_OPCODE  ||
 1707          opcode == Assembler::STW_OPCODE  ||
 1708          opcode == Assembler::LFD_OPCODE  ||
 1709          opcode == Assembler::STFD_OPCODE ||
 1710          opcode == Assembler::LFS_OPCODE  ||
 1711          opcode == Assembler::STFS_OPCODE,
 1712          &quot;opcode not supported&quot;);
 1713 
 1714   if (cbuf) {
 1715     int d =
 1716       (Assembler::LD_OPCODE == opcode || Assembler::STD_OPCODE == opcode) ?
 1717         Assembler::ds(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/)
 1718       : Assembler::d1(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/); // Makes no difference in opt build.
 1719     emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));
 1720   }
 1721 #ifndef PRODUCT
 1722   else if (do_print) {
 1723     st-&gt;print(&quot;%-7s %s, [R1_SP + #%d+%d] \t// spill copy&quot;,
 1724               op_str,
 1725               Matcher::regName[reg],
 1726               offset, 0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/);
 1727   }
 1728 #endif
 1729   return 4; // size
 1730 }
 1731 
 1732 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
 1733   Compile* C = ra_-&gt;C;
 1734 
 1735   // Get registers to move.
 1736   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1737   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1738   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1739   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1740 
 1741   enum RC src_hi_rc = rc_class(src_hi);
 1742   enum RC src_lo_rc = rc_class(src_lo);
 1743   enum RC dst_hi_rc = rc_class(dst_hi);
 1744   enum RC dst_lo_rc = rc_class(dst_lo);
 1745 
 1746   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1747   if (src_hi != OptoReg::Bad)
 1748     assert((src_lo&amp;1)==0 &amp;&amp; src_lo+1==src_hi &amp;&amp;
 1749            (dst_lo&amp;1)==0 &amp;&amp; dst_lo+1==dst_hi,
 1750            &quot;expected aligned-adjacent pairs&quot;);
 1751   // Generate spill code!
 1752   int size = 0;
 1753 
 1754   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1755     return size;            // Self copy, no move.
 1756 
 1757   if (bottom_type()-&gt;isa_vect() != NULL &amp;&amp; ideal_reg() == Op_VecX) {
 1758     // Memory-&gt;Memory Spill.
 1759     if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1760       int src_offset = ra_-&gt;reg2offset(src_lo);
 1761       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1762       if (cbuf) {
 1763         C2_MacroAssembler _masm(cbuf);
 1764         __ ld(R0, src_offset, R1_SP);
 1765         __ std(R0, dst_offset, R1_SP);
 1766         __ ld(R0, src_offset+8, R1_SP);
 1767         __ std(R0, dst_offset+8, R1_SP);
 1768       }
 1769       size += 16;
 1770     }
 1771     // VectorSRegister-&gt;Memory Spill.
 1772     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_stack) {
 1773       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1774       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1775       if (cbuf) {
 1776         C2_MacroAssembler _masm(cbuf);
 1777         __ addi(R0, R1_SP, dst_offset);
 1778         __ stxvd2x(Rsrc, R0);
 1779       }
 1780       size += 8;
 1781     }
 1782     // Memory-&gt;VectorSRegister Spill.
 1783     else if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_vs) {
 1784       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1785       int src_offset = ra_-&gt;reg2offset(src_lo);
 1786       if (cbuf) {
 1787         C2_MacroAssembler _masm(cbuf);
 1788         __ addi(R0, R1_SP, src_offset);
 1789         __ lxvd2x(Rdst, R0);
 1790       }
 1791       size += 8;
 1792     }
 1793     // VectorSRegister-&gt;VectorSRegister.
 1794     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_vs) {
 1795       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1796       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1797       if (cbuf) {
 1798         C2_MacroAssembler _masm(cbuf);
 1799         __ xxlor(Rdst, Rsrc, Rsrc);
 1800       }
 1801       size += 4;
 1802     }
 1803     else {
 1804       ShouldNotReachHere(); // No VSR spill.
 1805     }
 1806     return size;
 1807   }
 1808 
 1809   // --------------------------------------
 1810   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1811   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1812     int src_offset = ra_-&gt;reg2offset(src_lo);
 1813     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1814     if (src_hi != OptoReg::Bad) {
 1815       assert(src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack,
 1816              &quot;expected same type of move for high parts&quot;);
 1817       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);
 1818       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1819       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1820     } else {
 1821       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);
 1822       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1823       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1824     }
 1825     return size;
 1826   }
 1827 
 1828   // --------------------------------------
 1829   // Check for float-&gt;int copy; requires a trip through memory.
 1830   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1831     Unimplemented();
 1832   }
 1833 
 1834   // --------------------------------------
 1835   // Check for integer reg-reg copy.
 1836   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1837       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1838       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1839       size = (Rsrc != Rdst) ? 4 : 0;
 1840 
 1841       if (cbuf) {
 1842         C2_MacroAssembler _masm(cbuf);
 1843         if (size) {
 1844           __ mr(Rdst, Rsrc);
 1845         }
 1846       }
 1847 #ifndef PRODUCT
 1848       else if (!do_size) {
 1849         if (size) {
 1850           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1851         } else {
 1852           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR-NOP&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1853         }
 1854       }
 1855 #endif
 1856       return size;
 1857   }
 1858 
 1859   // Check for integer store.
 1860   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1861     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1862     if (src_hi != OptoReg::Bad) {
 1863       assert(src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack,
 1864              &quot;expected same type of move for high parts&quot;);
 1865       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1866     } else {
 1867       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1868     }
 1869     return size;
 1870   }
 1871 
 1872   // Check for integer load.
 1873   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1874     int src_offset = ra_-&gt;reg2offset(src_lo);
 1875     if (src_hi != OptoReg::Bad) {
 1876       assert(dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack,
 1877              &quot;expected same type of move for high parts&quot;);
 1878       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1879     } else {
 1880       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1881     }
 1882     return size;
 1883   }
 1884 
 1885   // Check for float reg-reg copy.
 1886   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1887     if (cbuf) {
 1888       C2_MacroAssembler _masm(cbuf);
 1889       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1890       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1891       __ fmr(Rdst, Rsrc);
 1892     }
 1893 #ifndef PRODUCT
 1894     else if (!do_size) {
 1895       st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;FMR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1896     }
 1897 #endif
 1898     return 4;
 1899   }
 1900 
 1901   // Check for float store.
 1902   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1903     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1904     if (src_hi != OptoReg::Bad) {
 1905       assert(src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack,
 1906              &quot;expected same type of move for high parts&quot;);
 1907       size += ld_st_helper(cbuf, &quot;STFD&quot;, Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1908     } else {
 1909       size += ld_st_helper(cbuf, &quot;STFS&quot;, Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1910     }
 1911     return size;
 1912   }
 1913 
 1914   // Check for float load.
 1915   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1916     int src_offset = ra_-&gt;reg2offset(src_lo);
 1917     if (src_hi != OptoReg::Bad) {
 1918       assert(dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack,
 1919              &quot;expected same type of move for high parts&quot;);
 1920       size += ld_st_helper(cbuf, &quot;LFD &quot;, Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1921     } else {
 1922       size += ld_st_helper(cbuf, &quot;LFS &quot;, Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1923     }
 1924     return size;
 1925   }
 1926 
 1927   // --------------------------------------------------------------------
 1928   // Check for hi bits still needing moving. Only happens for misaligned
 1929   // arguments to native calls.
 1930   if (src_hi == dst_hi)
 1931     return size;               // Self copy; no move.
 1932 
 1933   assert(src_hi_rc != rc_bad &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1934   ShouldNotReachHere(); // Unimplemented
 1935   return 0;
 1936 }
 1937 
 1938 #ifndef PRODUCT
 1939 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1940   if (!ra_)
 1941     st-&gt;print(&quot;N%d = SpillCopy(N%d)&quot;, _idx, in(1)-&gt;_idx);
 1942   else
 1943     implementation(NULL, ra_, false, st);
 1944 }
 1945 #endif
 1946 
 1947 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1948   implementation(&amp;cbuf, ra_, false, NULL);
 1949 }
 1950 
 1951 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1952   return implementation(NULL, ra_, true, NULL);
 1953 }
 1954 
 1955 #if 0 // TODO: PPC port
 1956 ArchOpcode MachSpillCopyNode_archOpcode(MachSpillCopyNode *n, PhaseRegAlloc *ra_) {
 1957 #ifndef PRODUCT
 1958   if (ra_-&gt;node_regs_max_index() == 0) return archOpcode_undefined;
 1959 #endif
 1960   assert(ra_-&gt;node_regs_max_index() != 0, &quot;&quot;);
 1961 
 1962   // Get registers to move.
 1963   OptoReg::Name src_hi = ra_-&gt;get_reg_second(n-&gt;in(1));
 1964   OptoReg::Name src_lo = ra_-&gt;get_reg_first(n-&gt;in(1));
 1965   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(n);
 1966   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(n);
 1967 
 1968   enum RC src_lo_rc = rc_class(src_lo);
 1969   enum RC dst_lo_rc = rc_class(dst_lo);
 1970 
 1971   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1972     return ppc64Opcode_none;            // Self copy, no move.
 1973 
 1974   // --------------------------------------
 1975   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1976   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1977     return ppc64Opcode_compound;
 1978   }
 1979 
 1980   // --------------------------------------
 1981   // Check for float-&gt;int copy; requires a trip through memory.
 1982   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1983     Unimplemented();
 1984   }
 1985 
 1986   // --------------------------------------
 1987   // Check for integer reg-reg copy.
 1988   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1989     Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1990     Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1991     if (Rsrc == Rdst) {
 1992       return ppc64Opcode_none;
 1993     } else {
 1994       return ppc64Opcode_or;
 1995     }
 1996   }
 1997 
 1998   // Check for integer store.
 1999   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 2000     if (src_hi != OptoReg::Bad) {
 2001       return ppc64Opcode_std;
 2002     } else {
 2003       return ppc64Opcode_stw;
 2004     }
 2005   }
 2006 
 2007   // Check for integer load.
 2008   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 2009     if (src_hi != OptoReg::Bad) {
 2010       return ppc64Opcode_ld;
 2011     } else {
 2012       return ppc64Opcode_lwz;
 2013     }
 2014   }
 2015 
 2016   // Check for float reg-reg copy.
 2017   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 2018     return ppc64Opcode_fmr;
 2019   }
 2020 
 2021   // Check for float store.
 2022   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 2023     if (src_hi != OptoReg::Bad) {
 2024       return ppc64Opcode_stfd;
 2025     } else {
 2026       return ppc64Opcode_stfs;
 2027     }
 2028   }
 2029 
 2030   // Check for float load.
 2031   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 2032     if (src_hi != OptoReg::Bad) {
 2033       return ppc64Opcode_lfd;
 2034     } else {
 2035       return ppc64Opcode_lfs;
 2036     }
 2037   }
 2038 
 2039   // --------------------------------------------------------------------
 2040   // Check for hi bits still needing moving. Only happens for misaligned
 2041   // arguments to native calls.
 2042   if (src_hi == dst_hi) {
 2043     return ppc64Opcode_none;               // Self copy; no move.
 2044   }
 2045 
 2046   ShouldNotReachHere();
 2047   return ppc64Opcode_undefined;
 2048 }
 2049 #endif // PPC port
 2050 
 2051 #ifndef PRODUCT
 2052 void MachNopNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2053   st-&gt;print(&quot;NOP \t// %d nops to pad for loops.&quot;, _count);
 2054 }
 2055 #endif
 2056 
 2057 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
 2058   C2_MacroAssembler _masm(&amp;cbuf);
 2059   // _count contains the number of nops needed for padding.
 2060   for (int i = 0; i &lt; _count; i++) {
 2061     __ nop();
 2062   }
 2063 }
 2064 
 2065 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 2066   return _count * 4;
 2067 }
 2068 
 2069 #ifndef PRODUCT
 2070 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2071   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2072   char reg_str[128];
 2073   ra_-&gt;dump_register(this, reg_str);
 2074   st-&gt;print(&quot;ADDI    %s, SP, %d \t// box node&quot;, reg_str, offset);
 2075 }
 2076 #endif
 2077 
 2078 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2079   C2_MacroAssembler _masm(&amp;cbuf);
 2080 
 2081   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2082   int reg    = ra_-&gt;get_encode(this);
 2083 
 2084   if (Assembler::is_simm(offset, 16)) {
 2085     __ addi(as_Register(reg), R1, offset);
 2086   } else {
 2087     ShouldNotReachHere();
 2088   }
 2089 }
 2090 
 2091 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 2092   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 2093   return 4;
 2094 }
 2095 
 2096 #ifndef PRODUCT
 2097 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2098   st-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 2099   st-&gt;print_cr(&quot;...&quot;);
 2100 }
 2101 #endif
 2102 
 2103 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2104   // This is the unverified entry point.
 2105   C2_MacroAssembler _masm(&amp;cbuf);
 2106 
 2107   // Inline_cache contains a klass.
 2108   Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
 2109   Register receiver_klass = R12_scratch2;  // tmp
 2110 
 2111   assert_different_registers(ic_klass, receiver_klass, R11_scratch1, R3_ARG1);
 2112   assert(R11_scratch1 == R11, &quot;need prologue scratch register&quot;);
 2113 
 2114   // Check for NULL argument if we don&#39;t have implicit null checks.
 2115   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
 2116     if (TrapBasedNullChecks) {
 2117       __ trap_null_check(R3_ARG1);
 2118     } else {
 2119       Label valid;
 2120       __ cmpdi(CCR0, R3_ARG1, 0);
 2121       __ bne_predict_taken(CCR0, valid);
 2122       // We have a null argument, branch to ic_miss_stub.
 2123       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2124                            relocInfo::runtime_call_type);
 2125       __ bind(valid);
 2126     }
 2127   }
 2128   // Assume argument is not NULL, load klass from receiver.
 2129   __ load_klass(receiver_klass, R3_ARG1);
 2130 
 2131   if (TrapBasedICMissChecks) {
 2132     __ trap_ic_miss_check(receiver_klass, ic_klass);
 2133   } else {
 2134     Label valid;
 2135     __ cmpd(CCR0, receiver_klass, ic_klass);
 2136     __ beq_predict_taken(CCR0, valid);
 2137     // We have an unexpected klass, branch to ic_miss_stub.
 2138     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2139                          relocInfo::runtime_call_type);
 2140     __ bind(valid);
 2141   }
 2142 
 2143   // Argument is valid and klass is as expected, continue.
 2144 }
 2145 
 2146 #if 0 // TODO: PPC port
 2147 // Optimize UEP code on z (save a load_const() call in main path).
 2148 int MachUEPNode::ep_offset() {
 2149   return 0;
 2150 }
 2151 #endif
 2152 
 2153 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 2154   // Variable size. Determine dynamically.
 2155   return MachNode::size(ra_);
 2156 }
 2157 
 2158 //=============================================================================
 2159 
 2160 %} // interrupt source
 2161 
 2162 source_hpp %{ // Header information of the source block.
 2163 
 2164 class HandlerImpl {
 2165 
 2166  public:
 2167 
 2168   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 2169   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 2170 
 2171   static uint size_exception_handler() {
 2172     // The exception_handler is a b64_patchable.
 2173     return MacroAssembler::b64_patchable_size;
 2174   }
 2175 
 2176   static uint size_deopt_handler() {
 2177     // The deopt_handler is a bl64_patchable.
 2178     return MacroAssembler::bl64_patchable_size;
 2179   }
 2180 
 2181 };
 2182 
 2183 class Node::PD {
 2184 public:
 2185   enum NodeFlags {
 2186     _last_flag = Node::_last_flag
 2187   };
 2188 };
 2189 
 2190 %} // end source_hpp
 2191 
 2192 source %{
 2193 
 2194 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 2195   C2_MacroAssembler _masm(&amp;cbuf);
 2196 
 2197   address base = __ start_a_stub(size_exception_handler());
 2198   if (base == NULL) return 0; // CodeBuffer::expand failed
 2199 
 2200   int offset = __ offset();
 2201   __ b64_patchable((address)OptoRuntime::exception_blob()-&gt;content_begin(),
 2202                        relocInfo::runtime_call_type);
 2203   assert(__ offset() - offset == (int)size_exception_handler(), &quot;must be fixed size&quot;);
 2204   __ end_a_stub();
 2205 
 2206   return offset;
 2207 }
 2208 
 2209 // The deopt_handler is like the exception handler, but it calls to
 2210 // the deoptimization blob instead of jumping to the exception blob.
 2211 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 2212   C2_MacroAssembler _masm(&amp;cbuf);
 2213 
 2214   address base = __ start_a_stub(size_deopt_handler());
 2215   if (base == NULL) return 0; // CodeBuffer::expand failed
 2216 
 2217   int offset = __ offset();
 2218   __ bl64_patchable((address)SharedRuntime::deopt_blob()-&gt;unpack(),
 2219                         relocInfo::runtime_call_type);
 2220   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 2221   __ end_a_stub();
 2222 
 2223   return offset;
 2224 }
 2225 
 2226 //=============================================================================
 2227 
 2228 // Use a frame slots bias for frameless methods if accessing the stack.
 2229 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
 2230   if (as_Register(reg_enc) == R1_SP) {
 2231     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
 2232   }
 2233   return 0;
 2234 }
 2235 
 2236 const bool Matcher::match_rule_supported(int opcode) {
 2237   if (!has_match_rule(opcode))
 2238     return false;
 2239 
 2240   bool ret_value = true;
 2241   switch (opcode) {
 2242   case Op_SqrtD:
 2243     return VM_Version::has_fsqrt();
 2244   case Op_CountLeadingZerosI:
 2245   case Op_CountLeadingZerosL:
 2246     if (!UseCountLeadingZerosInstructionsPPC64)
 2247       return false;
 2248     break;
 2249   case Op_CountTrailingZerosI:
 2250   case Op_CountTrailingZerosL:
 2251     if (!UseCountLeadingZerosInstructionsPPC64 &amp;&amp;
 2252         !UseCountTrailingZerosInstructionsPPC64)
 2253       return false;
 2254     break;
 2255 
 2256   case Op_PopCountI:
 2257   case Op_PopCountL:
 2258     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
 2259 
 2260   case Op_StrComp:
 2261     return SpecialStringCompareTo;
 2262   case Op_StrEquals:
 2263     return SpecialStringEquals;
 2264   case Op_StrIndexOf:
 2265   case Op_StrIndexOfChar:
 2266     return SpecialStringIndexOf;
 2267   case Op_AddVB:
 2268   case Op_AddVS:
 2269   case Op_AddVI:
 2270   case Op_AddVF:
 2271   case Op_AddVD:
 2272   case Op_SubVB:
 2273   case Op_SubVS:
 2274   case Op_SubVI:
 2275   case Op_SubVF:
 2276   case Op_SubVD:
 2277   case Op_MulVS:
 2278   case Op_MulVF:
 2279   case Op_MulVD:
 2280   case Op_DivVF:
 2281   case Op_DivVD:
 2282   case Op_AbsVF:
 2283   case Op_AbsVD:
 2284   case Op_NegVF:
 2285   case Op_NegVD:
 2286   case Op_SqrtVF:
 2287   case Op_SqrtVD:
 2288   case Op_AddVL:
 2289   case Op_SubVL:
 2290   case Op_MulVI:
 2291   case Op_RoundDoubleModeV:
 2292     return SuperwordUseVSX;
 2293   case Op_PopCountVI:
 2294     return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
 2295   case Op_FmaVF:
 2296   case Op_FmaVD:
 2297     return (SuperwordUseVSX &amp;&amp; UseFMA);
 2298   case Op_Digit:
 2299     return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isDigit);
 2300   case Op_LowerCase:
 2301     return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isLowerCase);
 2302   case Op_UpperCase:
 2303     return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isUpperCase);
 2304   case Op_Whitespace:
 2305     return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isWhitespace);
 2306 
 2307   case Op_CacheWB:
 2308   case Op_CacheWBPreSync:
 2309   case Op_CacheWBPostSync:
 2310     if (!VM_Version::supports_data_cache_line_flush()) {
 2311       ret_value = false;
 2312     }
 2313     break;
 2314   }
 2315 
 2316   return ret_value;  // Per default match rules are supported.
 2317 }
 2318 
 2319 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 2320 
 2321   // TODO
 2322   // identify extra cases that we might want to provide match rules for
 2323   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2324   bool ret_value = match_rule_supported(opcode);
 2325   // Add rules here.
 2326 
 2327   return ret_value;  // Per default match rules are supported.
 2328 }
 2329 
 2330 const bool Matcher::has_predicated_vectors(void) {
 2331   return false;
 2332 }
 2333 
 2334 const int Matcher::float_pressure(int default_pressure_threshold) {
 2335   return default_pressure_threshold;
 2336 }
 2337 
 2338 int Matcher::regnum_to_fpu_offset(int regnum) {
 2339   // No user for this method?
 2340   Unimplemented();
 2341   return 999;
 2342 }
 2343 
 2344 const bool Matcher::convL2FSupported(void) {
 2345   // fcfids can do the conversion (&gt;= Power7).
 2346   // fcfid + frsp showed rounding problem when result should be 0x3f800001.
 2347   return VM_Version::has_fcfids(); // False means that conversion is done by runtime call.
 2348 }
 2349 
 2350 // Vector width in bytes.
 2351 const int Matcher::vector_width_in_bytes(BasicType bt) {
 2352   if (SuperwordUseVSX) {
 2353     assert(MaxVectorSize == 16, &quot;&quot;);
 2354     return 16;
 2355   } else {
 2356     assert(MaxVectorSize == 8, &quot;&quot;);
 2357     return 8;
 2358   }
 2359 }
 2360 
 2361 // Vector ideal reg.
 2362 const uint Matcher::vector_ideal_reg(int size) {
 2363   if (SuperwordUseVSX) {
 2364     assert(MaxVectorSize == 16 &amp;&amp; size == 16, &quot;&quot;);
 2365     return Op_VecX;
 2366   } else {
 2367     assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 2368     return Op_RegL;
 2369   }
 2370 }
 2371 
 2372 // Limits on vector size (number of elements) loaded into vector.
 2373 const int Matcher::max_vector_size(const BasicType bt) {
 2374   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 2375   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 2376 }
 2377 
 2378 const int Matcher::min_vector_size(const BasicType bt) {
 2379   return max_vector_size(bt); // Same as max.
 2380 }
 2381 
 2382 // PPC implementation uses VSX load/store instructions (if
 2383 // SuperwordUseVSX) which support 4 byte but not arbitrary alignment
 2384 const bool Matcher::misaligned_vectors_ok() {
 2385   return false;
 2386 }
 2387 
 2388 // PPC AES support not yet implemented
 2389 const bool Matcher::pass_original_key_for_aes() {
 2390   return false;
 2391 }
 2392 
 2393 // RETURNS: whether this branch offset is short enough that a short
 2394 // branch can be used.
 2395 //
 2396 // If the platform does not provide any short branch variants, then
 2397 // this method should return `false&#39; for offset 0.
 2398 //
 2399 // `Compile::Fill_buffer&#39; will decide on basis of this information
 2400 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 2401 //
 2402 // And `Compile::Shorten_branches&#39; will decide on basis of this
 2403 // information whether to replace particular branch sites by short
 2404 // ones.
 2405 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 2406   // Is the offset within the range of a ppc64 pc relative branch?
 2407   bool b;
 2408 
 2409   const int safety_zone = 3 * BytesPerInstWord;
 2410   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
 2411                          29 - 16 + 1 + 2);
 2412   return b;
 2413 }
 2414 
 2415 const bool Matcher::isSimpleConstant64(jlong value) {
 2416   // Probably always true, even if a temp register is required.
 2417   return true;
 2418 }
 2419 /* TODO: PPC port
 2420 // Make a new machine dependent decode node (with its operands).
 2421 MachTypeNode *Matcher::make_decode_node() {
 2422   assert(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0,
 2423          &quot;This method is only implemented for unscaled cOops mode so far&quot;);
 2424   MachTypeNode *decode = new decodeN_unscaledNode();
 2425   decode-&gt;set_opnd_array(0, new iRegPdstOper());
 2426   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
 2427   return decode;
 2428 }
 2429 */
 2430 
 2431 // false =&gt; size gets scaled to BytesPerLong, ok.
 2432 const bool Matcher::init_array_count_is_in_bytes = false;
 2433 
 2434 // Use conditional move (CMOVL) on Power7.
 2435 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
 2436 
 2437 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
 2438 // fsel doesn&#39;t accept a condition register as input, so this would be slightly different.
 2439 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 2440 
 2441 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
 2442 const bool Matcher::require_postalloc_expand = true;
 2443 
 2444 // Do we need to mask the count passed to shift instructions or does
 2445 // the cpu only look at the lower 5/6 bits anyway?
 2446 // PowerPC requires masked shift counts.
 2447 const bool Matcher::need_masked_shift_count = true;
 2448 
 2449 // No support for generic vector operands.
 2450 const bool Matcher::supports_generic_vector_operands  = false;
 2451 
 2452 MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 2453   ShouldNotReachHere(); // generic vector operands not supported
 2454   return NULL;
 2455 }
 2456 
 2457 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 2458   ShouldNotReachHere();  // generic vector operands not supported
 2459   return false;
 2460 }
 2461 
 2462 bool Matcher::is_generic_vector(MachOper* opnd)  {
 2463   ShouldNotReachHere();  // generic vector operands not supported
 2464   return false;
 2465 }
 2466 
 2467 // This affects two different things:
 2468 //  - how Decode nodes are matched
 2469 //  - how ImplicitNullCheck opportunities are recognized
 2470 // If true, the matcher will try to remove all Decodes and match them
 2471 // (as operands) into nodes. NullChecks are not prepared to deal with
 2472 // Decodes by final_graph_reshaping().
 2473 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2474 // for a NullCheck. The matcher matches the Decode node into a register.
 2475 // Implicit_null_check optimization moves the Decode along with the
 2476 // memory operation back up before the NullCheck.
 2477 bool Matcher::narrow_oop_use_complex_address() {
 2478   // TODO: PPC port if (MatchDecodeNodes) return true;
 2479   return false;
 2480 }
 2481 
 2482 bool Matcher::narrow_klass_use_complex_address() {
 2483   NOT_LP64(ShouldNotCallThis());
 2484   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 2485   // TODO: PPC port if (MatchDecodeNodes) return true;
 2486   return false;
 2487 }
 2488 
 2489 bool Matcher::const_oop_prefer_decode() {
 2490   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 2491   return CompressedOops::base() == NULL;
 2492 }
 2493 
 2494 bool Matcher::const_klass_prefer_decode() {
 2495   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 2496   return CompressedKlassPointers::base() == NULL;
 2497 }
 2498 
 2499 // Is it better to copy float constants, or load them directly from memory?
 2500 // Intel can load a float constant from a direct address, requiring no
 2501 // extra registers. Most RISCs will have to materialize an address into a
 2502 // register first, so they would do better to copy the constant from stack.
 2503 const bool Matcher::rematerialize_float_constants = false;
 2504 
 2505 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2506 // needed. Else we split the double into 2 integer pieces and move it
 2507 // piece-by-piece. Only happens when passing doubles into C code as the
 2508 // Java calling convention forces doubles to be aligned.
 2509 const bool Matcher::misaligned_doubles_ok = true;
 2510 
 2511 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2512  Unimplemented();
 2513 }
 2514 
 2515 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 2516 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2517 
 2518 // Do floats take an entire double register or just half?
 2519 //
 2520 // A float occupies a ppc64 double register. For the allocator, a
 2521 // ppc64 double register appears as a pair of float registers.
 2522 bool Matcher::float_in_double() { return true; }
 2523 
 2524 // Do ints take an entire long register or just half?
 2525 // The relevant question is how the int is callee-saved:
 2526 // the whole long is written but de-opt&#39;ing will have to extract
 2527 // the relevant 32 bits.
 2528 const bool Matcher::int_in_long = true;
 2529 
 2530 // Constants for c2c and c calling conventions.
 2531 
 2532 const MachRegisterNumbers iarg_reg[8] = {
 2533   R3_num, R4_num, R5_num, R6_num,
 2534   R7_num, R8_num, R9_num, R10_num
 2535 };
 2536 
 2537 const MachRegisterNumbers farg_reg[13] = {
 2538   F1_num, F2_num, F3_num, F4_num,
 2539   F5_num, F6_num, F7_num, F8_num,
 2540   F9_num, F10_num, F11_num, F12_num,
 2541   F13_num
 2542 };
 2543 
 2544 const MachRegisterNumbers vsarg_reg[64] = {
 2545   VSR0_num, VSR1_num, VSR2_num, VSR3_num,
 2546   VSR4_num, VSR5_num, VSR6_num, VSR7_num,
 2547   VSR8_num, VSR9_num, VSR10_num, VSR11_num,
 2548   VSR12_num, VSR13_num, VSR14_num, VSR15_num,
 2549   VSR16_num, VSR17_num, VSR18_num, VSR19_num,
 2550   VSR20_num, VSR21_num, VSR22_num, VSR23_num,
 2551   VSR24_num, VSR23_num, VSR24_num, VSR25_num,
 2552   VSR28_num, VSR29_num, VSR30_num, VSR31_num,
 2553   VSR32_num, VSR33_num, VSR34_num, VSR35_num,
 2554   VSR36_num, VSR37_num, VSR38_num, VSR39_num,
 2555   VSR40_num, VSR41_num, VSR42_num, VSR43_num,
 2556   VSR44_num, VSR45_num, VSR46_num, VSR47_num,
 2557   VSR48_num, VSR49_num, VSR50_num, VSR51_num,
 2558   VSR52_num, VSR53_num, VSR54_num, VSR55_num,
 2559   VSR56_num, VSR57_num, VSR58_num, VSR59_num,
 2560   VSR60_num, VSR61_num, VSR62_num, VSR63_num
 2561 };
 2562 
 2563 const int num_iarg_registers = sizeof(iarg_reg) / sizeof(iarg_reg[0]);
 2564 
 2565 const int num_farg_registers = sizeof(farg_reg) / sizeof(farg_reg[0]);
 2566 
 2567 const int num_vsarg_registers = sizeof(vsarg_reg) / sizeof(vsarg_reg[0]);
 2568 
 2569 // Return whether or not this register is ever used as an argument. This
 2570 // function is used on startup to build the trampoline stubs in generateOptoStub.
 2571 // Registers not mentioned will be killed by the VM call in the trampoline, and
 2572 // arguments in those registers not be available to the callee.
 2573 bool Matcher::can_be_java_arg(int reg) {
 2574   // We return true for all registers contained in iarg_reg[] and
 2575   // farg_reg[] and their virtual halves.
 2576   // We must include the virtual halves in order to get STDs and LDs
 2577   // instead of STWs and LWs in the trampoline stubs.
 2578 
 2579   if (   reg == R3_num  || reg == R3_H_num
 2580       || reg == R4_num  || reg == R4_H_num
 2581       || reg == R5_num  || reg == R5_H_num
 2582       || reg == R6_num  || reg == R6_H_num
 2583       || reg == R7_num  || reg == R7_H_num
 2584       || reg == R8_num  || reg == R8_H_num
 2585       || reg == R9_num  || reg == R9_H_num
 2586       || reg == R10_num || reg == R10_H_num)
 2587     return true;
 2588 
 2589   if (   reg == F1_num  || reg == F1_H_num
 2590       || reg == F2_num  || reg == F2_H_num
 2591       || reg == F3_num  || reg == F3_H_num
 2592       || reg == F4_num  || reg == F4_H_num
 2593       || reg == F5_num  || reg == F5_H_num
 2594       || reg == F6_num  || reg == F6_H_num
 2595       || reg == F7_num  || reg == F7_H_num
 2596       || reg == F8_num  || reg == F8_H_num
 2597       || reg == F9_num  || reg == F9_H_num
 2598       || reg == F10_num || reg == F10_H_num
 2599       || reg == F11_num || reg == F11_H_num
 2600       || reg == F12_num || reg == F12_H_num
 2601       || reg == F13_num || reg == F13_H_num)
 2602     return true;
 2603 
 2604   return false;
 2605 }
 2606 
 2607 bool Matcher::is_spillable_arg(int reg) {
 2608   return can_be_java_arg(reg);
 2609 }
 2610 
 2611 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 2612   return false;
 2613 }
 2614 
 2615 // Register for DIVI projection of divmodI.
 2616 RegMask Matcher::divI_proj_mask() {
 2617   ShouldNotReachHere();
 2618   return RegMask();
 2619 }
 2620 
 2621 // Register for MODI projection of divmodI.
 2622 RegMask Matcher::modI_proj_mask() {
 2623   ShouldNotReachHere();
 2624   return RegMask();
 2625 }
 2626 
 2627 // Register for DIVL projection of divmodL.
 2628 RegMask Matcher::divL_proj_mask() {
 2629   ShouldNotReachHere();
 2630   return RegMask();
 2631 }
 2632 
 2633 // Register for MODL projection of divmodL.
 2634 RegMask Matcher::modL_proj_mask() {
 2635   ShouldNotReachHere();
 2636   return RegMask();
 2637 }
 2638 
 2639 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 2640   return RegMask();
 2641 }
 2642 
 2643 const bool Matcher::convi2l_type_required = true;
 2644 
 2645 %}
 2646 
 2647 //----------ENCODING BLOCK-----------------------------------------------------
 2648 // This block specifies the encoding classes used by the compiler to output
 2649 // byte streams. Encoding classes are parameterized macros used by
 2650 // Machine Instruction Nodes in order to generate the bit encoding of the
 2651 // instruction. Operands specify their base encoding interface with the
 2652 // interface keyword. There are currently supported four interfaces,
 2653 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 2654 // operand to generate a function which returns its register number when
 2655 // queried. CONST_INTER causes an operand to generate a function which
 2656 // returns the value of the constant when queried. MEMORY_INTER causes an
 2657 // operand to generate four functions which return the Base Register, the
 2658 // Index Register, the Scale Value, and the Offset Value of the operand when
 2659 // queried. COND_INTER causes an operand to generate six functions which
 2660 // return the encoding code (ie - encoding bits for the instruction)
 2661 // associated with each basic boolean condition for a conditional instruction.
 2662 //
 2663 // Instructions specify two basic values for encoding. Again, a function
 2664 // is available to check if the constant displacement is an oop. They use the
 2665 // ins_encode keyword to specify their encoding classes (which must be
 2666 // a sequence of enc_class names, and their parameters, specified in
 2667 // the encoding block), and they use the
 2668 // opcode keyword to specify, in order, their primary, secondary, and
 2669 // tertiary opcode. Only the opcode sections which a particular instruction
 2670 // needs for encoding need to be specified.
 2671 encode %{
 2672   enc_class enc_unimplemented %{
 2673     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2674     C2_MacroAssembler _masm(&amp;cbuf);
 2675     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 2676   %}
 2677 
 2678   enc_class enc_untested %{
 2679 #ifdef ASSERT
 2680     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2681     C2_MacroAssembler _masm(&amp;cbuf);
 2682     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 2683 #else
 2684     // TODO: PPC port $archOpcode(ppc64Opcode_none);
 2685 #endif
 2686   %}
 2687 
 2688   enc_class enc_lbz(iRegIdst dst, memory mem) %{
 2689     // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
 2690     C2_MacroAssembler _masm(&amp;cbuf);
 2691     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2692     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2693   %}
 2694 
 2695   // Load acquire.
 2696   enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
 2697     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2698     C2_MacroAssembler _masm(&amp;cbuf);
 2699     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2700     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2701     __ twi_0($dst$$Register);
 2702     __ isync();
 2703   %}
 2704 
 2705   enc_class enc_lhz(iRegIdst dst, memory mem) %{
 2706     // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
 2707 
 2708     C2_MacroAssembler _masm(&amp;cbuf);
 2709     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2710     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2711   %}
 2712 
 2713   // Load acquire.
 2714   enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
 2715     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2716 
 2717     C2_MacroAssembler _masm(&amp;cbuf);
 2718     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2719     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2720     __ twi_0($dst$$Register);
 2721     __ isync();
 2722   %}
 2723 
 2724   enc_class enc_lwz(iRegIdst dst, memory mem) %{
 2725     // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
 2726 
 2727     C2_MacroAssembler _masm(&amp;cbuf);
 2728     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2729     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2730   %}
 2731 
 2732   // Load acquire.
 2733   enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
 2734     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2735 
 2736     C2_MacroAssembler _masm(&amp;cbuf);
 2737     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2738     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2739     __ twi_0($dst$$Register);
 2740     __ isync();
 2741   %}
 2742 
 2743   enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
 2744     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2745     C2_MacroAssembler _masm(&amp;cbuf);
 2746     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2747     // Operand &#39;ds&#39; requires 4-alignment.
 2748     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2749     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2750   %}
 2751 
 2752   // Load acquire.
 2753   enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
 2754     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2755     C2_MacroAssembler _masm(&amp;cbuf);
 2756     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2757     // Operand &#39;ds&#39; requires 4-alignment.
 2758     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2759     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2760     __ twi_0($dst$$Register);
 2761     __ isync();
 2762   %}
 2763 
 2764   enc_class enc_lfd(RegF dst, memory mem) %{
 2765     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 2766     C2_MacroAssembler _masm(&amp;cbuf);
 2767     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2768     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 2769   %}
 2770 
 2771   enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
 2772     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2773 
 2774     C2_MacroAssembler _masm(&amp;cbuf);
 2775     int toc_offset = 0;
 2776 
 2777     address const_toc_addr;
 2778     // Create a non-oop constant, no relocation needed.
 2779     // If it is an IC, it has a virtual_call_Relocation.
 2780     const_toc_addr = __ long_constant((jlong)$src$$constant);
 2781     if (const_toc_addr == NULL) {
 2782       ciEnv::current()-&gt;record_out_of_memory_failure();
 2783       return;
 2784     }
 2785 
 2786     // Get the constant&#39;s TOC offset.
 2787     toc_offset = __ offset_to_method_toc(const_toc_addr);
 2788 
 2789     // Keep the current instruction offset in mind.
 2790     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2791 
 2792     __ ld($dst$$Register, toc_offset, $toc$$Register);
 2793   %}
 2794 
 2795   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
 2796     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 2797 
 2798     C2_MacroAssembler _masm(&amp;cbuf);
 2799 
 2800     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {
 2801       address const_toc_addr;
 2802       // Create a non-oop constant, no relocation needed.
 2803       // If it is an IC, it has a virtual_call_Relocation.
 2804       const_toc_addr = __ long_constant((jlong)$src$$constant);
 2805       if (const_toc_addr == NULL) {
 2806         ciEnv::current()-&gt;record_out_of_memory_failure();
 2807         return;
 2808       }
 2809 
 2810       // Get the constant&#39;s TOC offset.
 2811       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 2812       // Store the toc offset of the constant.
 2813       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 2814 
 2815       // Also keep the current instruction offset in mind.
 2816       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2817     }
 2818 
 2819     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 2820   %}
 2821 
 2822 %} // encode
 2823 
 2824 source %{
 2825 
 2826 typedef struct {
 2827   loadConL_hiNode *_large_hi;
 2828   loadConL_loNode *_large_lo;
 2829   loadConLNode    *_small;
 2830   MachNode        *_last;
 2831 } loadConLNodesTuple;
 2832 
 2833 loadConLNodesTuple loadConLNodesTuple_create(PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2834                                              OptoReg::Name reg_second, OptoReg::Name reg_first) {
 2835   loadConLNodesTuple nodes;
 2836 
 2837   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2838   if (large_constant_pool) {
 2839     // Create new nodes.
 2840     loadConL_hiNode *m1 = new loadConL_hiNode();
 2841     loadConL_loNode *m2 = new loadConL_loNode();
 2842 
 2843     // inputs for new nodes
 2844     m1-&gt;add_req(NULL, toc);
 2845     m2-&gt;add_req(NULL, m1);
 2846 
 2847     // operands for new nodes
 2848     m1-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2849     m1-&gt;_opnds[1] = immSrc;             // src
 2850     m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2851     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2852     m2-&gt;_opnds[1] = immSrc;             // src
 2853     m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 2854 
 2855     // Initialize ins_attrib TOC fields.
 2856     m1-&gt;_const_toc_offset = -1;
 2857     m2-&gt;_const_toc_offset_hi_node = m1;
 2858 
 2859     // Initialize ins_attrib instruction offset.
 2860     m1-&gt;_cbuf_insts_offset = -1;
 2861 
 2862     // register allocation for new nodes
 2863     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2864     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2865 
 2866     // Create result.
 2867     nodes._large_hi = m1;
 2868     nodes._large_lo = m2;
 2869     nodes._small = NULL;
 2870     nodes._last = nodes._large_lo;
 2871     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2872   } else {
 2873     loadConLNode *m2 = new loadConLNode();
 2874 
 2875     // inputs for new nodes
 2876     m2-&gt;add_req(NULL, toc);
 2877 
 2878     // operands for new nodes
 2879     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2880     m2-&gt;_opnds[1] = immSrc;             // src
 2881     m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2882 
 2883     // Initialize ins_attrib instruction offset.
 2884     m2-&gt;_cbuf_insts_offset = -1;
 2885 
 2886     // register allocation for new nodes
 2887     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2888 
 2889     // Create result.
 2890     nodes._large_hi = NULL;
 2891     nodes._large_lo = NULL;
 2892     nodes._small = m2;
 2893     nodes._last = nodes._small;
 2894     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2895   }
 2896 
 2897   return nodes;
 2898 }
 2899 
 2900 typedef struct {
 2901   loadConL_hiNode *_large_hi;
 2902   loadConL_loNode *_large_lo;
 2903   mtvsrdNode      *_moved;
 2904   xxspltdNode     *_replicated;
 2905   loadConLNode    *_small;
 2906   MachNode        *_last;
 2907 } loadConLReplicatedNodesTuple;
 2908 
 2909 loadConLReplicatedNodesTuple loadConLReplicatedNodesTuple_create(Compile *C, PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2910                                                  vecXOper *dst, immI_0Oper *zero,
 2911                                                  OptoReg::Name reg_second, OptoReg::Name reg_first,
 2912                                                  OptoReg::Name reg_vec_second, OptoReg::Name reg_vec_first) {
 2913   loadConLReplicatedNodesTuple nodes;
 2914 
 2915   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2916   if (large_constant_pool) {
 2917     // Create new nodes.
 2918     loadConL_hiNode *m1 = new  loadConL_hiNode();
 2919     loadConL_loNode *m2 = new  loadConL_loNode();
 2920     mtvsrdNode *m3 = new  mtvsrdNode();
 2921     xxspltdNode *m4 = new  xxspltdNode();
 2922 
 2923     // inputs for new nodes
 2924     m1-&gt;add_req(NULL, toc);
 2925     m2-&gt;add_req(NULL, m1);
 2926     m3-&gt;add_req(NULL, m2);
 2927     m4-&gt;add_req(NULL, m3);
 2928 
 2929     // operands for new nodes
 2930     m1-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2931     m1-&gt;_opnds[1] = immSrc;              // src
 2932     m1-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2933 
 2934     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2935     m2-&gt;_opnds[1] = immSrc;              // src
 2936     m2-&gt;_opnds[2] = new  iRegLdstOper(); // base
 2937 
 2938     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2939     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2940 
 2941     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2942     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2943     m4-&gt;_opnds[2] = zero;
 2944 
 2945     // Initialize ins_attrib TOC fields.
 2946     m1-&gt;_const_toc_offset = -1;
 2947     m2-&gt;_const_toc_offset_hi_node = m1;
 2948 
 2949     // Initialize ins_attrib instruction offset.
 2950     m1-&gt;_cbuf_insts_offset = -1;
 2951 
 2952     // register allocation for new nodes
 2953     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2954     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2955     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2956     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2957     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2958 
 2959     // Create result.
 2960     nodes._large_hi = m1;
 2961     nodes._large_lo = m2;
 2962     nodes._moved = m3;
 2963     nodes._replicated = m4;
 2964     nodes._small = NULL;
 2965     nodes._last = nodes._replicated;
 2966     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2967   } else {
 2968     loadConLNode *m2 = new  loadConLNode();
 2969     mtvsrdNode *m3 = new  mtvsrdNode();
 2970     xxspltdNode *m4 = new  xxspltdNode();
 2971 
 2972     // inputs for new nodes
 2973     m2-&gt;add_req(NULL, toc);
 2974 
 2975     // operands for new nodes
 2976     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2977     m2-&gt;_opnds[1] = immSrc;              // src
 2978     m2-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2979 
 2980     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2981     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2982 
 2983     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2984     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2985     m4-&gt;_opnds[2] = zero;
 2986 
 2987     // Initialize ins_attrib instruction offset.
 2988     m2-&gt;_cbuf_insts_offset = -1;
 2989     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2990     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2991     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2992 
 2993     // register allocation for new nodes
 2994     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2995 
 2996     // Create result.
 2997     nodes._large_hi = NULL;
 2998     nodes._large_lo = NULL;
 2999     nodes._small = m2;
 3000     nodes._moved = m3;
 3001     nodes._replicated = m4;
 3002     nodes._last = nodes._replicated;
 3003     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3004   }
 3005 
 3006   return nodes;
 3007 }
 3008 
 3009 %} // source
 3010 
 3011 encode %{
 3012   // Postalloc expand emitter for loading a long constant from the method&#39;s TOC.
 3013   // Enc_class needed as consttanttablebase is not supported by postalloc
 3014   // expand.
 3015   enc_class postalloc_expand_load_long_constant(iRegLdst dst, immL src, iRegLdst toc) %{
 3016     // Create new nodes.
 3017     loadConLNodesTuple loadConLNodes =
 3018       loadConLNodesTuple_create(ra_, n_toc, op_src,
 3019                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3020 
 3021     // Push new nodes.
 3022     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3023     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3024 
 3025     // some asserts
 3026     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3027     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3028   %}
 3029 
 3030   enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
 3031     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3032 
 3033     C2_MacroAssembler _masm(&amp;cbuf);
 3034     int toc_offset = 0;
 3035 
 3036     intptr_t val = $src$$constant;
 3037     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3038     address const_toc_addr;
 3039     if (constant_reloc == relocInfo::oop_type) {
 3040       // Create an oop constant and a corresponding relocation.
 3041       AddressLiteral a = __ allocate_oop_address((jobject)val);
 3042       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3043       __ relocate(a.rspec());
 3044     } else if (constant_reloc == relocInfo::metadata_type) {
 3045       AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3046       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3047       __ relocate(a.rspec());
 3048     } else {
 3049       // Create a non-oop constant, no relocation needed.
 3050       const_toc_addr = __ long_constant((jlong)$src$$constant);
 3051     }
 3052 
 3053     if (const_toc_addr == NULL) {
 3054       ciEnv::current()-&gt;record_out_of_memory_failure();
 3055       return;
 3056     }
 3057     // Get the constant&#39;s TOC offset.
 3058     toc_offset = __ offset_to_method_toc(const_toc_addr);
 3059 
 3060     __ ld($dst$$Register, toc_offset, $toc$$Register);
 3061   %}
 3062 
 3063   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
 3064     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 3065 
 3066     C2_MacroAssembler _masm(&amp;cbuf);
 3067     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {
 3068       intptr_t val = $src$$constant;
 3069       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3070       address const_toc_addr;
 3071       if (constant_reloc == relocInfo::oop_type) {
 3072         // Create an oop constant and a corresponding relocation.
 3073         AddressLiteral a = __ allocate_oop_address((jobject)val);
 3074         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3075         __ relocate(a.rspec());
 3076       } else if (constant_reloc == relocInfo::metadata_type) {
 3077         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3078         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3079         __ relocate(a.rspec());
 3080       } else {  // non-oop pointers, e.g. card mark base, heap top
 3081         // Create a non-oop constant, no relocation needed.
 3082         const_toc_addr = __ long_constant((jlong)$src$$constant);
 3083       }
 3084 
 3085       if (const_toc_addr == NULL) {
 3086         ciEnv::current()-&gt;record_out_of_memory_failure();
 3087         return;
 3088       }
 3089       // Get the constant&#39;s TOC offset.
 3090       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 3091       // Store the toc offset of the constant.
 3092       ((loadConP_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 3093     }
 3094 
 3095     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 3096   %}
 3097 
 3098   // Postalloc expand emitter for loading a ptr constant from the method&#39;s TOC.
 3099   // Enc_class needed as consttanttablebase is not supported by postalloc
 3100   // expand.
 3101   enc_class postalloc_expand_load_ptr_constant(iRegPdst dst, immP src, iRegLdst toc) %{
 3102     const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3103     if (large_constant_pool) {
 3104       // Create new nodes.
 3105       loadConP_hiNode *m1 = new loadConP_hiNode();
 3106       loadConP_loNode *m2 = new loadConP_loNode();
 3107 
 3108       // inputs for new nodes
 3109       m1-&gt;add_req(NULL, n_toc);
 3110       m2-&gt;add_req(NULL, m1);
 3111 
 3112       // operands for new nodes
 3113       m1-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3114       m1-&gt;_opnds[1] = op_src;             // src
 3115       m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3116       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3117       m2-&gt;_opnds[1] = op_src;             // src
 3118       m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 3119 
 3120       // Initialize ins_attrib TOC fields.
 3121       m1-&gt;_const_toc_offset = -1;
 3122       m2-&gt;_const_toc_offset_hi_node = m1;
 3123 
 3124       // Register allocation for new nodes.
 3125       ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3126       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3127 
 3128       nodes-&gt;push(m1);
 3129       nodes-&gt;push(m2);
 3130       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3131     } else {
 3132       loadConPNode *m2 = new loadConPNode();
 3133 
 3134       // inputs for new nodes
 3135       m2-&gt;add_req(NULL, n_toc);
 3136 
 3137       // operands for new nodes
 3138       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3139       m2-&gt;_opnds[1] = op_src;             // src
 3140       m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3141 
 3142       // Register allocation for new nodes.
 3143       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3144 
 3145       nodes-&gt;push(m2);
 3146       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3147     }
 3148   %}
 3149 
 3150   // Enc_class needed as consttanttablebase is not supported by postalloc
 3151   // expand.
 3152   enc_class postalloc_expand_load_float_constant(regF dst, immF src, iRegLdst toc) %{
 3153     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3154 
 3155     MachNode *m2;
 3156     if (large_constant_pool) {
 3157       m2 = new loadConFCompNode();
 3158     } else {
 3159       m2 = new loadConFNode();
 3160     }
 3161     // inputs for new nodes
 3162     m2-&gt;add_req(NULL, n_toc);
 3163 
 3164     // operands for new nodes
 3165     m2-&gt;_opnds[0] = op_dst;
 3166     m2-&gt;_opnds[1] = op_src;
 3167     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3168 
 3169     // register allocation for new nodes
 3170     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3171     nodes-&gt;push(m2);
 3172   %}
 3173 
 3174   // Enc_class needed as consttanttablebase is not supported by postalloc
 3175   // expand.
 3176   enc_class postalloc_expand_load_double_constant(regD dst, immD src, iRegLdst toc) %{
 3177     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3178 
 3179     MachNode *m2;
 3180     if (large_constant_pool) {
 3181       m2 = new loadConDCompNode();
 3182     } else {
 3183       m2 = new loadConDNode();
 3184     }
 3185     // inputs for new nodes
 3186     m2-&gt;add_req(NULL, n_toc);
 3187 
 3188     // operands for new nodes
 3189     m2-&gt;_opnds[0] = op_dst;
 3190     m2-&gt;_opnds[1] = op_src;
 3191     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3192 
 3193     // register allocation for new nodes
 3194     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3195     nodes-&gt;push(m2);
 3196   %}
 3197 
 3198   enc_class enc_stw(iRegIsrc src, memory mem) %{
 3199     // TODO: PPC port $archOpcode(ppc64Opcode_stw);
 3200     C2_MacroAssembler _masm(&amp;cbuf);
 3201     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3202     __ stw($src$$Register, Idisp, $mem$$base$$Register);
 3203   %}
 3204 
 3205   enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
 3206     // TODO: PPC port $archOpcode(ppc64Opcode_std);
 3207     C2_MacroAssembler _masm(&amp;cbuf);
 3208     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3209     // Operand &#39;ds&#39; requires 4-alignment.
 3210     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 3211     __ std($src$$Register, Idisp, $mem$$base$$Register);
 3212   %}
 3213 
 3214   enc_class enc_stfs(RegF src, memory mem) %{
 3215     // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
 3216     C2_MacroAssembler _masm(&amp;cbuf);
 3217     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3218     __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3219   %}
 3220 
 3221   enc_class enc_stfd(RegF src, memory mem) %{
 3222     // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
 3223     C2_MacroAssembler _masm(&amp;cbuf);
 3224     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3225     __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3226   %}
 3227 
 3228   // Use release_store for card-marking to ensure that previous
 3229   // oop-stores are visible before the card-mark change.
 3230   enc_class enc_cms_card_mark(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 3231     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3232     // FIXME: Implement this as a cmove and use a fixed condition code
 3233     // register which is written on every transition to compiled code,
 3234     // e.g. in call-stub and when returning from runtime stubs.
 3235     //
 3236     // Proposed code sequence for the cmove implementation:
 3237     //
 3238     // Label skip_release;
 3239     // __ beq(CCRfixed, skip_release);
 3240     // __ release();
 3241     // __ bind(skip_release);
 3242     // __ stb(card mark);
 3243 
 3244     C2_MacroAssembler _masm(&amp;cbuf);
 3245     Label skip_storestore;
 3246 
 3247 #if 0 // TODO: PPC port
 3248     // Check CMSCollectorCardTableBarrierSetBSExt::_requires_release and do the
 3249     // StoreStore barrier conditionally.
 3250     __ lwz(R0, 0, $releaseFieldAddr$$Register);
 3251     __ cmpwi($crx$$CondRegister, R0, 0);
 3252     __ beq_predict_taken($crx$$CondRegister, skip_storestore);
 3253 #endif
 3254     __ li(R0, 0);
 3255     __ membar(Assembler::StoreStore);
 3256 #if 0 // TODO: PPC port
 3257     __ bind(skip_storestore);
 3258 #endif
 3259 
 3260     // Do the store.
 3261     if ($mem$$index == 0) {
 3262       __ stb(R0, $mem$$disp, $mem$$base$$Register);
 3263     } else {
 3264       assert(0 == $mem$$disp, &quot;no displacement possible with indexed load/stores on ppc&quot;);
 3265       __ stbx(R0, $mem$$base$$Register, $mem$$index$$Register);
 3266     }
 3267   %}
 3268 
 3269   enc_class postalloc_expand_encode_oop(iRegNdst dst, iRegPdst src, flagsReg crx) %{
 3270 
 3271     if (VM_Version::has_isel()) {
 3272       // use isel instruction with Power 7
 3273       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3274       encodeP_subNode    *n_sub_base = new encodeP_subNode();
 3275       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3276       cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();
 3277 
 3278       n_compare-&gt;add_req(n_region, n_src);
 3279       n_compare-&gt;_opnds[0] = op_crx;
 3280       n_compare-&gt;_opnds[1] = op_src;
 3281       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3282 
 3283       n_sub_base-&gt;add_req(n_region, n_src);
 3284       n_sub_base-&gt;_opnds[0] = op_dst;
 3285       n_sub_base-&gt;_opnds[1] = op_src;
 3286       n_sub_base-&gt;_bottom_type = _bottom_type;
 3287 
 3288       n_shift-&gt;add_req(n_region, n_sub_base);
 3289       n_shift-&gt;_opnds[0] = op_dst;
 3290       n_shift-&gt;_opnds[1] = op_dst;
 3291       n_shift-&gt;_bottom_type = _bottom_type;
 3292 
 3293       n_cond_set-&gt;add_req(n_region, n_compare, n_shift);
 3294       n_cond_set-&gt;_opnds[0] = op_dst;
 3295       n_cond_set-&gt;_opnds[1] = op_crx;
 3296       n_cond_set-&gt;_opnds[2] = op_dst;
 3297       n_cond_set-&gt;_bottom_type = _bottom_type;
 3298 
 3299       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3300       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3301       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3302       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3303 
 3304       nodes-&gt;push(n_compare);
 3305       nodes-&gt;push(n_sub_base);
 3306       nodes-&gt;push(n_shift);
 3307       nodes-&gt;push(n_cond_set);
 3308 
 3309     } else {
 3310       // before Power 7
 3311       moveRegNode        *n_move     = new moveRegNode();
 3312       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3313       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3314       cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();
 3315 
 3316       n_move-&gt;add_req(n_region, n_src);
 3317       n_move-&gt;_opnds[0] = op_dst;
 3318       n_move-&gt;_opnds[1] = op_src;
 3319       ra_-&gt;set_oop(n_move, true); // Until here, &#39;n_move&#39; still produces an oop.
 3320 
 3321       n_compare-&gt;add_req(n_region, n_src);
 3322       n_compare-&gt;add_prec(n_move);
 3323 
 3324       n_compare-&gt;_opnds[0] = op_crx;
 3325       n_compare-&gt;_opnds[1] = op_src;
 3326       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3327 
 3328       n_sub_base-&gt;add_req(n_region, n_compare, n_src);
 3329       n_sub_base-&gt;_opnds[0] = op_dst;
 3330       n_sub_base-&gt;_opnds[1] = op_crx;
 3331       n_sub_base-&gt;_opnds[2] = op_src;
 3332       n_sub_base-&gt;_bottom_type = _bottom_type;
 3333 
 3334       n_shift-&gt;add_req(n_region, n_sub_base);
 3335       n_shift-&gt;_opnds[0] = op_dst;
 3336       n_shift-&gt;_opnds[1] = op_dst;
 3337       n_shift-&gt;_bottom_type = _bottom_type;
 3338 
 3339       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3340       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3341       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3342       ra_-&gt;set_pair(n_move-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3343 
 3344       nodes-&gt;push(n_move);
 3345       nodes-&gt;push(n_compare);
 3346       nodes-&gt;push(n_sub_base);
 3347       nodes-&gt;push(n_shift);
 3348     }
 3349 
 3350     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3351   %}
 3352 
 3353   enc_class postalloc_expand_encode_oop_not_null(iRegNdst dst, iRegPdst src) %{
 3354 
 3355     encodeP_subNode *n1 = new encodeP_subNode();
 3356     n1-&gt;add_req(n_region, n_src);
 3357     n1-&gt;_opnds[0] = op_dst;
 3358     n1-&gt;_opnds[1] = op_src;
 3359     n1-&gt;_bottom_type = _bottom_type;
 3360 
 3361     encodeP_shiftNode *n2 = new encodeP_shiftNode();
 3362     n2-&gt;add_req(n_region, n1);
 3363     n2-&gt;_opnds[0] = op_dst;
 3364     n2-&gt;_opnds[1] = op_dst;
 3365     n2-&gt;_bottom_type = _bottom_type;
 3366     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3367     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3368 
 3369     nodes-&gt;push(n1);
 3370     nodes-&gt;push(n2);
 3371     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3372   %}
 3373 
 3374   enc_class postalloc_expand_decode_oop(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 3375     decodeN_shiftNode *n_shift    = new decodeN_shiftNode();
 3376     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 3377 
 3378     n_compare-&gt;add_req(n_region, n_src);
 3379     n_compare-&gt;_opnds[0] = op_crx;
 3380     n_compare-&gt;_opnds[1] = op_src;
 3381     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 3382 
 3383     n_shift-&gt;add_req(n_region, n_src);
 3384     n_shift-&gt;_opnds[0] = op_dst;
 3385     n_shift-&gt;_opnds[1] = op_src;
 3386     n_shift-&gt;_bottom_type = _bottom_type;
 3387 
 3388     if (VM_Version::has_isel()) {
 3389       // use isel instruction with Power 7
 3390 
 3391       decodeN_addNode *n_add_base = new decodeN_addNode();
 3392       n_add_base-&gt;add_req(n_region, n_shift);
 3393       n_add_base-&gt;_opnds[0] = op_dst;
 3394       n_add_base-&gt;_opnds[1] = op_dst;
 3395       n_add_base-&gt;_bottom_type = _bottom_type;
 3396 
 3397       cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 3398       n_cond_set-&gt;add_req(n_region, n_compare, n_add_base);
 3399       n_cond_set-&gt;_opnds[0] = op_dst;
 3400       n_cond_set-&gt;_opnds[1] = op_crx;
 3401       n_cond_set-&gt;_opnds[2] = op_dst;
 3402       n_cond_set-&gt;_bottom_type = _bottom_type;
 3403 
 3404       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3405       ra_-&gt;set_oop(n_cond_set, true);
 3406 
 3407       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3408       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3409       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3410       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3411 
 3412       nodes-&gt;push(n_compare);
 3413       nodes-&gt;push(n_shift);
 3414       nodes-&gt;push(n_add_base);
 3415       nodes-&gt;push(n_cond_set);
 3416 
 3417     } else {
 3418       // before Power 7
 3419       cond_add_baseNode *n_add_base = new cond_add_baseNode();
 3420 
 3421       n_add_base-&gt;add_req(n_region, n_compare, n_shift);
 3422       n_add_base-&gt;_opnds[0] = op_dst;
 3423       n_add_base-&gt;_opnds[1] = op_crx;
 3424       n_add_base-&gt;_opnds[2] = op_dst;
 3425       n_add_base-&gt;_bottom_type = _bottom_type;
 3426 
 3427       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3428       ra_-&gt;set_oop(n_add_base, true);
 3429 
 3430       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3431       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3432       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3433 
 3434       nodes-&gt;push(n_compare);
 3435       nodes-&gt;push(n_shift);
 3436       nodes-&gt;push(n_add_base);
 3437     }
 3438   %}
 3439 
 3440   enc_class postalloc_expand_decode_oop_not_null(iRegPdst dst, iRegNsrc src) %{
 3441     decodeN_shiftNode *n1 = new decodeN_shiftNode();
 3442     n1-&gt;add_req(n_region, n_src);
 3443     n1-&gt;_opnds[0] = op_dst;
 3444     n1-&gt;_opnds[1] = op_src;
 3445     n1-&gt;_bottom_type = _bottom_type;
 3446 
 3447     decodeN_addNode *n2 = new decodeN_addNode();
 3448     n2-&gt;add_req(n_region, n1);
 3449     n2-&gt;_opnds[0] = op_dst;
 3450     n2-&gt;_opnds[1] = op_dst;
 3451     n2-&gt;_bottom_type = _bottom_type;
 3452     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3453     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3454 
 3455     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3456     ra_-&gt;set_oop(n2, true);
 3457 
 3458     nodes-&gt;push(n1);
 3459     nodes-&gt;push(n2);
 3460   %}
 3461 
 3462   enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
 3463     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3464 
 3465     C2_MacroAssembler _masm(&amp;cbuf);
 3466     int cc        = $cmp$$cmpcode;
 3467     int flags_reg = $crx$$reg;
 3468     Label done;
 3469     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3470     // Branch if not (cmp crx).
 3471     __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);
 3472     __ mr($dst$$Register, $src$$Register);
 3473     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3474     __ bind(done);
 3475   %}
 3476 
 3477   enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
 3478     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3479 
 3480     C2_MacroAssembler _masm(&amp;cbuf);
 3481     Label done;
 3482     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3483     // Branch if not (cmp crx).
 3484     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 3485     __ li($dst$$Register, $src$$constant);
 3486     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3487     __ bind(done);
 3488   %}
 3489 
 3490   // This enc_class is needed so that scheduler gets proper
 3491   // input mapping for latency computation.
 3492   enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 3493     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
 3494     C2_MacroAssembler _masm(&amp;cbuf);
 3495     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
 3496   %}
 3497 
 3498   enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3499     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3500 
 3501     C2_MacroAssembler _masm(&amp;cbuf);
 3502 
 3503     Label done;
 3504     __ cmpwi($crx$$CondRegister, $src$$Register, 0);
 3505     __ li($dst$$Register, $zero$$constant);
 3506     __ beq($crx$$CondRegister, done);
 3507     __ li($dst$$Register, $notzero$$constant);
 3508     __ bind(done);
 3509   %}
 3510 
 3511   enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3512     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3513 
 3514     C2_MacroAssembler _masm(&amp;cbuf);
 3515 
 3516     Label done;
 3517     __ cmpdi($crx$$CondRegister, $src$$Register, 0);
 3518     __ li($dst$$Register, $zero$$constant);
 3519     __ beq($crx$$CondRegister, done);
 3520     __ li($dst$$Register, $notzero$$constant);
 3521     __ bind(done);
 3522   %}
 3523 
 3524   enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
 3525     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3526 
 3527     C2_MacroAssembler _masm(&amp;cbuf);
 3528     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3529     Label done;
 3530     __ bso($crx$$CondRegister, done);
 3531     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 3532     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3533     __ bind(done);
 3534   %}
 3535 
 3536   enc_class enc_cmove_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
 3537     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3538 
 3539     C2_MacroAssembler _masm(&amp;cbuf);
 3540     Label done;
 3541     __ bso($crx$$CondRegister, done);
 3542     __ mffprd($dst$$Register, $src$$FloatRegister);
 3543     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3544     __ bind(done);
 3545   %}
 3546 
 3547   enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3548     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3549 
 3550     C2_MacroAssembler _masm(&amp;cbuf);
 3551     Label d;   // dummy
 3552     __ bind(d);
 3553     Label* p = ($lbl$$label);
 3554     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3555     // determine the size of the encoded instruction.
 3556     Label&amp; l = (NULL == p)? d : *(p);
 3557     int cc = $cmp$$cmpcode;
 3558     int flags_reg = $crx$$reg;
 3559     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3560     int bhint = Assembler::bhintNoHint;
 3561 
 3562     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3563       if (_prob &lt;= PROB_NEVER) {
 3564         bhint = Assembler::bhintIsNotTaken;
 3565       } else if (_prob &gt;= PROB_ALWAYS) {
 3566         bhint = Assembler::bhintIsTaken;
 3567       }
 3568     }
 3569 
 3570     __ bc(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3571           cc_to_biint(cc, flags_reg),
 3572           l);
 3573   %}
 3574 
 3575   enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3576     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3577     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3578     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3579 
 3580     C2_MacroAssembler _masm(&amp;cbuf);
 3581     Label d;    // dummy
 3582     __ bind(d);
 3583     Label* p = ($lbl$$label);
 3584     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3585     // determine the size of the encoded instruction.
 3586     Label&amp; l = (NULL == p)? d : *(p);
 3587     int cc = $cmp$$cmpcode;
 3588     int flags_reg = $crx$$reg;
 3589     int bhint = Assembler::bhintNoHint;
 3590 
 3591     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3592       if (_prob &lt;= PROB_NEVER) {
 3593         bhint = Assembler::bhintIsNotTaken;
 3594       } else if (_prob &gt;= PROB_ALWAYS) {
 3595         bhint = Assembler::bhintIsTaken;
 3596       }
 3597     }
 3598 
 3599     // Tell the conditional far branch to optimize itself when being relocated.
 3600     __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3601                   cc_to_biint(cc, flags_reg),
 3602                   l,
 3603                   MacroAssembler::bc_far_optimize_on_relocate);
 3604   %}
 3605 
 3606   // Branch used with Power6 scheduling (can be shortened without changing the node).
 3607   enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3608     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3609     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3610     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3611 
 3612     C2_MacroAssembler _masm(&amp;cbuf);
 3613     Label d;   // dummy
 3614     __ bind(d);
 3615     Label* p = ($lbl$$label);
 3616     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3617     // determine the size of the encoded instruction.
 3618     Label&amp; l = (NULL == p)? d : *(p);
 3619     int cc = $cmp$$cmpcode;
 3620     int flags_reg = $crx$$reg;
 3621     int bhint = Assembler::bhintNoHint;
 3622 
 3623     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3624       if (_prob &lt;= PROB_NEVER) {
 3625         bhint = Assembler::bhintIsNotTaken;
 3626       } else if (_prob &gt;= PROB_ALWAYS) {
 3627         bhint = Assembler::bhintIsTaken;
 3628       }
 3629     }
 3630 
 3631 #if 0 // TODO: PPC port
 3632     if (_size == 8) {
 3633       // Tell the conditional far branch to optimize itself when being relocated.
 3634       __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3635                     cc_to_biint(cc, flags_reg),
 3636                     l,
 3637                     MacroAssembler::bc_far_optimize_on_relocate);
 3638     } else {
 3639       __ bc    (Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3640                     cc_to_biint(cc, flags_reg),
 3641                     l);
 3642     }
 3643 #endif
 3644     Unimplemented();
 3645   %}
 3646 
 3647   // Postalloc expand emitter for loading a replicatef float constant from
 3648   // the method&#39;s TOC.
 3649   // Enc_class needed as consttanttablebase is not supported by postalloc
 3650   // expand.
 3651   enc_class postalloc_expand_load_replF_constant(iRegLdst dst, immF src, iRegLdst toc) %{
 3652     // Create new nodes.
 3653 
 3654     // Make an operand with the bit pattern to load as float.
 3655     immLOper *op_repl = new immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3656 
 3657     loadConLNodesTuple loadConLNodes =
 3658       loadConLNodesTuple_create(ra_, n_toc, op_repl,
 3659                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3660 
 3661     // Push new nodes.
 3662     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3663     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3664 
 3665     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3666     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3667   %}
 3668 
 3669   enc_class postalloc_expand_load_replF_constant_vsx(vecX dst, immF src, iRegLdst toc, iRegLdst tmp) %{
 3670     // Create new nodes.
 3671 
 3672     // Make an operand with the bit pattern to load as float.
 3673     immLOper *op_repl = new  immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3674     immI_0Oper *op_zero = new  immI_0Oper(0);
 3675 
 3676     loadConLReplicatedNodesTuple loadConLNodes =
 3677       loadConLReplicatedNodesTuple_create(C, ra_, n_toc, op_repl, op_dst, op_zero,
 3678                                 ra_-&gt;get_reg_second(n_tmp), ra_-&gt;get_reg_first(n_tmp),
 3679                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3680 
 3681     // Push new nodes.
 3682     if (loadConLNodes._large_hi) { nodes-&gt;push(loadConLNodes._large_hi); }
 3683     if (loadConLNodes._large_lo) { nodes-&gt;push(loadConLNodes._large_lo); }
 3684     if (loadConLNodes._moved)    { nodes-&gt;push(loadConLNodes._moved); }
 3685     if (loadConLNodes._last)     { nodes-&gt;push(loadConLNodes._last); }
 3686 
 3687     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3688   %}
 3689 
 3690   // This enc_class is needed so that scheduler gets proper
 3691   // input mapping for latency computation.
 3692   enc_class enc_poll(immI dst, iRegLdst poll) %{
 3693     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3694     // Fake operand dst needed for PPC scheduler.
 3695     assert($dst$$constant == 0x0, &quot;dst must be 0x0&quot;);
 3696 
 3697     C2_MacroAssembler _masm(&amp;cbuf);
 3698     // Mark the code position where the load from the safepoint
 3699     // polling page was emitted as relocInfo::poll_type.
 3700     __ relocate(relocInfo::poll_type);
 3701     __ load_from_polling_page($poll$$Register);
 3702   %}
 3703 
 3704   // A Java static call or a runtime call.
 3705   //
 3706   // Branch-and-link relative to a trampoline.
 3707   // The trampoline loads the target address and does a long branch to there.
 3708   // In case we call java, the trampoline branches to a interpreter_stub
 3709   // which loads the inline cache and the real call target from the constant pool.
 3710   //
 3711   // This basically looks like this:
 3712   //
 3713   // &gt;&gt;&gt;&gt; consts      -+  -+
 3714   //                   |   |- offset1
 3715   // [call target1]    | &lt;-+
 3716   // [IC cache]        |- offset2
 3717   // [call target2] &lt;--+
 3718   //
 3719   // &lt;&lt;&lt;&lt; consts
 3720   // &gt;&gt;&gt;&gt; insts
 3721   //
 3722   // bl offset16               -+  -+             ??? // How many bits available?
 3723   //                            |   |
 3724   // &lt;&lt;&lt;&lt; insts                 |   |
 3725   // &gt;&gt;&gt;&gt; stubs                 |   |
 3726   //                            |   |- trampoline_stub_Reloc
 3727   // trampoline stub:           | &lt;-+
 3728   //   r2 = toc                 |
 3729   //   r2 = [r2 + offset1]      |       // Load call target1 from const section
 3730   //   mtctr r2                 |
 3731   //   bctr                     |- static_stub_Reloc
 3732   // comp_to_interp_stub:   &lt;---+
 3733   //   r1 = toc
 3734   //   ICreg = [r1 + IC_offset]         // Load IC from const section
 3735   //   r1    = [r1 + offset2]           // Load call target2 from const section
 3736   //   mtctr r1
 3737   //   bctr
 3738   //
 3739   // &lt;&lt;&lt;&lt; stubs
 3740   //
 3741   // The call instruction in the code either
 3742   // - Branches directly to a compiled method if the offset is encodable in instruction.
 3743   // - Branches to the trampoline stub if the offset to the compiled method is not encodable.
 3744   // - Branches to the compiled_to_interp stub if the target is interpreted.
 3745   //
 3746   // Further there are three relocations from the loads to the constants in
 3747   // the constant section.
 3748   //
 3749   // Usage of r1 and r2 in the stubs allows to distinguish them.
 3750   enc_class enc_java_static_call(method meth) %{
 3751     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3752 
 3753     C2_MacroAssembler _masm(&amp;cbuf);
 3754     address entry_point = (address)$meth$$method;
 3755 
 3756     if (!_method) {
 3757       // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
 3758       emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
 3759     } else {
 3760       // Remember the offset not the address.
 3761       const int start_offset = __ offset();
 3762 
 3763       // The trampoline stub.
 3764       // No entry point given, use the current pc.
 3765       // Make sure branch fits into
 3766       if (entry_point == 0) entry_point = __ pc();
 3767 
 3768       // Put the entry point as a constant into the constant pool.
 3769       const address entry_point_toc_addr = __ address_constant(entry_point, RelocationHolder::none);
 3770       if (entry_point_toc_addr == NULL) {
 3771         ciEnv::current()-&gt;record_out_of_memory_failure();
 3772         return;
 3773       }
 3774       const int entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 3775 
 3776       // Emit the trampoline stub which will be related to the branch-and-link below.
 3777       CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);
 3778       if (ciEnv::current()-&gt;failing()) { return; } // Code cache may be full.
 3779       int method_index = resolved_method_index(cbuf);
 3780       __ relocate(_optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 3781                   : static_call_Relocation::spec(method_index));
 3782 
 3783       // The real call.
 3784       // Note: At this point we do not have the address of the trampoline
 3785       // stub, and the entry point might be too far away for bl, so __ pc()
 3786       // serves as dummy and the bl will be patched later.
 3787       cbuf.set_insts_mark();
 3788       __ bl(__ pc());  // Emits a relocation.
 3789 
 3790       // The stub for call to interpreter.
 3791       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 3792       if (stub == NULL) {
 3793         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3794         return;
 3795       }
 3796     }
 3797   %}
 3798 
 3799   // Second node of expanded dynamic call - the call.
 3800   enc_class enc_java_dynamic_call_sched(method meth) %{
 3801     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3802 
 3803     C2_MacroAssembler _masm(&amp;cbuf);
 3804 
 3805     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {
 3806       // Create a call trampoline stub for the given method.
 3807       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
 3808       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
 3809       if (entry_point_const == NULL) {
 3810         ciEnv::current()-&gt;record_out_of_memory_failure();
 3811         return;
 3812       }
 3813       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
 3814       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
 3815       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
 3816 
 3817       // Build relocation at call site with ic position as data.
 3818       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
 3819              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
 3820              &quot;must have one, but can&#39;t have both&quot;);
 3821       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
 3822              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
 3823              &quot;must contain instruction offset&quot;);
 3824       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
 3825         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
 3826         : _load_ic_node-&gt;_cbuf_insts_offset;
 3827       const address virtual_call_oop_addr = __ addr_at(virtual_call_oop_addr_offset);
 3828       assert(MacroAssembler::is_load_const_from_method_toc_at(virtual_call_oop_addr),
 3829              &quot;should be load from TOC&quot;);
 3830       int method_index = resolved_method_index(cbuf);
 3831       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 3832     }
 3833 
 3834     // At this point I do not have the address of the trampoline stub,
 3835     // and the entry point might be too far away for bl. Pc() serves
 3836     // as dummy and bl will be patched later.
 3837     __ bl((address) __ pc());
 3838   %}
 3839 
 3840   // postalloc expand emitter for virtual calls.
 3841   enc_class postalloc_expand_java_dynamic_call_sched(method meth, iRegLdst toc) %{
 3842 
 3843     // Create the nodes for loading the IC from the TOC.
 3844     loadConLNodesTuple loadConLNodes_IC =
 3845       loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong)Universe::non_oop_word()),
 3846                                 OptoReg::Name(R19_H_num), OptoReg::Name(R19_num));
 3847 
 3848     // Create the call node.
 3849     CallDynamicJavaDirectSchedNode *call = new CallDynamicJavaDirectSchedNode();
 3850     call-&gt;_method_handle_invoke = _method_handle_invoke;
 3851     call-&gt;_vtable_index      = _vtable_index;
 3852     call-&gt;_method            = _method;
 3853     call-&gt;_bci               = _bci;
 3854     call-&gt;_optimized_virtual = _optimized_virtual;
 3855     call-&gt;_tf                = _tf;
 3856     call-&gt;_entry_point       = _entry_point;
 3857     call-&gt;_cnt               = _cnt;
 3858     call-&gt;_argsize           = _argsize;
 3859     call-&gt;_oop_map           = _oop_map;
 3860     call-&gt;_jvms              = _jvms;
 3861     call-&gt;_jvmadj            = _jvmadj;
 3862     call-&gt;_in_rms            = _in_rms;
 3863     call-&gt;_nesting           = _nesting;
 3864     call-&gt;_override_symbolic_info = _override_symbolic_info;
 3865 
 3866     // New call needs all inputs of old call.
 3867     // Req...
 3868     for (uint i = 0; i &lt; req(); ++i) {
 3869       // The expanded node does not need toc any more.
 3870       // Add the inline cache constant here instead. This expresses the
 3871       // register of the inline cache must be live at the call.
 3872       // Else we would have to adapt JVMState by -1.
 3873       if (i == mach_constant_base_node_input()) {
 3874         call-&gt;add_req(loadConLNodes_IC._last);
 3875       } else {
 3876         call-&gt;add_req(in(i));
 3877       }
 3878     }
 3879     // ...as well as prec
 3880     for (uint i = req(); i &lt; len(); ++i) {
 3881       call-&gt;add_prec(in(i));
 3882     }
 3883 
 3884     // Remember nodes loading the inline cache into r19.
 3885     call-&gt;_load_ic_hi_node = loadConLNodes_IC._large_hi;
 3886     call-&gt;_load_ic_node    = loadConLNodes_IC._small;
 3887 
 3888     // Operands for new nodes.
 3889     call-&gt;_opnds[0] = _opnds[0];
 3890     call-&gt;_opnds[1] = _opnds[1];
 3891 
 3892     // Only the inline cache is associated with a register.
 3893     assert(Matcher::inline_cache_reg() == OptoReg::Name(R19_num), &quot;ic reg should be R19&quot;);
 3894 
 3895     // Push new nodes.
 3896     if (loadConLNodes_IC._large_hi) nodes-&gt;push(loadConLNodes_IC._large_hi);
 3897     if (loadConLNodes_IC._last)     nodes-&gt;push(loadConLNodes_IC._last);
 3898     nodes-&gt;push(call);
 3899   %}
 3900 
 3901   // Compound version of call dynamic
 3902   // Toc is only passed so that it can be used in ins_encode statement.
 3903   // In the code we have to use $constanttablebase.
 3904   enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
 3905     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3906     C2_MacroAssembler _masm(&amp;cbuf);
 3907     int start_offset = __ offset();
 3908 
 3909     Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
 3910 #if 0
 3911     int vtable_index = this-&gt;_vtable_index;
 3912     if (_vtable_index &lt; 0) {
 3913       // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 3914       assert(_vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 3915       Register ic_reg = as_Register(Matcher::inline_cache_reg_encode());
 3916 
 3917       // Virtual call relocation will point to ic load.
 3918       address virtual_call_meta_addr = __ pc();
 3919       // Load a clear inline cache.
 3920       AddressLiteral empty_ic((address) Universe::non_oop_word());
 3921       bool success = __ load_const_from_method_toc(ic_reg, empty_ic, Rtoc, /*fixed_size*/ true);
 3922       if (!success) {
 3923         ciEnv::current()-&gt;record_out_of_memory_failure();
 3924         return;
 3925       }
 3926       // CALL to fixup routine.  Fixup routine uses ScopeDesc info
 3927       // to determine who we intended to call.
 3928       __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 3929       emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);
 3930       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3931              &quot;Fix constant in ret_addr_offset()&quot;);
 3932     } else {
 3933       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 3934       // Go thru the vtable. Get receiver klass. Receiver already
 3935       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 3936       // interpreter expects method in R19_method.
 3937 
 3938       __ load_klass(R11_scratch1, R3);
 3939 
 3940       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
 3941       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 3942       __ li(R19_method, v_off);
 3943       __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
 3944       // NOTE: for vtable dispatches, the vtable entry will never be
 3945       // null. However it may very well end up in handle_wrong_method
 3946       // if the method is abstract for the particular class.
 3947       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
 3948       // Call target. Either compiled code or C2I adapter.
 3949       __ mtctr(R11_scratch1);
 3950       __ bctrl();
 3951       if (((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() != __ offset() - start_offset) {
 3952         tty-&gt;print(&quot; %d, %d\n&quot;, ((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset(),__ offset() - start_offset);
 3953       }
 3954       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3955              &quot;Fix constant in ret_addr_offset()&quot;);
 3956     }
 3957 #endif
 3958     Unimplemented();  // ret_addr_offset not yet fixed. Depends on compressed oops (load klass!).
 3959   %}
 3960 
 3961   // a runtime call
 3962   enc_class enc_java_to_runtime_call (method meth) %{
 3963     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3964 
 3965     C2_MacroAssembler _masm(&amp;cbuf);
 3966     const address start_pc = __ pc();
 3967 
 3968 #if defined(ABI_ELFv2)
 3969     address entry= !($meth$$method) ? NULL : (address)$meth$$method;
 3970     __ call_c(entry, relocInfo::runtime_call_type);
 3971 #else
 3972     // The function we&#39;re going to call.
 3973     FunctionDescriptor fdtemp;
 3974     const FunctionDescriptor* fd = !($meth$$method) ? &amp;fdtemp : (FunctionDescriptor*)$meth$$method;
 3975 
 3976     Register Rtoc = R12_scratch2;
 3977     // Calculate the method&#39;s TOC.
 3978     __ calculate_address_from_global_toc(Rtoc, __ method_toc());
 3979     // Put entry, env, toc into the constant pool, this needs up to 3 constant
 3980     // pool entries; call_c_using_toc will optimize the call.
 3981     bool success = __ call_c_using_toc(fd, relocInfo::runtime_call_type, Rtoc);
 3982     if (!success) {
 3983       ciEnv::current()-&gt;record_out_of_memory_failure();
 3984       return;
 3985     }
 3986 #endif
 3987 
 3988     // Check the ret_addr_offset.
 3989     assert(((MachCallRuntimeNode*)this)-&gt;ret_addr_offset() ==  __ last_calls_return_pc() - start_pc,
 3990            &quot;Fix constant in ret_addr_offset()&quot;);
 3991   %}
 3992 
 3993   // Move to ctr for leaf call.
 3994   // This enc_class is needed so that scheduler gets proper
 3995   // input mapping for latency computation.
 3996   enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
 3997     // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
 3998     C2_MacroAssembler _masm(&amp;cbuf);
 3999     __ mtctr($src$$Register);
 4000   %}
 4001 
 4002   // Postalloc expand emitter for runtime leaf calls.
 4003   enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
 4004     loadConLNodesTuple loadConLNodes_Entry;
 4005 #if defined(ABI_ELFv2)
 4006     jlong entry_address = (jlong) this-&gt;entry_point();
 4007     assert(entry_address, &quot;need address here&quot;);
 4008     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4009                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4010 #else
 4011     // Get the struct that describes the function we are about to call.
 4012     FunctionDescriptor* fd = (FunctionDescriptor*) this-&gt;entry_point();
 4013     assert(fd, &quot;need fd here&quot;);
 4014     jlong entry_address = (jlong) fd-&gt;entry();
 4015     // new nodes
 4016     loadConLNodesTuple loadConLNodes_Env;
 4017     loadConLNodesTuple loadConLNodes_Toc;
 4018 
 4019     // Create nodes and operands for loading the entry point.
 4020     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4021                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4022 
 4023 
 4024     // Create nodes and operands for loading the env pointer.
 4025     if (fd-&gt;env() != NULL) {
 4026       loadConLNodes_Env = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;env()),
 4027                                                     OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4028     } else {
 4029       loadConLNodes_Env._large_hi = NULL;
 4030       loadConLNodes_Env._large_lo = NULL;
 4031       loadConLNodes_Env._small    = NULL;
 4032       loadConLNodes_Env._last = new loadConL16Node();
 4033       loadConLNodes_Env._last-&gt;_opnds[0] = new iRegLdstOper();
 4034       loadConLNodes_Env._last-&gt;_opnds[1] = new immL16Oper(0);
 4035       ra_-&gt;set_pair(loadConLNodes_Env._last-&gt;_idx, OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4036     }
 4037 
 4038     // Create nodes and operands for loading the Toc point.
 4039     loadConLNodes_Toc = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;toc()),
 4040                                                   OptoReg::Name(R2_H_num), OptoReg::Name(R2_num));
 4041 #endif // ABI_ELFv2
 4042     // mtctr node
 4043     MachNode *mtctr = new CallLeafDirect_mtctrNode();
 4044 
 4045     assert(loadConLNodes_Entry._last != NULL, &quot;entry must exist&quot;);
 4046     mtctr-&gt;add_req(0, loadConLNodes_Entry._last);
 4047 
 4048     mtctr-&gt;_opnds[0] = new iRegLdstOper();
 4049     mtctr-&gt;_opnds[1] = new iRegLdstOper();
 4050 
 4051     // call node
 4052     MachCallLeafNode *call = new CallLeafDirectNode();
 4053 
 4054     call-&gt;_opnds[0] = _opnds[0];
 4055     call-&gt;_opnds[1] = new methodOper((intptr_t) entry_address); // May get set later.
 4056 
 4057     // Make the new call node look like the old one.
 4058     call-&gt;_name        = _name;
 4059     call-&gt;_tf          = _tf;
 4060     call-&gt;_entry_point = _entry_point;
 4061     call-&gt;_cnt         = _cnt;
 4062     call-&gt;_argsize     = _argsize;
 4063     call-&gt;_oop_map     = _oop_map;
 4064     guarantee(!_jvms, &quot;You must clone the jvms and adapt the offsets by fix_jvms().&quot;);
 4065     call-&gt;_jvms        = NULL;
 4066     call-&gt;_jvmadj      = _jvmadj;
 4067     call-&gt;_in_rms      = _in_rms;
 4068     call-&gt;_nesting     = _nesting;
 4069 
 4070 
 4071     // New call needs all inputs of old call.
 4072     // Req...
 4073     for (uint i = 0; i &lt; req(); ++i) {
 4074       if (i != mach_constant_base_node_input()) {
 4075         call-&gt;add_req(in(i));
 4076       }
 4077     }
 4078 
 4079     // These must be reqired edges, as the registers are live up to
 4080     // the call. Else the constants are handled as kills.
 4081     call-&gt;add_req(mtctr);
 4082 #if !defined(ABI_ELFv2)
 4083     call-&gt;add_req(loadConLNodes_Env._last);
 4084     call-&gt;add_req(loadConLNodes_Toc._last);
 4085 #endif
 4086 
 4087     // ...as well as prec
 4088     for (uint i = req(); i &lt; len(); ++i) {
 4089       call-&gt;add_prec(in(i));
 4090     }
 4091 
 4092     // registers
 4093     ra_-&gt;set1(mtctr-&gt;_idx, OptoReg::Name(SR_CTR_num));
 4094 
 4095     // Insert the new nodes.
 4096     if (loadConLNodes_Entry._large_hi) nodes-&gt;push(loadConLNodes_Entry._large_hi);
 4097     if (loadConLNodes_Entry._last)     nodes-&gt;push(loadConLNodes_Entry._last);
 4098 #if !defined(ABI_ELFv2)
 4099     if (loadConLNodes_Env._large_hi)   nodes-&gt;push(loadConLNodes_Env._large_hi);
 4100     if (loadConLNodes_Env._last)       nodes-&gt;push(loadConLNodes_Env._last);
 4101     if (loadConLNodes_Toc._large_hi)   nodes-&gt;push(loadConLNodes_Toc._large_hi);
 4102     if (loadConLNodes_Toc._last)       nodes-&gt;push(loadConLNodes_Toc._last);
 4103 #endif
 4104     nodes-&gt;push(mtctr);
 4105     nodes-&gt;push(call);
 4106   %}
 4107 %}
 4108 
 4109 //----------FRAME--------------------------------------------------------------
 4110 // Definition of frame structure and management information.
 4111 
 4112 frame %{
 4113   // What direction does stack grow in (assumed to be same for native &amp; Java).
 4114   stack_direction(TOWARDS_LOW);
 4115 
 4116   // These two registers define part of the calling convention between
 4117   // compiled code and the interpreter.
 4118 
 4119   // Inline Cache Register or method for I2C.
 4120   inline_cache_reg(R19); // R19_method
 4121 
 4122   // Method Oop Register when calling interpreter.
 4123   interpreter_method_oop_reg(R19); // R19_method
 4124 
 4125   // Optional: name the operand used by cisc-spilling to access
 4126   // [stack_pointer + offset].
 4127   cisc_spilling_operand_name(indOffset);
 4128 
 4129   // Number of stack slots consumed by a Monitor enter.
 4130   sync_stack_slots((frame::jit_monitor_size / VMRegImpl::stack_slot_size));
 4131 
 4132   // Compiled code&#39;s Frame Pointer.
 4133   frame_pointer(R1); // R1_SP
 4134 
 4135   // Interpreter stores its frame pointer in a register which is
 4136   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 4137   // interpreted java to compiled java.
 4138   //
 4139   // R14_state holds pointer to caller&#39;s cInterpreter.
 4140   interpreter_frame_pointer(R14); // R14_state
 4141 
 4142   stack_alignment(frame::alignment_in_bytes);
 4143 
 4144   in_preserve_stack_slots((frame::jit_in_preserve_size / VMRegImpl::stack_slot_size));
 4145 
 4146   // Number of outgoing stack slots killed above the
 4147   // out_preserve_stack_slots for calls to C. Supports the var-args
 4148   // backing area for register parms.
 4149   //
 4150   varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 4151 
 4152   // The after-PROLOG location of the return address. Location of
 4153   // return address specifies a type (REG or STACK) and a number
 4154   // representing the register number (i.e. - use a register name) or
 4155   // stack slot.
 4156   //
 4157   // A: Link register is stored in stack slot ...
 4158   // M:  ... but it&#39;s in the caller&#39;s frame according to PPC-64 ABI.
 4159   // J: Therefore, we make sure that the link register is also in R11_scratch1
 4160   //    at the end of the prolog.
 4161   // B: We use R20, now.
 4162   //return_addr(REG R20);
 4163 
 4164   // G: After reading the comments made by all the luminaries on their
 4165   //    failure to tell the compiler where the return address really is,
 4166   //    I hardly dare to try myself.  However, I&#39;m convinced it&#39;s in slot
 4167   //    4 what apparently works and saves us some spills.
 4168   return_addr(STACK 4);
 4169 
 4170   // This is the body of the function
 4171   //
 4172   // void Matcher::calling_convention(OptoRegPair* sig, // array of ideal regs
 4173   //                                  uint length,      // length of array
 4174   //                                  bool is_outgoing)
 4175   //
 4176   // The `sig&#39; array is to be updated. sig[j] represents the location
 4177   // of the j-th argument, either a register or a stack slot.
 4178 
 4179   // Comment taken from i486.ad:
 4180   // Body of function which returns an integer array locating
 4181   // arguments either in registers or in stack slots. Passed an array
 4182   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4183   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4184   // arguments for a CALLEE. Incoming stack arguments are
 4185   // automatically biased by the preserve_stack_slots field above.
 4186   calling_convention %{
 4187     // No difference between ingoing/outgoing. Just pass false.
 4188     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 4189   %}
 4190 
 4191   // Comment taken from i486.ad:
 4192   // Body of function which returns an integer array locating
 4193   // arguments either in registers or in stack slots. Passed an array
 4194   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4195   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4196   // arguments for a CALLEE. Incoming stack arguments are
 4197   // automatically biased by the preserve_stack_slots field above.
 4198   c_calling_convention %{
 4199     // This is obviously always outgoing.
 4200     // C argument in register AND stack slot.
 4201     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 4202   %}
 4203 
 4204   // Location of native (C/C++) and interpreter return values. This
 4205   // is specified to be the same as Java. In the 32-bit VM, long
 4206   // values are actually returned from native calls in O0:O1 and
 4207   // returned to the interpreter in I0:I1. The copying to and from
 4208   // the register pairs is done by the appropriate call and epilog
 4209   // opcodes. This simplifies the register allocator.
 4210   c_return_value %{
 4211     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4212             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4213             &quot;only return normal values&quot;);
 4214     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4215     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4216     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4217     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4218   %}
 4219 
 4220   // Location of compiled Java return values.  Same as C
 4221   return_value %{
 4222     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4223             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4224             &quot;only return normal values&quot;);
 4225     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4226     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4227     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4228     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4229   %}
 4230 %}
 4231 
 4232 
 4233 //----------ATTRIBUTES---------------------------------------------------------
 4234 
 4235 //----------Operand Attributes-------------------------------------------------
 4236 op_attrib op_cost(1);          // Required cost attribute.
 4237 
 4238 //----------Instruction Attributes---------------------------------------------
 4239 
 4240 // Cost attribute. required.
 4241 ins_attrib ins_cost(DEFAULT_COST);
 4242 
 4243 // Is this instruction a non-matching short branch variant of some
 4244 // long branch? Not required.
 4245 ins_attrib ins_short_branch(0);
 4246 
 4247 ins_attrib ins_is_TrapBasedCheckNode(true);
 4248 
 4249 // Number of constants.
 4250 // This instruction uses the given number of constants
 4251 // (optional attribute).
 4252 // This is needed to determine in time whether the constant pool will
 4253 // exceed 4000 entries. Before postalloc_expand the overall number of constants
 4254 // is determined. It&#39;s also used to compute the constant pool size
 4255 // in Output().
 4256 ins_attrib ins_num_consts(0);
 4257 
 4258 // Required alignment attribute (must be a power of 2) specifies the
 4259 // alignment that some part of the instruction (not necessarily the
 4260 // start) requires. If &gt; 1, a compute_padding() function must be
 4261 // provided for the instruction.
 4262 ins_attrib ins_alignment(1);
 4263 
 4264 // Enforce/prohibit rematerializations.
 4265 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 4266 //   then rematerialization of that instruction is prohibited and the
 4267 //   instruction&#39;s value will be spilled if necessary.
 4268 //   Causes that MachNode::rematerialize() returns false.
 4269 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 4270 //   then rematerialization should be enforced and a copy of the instruction
 4271 //   should be inserted if possible; rematerialization is not guaranteed.
 4272 //   Note: this may result in rematerializations in front of every use.
 4273 //   Causes that MachNode::rematerialize() can return true.
 4274 // (optional attribute)
 4275 ins_attrib ins_cannot_rematerialize(false);
 4276 ins_attrib ins_should_rematerialize(false);
 4277 
 4278 // Instruction has variable size depending on alignment.
 4279 ins_attrib ins_variable_size_depending_on_alignment(false);
 4280 
 4281 // Instruction is a nop.
 4282 ins_attrib ins_is_nop(false);
 4283 
 4284 // Instruction is mapped to a MachIfFastLock node (instead of MachFastLock).
 4285 ins_attrib ins_use_mach_if_fast_lock_node(false);
 4286 
 4287 // Field for the toc offset of a constant.
 4288 //
 4289 // This is needed if the toc offset is not encodable as an immediate in
 4290 // the PPC load instruction. If so, the upper (hi) bits of the offset are
 4291 // added to the toc, and from this a load with immediate is performed.
 4292 // With postalloc expand, we get two nodes that require the same offset
 4293 // but which don&#39;t know about each other. The offset is only known
 4294 // when the constant is added to the constant pool during emitting.
 4295 // It is generated in the &#39;hi&#39;-node adding the upper bits, and saved
 4296 // in this node.  The &#39;lo&#39;-node has a link to the &#39;hi&#39;-node and reads
 4297 // the offset from there when it gets encoded.
 4298 ins_attrib ins_field_const_toc_offset(0);
 4299 ins_attrib ins_field_const_toc_offset_hi_node(0);
 4300 
 4301 // A field that can hold the instructions offset in the code buffer.
 4302 // Set in the nodes emitter.
 4303 ins_attrib ins_field_cbuf_insts_offset(-1);
 4304 
 4305 // Fields for referencing a call&#39;s load-IC-node.
 4306 // If the toc offset can not be encoded as an immediate in a load, we
 4307 // use two nodes.
 4308 ins_attrib ins_field_load_ic_hi_node(0);
 4309 ins_attrib ins_field_load_ic_node(0);
 4310 
 4311 //----------OPERANDS-----------------------------------------------------------
 4312 // Operand definitions must precede instruction definitions for correct
 4313 // parsing in the ADLC because operands constitute user defined types
 4314 // which are used in instruction definitions.
 4315 //
 4316 // Formats are generated automatically for constants and base registers.
 4317 
 4318 operand vecX() %{
 4319   constraint(ALLOC_IN_RC(vs_reg));
 4320   match(VecX);
 4321 
 4322   format %{ %}
 4323   interface(REG_INTER);
 4324 %}
 4325 
 4326 //----------Simple Operands----------------------------------------------------
 4327 // Immediate Operands
 4328 
 4329 // Integer Immediate: 32-bit
 4330 operand immI() %{
 4331   match(ConI);
 4332   op_cost(40);
 4333   format %{ %}
 4334   interface(CONST_INTER);
 4335 %}
 4336 
 4337 operand immI8() %{
 4338   predicate(Assembler::is_simm(n-&gt;get_int(), 8));
 4339   op_cost(0);
 4340   match(ConI);
 4341   format %{ %}
 4342   interface(CONST_INTER);
 4343 %}
 4344 
 4345 // Integer Immediate: 16-bit
 4346 operand immI16() %{
 4347   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4348   op_cost(0);
 4349   match(ConI);
 4350   format %{ %}
 4351   interface(CONST_INTER);
 4352 %}
 4353 
 4354 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4355 operand immIhi16() %{
 4356   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4357   match(ConI);
 4358   op_cost(0);
 4359   format %{ %}
 4360   interface(CONST_INTER);
 4361 %}
 4362 
 4363 operand immInegpow2() %{
 4364   predicate(is_power_of_2((jlong) (julong) (juint) (-(n-&gt;get_int()))));
 4365   match(ConI);
 4366   op_cost(0);
 4367   format %{ %}
 4368   interface(CONST_INTER);
 4369 %}
 4370 
 4371 operand immIpow2minus1() %{
 4372   predicate(is_power_of_2((((jlong) (n-&gt;get_int()))+1)));
 4373   match(ConI);
 4374   op_cost(0);
 4375   format %{ %}
 4376   interface(CONST_INTER);
 4377 %}
 4378 
 4379 operand immIpowerOf2() %{
 4380   predicate(is_power_of_2((((jlong) (julong) (juint) (n-&gt;get_int())))));
 4381   match(ConI);
 4382   op_cost(0);
 4383   format %{ %}
 4384   interface(CONST_INTER);
 4385 %}
 4386 
 4387 // Unsigned Integer Immediate: the values 0-31
 4388 operand uimmI5() %{
 4389   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4390   match(ConI);
 4391   op_cost(0);
 4392   format %{ %}
 4393   interface(CONST_INTER);
 4394 %}
 4395 
 4396 // Unsigned Integer Immediate: 6-bit
 4397 operand uimmI6() %{
 4398   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4399   match(ConI);
 4400   op_cost(0);
 4401   format %{ %}
 4402   interface(CONST_INTER);
 4403 %}
 4404 
 4405 // Unsigned Integer Immediate:  6-bit int, greater than 32
 4406 operand uimmI6_ge32() %{
 4407   predicate(Assembler::is_uimm(n-&gt;get_int(), 6) &amp;&amp; n-&gt;get_int() &gt;= 32);
 4408   match(ConI);
 4409   op_cost(0);
 4410   format %{ %}
 4411   interface(CONST_INTER);
 4412 %}
 4413 
 4414 // Unsigned Integer Immediate: 15-bit
 4415 operand uimmI15() %{
 4416   predicate(Assembler::is_uimm(n-&gt;get_int(), 15));
 4417   match(ConI);
 4418   op_cost(0);
 4419   format %{ %}
 4420   interface(CONST_INTER);
 4421 %}
 4422 
 4423 // Unsigned Integer Immediate: 16-bit
 4424 operand uimmI16() %{
 4425   predicate(Assembler::is_uimm(n-&gt;get_int(), 16));
 4426   match(ConI);
 4427   op_cost(0);
 4428   format %{ %}
 4429   interface(CONST_INTER);
 4430 %}
 4431 
 4432 // constant &#39;int 0&#39;.
 4433 operand immI_0() %{
 4434   predicate(n-&gt;get_int() == 0);
 4435   match(ConI);
 4436   op_cost(0);
 4437   format %{ %}
 4438   interface(CONST_INTER);
 4439 %}
 4440 
 4441 // constant &#39;int 1&#39;.
 4442 operand immI_1() %{
 4443   predicate(n-&gt;get_int() == 1);
 4444   match(ConI);
 4445   op_cost(0);
 4446   format %{ %}
 4447   interface(CONST_INTER);
 4448 %}
 4449 
 4450 // constant &#39;int -1&#39;.
 4451 operand immI_minus1() %{
 4452   predicate(n-&gt;get_int() == -1);
 4453   match(ConI);
 4454   op_cost(0);
 4455   format %{ %}
 4456   interface(CONST_INTER);
 4457 %}
 4458 
 4459 // int value 16.
 4460 operand immI_16() %{
 4461   predicate(n-&gt;get_int() == 16);
 4462   match(ConI);
 4463   op_cost(0);
 4464   format %{ %}
 4465   interface(CONST_INTER);
 4466 %}
 4467 
 4468 // int value 24.
 4469 operand immI_24() %{
 4470   predicate(n-&gt;get_int() == 24);
 4471   match(ConI);
 4472   op_cost(0);
 4473   format %{ %}
 4474   interface(CONST_INTER);
 4475 %}
 4476 
 4477 // Compressed oops constants
 4478 // Pointer Immediate
 4479 operand immN() %{
 4480   match(ConN);
 4481 
 4482   op_cost(10);
 4483   format %{ %}
 4484   interface(CONST_INTER);
 4485 %}
 4486 
 4487 // NULL Pointer Immediate
 4488 operand immN_0() %{
 4489   predicate(n-&gt;get_narrowcon() == 0);
 4490   match(ConN);
 4491 
 4492   op_cost(0);
 4493   format %{ %}
 4494   interface(CONST_INTER);
 4495 %}
 4496 
 4497 // Compressed klass constants
 4498 operand immNKlass() %{
 4499   match(ConNKlass);
 4500 
 4501   op_cost(0);
 4502   format %{ %}
 4503   interface(CONST_INTER);
 4504 %}
 4505 
 4506 // This operand can be used to avoid matching of an instruct
 4507 // with chain rule.
 4508 operand immNKlass_NM() %{
 4509   match(ConNKlass);
 4510   predicate(false);
 4511   op_cost(0);
 4512   format %{ %}
 4513   interface(CONST_INTER);
 4514 %}
 4515 
 4516 // Pointer Immediate: 64-bit
 4517 operand immP() %{
 4518   match(ConP);
 4519   op_cost(0);
 4520   format %{ %}
 4521   interface(CONST_INTER);
 4522 %}
 4523 
 4524 // Operand to avoid match of loadConP.
 4525 // This operand can be used to avoid matching of an instruct
 4526 // with chain rule.
 4527 operand immP_NM() %{
 4528   match(ConP);
 4529   predicate(false);
 4530   op_cost(0);
 4531   format %{ %}
 4532   interface(CONST_INTER);
 4533 %}
 4534 
 4535 // costant &#39;pointer 0&#39;.
 4536 operand immP_0() %{
 4537   predicate(n-&gt;get_ptr() == 0);
 4538   match(ConP);
 4539   op_cost(0);
 4540   format %{ %}
 4541   interface(CONST_INTER);
 4542 %}
 4543 
 4544 // pointer 0x0 or 0x1
 4545 operand immP_0or1() %{
 4546   predicate((n-&gt;get_ptr() == 0) || (n-&gt;get_ptr() == 1));
 4547   match(ConP);
 4548   op_cost(0);
 4549   format %{ %}
 4550   interface(CONST_INTER);
 4551 %}
 4552 
 4553 operand immL() %{
 4554   match(ConL);
 4555   op_cost(40);
 4556   format %{ %}
 4557   interface(CONST_INTER);
 4558 %}
 4559 
 4560 operand immLmax30() %{
 4561   predicate((n-&gt;get_long() &lt;= 30));
 4562   match(ConL);
 4563   op_cost(0);
 4564   format %{ %}
 4565   interface(CONST_INTER);
 4566 %}
 4567 
 4568 // Long Immediate: 16-bit
 4569 operand immL16() %{
 4570   predicate(Assembler::is_simm(n-&gt;get_long(), 16));
 4571   match(ConL);
 4572   op_cost(0);
 4573   format %{ %}
 4574   interface(CONST_INTER);
 4575 %}
 4576 
 4577 // Long Immediate: 16-bit, 4-aligned
 4578 operand immL16Alg4() %{
 4579   predicate(Assembler::is_simm(n-&gt;get_long(), 16) &amp;&amp; ((n-&gt;get_long() &amp; 0x3) == 0));
 4580   match(ConL);
 4581   op_cost(0);
 4582   format %{ %}
 4583   interface(CONST_INTER);
 4584 %}
 4585 
 4586 // Long Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4587 operand immL32hi16() %{
 4588   predicate(Assembler::is_simm(n-&gt;get_long(), 32) &amp;&amp; ((n-&gt;get_long() &amp; 0xffffL) == 0L));
 4589   match(ConL);
 4590   op_cost(0);
 4591   format %{ %}
 4592   interface(CONST_INTER);
 4593 %}
 4594 
 4595 // Long Immediate: 32-bit
 4596 operand immL32() %{
 4597   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4598   match(ConL);
 4599   op_cost(0);
 4600   format %{ %}
 4601   interface(CONST_INTER);
 4602 %}
 4603 
 4604 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4605 operand immLhighest16() %{
 4606   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4607   match(ConL);
 4608   op_cost(0);
 4609   format %{ %}
 4610   interface(CONST_INTER);
 4611 %}
 4612 
 4613 operand immLnegpow2() %{
 4614   predicate(is_power_of_2((jlong)-(n-&gt;get_long())));
 4615   match(ConL);
 4616   op_cost(0);
 4617   format %{ %}
 4618   interface(CONST_INTER);
 4619 %}
 4620 
 4621 operand immLpow2minus1() %{
 4622   predicate(is_power_of_2((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;
 4623             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4624   match(ConL);
 4625   op_cost(0);
 4626   format %{ %}
 4627   interface(CONST_INTER);
 4628 %}
 4629 
 4630 // constant &#39;long 0&#39;.
 4631 operand immL_0() %{
 4632   predicate(n-&gt;get_long() == 0L);
 4633   match(ConL);
 4634   op_cost(0);
 4635   format %{ %}
 4636   interface(CONST_INTER);
 4637 %}
 4638 
 4639 // constat &#39; long -1&#39;.
 4640 operand immL_minus1() %{
 4641   predicate(n-&gt;get_long() == -1L);
 4642   match(ConL);
 4643   op_cost(0);
 4644   format %{ %}
 4645   interface(CONST_INTER);
 4646 %}
 4647 
 4648 // Long Immediate: low 32-bit mask
 4649 operand immL_32bits() %{
 4650   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 4651   match(ConL);
 4652   op_cost(0);
 4653   format %{ %}
 4654   interface(CONST_INTER);
 4655 %}
 4656 
 4657 // Unsigned Long Immediate: 16-bit
 4658 operand uimmL16() %{
 4659   predicate(Assembler::is_uimm(n-&gt;get_long(), 16));
 4660   match(ConL);
 4661   op_cost(0);
 4662   format %{ %}
 4663   interface(CONST_INTER);
 4664 %}
 4665 
 4666 // Float Immediate
 4667 operand immF() %{
 4668   match(ConF);
 4669   op_cost(40);
 4670   format %{ %}
 4671   interface(CONST_INTER);
 4672 %}
 4673 
 4674 // Float Immediate: +0.0f.
 4675 operand immF_0() %{
 4676   predicate(jint_cast(n-&gt;getf()) == 0);
 4677   match(ConF);
 4678 
 4679   op_cost(0);
 4680   format %{ %}
 4681   interface(CONST_INTER);
 4682 %}
 4683 
 4684 // Double Immediate
 4685 operand immD() %{
 4686   match(ConD);
 4687   op_cost(40);
 4688   format %{ %}
 4689   interface(CONST_INTER);
 4690 %}
 4691 
 4692 // Double Immediate: +0.0d.
 4693 operand immD_0() %{
 4694   predicate(jlong_cast(n-&gt;getd()) == 0);
 4695   match(ConD);
 4696 
 4697   op_cost(0);
 4698   format %{ %}
 4699   interface(CONST_INTER);
 4700 %}
 4701 
 4702 // Integer Register Operands
 4703 // Integer Destination Register
 4704 // See definition of reg_class bits32_reg_rw.
 4705 operand iRegIdst() %{
 4706   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4707   match(RegI);
 4708   match(rscratch1RegI);
 4709   match(rscratch2RegI);
 4710   match(rarg1RegI);
 4711   match(rarg2RegI);
 4712   match(rarg3RegI);
 4713   match(rarg4RegI);
 4714   format %{ %}
 4715   interface(REG_INTER);
 4716 %}
 4717 
 4718 // Integer Source Register
 4719 // See definition of reg_class bits32_reg_ro.
 4720 operand iRegIsrc() %{
 4721   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4722   match(RegI);
 4723   match(rscratch1RegI);
 4724   match(rscratch2RegI);
 4725   match(rarg1RegI);
 4726   match(rarg2RegI);
 4727   match(rarg3RegI);
 4728   match(rarg4RegI);
 4729   format %{ %}
 4730   interface(REG_INTER);
 4731 %}
 4732 
 4733 operand rscratch1RegI() %{
 4734   constraint(ALLOC_IN_RC(rscratch1_bits32_reg));
 4735   match(iRegIdst);
 4736   format %{ %}
 4737   interface(REG_INTER);
 4738 %}
 4739 
 4740 operand rscratch2RegI() %{
 4741   constraint(ALLOC_IN_RC(rscratch2_bits32_reg));
 4742   match(iRegIdst);
 4743   format %{ %}
 4744   interface(REG_INTER);
 4745 %}
 4746 
 4747 operand rarg1RegI() %{
 4748   constraint(ALLOC_IN_RC(rarg1_bits32_reg));
 4749   match(iRegIdst);
 4750   format %{ %}
 4751   interface(REG_INTER);
 4752 %}
 4753 
 4754 operand rarg2RegI() %{
 4755   constraint(ALLOC_IN_RC(rarg2_bits32_reg));
 4756   match(iRegIdst);
 4757   format %{ %}
 4758   interface(REG_INTER);
 4759 %}
 4760 
 4761 operand rarg3RegI() %{
 4762   constraint(ALLOC_IN_RC(rarg3_bits32_reg));
 4763   match(iRegIdst);
 4764   format %{ %}
 4765   interface(REG_INTER);
 4766 %}
 4767 
 4768 operand rarg4RegI() %{
 4769   constraint(ALLOC_IN_RC(rarg4_bits32_reg));
 4770   match(iRegIdst);
 4771   format %{ %}
 4772   interface(REG_INTER);
 4773 %}
 4774 
 4775 operand rarg1RegL() %{
 4776   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4777   match(iRegLdst);
 4778   format %{ %}
 4779   interface(REG_INTER);
 4780 %}
 4781 
 4782 operand rarg2RegL() %{
 4783   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4784   match(iRegLdst);
 4785   format %{ %}
 4786   interface(REG_INTER);
 4787 %}
 4788 
 4789 operand rarg3RegL() %{
 4790   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4791   match(iRegLdst);
 4792   format %{ %}
 4793   interface(REG_INTER);
 4794 %}
 4795 
 4796 operand rarg4RegL() %{
 4797   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4798   match(iRegLdst);
 4799   format %{ %}
 4800   interface(REG_INTER);
 4801 %}
 4802 
 4803 // Pointer Destination Register
 4804 // See definition of reg_class bits64_reg_rw.
 4805 operand iRegPdst() %{
 4806   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4807   match(RegP);
 4808   match(rscratch1RegP);
 4809   match(rscratch2RegP);
 4810   match(rarg1RegP);
 4811   match(rarg2RegP);
 4812   match(rarg3RegP);
 4813   match(rarg4RegP);
 4814   format %{ %}
 4815   interface(REG_INTER);
 4816 %}
 4817 
 4818 // Pointer Destination Register
 4819 // Operand not using r11 and r12 (killed in epilog).
 4820 operand iRegPdstNoScratch() %{
 4821   constraint(ALLOC_IN_RC(bits64_reg_leaf_call));
 4822   match(RegP);
 4823   match(rarg1RegP);
 4824   match(rarg2RegP);
 4825   match(rarg3RegP);
 4826   match(rarg4RegP);
 4827   format %{ %}
 4828   interface(REG_INTER);
 4829 %}
 4830 
 4831 // Pointer Source Register
 4832 // See definition of reg_class bits64_reg_ro.
 4833 operand iRegPsrc() %{
 4834   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4835   match(RegP);
 4836   match(iRegPdst);
 4837   match(rscratch1RegP);
 4838   match(rscratch2RegP);
 4839   match(rarg1RegP);
 4840   match(rarg2RegP);
 4841   match(rarg3RegP);
 4842   match(rarg4RegP);
 4843   match(threadRegP);
 4844   format %{ %}
 4845   interface(REG_INTER);
 4846 %}
 4847 
 4848 // Thread operand.
 4849 operand threadRegP() %{
 4850   constraint(ALLOC_IN_RC(thread_bits64_reg));
 4851   match(iRegPdst);
 4852   format %{ &quot;R16&quot; %}
 4853   interface(REG_INTER);
 4854 %}
 4855 
 4856 operand rscratch1RegP() %{
 4857   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4858   match(iRegPdst);
 4859   format %{ &quot;R11&quot; %}
 4860   interface(REG_INTER);
 4861 %}
 4862 
 4863 operand rscratch2RegP() %{
 4864   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4865   match(iRegPdst);
 4866   format %{ %}
 4867   interface(REG_INTER);
 4868 %}
 4869 
 4870 operand rarg1RegP() %{
 4871   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4872   match(iRegPdst);
 4873   format %{ %}
 4874   interface(REG_INTER);
 4875 %}
 4876 
 4877 operand rarg2RegP() %{
 4878   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4879   match(iRegPdst);
 4880   format %{ %}
 4881   interface(REG_INTER);
 4882 %}
 4883 
 4884 operand rarg3RegP() %{
 4885   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4886   match(iRegPdst);
 4887   format %{ %}
 4888   interface(REG_INTER);
 4889 %}
 4890 
 4891 operand rarg4RegP() %{
 4892   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4893   match(iRegPdst);
 4894   format %{ %}
 4895   interface(REG_INTER);
 4896 %}
 4897 
 4898 operand iRegNsrc() %{
 4899   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4900   match(RegN);
 4901   match(iRegNdst);
 4902 
 4903   format %{ %}
 4904   interface(REG_INTER);
 4905 %}
 4906 
 4907 operand iRegNdst() %{
 4908   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4909   match(RegN);
 4910 
 4911   format %{ %}
 4912   interface(REG_INTER);
 4913 %}
 4914 
 4915 // Long Destination Register
 4916 // See definition of reg_class bits64_reg_rw.
 4917 operand iRegLdst() %{
 4918   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4919   match(RegL);
 4920   match(rscratch1RegL);
 4921   match(rscratch2RegL);
 4922   format %{ %}
 4923   interface(REG_INTER);
 4924 %}
 4925 
 4926 // Long Source Register
 4927 // See definition of reg_class bits64_reg_ro.
 4928 operand iRegLsrc() %{
 4929   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4930   match(RegL);
 4931   match(iRegLdst);
 4932   match(rscratch1RegL);
 4933   match(rscratch2RegL);
 4934   format %{ %}
 4935   interface(REG_INTER);
 4936 %}
 4937 
 4938 // Special operand for ConvL2I.
 4939 operand iRegL2Isrc(iRegLsrc reg) %{
 4940   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4941   match(ConvL2I reg);
 4942   format %{ &quot;ConvL2I($reg)&quot; %}
 4943   interface(REG_INTER)
 4944 %}
 4945 
 4946 operand rscratch1RegL() %{
 4947   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4948   match(RegL);
 4949   format %{ %}
 4950   interface(REG_INTER);
 4951 %}
 4952 
 4953 operand rscratch2RegL() %{
 4954   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4955   match(RegL);
 4956   format %{ %}
 4957   interface(REG_INTER);
 4958 %}
 4959 
 4960 // Condition Code Flag Registers
 4961 operand flagsReg() %{
 4962   constraint(ALLOC_IN_RC(int_flags));
 4963   match(RegFlags);
 4964   format %{ %}
 4965   interface(REG_INTER);
 4966 %}
 4967 
 4968 operand flagsRegSrc() %{
 4969   constraint(ALLOC_IN_RC(int_flags_ro));
 4970   match(RegFlags);
 4971   match(flagsReg);
 4972   match(flagsRegCR0);
 4973   format %{ %}
 4974   interface(REG_INTER);
 4975 %}
 4976 
 4977 // Condition Code Flag Register CR0
 4978 operand flagsRegCR0() %{
 4979   constraint(ALLOC_IN_RC(int_flags_CR0));
 4980   match(RegFlags);
 4981   format %{ &quot;CR0&quot; %}
 4982   interface(REG_INTER);
 4983 %}
 4984 
 4985 operand flagsRegCR1() %{
 4986   constraint(ALLOC_IN_RC(int_flags_CR1));
 4987   match(RegFlags);
 4988   format %{ &quot;CR1&quot; %}
 4989   interface(REG_INTER);
 4990 %}
 4991 
 4992 operand flagsRegCR6() %{
 4993   constraint(ALLOC_IN_RC(int_flags_CR6));
 4994   match(RegFlags);
 4995   format %{ &quot;CR6&quot; %}
 4996   interface(REG_INTER);
 4997 %}
 4998 
 4999 operand regCTR() %{
 5000   constraint(ALLOC_IN_RC(ctr_reg));
 5001   // RegFlags should work. Introducing a RegSpecial type would cause a
 5002   // lot of changes.
 5003   match(RegFlags);
 5004   format %{&quot;SR_CTR&quot; %}
 5005   interface(REG_INTER);
 5006 %}
 5007 
 5008 operand regD() %{
 5009   constraint(ALLOC_IN_RC(dbl_reg));
 5010   match(RegD);
 5011   format %{ %}
 5012   interface(REG_INTER);
 5013 %}
 5014 
 5015 operand regF() %{
 5016   constraint(ALLOC_IN_RC(flt_reg));
 5017   match(RegF);
 5018   format %{ %}
 5019   interface(REG_INTER);
 5020 %}
 5021 
 5022 // Special Registers
 5023 
 5024 // Method Register
 5025 operand inline_cache_regP(iRegPdst reg) %{
 5026   constraint(ALLOC_IN_RC(r19_bits64_reg)); // inline_cache_reg
 5027   match(reg);
 5028   format %{ %}
 5029   interface(REG_INTER);
 5030 %}
 5031 
 5032 operand compiler_method_oop_regP(iRegPdst reg) %{
 5033   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
 5034   match(reg);
 5035   format %{ %}
 5036   interface(REG_INTER);
 5037 %}
 5038 
 5039 operand interpreter_method_oop_regP(iRegPdst reg) %{
 5040   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
 5041   match(reg);
 5042   format %{ %}
 5043   interface(REG_INTER);
 5044 %}
 5045 
 5046 // Operands to remove register moves in unscaled mode.
 5047 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 5048 operand iRegP2N(iRegPsrc reg) %{
 5049   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; CompressedOops::shift() == 0);
 5050   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5051   match(EncodeP reg);
 5052   format %{ &quot;$reg&quot; %}
 5053   interface(REG_INTER)
 5054 %}
 5055 
 5056 operand iRegN2P(iRegNsrc reg) %{
 5057   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5058   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5059   match(DecodeN reg);
 5060   format %{ &quot;$reg&quot; %}
 5061   interface(REG_INTER)
 5062 %}
 5063 
 5064 operand iRegN2P_klass(iRegNsrc reg) %{
 5065   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5066   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5067   match(DecodeNKlass reg);
 5068   format %{ &quot;$reg&quot; %}
 5069   interface(REG_INTER)
 5070 %}
 5071 
 5072 //----------Complex Operands---------------------------------------------------
 5073 // Indirect Memory Reference
 5074 operand indirect(iRegPsrc reg) %{
 5075   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5076   match(reg);
 5077   op_cost(100);
 5078   format %{ &quot;[$reg]&quot; %}
 5079   interface(MEMORY_INTER) %{
 5080     base($reg);
 5081     index(0x0);
 5082     scale(0x0);
 5083     disp(0x0);
 5084   %}
 5085 %}
 5086 
 5087 // Indirect with Offset
 5088 operand indOffset16(iRegPsrc reg, immL16 offset) %{
 5089   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5090   match(AddP reg offset);
 5091   op_cost(100);
 5092   format %{ &quot;[$reg + $offset]&quot; %}
 5093   interface(MEMORY_INTER) %{
 5094     base($reg);
 5095     index(0x0);
 5096     scale(0x0);
 5097     disp($offset);
 5098   %}
 5099 %}
 5100 
 5101 // Indirect with 4-aligned Offset
 5102 operand indOffset16Alg4(iRegPsrc reg, immL16Alg4 offset) %{
 5103   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5104   match(AddP reg offset);
 5105   op_cost(100);
 5106   format %{ &quot;[$reg + $offset]&quot; %}
 5107   interface(MEMORY_INTER) %{
 5108     base($reg);
 5109     index(0x0);
 5110     scale(0x0);
 5111     disp($offset);
 5112   %}
 5113 %}
 5114 
 5115 //----------Complex Operands for Compressed OOPs-------------------------------
 5116 // Compressed OOPs with narrow_oop_shift == 0.
 5117 
 5118 // Indirect Memory Reference, compressed OOP
 5119 operand indirectNarrow(iRegNsrc reg) %{
 5120   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5121   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5122   match(DecodeN reg);
 5123   op_cost(100);
 5124   format %{ &quot;[$reg]&quot; %}
 5125   interface(MEMORY_INTER) %{
 5126     base($reg);
 5127     index(0x0);
 5128     scale(0x0);
 5129     disp(0x0);
 5130   %}
 5131 %}
 5132 
 5133 operand indirectNarrow_klass(iRegNsrc reg) %{
 5134   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5135   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5136   match(DecodeNKlass reg);
 5137   op_cost(100);
 5138   format %{ &quot;[$reg]&quot; %}
 5139   interface(MEMORY_INTER) %{
 5140     base($reg);
 5141     index(0x0);
 5142     scale(0x0);
 5143     disp(0x0);
 5144   %}
 5145 %}
 5146 
 5147 // Indirect with Offset, compressed OOP
 5148 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
 5149   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5150   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5151   match(AddP (DecodeN reg) offset);
 5152   op_cost(100);
 5153   format %{ &quot;[$reg + $offset]&quot; %}
 5154   interface(MEMORY_INTER) %{
 5155     base($reg);
 5156     index(0x0);
 5157     scale(0x0);
 5158     disp($offset);
 5159   %}
 5160 %}
 5161 
 5162 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
 5163   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5164   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5165   match(AddP (DecodeNKlass reg) offset);
 5166   op_cost(100);
 5167   format %{ &quot;[$reg + $offset]&quot; %}
 5168   interface(MEMORY_INTER) %{
 5169     base($reg);
 5170     index(0x0);
 5171     scale(0x0);
 5172     disp($offset);
 5173   %}
 5174 %}
 5175 
 5176 // Indirect with 4-aligned Offset, compressed OOP
 5177 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
 5178   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5179   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5180   match(AddP (DecodeN reg) offset);
 5181   op_cost(100);
 5182   format %{ &quot;[$reg + $offset]&quot; %}
 5183   interface(MEMORY_INTER) %{
 5184     base($reg);
 5185     index(0x0);
 5186     scale(0x0);
 5187     disp($offset);
 5188   %}
 5189 %}
 5190 
 5191 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
 5192   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5193   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5194   match(AddP (DecodeNKlass reg) offset);
 5195   op_cost(100);
 5196   format %{ &quot;[$reg + $offset]&quot; %}
 5197   interface(MEMORY_INTER) %{
 5198     base($reg);
 5199     index(0x0);
 5200     scale(0x0);
 5201     disp($offset);
 5202   %}
 5203 %}
 5204 
 5205 //----------Special Memory Operands--------------------------------------------
 5206 // Stack Slot Operand
 5207 //
 5208 // This operand is used for loading and storing temporary values on
 5209 // the stack where a match requires a value to flow through memory.
 5210 operand stackSlotI(sRegI reg) %{
 5211   constraint(ALLOC_IN_RC(stack_slots));
 5212   op_cost(100);
 5213   //match(RegI);
 5214   format %{ &quot;[sp+$reg]&quot; %}
 5215   interface(MEMORY_INTER) %{
 5216     base(0x1);   // R1_SP
 5217     index(0x0);
 5218     scale(0x0);
 5219     disp($reg);  // Stack Offset
 5220   %}
 5221 %}
 5222 
 5223 operand stackSlotL(sRegL reg) %{
 5224   constraint(ALLOC_IN_RC(stack_slots));
 5225   op_cost(100);
 5226   //match(RegL);
 5227   format %{ &quot;[sp+$reg]&quot; %}
 5228   interface(MEMORY_INTER) %{
 5229     base(0x1);   // R1_SP
 5230     index(0x0);
 5231     scale(0x0);
 5232     disp($reg);  // Stack Offset
 5233   %}
 5234 %}
 5235 
 5236 operand stackSlotP(sRegP reg) %{
 5237   constraint(ALLOC_IN_RC(stack_slots));
 5238   op_cost(100);
 5239   //match(RegP);
 5240   format %{ &quot;[sp+$reg]&quot; %}
 5241   interface(MEMORY_INTER) %{
 5242     base(0x1);   // R1_SP
 5243     index(0x0);
 5244     scale(0x0);
 5245     disp($reg);  // Stack Offset
 5246   %}
 5247 %}
 5248 
 5249 operand stackSlotF(sRegF reg) %{
 5250   constraint(ALLOC_IN_RC(stack_slots));
 5251   op_cost(100);
 5252   //match(RegF);
 5253   format %{ &quot;[sp+$reg]&quot; %}
 5254   interface(MEMORY_INTER) %{
 5255     base(0x1);   // R1_SP
 5256     index(0x0);
 5257     scale(0x0);
 5258     disp($reg);  // Stack Offset
 5259   %}
 5260 %}
 5261 
 5262 operand stackSlotD(sRegD reg) %{
 5263   constraint(ALLOC_IN_RC(stack_slots));
 5264   op_cost(100);
 5265   //match(RegD);
 5266   format %{ &quot;[sp+$reg]&quot; %}
 5267   interface(MEMORY_INTER) %{
 5268     base(0x1);   // R1_SP
 5269     index(0x0);
 5270     scale(0x0);
 5271     disp($reg);  // Stack Offset
 5272   %}
 5273 %}
 5274 
 5275 // Operands for expressing Control Flow
 5276 // NOTE: Label is a predefined operand which should not be redefined in
 5277 //       the AD file. It is generically handled within the ADLC.
 5278 
 5279 //----------Conditional Branch Operands----------------------------------------
 5280 // Comparison Op
 5281 //
 5282 // This is the operation of the comparison, and is limited to the
 5283 // following set of codes: L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE
 5284 // (!=).
 5285 //
 5286 // Other attributes of the comparison, such as unsignedness, are specified
 5287 // by the comparison instruction that sets a condition code flags register.
 5288 // That result is represented by a flags operand whose subtype is appropriate
 5289 // to the unsignedness (etc.) of the comparison.
 5290 //
 5291 // Later, the instruction which matches both the Comparison Op (a Bool) and
 5292 // the flags (produced by the Cmp) specifies the coding of the comparison op
 5293 // by matching a specific subtype of Bool operand below.
 5294 
 5295 // When used for floating point comparisons: unordered same as less.
 5296 operand cmpOp() %{
 5297   match(Bool);
 5298   format %{ &quot;&quot; %}
 5299   interface(COND_INTER) %{
 5300                            // BO only encodes bit 4 of bcondCRbiIsX, as bits 1-3 are always &#39;100&#39;.
 5301                            //           BO          &amp;  BI
 5302     equal(0xA);            // 10 10:   bcondCRbiIs1 &amp; Condition::equal
 5303     not_equal(0x2);        // 00 10:   bcondCRbiIs0 &amp; Condition::equal
 5304     less(0x8);             // 10 00:   bcondCRbiIs1 &amp; Condition::less
 5305     greater_equal(0x0);    // 00 00:   bcondCRbiIs0 &amp; Condition::less
 5306     less_equal(0x1);       // 00 01:   bcondCRbiIs0 &amp; Condition::greater
 5307     greater(0x9);          // 10 01:   bcondCRbiIs1 &amp; Condition::greater
 5308     overflow(0xB);         // 10 11:   bcondCRbiIs1 &amp; Condition::summary_overflow
 5309     no_overflow(0x3);      // 00 11:   bcondCRbiIs0 &amp; Condition::summary_overflow
 5310   %}
 5311 %}
 5312 
 5313 //----------OPERAND CLASSES----------------------------------------------------
 5314 // Operand Classes are groups of operands that are used to simplify
 5315 // instruction definitions by not requiring the AD writer to specify
 5316 // seperate instructions for every form of operand when the
 5317 // instruction accepts multiple operand types with the same basic
 5318 // encoding and format. The classic case of this is memory operands.
 5319 // Indirect is not included since its use is limited to Compare &amp; Swap.
 5320 
 5321 opclass memory(indirect, indOffset16 /*, indIndex, tlsReference*/, indirectNarrow, indirectNarrow_klass, indOffset16Narrow, indOffset16Narrow_klass);
 5322 // Memory operand where offsets are 4-aligned. Required for ld, std.
 5323 opclass memoryAlg4(indirect, indOffset16Alg4, indirectNarrow, indOffset16NarrowAlg4, indOffset16NarrowAlg4_klass);
 5324 opclass indirectMemory(indirect, indirectNarrow);
 5325 
 5326 // Special opclass for I and ConvL2I.
 5327 opclass iRegIsrc_iRegL2Isrc(iRegIsrc, iRegL2Isrc);
 5328 
 5329 // Operand classes to match encode and decode. iRegN_P2N is only used
 5330 // for storeN. I have never seen an encode node elsewhere.
 5331 opclass iRegN_P2N(iRegNsrc, iRegP2N);
 5332 opclass iRegP_N2P(iRegPsrc, iRegN2P, iRegN2P_klass);
 5333 
 5334 //----------PIPELINE-----------------------------------------------------------
 5335 
 5336 pipeline %{
 5337 
 5338 // See J.M.Tendler et al. &quot;Power4 system microarchitecture&quot;, IBM
 5339 // J. Res. &amp; Dev., No. 1, Jan. 2002.
 5340 
 5341 //----------ATTRIBUTES---------------------------------------------------------
 5342 attributes %{
 5343 
 5344   // Power4 instructions are of fixed length.
 5345   fixed_size_instructions;
 5346 
 5347   // TODO: if `bundle&#39; means number of instructions fetched
 5348   // per cycle, this is 8. If `bundle&#39; means Power4 `group&#39;, that is
 5349   // max instructions issued per cycle, this is 5.
 5350   max_instructions_per_bundle = 8;
 5351 
 5352   // A Power4 instruction is 4 bytes long.
 5353   instruction_unit_size = 4;
 5354 
 5355   // The Power4 processor fetches 64 bytes...
 5356   instruction_fetch_unit_size = 64;
 5357 
 5358   // ...in one line
 5359   instruction_fetch_units = 1
 5360 
 5361   // Unused, list one so that array generated by adlc is not empty.
 5362   // Aix compiler chokes if _nop_count = 0.
 5363   nops(fxNop);
 5364 %}
 5365 
 5366 //----------RESOURCES----------------------------------------------------------
 5367 // Resources are the functional units available to the machine
 5368 resources(
 5369    PPC_BR,         // branch unit
 5370    PPC_CR,         // condition unit
 5371    PPC_FX1,        // integer arithmetic unit 1
 5372    PPC_FX2,        // integer arithmetic unit 2
 5373    PPC_LDST1,      // load/store unit 1
 5374    PPC_LDST2,      // load/store unit 2
 5375    PPC_FP1,        // float arithmetic unit 1
 5376    PPC_FP2,        // float arithmetic unit 2
 5377    PPC_LDST = PPC_LDST1 | PPC_LDST2,
 5378    PPC_FX = PPC_FX1 | PPC_FX2,
 5379    PPC_FP = PPC_FP1 | PPC_FP2
 5380  );
 5381 
 5382 //----------PIPELINE DESCRIPTION-----------------------------------------------
 5383 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 5384 pipe_desc(
 5385    // Power4 longest pipeline path
 5386    PPC_IF,   // instruction fetch
 5387    PPC_IC,
 5388    //PPC_BP, // branch prediction
 5389    PPC_D0,   // decode
 5390    PPC_D1,   // decode
 5391    PPC_D2,   // decode
 5392    PPC_D3,   // decode
 5393    PPC_Xfer1,
 5394    PPC_GD,   // group definition
 5395    PPC_MP,   // map
 5396    PPC_ISS,  // issue
 5397    PPC_RF,   // resource fetch
 5398    PPC_EX1,  // execute (all units)
 5399    PPC_EX2,  // execute (FP, LDST)
 5400    PPC_EX3,  // execute (FP, LDST)
 5401    PPC_EX4,  // execute (FP)
 5402    PPC_EX5,  // execute (FP)
 5403    PPC_EX6,  // execute (FP)
 5404    PPC_WB,   // write back
 5405    PPC_Xfer2,
 5406    PPC_CP
 5407  );
 5408 
 5409 //----------PIPELINE CLASSES---------------------------------------------------
 5410 // Pipeline Classes describe the stages in which input and output are
 5411 // referenced by the hardware pipeline.
 5412 
 5413 // Simple pipeline classes.
 5414 
 5415 // Default pipeline class.
 5416 pipe_class pipe_class_default() %{
 5417   single_instruction;
 5418   fixed_latency(2);
 5419 %}
 5420 
 5421 // Pipeline class for empty instructions.
 5422 pipe_class pipe_class_empty() %{
 5423   single_instruction;
 5424   fixed_latency(0);
 5425 %}
 5426 
 5427 // Pipeline class for compares.
 5428 pipe_class pipe_class_compare() %{
 5429   single_instruction;
 5430   fixed_latency(16);
 5431 %}
 5432 
 5433 // Pipeline class for traps.
 5434 pipe_class pipe_class_trap() %{
 5435   single_instruction;
 5436   fixed_latency(100);
 5437 %}
 5438 
 5439 // Pipeline class for memory operations.
 5440 pipe_class pipe_class_memory() %{
 5441   single_instruction;
 5442   fixed_latency(16);
 5443 %}
 5444 
 5445 // Pipeline class for call.
 5446 pipe_class pipe_class_call() %{
 5447   single_instruction;
 5448   fixed_latency(100);
 5449 %}
 5450 
 5451 // Define the class for the Nop node.
 5452 define %{
 5453    MachNop = pipe_class_default;
 5454 %}
 5455 
 5456 %}
 5457 
 5458 //----------INSTRUCTIONS-------------------------------------------------------
 5459 
 5460 // Naming of instructions:
 5461 //   opA_operB / opA_operB_operC:
 5462 //     Operation &#39;op&#39; with one or two source operands &#39;oper&#39;. Result
 5463 //     type is A, source operand types are B and C.
 5464 //     Iff A == B == C, B and C are left out.
 5465 //
 5466 // The instructions are ordered according to the following scheme:
 5467 //  - loads
 5468 //  - load constants
 5469 //  - prefetch
 5470 //  - store
 5471 //  - encode/decode
 5472 //  - membar
 5473 //  - conditional moves
 5474 //  - compare &amp; swap
 5475 //  - arithmetic and logic operations
 5476 //    * int: Add, Sub, Mul, Div, Mod
 5477 //    * int: lShift, arShift, urShift, rot
 5478 //    * float: Add, Sub, Mul, Div
 5479 //    * and, or, xor ...
 5480 //  - register moves: float &lt;-&gt; int, reg &lt;-&gt; stack, repl
 5481 //  - cast (high level type cast, XtoP, castPP, castII, not_null etc.
 5482 //  - conv (low level type cast requiring bit changes (sign extend etc)
 5483 //  - compares, range &amp; zero checks.
 5484 //  - branches
 5485 //  - complex operations, intrinsics, min, max, replicate
 5486 //  - lock
 5487 //  - Calls
 5488 //
 5489 // If there are similar instructions with different types they are sorted:
 5490 // int before float
 5491 // small before big
 5492 // signed before unsigned
 5493 // e.g., loadS before loadUS before loadI before loadF.
 5494 
 5495 
 5496 //----------Load/Store Instructions--------------------------------------------
 5497 
 5498 //----------Load Instructions--------------------------------------------------
 5499 
 5500 // Converts byte to int.
 5501 // As convB2I_reg, but without match rule.  The match rule of convB2I_reg
 5502 // reuses the &#39;amount&#39; operand, but adlc expects that operand specification
 5503 // and operands in match rule are equivalent.
 5504 instruct convB2I_reg_2(iRegIdst dst, iRegIsrc src) %{
 5505   effect(DEF dst, USE src);
 5506   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
 5507   size(4);
 5508   ins_encode %{
 5509     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
 5510     __ extsb($dst$$Register, $src$$Register);
 5511   %}
 5512   ins_pipe(pipe_class_default);
 5513 %}
 5514 
 5515 instruct loadUB_indirect(iRegIdst dst, indirectMemory mem) %{
 5516   // match-rule, false predicate
 5517   match(Set dst (LoadB mem));
 5518   predicate(false);
 5519 
 5520   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5521   size(4);
 5522   ins_encode( enc_lbz(dst, mem) );
 5523   ins_pipe(pipe_class_memory);
 5524 %}
 5525 
 5526 instruct loadUB_indirect_ac(iRegIdst dst, indirectMemory mem) %{
 5527   // match-rule, false predicate
 5528   match(Set dst (LoadB mem));
 5529   predicate(false);
 5530 
 5531   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5532             &quot;TWI     $dst\n\t&quot;
 5533             &quot;ISYNC&quot; %}
 5534   size(12);
 5535   ins_encode( enc_lbz_ac(dst, mem) );
 5536   ins_pipe(pipe_class_memory);
 5537 %}
 5538 
 5539 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5540 instruct loadB_indirect_Ex(iRegIdst dst, indirectMemory mem) %{
 5541   match(Set dst (LoadB mem));
 5542   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5543   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5544   expand %{
 5545     iRegIdst tmp;
 5546     loadUB_indirect(tmp, mem);
 5547     convB2I_reg_2(dst, tmp);
 5548   %}
 5549 %}
 5550 
 5551 instruct loadB_indirect_ac_Ex(iRegIdst dst, indirectMemory mem) %{
 5552   match(Set dst (LoadB mem));
 5553   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5554   expand %{
 5555     iRegIdst tmp;
 5556     loadUB_indirect_ac(tmp, mem);
 5557     convB2I_reg_2(dst, tmp);
 5558   %}
 5559 %}
 5560 
 5561 instruct loadUB_indOffset16(iRegIdst dst, indOffset16 mem) %{
 5562   // match-rule, false predicate
 5563   match(Set dst (LoadB mem));
 5564   predicate(false);
 5565 
 5566   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5567   size(4);
 5568   ins_encode( enc_lbz(dst, mem) );
 5569   ins_pipe(pipe_class_memory);
 5570 %}
 5571 
 5572 instruct loadUB_indOffset16_ac(iRegIdst dst, indOffset16 mem) %{
 5573   // match-rule, false predicate
 5574   match(Set dst (LoadB mem));
 5575   predicate(false);
 5576 
 5577   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5578             &quot;TWI     $dst\n\t&quot;
 5579             &quot;ISYNC&quot; %}
 5580   size(12);
 5581   ins_encode( enc_lbz_ac(dst, mem) );
 5582   ins_pipe(pipe_class_memory);
 5583 %}
 5584 
 5585 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5586 instruct loadB_indOffset16_Ex(iRegIdst dst, indOffset16 mem) %{
 5587   match(Set dst (LoadB mem));
 5588   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5589   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5590 
 5591   expand %{
 5592     iRegIdst tmp;
 5593     loadUB_indOffset16(tmp, mem);
 5594     convB2I_reg_2(dst, tmp);
 5595   %}
 5596 %}
 5597 
 5598 instruct loadB_indOffset16_ac_Ex(iRegIdst dst, indOffset16 mem) %{
 5599   match(Set dst (LoadB mem));
 5600   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5601 
 5602   expand %{
 5603     iRegIdst tmp;
 5604     loadUB_indOffset16_ac(tmp, mem);
 5605     convB2I_reg_2(dst, tmp);
 5606   %}
 5607 %}
 5608 
 5609 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 5610 instruct loadUB(iRegIdst dst, memory mem) %{
 5611   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5612   match(Set dst (LoadUB mem));
 5613   ins_cost(MEMORY_REF_COST);
 5614 
 5615   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int&quot; %}
 5616   size(4);
 5617   ins_encode( enc_lbz(dst, mem) );
 5618   ins_pipe(pipe_class_memory);
 5619 %}
 5620 
 5621 // Load  Unsigned Byte (8bit UNsigned) acquire.
 5622 instruct loadUB_ac(iRegIdst dst, memory mem) %{
 5623   match(Set dst (LoadUB mem));
 5624   ins_cost(3*MEMORY_REF_COST);
 5625 
 5626   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int, acquire\n\t&quot;
 5627             &quot;TWI     $dst\n\t&quot;
 5628             &quot;ISYNC&quot; %}
 5629   size(12);
 5630   ins_encode( enc_lbz_ac(dst, mem) );
 5631   ins_pipe(pipe_class_memory);
 5632 %}
 5633 
 5634 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 5635 instruct loadUB2L(iRegLdst dst, memory mem) %{
 5636   match(Set dst (ConvI2L (LoadUB mem)));
 5637   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5638   ins_cost(MEMORY_REF_COST);
 5639 
 5640   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long&quot; %}
 5641   size(4);
 5642   ins_encode( enc_lbz(dst, mem) );
 5643   ins_pipe(pipe_class_memory);
 5644 %}
 5645 
 5646 instruct loadUB2L_ac(iRegLdst dst, memory mem) %{
 5647   match(Set dst (ConvI2L (LoadUB mem)));
 5648   ins_cost(3*MEMORY_REF_COST);
 5649 
 5650   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long, acquire\n\t&quot;
 5651             &quot;TWI     $dst\n\t&quot;
 5652             &quot;ISYNC&quot; %}
 5653   size(12);
 5654   ins_encode( enc_lbz_ac(dst, mem) );
 5655   ins_pipe(pipe_class_memory);
 5656 %}
 5657 
 5658 // Load Short (16bit signed)
 5659 instruct loadS(iRegIdst dst, memory mem) %{
 5660   match(Set dst (LoadS mem));
 5661   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5662   ins_cost(MEMORY_REF_COST);
 5663 
 5664   format %{ &quot;LHA     $dst, $mem&quot; %}
 5665   size(4);
 5666   ins_encode %{
 5667     // TODO: PPC port $archOpcode(ppc64Opcode_lha);
 5668     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5669     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5670   %}
 5671   ins_pipe(pipe_class_memory);
 5672 %}
 5673 
 5674 // Load Short (16bit signed) acquire.
 5675 instruct loadS_ac(iRegIdst dst, memory mem) %{
 5676   match(Set dst (LoadS mem));
 5677   ins_cost(3*MEMORY_REF_COST);
 5678 
 5679   format %{ &quot;LHA     $dst, $mem\t acquire\n\t&quot;
 5680             &quot;TWI     $dst\n\t&quot;
 5681             &quot;ISYNC&quot; %}
 5682   size(12);
 5683   ins_encode %{
 5684     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 5685     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5686     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5687     __ twi_0($dst$$Register);
 5688     __ isync();
 5689   %}
 5690   ins_pipe(pipe_class_memory);
 5691 %}
 5692 
 5693 // Load Char (16bit unsigned)
 5694 instruct loadUS(iRegIdst dst, memory mem) %{
 5695   match(Set dst (LoadUS mem));
 5696   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5697   ins_cost(MEMORY_REF_COST);
 5698 
 5699   format %{ &quot;LHZ     $dst, $mem&quot; %}
 5700   size(4);
 5701   ins_encode( enc_lhz(dst, mem) );
 5702   ins_pipe(pipe_class_memory);
 5703 %}
 5704 
 5705 // Load Char (16bit unsigned) acquire.
 5706 instruct loadUS_ac(iRegIdst dst, memory mem) %{
 5707   match(Set dst (LoadUS mem));
 5708   ins_cost(3*MEMORY_REF_COST);
 5709 
 5710   format %{ &quot;LHZ     $dst, $mem \t// acquire\n\t&quot;
 5711             &quot;TWI     $dst\n\t&quot;
 5712             &quot;ISYNC&quot; %}
 5713   size(12);
 5714   ins_encode( enc_lhz_ac(dst, mem) );
 5715   ins_pipe(pipe_class_memory);
 5716 %}
 5717 
 5718 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 5719 instruct loadUS2L(iRegLdst dst, memory mem) %{
 5720   match(Set dst (ConvI2L (LoadUS mem)));
 5721   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5722   ins_cost(MEMORY_REF_COST);
 5723 
 5724   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long&quot; %}
 5725   size(4);
 5726   ins_encode( enc_lhz(dst, mem) );
 5727   ins_pipe(pipe_class_memory);
 5728 %}
 5729 
 5730 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register acquire.
 5731 instruct loadUS2L_ac(iRegLdst dst, memory mem) %{
 5732   match(Set dst (ConvI2L (LoadUS mem)));
 5733   ins_cost(3*MEMORY_REF_COST);
 5734 
 5735   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long, acquire\n\t&quot;
 5736             &quot;TWI     $dst\n\t&quot;
 5737             &quot;ISYNC&quot; %}
 5738   size(12);
 5739   ins_encode( enc_lhz_ac(dst, mem) );
 5740   ins_pipe(pipe_class_memory);
 5741 %}
 5742 
 5743 // Load Integer.
 5744 instruct loadI(iRegIdst dst, memory mem) %{
 5745   match(Set dst (LoadI mem));
 5746   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5747   ins_cost(MEMORY_REF_COST);
 5748 
 5749   format %{ &quot;LWZ     $dst, $mem&quot; %}
 5750   size(4);
 5751   ins_encode( enc_lwz(dst, mem) );
 5752   ins_pipe(pipe_class_memory);
 5753 %}
 5754 
 5755 // Load Integer acquire.
 5756 instruct loadI_ac(iRegIdst dst, memory mem) %{
 5757   match(Set dst (LoadI mem));
 5758   ins_cost(3*MEMORY_REF_COST);
 5759 
 5760   format %{ &quot;LWZ     $dst, $mem \t// load acquire\n\t&quot;
 5761             &quot;TWI     $dst\n\t&quot;
 5762             &quot;ISYNC&quot; %}
 5763   size(12);
 5764   ins_encode( enc_lwz_ac(dst, mem) );
 5765   ins_pipe(pipe_class_memory);
 5766 %}
 5767 
 5768 // Match loading integer and casting it to unsigned int in
 5769 // long register.
 5770 // LoadI + ConvI2L + AndL 0xffffffff.
 5771 instruct loadUI2L(iRegLdst dst, memory mem, immL_32bits mask) %{
 5772   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5773   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5774   ins_cost(MEMORY_REF_COST);
 5775 
 5776   format %{ &quot;LWZ     $dst, $mem \t// zero-extend to long&quot; %}
 5777   size(4);
 5778   ins_encode( enc_lwz(dst, mem) );
 5779   ins_pipe(pipe_class_memory);
 5780 %}
 5781 
 5782 // Match loading integer and casting it to long.
 5783 instruct loadI2L(iRegLdst dst, memoryAlg4 mem) %{
 5784   match(Set dst (ConvI2L (LoadI mem)));
 5785   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5786   ins_cost(MEMORY_REF_COST);
 5787 
 5788   format %{ &quot;LWA     $dst, $mem \t// loadI2L&quot; %}
 5789   size(4);
 5790   ins_encode %{
 5791     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5792     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5793     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5794   %}
 5795   ins_pipe(pipe_class_memory);
 5796 %}
 5797 
 5798 // Match loading integer and casting it to long - acquire.
 5799 instruct loadI2L_ac(iRegLdst dst, memoryAlg4 mem) %{
 5800   match(Set dst (ConvI2L (LoadI mem)));
 5801   ins_cost(3*MEMORY_REF_COST);
 5802 
 5803   format %{ &quot;LWA     $dst, $mem \t// loadI2L acquire&quot;
 5804             &quot;TWI     $dst\n\t&quot;
 5805             &quot;ISYNC&quot; %}
 5806   size(12);
 5807   ins_encode %{
 5808     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5809     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5810     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5811     __ twi_0($dst$$Register);
 5812     __ isync();
 5813   %}
 5814   ins_pipe(pipe_class_memory);
 5815 %}
 5816 
 5817 // Load Long - aligned
 5818 instruct loadL(iRegLdst dst, memoryAlg4 mem) %{
 5819   match(Set dst (LoadL mem));
 5820   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5821   ins_cost(MEMORY_REF_COST);
 5822 
 5823   format %{ &quot;LD      $dst, $mem \t// long&quot; %}
 5824   size(4);
 5825   ins_encode( enc_ld(dst, mem) );
 5826   ins_pipe(pipe_class_memory);
 5827 %}
 5828 
 5829 // Load Long - aligned acquire.
 5830 instruct loadL_ac(iRegLdst dst, memoryAlg4 mem) %{
 5831   match(Set dst (LoadL mem));
 5832   ins_cost(3*MEMORY_REF_COST);
 5833 
 5834   format %{ &quot;LD      $dst, $mem \t// long acquire\n\t&quot;
 5835             &quot;TWI     $dst\n\t&quot;
 5836             &quot;ISYNC&quot; %}
 5837   size(12);
 5838   ins_encode( enc_ld_ac(dst, mem) );
 5839   ins_pipe(pipe_class_memory);
 5840 %}
 5841 
 5842 // Load Long - UNaligned
 5843 instruct loadL_unaligned(iRegLdst dst, memoryAlg4 mem) %{
 5844   match(Set dst (LoadL_unaligned mem));
 5845   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 5846   ins_cost(MEMORY_REF_COST);
 5847 
 5848   format %{ &quot;LD      $dst, $mem \t// unaligned long&quot; %}
 5849   size(4);
 5850   ins_encode( enc_ld(dst, mem) );
 5851   ins_pipe(pipe_class_memory);
 5852 %}
 5853 
 5854 // Load nodes for superwords
 5855 
 5856 // Load Aligned Packed Byte
 5857 instruct loadV8(iRegLdst dst, memoryAlg4 mem) %{
 5858   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
 5859   match(Set dst (LoadVector mem));
 5860   ins_cost(MEMORY_REF_COST);
 5861 
 5862   format %{ &quot;LD      $dst, $mem \t// load 8-byte Vector&quot; %}
 5863   size(4);
 5864   ins_encode( enc_ld(dst, mem) );
 5865   ins_pipe(pipe_class_memory);
 5866 %}
 5867 
 5868 // Load Aligned Packed Byte
 5869 instruct loadV16(vecX dst, indirect mem) %{
 5870   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 16);
 5871   match(Set dst (LoadVector mem));
 5872   ins_cost(MEMORY_REF_COST);
 5873 
 5874   format %{ &quot;LXVD2X      $dst, $mem \t// load 16-byte Vector&quot; %}
 5875   size(4);
 5876   ins_encode %{
 5877     __ lxvd2x($dst$$VectorSRegister, $mem$$Register);
 5878   %}
 5879   ins_pipe(pipe_class_default);
 5880 %}
 5881 
 5882 // Load Range, range = array length (=jint)
 5883 instruct loadRange(iRegIdst dst, memory mem) %{
 5884   match(Set dst (LoadRange mem));
 5885   ins_cost(MEMORY_REF_COST);
 5886 
 5887   format %{ &quot;LWZ     $dst, $mem \t// range&quot; %}
 5888   size(4);
 5889   ins_encode( enc_lwz(dst, mem) );
 5890   ins_pipe(pipe_class_memory);
 5891 %}
 5892 
 5893 // Load Compressed Pointer
 5894 instruct loadN(iRegNdst dst, memory mem) %{
 5895   match(Set dst (LoadN mem));
 5896   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5897   ins_cost(MEMORY_REF_COST);
 5898 
 5899   format %{ &quot;LWZ     $dst, $mem \t// load compressed ptr&quot; %}
 5900   size(4);
 5901   ins_encode( enc_lwz(dst, mem) );
 5902   ins_pipe(pipe_class_memory);
 5903 %}
 5904 
 5905 // Load Compressed Pointer acquire.
 5906 instruct loadN_ac(iRegNdst dst, memory mem) %{
 5907   match(Set dst (LoadN mem));
 5908   ins_cost(3*MEMORY_REF_COST);
 5909 
 5910   format %{ &quot;LWZ     $dst, $mem \t// load acquire compressed ptr\n\t&quot;
 5911             &quot;TWI     $dst\n\t&quot;
 5912             &quot;ISYNC&quot; %}
 5913   size(12);
 5914   ins_encode( enc_lwz_ac(dst, mem) );
 5915   ins_pipe(pipe_class_memory);
 5916 %}
 5917 
 5918 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 5919 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
 5920   match(Set dst (DecodeN (LoadN mem)));
 5921   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; CompressedOops::shift() == 0);
 5922   ins_cost(MEMORY_REF_COST);
 5923 
 5924   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5925   size(4);
 5926   ins_encode( enc_lwz(dst, mem) );
 5927   ins_pipe(pipe_class_memory);
 5928 %}
 5929 
 5930 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
 5931   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 5932   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0 &amp;&amp;
 5933             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5934   ins_cost(MEMORY_REF_COST);
 5935 
 5936   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5937   size(4);
 5938   ins_encode( enc_lwz(dst, mem) );
 5939   ins_pipe(pipe_class_memory);
 5940 %}
 5941 
 5942 // Load Pointer
 5943 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
 5944   match(Set dst (LoadP mem));
 5945   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5946   ins_cost(MEMORY_REF_COST);
 5947 
 5948   format %{ &quot;LD      $dst, $mem \t// ptr&quot; %}
 5949   size(4);
 5950   ins_encode( enc_ld(dst, mem) );
 5951   ins_pipe(pipe_class_memory);
 5952 %}
 5953 
 5954 // Load Pointer acquire.
 5955 instruct loadP_ac(iRegPdst dst, memoryAlg4 mem) %{
 5956   match(Set dst (LoadP mem));
 5957   ins_cost(3*MEMORY_REF_COST);
 5958 
 5959   format %{ &quot;LD      $dst, $mem \t// ptr acquire\n\t&quot;
 5960             &quot;TWI     $dst\n\t&quot;
 5961             &quot;ISYNC&quot; %}
 5962   size(12);
 5963   ins_encode( enc_ld_ac(dst, mem) );
 5964   ins_pipe(pipe_class_memory);
 5965 %}
 5966 
 5967 // LoadP + CastP2L
 5968 instruct loadP2X(iRegLdst dst, memoryAlg4 mem) %{
 5969   match(Set dst (CastP2X (LoadP mem)));
 5970   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5971   ins_cost(MEMORY_REF_COST);
 5972 
 5973   format %{ &quot;LD      $dst, $mem \t// ptr + p2x&quot; %}
 5974   size(4);
 5975   ins_encode( enc_ld(dst, mem) );
 5976   ins_pipe(pipe_class_memory);
 5977 %}
 5978 
 5979 // Load compressed klass pointer.
 5980 instruct loadNKlass(iRegNdst dst, memory mem) %{
 5981   match(Set dst (LoadNKlass mem));
 5982   ins_cost(MEMORY_REF_COST);
 5983 
 5984   format %{ &quot;LWZ     $dst, $mem \t// compressed klass ptr&quot; %}
 5985   size(4);
 5986   ins_encode( enc_lwz(dst, mem) );
 5987   ins_pipe(pipe_class_memory);
 5988 %}
 5989 
 5990 // Load Klass Pointer
 5991 instruct loadKlass(iRegPdst dst, memoryAlg4 mem) %{
 5992   match(Set dst (LoadKlass mem));
 5993   ins_cost(MEMORY_REF_COST);
 5994 
 5995   format %{ &quot;LD      $dst, $mem \t// klass ptr&quot; %}
 5996   size(4);
 5997   ins_encode( enc_ld(dst, mem) );
 5998   ins_pipe(pipe_class_memory);
 5999 %}
 6000 
 6001 // Load Float
 6002 instruct loadF(regF dst, memory mem) %{
 6003   match(Set dst (LoadF mem));
 6004   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 6005   ins_cost(MEMORY_REF_COST);
 6006 
 6007   format %{ &quot;LFS     $dst, $mem&quot; %}
 6008   size(4);
 6009   ins_encode %{
 6010     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6011     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6012     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6013   %}
 6014   ins_pipe(pipe_class_memory);
 6015 %}
 6016 
 6017 // Load Float acquire.
 6018 instruct loadF_ac(regF dst, memory mem, flagsRegCR0 cr0) %{
 6019   match(Set dst (LoadF mem));
 6020   effect(TEMP cr0);
 6021   ins_cost(3*MEMORY_REF_COST);
 6022 
 6023   format %{ &quot;LFS     $dst, $mem \t// acquire\n\t&quot;
 6024             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6025             &quot;BNE     cr0, next\n&quot;
 6026             &quot;next:\n\t&quot;
 6027             &quot;ISYNC&quot; %}
 6028   size(16);
 6029   ins_encode %{
 6030     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6031     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6032     Label next;
 6033     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6034     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6035     __ bne(CCR0, next);
 6036     __ bind(next);
 6037     __ isync();
 6038   %}
 6039   ins_pipe(pipe_class_memory);
 6040 %}
 6041 
 6042 // Load Double - aligned
 6043 instruct loadD(regD dst, memory mem) %{
 6044   match(Set dst (LoadD mem));
 6045   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 6046   ins_cost(MEMORY_REF_COST);
 6047 
 6048   format %{ &quot;LFD     $dst, $mem&quot; %}
 6049   size(4);
 6050   ins_encode( enc_lfd(dst, mem) );
 6051   ins_pipe(pipe_class_memory);
 6052 %}
 6053 
 6054 // Load Double - aligned acquire.
 6055 instruct loadD_ac(regD dst, memory mem, flagsRegCR0 cr0) %{
 6056   match(Set dst (LoadD mem));
 6057   effect(TEMP cr0);
 6058   ins_cost(3*MEMORY_REF_COST);
 6059 
 6060   format %{ &quot;LFD     $dst, $mem \t// acquire\n\t&quot;
 6061             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6062             &quot;BNE     cr0, next\n&quot;
 6063             &quot;next:\n\t&quot;
 6064             &quot;ISYNC&quot; %}
 6065   size(16);
 6066   ins_encode %{
 6067     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6068     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6069     Label next;
 6070     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6071     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6072     __ bne(CCR0, next);
 6073     __ bind(next);
 6074     __ isync();
 6075   %}
 6076   ins_pipe(pipe_class_memory);
 6077 %}
 6078 
 6079 // Load Double - UNaligned
 6080 instruct loadD_unaligned(regD dst, memory mem) %{
 6081   match(Set dst (LoadD_unaligned mem));
 6082   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 6083   ins_cost(MEMORY_REF_COST);
 6084 
 6085   format %{ &quot;LFD     $dst, $mem&quot; %}
 6086   size(4);
 6087   ins_encode( enc_lfd(dst, mem) );
 6088   ins_pipe(pipe_class_memory);
 6089 %}
 6090 
 6091 //----------Constants--------------------------------------------------------
 6092 
 6093 // Load MachConstantTableBase: add hi offset to global toc.
 6094 // TODO: Handle hidden register r29 in bundler!
 6095 instruct loadToc_hi(iRegLdst dst) %{
 6096   effect(DEF dst);
 6097   ins_cost(DEFAULT_COST);
 6098 
 6099   format %{ &quot;ADDIS   $dst, R29, DISP.hi \t// load TOC hi&quot; %}
 6100   size(4);
 6101   ins_encode %{
 6102     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6103     __ calculate_address_from_global_toc_hi16only($dst$$Register, __ method_toc());
 6104   %}
 6105   ins_pipe(pipe_class_default);
 6106 %}
 6107 
 6108 // Load MachConstantTableBase: add lo offset to global toc.
 6109 instruct loadToc_lo(iRegLdst dst, iRegLdst src) %{
 6110   effect(DEF dst, USE src);
 6111   ins_cost(DEFAULT_COST);
 6112 
 6113   format %{ &quot;ADDI    $dst, $src, DISP.lo \t// load TOC lo&quot; %}
 6114   size(4);
 6115   ins_encode %{
 6116     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6117     __ calculate_address_from_global_toc_lo16only($dst$$Register, __ method_toc());
 6118   %}
 6119   ins_pipe(pipe_class_default);
 6120 %}
 6121 
 6122 // Load 16-bit integer constant 0xssss????
 6123 instruct loadConI16(iRegIdst dst, immI16 src) %{
 6124   match(Set dst src);
 6125 
 6126   format %{ &quot;LI      $dst, $src&quot; %}
 6127   size(4);
 6128   ins_encode %{
 6129     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6130     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6131   %}
 6132   ins_pipe(pipe_class_default);
 6133 %}
 6134 
 6135 // Load integer constant 0x????0000
 6136 instruct loadConIhi16(iRegIdst dst, immIhi16 src) %{
 6137   match(Set dst src);
 6138   ins_cost(DEFAULT_COST);
 6139 
 6140   format %{ &quot;LIS     $dst, $src.hi&quot; %}
 6141   size(4);
 6142   ins_encode %{
 6143     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6144     // Lis sign extends 16-bit src then shifts it 16 bit to the left.
 6145     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6146   %}
 6147   ins_pipe(pipe_class_default);
 6148 %}
 6149 
 6150 // Part 2 of loading 32 bit constant: hi16 is is src1 (properly shifted
 6151 // and sign extended), this adds the low 16 bits.
 6152 instruct loadConI32_lo16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 6153   // no match-rule, false predicate
 6154   effect(DEF dst, USE src1, USE src2);
 6155   predicate(false);
 6156 
 6157   format %{ &quot;ORI     $dst, $src1.hi, $src2.lo&quot; %}
 6158   size(4);
 6159   ins_encode %{
 6160     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6161     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6162   %}
 6163   ins_pipe(pipe_class_default);
 6164 %}
 6165 
 6166 instruct loadConI_Ex(iRegIdst dst, immI src) %{
 6167   match(Set dst src);
 6168   ins_cost(DEFAULT_COST*2);
 6169 
 6170   expand %{
 6171     // Would like to use $src$$constant.
 6172     immI16 srcLo %{ _opnds[1]-&gt;constant() %}
 6173     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6174     immIhi16 srcHi %{ _opnds[1]-&gt;constant() %}
 6175     iRegIdst tmpI;
 6176     loadConIhi16(tmpI, srcHi);
 6177     loadConI32_lo16(dst, tmpI, srcLo);
 6178   %}
 6179 %}
 6180 
 6181 // No constant pool entries required.
 6182 instruct loadConL16(iRegLdst dst, immL16 src) %{
 6183   match(Set dst src);
 6184 
 6185   format %{ &quot;LI      $dst, $src \t// long&quot; %}
 6186   size(4);
 6187   ins_encode %{
 6188     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6189     __ li($dst$$Register, (int)((short) ($src$$constant &amp; 0xFFFF)));
 6190   %}
 6191   ins_pipe(pipe_class_default);
 6192 %}
 6193 
 6194 // Load long constant 0xssssssss????0000
 6195 instruct loadConL32hi16(iRegLdst dst, immL32hi16 src) %{
 6196   match(Set dst src);
 6197   ins_cost(DEFAULT_COST);
 6198 
 6199   format %{ &quot;LIS     $dst, $src.hi \t// long&quot; %}
 6200   size(4);
 6201   ins_encode %{
 6202     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6203     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6204   %}
 6205   ins_pipe(pipe_class_default);
 6206 %}
 6207 
 6208 // To load a 32 bit constant: merge lower 16 bits into already loaded
 6209 // high 16 bits.
 6210 instruct loadConL32_lo16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 6211   // no match-rule, false predicate
 6212   effect(DEF dst, USE src1, USE src2);
 6213   predicate(false);
 6214 
 6215   format %{ &quot;ORI     $dst, $src1, $src2.lo&quot; %}
 6216   size(4);
 6217   ins_encode %{
 6218     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6219     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6220   %}
 6221   ins_pipe(pipe_class_default);
 6222 %}
 6223 
 6224 // Load 32-bit long constant
 6225 instruct loadConL32_Ex(iRegLdst dst, immL32 src) %{
 6226   match(Set dst src);
 6227   ins_cost(DEFAULT_COST*2);
 6228 
 6229   expand %{
 6230     // Would like to use $src$$constant.
 6231     immL16     srcLo %{ _opnds[1]-&gt;constant() /*&amp; 0x0000FFFFL */%}
 6232     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6233     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() /*&amp; 0xFFFF0000L */%}
 6234     iRegLdst tmpL;
 6235     loadConL32hi16(tmpL, srcHi);
 6236     loadConL32_lo16(dst, tmpL, srcLo);
 6237   %}
 6238 %}
 6239 
 6240 // Load long constant 0x????000000000000.
 6241 instruct loadConLhighest16_Ex(iRegLdst dst, immLhighest16 src) %{
 6242   match(Set dst src);
 6243   ins_cost(DEFAULT_COST);
 6244 
 6245   expand %{
 6246     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() &gt;&gt; 32 /*&amp; 0xFFFF0000L */%}
 6247     immI shift32 %{ 32 %}
 6248     iRegLdst tmpL;
 6249     loadConL32hi16(tmpL, srcHi);
 6250     lshiftL_regL_immI(dst, tmpL, shift32);
 6251   %}
 6252 %}
 6253 
 6254 // Expand node for constant pool load: small offset.
 6255 instruct loadConL(iRegLdst dst, immL src, iRegLdst toc) %{
 6256   effect(DEF dst, USE src, USE toc);
 6257   ins_cost(MEMORY_REF_COST);
 6258 
 6259   ins_num_consts(1);
 6260   // Needed so that CallDynamicJavaDirect can compute the address of this
 6261   // instruction for relocation.
 6262   ins_field_cbuf_insts_offset(int);
 6263 
 6264   format %{ &quot;LD      $dst, offset, $toc \t// load long $src from TOC&quot; %}
 6265   size(4);
 6266   ins_encode( enc_load_long_constL(dst, src, toc) );
 6267   ins_pipe(pipe_class_memory);
 6268 %}
 6269 
 6270 // Expand node for constant pool load: large offset.
 6271 instruct loadConL_hi(iRegLdst dst, immL src, iRegLdst toc) %{
 6272   effect(DEF dst, USE src, USE toc);
 6273   predicate(false);
 6274 
 6275   ins_num_consts(1);
 6276   ins_field_const_toc_offset(int);
 6277   // Needed so that CallDynamicJavaDirect can compute the address of this
 6278   // instruction for relocation.
 6279   ins_field_cbuf_insts_offset(int);
 6280 
 6281   format %{ &quot;ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)&quot; %}
 6282   size(4);
 6283   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
 6284   ins_pipe(pipe_class_default);
 6285 %}
 6286 
 6287 // Expand node for constant pool load: large offset.
 6288 // No constant pool entries required.
 6289 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
 6290   effect(DEF dst, USE src, USE base);
 6291   predicate(false);
 6292 
 6293   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
 6294 
 6295   format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
 6296   size(4);
 6297   ins_encode %{
 6298     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 6299     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
 6300     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6301   %}
 6302   ins_pipe(pipe_class_memory);
 6303 %}
 6304 
 6305 // Load long constant from constant table. Expand in case of
 6306 // offset &gt; 16 bit is needed.
 6307 // Adlc adds toc node MachConstantTableBase.
 6308 instruct loadConL_Ex(iRegLdst dst, immL src) %{
 6309   match(Set dst src);
 6310   ins_cost(MEMORY_REF_COST);
 6311 
 6312   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded&quot; %}
 6313   // We can not inline the enc_class for the expand as that does not support constanttablebase.
 6314   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
 6315 %}
 6316 
 6317 // Load NULL as compressed oop.
 6318 instruct loadConN0(iRegNdst dst, immN_0 src) %{
 6319   match(Set dst src);
 6320   ins_cost(DEFAULT_COST);
 6321 
 6322   format %{ &quot;LI      $dst, $src \t// compressed ptr&quot; %}
 6323   size(4);
 6324   ins_encode %{
 6325     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6326     __ li($dst$$Register, 0);
 6327   %}
 6328   ins_pipe(pipe_class_default);
 6329 %}
 6330 
 6331 // Load hi part of compressed oop constant.
 6332 instruct loadConN_hi(iRegNdst dst, immN src) %{
 6333   effect(DEF dst, USE src);
 6334   ins_cost(DEFAULT_COST);
 6335 
 6336   format %{ &quot;LIS     $dst, $src \t// narrow oop hi&quot; %}
 6337   size(4);
 6338   ins_encode %{
 6339     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6340     __ lis($dst$$Register, (int)(short)(($src$$constant &gt;&gt; 16) &amp; 0xffff));
 6341   %}
 6342   ins_pipe(pipe_class_default);
 6343 %}
 6344 
 6345 // Add lo part of compressed oop constant to already loaded hi part.
 6346 instruct loadConN_lo(iRegNdst dst, iRegNsrc src1, immN src2) %{
 6347   effect(DEF dst, USE src1, USE src2);
 6348   ins_cost(DEFAULT_COST);
 6349 
 6350   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow oop lo&quot; %}
 6351   size(4);
 6352   ins_encode %{
 6353     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6354     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6355     int oop_index = __ oop_recorder()-&gt;find_index((jobject)$src2$$constant);
 6356     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 6357     __ relocate(rspec, 1);
 6358     __ ori($dst$$Register, $src1$$Register, $src2$$constant &amp; 0xffff);
 6359   %}
 6360   ins_pipe(pipe_class_default);
 6361 %}
 6362 
 6363 instruct rldicl(iRegLdst dst, iRegLsrc src, immI16 shift, immI16 mask_begin) %{
 6364   effect(DEF dst, USE src, USE shift, USE mask_begin);
 6365 
 6366   size(4);
 6367   ins_encode %{
 6368     __ rldicl($dst$$Register, $src$$Register, $shift$$constant, $mask_begin$$constant);
 6369   %}
 6370   ins_pipe(pipe_class_default);
 6371 %}
 6372 
 6373 // Needed to postalloc expand loadConN: ConN is loaded as ConI
 6374 // leaving the upper 32 bits with sign-extension bits.
 6375 // This clears these bits: dst = src &amp; 0xFFFFFFFF.
 6376 // TODO: Eventually call this maskN_regN_FFFFFFFF.
 6377 instruct clearMs32b(iRegNdst dst, iRegNsrc src) %{
 6378   effect(DEF dst, USE src);
 6379   predicate(false);
 6380 
 6381   format %{ &quot;MASK    $dst, $src, 0xFFFFFFFF&quot; %} // mask
 6382   size(4);
 6383   ins_encode %{
 6384     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6385     __ clrldi($dst$$Register, $src$$Register, 0x20);
 6386   %}
 6387   ins_pipe(pipe_class_default);
 6388 %}
 6389 
 6390 // Optimize DecodeN for disjoint base.
 6391 // Load base of compressed oops into a register
 6392 instruct loadBase(iRegLdst dst) %{
 6393   effect(DEF dst);
 6394 
 6395   format %{ &quot;LoadConst $dst, heapbase&quot; %}
 6396   ins_encode %{
 6397     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6398     __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);
 6399   %}
 6400   ins_pipe(pipe_class_default);
 6401 %}
 6402 
 6403 // Loading ConN must be postalloc expanded so that edges between
 6404 // the nodes are safe. They may not interfere with a safepoint.
 6405 // GL TODO: This needs three instructions: better put this into the constant pool.
 6406 instruct loadConN_Ex(iRegNdst dst, immN src) %{
 6407   match(Set dst src);
 6408   ins_cost(DEFAULT_COST*2);
 6409 
 6410   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6411   postalloc_expand %{
 6412     MachNode *m1 = new loadConN_hiNode();
 6413     MachNode *m2 = new loadConN_loNode();
 6414     MachNode *m3 = new clearMs32bNode();
 6415     m1-&gt;add_req(NULL);
 6416     m2-&gt;add_req(NULL, m1);
 6417     m3-&gt;add_req(NULL, m2);
 6418     m1-&gt;_opnds[0] = op_dst;
 6419     m1-&gt;_opnds[1] = op_src;
 6420     m2-&gt;_opnds[0] = op_dst;
 6421     m2-&gt;_opnds[1] = op_dst;
 6422     m2-&gt;_opnds[2] = op_src;
 6423     m3-&gt;_opnds[0] = op_dst;
 6424     m3-&gt;_opnds[1] = op_dst;
 6425     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6426     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6427     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6428     nodes-&gt;push(m1);
 6429     nodes-&gt;push(m2);
 6430     nodes-&gt;push(m3);
 6431   %}
 6432 %}
 6433 
 6434 // We have seen a safepoint between the hi and lo parts, and this node was handled
 6435 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
 6436 // not a narrow oop.
 6437 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
 6438   match(Set dst src);
 6439   effect(DEF dst, USE src);
 6440   ins_cost(DEFAULT_COST);
 6441 
 6442   format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
 6443   size(4);
 6444   ins_encode %{
 6445     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6446     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);
 6447     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
 6448   %}
 6449   ins_pipe(pipe_class_default);
 6450 %}
 6451 
 6452 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
 6453 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6454   match(Set dst src1);
 6455   effect(TEMP src2);
 6456   ins_cost(DEFAULT_COST);
 6457 
 6458   format %{ &quot;MASK    $dst, $src2, 0xFFFFFFFF&quot; %} // mask
 6459   size(4);
 6460   ins_encode %{
 6461     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6462     __ clrldi($dst$$Register, $src2$$Register, 0x20);
 6463   %}
 6464   ins_pipe(pipe_class_default);
 6465 %}
 6466 
 6467 // This needs a match rule so that build_oop_map knows this is
 6468 // not a narrow oop.
 6469 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6470   match(Set dst src1);
 6471   effect(TEMP src2);
 6472   ins_cost(DEFAULT_COST);
 6473 
 6474   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
 6475   size(4);
 6476   ins_encode %{
 6477     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6478     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);
 6479     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6480     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
 6481     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 6482 
 6483     __ relocate(rspec, 1);
 6484     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
 6485   %}
 6486   ins_pipe(pipe_class_default);
 6487 %}
 6488 
 6489 // Loading ConNKlass must be postalloc expanded so that edges between
 6490 // the nodes are safe. They may not interfere with a safepoint.
 6491 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
 6492   match(Set dst src);
 6493   ins_cost(DEFAULT_COST*2);
 6494 
 6495   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6496   postalloc_expand %{
 6497     // Load high bits into register. Sign extended.
 6498     MachNode *m1 = new loadConNKlass_hiNode();
 6499     m1-&gt;add_req(NULL);
 6500     m1-&gt;_opnds[0] = op_dst;
 6501     m1-&gt;_opnds[1] = op_src;
 6502     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6503     nodes-&gt;push(m1);
 6504 
 6505     MachNode *m2 = m1;
 6506     if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src-&gt;constant()), 31)) {
 6507       // Value might be 1-extended. Mask out these bits.
 6508       m2 = new loadConNKlass_maskNode();
 6509       m2-&gt;add_req(NULL, m1);
 6510       m2-&gt;_opnds[0] = op_dst;
 6511       m2-&gt;_opnds[1] = op_src;
 6512       m2-&gt;_opnds[2] = op_dst;
 6513       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6514       nodes-&gt;push(m2);
 6515     }
 6516 
 6517     MachNode *m3 = new loadConNKlass_loNode();
 6518     m3-&gt;add_req(NULL, m2);
 6519     m3-&gt;_opnds[0] = op_dst;
 6520     m3-&gt;_opnds[1] = op_src;
 6521     m3-&gt;_opnds[2] = op_dst;
 6522     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6523     nodes-&gt;push(m3);
 6524   %}
 6525 %}
 6526 
 6527 // 0x1 is used in object initialization (initial object header).
 6528 // No constant pool entries required.
 6529 instruct loadConP0or1(iRegPdst dst, immP_0or1 src) %{
 6530   match(Set dst src);
 6531 
 6532   format %{ &quot;LI      $dst, $src \t// ptr&quot; %}
 6533   size(4);
 6534   ins_encode %{
 6535     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6536     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6537   %}
 6538   ins_pipe(pipe_class_default);
 6539 %}
 6540 
 6541 // Expand node for constant pool load: small offset.
 6542 // The match rule is needed to generate the correct bottom_type(),
 6543 // however this node should never match. The use of predicate is not
 6544 // possible since ADLC forbids predicates for chain rules. The higher
 6545 // costs do not prevent matching in this case. For that reason the
 6546 // operand immP_NM with predicate(false) is used.
 6547 instruct loadConP(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6548   match(Set dst src);
 6549   effect(TEMP toc);
 6550 
 6551   ins_num_consts(1);
 6552 
 6553   format %{ &quot;LD      $dst, offset, $toc \t// load ptr $src from TOC&quot; %}
 6554   size(4);
 6555   ins_encode( enc_load_long_constP(dst, src, toc) );
 6556   ins_pipe(pipe_class_memory);
 6557 %}
 6558 
 6559 // Expand node for constant pool load: large offset.
 6560 instruct loadConP_hi(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6561   effect(DEF dst, USE src, USE toc);
 6562   predicate(false);
 6563 
 6564   ins_num_consts(1);
 6565   ins_field_const_toc_offset(int);
 6566 
 6567   format %{ &quot;ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)&quot; %}
 6568   size(4);
 6569   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
 6570   ins_pipe(pipe_class_default);
 6571 %}
 6572 
 6573 // Expand node for constant pool load: large offset.
 6574 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
 6575   match(Set dst src);
 6576   effect(TEMP base);
 6577 
 6578   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
 6579 
 6580   format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
 6581   size(4);
 6582   ins_encode %{
 6583     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 6584     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
 6585     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6586   %}
 6587   ins_pipe(pipe_class_memory);
 6588 %}
 6589 
 6590 // Load pointer constant from constant table. Expand in case an
 6591 // offset &gt; 16 bit is needed.
 6592 // Adlc adds toc node MachConstantTableBase.
 6593 instruct loadConP_Ex(iRegPdst dst, immP src) %{
 6594   match(Set dst src);
 6595   ins_cost(MEMORY_REF_COST);
 6596 
 6597   // This rule does not use &quot;expand&quot; because then
 6598   // the result type is not known to be an Oop.  An ADLC
 6599   // enhancement will be needed to make that work - not worth it!
 6600 
 6601   // If this instruction rematerializes, it prolongs the live range
 6602   // of the toc node, causing illegal graphs.
 6603   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
 6604   ins_cannot_rematerialize(true);
 6605 
 6606   format %{ &quot;LD    $dst, offset, $constanttablebase \t//  load ptr $src from table, postalloc expanded&quot; %}
 6607   postalloc_expand( postalloc_expand_load_ptr_constant(dst, src, constanttablebase) );
 6608 %}
 6609 
 6610 // Expand node for constant pool load: small offset.
 6611 instruct loadConF(regF dst, immF src, iRegLdst toc) %{
 6612   effect(DEF dst, USE src, USE toc);
 6613   ins_cost(MEMORY_REF_COST);
 6614 
 6615   ins_num_consts(1);
 6616 
 6617   format %{ &quot;LFS     $dst, offset, $toc \t// load float $src from TOC&quot; %}
 6618   size(4);
 6619   ins_encode %{
 6620     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6621     address float_address = __ float_constant($src$$constant);
 6622     if (float_address == NULL) {
 6623       ciEnv::current()-&gt;record_out_of_memory_failure();
 6624       return;
 6625     }
 6626     __ lfs($dst$$FloatRegister, __ offset_to_method_toc(float_address), $toc$$Register);
 6627   %}
 6628   ins_pipe(pipe_class_memory);
 6629 %}
 6630 
 6631 // Expand node for constant pool load: large offset.
 6632 instruct loadConFComp(regF dst, immF src, iRegLdst toc) %{
 6633   effect(DEF dst, USE src, USE toc);
 6634   ins_cost(MEMORY_REF_COST);
 6635 
 6636   ins_num_consts(1);
 6637 
 6638   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6639             &quot;LFS     $dst, offset_lo, $toc \t// load float $src from TOC (hi/lo)\n\t&quot;
 6640             &quot;ADDIS   $toc, $toc, -offset_hi&quot;%}
 6641   size(12);
 6642   ins_encode %{
 6643     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6644     FloatRegister Rdst    = $dst$$FloatRegister;
 6645     Register Rtoc         = $toc$$Register;
 6646     address float_address = __ float_constant($src$$constant);
 6647     if (float_address == NULL) {
 6648       ciEnv::current()-&gt;record_out_of_memory_failure();
 6649       return;
 6650     }
 6651     int offset            = __ offset_to_method_toc(float_address);
 6652     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6653     int lo = offset - hi * (1&lt;&lt;16);
 6654 
 6655     __ addis(Rtoc, Rtoc, hi);
 6656     __ lfs(Rdst, lo, Rtoc);
 6657     __ addis(Rtoc, Rtoc, -hi);
 6658   %}
 6659   ins_pipe(pipe_class_memory);
 6660 %}
 6661 
 6662 // Adlc adds toc node MachConstantTableBase.
 6663 instruct loadConF_Ex(regF dst, immF src) %{
 6664   match(Set dst src);
 6665   ins_cost(MEMORY_REF_COST);
 6666 
 6667   // See loadConP.
 6668   ins_cannot_rematerialize(true);
 6669 
 6670   format %{ &quot;LFS     $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6671   postalloc_expand( postalloc_expand_load_float_constant(dst, src, constanttablebase) );
 6672 %}
 6673 
 6674 // Expand node for constant pool load: small offset.
 6675 instruct loadConD(regD dst, immD src, iRegLdst toc) %{
 6676   effect(DEF dst, USE src, USE toc);
 6677   ins_cost(MEMORY_REF_COST);
 6678 
 6679   ins_num_consts(1);
 6680 
 6681   format %{ &quot;LFD     $dst, offset, $toc \t// load double $src from TOC&quot; %}
 6682   size(4);
 6683   ins_encode %{
 6684     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 6685     address float_address = __ double_constant($src$$constant);
 6686     if (float_address == NULL) {
 6687       ciEnv::current()-&gt;record_out_of_memory_failure();
 6688       return;
 6689     }
 6690     int offset =  __ offset_to_method_toc(float_address);
 6691     __ lfd($dst$$FloatRegister, offset, $toc$$Register);
 6692   %}
 6693   ins_pipe(pipe_class_memory);
 6694 %}
 6695 
 6696 // Expand node for constant pool load: large offset.
 6697 instruct loadConDComp(regD dst, immD src, iRegLdst toc) %{
 6698   effect(DEF dst, USE src, USE toc);
 6699   ins_cost(MEMORY_REF_COST);
 6700 
 6701   ins_num_consts(1);
 6702 
 6703   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6704             &quot;LFD     $dst, offset_lo, $toc \t// load double $src from TOC (hi/lo)\n\t&quot;
 6705             &quot;ADDIS   $toc, $toc, -offset_hi&quot; %}
 6706   size(12);
 6707   ins_encode %{
 6708     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6709     FloatRegister Rdst    = $dst$$FloatRegister;
 6710     Register      Rtoc    = $toc$$Register;
 6711     address float_address = __ double_constant($src$$constant);
 6712     if (float_address == NULL) {
 6713       ciEnv::current()-&gt;record_out_of_memory_failure();
 6714       return;
 6715     }
 6716     int offset = __ offset_to_method_toc(float_address);
 6717     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6718     int lo = offset - hi * (1&lt;&lt;16);
 6719 
 6720     __ addis(Rtoc, Rtoc, hi);
 6721     __ lfd(Rdst, lo, Rtoc);
 6722     __ addis(Rtoc, Rtoc, -hi);
 6723   %}
 6724   ins_pipe(pipe_class_memory);
 6725 %}
 6726 
 6727 // Adlc adds toc node MachConstantTableBase.
 6728 instruct loadConD_Ex(regD dst, immD src) %{
 6729   match(Set dst src);
 6730   ins_cost(MEMORY_REF_COST);
 6731 
 6732   // See loadConP.
 6733   ins_cannot_rematerialize(true);
 6734 
 6735   format %{ &quot;ConD    $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6736   postalloc_expand( postalloc_expand_load_double_constant(dst, src, constanttablebase) );
 6737 %}
 6738 
 6739 // Prefetch instructions.
 6740 // Must be safe to execute with invalid address (cannot fault).
 6741 
 6742 // Special prefetch versions which use the dcbz instruction.
 6743 instruct prefetch_alloc_zero(indirectMemory mem, iRegLsrc src) %{
 6744   match(PrefetchAllocation (AddP mem src));
 6745   predicate(AllocatePrefetchStyle == 3);
 6746   ins_cost(MEMORY_REF_COST);
 6747 
 6748   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many with zero&quot; %}
 6749   size(4);
 6750   ins_encode %{
 6751     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6752     __ dcbz($src$$Register, $mem$$base$$Register);
 6753   %}
 6754   ins_pipe(pipe_class_memory);
 6755 %}
 6756 
 6757 instruct prefetch_alloc_zero_no_offset(indirectMemory mem) %{
 6758   match(PrefetchAllocation mem);
 6759   predicate(AllocatePrefetchStyle == 3);
 6760   ins_cost(MEMORY_REF_COST);
 6761 
 6762   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many with zero&quot; %}
 6763   size(4);
 6764   ins_encode %{
 6765     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6766     __ dcbz($mem$$base$$Register);
 6767   %}
 6768   ins_pipe(pipe_class_memory);
 6769 %}
 6770 
 6771 instruct prefetch_alloc(indirectMemory mem, iRegLsrc src) %{
 6772   match(PrefetchAllocation (AddP mem src));
 6773   predicate(AllocatePrefetchStyle != 3);
 6774   ins_cost(MEMORY_REF_COST);
 6775 
 6776   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many&quot; %}
 6777   size(4);
 6778   ins_encode %{
 6779     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6780     __ dcbtst($src$$Register, $mem$$base$$Register);
 6781   %}
 6782   ins_pipe(pipe_class_memory);
 6783 %}
 6784 
 6785 instruct prefetch_alloc_no_offset(indirectMemory mem) %{
 6786   match(PrefetchAllocation mem);
 6787   predicate(AllocatePrefetchStyle != 3);
 6788   ins_cost(MEMORY_REF_COST);
 6789 
 6790   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many&quot; %}
 6791   size(4);
 6792   ins_encode %{
 6793     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6794     __ dcbtst($mem$$base$$Register);
 6795   %}
 6796   ins_pipe(pipe_class_memory);
 6797 %}
 6798 
 6799 //----------Store Instructions-------------------------------------------------
 6800 
 6801 // Store Byte
 6802 instruct storeB(memory mem, iRegIsrc src) %{
 6803   match(Set mem (StoreB mem src));
 6804   ins_cost(MEMORY_REF_COST);
 6805 
 6806   format %{ &quot;STB     $src, $mem \t// byte&quot; %}
 6807   size(4);
 6808   ins_encode %{
 6809     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
 6810     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6811     __ stb($src$$Register, Idisp, $mem$$base$$Register);
 6812   %}
 6813   ins_pipe(pipe_class_memory);
 6814 %}
 6815 
 6816 // Store Char/Short
 6817 instruct storeC(memory mem, iRegIsrc src) %{
 6818   match(Set mem (StoreC mem src));
 6819   ins_cost(MEMORY_REF_COST);
 6820 
 6821   format %{ &quot;STH     $src, $mem \t// short&quot; %}
 6822   size(4);
 6823   ins_encode %{
 6824     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
 6825     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6826     __ sth($src$$Register, Idisp, $mem$$base$$Register);
 6827   %}
 6828   ins_pipe(pipe_class_memory);
 6829 %}
 6830 
 6831 // Store Integer
 6832 instruct storeI(memory mem, iRegIsrc src) %{
 6833   match(Set mem (StoreI mem src));
 6834   ins_cost(MEMORY_REF_COST);
 6835 
 6836   format %{ &quot;STW     $src, $mem&quot; %}
 6837   size(4);
 6838   ins_encode( enc_stw(src, mem) );
 6839   ins_pipe(pipe_class_memory);
 6840 %}
 6841 
 6842 // ConvL2I + StoreI.
 6843 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
 6844   match(Set mem (StoreI mem (ConvL2I src)));
 6845   ins_cost(MEMORY_REF_COST);
 6846 
 6847   format %{ &quot;STW     l2i($src), $mem&quot; %}
 6848   size(4);
 6849   ins_encode( enc_stw(src, mem) );
 6850   ins_pipe(pipe_class_memory);
 6851 %}
 6852 
 6853 // Store Long
 6854 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
 6855   match(Set mem (StoreL mem src));
 6856   ins_cost(MEMORY_REF_COST);
 6857 
 6858   format %{ &quot;STD     $src, $mem \t// long&quot; %}
 6859   size(4);
 6860   ins_encode( enc_std(src, mem) );
 6861   ins_pipe(pipe_class_memory);
 6862 %}
 6863 
 6864 // Store super word nodes.
 6865 
 6866 // Store Aligned Packed Byte long register to memory
 6867 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
 6868   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
 6869   match(Set mem (StoreVector mem src));
 6870   ins_cost(MEMORY_REF_COST);
 6871 
 6872   format %{ &quot;STD     $mem, $src \t// packed8B&quot; %}
 6873   size(4);
 6874   ins_encode( enc_std(src, mem) );
 6875   ins_pipe(pipe_class_memory);
 6876 %}
 6877 
 6878 // Store Packed Byte long register to memory
 6879 instruct storeV16(indirect mem, vecX src) %{
 6880   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 16);
 6881   match(Set mem (StoreVector mem src));
 6882   ins_cost(MEMORY_REF_COST);
 6883 
 6884   format %{ &quot;STXVD2X     $mem, $src \t// store 16-byte Vector&quot; %}
 6885   size(4);
 6886   ins_encode %{
 6887     __ stxvd2x($src$$VectorSRegister, $mem$$Register);
 6888   %}
 6889   ins_pipe(pipe_class_default);
 6890 %}
 6891 
 6892 // Store Compressed Oop
 6893 instruct storeN(memory dst, iRegN_P2N src) %{
 6894   match(Set dst (StoreN dst src));
 6895   ins_cost(MEMORY_REF_COST);
 6896 
 6897   format %{ &quot;STW     $src, $dst \t// compressed oop&quot; %}
 6898   size(4);
 6899   ins_encode( enc_stw(src, dst) );
 6900   ins_pipe(pipe_class_memory);
 6901 %}
 6902 
 6903 // Store Compressed KLass
 6904 instruct storeNKlass(memory dst, iRegN_P2N src) %{
 6905   match(Set dst (StoreNKlass dst src));
 6906   ins_cost(MEMORY_REF_COST);
 6907 
 6908   format %{ &quot;STW     $src, $dst \t// compressed klass&quot; %}
 6909   size(4);
 6910   ins_encode( enc_stw(src, dst) );
 6911   ins_pipe(pipe_class_memory);
 6912 %}
 6913 
 6914 // Store Pointer
 6915 instruct storeP(memoryAlg4 dst, iRegPsrc src) %{
 6916   match(Set dst (StoreP dst src));
 6917   ins_cost(MEMORY_REF_COST);
 6918 
 6919   format %{ &quot;STD     $src, $dst \t// ptr&quot; %}
 6920   size(4);
 6921   ins_encode( enc_std(src, dst) );
 6922   ins_pipe(pipe_class_memory);
 6923 %}
 6924 
 6925 // Store Float
 6926 instruct storeF(memory mem, regF src) %{
 6927   match(Set mem (StoreF mem src));
 6928   ins_cost(MEMORY_REF_COST);
 6929 
 6930   format %{ &quot;STFS    $src, $mem&quot; %}
 6931   size(4);
 6932   ins_encode( enc_stfs(src, mem) );
 6933   ins_pipe(pipe_class_memory);
 6934 %}
 6935 
 6936 // Store Double
 6937 instruct storeD(memory mem, regD src) %{
 6938   match(Set mem (StoreD mem src));
 6939   ins_cost(MEMORY_REF_COST);
 6940 
 6941   format %{ &quot;STFD    $src, $mem&quot; %}
 6942   size(4);
 6943   ins_encode( enc_stfd(src, mem) );
 6944   ins_pipe(pipe_class_memory);
 6945 %}
 6946 
 6947 //----------Store Instructions With Zeros--------------------------------------
 6948 
 6949 // Card-mark for CMS garbage collection.
 6950 // This cardmark does an optimization so that it must not always
 6951 // do a releasing store. For this, it gets the address of
 6952 // CMSCollectorCardTableBarrierSetBSExt::_requires_release as input.
 6953 // (Using releaseFieldAddr in the match rule is a hack.)
 6954 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 6955   match(Set mem (StoreCM mem releaseFieldAddr));
 6956   effect(TEMP crx);
 6957   predicate(false);
 6958   ins_cost(MEMORY_REF_COST);
 6959 
 6960   // See loadConP.
 6961   ins_cannot_rematerialize(true);
 6962 
 6963   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
 6964   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
 6965   ins_pipe(pipe_class_memory);
 6966 %}
 6967 
 6968 instruct storeCM_G1(memory mem, immI_0 zero) %{
 6969   match(Set mem (StoreCM mem zero));
 6970   predicate(UseG1GC);
 6971   ins_cost(MEMORY_REF_COST);
 6972 
 6973   ins_cannot_rematerialize(true);
 6974 
 6975   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte store (G1)&quot; %}
 6976   size(8);
 6977   ins_encode %{
 6978     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6979     __ li(R0, 0);
 6980     //__ release(); // G1: oops are allowed to get visible after dirty marking
 6981     guarantee($mem$$base$$Register != R1_SP, &quot;use frame_slots_bias&quot;);
 6982     __ stb(R0, $mem$$disp, $mem$$base$$Register);
 6983   %}
 6984   ins_pipe(pipe_class_memory);
 6985 %}
 6986 
 6987 // Convert oop pointer into compressed form.
 6988 
 6989 // Nodes for postalloc expand.
 6990 
 6991 // Shift node for expand.
 6992 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
 6993   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6994   match(Set dst (EncodeP src));
 6995   predicate(false);
 6996 
 6997   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 6998   size(4);
 6999   ins_encode %{
 7000     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7001     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 7002   %}
 7003   ins_pipe(pipe_class_default);
 7004 %}
 7005 
 7006 // Add node for expand.
 7007 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
 7008   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7009   match(Set dst (EncodeP src));
 7010   predicate(false);
 7011 
 7012   format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
 7013   ins_encode %{
 7014     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7015     __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7016   %}
 7017   ins_pipe(pipe_class_default);
 7018 %}
 7019 
 7020 // Conditional sub base.
 7021 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7022   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7023   match(Set dst (EncodeP (Binary crx src1)));
 7024   predicate(false);
 7025 
 7026   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7027             &quot;SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n&quot;
 7028             &quot;done:&quot; %}
 7029   ins_encode %{
 7030     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7031     Label done;
 7032     __ beq($crx$$CondRegister, done);
 7033     __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);
 7034     __ bind(done);
 7035   %}
 7036   ins_pipe(pipe_class_default);
 7037 %}
 7038 
 7039 // Power 7 can use isel instruction
 7040 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7041   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7042   match(Set dst (EncodeP (Binary crx src1)));
 7043   predicate(false);
 7044 
 7045   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0&quot; %}
 7046   size(4);
 7047   ins_encode %{
 7048     // This is a Power7 instruction for which no machine description exists.
 7049     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7050     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7051   %}
 7052   ins_pipe(pipe_class_default);
 7053 %}
 7054 
 7055 // Disjoint narrow oop base.
 7056 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7057   match(Set dst (EncodeP src));
 7058   predicate(CompressedOops::base_disjoint());
 7059 
 7060   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7061   size(4);
 7062   ins_encode %{
 7063     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7064     __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);
 7065   %}
 7066   ins_pipe(pipe_class_default);
 7067 %}
 7068 
 7069 // shift != 0, base != 0
 7070 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
 7071   match(Set dst (EncodeP src));
 7072   effect(TEMP crx);
 7073   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7074             CompressedOops::shift() != 0 &amp;&amp;
 7075             CompressedOops::base_overlaps());
 7076 
 7077   format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
 7078   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 7079 %}
 7080 
 7081 // shift != 0, base != 0
 7082 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
 7083   match(Set dst (EncodeP src));
 7084   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
 7085             CompressedOops::shift() != 0 &amp;&amp;
 7086             CompressedOops::base_overlaps());
 7087 
 7088   format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7089   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 7090 %}
 7091 
 7092 // shift != 0, base == 0
 7093 // TODO: This is the same as encodeP_shift. Merge!
 7094 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
 7095   match(Set dst (EncodeP src));
 7096   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7097             CompressedOops::base() ==0);
 7098 
 7099   format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
 7100   size(4);
 7101   ins_encode %{
 7102     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7103     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 7104   %}
 7105   ins_pipe(pipe_class_default);
 7106 %}
 7107 
 7108 // Compressed OOPs with narrow_oop_shift == 0.
 7109 // shift == 0, base == 0
 7110 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
 7111   match(Set dst (EncodeP src));
 7112   predicate(CompressedOops::shift() == 0);
 7113 
 7114   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
 7115   // variable size, 0 or 4.
 7116   ins_encode %{
 7117     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7118     __ mr_if_needed($dst$$Register, $src$$Register);
 7119   %}
 7120   ins_pipe(pipe_class_default);
 7121 %}
 7122 
 7123 // Decode nodes.
 7124 
 7125 // Shift node for expand.
 7126 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
 7127   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7128   match(Set dst (DecodeN src));
 7129   predicate(false);
 7130 
 7131   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
 7132   size(4);
 7133   ins_encode %{
 7134     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7135     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7136   %}
 7137   ins_pipe(pipe_class_default);
 7138 %}
 7139 
 7140 // Add node for expand.
 7141 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
 7142   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7143   match(Set dst (DecodeN src));
 7144   predicate(false);
 7145 
 7146   format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
 7147   ins_encode %{
 7148     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7149     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7150   %}
 7151   ins_pipe(pipe_class_default);
 7152 %}
 7153 
 7154 // conditianal add base for expand
 7155 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
 7156   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7157   // NOTICE that the rule is nonsense - we just have to make sure that:
 7158   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7159   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7160   match(Set dst (DecodeN (Binary crx src)));
 7161   predicate(false);
 7162 
 7163   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7164             &quot;ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n&quot;
 7165             &quot;done:&quot; %}
 7166   ins_encode %{
 7167     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7168     Label done;
 7169     __ beq($crx$$CondRegister, done);
 7170     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7171     __ bind(done);
 7172   %}
 7173   ins_pipe(pipe_class_default);
 7174 %}
 7175 
 7176 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7177   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7178   // NOTICE that the rule is nonsense - we just have to make sure that:
 7179   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7180   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7181   match(Set dst (DecodeN (Binary crx src1)));
 7182   predicate(false);
 7183 
 7184   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0&quot; %}
 7185   size(4);
 7186   ins_encode %{
 7187     // This is a Power7 instruction for which no machine description exists.
 7188     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7189     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7190   %}
 7191   ins_pipe(pipe_class_default);
 7192 %}
 7193 
 7194 //  shift != 0, base != 0
 7195 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7196   match(Set dst (DecodeN src));
 7197   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7198              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7199             CompressedOops::shift() != 0 &amp;&amp;
 7200             CompressedOops::base() != 0);
 7201   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
 7202   effect(TEMP crx);
 7203 
 7204   format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
 7205   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 7206 %}
 7207 
 7208 // shift != 0, base == 0
 7209 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
 7210   match(Set dst (DecodeN src));
 7211   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7212             CompressedOops::base() == 0);
 7213 
 7214   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
 7215   size(4);
 7216   ins_encode %{
 7217     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7218     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7219   %}
 7220   ins_pipe(pipe_class_default);
 7221 %}
 7222 
 7223 // Optimize DecodeN for disjoint base.
 7224 // Shift narrow oop and or it into register that already contains the heap base.
 7225 // Base == dst must hold, and is assured by construction in postaloc_expand.
 7226 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
 7227   match(Set dst (DecodeN src));
 7228   effect(TEMP base);
 7229   predicate(false);
 7230 
 7231   format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
 7232   size(4);
 7233   ins_encode %{
 7234     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
 7235     __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());
 7236   %}
 7237   ins_pipe(pipe_class_default);
 7238 %}
 7239 
 7240 // Optimize DecodeN for disjoint base.
 7241 // This node requires only one cycle on the critical path.
 7242 // We must postalloc_expand as we can not express use_def effects where
 7243 // the used register is L and the def&#39;ed register P.
 7244 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
 7245   match(Set dst (DecodeN src));
 7246   effect(TEMP_DEF dst);
 7247   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7248              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7249             CompressedOops::base_disjoint());
 7250   ins_cost(DEFAULT_COST);
 7251 
 7252   format %{ &quot;MOV     $dst, heapbase \t\n&quot;
 7253             &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
 7254   postalloc_expand %{
 7255     loadBaseNode *n1 = new loadBaseNode();
 7256     n1-&gt;add_req(NULL);
 7257     n1-&gt;_opnds[0] = op_dst;
 7258 
 7259     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7260     n2-&gt;add_req(n_region, n_src, n1);
 7261     n2-&gt;_opnds[0] = op_dst;
 7262     n2-&gt;_opnds[1] = op_src;
 7263     n2-&gt;_opnds[2] = op_dst;
 7264     n2-&gt;_bottom_type = _bottom_type;
 7265 
 7266     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7267     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7268 
 7269     nodes-&gt;push(n1);
 7270     nodes-&gt;push(n2);
 7271   %}
 7272 %}
 7273 
 7274 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7275   match(Set dst (DecodeN src));
 7276   effect(TEMP_DEF dst, TEMP crx);
 7277   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7278              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7279             CompressedOops::base_disjoint() &amp;&amp; VM_Version::has_isel());
 7280   ins_cost(3 * DEFAULT_COST);
 7281 
 7282   format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
 7283   postalloc_expand %{
 7284     loadBaseNode *n1 = new loadBaseNode();
 7285     n1-&gt;add_req(NULL);
 7286     n1-&gt;_opnds[0] = op_dst;
 7287 
 7288     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 7289     n_compare-&gt;add_req(n_region, n_src);
 7290     n_compare-&gt;_opnds[0] = op_crx;
 7291     n_compare-&gt;_opnds[1] = op_src;
 7292     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 7293 
 7294     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7295     n2-&gt;add_req(n_region, n_src, n1);
 7296     n2-&gt;_opnds[0] = op_dst;
 7297     n2-&gt;_opnds[1] = op_src;
 7298     n2-&gt;_opnds[2] = op_dst;
 7299     n2-&gt;_bottom_type = _bottom_type;
 7300 
 7301     cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 7302     n_cond_set-&gt;add_req(n_region, n_compare, n2);
 7303     n_cond_set-&gt;_opnds[0] = op_dst;
 7304     n_cond_set-&gt;_opnds[1] = op_crx;
 7305     n_cond_set-&gt;_opnds[2] = op_dst;
 7306     n_cond_set-&gt;_bottom_type = _bottom_type;
 7307 
 7308     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 7309     ra_-&gt;set_oop(n_cond_set, true);
 7310 
 7311     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7312     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 7313     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7314     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7315 
 7316     nodes-&gt;push(n1);
 7317     nodes-&gt;push(n_compare);
 7318     nodes-&gt;push(n2);
 7319     nodes-&gt;push(n_cond_set);
 7320   %}
 7321 %}
 7322 
 7323 // src != 0, shift != 0, base != 0
 7324 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
 7325   match(Set dst (DecodeN src));
 7326   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7327              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7328             CompressedOops::shift() != 0 &amp;&amp;
 7329             CompressedOops::base() != 0);
 7330   ins_cost(2 * DEFAULT_COST);
 7331 
 7332   format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
 7333   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 7334 %}
 7335 
 7336 // Compressed OOPs with narrow_oop_shift == 0.
 7337 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
 7338   match(Set dst (DecodeN src));
 7339   predicate(CompressedOops::shift() == 0);
 7340   ins_cost(DEFAULT_COST);
 7341 
 7342   format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
 7343   // variable size, 0 or 4.
 7344   ins_encode %{
 7345     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7346     __ mr_if_needed($dst$$Register, $src$$Register);
 7347   %}
 7348   ins_pipe(pipe_class_default);
 7349 %}
 7350 
 7351 // Convert compressed oop into int for vectors alignment masking.
 7352 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
 7353   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 7354   predicate(CompressedOops::shift() == 0);
 7355   ins_cost(DEFAULT_COST);
 7356 
 7357   format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
 7358   // variable size, 0 or 4.
 7359   ins_encode %{
 7360     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7361     __ mr_if_needed($dst$$Register, $src$$Register);
 7362   %}
 7363   ins_pipe(pipe_class_default);
 7364 %}
 7365 
 7366 // Convert klass pointer into compressed form.
 7367 
 7368 // Nodes for postalloc expand.
 7369 
 7370 // Shift node for expand.
 7371 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
 7372   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7373   match(Set dst (EncodePKlass src));
 7374   predicate(false);
 7375 
 7376   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7377   size(4);
 7378   ins_encode %{
 7379     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7380     __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7381   %}
 7382   ins_pipe(pipe_class_default);
 7383 %}
 7384 
 7385 // Add node for expand.
 7386 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7387   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7388   match(Set dst (EncodePKlass (Binary base src)));
 7389   predicate(false);
 7390 
 7391   format %{ &quot;SUB     $dst, $base, $src \t// encode&quot; %}
 7392   size(4);
 7393   ins_encode %{
 7394     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 7395     __ subf($dst$$Register, $base$$Register, $src$$Register);
 7396   %}
 7397   ins_pipe(pipe_class_default);
 7398 %}
 7399 
 7400 // Disjoint narrow oop base.
 7401 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7402   match(Set dst (EncodePKlass src));
 7403   predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);
 7404 
 7405   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7406   size(4);
 7407   ins_encode %{
 7408     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7409     __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);
 7410   %}
 7411   ins_pipe(pipe_class_default);
 7412 %}
 7413 
 7414 // shift != 0, base != 0
 7415 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
 7416   match(Set dst (EncodePKlass (Binary base src)));
 7417   predicate(false);
 7418 
 7419   format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7420   postalloc_expand %{
 7421     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
 7422     n1-&gt;add_req(n_region, n_base, n_src);
 7423     n1-&gt;_opnds[0] = op_dst;
 7424     n1-&gt;_opnds[1] = op_base;
 7425     n1-&gt;_opnds[2] = op_src;
 7426     n1-&gt;_bottom_type = _bottom_type;
 7427 
 7428     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
 7429     n2-&gt;add_req(n_region, n1);
 7430     n2-&gt;_opnds[0] = op_dst;
 7431     n2-&gt;_opnds[1] = op_dst;
 7432     n2-&gt;_bottom_type = _bottom_type;
 7433     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7434     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7435 
 7436     nodes-&gt;push(n1);
 7437     nodes-&gt;push(n2);
 7438   %}
 7439 %}
 7440 
 7441 // shift != 0, base != 0
 7442 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
 7443   match(Set dst (EncodePKlass src));
 7444   //predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7445   //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);
 7446 
 7447   //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7448   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7449   expand %{
 7450     immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}
 7451     iRegLdst base;
 7452     loadConL_Ex(base, baseImm);
 7453     encodePKlass_not_null_Ex(dst, base, src);
 7454   %}
 7455 %}
 7456 
 7457 // Decode nodes.
 7458 
 7459 // Shift node for expand.
 7460 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
 7461   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7462   match(Set dst (DecodeNKlass src));
 7463   predicate(false);
 7464 
 7465   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
 7466   size(4);
 7467   ins_encode %{
 7468     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7469     __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7470   %}
 7471   ins_pipe(pipe_class_default);
 7472 %}
 7473 
 7474 // Add node for expand.
 7475 
 7476 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7477   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7478   match(Set dst (DecodeNKlass (Binary base src)));
 7479   predicate(false);
 7480 
 7481   format %{ &quot;ADD     $dst, $base, $src \t// DecodeNKlass, add klass base&quot; %}
 7482   size(4);
 7483   ins_encode %{
 7484     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 7485     __ add($dst$$Register, $base$$Register, $src$$Register);
 7486   %}
 7487   ins_pipe(pipe_class_default);
 7488 %}
 7489 
 7490 // src != 0, shift != 0, base != 0
 7491 instruct decodeNKlass_notNull_addBase_Ex(iRegPdst dst, iRegLsrc base, iRegNsrc src) %{
 7492   match(Set dst (DecodeNKlass (Binary base src)));
 7493   //effect(kill src); // We need a register for the immediate result after shifting.
 7494   predicate(false);
 7495 
 7496   format %{ &quot;DecodeNKlass $dst =  $base + ($src &lt;&lt; 3) \t// $src != NULL, postalloc expanded&quot; %}
 7497   postalloc_expand %{
 7498     decodeNKlass_add_baseNode *n1 = new decodeNKlass_add_baseNode();
 7499     n1-&gt;add_req(n_region, n_base, n_src);
 7500     n1-&gt;_opnds[0] = op_dst;
 7501     n1-&gt;_opnds[1] = op_base;
 7502     n1-&gt;_opnds[2] = op_src;
 7503     n1-&gt;_bottom_type = _bottom_type;
 7504 
 7505     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
 7506     n2-&gt;add_req(n_region, n1);
 7507     n2-&gt;_opnds[0] = op_dst;
 7508     n2-&gt;_opnds[1] = op_dst;
 7509     n2-&gt;_bottom_type = _bottom_type;
 7510 
 7511     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7512     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7513 
 7514     nodes-&gt;push(n1);
 7515     nodes-&gt;push(n2);
 7516   %}
 7517 %}
 7518 
 7519 // src != 0, shift != 0, base != 0
 7520 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
 7521   match(Set dst (DecodeNKlass src));
 7522   // predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7523   //           CompressedKlassPointers::base() != 0);
 7524 
 7525   //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
 7526 
 7527   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7528   expand %{
 7529     // We add first, then we shift. Like this, we can get along with one register less.
 7530     // But we have to load the base pre-shifted.
 7531     immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift()) %}
 7532     iRegLdst base;
 7533     loadConL_Ex(base, baseImm);
 7534     decodeNKlass_notNull_addBase_Ex(dst, base, src);
 7535   %}
 7536 %}
 7537 
 7538 //----------MemBar Instructions-----------------------------------------------
 7539 // Memory barrier flavors
 7540 
 7541 instruct membar_acquire() %{
 7542   match(LoadFence);
 7543   ins_cost(4*MEMORY_REF_COST);
 7544 
 7545   format %{ &quot;MEMBAR-acquire&quot; %}
 7546   size(4);
 7547   ins_encode %{
 7548     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7549     __ acquire();
 7550   %}
 7551   ins_pipe(pipe_class_default);
 7552 %}
 7553 
 7554 instruct unnecessary_membar_acquire() %{
 7555   match(MemBarAcquire);
 7556   ins_cost(0);
 7557 
 7558   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty&quot; %}
 7559   size(0);
 7560   ins_encode( /*empty*/ );
 7561   ins_pipe(pipe_class_default);
 7562 %}
 7563 
 7564 instruct membar_acquire_lock() %{
 7565   match(MemBarAcquireLock);
 7566   ins_cost(0);
 7567 
 7568   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty (acquire as part of CAS in prior FastLock)&quot; %}
 7569   size(0);
 7570   ins_encode( /*empty*/ );
 7571   ins_pipe(pipe_class_default);
 7572 %}
 7573 
 7574 instruct membar_release() %{
 7575   match(MemBarRelease);
 7576   match(StoreFence);
 7577   ins_cost(4*MEMORY_REF_COST);
 7578 
 7579   format %{ &quot;MEMBAR-release&quot; %}
 7580   size(4);
 7581   ins_encode %{
 7582     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7583     __ release();
 7584   %}
 7585   ins_pipe(pipe_class_default);
 7586 %}
 7587 
 7588 instruct membar_storestore() %{
 7589   match(MemBarStoreStore);
 7590   ins_cost(4*MEMORY_REF_COST);
 7591 
 7592   format %{ &quot;MEMBAR-store-store&quot; %}
 7593   size(4);
 7594   ins_encode %{
 7595     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7596     __ membar(Assembler::StoreStore);
 7597   %}
 7598   ins_pipe(pipe_class_default);
 7599 %}
 7600 
 7601 instruct membar_release_lock() %{
 7602   match(MemBarReleaseLock);
 7603   ins_cost(0);
 7604 
 7605   format %{ &quot; -- \t// redundant MEMBAR-release - empty (release in FastUnlock)&quot; %}
 7606   size(0);
 7607   ins_encode( /*empty*/ );
 7608   ins_pipe(pipe_class_default);
 7609 %}
 7610 
 7611 instruct membar_volatile() %{
 7612   match(MemBarVolatile);
 7613   ins_cost(4*MEMORY_REF_COST);
 7614 
 7615   format %{ &quot;MEMBAR-volatile&quot; %}
 7616   size(4);
 7617   ins_encode %{
 7618     // TODO: PPC port $archOpcode(ppc64Opcode_sync);
 7619     __ fence();
 7620   %}
 7621   ins_pipe(pipe_class_default);
 7622 %}
 7623 
 7624 // This optimization is wrong on PPC. The following pattern is not supported:
 7625 //  MemBarVolatile
 7626 //   ^        ^
 7627 //   |        |
 7628 //  CtrlProj MemProj
 7629 //   ^        ^
 7630 //   |        |
 7631 //   |       Load
 7632 //   |
 7633 //  MemBarVolatile
 7634 //
 7635 //  The first MemBarVolatile could get optimized out! According to
 7636 //  Vladimir, this pattern can not occur on Oracle platforms.
 7637 //  However, it does occur on PPC64 (because of membars in
 7638 //  inline_unsafe_load_store).
 7639 //
 7640 // Add this node again if we found a good solution for inline_unsafe_load_store().
 7641 // Don&#39;t forget to look at the implementation of post_store_load_barrier again,
 7642 // we did other fixes in that method.
 7643 //instruct unnecessary_membar_volatile() %{
 7644 //  match(MemBarVolatile);
 7645 //  predicate(Matcher::post_store_load_barrier(n));
 7646 //  ins_cost(0);
 7647 //
 7648 //  format %{ &quot; -- \t// redundant MEMBAR-volatile - empty&quot; %}
 7649 //  size(0);
 7650 //  ins_encode( /*empty*/ );
 7651 //  ins_pipe(pipe_class_default);
 7652 //%}
 7653 
 7654 instruct membar_CPUOrder() %{
 7655   match(MemBarCPUOrder);
 7656   ins_cost(0);
 7657 
 7658   format %{ &quot; -- \t// MEMBAR-CPUOrder - empty: PPC64 processors are self-consistent.&quot; %}
 7659   size(0);
 7660   ins_encode( /*empty*/ );
 7661   ins_pipe(pipe_class_default);
 7662 %}
 7663 
 7664 //----------Conditional Move---------------------------------------------------
 7665 
 7666 // Cmove using isel.
 7667 instruct cmovI_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7668   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7669   predicate(VM_Version::has_isel());
 7670   ins_cost(DEFAULT_COST);
 7671 
 7672   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7673   size(4);
 7674   ins_encode %{
 7675     // This is a Power7 instruction for which no machine description
 7676     // exists. Anyways, the scheduler should be off on Power7.
 7677     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7678     int cc        = $cmp$$cmpcode;
 7679     __ isel($dst$$Register, $crx$$CondRegister,
 7680             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7681   %}
 7682   ins_pipe(pipe_class_default);
 7683 %}
 7684 
 7685 instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7686   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7687   predicate(!VM_Version::has_isel());
 7688   ins_cost(DEFAULT_COST+BRANCH_COST);
 7689 
 7690   ins_variable_size_depending_on_alignment(true);
 7691 
 7692   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7693   // Worst case is branch + move + stop, no stop without scheduler
 7694   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7695   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7696   ins_pipe(pipe_class_default);
 7697 %}
 7698 
 7699 instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{
 7700   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7701   ins_cost(DEFAULT_COST+BRANCH_COST);
 7702 
 7703   ins_variable_size_depending_on_alignment(true);
 7704 
 7705   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7706   // Worst case is branch + move + stop, no stop without scheduler
 7707   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7708   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7709   ins_pipe(pipe_class_default);
 7710 %}
 7711 
 7712 // Cmove using isel.
 7713 instruct cmovL_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7714   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7715   predicate(VM_Version::has_isel());
 7716   ins_cost(DEFAULT_COST);
 7717 
 7718   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7719   size(4);
 7720   ins_encode %{
 7721     // This is a Power7 instruction for which no machine description
 7722     // exists. Anyways, the scheduler should be off on Power7.
 7723     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7724     int cc        = $cmp$$cmpcode;
 7725     __ isel($dst$$Register, $crx$$CondRegister,
 7726             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7727   %}
 7728   ins_pipe(pipe_class_default);
 7729 %}
 7730 
 7731 instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7732   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7733   predicate(!VM_Version::has_isel());
 7734   ins_cost(DEFAULT_COST+BRANCH_COST);
 7735 
 7736   ins_variable_size_depending_on_alignment(true);
 7737 
 7738   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7739   // Worst case is branch + move + stop, no stop without scheduler.
 7740   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7741   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7742   ins_pipe(pipe_class_default);
 7743 %}
 7744 
 7745 instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{
 7746   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7747   ins_cost(DEFAULT_COST+BRANCH_COST);
 7748 
 7749   ins_variable_size_depending_on_alignment(true);
 7750 
 7751   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7752   // Worst case is branch + move + stop, no stop without scheduler.
 7753   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7754   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7755   ins_pipe(pipe_class_default);
 7756 %}
 7757 
 7758 // Cmove using isel.
 7759 instruct cmovN_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7760   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7761   predicate(VM_Version::has_isel());
 7762   ins_cost(DEFAULT_COST);
 7763 
 7764   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7765   size(4);
 7766   ins_encode %{
 7767     // This is a Power7 instruction for which no machine description
 7768     // exists. Anyways, the scheduler should be off on Power7.
 7769     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7770     int cc        = $cmp$$cmpcode;
 7771     __ isel($dst$$Register, $crx$$CondRegister,
 7772             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7773   %}
 7774   ins_pipe(pipe_class_default);
 7775 %}
 7776 
 7777 // Conditional move for RegN. Only cmov(reg, reg).
 7778 instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7779   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7780   predicate(!VM_Version::has_isel());
 7781   ins_cost(DEFAULT_COST+BRANCH_COST);
 7782 
 7783   ins_variable_size_depending_on_alignment(true);
 7784 
 7785   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7786   // Worst case is branch + move + stop, no stop without scheduler.
 7787   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7788   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7789   ins_pipe(pipe_class_default);
 7790 %}
 7791 
 7792 instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{
 7793   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7794   ins_cost(DEFAULT_COST+BRANCH_COST);
 7795 
 7796   ins_variable_size_depending_on_alignment(true);
 7797 
 7798   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7799   // Worst case is branch + move + stop, no stop without scheduler.
 7800   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7801   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7802   ins_pipe(pipe_class_default);
 7803 %}
 7804 
 7805 // Cmove using isel.
 7806 instruct cmovP_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegPsrc src) %{
 7807   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7808   predicate(VM_Version::has_isel());
 7809   ins_cost(DEFAULT_COST);
 7810 
 7811   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7812   size(4);
 7813   ins_encode %{
 7814     // This is a Power7 instruction for which no machine description
 7815     // exists. Anyways, the scheduler should be off on Power7.
 7816     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7817     int cc        = $cmp$$cmpcode;
 7818     __ isel($dst$$Register, $crx$$CondRegister,
 7819             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7820   %}
 7821   ins_pipe(pipe_class_default);
 7822 %}
 7823 
 7824 instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{
 7825   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7826   predicate(!VM_Version::has_isel());
 7827   ins_cost(DEFAULT_COST+BRANCH_COST);
 7828 
 7829   ins_variable_size_depending_on_alignment(true);
 7830 
 7831   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7832   // Worst case is branch + move + stop, no stop without scheduler.
 7833   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7834   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7835   ins_pipe(pipe_class_default);
 7836 %}
 7837 
 7838 instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{
 7839   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7840   ins_cost(DEFAULT_COST+BRANCH_COST);
 7841 
 7842   ins_variable_size_depending_on_alignment(true);
 7843 
 7844   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7845   // Worst case is branch + move + stop, no stop without scheduler.
 7846   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7847   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7848   ins_pipe(pipe_class_default);
 7849 %}
 7850 
 7851 instruct cmovF_reg(cmpOp cmp, flagsRegSrc crx, regF dst, regF src) %{
 7852   match(Set dst (CMoveF (Binary cmp crx) (Binary dst src)));
 7853   ins_cost(DEFAULT_COST+BRANCH_COST);
 7854 
 7855   ins_variable_size_depending_on_alignment(true);
 7856 
 7857   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7858   // Worst case is branch + move + stop, no stop without scheduler.
 7859   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7860   ins_encode %{
 7861     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7862     Label done;
 7863     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7864     // Branch if not (cmp crx).
 7865     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7866     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7867     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7868     __ bind(done);
 7869   %}
 7870   ins_pipe(pipe_class_default);
 7871 %}
 7872 
 7873 instruct cmovD_reg(cmpOp cmp, flagsRegSrc crx, regD dst, regD src) %{
 7874   match(Set dst (CMoveD (Binary cmp crx) (Binary dst src)));
 7875   ins_cost(DEFAULT_COST+BRANCH_COST);
 7876 
 7877   ins_variable_size_depending_on_alignment(true);
 7878 
 7879   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7880   // Worst case is branch + move + stop, no stop without scheduler.
 7881   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7882   ins_encode %{
 7883     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7884     Label done;
 7885     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7886     // Branch if not (cmp crx).
 7887     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7888     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7889     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7890     __ bind(done);
 7891   %}
 7892   ins_pipe(pipe_class_default);
 7893 %}
 7894 
 7895 //----------Conditional_store--------------------------------------------------
 7896 // Conditional-store of the updated heap-top.
 7897 // Used during allocation of the shared heap.
 7898 // Sets flags (EQ) on success. Implemented with a CASA on Sparc.
 7899 
 7900 // As compareAndSwapL, but return flag register instead of boolean value in
 7901 // int register.
 7902 // Used by sun/misc/AtomicLongCSImpl.java.
 7903 // Mem_ptr must be a memory operand, else this node does not get
 7904 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7905 // can be rematerialized which leads to errors.
 7906 instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{
 7907   match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));
 7908   effect(TEMP cr0);
 7909   format %{ &quot;CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7910   ins_encode %{
 7911     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7912     __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,
 7913                 MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7914                 noreg, NULL, true);
 7915   %}
 7916   ins_pipe(pipe_class_default);
 7917 %}
 7918 
 7919 // As compareAndSwapP, but return flag register instead of boolean value in
 7920 // int register.
 7921 // This instruction is matched if UseTLAB is off.
 7922 // Mem_ptr must be a memory operand, else this node does not get
 7923 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7924 // can be rematerialized which leads to errors.
 7925 instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{
 7926   match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));
 7927   ins_cost(2*MEMORY_REF_COST);
 7928 
 7929   format %{ &quot;STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7930   ins_encode %{
 7931     // TODO: PPC port $archOpcode(ppc64Opcode_stdcx_);
 7932     __ stdcx_($newVal$$Register, $mem_ptr$$Register);
 7933   %}
 7934   ins_pipe(pipe_class_memory);
 7935 %}
 7936 
 7937 // Implement LoadPLocked. Must be ordered against changes of the memory location
 7938 // by storePConditional.
 7939 // Don&#39;t know whether this is ever used.
 7940 instruct loadPLocked(iRegPdst dst, memory mem) %{
 7941   match(Set dst (LoadPLocked mem));
 7942   ins_cost(2*MEMORY_REF_COST);
 7943 
 7944   format %{ &quot;LDARX   $dst, $mem \t// loadPLocked\n\t&quot; %}
 7945   size(4);
 7946   ins_encode %{
 7947     // TODO: PPC port $archOpcode(ppc64Opcode_ldarx);
 7948     __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 7949   %}
 7950   ins_pipe(pipe_class_memory);
 7951 %}
 7952 
 7953 //----------Compare-And-Swap---------------------------------------------------
 7954 
 7955 // CompareAndSwap{P,I,L} have more than one output, therefore &quot;CmpI
 7956 // (CompareAndSwap ...)&quot; or &quot;If (CmpI (CompareAndSwap ..))&quot;  cannot be
 7957 // matched.
 7958 
 7959 // Strong versions:
 7960 
 7961 instruct compareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7962   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7963   predicate(VM_Version::has_lqarx());
 7964   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7965   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7966   ins_encode %{
 7967     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7968     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7969     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 7970                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7971                 $res$$Register, true);
 7972     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7973       __ isync();
 7974     } else {
 7975       __ sync();
 7976     }
 7977   %}
 7978   ins_pipe(pipe_class_default);
 7979 %}
 7980 
 7981 instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 7982   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7983   predicate(!VM_Version::has_lqarx());
 7984   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 7985   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7986   ins_encode %{
 7987     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7988     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7989     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 7990                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7991                 $res$$Register, true);
 7992     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7993       __ isync();
 7994     } else {
 7995       __ sync();
 7996     }
 7997   %}
 7998   ins_pipe(pipe_class_default);
 7999 %}
 8000 
 8001 instruct compareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8002   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 8003   predicate(VM_Version::has_lqarx());
 8004   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8005   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8006   ins_encode %{
 8007     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8008     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8009     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8010                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8011                 $res$$Register, true);
 8012     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8013       __ isync();
 8014     } else {
 8015       __ sync();
 8016     }
 8017   %}
 8018   ins_pipe(pipe_class_default);
 8019 %}
 8020 
 8021 instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8022   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 8023   predicate(!VM_Version::has_lqarx());
 8024   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8025   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8026   ins_encode %{
 8027     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8028     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8029     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8030                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8031                 $res$$Register, true);
 8032     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8033       __ isync();
 8034     } else {
 8035       __ sync();
 8036     }
 8037   %}
 8038   ins_pipe(pipe_class_default);
 8039 %}
 8040 
 8041 instruct compareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8042   match(Set res (CompareAndSwapI mem_ptr (Binary src1 src2)));
 8043   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8044   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8045   ins_encode %{
 8046     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8047     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8048     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8049                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8050                 $res$$Register, true);
 8051     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8052       __ isync();
 8053     } else {
 8054       __ sync();
 8055     }
 8056   %}
 8057   ins_pipe(pipe_class_default);
 8058 %}
 8059 
 8060 instruct compareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8061   match(Set res (CompareAndSwapN mem_ptr (Binary src1 src2)));
 8062   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8063   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8064   ins_encode %{
 8065     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8066     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8067     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8068                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8069                 $res$$Register, true);
 8070     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8071       __ isync();
 8072     } else {
 8073       __ sync();
 8074     }
 8075   %}
 8076   ins_pipe(pipe_class_default);
 8077 %}
 8078 
 8079 instruct compareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8080   match(Set res (CompareAndSwapL mem_ptr (Binary src1 src2)));
 8081   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8082   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8083   ins_encode %{
 8084     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8085     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8086     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8087                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8088                 $res$$Register, NULL, true);
 8089     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8090       __ isync();
 8091     } else {
 8092       __ sync();
 8093     }
 8094   %}
 8095   ins_pipe(pipe_class_default);
 8096 %}
 8097 
 8098 instruct compareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8099   match(Set res (CompareAndSwapP mem_ptr (Binary src1 src2)));
 8100   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8101   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8102   ins_encode %{
 8103     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8104     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8105     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8106                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8107                 $res$$Register, NULL, true);
 8108     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8109       __ isync();
 8110     } else {
 8111       __ sync();
 8112     }
 8113   %}
 8114   ins_pipe(pipe_class_default);
 8115 %}
 8116 
 8117 // Weak versions:
 8118 
 8119 instruct weakCompareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8120   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8121   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8122   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8123   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8124   ins_encode %{
 8125     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8126     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8127     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8128                 MacroAssembler::MemBarNone,
 8129                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8130   %}
 8131   ins_pipe(pipe_class_default);
 8132 %}
 8133 
 8134 instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8135   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8136   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8137   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8138   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8139   ins_encode %{
 8140     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8141     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8142     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8143                 MacroAssembler::MemBarNone,
 8144                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8145   %}
 8146   ins_pipe(pipe_class_default);
 8147 %}
 8148 
 8149 instruct weakCompareAndSwapB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8150   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8151   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8152   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8153   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8154   ins_encode %{
 8155     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8156     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8157     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8158                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8159                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8160   %}
 8161   ins_pipe(pipe_class_default);
 8162 %}
 8163 
 8164 instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8165   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8166   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8167   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8168   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8169   ins_encode %{
 8170     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8171     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8172     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8173                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8174                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8175   %}
 8176   ins_pipe(pipe_class_default);
 8177 %}
 8178 
 8179 instruct weakCompareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8180   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8181   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8182   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8183   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8184   ins_encode %{
 8185     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8186     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8187     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8188                 MacroAssembler::MemBarNone,
 8189                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8190   %}
 8191   ins_pipe(pipe_class_default);
 8192 %}
 8193 
 8194 instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8195   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8196   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8197   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8198   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8199   ins_encode %{
 8200     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8201     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8202     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8203                 MacroAssembler::MemBarNone,
 8204                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8205   %}
 8206   ins_pipe(pipe_class_default);
 8207 %}
 8208 
 8209 instruct weakCompareAndSwapS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8210   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8211   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8212   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8213   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8214   ins_encode %{
 8215     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8216     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8217     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8218                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8219                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8220   %}
 8221   ins_pipe(pipe_class_default);
 8222 %}
 8223 
 8224 instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8225   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8226   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8227   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8228   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8229   ins_encode %{
 8230     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8231     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8232     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8233                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8234                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8235   %}
 8236   ins_pipe(pipe_class_default);
 8237 %}
 8238 
 8239 instruct weakCompareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8240   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8241   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8242   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8243   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8244   ins_encode %{
 8245     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8246     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8247     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8248                 MacroAssembler::MemBarNone,
 8249                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8250   %}
 8251   ins_pipe(pipe_class_default);
 8252 %}
 8253 
 8254 instruct weakCompareAndSwapI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8255   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8256   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8257   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8258   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8259   ins_encode %{
 8260     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8261     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8262     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8263     // value is never passed to caller.
 8264     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8265                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8266                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8267   %}
 8268   ins_pipe(pipe_class_default);
 8269 %}
 8270 
 8271 instruct weakCompareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8272   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8273   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8274   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8275   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8276   ins_encode %{
 8277     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8278     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8279     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8280                 MacroAssembler::MemBarNone,
 8281                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8282   %}
 8283   ins_pipe(pipe_class_default);
 8284 %}
 8285 
 8286 instruct weakCompareAndSwapN_acq_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8287   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8288   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8289   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8290   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8291   ins_encode %{
 8292     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8293     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8294     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8295     // value is never passed to caller.
 8296     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8297                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8298                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8299   %}
 8300   ins_pipe(pipe_class_default);
 8301 %}
 8302 
 8303 instruct weakCompareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8304   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8305   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8306   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8307   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8308   ins_encode %{
 8309     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8310     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8311     // value is never passed to caller.
 8312     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8313                 MacroAssembler::MemBarNone,
 8314                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8315   %}
 8316   ins_pipe(pipe_class_default);
 8317 %}
 8318 
 8319 instruct weakCompareAndSwapL_acq_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8320   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8321   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8322   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8323   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8324   ins_encode %{
 8325     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8326     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8327     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8328     // value is never passed to caller.
 8329     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8330                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8331                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8332   %}
 8333   ins_pipe(pipe_class_default);
 8334 %}
 8335 
 8336 instruct weakCompareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8337   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8338   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8339   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8340   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8341   ins_encode %{
 8342     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8343     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8344     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8345                 MacroAssembler::MemBarNone,
 8346                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8347   %}
 8348   ins_pipe(pipe_class_default);
 8349 %}
 8350 
 8351 instruct weakCompareAndSwapP_acq_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8352   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8353   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8354   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8355   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8356   ins_encode %{
 8357     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8358     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8359     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8360     // value is never passed to caller.
 8361     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8362                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8363                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8364   %}
 8365   ins_pipe(pipe_class_default);
 8366 %}
 8367 
 8368 // CompareAndExchange
 8369 
 8370 instruct compareAndExchangeB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8371   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8372   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8373   effect(TEMP_DEF res, TEMP cr0);
 8374   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8375   ins_encode %{
 8376     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8377     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8378     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8379                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8380                 noreg, true);
 8381   %}
 8382   ins_pipe(pipe_class_default);
 8383 %}
 8384 
 8385 instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8386   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8387   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8388   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8389   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8390   ins_encode %{
 8391     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8392     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8393     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8394                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8395                 noreg, true);
 8396   %}
 8397   ins_pipe(pipe_class_default);
 8398 %}
 8399 
 8400 instruct compareAndExchangeB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8401   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8402   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8403   effect(TEMP_DEF res, TEMP cr0);
 8404   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8405   ins_encode %{
 8406     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8407     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8408     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8409                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8410                 noreg, true);
 8411     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8412       __ isync();
 8413     } else {
 8414       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8415       __ sync();
 8416     }
 8417   %}
 8418   ins_pipe(pipe_class_default);
 8419 %}
 8420 
 8421 instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8422   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8423   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8424   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8425   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8426   ins_encode %{
 8427     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8428     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8429     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8430                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8431                 noreg, true);
 8432     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8433       __ isync();
 8434     } else {
 8435       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8436       __ sync();
 8437     }
 8438   %}
 8439   ins_pipe(pipe_class_default);
 8440 %}
 8441 
 8442 instruct compareAndExchangeS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8443   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8444   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8445   effect(TEMP_DEF res, TEMP cr0);
 8446   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8447   ins_encode %{
 8448     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8449     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8450     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8451                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8452                 noreg, true);
 8453   %}
 8454   ins_pipe(pipe_class_default);
 8455 %}
 8456 
 8457 instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8458   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8459   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8460   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8461   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8462   ins_encode %{
 8463     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8464     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8465     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8466                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8467                 noreg, true);
 8468   %}
 8469   ins_pipe(pipe_class_default);
 8470 %}
 8471 
 8472 instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8473   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8474   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8475   effect(TEMP_DEF res, TEMP cr0);
 8476   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8477   ins_encode %{
 8478     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8479     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8480     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8481                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8482                 noreg, true);
 8483     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8484       __ isync();
 8485     } else {
 8486       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8487       __ sync();
 8488     }
 8489   %}
 8490   ins_pipe(pipe_class_default);
 8491 %}
 8492 
 8493 instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8494   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8495   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8496   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8497   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8498   ins_encode %{
 8499     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8500     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8501     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8502                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8503                 noreg, true);
 8504     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8505       __ isync();
 8506     } else {
 8507       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8508       __ sync();
 8509     }
 8510   %}
 8511   ins_pipe(pipe_class_default);
 8512 %}
 8513 
 8514 instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8515   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8516   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8517   effect(TEMP_DEF res, TEMP cr0);
 8518   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8519   ins_encode %{
 8520     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8521     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8522     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8523                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8524                 noreg, true);
 8525   %}
 8526   ins_pipe(pipe_class_default);
 8527 %}
 8528 
 8529 instruct compareAndExchangeI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8530   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8531   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8532   effect(TEMP_DEF res, TEMP cr0);
 8533   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8534   ins_encode %{
 8535     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8536     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8537     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8538                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8539                 noreg, true);
 8540     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8541       __ isync();
 8542     } else {
 8543       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8544       __ sync();
 8545     }
 8546   %}
 8547   ins_pipe(pipe_class_default);
 8548 %}
 8549 
 8550 instruct compareAndExchangeN_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8551   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8552   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8553   effect(TEMP_DEF res, TEMP cr0);
 8554   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8555   ins_encode %{
 8556     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8557     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8558     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8559                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8560                 noreg, true);
 8561   %}
 8562   ins_pipe(pipe_class_default);
 8563 %}
 8564 
 8565 instruct compareAndExchangeN_acq_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8566   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8567   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8568   effect(TEMP_DEF res, TEMP cr0);
 8569   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8570   ins_encode %{
 8571     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8572     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8573     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8574                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8575                 noreg, true);
 8576     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8577       __ isync();
 8578     } else {
 8579       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8580       __ sync();
 8581     }
 8582   %}
 8583   ins_pipe(pipe_class_default);
 8584 %}
 8585 
 8586 instruct compareAndExchangeL_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8587   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8588   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8589   effect(TEMP_DEF res, TEMP cr0);
 8590   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8591   ins_encode %{
 8592     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8593     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8594     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8595                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8596                 noreg, NULL, true);
 8597   %}
 8598   ins_pipe(pipe_class_default);
 8599 %}
 8600 
 8601 instruct compareAndExchangeL_acq_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8602   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8603   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8604   effect(TEMP_DEF res, TEMP cr0);
 8605   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8606   ins_encode %{
 8607     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8608     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8609     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8610                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8611                 noreg, NULL, true);
 8612     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8613       __ isync();
 8614     } else {
 8615       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8616       __ sync();
 8617     }
 8618   %}
 8619   ins_pipe(pipe_class_default);
 8620 %}
 8621 
 8622 instruct compareAndExchangeP_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8623   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8624   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8625   effect(TEMP_DEF res, TEMP cr0);
 8626   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8627   ins_encode %{
 8628     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8629     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8630     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8631                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8632                 noreg, NULL, true);
 8633   %}
 8634   ins_pipe(pipe_class_default);
 8635 %}
 8636 
 8637 instruct compareAndExchangeP_acq_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8638   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8639   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8640   effect(TEMP_DEF res, TEMP cr0);
 8641   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8642   ins_encode %{
 8643     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8644     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8645     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8646                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8647                 noreg, NULL, true);
 8648     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8649       __ isync();
 8650     } else {
 8651       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8652       __ sync();
 8653     }
 8654   %}
 8655   ins_pipe(pipe_class_default);
 8656 %}
 8657 
 8658 // Special RMW
 8659 
 8660 instruct getAndAddB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8661   match(Set res (GetAndAddB mem_ptr src));
 8662   predicate(VM_Version::has_lqarx());
 8663   effect(TEMP_DEF res, TEMP cr0);
 8664   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8665   ins_encode %{
 8666     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8667                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8668     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8669       __ isync();
 8670     } else {
 8671       __ sync();
 8672     }
 8673   %}
 8674   ins_pipe(pipe_class_default);
 8675 %}
 8676 
 8677 instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8678   match(Set res (GetAndAddB mem_ptr src));
 8679   predicate(!VM_Version::has_lqarx());
 8680   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8681   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8682   ins_encode %{
 8683     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8684                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8685     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8686       __ isync();
 8687     } else {
 8688       __ sync();
 8689     }
 8690   %}
 8691   ins_pipe(pipe_class_default);
 8692 %}
 8693 
 8694 instruct getAndAddS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8695   match(Set res (GetAndAddS mem_ptr src));
 8696   predicate(VM_Version::has_lqarx());
 8697   effect(TEMP_DEF res, TEMP cr0);
 8698   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8699   ins_encode %{
 8700     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8701                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8702     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8703       __ isync();
 8704     } else {
 8705       __ sync();
 8706     }
 8707   %}
 8708   ins_pipe(pipe_class_default);
 8709 %}
 8710 
 8711 instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8712   match(Set res (GetAndAddS mem_ptr src));
 8713   predicate(!VM_Version::has_lqarx());
 8714   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8715   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8716   ins_encode %{
 8717     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8718                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8719     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8720       __ isync();
 8721     } else {
 8722       __ sync();
 8723     }
 8724   %}
 8725   ins_pipe(pipe_class_default);
 8726 %}
 8727 
 8728 instruct getAndAddI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8729   match(Set res (GetAndAddI mem_ptr src));
 8730   effect(TEMP_DEF res, TEMP cr0);
 8731   format %{ &quot;GetAndAddI $res, $mem_ptr, $src&quot; %}
 8732   ins_encode %{
 8733     __ getandaddw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8734                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8735     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8736       __ isync();
 8737     } else {
 8738       __ sync();
 8739     }
 8740   %}
 8741   ins_pipe(pipe_class_default);
 8742 %}
 8743 
 8744 instruct getAndAddL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8745   match(Set res (GetAndAddL mem_ptr src));
 8746   effect(TEMP_DEF res, TEMP cr0);
 8747   format %{ &quot;GetAndAddL $res, $mem_ptr, $src&quot; %}
 8748   ins_encode %{
 8749     __ getandaddd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8750                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8751     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8752       __ isync();
 8753     } else {
 8754       __ sync();
 8755     }
 8756   %}
 8757   ins_pipe(pipe_class_default);
 8758 %}
 8759 
 8760 instruct getAndSetB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8761   match(Set res (GetAndSetB mem_ptr src));
 8762   predicate(VM_Version::has_lqarx());
 8763   effect(TEMP_DEF res, TEMP cr0);
 8764   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8765   ins_encode %{
 8766     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8767                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8768     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8769       __ isync();
 8770     } else {
 8771       __ sync();
 8772     }
 8773   %}
 8774   ins_pipe(pipe_class_default);
 8775 %}
 8776 
 8777 instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8778   match(Set res (GetAndSetB mem_ptr src));
 8779   predicate(!VM_Version::has_lqarx());
 8780   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8781   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8782   ins_encode %{
 8783     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8784                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8785     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8786       __ isync();
 8787     } else {
 8788       __ sync();
 8789     }
 8790   %}
 8791   ins_pipe(pipe_class_default);
 8792 %}
 8793 
 8794 instruct getAndSetS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8795   match(Set res (GetAndSetS mem_ptr src));
 8796   predicate(VM_Version::has_lqarx());
 8797   effect(TEMP_DEF res, TEMP cr0);
 8798   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8799   ins_encode %{
 8800     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8801                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8802     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8803       __ isync();
 8804     } else {
 8805       __ sync();
 8806     }
 8807   %}
 8808   ins_pipe(pipe_class_default);
 8809 %}
 8810 
 8811 instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8812   match(Set res (GetAndSetS mem_ptr src));
 8813   predicate(!VM_Version::has_lqarx());
 8814   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8815   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8816   ins_encode %{
 8817     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8818                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8819     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8820       __ isync();
 8821     } else {
 8822       __ sync();
 8823     }
 8824   %}
 8825   ins_pipe(pipe_class_default);
 8826 %}
 8827 
 8828 instruct getAndSetI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8829   match(Set res (GetAndSetI mem_ptr src));
 8830   effect(TEMP_DEF res, TEMP cr0);
 8831   format %{ &quot;GetAndSetI $res, $mem_ptr, $src&quot; %}
 8832   ins_encode %{
 8833     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8834                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8835     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8836       __ isync();
 8837     } else {
 8838       __ sync();
 8839     }
 8840   %}
 8841   ins_pipe(pipe_class_default);
 8842 %}
 8843 
 8844 instruct getAndSetL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8845   match(Set res (GetAndSetL mem_ptr src));
 8846   effect(TEMP_DEF res, TEMP cr0);
 8847   format %{ &quot;GetAndSetL $res, $mem_ptr, $src&quot; %}
 8848   ins_encode %{
 8849     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8850                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8851     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8852       __ isync();
 8853     } else {
 8854       __ sync();
 8855     }
 8856   %}
 8857   ins_pipe(pipe_class_default);
 8858 %}
 8859 
 8860 instruct getAndSetP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src, flagsRegCR0 cr0) %{
 8861   match(Set res (GetAndSetP mem_ptr src));
 8862   effect(TEMP_DEF res, TEMP cr0);
 8863   format %{ &quot;GetAndSetP $res, $mem_ptr, $src&quot; %}
 8864   ins_encode %{
 8865     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8866                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8867     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8868       __ isync();
 8869     } else {
 8870       __ sync();
 8871     }
 8872   %}
 8873   ins_pipe(pipe_class_default);
 8874 %}
 8875 
 8876 instruct getAndSetN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src, flagsRegCR0 cr0) %{
 8877   match(Set res (GetAndSetN mem_ptr src));
 8878   effect(TEMP_DEF res, TEMP cr0);
 8879   format %{ &quot;GetAndSetN $res, $mem_ptr, $src&quot; %}
 8880   ins_encode %{
 8881     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8882                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8883     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8884       __ isync();
 8885     } else {
 8886       __ sync();
 8887     }
 8888   %}
 8889   ins_pipe(pipe_class_default);
 8890 %}
 8891 
 8892 //----------Arithmetic Instructions--------------------------------------------
 8893 // Addition Instructions
 8894 
 8895 // Register Addition
 8896 instruct addI_reg_reg(iRegIdst dst, iRegIsrc_iRegL2Isrc src1, iRegIsrc_iRegL2Isrc src2) %{
 8897   match(Set dst (AddI src1 src2));
 8898   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8899   size(4);
 8900   ins_encode %{
 8901     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8902     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8903   %}
 8904   ins_pipe(pipe_class_default);
 8905 %}
 8906 
 8907 // Expand does not work with above instruct. (??)
 8908 instruct addI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 8909   // no match-rule
 8910   effect(DEF dst, USE src1, USE src2);
 8911   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8912   size(4);
 8913   ins_encode %{
 8914     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8915     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8916   %}
 8917   ins_pipe(pipe_class_default);
 8918 %}
 8919 
 8920 instruct tree_addI_addI_addI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
 8921   match(Set dst (AddI (AddI (AddI src1 src2) src3) src4));
 8922   ins_cost(DEFAULT_COST*3);
 8923 
 8924   expand %{
 8925     // FIXME: we should do this in the ideal world.
 8926     iRegIdst tmp1;
 8927     iRegIdst tmp2;
 8928     addI_reg_reg(tmp1, src1, src2);
 8929     addI_reg_reg_2(tmp2, src3, src4); // Adlc complains about addI_reg_reg.
 8930     addI_reg_reg(dst, tmp1, tmp2);
 8931   %}
 8932 %}
 8933 
 8934 // Immediate Addition
 8935 instruct addI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 8936   match(Set dst (AddI src1 src2));
 8937   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 8938   size(4);
 8939   ins_encode %{
 8940     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 8941     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 8942   %}
 8943   ins_pipe(pipe_class_default);
 8944 %}
 8945 
 8946 // Immediate Addition with 16-bit shifted operand
 8947 instruct addI_reg_immhi16(iRegIdst dst, iRegIsrc src1, immIhi16 src2) %{
 8948   match(Set dst (AddI src1 src2));
 8949   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 8950   size(4);
 8951   ins_encode %{
 8952     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 8953     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 8954   %}
 8955   ins_pipe(pipe_class_default);
 8956 %}
 8957 
 8958 // Long Addition
 8959 instruct addL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8960   match(Set dst (AddL src1 src2));
 8961   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8962   size(4);
 8963   ins_encode %{
 8964     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8965     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8966   %}
 8967   ins_pipe(pipe_class_default);
 8968 %}
 8969 
 8970 // Expand does not work with above instruct. (??)
 8971 instruct addL_reg_reg_2(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8972   // no match-rule
 8973   effect(DEF dst, USE src1, USE src2);
 8974   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8975   size(4);
 8976   ins_encode %{
 8977     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8978     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8979   %}
 8980   ins_pipe(pipe_class_default);
 8981 %}
 8982 
 8983 instruct tree_addL_addL_addL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2, iRegLsrc src3, iRegLsrc src4) %{
 8984   match(Set dst (AddL (AddL (AddL src1 src2) src3) src4));
 8985   ins_cost(DEFAULT_COST*3);
 8986 
 8987   expand %{
 8988     // FIXME: we should do this in the ideal world.
 8989     iRegLdst tmp1;
 8990     iRegLdst tmp2;
 8991     addL_reg_reg(tmp1, src1, src2);
 8992     addL_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
 8993     addL_reg_reg(dst, tmp1, tmp2);
 8994   %}
 8995 %}
 8996 
 8997 // AddL + ConvL2I.
 8998 instruct addI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8999   match(Set dst (ConvL2I (AddL src1 src2)));
 9000 
 9001   format %{ &quot;ADD     $dst, $src1, $src2 \t// long + l2i&quot; %}
 9002   size(4);
 9003   ins_encode %{
 9004     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 9005     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 9006   %}
 9007   ins_pipe(pipe_class_default);
 9008 %}
 9009 
 9010 // No constant pool entries required.
 9011 instruct addL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9012   match(Set dst (AddL src1 src2));
 9013 
 9014   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9015   size(4);
 9016   ins_encode %{
 9017     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9018     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9019   %}
 9020   ins_pipe(pipe_class_default);
 9021 %}
 9022 
 9023 // Long Immediate Addition with 16-bit shifted operand.
 9024 // No constant pool entries required.
 9025 instruct addL_reg_immhi16(iRegLdst dst, iRegLsrc src1, immL32hi16 src2) %{
 9026   match(Set dst (AddL src1 src2));
 9027 
 9028   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9029   size(4);
 9030   ins_encode %{
 9031     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9032     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9033   %}
 9034   ins_pipe(pipe_class_default);
 9035 %}
 9036 
 9037 // Pointer Register Addition
 9038 instruct addP_reg_reg(iRegPdst dst, iRegP_N2P src1, iRegLsrc src2) %{
 9039   match(Set dst (AddP src1 src2));
 9040   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 9041   size(4);
 9042   ins_encode %{
 9043     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 9044     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 9045   %}
 9046   ins_pipe(pipe_class_default);
 9047 %}
 9048 
 9049 // Pointer Immediate Addition
 9050 // No constant pool entries required.
 9051 instruct addP_reg_imm16(iRegPdst dst, iRegP_N2P src1, immL16 src2) %{
 9052   match(Set dst (AddP src1 src2));
 9053 
 9054   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9055   size(4);
 9056   ins_encode %{
 9057     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9058     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9059   %}
 9060   ins_pipe(pipe_class_default);
 9061 %}
 9062 
 9063 // Pointer Immediate Addition with 16-bit shifted operand.
 9064 // No constant pool entries required.
 9065 instruct addP_reg_immhi16(iRegPdst dst, iRegP_N2P src1, immL32hi16 src2) %{
 9066   match(Set dst (AddP src1 src2));
 9067 
 9068   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9069   size(4);
 9070   ins_encode %{
 9071     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9072     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9073   %}
 9074   ins_pipe(pipe_class_default);
 9075 %}
 9076 
 9077 //---------------------
 9078 // Subtraction Instructions
 9079 
 9080 // Register Subtraction
 9081 instruct subI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9082   match(Set dst (SubI src1 src2));
 9083   format %{ &quot;SUBF    $dst, $src2, $src1&quot; %}
 9084   size(4);
 9085   ins_encode %{
 9086     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9087     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9088   %}
 9089   ins_pipe(pipe_class_default);
 9090 %}
 9091 
 9092 // Immediate Subtraction
 9093 // Immediate Subtraction: The compiler converts &quot;x-c0&quot; into &quot;x+ -c0&quot; (see SubLNode::Ideal),
 9094 // Don&#39;t try to use addi with - $src2$$constant since it can overflow when $src2$$constant == minI16.
 9095 
 9096 // SubI from constant (using subfic).
 9097 instruct subI_imm16_reg(iRegIdst dst, immI16 src1, iRegIsrc src2) %{
 9098   match(Set dst (SubI src1 src2));
 9099   format %{ &quot;SUBI    $dst, $src1, $src2&quot; %}
 9100 
 9101   size(4);
 9102   ins_encode %{
 9103     // TODO: PPC port $archOpcode(ppc64Opcode_subfic);
 9104     __ subfic($dst$$Register, $src2$$Register, $src1$$constant);
 9105   %}
 9106   ins_pipe(pipe_class_default);
 9107 %}
 9108 
 9109 // Turn the sign-bit of an integer into a 32-bit mask, 0x0...0 for
 9110 // positive integers and 0xF...F for negative ones.
 9111 instruct signmask32I_regI(iRegIdst dst, iRegIsrc src) %{
 9112   // no match-rule, false predicate
 9113   effect(DEF dst, USE src);
 9114   predicate(false);
 9115 
 9116   format %{ &quot;SRAWI   $dst, $src, #31&quot; %}
 9117   size(4);
 9118   ins_encode %{
 9119     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9120     __ srawi($dst$$Register, $src$$Register, 0x1f);
 9121   %}
 9122   ins_pipe(pipe_class_default);
 9123 %}
 9124 
 9125 instruct absI_reg_Ex(iRegIdst dst, iRegIsrc src) %{
 9126   match(Set dst (AbsI src));
 9127   ins_cost(DEFAULT_COST*3);
 9128 
 9129   expand %{
 9130     iRegIdst tmp1;
 9131     iRegIdst tmp2;
 9132     signmask32I_regI(tmp1, src);
 9133     xorI_reg_reg(tmp2, tmp1, src);
 9134     subI_reg_reg(dst, tmp2, tmp1);
 9135   %}
 9136 %}
 9137 
 9138 instruct negI_regI(iRegIdst dst, immI_0 zero, iRegIsrc src2) %{
 9139   match(Set dst (SubI zero src2));
 9140   format %{ &quot;NEG     $dst, $src2&quot; %}
 9141   size(4);
 9142   ins_encode %{
 9143     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9144     __ neg($dst$$Register, $src2$$Register);
 9145   %}
 9146   ins_pipe(pipe_class_default);
 9147 %}
 9148 
 9149 // Long subtraction
 9150 instruct subL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9151   match(Set dst (SubL src1 src2));
 9152   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long&quot; %}
 9153   size(4);
 9154   ins_encode %{
 9155     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9156     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9157   %}
 9158   ins_pipe(pipe_class_default);
 9159 %}
 9160 
 9161 // SubL + convL2I.
 9162 instruct subI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9163   match(Set dst (ConvL2I (SubL src1 src2)));
 9164 
 9165   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long + l2i&quot; %}
 9166   size(4);
 9167   ins_encode %{
 9168     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9169     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9170   %}
 9171   ins_pipe(pipe_class_default);
 9172 %}
 9173 
 9174 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9175 // positive longs and 0xF...F for negative ones.
 9176 instruct signmask64I_regL(iRegIdst dst, iRegLsrc src) %{
 9177   // no match-rule, false predicate
 9178   effect(DEF dst, USE src);
 9179   predicate(false);
 9180 
 9181   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9182   size(4);
 9183   ins_encode %{
 9184     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9185     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9186   %}
 9187   ins_pipe(pipe_class_default);
 9188 %}
 9189 
 9190 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9191 // positive longs and 0xF...F for negative ones.
 9192 instruct signmask64L_regL(iRegLdst dst, iRegLsrc src) %{
 9193   // no match-rule, false predicate
 9194   effect(DEF dst, USE src);
 9195   predicate(false);
 9196 
 9197   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9198   size(4);
 9199   ins_encode %{
 9200     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9201     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9202   %}
 9203   ins_pipe(pipe_class_default);
 9204 %}
 9205 
 9206 // Long negation
 9207 instruct negL_reg_reg(iRegLdst dst, immL_0 zero, iRegLsrc src2) %{
 9208   match(Set dst (SubL zero src2));
 9209   format %{ &quot;NEG     $dst, $src2 \t// long&quot; %}
 9210   size(4);
 9211   ins_encode %{
 9212     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9213     __ neg($dst$$Register, $src2$$Register);
 9214   %}
 9215   ins_pipe(pipe_class_default);
 9216 %}
 9217 
 9218 // NegL + ConvL2I.
 9219 instruct negI_con0_regL(iRegIdst dst, immL_0 zero, iRegLsrc src2) %{
 9220   match(Set dst (ConvL2I (SubL zero src2)));
 9221 
 9222   format %{ &quot;NEG     $dst, $src2 \t// long + l2i&quot; %}
 9223   size(4);
 9224   ins_encode %{
 9225     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9226     __ neg($dst$$Register, $src2$$Register);
 9227   %}
 9228   ins_pipe(pipe_class_default);
 9229 %}
 9230 
 9231 // Multiplication Instructions
 9232 // Integer Multiplication
 9233 
 9234 // Register Multiplication
 9235 instruct mulI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9236   match(Set dst (MulI src1 src2));
 9237   ins_cost(DEFAULT_COST);
 9238 
 9239   format %{ &quot;MULLW   $dst, $src1, $src2&quot; %}
 9240   size(4);
 9241   ins_encode %{
 9242     // TODO: PPC port $archOpcode(ppc64Opcode_mullw);
 9243     __ mullw($dst$$Register, $src1$$Register, $src2$$Register);
 9244   %}
 9245   ins_pipe(pipe_class_default);
 9246 %}
 9247 
 9248 // Immediate Multiplication
 9249 instruct mulI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 9250   match(Set dst (MulI src1 src2));
 9251   ins_cost(DEFAULT_COST);
 9252 
 9253   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9254   size(4);
 9255   ins_encode %{
 9256     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9257     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9258   %}
 9259   ins_pipe(pipe_class_default);
 9260 %}
 9261 
 9262 instruct mulL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9263   match(Set dst (MulL src1 src2));
 9264   ins_cost(DEFAULT_COST);
 9265 
 9266   format %{ &quot;MULLD   $dst $src1, $src2 \t// long&quot; %}
 9267   size(4);
 9268   ins_encode %{
 9269     // TODO: PPC port $archOpcode(ppc64Opcode_mulld);
 9270     __ mulld($dst$$Register, $src1$$Register, $src2$$Register);
 9271   %}
 9272   ins_pipe(pipe_class_default);
 9273 %}
 9274 
 9275 // Multiply high for optimized long division by constant.
 9276 instruct mulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9277   match(Set dst (MulHiL src1 src2));
 9278   ins_cost(DEFAULT_COST);
 9279 
 9280   format %{ &quot;MULHD   $dst $src1, $src2 \t// long&quot; %}
 9281   size(4);
 9282   ins_encode %{
 9283     // TODO: PPC port $archOpcode(ppc64Opcode_mulhd);
 9284     __ mulhd($dst$$Register, $src1$$Register, $src2$$Register);
 9285   %}
 9286   ins_pipe(pipe_class_default);
 9287 %}
 9288 
 9289 // Immediate Multiplication
 9290 instruct mulL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9291   match(Set dst (MulL src1 src2));
 9292   ins_cost(DEFAULT_COST);
 9293 
 9294   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9295   size(4);
 9296   ins_encode %{
 9297     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9298     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9299   %}
 9300   ins_pipe(pipe_class_default);
 9301 %}
 9302 
 9303 // Integer Division with Immediate -1: Negate.
 9304 instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
 9305   match(Set dst (DivI src1 src2));
 9306   ins_cost(DEFAULT_COST);
 9307 
 9308   format %{ &quot;NEG     $dst, $src1 \t// /-1&quot; %}
 9309   size(4);
 9310   ins_encode %{
 9311     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9312     __ neg($dst$$Register, $src1$$Register);
 9313   %}
 9314   ins_pipe(pipe_class_default);
 9315 %}
 9316 
 9317 // Integer Division with constant, but not -1.
 9318 // We should be able to improve this by checking the type of src2.
 9319 // It might well be that src2 is known to be positive.
 9320 instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9321   match(Set dst (DivI src1 src2));
 9322   predicate(n-&gt;in(2)-&gt;find_int_con(-1) != -1); // src2 is a constant, but not -1
 9323   ins_cost(2*DEFAULT_COST);
 9324 
 9325   format %{ &quot;DIVW    $dst, $src1, $src2 \t// /not-1&quot; %}
 9326   size(4);
 9327   ins_encode %{
 9328     // TODO: PPC port $archOpcode(ppc64Opcode_divw);
 9329     __ divw($dst$$Register, $src1$$Register, $src2$$Register);
 9330   %}
 9331   ins_pipe(pipe_class_default);
 9332 %}
 9333 
 9334 instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{
 9335   effect(USE_DEF dst, USE src1, USE crx);
 9336   predicate(false);
 9337 
 9338   ins_variable_size_depending_on_alignment(true);
 9339 
 9340   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9341   // Worst case is branch + move + stop, no stop without scheduler.
 9342   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9343   ins_encode %{
 9344     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9345     Label done;
 9346     __ bne($crx$$CondRegister, done);
 9347     __ neg($dst$$Register, $src1$$Register);
 9348     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9349     __ bind(done);
 9350   %}
 9351   ins_pipe(pipe_class_default);
 9352 %}
 9353 
 9354 // Integer Division with Registers not containing constants.
 9355 instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9356   match(Set dst (DivI src1 src2));
 9357   ins_cost(10*DEFAULT_COST);
 9358 
 9359   expand %{
 9360     immI16 imm %{ (int)-1 %}
 9361     flagsReg tmp1;
 9362     cmpI_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9363     divI_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9364     cmovI_bne_negI_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9365   %}
 9366 %}
 9367 
 9368 // Long Division with Immediate -1: Negate.
 9369 instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
 9370   match(Set dst (DivL src1 src2));
 9371   ins_cost(DEFAULT_COST);
 9372 
 9373   format %{ &quot;NEG     $dst, $src1 \t// /-1, long&quot; %}
 9374   size(4);
 9375   ins_encode %{
 9376     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9377     __ neg($dst$$Register, $src1$$Register);
 9378   %}
 9379   ins_pipe(pipe_class_default);
 9380 %}
 9381 
 9382 // Long Division with constant, but not -1.
 9383 instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9384   match(Set dst (DivL src1 src2));
 9385   predicate(n-&gt;in(2)-&gt;find_long_con(-1L) != -1L); // Src2 is a constant, but not -1.
 9386   ins_cost(2*DEFAULT_COST);
 9387 
 9388   format %{ &quot;DIVD    $dst, $src1, $src2 \t// /not-1, long&quot; %}
 9389   size(4);
 9390   ins_encode %{
 9391     // TODO: PPC port $archOpcode(ppc64Opcode_divd);
 9392     __ divd($dst$$Register, $src1$$Register, $src2$$Register);
 9393   %}
 9394   ins_pipe(pipe_class_default);
 9395 %}
 9396 
 9397 instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{
 9398   effect(USE_DEF dst, USE src1, USE crx);
 9399   predicate(false);
 9400 
 9401   ins_variable_size_depending_on_alignment(true);
 9402 
 9403   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9404   // Worst case is branch + move + stop, no stop without scheduler.
 9405   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9406   ins_encode %{
 9407     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9408     Label done;
 9409     __ bne($crx$$CondRegister, done);
 9410     __ neg($dst$$Register, $src1$$Register);
 9411     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9412     __ bind(done);
 9413   %}
 9414   ins_pipe(pipe_class_default);
 9415 %}
 9416 
 9417 // Long Division with Registers not containing constants.
 9418 instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9419   match(Set dst (DivL src1 src2));
 9420   ins_cost(10*DEFAULT_COST);
 9421 
 9422   expand %{
 9423     immL16 imm %{ (int)-1 %}
 9424     flagsReg tmp1;
 9425     cmpL_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9426     divL_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9427     cmovL_bne_negL_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9428   %}
 9429 %}
 9430 
 9431 // Integer Remainder with registers.
 9432 instruct modI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9433   match(Set dst (ModI src1 src2));
 9434   ins_cost(10*DEFAULT_COST);
 9435 
 9436   expand %{
 9437     immI16 imm %{ (int)-1 %}
 9438     flagsReg tmp1;
 9439     iRegIdst tmp2;
 9440     iRegIdst tmp3;
 9441     cmpI_reg_imm16(tmp1, src2, imm);           // check src2 == -1
 9442     divI_reg_regnotMinus1(tmp2, src1, src2);   // tmp2 = src1 / src2
 9443     cmovI_bne_negI_reg(tmp2, tmp1, src1);      // cmove tmp2 = neg(src1) if src2 == -1
 9444     mulI_reg_reg(tmp3, src2, tmp2);            // tmp3 = src2 * tmp2
 9445     subI_reg_reg(dst, src1, tmp3);             // dst = src1 - tmp3
 9446   %}
 9447 %}
 9448 
 9449 // Long Remainder with registers
 9450 instruct modL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9451   match(Set dst (ModL src1 src2));
 9452   ins_cost(10*DEFAULT_COST);
 9453 
 9454   expand %{
 9455     immL16 imm %{ (int)-1 %}
 9456     flagsReg tmp1;
 9457     iRegLdst tmp2;
 9458     iRegLdst tmp3;
 9459     cmpL_reg_imm16(tmp1, src2, imm);             // check src2 == -1
 9460     divL_reg_regnotMinus1(tmp2, src1, src2);     // tmp2 = src1 / src2
 9461     cmovL_bne_negL_reg(tmp2, tmp1, src1);        // cmove tmp2 = neg(src1) if src2 == -1
 9462     mulL_reg_reg(tmp3, src2, tmp2);              // tmp3 = src2 * tmp2
 9463     subL_reg_reg(dst, src1, tmp3);               // dst = src1 - tmp3
 9464   %}
 9465 %}
 9466 
 9467 // Integer Shift Instructions
 9468 
 9469 // Register Shift Left
 9470 
 9471 // Clear all but the lowest #mask bits.
 9472 // Used to normalize shift amounts in registers.
 9473 instruct maskI_reg_imm(iRegIdst dst, iRegIsrc src, uimmI6 mask) %{
 9474   // no match-rule, false predicate
 9475   effect(DEF dst, USE src, USE mask);
 9476   predicate(false);
 9477 
 9478   format %{ &quot;MASK    $dst, $src, $mask \t// clear $mask upper bits&quot; %}
 9479   size(4);
 9480   ins_encode %{
 9481     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9482     __ clrldi($dst$$Register, $src$$Register, $mask$$constant);
 9483   %}
 9484   ins_pipe(pipe_class_default);
 9485 %}
 9486 
 9487 instruct lShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9488   // no match-rule, false predicate
 9489   effect(DEF dst, USE src1, USE src2);
 9490   predicate(false);
 9491 
 9492   format %{ &quot;SLW     $dst, $src1, $src2&quot; %}
 9493   size(4);
 9494   ins_encode %{
 9495     // TODO: PPC port $archOpcode(ppc64Opcode_slw);
 9496     __ slw($dst$$Register, $src1$$Register, $src2$$Register);
 9497   %}
 9498   ins_pipe(pipe_class_default);
 9499 %}
 9500 
 9501 instruct lShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9502   match(Set dst (LShiftI src1 src2));
 9503   ins_cost(DEFAULT_COST*2);
 9504   expand %{
 9505     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9506     iRegIdst tmpI;
 9507     maskI_reg_imm(tmpI, src2, mask);
 9508     lShiftI_reg_reg(dst, src1, tmpI);
 9509   %}
 9510 %}
 9511 
 9512 // Register Shift Left Immediate
 9513 instruct lShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9514   match(Set dst (LShiftI src1 src2));
 9515 
 9516   format %{ &quot;SLWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9517   size(4);
 9518   ins_encode %{
 9519     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9520     __ slwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9521   %}
 9522   ins_pipe(pipe_class_default);
 9523 %}
 9524 
 9525 // AndI with negpow2-constant + LShiftI
 9526 instruct lShiftI_andI_immInegpow2_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9527   match(Set dst (LShiftI (AndI src1 src2) src3));
 9528   predicate(UseRotateAndMaskInstructionsPPC64);
 9529 
 9530   format %{ &quot;RLWINM  $dst, lShiftI(AndI($src1, $src2), $src3)&quot; %}
 9531   size(4);
 9532   ins_encode %{
 9533     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9534     long src2      = $src2$$constant;
 9535     long src3      = $src3$$constant;
 9536     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9537     if (maskbits &gt;= 32) {
 9538       __ li($dst$$Register, 0); // addi
 9539     } else {
 9540       __ rlwinm($dst$$Register, $src1$$Register, src3 &amp; 0x1f, 0, (31-maskbits) &amp; 0x1f);
 9541     }
 9542   %}
 9543   ins_pipe(pipe_class_default);
 9544 %}
 9545 
 9546 // RShiftI + AndI with negpow2-constant + LShiftI
 9547 instruct lShiftI_andI_immInegpow2_rShiftI_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9548   match(Set dst (LShiftI (AndI (RShiftI src1 src3) src2) src3));
 9549   predicate(UseRotateAndMaskInstructionsPPC64);
 9550 
 9551   format %{ &quot;RLWINM  $dst, lShiftI(AndI(RShiftI($src1, $src3), $src2), $src3)&quot; %}
 9552   size(4);
 9553   ins_encode %{
 9554     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9555     long src2      = $src2$$constant;
 9556     long src3      = $src3$$constant;
 9557     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9558     if (maskbits &gt;= 32) {
 9559       __ li($dst$$Register, 0); // addi
 9560     } else {
 9561       __ rlwinm($dst$$Register, $src1$$Register, 0, 0, (31-maskbits) &amp; 0x1f);
 9562     }
 9563   %}
 9564   ins_pipe(pipe_class_default);
 9565 %}
 9566 
 9567 instruct lShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9568   // no match-rule, false predicate
 9569   effect(DEF dst, USE src1, USE src2);
 9570   predicate(false);
 9571 
 9572   format %{ &quot;SLD     $dst, $src1, $src2&quot; %}
 9573   size(4);
 9574   ins_encode %{
 9575     // TODO: PPC port $archOpcode(ppc64Opcode_sld);
 9576     __ sld($dst$$Register, $src1$$Register, $src2$$Register);
 9577   %}
 9578   ins_pipe(pipe_class_default);
 9579 %}
 9580 
 9581 // Register Shift Left
 9582 instruct lShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9583   match(Set dst (LShiftL src1 src2));
 9584   ins_cost(DEFAULT_COST*2);
 9585   expand %{
 9586     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9587     iRegIdst tmpI;
 9588     maskI_reg_imm(tmpI, src2, mask);
 9589     lShiftL_regL_regI(dst, src1, tmpI);
 9590   %}
 9591 %}
 9592 
 9593 // Register Shift Left Immediate
 9594 instruct lshiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9595   match(Set dst (LShiftL src1 src2));
 9596   format %{ &quot;SLDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9597   size(4);
 9598   ins_encode %{
 9599     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9600     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9601   %}
 9602   ins_pipe(pipe_class_default);
 9603 %}
 9604 
 9605 // If we shift more than 32 bits, we need not convert I2L.
 9606 instruct lShiftL_regI_immGE32(iRegLdst dst, iRegIsrc src1, uimmI6_ge32 src2) %{
 9607   match(Set dst (LShiftL (ConvI2L src1) src2));
 9608   ins_cost(DEFAULT_COST);
 9609 
 9610   size(4);
 9611   format %{ &quot;SLDI    $dst, i2l($src1), $src2&quot; %}
 9612   ins_encode %{
 9613     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9614     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9615   %}
 9616   ins_pipe(pipe_class_default);
 9617 %}
 9618 
 9619 // Shift a postivie int to the left.
 9620 // Clrlsldi clears the upper 32 bits and shifts.
 9621 instruct scaledPositiveI2L_lShiftL_convI2L_reg_imm6(iRegLdst dst, iRegIsrc src1, uimmI6 src2) %{
 9622   match(Set dst (LShiftL (ConvI2L src1) src2));
 9623   predicate(((ConvI2LNode*)(_kids[0]-&gt;_leaf))-&gt;type()-&gt;is_long()-&gt;is_positive_int());
 9624 
 9625   format %{ &quot;SLDI    $dst, i2l(positive_int($src1)), $src2&quot; %}
 9626   size(4);
 9627   ins_encode %{
 9628     // TODO: PPC port $archOpcode(ppc64Opcode_rldic);
 9629     __ clrlsldi($dst$$Register, $src1$$Register, 0x20, $src2$$constant);
 9630   %}
 9631   ins_pipe(pipe_class_default);
 9632 %}
 9633 
 9634 instruct arShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9635   // no match-rule, false predicate
 9636   effect(DEF dst, USE src1, USE src2);
 9637   predicate(false);
 9638 
 9639   format %{ &quot;SRAW    $dst, $src1, $src2&quot; %}
 9640   size(4);
 9641   ins_encode %{
 9642     // TODO: PPC port $archOpcode(ppc64Opcode_sraw);
 9643     __ sraw($dst$$Register, $src1$$Register, $src2$$Register);
 9644   %}
 9645   ins_pipe(pipe_class_default);
 9646 %}
 9647 
 9648 // Register Arithmetic Shift Right
 9649 instruct arShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9650   match(Set dst (RShiftI src1 src2));
 9651   ins_cost(DEFAULT_COST*2);
 9652   expand %{
 9653     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9654     iRegIdst tmpI;
 9655     maskI_reg_imm(tmpI, src2, mask);
 9656     arShiftI_reg_reg(dst, src1, tmpI);
 9657   %}
 9658 %}
 9659 
 9660 // Register Arithmetic Shift Right Immediate
 9661 instruct arShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9662   match(Set dst (RShiftI src1 src2));
 9663 
 9664   format %{ &quot;SRAWI   $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9665   size(4);
 9666   ins_encode %{
 9667     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9668     __ srawi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9669   %}
 9670   ins_pipe(pipe_class_default);
 9671 %}
 9672 
 9673 instruct arShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9674   // no match-rule, false predicate
 9675   effect(DEF dst, USE src1, USE src2);
 9676   predicate(false);
 9677 
 9678   format %{ &quot;SRAD    $dst, $src1, $src2&quot; %}
 9679   size(4);
 9680   ins_encode %{
 9681     // TODO: PPC port $archOpcode(ppc64Opcode_srad);
 9682     __ srad($dst$$Register, $src1$$Register, $src2$$Register);
 9683   %}
 9684   ins_pipe(pipe_class_default);
 9685 %}
 9686 
 9687 // Register Shift Right Arithmetic Long
 9688 instruct arShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9689   match(Set dst (RShiftL src1 src2));
 9690   ins_cost(DEFAULT_COST*2);
 9691 
 9692   expand %{
 9693     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9694     iRegIdst tmpI;
 9695     maskI_reg_imm(tmpI, src2, mask);
 9696     arShiftL_regL_regI(dst, src1, tmpI);
 9697   %}
 9698 %}
 9699 
 9700 // Register Shift Right Immediate
 9701 instruct arShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9702   match(Set dst (RShiftL src1 src2));
 9703 
 9704   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9705   size(4);
 9706   ins_encode %{
 9707     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9708     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9709   %}
 9710   ins_pipe(pipe_class_default);
 9711 %}
 9712 
 9713 // RShiftL + ConvL2I
 9714 instruct convL2I_arShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9715   match(Set dst (ConvL2I (RShiftL src1 src2)));
 9716 
 9717   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9718   size(4);
 9719   ins_encode %{
 9720     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9721     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9722   %}
 9723   ins_pipe(pipe_class_default);
 9724 %}
 9725 
 9726 instruct urShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9727   // no match-rule, false predicate
 9728   effect(DEF dst, USE src1, USE src2);
 9729   predicate(false);
 9730 
 9731   format %{ &quot;SRW     $dst, $src1, $src2&quot; %}
 9732   size(4);
 9733   ins_encode %{
 9734     // TODO: PPC port $archOpcode(ppc64Opcode_srw);
 9735     __ srw($dst$$Register, $src1$$Register, $src2$$Register);
 9736   %}
 9737   ins_pipe(pipe_class_default);
 9738 %}
 9739 
 9740 // Register Shift Right
 9741 instruct urShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9742   match(Set dst (URShiftI src1 src2));
 9743   ins_cost(DEFAULT_COST*2);
 9744 
 9745   expand %{
 9746     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9747     iRegIdst tmpI;
 9748     maskI_reg_imm(tmpI, src2, mask);
 9749     urShiftI_reg_reg(dst, src1, tmpI);
 9750   %}
 9751 %}
 9752 
 9753 // Register Shift Right Immediate
 9754 instruct urShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9755   match(Set dst (URShiftI src1 src2));
 9756 
 9757   format %{ &quot;SRWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9758   size(4);
 9759   ins_encode %{
 9760     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9761     __ srwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9762   %}
 9763   ins_pipe(pipe_class_default);
 9764 %}
 9765 
 9766 instruct urShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9767   // no match-rule, false predicate
 9768   effect(DEF dst, USE src1, USE src2);
 9769   predicate(false);
 9770 
 9771   format %{ &quot;SRD     $dst, $src1, $src2&quot; %}
 9772   size(4);
 9773   ins_encode %{
 9774     // TODO: PPC port $archOpcode(ppc64Opcode_srd);
 9775     __ srd($dst$$Register, $src1$$Register, $src2$$Register);
 9776   %}
 9777   ins_pipe(pipe_class_default);
 9778 %}
 9779 
 9780 // Register Shift Right
 9781 instruct urShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9782   match(Set dst (URShiftL src1 src2));
 9783   ins_cost(DEFAULT_COST*2);
 9784 
 9785   expand %{
 9786     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9787     iRegIdst tmpI;
 9788     maskI_reg_imm(tmpI, src2, mask);
 9789     urShiftL_regL_regI(dst, src1, tmpI);
 9790   %}
 9791 %}
 9792 
 9793 // Register Shift Right Immediate
 9794 instruct urShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9795   match(Set dst (URShiftL src1 src2));
 9796 
 9797   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9798   size(4);
 9799   ins_encode %{
 9800     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9801     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9802   %}
 9803   ins_pipe(pipe_class_default);
 9804 %}
 9805 
 9806 // URShiftL + ConvL2I.
 9807 instruct convL2I_urShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9808   match(Set dst (ConvL2I (URShiftL src1 src2)));
 9809 
 9810   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9811   size(4);
 9812   ins_encode %{
 9813     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9814     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9815   %}
 9816   ins_pipe(pipe_class_default);
 9817 %}
 9818 
 9819 // Register Shift Right Immediate with a CastP2X
 9820 instruct shrP_convP2X_reg_imm6(iRegLdst dst, iRegP_N2P src1, uimmI6 src2) %{
 9821   match(Set dst (URShiftL (CastP2X src1) src2));
 9822 
 9823   format %{ &quot;SRDI    $dst, $src1, $src2 \t// Cast ptr $src1 to long and shift&quot; %}
 9824   size(4);
 9825   ins_encode %{
 9826     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9827     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9828   %}
 9829   ins_pipe(pipe_class_default);
 9830 %}
 9831 
 9832 // Bitfield Extract: URShiftI + AndI
 9833 instruct andI_urShiftI_regI_immI_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immI src2, immIpow2minus1 src3) %{
 9834   match(Set dst (AndI (URShiftI src1 src2) src3));
 9835 
 9836   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// int bitfield extract&quot; %}
 9837   size(4);
 9838   ins_encode %{
 9839     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9840     int rshift = ($src2$$constant) &amp; 0x1f;
 9841     int length = log2_long(((jlong) $src3$$constant) + 1);
 9842     if (rshift + length &gt; 32) {
 9843       // if necessary, adjust mask to omit rotated bits.
 9844       length = 32 - rshift;
 9845     }
 9846     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9847   %}
 9848   ins_pipe(pipe_class_default);
 9849 %}
 9850 
 9851 // Bitfield Extract: URShiftL + AndL
 9852 instruct andL_urShiftL_regL_immI_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immI src2, immLpow2minus1 src3) %{
 9853   match(Set dst (AndL (URShiftL src1 src2) src3));
 9854 
 9855   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// long bitfield extract&quot; %}
 9856   size(4);
 9857   ins_encode %{
 9858     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9859     int rshift  = ($src2$$constant) &amp; 0x3f;
 9860     int length = log2_long(((jlong) $src3$$constant) + 1);
 9861     if (rshift + length &gt; 64) {
 9862       // if necessary, adjust mask to omit rotated bits.
 9863       length = 64 - rshift;
 9864     }
 9865     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9866   %}
 9867   ins_pipe(pipe_class_default);
 9868 %}
 9869 
 9870 instruct sxtI_reg(iRegIdst dst, iRegIsrc src) %{
 9871   match(Set dst (ConvL2I (ConvI2L src)));
 9872 
 9873   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;int&quot; %}
 9874   size(4);
 9875   ins_encode %{
 9876     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
 9877     __ extsw($dst$$Register, $src$$Register);
 9878   %}
 9879   ins_pipe(pipe_class_default);
 9880 %}
 9881 
 9882 //----------Rotate Instructions------------------------------------------------
 9883 
 9884 // Rotate Left by 8-bit immediate
 9885 instruct rotlI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 lshift, immI8 rshift) %{
 9886   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 9887   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9888 
 9889   format %{ &quot;ROTLWI  $dst, $src, $lshift&quot; %}
 9890   size(4);
 9891   ins_encode %{
 9892     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9893     __ rotlwi($dst$$Register, $src$$Register, $lshift$$constant);
 9894   %}
 9895   ins_pipe(pipe_class_default);
 9896 %}
 9897 
 9898 // Rotate Right by 8-bit immediate
 9899 instruct rotrI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 rshift, immI8 lshift) %{
 9900   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 9901   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9902 
 9903   format %{ &quot;ROTRWI  $dst, $rshift&quot; %}
 9904   size(4);
 9905   ins_encode %{
 9906     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9907     __ rotrwi($dst$$Register, $src$$Register, $rshift$$constant);
 9908   %}
 9909   ins_pipe(pipe_class_default);
 9910 %}
 9911 
 9912 //----------Floating Point Arithmetic Instructions-----------------------------
 9913 
 9914 // Add float single precision
 9915 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 9916   match(Set dst (AddF src1 src2));
 9917 
 9918   format %{ &quot;FADDS   $dst, $src1, $src2&quot; %}
 9919   size(4);
 9920   ins_encode %{
 9921     // TODO: PPC port $archOpcode(ppc64Opcode_fadds);
 9922     __ fadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9923   %}
 9924   ins_pipe(pipe_class_default);
 9925 %}
 9926 
 9927 // Add float double precision
 9928 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 9929   match(Set dst (AddD src1 src2));
 9930 
 9931   format %{ &quot;FADD    $dst, $src1, $src2&quot; %}
 9932   size(4);
 9933   ins_encode %{
 9934     // TODO: PPC port $archOpcode(ppc64Opcode_fadd);
 9935     __ fadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9936   %}
 9937   ins_pipe(pipe_class_default);
 9938 %}
 9939 
 9940 // Sub float single precision
 9941 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 9942   match(Set dst (SubF src1 src2));
 9943 
 9944   format %{ &quot;FSUBS   $dst, $src1, $src2&quot; %}
 9945   size(4);
 9946   ins_encode %{
 9947     // TODO: PPC port $archOpcode(ppc64Opcode_fsubs);
 9948     __ fsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9949   %}
 9950   ins_pipe(pipe_class_default);
 9951 %}
 9952 
 9953 // Sub float double precision
 9954 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 9955   match(Set dst (SubD src1 src2));
 9956   format %{ &quot;FSUB    $dst, $src1, $src2&quot; %}
 9957   size(4);
 9958   ins_encode %{
 9959     // TODO: PPC port $archOpcode(ppc64Opcode_fsub);
 9960     __ fsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9961   %}
 9962   ins_pipe(pipe_class_default);
 9963 %}
 9964 
 9965 // Mul float single precision
 9966 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 9967   match(Set dst (MulF src1 src2));
 9968   format %{ &quot;FMULS   $dst, $src1, $src2&quot; %}
 9969   size(4);
 9970   ins_encode %{
 9971     // TODO: PPC port $archOpcode(ppc64Opcode_fmuls);
 9972     __ fmuls($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9973   %}
 9974   ins_pipe(pipe_class_default);
 9975 %}
 9976 
 9977 // Mul float double precision
 9978 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 9979   match(Set dst (MulD src1 src2));
 9980   format %{ &quot;FMUL    $dst, $src1, $src2&quot; %}
 9981   size(4);
 9982   ins_encode %{
 9983     // TODO: PPC port $archOpcode(ppc64Opcode_fmul);
 9984     __ fmul($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9985   %}
 9986   ins_pipe(pipe_class_default);
 9987 %}
 9988 
 9989 // Div float single precision
 9990 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 9991   match(Set dst (DivF src1 src2));
 9992   format %{ &quot;FDIVS   $dst, $src1, $src2&quot; %}
 9993   size(4);
 9994   ins_encode %{
 9995     // TODO: PPC port $archOpcode(ppc64Opcode_fdivs);
 9996     __ fdivs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9997   %}
 9998   ins_pipe(pipe_class_default);
 9999 %}
10000 
10001 // Div float double precision
10002 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
10003   match(Set dst (DivD src1 src2));
10004   format %{ &quot;FDIV    $dst, $src1, $src2&quot; %}
10005   size(4);
10006   ins_encode %{
10007     // TODO: PPC port $archOpcode(ppc64Opcode_fdiv);
10008     __ fdiv($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
10009   %}
10010   ins_pipe(pipe_class_default);
10011 %}
10012 
10013 // Absolute float single precision
10014 instruct absF_reg(regF dst, regF src) %{
10015   match(Set dst (AbsF src));
10016   format %{ &quot;FABS    $dst, $src \t// float&quot; %}
10017   size(4);
10018   ins_encode %{
10019     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10020     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10021   %}
10022   ins_pipe(pipe_class_default);
10023 %}
10024 
10025 // Absolute float double precision
10026 instruct absD_reg(regD dst, regD src) %{
10027   match(Set dst (AbsD src));
10028   format %{ &quot;FABS    $dst, $src \t// double&quot; %}
10029   size(4);
10030   ins_encode %{
10031     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10032     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10033   %}
10034   ins_pipe(pipe_class_default);
10035 %}
10036 
10037 instruct negF_reg(regF dst, regF src) %{
10038   match(Set dst (NegF src));
10039   format %{ &quot;FNEG    $dst, $src \t// float&quot; %}
10040   size(4);
10041   ins_encode %{
10042     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10043     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10044   %}
10045   ins_pipe(pipe_class_default);
10046 %}
10047 
10048 instruct negD_reg(regD dst, regD src) %{
10049   match(Set dst (NegD src));
10050   format %{ &quot;FNEG    $dst, $src \t// double&quot; %}
10051   size(4);
10052   ins_encode %{
10053     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10054     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10055   %}
10056   ins_pipe(pipe_class_default);
10057 %}
10058 
10059 // AbsF + NegF.
10060 instruct negF_absF_reg(regF dst, regF src) %{
10061   match(Set dst (NegF (AbsF src)));
10062   format %{ &quot;FNABS   $dst, $src \t// float&quot; %}
10063   size(4);
10064   ins_encode %{
10065     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10066     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10067   %}
10068   ins_pipe(pipe_class_default);
10069 %}
10070 
10071 // AbsD + NegD.
10072 instruct negD_absD_reg(regD dst, regD src) %{
10073   match(Set dst (NegD (AbsD src)));
10074   format %{ &quot;FNABS   $dst, $src \t// double&quot; %}
10075   size(4);
10076   ins_encode %{
10077     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10078     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10079   %}
10080   ins_pipe(pipe_class_default);
10081 %}
10082 
10083 // VM_Version::has_fsqrt() decides if this node will be used.
10084 // Sqrt float double precision
10085 instruct sqrtD_reg(regD dst, regD src) %{
10086   match(Set dst (SqrtD src));
10087   format %{ &quot;FSQRT   $dst, $src&quot; %}
10088   size(4);
10089   ins_encode %{
10090     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrt);
10091     __ fsqrt($dst$$FloatRegister, $src$$FloatRegister);
10092   %}
10093   ins_pipe(pipe_class_default);
10094 %}
10095 
10096 // Single-precision sqrt.
10097 instruct sqrtF_reg(regF dst, regF src) %{
10098   match(Set dst (SqrtF src));
10099   predicate(VM_Version::has_fsqrts());
10100   ins_cost(DEFAULT_COST);
10101 
10102   format %{ &quot;FSQRTS  $dst, $src&quot; %}
10103   size(4);
10104   ins_encode %{
10105     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrts);
10106     __ fsqrts($dst$$FloatRegister, $src$$FloatRegister);
10107   %}
10108   ins_pipe(pipe_class_default);
10109 %}
10110 
10111 instruct roundDouble_nop(regD dst) %{
10112   match(Set dst (RoundDouble dst));
10113   ins_cost(0);
10114 
10115   format %{ &quot; -- \t// RoundDouble not needed - empty&quot; %}
10116   size(0);
10117   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10118   ins_encode( /*empty*/ );
10119   ins_pipe(pipe_class_default);
10120 %}
10121 
10122 instruct roundFloat_nop(regF dst) %{
10123   match(Set dst (RoundFloat dst));
10124   ins_cost(0);
10125 
10126   format %{ &quot; -- \t// RoundFloat not needed - empty&quot; %}
10127   size(0);
10128   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10129   ins_encode( /*empty*/ );
10130   ins_pipe(pipe_class_default);
10131 %}
10132 
10133 
10134 // Multiply-Accumulate
10135 // src1 * src2 + src3
10136 instruct maddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10137   match(Set dst (FmaF src3 (Binary src1 src2)));
10138 
10139   format %{ &quot;FMADDS  $dst, $src1, $src2, $src3&quot; %}
10140   size(4);
10141   ins_encode %{
10142     // TODO: PPC port $archOpcode(ppc64Opcode_fmadds);
10143     __ fmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10144   %}
10145   ins_pipe(pipe_class_default);
10146 %}
10147 
10148 // src1 * src2 + src3
10149 instruct maddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10150   match(Set dst (FmaD src3 (Binary src1 src2)));
10151 
10152   format %{ &quot;FMADD   $dst, $src1, $src2, $src3&quot; %}
10153   size(4);
10154   ins_encode %{
10155     // TODO: PPC port $archOpcode(ppc64Opcode_fmadd);
10156     __ fmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10157   %}
10158   ins_pipe(pipe_class_default);
10159 %}
10160 
10161 // -src1 * src2 + src3 = -(src1*src2-src3)
10162 instruct mnsubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10163   match(Set dst (FmaF src3 (Binary (NegF src1) src2)));
10164   match(Set dst (FmaF src3 (Binary src1 (NegF src2))));
10165 
10166   format %{ &quot;FNMSUBS $dst, $src1, $src2, $src3&quot; %}
10167   size(4);
10168   ins_encode %{
10169     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsubs);
10170     __ fnmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10171   %}
10172   ins_pipe(pipe_class_default);
10173 %}
10174 
10175 // -src1 * src2 + src3 = -(src1*src2-src3)
10176 instruct mnsubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10177   match(Set dst (FmaD src3 (Binary (NegD src1) src2)));
10178   match(Set dst (FmaD src3 (Binary src1 (NegD src2))));
10179 
10180   format %{ &quot;FNMSUB  $dst, $src1, $src2, $src3&quot; %}
10181   size(4);
10182   ins_encode %{
10183     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsub);
10184     __ fnmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10185   %}
10186   ins_pipe(pipe_class_default);
10187 %}
10188 
10189 // -src1 * src2 - src3 = -(src1*src2+src3)
10190 instruct mnaddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10191   match(Set dst (FmaF (NegF src3) (Binary (NegF src1) src2)));
10192   match(Set dst (FmaF (NegF src3) (Binary src1 (NegF src2))));
10193 
10194   format %{ &quot;FNMADDS $dst, $src1, $src2, $src3&quot; %}
10195   size(4);
10196   ins_encode %{
10197     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadds);
10198     __ fnmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10199   %}
10200   ins_pipe(pipe_class_default);
10201 %}
10202 
10203 // -src1 * src2 - src3 = -(src1*src2+src3)
10204 instruct mnaddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10205   match(Set dst (FmaD (NegD src3) (Binary (NegD src1) src2)));
10206   match(Set dst (FmaD (NegD src3) (Binary src1 (NegD src2))));
10207 
10208   format %{ &quot;FNMADD  $dst, $src1, $src2, $src3&quot; %}
10209   size(4);
10210   ins_encode %{
10211     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadd);
10212     __ fnmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10213   %}
10214   ins_pipe(pipe_class_default);
10215 %}
10216 
10217 // src1 * src2 - src3
10218 instruct msubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10219   match(Set dst (FmaF (NegF src3) (Binary src1 src2)));
10220 
10221   format %{ &quot;FMSUBS  $dst, $src1, $src2, $src3&quot; %}
10222   size(4);
10223   ins_encode %{
10224     // TODO: PPC port $archOpcode(ppc64Opcode_fmsubs);
10225     __ fmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10226   %}
10227   ins_pipe(pipe_class_default);
10228 %}
10229 
10230 // src1 * src2 - src3
10231 instruct msubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10232   match(Set dst (FmaD (NegD src3) (Binary src1 src2)));
10233 
10234   format %{ &quot;FMSUB   $dst, $src1, $src2, $src3&quot; %}
10235   size(4);
10236   ins_encode %{
10237     // TODO: PPC port $archOpcode(ppc64Opcode_fmsub);
10238     __ fmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10239   %}
10240   ins_pipe(pipe_class_default);
10241 %}
10242 
10243 
10244 //----------Logical Instructions-----------------------------------------------
10245 
10246 // And Instructions
10247 
10248 // Register And
10249 instruct andI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10250   match(Set dst (AndI src1 src2));
10251   format %{ &quot;AND     $dst, $src1, $src2&quot; %}
10252   size(4);
10253   ins_encode %{
10254     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10255     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10256   %}
10257   ins_pipe(pipe_class_default);
10258 %}
10259 
10260 // Left shifted Immediate And
10261 instruct andI_reg_immIhi16(iRegIdst dst, iRegIsrc src1, immIhi16  src2, flagsRegCR0 cr0) %{
10262   match(Set dst (AndI src1 src2));
10263   effect(KILL cr0);
10264   format %{ &quot;ANDIS   $dst, $src1, $src2.hi&quot; %}
10265   size(4);
10266   ins_encode %{
10267     // TODO: PPC port $archOpcode(ppc64Opcode_andis_);
10268     __ andis_($dst$$Register, $src1$$Register, (int)((unsigned short)(($src2$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
10269   %}
10270   ins_pipe(pipe_class_default);
10271 %}
10272 
10273 // Immediate And
10274 instruct andI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2, flagsRegCR0 cr0) %{
10275   match(Set dst (AndI src1 src2));
10276   effect(KILL cr0);
10277 
10278   format %{ &quot;ANDI    $dst, $src1, $src2&quot; %}
10279   size(4);
10280   ins_encode %{
10281     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10282     // FIXME: avoid andi_ ?
10283     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10284   %}
10285   ins_pipe(pipe_class_default);
10286 %}
10287 
10288 // Immediate And where the immediate is a negative power of 2.
10289 instruct andI_reg_immInegpow2(iRegIdst dst, iRegIsrc src1, immInegpow2 src2) %{
10290   match(Set dst (AndI src1 src2));
10291   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10292   size(4);
10293   ins_encode %{
10294     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10295     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)(julong)(juint)-($src2$$constant)));
10296   %}
10297   ins_pipe(pipe_class_default);
10298 %}
10299 
10300 instruct andI_reg_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immIpow2minus1 src2) %{
10301   match(Set dst (AndI src1 src2));
10302   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10303   size(4);
10304   ins_encode %{
10305     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10306     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10307   %}
10308   ins_pipe(pipe_class_default);
10309 %}
10310 
10311 instruct andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src1, immIpowerOf2 src2) %{
10312   match(Set dst (AndI src1 src2));
10313   predicate(UseRotateAndMaskInstructionsPPC64);
10314   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10315   size(4);
10316   ins_encode %{
10317     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10318     __ rlwinm($dst$$Register, $src1$$Register, 0,
10319               (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f, (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f);
10320   %}
10321   ins_pipe(pipe_class_default);
10322 %}
10323 
10324 // Register And Long
10325 instruct andL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10326   match(Set dst (AndL src1 src2));
10327   ins_cost(DEFAULT_COST);
10328 
10329   format %{ &quot;AND     $dst, $src1, $src2 \t// long&quot; %}
10330   size(4);
10331   ins_encode %{
10332     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10333     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10334   %}
10335   ins_pipe(pipe_class_default);
10336 %}
10337 
10338 // Immediate And long
10339 instruct andL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2, flagsRegCR0 cr0) %{
10340   match(Set dst (AndL src1 src2));
10341   effect(KILL cr0);
10342 
10343   format %{ &quot;ANDI    $dst, $src1, $src2 \t// long&quot; %}
10344   size(4);
10345   ins_encode %{
10346     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10347     // FIXME: avoid andi_ ?
10348     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10349   %}
10350   ins_pipe(pipe_class_default);
10351 %}
10352 
10353 // Immediate And Long where the immediate is a negative power of 2.
10354 instruct andL_reg_immLnegpow2(iRegLdst dst, iRegLsrc src1, immLnegpow2 src2) %{
10355   match(Set dst (AndL src1 src2));
10356   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10357   size(4);
10358   ins_encode %{
10359     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10360     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)-$src2$$constant));
10361   %}
10362   ins_pipe(pipe_class_default);
10363 %}
10364 
10365 instruct andL_reg_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10366   match(Set dst (AndL src1 src2));
10367   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10368   size(4);
10369   ins_encode %{
10370     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10371     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10372   %}
10373   ins_pipe(pipe_class_default);
10374 %}
10375 
10376 // AndL + ConvL2I.
10377 instruct convL2I_andL_reg_immLpow2minus1(iRegIdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10378   match(Set dst (ConvL2I (AndL src1 src2)));
10379   ins_cost(DEFAULT_COST);
10380 
10381   format %{ &quot;ANDDI   $dst, $src1, $src2 \t// long + l2i&quot; %}
10382   size(4);
10383   ins_encode %{
10384     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10385     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10386   %}
10387   ins_pipe(pipe_class_default);
10388 %}
10389 
10390 // Or Instructions
10391 
10392 // Register Or
10393 instruct orI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10394   match(Set dst (OrI src1 src2));
10395   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10396   size(4);
10397   ins_encode %{
10398     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10399     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10400   %}
10401   ins_pipe(pipe_class_default);
10402 %}
10403 
10404 // Expand does not work with above instruct. (??)
10405 instruct orI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10406   // no match-rule
10407   effect(DEF dst, USE src1, USE src2);
10408   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10409   size(4);
10410   ins_encode %{
10411     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10412     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10413   %}
10414   ins_pipe(pipe_class_default);
10415 %}
10416 
10417 instruct tree_orI_orI_orI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10418   match(Set dst (OrI (OrI (OrI src1 src2) src3) src4));
10419   ins_cost(DEFAULT_COST*3);
10420 
10421   expand %{
10422     // FIXME: we should do this in the ideal world.
10423     iRegIdst tmp1;
10424     iRegIdst tmp2;
10425     orI_reg_reg(tmp1, src1, src2);
10426     orI_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
10427     orI_reg_reg(dst, tmp1, tmp2);
10428   %}
10429 %}
10430 
10431 // Immediate Or
10432 instruct orI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10433   match(Set dst (OrI src1 src2));
10434   format %{ &quot;ORI     $dst, $src1, $src2&quot; %}
10435   size(4);
10436   ins_encode %{
10437     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10438     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
10439   %}
10440   ins_pipe(pipe_class_default);
10441 %}
10442 
10443 // Register Or Long
10444 instruct orL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10445   match(Set dst (OrL src1 src2));
10446   ins_cost(DEFAULT_COST);
10447 
10448   size(4);
10449   format %{ &quot;OR      $dst, $src1, $src2 \t// long&quot; %}
10450   ins_encode %{
10451     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10452     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10453   %}
10454   ins_pipe(pipe_class_default);
10455 %}
10456 
10457 // OrL + ConvL2I.
10458 instruct orI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10459   match(Set dst (ConvL2I (OrL src1 src2)));
10460   ins_cost(DEFAULT_COST);
10461 
10462   format %{ &quot;OR      $dst, $src1, $src2 \t// long + l2i&quot; %}
10463   size(4);
10464   ins_encode %{
10465     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10466     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10467   %}
10468   ins_pipe(pipe_class_default);
10469 %}
10470 
10471 // Immediate Or long
10472 instruct orL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 con) %{
10473   match(Set dst (OrL src1 con));
10474   ins_cost(DEFAULT_COST);
10475 
10476   format %{ &quot;ORI     $dst, $src1, $con \t// long&quot; %}
10477   size(4);
10478   ins_encode %{
10479     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10480     __ ori($dst$$Register, $src1$$Register, ($con$$constant) &amp; 0xFFFF);
10481   %}
10482   ins_pipe(pipe_class_default);
10483 %}
10484 
10485 // Xor Instructions
10486 
10487 // Register Xor
10488 instruct xorI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10489   match(Set dst (XorI src1 src2));
10490   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10491   size(4);
10492   ins_encode %{
10493     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10494     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10495   %}
10496   ins_pipe(pipe_class_default);
10497 %}
10498 
10499 // Expand does not work with above instruct. (??)
10500 instruct xorI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10501   // no match-rule
10502   effect(DEF dst, USE src1, USE src2);
10503   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10504   size(4);
10505   ins_encode %{
10506     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10507     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10508   %}
10509   ins_pipe(pipe_class_default);
10510 %}
10511 
10512 instruct tree_xorI_xorI_xorI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10513   match(Set dst (XorI (XorI (XorI src1 src2) src3) src4));
10514   ins_cost(DEFAULT_COST*3);
10515 
10516   expand %{
10517     // FIXME: we should do this in the ideal world.
10518     iRegIdst tmp1;
10519     iRegIdst tmp2;
10520     xorI_reg_reg(tmp1, src1, src2);
10521     xorI_reg_reg_2(tmp2, src3, src4); // Adlc complains about xorI_reg_reg.
10522     xorI_reg_reg(dst, tmp1, tmp2);
10523   %}
10524 %}
10525 
10526 // Immediate Xor
10527 instruct xorI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10528   match(Set dst (XorI src1 src2));
10529   format %{ &quot;XORI    $dst, $src1, $src2&quot; %}
10530   size(4);
10531   ins_encode %{
10532     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10533     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10534   %}
10535   ins_pipe(pipe_class_default);
10536 %}
10537 
10538 // Register Xor Long
10539 instruct xorL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10540   match(Set dst (XorL src1 src2));
10541   ins_cost(DEFAULT_COST);
10542 
10543   format %{ &quot;XOR     $dst, $src1, $src2 \t// long&quot; %}
10544   size(4);
10545   ins_encode %{
10546     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10547     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10548   %}
10549   ins_pipe(pipe_class_default);
10550 %}
10551 
10552 // XorL + ConvL2I.
10553 instruct xorI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10554   match(Set dst (ConvL2I (XorL src1 src2)));
10555   ins_cost(DEFAULT_COST);
10556 
10557   format %{ &quot;XOR     $dst, $src1, $src2 \t// long + l2i&quot; %}
10558   size(4);
10559   ins_encode %{
10560     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10561     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10562   %}
10563   ins_pipe(pipe_class_default);
10564 %}
10565 
10566 // Immediate Xor Long
10567 instruct xorL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2) %{
10568   match(Set dst (XorL src1 src2));
10569   ins_cost(DEFAULT_COST);
10570 
10571   format %{ &quot;XORI    $dst, $src1, $src2 \t// long&quot; %}
10572   size(4);
10573   ins_encode %{
10574     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10575     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10576   %}
10577   ins_pipe(pipe_class_default);
10578 %}
10579 
10580 instruct notI_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
10581   match(Set dst (XorI src1 src2));
10582   ins_cost(DEFAULT_COST);
10583 
10584   format %{ &quot;NOT     $dst, $src1 ($src2)&quot; %}
10585   size(4);
10586   ins_encode %{
10587     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10588     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10589   %}
10590   ins_pipe(pipe_class_default);
10591 %}
10592 
10593 instruct notL_reg(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
10594   match(Set dst (XorL src1 src2));
10595   ins_cost(DEFAULT_COST);
10596 
10597   format %{ &quot;NOT     $dst, $src1 ($src2) \t// long&quot; %}
10598   size(4);
10599   ins_encode %{
10600     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10601     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10602   %}
10603   ins_pipe(pipe_class_default);
10604 %}
10605 
10606 // And-complement
10607 instruct andcI_reg_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2, iRegIsrc src3) %{
10608   match(Set dst (AndI (XorI src1 src2) src3));
10609   ins_cost(DEFAULT_COST);
10610 
10611   format %{ &quot;ANDW    $dst, xori($src1, $src2), $src3&quot; %}
10612   size(4);
10613   ins_encode( enc_andc(dst, src3, src1) );
10614   ins_pipe(pipe_class_default);
10615 %}
10616 
10617 // And-complement
10618 instruct andcL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10619   // no match-rule, false predicate
10620   effect(DEF dst, USE src1, USE src2);
10621   predicate(false);
10622 
10623   format %{ &quot;ANDC    $dst, $src1, $src2&quot; %}
10624   size(4);
10625   ins_encode %{
10626     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
10627     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
10628   %}
10629   ins_pipe(pipe_class_default);
10630 %}
10631 
10632 //----------Moves between int/long and float/double----------------------------
10633 //
10634 // The following rules move values from int/long registers/stack-locations
10635 // to float/double registers/stack-locations and vice versa, without doing any
10636 // conversions. These rules are used to implement the bit-conversion methods
10637 // of java.lang.Float etc., e.g.
10638 //   int   floatToIntBits(float value)
10639 //   float intBitsToFloat(int bits)
10640 //
10641 // Notes on the implementation on ppc64:
10642 // For Power7 and earlier, the rules are limited to those which move between a
10643 // register and a stack-location, because we always have to go through memory
10644 // when moving between a float register and an integer register.
10645 // This restriction is removed in Power8 with the introduction of the mtfprd
10646 // and mffprd instructions.
10647 
10648 instruct moveL2D_reg(regD dst, iRegLsrc src) %{
10649   match(Set dst (MoveL2D src));
10650   predicate(VM_Version::has_mtfprd());
10651 
10652   format %{ &quot;MTFPRD  $dst, $src&quot; %}
10653   size(4);
10654   ins_encode %{
10655     __ mtfprd($dst$$FloatRegister, $src$$Register);
10656   %}
10657   ins_pipe(pipe_class_default);
10658 %}
10659 
10660 instruct moveI2D_reg(regD dst, iRegIsrc src) %{
10661   // no match-rule, false predicate
10662   effect(DEF dst, USE src);
10663   predicate(false);
10664 
10665   format %{ &quot;MTFPRWA $dst, $src&quot; %}
10666   size(4);
10667   ins_encode %{
10668     __ mtfprwa($dst$$FloatRegister, $src$$Register);
10669   %}
10670   ins_pipe(pipe_class_default);
10671 %}
10672 
10673 //---------- Chain stack slots between similar types --------
10674 
10675 // These are needed so that the rules below can match.
10676 
10677 // Load integer from stack slot
10678 instruct stkI_to_regI(iRegIdst dst, stackSlotI src) %{
10679   match(Set dst src);
10680   ins_cost(MEMORY_REF_COST);
10681 
10682   format %{ &quot;LWZ     $dst, $src&quot; %}
10683   size(4);
10684   ins_encode( enc_lwz(dst, src) );
10685   ins_pipe(pipe_class_memory);
10686 %}
10687 
10688 // Store integer to stack slot
10689 instruct regI_to_stkI(stackSlotI dst, iRegIsrc src) %{
10690   match(Set dst src);
10691   ins_cost(MEMORY_REF_COST);
10692 
10693   format %{ &quot;STW     $src, $dst \t// stk&quot; %}
10694   size(4);
10695   ins_encode( enc_stw(src, dst) ); // rs=rt
10696   ins_pipe(pipe_class_memory);
10697 %}
10698 
10699 // Load long from stack slot
10700 instruct stkL_to_regL(iRegLdst dst, stackSlotL src) %{
10701   match(Set dst src);
10702   ins_cost(MEMORY_REF_COST);
10703 
10704   format %{ &quot;LD      $dst, $src \t// long&quot; %}
10705   size(4);
10706   ins_encode( enc_ld(dst, src) );
10707   ins_pipe(pipe_class_memory);
10708 %}
10709 
10710 // Store long to stack slot
10711 instruct regL_to_stkL(stackSlotL dst, iRegLsrc src) %{
10712   match(Set dst src);
10713   ins_cost(MEMORY_REF_COST);
10714 
10715   format %{ &quot;STD     $src, $dst \t// long&quot; %}
10716   size(4);
10717   ins_encode( enc_std(src, dst) ); // rs=rt
10718   ins_pipe(pipe_class_memory);
10719 %}
10720 
10721 //----------Moves between int and float
10722 
10723 // Move float value from float stack-location to integer register.
10724 instruct moveF2I_stack_reg(iRegIdst dst, stackSlotF src) %{
10725   match(Set dst (MoveF2I src));
10726   ins_cost(MEMORY_REF_COST);
10727 
10728   format %{ &quot;LWZ     $dst, $src \t// MoveF2I&quot; %}
10729   size(4);
10730   ins_encode( enc_lwz(dst, src) );
10731   ins_pipe(pipe_class_memory);
10732 %}
10733 
10734 // Move float value from float register to integer stack-location.
10735 instruct moveF2I_reg_stack(stackSlotI dst, regF src) %{
10736   match(Set dst (MoveF2I src));
10737   ins_cost(MEMORY_REF_COST);
10738 
10739   format %{ &quot;STFS    $src, $dst \t// MoveF2I&quot; %}
10740   size(4);
10741   ins_encode( enc_stfs(src, dst) );
10742   ins_pipe(pipe_class_memory);
10743 %}
10744 
10745 // Move integer value from integer stack-location to float register.
10746 instruct moveI2F_stack_reg(regF dst, stackSlotI src) %{
10747   match(Set dst (MoveI2F src));
10748   ins_cost(MEMORY_REF_COST);
10749 
10750   format %{ &quot;LFS     $dst, $src \t// MoveI2F&quot; %}
10751   size(4);
10752   ins_encode %{
10753     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
10754     int Idisp = $src$$disp + frame_slots_bias($src$$base, ra_);
10755     __ lfs($dst$$FloatRegister, Idisp, $src$$base$$Register);
10756   %}
10757   ins_pipe(pipe_class_memory);
10758 %}
10759 
10760 // Move integer value from integer register to float stack-location.
10761 instruct moveI2F_reg_stack(stackSlotF dst, iRegIsrc src) %{
10762   match(Set dst (MoveI2F src));
10763   ins_cost(MEMORY_REF_COST);
10764 
10765   format %{ &quot;STW     $src, $dst \t// MoveI2F&quot; %}
10766   size(4);
10767   ins_encode( enc_stw(src, dst) );
10768   ins_pipe(pipe_class_memory);
10769 %}
10770 
10771 //----------Moves between long and float
10772 
10773 instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{
10774   // no match-rule, false predicate
10775   effect(DEF dst, USE src);
10776   predicate(false);
10777 
10778   format %{ &quot;storeD  $src, $dst \t// STACK&quot; %}
10779   size(4);
10780   ins_encode( enc_stfd(src, dst) );
10781   ins_pipe(pipe_class_default);
10782 %}
10783 
10784 //----------Moves between long and double
10785 
10786 // Move double value from double stack-location to long register.
10787 instruct moveD2L_stack_reg(iRegLdst dst, stackSlotD src) %{
10788   match(Set dst (MoveD2L src));
10789   ins_cost(MEMORY_REF_COST);
10790   size(4);
10791   format %{ &quot;LD      $dst, $src \t// MoveD2L&quot; %}
10792   ins_encode( enc_ld(dst, src) );
10793   ins_pipe(pipe_class_memory);
10794 %}
10795 
10796 // Move double value from double register to long stack-location.
10797 instruct moveD2L_reg_stack(stackSlotL dst, regD src) %{
10798   match(Set dst (MoveD2L src));
10799   effect(DEF dst, USE src);
10800   ins_cost(MEMORY_REF_COST);
10801 
10802   format %{ &quot;STFD    $src, $dst \t// MoveD2L&quot; %}
10803   size(4);
10804   ins_encode( enc_stfd(src, dst) );
10805   ins_pipe(pipe_class_memory);
10806 %}
10807 
10808 // Move long value from long stack-location to double register.
10809 instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{
10810   match(Set dst (MoveL2D src));
10811   ins_cost(MEMORY_REF_COST);
10812 
10813   format %{ &quot;LFD     $dst, $src \t// MoveL2D&quot; %}
10814   size(4);
10815   ins_encode( enc_lfd(dst, src) );
10816   ins_pipe(pipe_class_memory);
10817 %}
10818 
10819 // Move long value from long register to double stack-location.
10820 instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{
10821   match(Set dst (MoveL2D src));
10822   ins_cost(MEMORY_REF_COST);
10823 
10824   format %{ &quot;STD     $src, $dst \t// MoveL2D&quot; %}
10825   size(4);
10826   ins_encode( enc_std(src, dst) );
10827   ins_pipe(pipe_class_memory);
10828 %}
10829 
10830 //----------Register Move Instructions-----------------------------------------
10831 
10832 // Replicate for Superword
10833 
10834 instruct moveReg(iRegLdst dst, iRegIsrc src) %{
10835   predicate(false);
10836   effect(DEF dst, USE src);
10837 
10838   format %{ &quot;MR      $dst, $src \t// replicate &quot; %}
10839   // variable size, 0 or 4.
10840   ins_encode %{
10841     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10842     __ mr_if_needed($dst$$Register, $src$$Register);
10843   %}
10844   ins_pipe(pipe_class_default);
10845 %}
10846 
10847 //----------Cast instructions (Java-level type cast)---------------------------
10848 
10849 // Cast Long to Pointer for unsafe natives.
10850 instruct castX2P(iRegPdst dst, iRegLsrc src) %{
10851   match(Set dst (CastX2P src));
10852 
10853   format %{ &quot;MR      $dst, $src \t// Long-&gt;Ptr&quot; %}
10854   // variable size, 0 or 4.
10855   ins_encode %{
10856     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10857     __ mr_if_needed($dst$$Register, $src$$Register);
10858   %}
10859  ins_pipe(pipe_class_default);
10860 %}
10861 
10862 // Cast Pointer to Long for unsafe natives.
10863 instruct castP2X(iRegLdst dst, iRegP_N2P src) %{
10864   match(Set dst (CastP2X src));
10865 
10866   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Long&quot; %}
10867   // variable size, 0 or 4.
10868   ins_encode %{
10869     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10870     __ mr_if_needed($dst$$Register, $src$$Register);
10871   %}
10872   ins_pipe(pipe_class_default);
10873 %}
10874 
10875 instruct castPP(iRegPdst dst) %{
10876   match(Set dst (CastPP dst));
10877   format %{ &quot; -- \t// castPP of $dst&quot; %}
10878   size(0);
10879   ins_encode( /*empty*/ );
10880   ins_pipe(pipe_class_default);
10881 %}
10882 
10883 instruct castII(iRegIdst dst) %{
10884   match(Set dst (CastII dst));
10885   format %{ &quot; -- \t// castII of $dst&quot; %}
10886   size(0);
10887   ins_encode( /*empty*/ );
10888   ins_pipe(pipe_class_default);
10889 %}
10890 
10891 instruct checkCastPP(iRegPdst dst) %{
10892   match(Set dst (CheckCastPP dst));
10893   format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
10894   size(0);
10895   ins_encode( /*empty*/ );
10896   ins_pipe(pipe_class_default);
10897 %}
10898 
10899 //----------Convert instructions-----------------------------------------------
10900 
10901 // Convert to boolean.
10902 
10903 // int_to_bool(src) : { 1   if src != 0
10904 //                    { 0   else
10905 //
10906 // strategy:
10907 // 1) Count leading zeros of 32 bit-value src,
10908 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10909 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10910 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10911 
10912 // convI2Bool
10913 instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{
10914   match(Set dst (Conv2B src));
10915   predicate(UseCountLeadingZerosInstructionsPPC64);
10916   ins_cost(DEFAULT_COST);
10917 
10918   expand %{
10919     immI shiftAmount %{ 0x5 %}
10920     uimmI16 mask %{ 0x1 %}
10921     iRegIdst tmp1;
10922     iRegIdst tmp2;
10923     countLeadingZerosI(tmp1, src);
10924     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10925     xorI_reg_uimm16(dst, tmp2, mask);
10926   %}
10927 %}
10928 
10929 instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{
10930   match(Set dst (Conv2B src));
10931   effect(TEMP crx);
10932   predicate(!UseCountLeadingZerosInstructionsPPC64);
10933   ins_cost(DEFAULT_COST);
10934 
10935   format %{ &quot;CMPWI   $crx, $src, #0 \t// convI2B&quot;
10936             &quot;LI      $dst, #0\n\t&quot;
10937             &quot;BEQ     $crx, done\n\t&quot;
10938             &quot;LI      $dst, #1\n&quot;
10939             &quot;done:&quot; %}
10940   size(16);
10941   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );
10942   ins_pipe(pipe_class_compare);
10943 %}
10944 
10945 // ConvI2B + XorI
10946 instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{
10947   match(Set dst (XorI (Conv2B src) mask));
10948   predicate(UseCountLeadingZerosInstructionsPPC64);
10949   ins_cost(DEFAULT_COST);
10950 
10951   expand %{
10952     immI shiftAmount %{ 0x5 %}
10953     iRegIdst tmp1;
10954     countLeadingZerosI(tmp1, src);
10955     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10956   %}
10957 %}
10958 
10959 instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{
10960   match(Set dst (XorI (Conv2B src) mask));
10961   effect(TEMP crx);
10962   predicate(!UseCountLeadingZerosInstructionsPPC64);
10963   ins_cost(DEFAULT_COST);
10964 
10965   format %{ &quot;CMPWI   $crx, $src, #0 \t// Xor(convI2B($src), $mask)&quot;
10966             &quot;LI      $dst, #1\n\t&quot;
10967             &quot;BEQ     $crx, done\n\t&quot;
10968             &quot;LI      $dst, #0\n&quot;
10969             &quot;done:&quot; %}
10970   size(16);
10971   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );
10972   ins_pipe(pipe_class_compare);
10973 %}
10974 
10975 // AndI 0b0..010..0 + ConvI2B
10976 instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{
10977   match(Set dst (Conv2B (AndI src mask)));
10978   predicate(UseRotateAndMaskInstructionsPPC64);
10979   ins_cost(DEFAULT_COST);
10980 
10981   format %{ &quot;RLWINM  $dst, $src, $mask \t// convI2B(AndI($src, $mask))&quot; %}
10982   size(4);
10983   ins_encode %{
10984     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10985     __ rlwinm($dst$$Register, $src$$Register, (32-log2_long((jlong)$mask$$constant)) &amp; 0x1f, 31, 31);
10986   %}
10987   ins_pipe(pipe_class_default);
10988 %}
10989 
10990 // Convert pointer to boolean.
10991 //
10992 // ptr_to_bool(src) : { 1   if src != 0
10993 //                    { 0   else
10994 //
10995 // strategy:
10996 // 1) Count leading zeros of 64 bit-value src,
10997 //    this returns 64 (0b100.0000) iff src == 0 and &lt;64 otherwise.
10998 // 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10999 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
11000 
11001 // ConvP2B
11002 instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{
11003   match(Set dst (Conv2B src));
11004   predicate(UseCountLeadingZerosInstructionsPPC64);
11005   ins_cost(DEFAULT_COST);
11006 
11007   expand %{
11008     immI shiftAmount %{ 0x6 %}
11009     uimmI16 mask %{ 0x1 %}
11010     iRegIdst tmp1;
11011     iRegIdst tmp2;
11012     countLeadingZerosP(tmp1, src);
11013     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
11014     xorI_reg_uimm16(dst, tmp2, mask);
11015   %}
11016 %}
11017 
11018 instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{
11019   match(Set dst (Conv2B src));
11020   effect(TEMP crx);
11021   predicate(!UseCountLeadingZerosInstructionsPPC64);
11022   ins_cost(DEFAULT_COST);
11023 
11024   format %{ &quot;CMPDI   $crx, $src, #0 \t// convP2B&quot;
11025             &quot;LI      $dst, #0\n\t&quot;
11026             &quot;BEQ     $crx, done\n\t&quot;
11027             &quot;LI      $dst, #1\n&quot;
11028             &quot;done:&quot; %}
11029   size(16);
11030   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );
11031   ins_pipe(pipe_class_compare);
11032 %}
11033 
11034 // ConvP2B + XorI
11035 instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{
11036   match(Set dst (XorI (Conv2B src) mask));
11037   predicate(UseCountLeadingZerosInstructionsPPC64);
11038   ins_cost(DEFAULT_COST);
11039 
11040   expand %{
11041     immI shiftAmount %{ 0x6 %}
11042     iRegIdst tmp1;
11043     countLeadingZerosP(tmp1, src);
11044     urShiftI_reg_imm(dst, tmp1, shiftAmount);
11045   %}
11046 %}
11047 
11048 instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{
11049   match(Set dst (XorI (Conv2B src) mask));
11050   effect(TEMP crx);
11051   predicate(!UseCountLeadingZerosInstructionsPPC64);
11052   ins_cost(DEFAULT_COST);
11053 
11054   format %{ &quot;CMPDI   $crx, $src, #0 \t// XorI(convP2B($src), $mask)&quot;
11055             &quot;LI      $dst, #1\n\t&quot;
11056             &quot;BEQ     $crx, done\n\t&quot;
11057             &quot;LI      $dst, #0\n&quot;
11058             &quot;done:&quot; %}
11059   size(16);
11060   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );
11061   ins_pipe(pipe_class_compare);
11062 %}
11063 
11064 // if src1 &lt; src2, return -1 else return 0
11065 instruct cmpLTMask_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
11066   match(Set dst (CmpLTMask src1 src2));
11067   ins_cost(DEFAULT_COST*4);
11068 
11069   expand %{
11070     iRegLdst src1s;
11071     iRegLdst src2s;
11072     iRegLdst diff;
11073     convI2L_reg(src1s, src1); // Ensure proper sign extension.
11074     convI2L_reg(src2s, src2); // Ensure proper sign extension.
11075     subL_reg_reg(diff, src1s, src2s);
11076     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
11077     signmask64I_regL(dst, diff);
11078   %}
11079 %}
11080 
11081 instruct cmpLTMask_reg_immI0(iRegIdst dst, iRegIsrc src1, immI_0 src2) %{
11082   match(Set dst (CmpLTMask src1 src2)); // if src1 &lt; src2, return -1 else return 0
11083   format %{ &quot;SRAWI   $dst, $src1, $src2 \t// CmpLTMask&quot; %}
11084   size(4);
11085   ins_encode %{
11086     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
11087     __ srawi($dst$$Register, $src1$$Register, 0x1f);
11088   %}
11089   ins_pipe(pipe_class_default);
11090 %}
11091 
11092 //----------Arithmetic Conversion Instructions---------------------------------
11093 
11094 // Convert to Byte  -- nop
11095 // Convert to Short -- nop
11096 
11097 // Convert to Int
11098 
11099 instruct convB2I_reg(iRegIdst dst, iRegIsrc src, immI_24 amount) %{
11100   match(Set dst (RShiftI (LShiftI src amount) amount));
11101   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
11102   size(4);
11103   ins_encode %{
11104     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
11105     __ extsb($dst$$Register, $src$$Register);
11106   %}
11107   ins_pipe(pipe_class_default);
11108 %}
11109 
11110 instruct extsh(iRegIdst dst, iRegIsrc src) %{
11111   effect(DEF dst, USE src);
11112 
11113   size(4);
11114   ins_encode %{
11115     __ extsh($dst$$Register, $src$$Register);
11116   %}
11117   ins_pipe(pipe_class_default);
11118 %}
11119 
11120 // LShiftI 16 + RShiftI 16 converts short to int.
11121 instruct convS2I_reg(iRegIdst dst, iRegIsrc src, immI_16 amount) %{
11122   match(Set dst (RShiftI (LShiftI src amount) amount));
11123   format %{ &quot;EXTSH   $dst, $src \t// short-&gt;int&quot; %}
11124   size(4);
11125   ins_encode %{
11126     // TODO: PPC port $archOpcode(ppc64Opcode_extsh);
11127     __ extsh($dst$$Register, $src$$Register);
11128   %}
11129   ins_pipe(pipe_class_default);
11130 %}
11131 
11132 // ConvL2I + ConvI2L: Sign extend int in long register.
11133 instruct sxtI_L2L_reg(iRegLdst dst, iRegLsrc src) %{
11134   match(Set dst (ConvI2L (ConvL2I src)));
11135 
11136   format %{ &quot;EXTSW   $dst, $src \t// long-&gt;long&quot; %}
11137   size(4);
11138   ins_encode %{
11139     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11140     __ extsw($dst$$Register, $src$$Register);
11141   %}
11142   ins_pipe(pipe_class_default);
11143 %}
11144 
11145 instruct convL2I_reg(iRegIdst dst, iRegLsrc src) %{
11146   match(Set dst (ConvL2I src));
11147   format %{ &quot;MR      $dst, $src \t// long-&gt;int&quot; %}
11148   // variable size, 0 or 4
11149   ins_encode %{
11150     // TODO: PPC port $archOpcode(ppc64Opcode_or);
11151     __ mr_if_needed($dst$$Register, $src$$Register);
11152   %}
11153   ins_pipe(pipe_class_default);
11154 %}
11155 
11156 instruct convD2IRaw_regD(regD dst, regD src) %{
11157   // no match-rule, false predicate
11158   effect(DEF dst, USE src);
11159   predicate(false);
11160 
11161   format %{ &quot;FCTIWZ $dst, $src \t// convD2I, $src != NaN&quot; %}
11162   size(4);
11163   ins_encode %{
11164     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);;
11165     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11166   %}
11167   ins_pipe(pipe_class_default);
11168 %}
11169 
11170 instruct cmovI_bso_stackSlotL(iRegIdst dst, flagsRegSrc crx, stackSlotL src) %{
11171   // no match-rule, false predicate
11172   effect(DEF dst, USE crx, USE src);
11173   predicate(false);
11174 
11175   ins_variable_size_depending_on_alignment(true);
11176 
11177   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11178   // Worst case is branch + move + stop, no stop without scheduler.
11179   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11180   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11181   ins_pipe(pipe_class_default);
11182 %}
11183 
11184 instruct cmovI_bso_reg(iRegIdst dst, flagsRegSrc crx, regD src) %{
11185   // no match-rule, false predicate
11186   effect(DEF dst, USE crx, USE src);
11187   predicate(false);
11188 
11189   ins_variable_size_depending_on_alignment(true);
11190 
11191   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11192   // Worst case is branch + move + stop, no stop without scheduler.
11193   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11194   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11195   ins_pipe(pipe_class_default);
11196 %}
11197 
11198 instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{
11199   // no match-rule, false predicate
11200   effect(DEF dst, USE crx, USE mem);
11201   predicate(false);
11202 
11203   format %{ &quot;CmovI   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11204   postalloc_expand %{
11205     //
11206     // replaces
11207     //
11208     //   region  dst  crx  mem
11209     //    \       |    |   /
11210     //     dst=cmovI_bso_stackSlotL_conLvalue0
11211     //
11212     // with
11213     //
11214     //   region  dst
11215     //    \       /
11216     //     dst=loadConI16(0)
11217     //      |
11218     //      ^  region  dst  crx  mem
11219     //      |   \       |    |    /
11220     //      dst=cmovI_bso_stackSlotL
11221     //
11222 
11223     // Create new nodes.
11224     MachNode *m1 = new loadConI16Node();
11225     MachNode *m2 = new cmovI_bso_stackSlotLNode();
11226 
11227     // inputs for new nodes
11228     m1-&gt;add_req(n_region);
11229     m2-&gt;add_req(n_region, n_crx, n_mem);
11230 
11231     // precedences for new nodes
11232     m2-&gt;add_prec(m1);
11233 
11234     // operands for new nodes
11235     m1-&gt;_opnds[0] = op_dst;
11236     m1-&gt;_opnds[1] = new immI16Oper(0);
11237 
11238     m2-&gt;_opnds[0] = op_dst;
11239     m2-&gt;_opnds[1] = op_crx;
11240     m2-&gt;_opnds[2] = op_mem;
11241 
11242     // registers for new nodes
11243     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11244     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11245 
11246     // Insert new nodes.
11247     nodes-&gt;push(m1);
11248     nodes-&gt;push(m2);
11249   %}
11250 %}
11251 
11252 instruct cmovI_bso_reg_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, regD src) %{
11253   // no match-rule, false predicate
11254   effect(DEF dst, USE crx, USE src);
11255   predicate(false);
11256 
11257   format %{ &quot;CmovI   $dst, $crx, $src \t// postalloc expanded&quot; %}
11258   postalloc_expand %{
11259     //
11260     // replaces
11261     //
11262     //   region  dst  crx  src
11263     //    \       |    |   /
11264     //     dst=cmovI_bso_reg_conLvalue0
11265     //
11266     // with
11267     //
11268     //   region  dst
11269     //    \       /
11270     //     dst=loadConI16(0)
11271     //      |
11272     //      ^  region  dst  crx  src
11273     //      |   \       |    |    /
11274     //      dst=cmovI_bso_reg
11275     //
11276 
11277     // Create new nodes.
11278     MachNode *m1 = new loadConI16Node();
11279     MachNode *m2 = new cmovI_bso_regNode();
11280 
11281     // inputs for new nodes
11282     m1-&gt;add_req(n_region);
11283     m2-&gt;add_req(n_region, n_crx, n_src);
11284 
11285     // precedences for new nodes
11286     m2-&gt;add_prec(m1);
11287 
11288     // operands for new nodes
11289     m1-&gt;_opnds[0] = op_dst;
11290     m1-&gt;_opnds[1] = new immI16Oper(0);
11291 
11292     m2-&gt;_opnds[0] = op_dst;
11293     m2-&gt;_opnds[1] = op_crx;
11294     m2-&gt;_opnds[2] = op_src;
11295 
11296     // registers for new nodes
11297     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11298     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11299 
11300     // Insert new nodes.
11301     nodes-&gt;push(m1);
11302     nodes-&gt;push(m2);
11303   %}
11304 %}
11305 
11306 // Double to Int conversion, NaN is mapped to 0.
11307 instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{
11308   match(Set dst (ConvD2I src));
11309   predicate(!VM_Version::has_mtfprd());
11310   ins_cost(DEFAULT_COST);
11311 
11312   expand %{
11313     regD tmpD;
11314     stackSlotL tmpS;
11315     flagsReg crx;
11316     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11317     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11318     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11319     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11320   %}
11321 %}
11322 
11323 // Double to Int conversion, NaN is mapped to 0. Special version for Power8.
11324 instruct convD2I_reg_mffprd_ExEx(iRegIdst dst, regD src) %{
11325   match(Set dst (ConvD2I src));
11326   predicate(VM_Version::has_mtfprd());
11327   ins_cost(DEFAULT_COST);
11328 
11329   expand %{
11330     regD tmpD;
11331     flagsReg crx;
11332     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11333     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11334     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11335   %}
11336 %}
11337 
11338 instruct convF2IRaw_regF(regF dst, regF src) %{
11339   // no match-rule, false predicate
11340   effect(DEF dst, USE src);
11341   predicate(false);
11342 
11343   format %{ &quot;FCTIWZ $dst, $src \t// convF2I, $src != NaN&quot; %}
11344   size(4);
11345   ins_encode %{
11346     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11347     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11348   %}
11349   ins_pipe(pipe_class_default);
11350 %}
11351 
11352 // Float to Int conversion, NaN is mapped to 0.
11353 instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{
11354   match(Set dst (ConvF2I src));
11355   predicate(!VM_Version::has_mtfprd());
11356   ins_cost(DEFAULT_COST);
11357 
11358   expand %{
11359     regF tmpF;
11360     stackSlotL tmpS;
11361     flagsReg crx;
11362     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11363     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11364     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11365     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11366   %}
11367 %}
11368 
11369 // Float to Int conversion, NaN is mapped to 0. Special version for Power8.
11370 instruct convF2I_regF_mffprd_ExEx(iRegIdst dst, regF src) %{
11371   match(Set dst (ConvF2I src));
11372   predicate(VM_Version::has_mtfprd());
11373   ins_cost(DEFAULT_COST);
11374 
11375   expand %{
11376     regF tmpF;
11377     flagsReg crx;
11378     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11379     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11380     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11381   %}
11382 %}
11383 
11384 // Convert to Long
11385 
11386 instruct convI2L_reg(iRegLdst dst, iRegIsrc src) %{
11387   match(Set dst (ConvI2L src));
11388   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;long&quot; %}
11389   size(4);
11390   ins_encode %{
11391     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11392     __ extsw($dst$$Register, $src$$Register);
11393   %}
11394   ins_pipe(pipe_class_default);
11395 %}
11396 
11397 // Zero-extend: convert unsigned int to long (convUI2L).
11398 instruct zeroExtendL_regI(iRegLdst dst, iRegIsrc src, immL_32bits mask) %{
11399   match(Set dst (AndL (ConvI2L src) mask));
11400   ins_cost(DEFAULT_COST);
11401 
11402   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11403   size(4);
11404   ins_encode %{
11405     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11406     __ clrldi($dst$$Register, $src$$Register, 32);
11407   %}
11408   ins_pipe(pipe_class_default);
11409 %}
11410 
11411 // Zero-extend: convert unsigned int to long in long register.
11412 instruct zeroExtendL_regL(iRegLdst dst, iRegLsrc src, immL_32bits mask) %{
11413   match(Set dst (AndL src mask));
11414   ins_cost(DEFAULT_COST);
11415 
11416   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11417   size(4);
11418   ins_encode %{
11419     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11420     __ clrldi($dst$$Register, $src$$Register, 32);
11421   %}
11422   ins_pipe(pipe_class_default);
11423 %}
11424 
11425 instruct convF2LRaw_regF(regF dst, regF src) %{
11426   // no match-rule, false predicate
11427   effect(DEF dst, USE src);
11428   predicate(false);
11429 
11430   format %{ &quot;FCTIDZ $dst, $src \t// convF2L, $src != NaN&quot; %}
11431   size(4);
11432   ins_encode %{
11433     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11434     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11435   %}
11436   ins_pipe(pipe_class_default);
11437 %}
11438 
11439 instruct cmovL_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL src) %{
11440   // no match-rule, false predicate
11441   effect(DEF dst, USE crx, USE src);
11442   predicate(false);
11443 
11444   ins_variable_size_depending_on_alignment(true);
11445 
11446   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11447   // Worst case is branch + move + stop, no stop without scheduler.
11448   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11449   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11450   ins_pipe(pipe_class_default);
11451 %}
11452 
11453 instruct cmovL_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
11454   // no match-rule, false predicate
11455   effect(DEF dst, USE crx, USE src);
11456   predicate(false);
11457 
11458   ins_variable_size_depending_on_alignment(true);
11459 
11460   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11461   // Worst case is branch + move + stop, no stop without scheduler.
11462   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11463   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11464   ins_pipe(pipe_class_default);
11465 %}
11466 
11467 instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{
11468   // no match-rule, false predicate
11469   effect(DEF dst, USE crx, USE mem);
11470   predicate(false);
11471 
11472   format %{ &quot;CmovL   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11473   postalloc_expand %{
11474     //
11475     // replaces
11476     //
11477     //   region  dst  crx  mem
11478     //    \       |    |   /
11479     //     dst=cmovL_bso_stackSlotL_conLvalue0
11480     //
11481     // with
11482     //
11483     //   region  dst
11484     //    \       /
11485     //     dst=loadConL16(0)
11486     //      |
11487     //      ^  region  dst  crx  mem
11488     //      |   \       |    |    /
11489     //      dst=cmovL_bso_stackSlotL
11490     //
11491 
11492     // Create new nodes.
11493     MachNode *m1 = new loadConL16Node();
11494     MachNode *m2 = new cmovL_bso_stackSlotLNode();
11495 
11496     // inputs for new nodes
11497     m1-&gt;add_req(n_region);
11498     m2-&gt;add_req(n_region, n_crx, n_mem);
11499     m2-&gt;add_prec(m1);
11500 
11501     // operands for new nodes
11502     m1-&gt;_opnds[0] = op_dst;
11503     m1-&gt;_opnds[1] = new immL16Oper(0);
11504     m2-&gt;_opnds[0] = op_dst;
11505     m2-&gt;_opnds[1] = op_crx;
11506     m2-&gt;_opnds[2] = op_mem;
11507 
11508     // registers for new nodes
11509     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11510     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11511 
11512     // Insert new nodes.
11513     nodes-&gt;push(m1);
11514     nodes-&gt;push(m2);
11515   %}
11516 %}
11517 
11518 instruct cmovL_bso_reg_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, regD src) %{
11519   // no match-rule, false predicate
11520   effect(DEF dst, USE crx, USE src);
11521   predicate(false);
11522 
11523   format %{ &quot;CmovL   $dst, $crx, $src \t// postalloc expanded&quot; %}
11524   postalloc_expand %{
11525     //
11526     // replaces
11527     //
11528     //   region  dst  crx  src
11529     //    \       |    |   /
11530     //     dst=cmovL_bso_reg_conLvalue0
11531     //
11532     // with
11533     //
11534     //   region  dst
11535     //    \       /
11536     //     dst=loadConL16(0)
11537     //      |
11538     //      ^  region  dst  crx  src
11539     //      |   \       |    |    /
11540     //      dst=cmovL_bso_reg
11541     //
11542 
11543     // Create new nodes.
11544     MachNode *m1 = new loadConL16Node();
11545     MachNode *m2 = new cmovL_bso_regNode();
11546 
11547     // inputs for new nodes
11548     m1-&gt;add_req(n_region);
11549     m2-&gt;add_req(n_region, n_crx, n_src);
11550     m2-&gt;add_prec(m1);
11551 
11552     // operands for new nodes
11553     m1-&gt;_opnds[0] = op_dst;
11554     m1-&gt;_opnds[1] = new immL16Oper(0);
11555     m2-&gt;_opnds[0] = op_dst;
11556     m2-&gt;_opnds[1] = op_crx;
11557     m2-&gt;_opnds[2] = op_src;
11558 
11559     // registers for new nodes
11560     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11561     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11562 
11563     // Insert new nodes.
11564     nodes-&gt;push(m1);
11565     nodes-&gt;push(m2);
11566   %}
11567 %}
11568 
11569 // Float to Long conversion, NaN is mapped to 0.
11570 instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{
11571   match(Set dst (ConvF2L src));
11572   predicate(!VM_Version::has_mtfprd());
11573   ins_cost(DEFAULT_COST);
11574 
11575   expand %{
11576     regF tmpF;
11577     stackSlotL tmpS;
11578     flagsReg crx;
11579     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11580     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11581     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11582     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11583   %}
11584 %}
11585 
11586 // Float to Long conversion, NaN is mapped to 0. Special version for Power8.
11587 instruct convF2L_reg_mffprd_ExEx(iRegLdst dst, regF src) %{
11588   match(Set dst (ConvF2L src));
11589   predicate(VM_Version::has_mtfprd());
11590   ins_cost(DEFAULT_COST);
11591 
11592   expand %{
11593     regF tmpF;
11594     flagsReg crx;
11595     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11596     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11597     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11598   %}
11599 %}
11600 
11601 instruct convD2LRaw_regD(regD dst, regD src) %{
11602   // no match-rule, false predicate
11603   effect(DEF dst, USE src);
11604   predicate(false);
11605 
11606   format %{ &quot;FCTIDZ $dst, $src \t// convD2L $src != NaN&quot; %}
11607   size(4);
11608   ins_encode %{
11609     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11610     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11611   %}
11612   ins_pipe(pipe_class_default);
11613 %}
11614 
11615 // Double to Long conversion, NaN is mapped to 0.
11616 instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{
11617   match(Set dst (ConvD2L src));
11618   predicate(!VM_Version::has_mtfprd());
11619   ins_cost(DEFAULT_COST);
11620 
11621   expand %{
11622     regD tmpD;
11623     stackSlotL tmpS;
11624     flagsReg crx;
11625     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11626     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11627     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11628     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11629   %}
11630 %}
11631 
11632 // Double to Long conversion, NaN is mapped to 0. Special version for Power8.
11633 instruct convD2L_reg_mffprd_ExEx(iRegLdst dst, regD src) %{
11634   match(Set dst (ConvD2L src));
11635   predicate(VM_Version::has_mtfprd());
11636   ins_cost(DEFAULT_COST);
11637 
11638   expand %{
11639     regD tmpD;
11640     flagsReg crx;
11641     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11642     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11643     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11644   %}
11645 %}
11646 
11647 // Convert to Float
11648 
11649 // Placed here as needed in expand.
11650 instruct convL2DRaw_regD(regD dst, regD src) %{
11651   // no match-rule, false predicate
11652   effect(DEF dst, USE src);
11653   predicate(false);
11654 
11655   format %{ &quot;FCFID $dst, $src \t// convL2D&quot; %}
11656   size(4);
11657   ins_encode %{
11658     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11659     __ fcfid($dst$$FloatRegister, $src$$FloatRegister);
11660   %}
11661   ins_pipe(pipe_class_default);
11662 %}
11663 
11664 // Placed here as needed in expand.
11665 instruct convD2F_reg(regF dst, regD src) %{
11666   match(Set dst (ConvD2F src));
11667   format %{ &quot;FRSP    $dst, $src \t// convD2F&quot; %}
11668   size(4);
11669   ins_encode %{
11670     // TODO: PPC port $archOpcode(ppc64Opcode_frsp);
11671     __ frsp($dst$$FloatRegister, $src$$FloatRegister);
11672   %}
11673   ins_pipe(pipe_class_default);
11674 %}
11675 
11676 // Integer to Float conversion.
11677 instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{
11678   match(Set dst (ConvI2F src));
11679   predicate(!VM_Version::has_fcfids());
11680   ins_cost(DEFAULT_COST);
11681 
11682   expand %{
11683     iRegLdst tmpL;
11684     stackSlotL tmpS;
11685     regD tmpD;
11686     regD tmpD2;
11687     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11688     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11689     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11690     convL2DRaw_regD(tmpD2, tmpD);        // Convert to double.
11691     convD2F_reg(dst, tmpD2);             // Convert double to float.
11692   %}
11693 %}
11694 
11695 instruct convL2FRaw_regF(regF dst, regD src) %{
11696   // no match-rule, false predicate
11697   effect(DEF dst, USE src);
11698   predicate(false);
11699 
11700   format %{ &quot;FCFIDS $dst, $src \t// convL2F&quot; %}
11701   size(4);
11702   ins_encode %{
11703     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11704     __ fcfids($dst$$FloatRegister, $src$$FloatRegister);
11705   %}
11706   ins_pipe(pipe_class_default);
11707 %}
11708 
11709 // Integer to Float conversion. Special version for Power7.
11710 instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{
11711   match(Set dst (ConvI2F src));
11712   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11713   ins_cost(DEFAULT_COST);
11714 
11715   expand %{
11716     iRegLdst tmpL;
11717     stackSlotL tmpS;
11718     regD tmpD;
11719     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11720     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11721     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11722     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11723   %}
11724 %}
11725 
11726 // Integer to Float conversion. Special version for Power8.
11727 instruct convI2F_ireg_mtfprd_Ex(regF dst, iRegIsrc src) %{
11728   match(Set dst (ConvI2F src));
11729   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11730   ins_cost(DEFAULT_COST);
11731 
11732   expand %{
11733     regD tmpD;
11734     moveI2D_reg(tmpD, src);
11735     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11736   %}
11737 %}
11738 
11739 // L2F to avoid runtime call.
11740 instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{
11741   match(Set dst (ConvL2F src));
11742   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11743   ins_cost(DEFAULT_COST);
11744 
11745   expand %{
11746     stackSlotL tmpS;
11747     regD tmpD;
11748     regL_to_stkL(tmpS, src);             // Store long to stack.
11749     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11750     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11751   %}
11752 %}
11753 
11754 // L2F to avoid runtime call.  Special version for Power8.
11755 instruct convL2F_ireg_mtfprd_Ex(regF dst, iRegLsrc src) %{
11756   match(Set dst (ConvL2F src));
11757   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11758   ins_cost(DEFAULT_COST);
11759 
11760   expand %{
11761     regD tmpD;
11762     moveL2D_reg(tmpD, src);
11763     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11764   %}
11765 %}
11766 
11767 // Moved up as used in expand.
11768 //instruct convD2F_reg(regF dst, regD src) %{%}
11769 
11770 // Convert to Double
11771 
11772 // Integer to Double conversion.
11773 instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{
11774   match(Set dst (ConvI2D src));
11775   predicate(!VM_Version::has_mtfprd());
11776   ins_cost(DEFAULT_COST);
11777 
11778   expand %{
11779     iRegLdst tmpL;
11780     stackSlotL tmpS;
11781     regD tmpD;
11782     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11783     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11784     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11785     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11786   %}
11787 %}
11788 
11789 // Integer to Double conversion. Special version for Power8.
11790 instruct convI2D_reg_mtfprd_Ex(regD dst, iRegIsrc src) %{
11791   match(Set dst (ConvI2D src));
11792   predicate(VM_Version::has_mtfprd());
11793   ins_cost(DEFAULT_COST);
11794 
11795   expand %{
11796     regD tmpD;
11797     moveI2D_reg(tmpD, src);
11798     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11799   %}
11800 %}
11801 
11802 // Long to Double conversion
11803 instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{
11804   match(Set dst (ConvL2D src));
11805   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
11806 
11807   expand %{
11808     regD tmpD;
11809     moveL2D_stack_reg(tmpD, src);
11810     convL2DRaw_regD(dst, tmpD);
11811   %}
11812 %}
11813 
11814 // Long to Double conversion. Special version for Power8.
11815 instruct convL2D_reg_mtfprd_Ex(regD dst, iRegLsrc src) %{
11816   match(Set dst (ConvL2D src));
11817   predicate(VM_Version::has_mtfprd());
11818   ins_cost(DEFAULT_COST);
11819 
11820   expand %{
11821     regD tmpD;
11822     moveL2D_reg(tmpD, src);
11823     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11824   %}
11825 %}
11826 
11827 instruct convF2D_reg(regD dst, regF src) %{
11828   match(Set dst (ConvF2D src));
11829   format %{ &quot;FMR     $dst, $src \t// float-&gt;double&quot; %}
11830   // variable size, 0 or 4
11831   ins_encode %{
11832     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
11833     __ fmr_if_needed($dst$$FloatRegister, $src$$FloatRegister);
11834   %}
11835   ins_pipe(pipe_class_default);
11836 %}
11837 
11838 //----------Control Flow Instructions------------------------------------------
11839 // Compare Instructions
11840 
11841 // Compare Integers
11842 instruct cmpI_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11843   match(Set crx (CmpI src1 src2));
11844   size(4);
11845   format %{ &quot;CMPW    $crx, $src1, $src2&quot; %}
11846   ins_encode %{
11847     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11848     __ cmpw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11849   %}
11850   ins_pipe(pipe_class_compare);
11851 %}
11852 
11853 instruct cmpI_reg_imm16(flagsReg crx, iRegIsrc src1, immI16 src2) %{
11854   match(Set crx (CmpI src1 src2));
11855   format %{ &quot;CMPWI   $crx, $src1, $src2&quot; %}
11856   size(4);
11857   ins_encode %{
11858     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11859     __ cmpwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11860   %}
11861   ins_pipe(pipe_class_compare);
11862 %}
11863 
11864 // (src1 &amp; src2) == 0?
11865 instruct testI_reg_imm(flagsRegCR0 cr0, iRegIsrc src1, uimmI16 src2, immI_0 zero) %{
11866   match(Set cr0 (CmpI (AndI src1 src2) zero));
11867   // r0 is killed
11868   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST int&quot; %}
11869   size(4);
11870   ins_encode %{
11871     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11872     __ andi_(R0, $src1$$Register, $src2$$constant);
11873   %}
11874   ins_pipe(pipe_class_compare);
11875 %}
11876 
11877 instruct cmpL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11878   match(Set crx (CmpL src1 src2));
11879   format %{ &quot;CMPD    $crx, $src1, $src2&quot; %}
11880   size(4);
11881   ins_encode %{
11882     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11883     __ cmpd($crx$$CondRegister, $src1$$Register, $src2$$Register);
11884   %}
11885   ins_pipe(pipe_class_compare);
11886 %}
11887 
11888 instruct cmpL_reg_imm16(flagsReg crx, iRegLsrc src1, immL16 src2) %{
11889   match(Set crx (CmpL src1 src2));
11890   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
11891   size(4);
11892   ins_encode %{
11893     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11894     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11895   %}
11896   ins_pipe(pipe_class_compare);
11897 %}
11898 
11899 // Added CmpUL for LoopPredicate.
11900 instruct cmpUL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11901   match(Set crx (CmpUL src1 src2));
11902   format %{ &quot;CMPLD   $crx, $src1, $src2&quot; %}
11903   size(4);
11904   ins_encode %{
11905     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11906     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
11907   %}
11908   ins_pipe(pipe_class_compare);
11909 %}
11910 
11911 instruct cmpUL_reg_imm16(flagsReg crx, iRegLsrc src1, uimmL16 src2) %{
11912   match(Set crx (CmpUL src1 src2));
11913   format %{ &quot;CMPLDI  $crx, $src1, $src2&quot; %}
11914   size(4);
11915   ins_encode %{
11916     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11917     __ cmpldi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11918   %}
11919   ins_pipe(pipe_class_compare);
11920 %}
11921 
11922 instruct testL_reg_reg(flagsRegCR0 cr0, iRegLsrc src1, iRegLsrc src2, immL_0 zero) %{
11923   match(Set cr0 (CmpL (AndL src1 src2) zero));
11924   // r0 is killed
11925   format %{ &quot;AND     R0, $src1, $src2 \t// BTST long&quot; %}
11926   size(4);
11927   ins_encode %{
11928     // TODO: PPC port $archOpcode(ppc64Opcode_and_);
11929     __ and_(R0, $src1$$Register, $src2$$Register);
11930   %}
11931   ins_pipe(pipe_class_compare);
11932 %}
11933 
11934 instruct testL_reg_imm(flagsRegCR0 cr0, iRegLsrc src1, uimmL16 src2, immL_0 zero) %{
11935   match(Set cr0 (CmpL (AndL src1 src2) zero));
11936   // r0 is killed
11937   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST long&quot; %}
11938   size(4);
11939   ins_encode %{
11940     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11941     __ andi_(R0, $src1$$Register, $src2$$constant);
11942   %}
11943   ins_pipe(pipe_class_compare);
11944 %}
11945 
11946 instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{
11947   // no match-rule, false predicate
11948   effect(DEF dst, USE crx);
11949   predicate(false);
11950 
11951   ins_variable_size_depending_on_alignment(true);
11952 
11953   format %{ &quot;cmovI   $crx, $dst, -1, 0, +1&quot; %}
11954   // Worst case is branch + move + branch + move + stop, no stop without scheduler.
11955   size((false /* TODO: PPC PORTInsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 20 : 16));
11956   ins_encode %{
11957     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
11958     Label done;
11959     // li(Rdst, 0);              // equal -&gt; 0
11960     __ beq($crx$$CondRegister, done);
11961     __ li($dst$$Register, 1);    // greater -&gt; +1
11962     __ bgt($crx$$CondRegister, done);
11963     __ li($dst$$Register, -1);   // unordered or less -&gt; -1
11964     // TODO: PPC port__ endgroup_if_needed(_size == 20);
11965     __ bind(done);
11966   %}
11967   ins_pipe(pipe_class_compare);
11968 %}
11969 
11970 instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{
11971   // no match-rule, false predicate
11972   effect(DEF dst, USE crx);
11973   predicate(false);
11974 
11975   format %{ &quot;CmovI    $crx, $dst, -1, 0, +1 \t// postalloc expanded&quot; %}
11976   postalloc_expand %{
11977     //
11978     // replaces
11979     //
11980     //   region  crx
11981     //    \       |
11982     //     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1
11983     //
11984     // with
11985     //
11986     //   region
11987     //    \
11988     //     dst=loadConI16(0)
11989     //      |
11990     //      ^  region  crx
11991     //      |   \       |
11992     //      dst=cmovI_conIvalueMinus1_conIvalue1
11993     //
11994 
11995     // Create new nodes.
11996     MachNode *m1 = new loadConI16Node();
11997     MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();
11998 
11999     // inputs for new nodes
12000     m1-&gt;add_req(n_region);
12001     m2-&gt;add_req(n_region, n_crx);
12002     m2-&gt;add_prec(m1);
12003 
12004     // operands for new nodes
12005     m1-&gt;_opnds[0] = op_dst;
12006     m1-&gt;_opnds[1] = new immI16Oper(0);
12007     m2-&gt;_opnds[0] = op_dst;
12008     m2-&gt;_opnds[1] = op_crx;
12009 
12010     // registers for new nodes
12011     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12012     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12013 
12014     // Insert new nodes.
12015     nodes-&gt;push(m1);
12016     nodes-&gt;push(m2);
12017   %}
12018 %}
12019 
12020 // Manifest a CmpL3 result in an integer register. Very painful.
12021 // This is the test to avoid.
12022 // (src1 &lt; src2) ? -1 : ((src1 &gt; src2) ? 1 : 0)
12023 instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
12024   match(Set dst (CmpL3 src1 src2));
12025   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12026 
12027   expand %{
12028     flagsReg tmp1;
12029     cmpL_reg_reg(tmp1, src1, src2);
12030     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12031   %}
12032 %}
12033 
12034 // Implicit range checks.
12035 // A range check in the ideal world has one of the following shapes:
12036 //  - (If le (CmpU length index)), (IfTrue  throw exception)
12037 //  - (If lt (CmpU index length)), (IfFalse throw exception)
12038 //
12039 // Match range check &#39;If le (CmpU length index)&#39;.
12040 instruct rangeCheck_iReg_uimm15(cmpOp cmp, iRegIsrc src_length, uimmI15 index, label labl) %{
12041   match(If cmp (CmpU src_length index));
12042   effect(USE labl);
12043   predicate(TrapBasedRangeChecks &amp;&amp;
12044             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
12045             PROB_UNLIKELY(_leaf-&gt;as_If()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
12046             (Matcher::branches_to_uncommon_trap(_leaf)));
12047 
12048   ins_is_TrapBasedCheckNode(true);
12049 
12050   format %{ &quot;TWI     $index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12051   size(4);
12052   ins_encode %{
12053     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12054     if ($cmp$$cmpcode == 0x1 /* less_equal */) {
12055       __ trap_range_check_le($src_length$$Register, $index$$constant);
12056     } else {
12057       // Both successors are uncommon traps, probability is 0.
12058       // Node got flipped during fixup flow.
12059       assert($cmp$$cmpcode == 0x9, &quot;must be greater&quot;);
12060       __ trap_range_check_g($src_length$$Register, $index$$constant);
12061     }
12062   %}
12063   ins_pipe(pipe_class_trap);
12064 %}
12065 
12066 // Match range check &#39;If lt (CmpU index length)&#39;.
12067 instruct rangeCheck_iReg_iReg(cmpOp cmp, iRegIsrc src_index, iRegIsrc src_length, label labl) %{
12068   match(If cmp (CmpU src_index src_length));
12069   effect(USE labl);
12070   predicate(TrapBasedRangeChecks &amp;&amp;
12071             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12072             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12073             (Matcher::branches_to_uncommon_trap(_leaf)));
12074 
12075   ins_is_TrapBasedCheckNode(true);
12076 
12077   format %{ &quot;TW      $src_index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12078   size(4);
12079   ins_encode %{
12080     // TODO: PPC port $archOpcode(ppc64Opcode_tw);
12081     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12082       __ trap_range_check_ge($src_index$$Register, $src_length$$Register);
12083     } else {
12084       // Both successors are uncommon traps, probability is 0.
12085       // Node got flipped during fixup flow.
12086       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12087       __ trap_range_check_l($src_index$$Register, $src_length$$Register);
12088     }
12089   %}
12090   ins_pipe(pipe_class_trap);
12091 %}
12092 
12093 // Match range check &#39;If lt (CmpU index length)&#39;.
12094 instruct rangeCheck_uimm15_iReg(cmpOp cmp, iRegIsrc src_index, uimmI15 length, label labl) %{
12095   match(If cmp (CmpU src_index length));
12096   effect(USE labl);
12097   predicate(TrapBasedRangeChecks &amp;&amp;
12098             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12099             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12100             (Matcher::branches_to_uncommon_trap(_leaf)));
12101 
12102   ins_is_TrapBasedCheckNode(true);
12103 
12104   format %{ &quot;TWI     $src_index $cmp $length \t// RangeCheck =&gt; trap $labl&quot; %}
12105   size(4);
12106   ins_encode %{
12107     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12108     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12109       __ trap_range_check_ge($src_index$$Register, $length$$constant);
12110     } else {
12111       // Both successors are uncommon traps, probability is 0.
12112       // Node got flipped during fixup flow.
12113       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12114       __ trap_range_check_l($src_index$$Register, $length$$constant);
12115     }
12116   %}
12117   ins_pipe(pipe_class_trap);
12118 %}
12119 
12120 instruct compU_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
12121   match(Set crx (CmpU src1 src2));
12122   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// unsigned&quot; %}
12123   size(4);
12124   ins_encode %{
12125     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12126     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12127   %}
12128   ins_pipe(pipe_class_compare);
12129 %}
12130 
12131 instruct compU_reg_uimm16(flagsReg crx, iRegIsrc src1, uimmI16 src2) %{
12132   match(Set crx (CmpU src1 src2));
12133   size(4);
12134   format %{ &quot;CMPLWI  $crx, $src1, $src2&quot; %}
12135   ins_encode %{
12136     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12137     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12138   %}
12139   ins_pipe(pipe_class_compare);
12140 %}
12141 
12142 // Implicit zero checks (more implicit null checks).
12143 // No constant pool entries required.
12144 instruct zeroCheckN_iReg_imm0(cmpOp cmp, iRegNsrc value, immN_0 zero, label labl) %{
12145   match(If cmp (CmpN value zero));
12146   effect(USE labl);
12147   predicate(TrapBasedNullChecks &amp;&amp;
12148             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12149             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12150             Matcher::branches_to_uncommon_trap(_leaf));
12151   ins_cost(1);
12152 
12153   ins_is_TrapBasedCheckNode(true);
12154 
12155   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckN =&gt; trap $labl&quot; %}
12156   size(4);
12157   ins_encode %{
12158     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12159     if ($cmp$$cmpcode == 0xA) {
12160       __ trap_null_check($value$$Register);
12161     } else {
12162       // Both successors are uncommon traps, probability is 0.
12163       // Node got flipped during fixup flow.
12164       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12165       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12166     }
12167   %}
12168   ins_pipe(pipe_class_trap);
12169 %}
12170 
12171 // Compare narrow oops.
12172 instruct cmpN_reg_reg(flagsReg crx, iRegNsrc src1, iRegNsrc src2) %{
12173   match(Set crx (CmpN src1 src2));
12174 
12175   size(4);
12176   ins_cost(2);
12177   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// compressed ptr&quot; %}
12178   ins_encode %{
12179     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12180     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12181   %}
12182   ins_pipe(pipe_class_compare);
12183 %}
12184 
12185 instruct cmpN_reg_imm0(flagsReg crx, iRegNsrc src1, immN_0 src2) %{
12186   match(Set crx (CmpN src1 src2));
12187   // Make this more expensive than zeroCheckN_iReg_imm0.
12188   ins_cost(2);
12189 
12190   format %{ &quot;CMPLWI  $crx, $src1, $src2 \t// compressed ptr&quot; %}
12191   size(4);
12192   ins_encode %{
12193     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12194     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12195   %}
12196   ins_pipe(pipe_class_compare);
12197 %}
12198 
12199 // Implicit zero checks (more implicit null checks).
12200 // No constant pool entries required.
12201 instruct zeroCheckP_reg_imm0(cmpOp cmp, iRegP_N2P value, immP_0 zero, label labl) %{
12202   match(If cmp (CmpP value zero));
12203   effect(USE labl);
12204   predicate(TrapBasedNullChecks &amp;&amp;
12205             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12206             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12207             Matcher::branches_to_uncommon_trap(_leaf));
12208   ins_cost(1); // Should not be cheaper than zeroCheckN.
12209 
12210   ins_is_TrapBasedCheckNode(true);
12211 
12212   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckP =&gt; trap $labl&quot; %}
12213   size(4);
12214   ins_encode %{
12215     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12216     if ($cmp$$cmpcode == 0xA) {
12217       __ trap_null_check($value$$Register);
12218     } else {
12219       // Both successors are uncommon traps, probability is 0.
12220       // Node got flipped during fixup flow.
12221       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12222       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12223     }
12224   %}
12225   ins_pipe(pipe_class_trap);
12226 %}
12227 
12228 // Compare Pointers
12229 instruct cmpP_reg_reg(flagsReg crx, iRegP_N2P src1, iRegP_N2P src2) %{
12230   match(Set crx (CmpP src1 src2));
12231   format %{ &quot;CMPLD   $crx, $src1, $src2 \t// ptr&quot; %}
12232   size(4);
12233   ins_encode %{
12234     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12235     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
12236   %}
12237   ins_pipe(pipe_class_compare);
12238 %}
12239 
12240 instruct cmpP_reg_null(flagsReg crx, iRegP_N2P src1, immP_0or1 src2) %{
12241   match(Set crx (CmpP src1 src2));
12242   format %{ &quot;CMPLDI   $crx, $src1, $src2 \t// ptr&quot; %}
12243   size(4);
12244   ins_encode %{
12245     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12246     __ cmpldi($crx$$CondRegister, $src1$$Register, (int)((short)($src2$$constant &amp; 0xFFFF)));
12247   %}
12248   ins_pipe(pipe_class_compare);
12249 %}
12250 
12251 // Used in postalloc expand.
12252 instruct cmpP_reg_imm16(flagsReg crx, iRegPsrc src1, immL16 src2) %{
12253   // This match rule prevents reordering of node before a safepoint.
12254   // This only makes sense if this instructions is used exclusively
12255   // for the expansion of EncodeP!
12256   match(Set crx (CmpP src1 src2));
12257   predicate(false);
12258 
12259   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
12260   size(4);
12261   ins_encode %{
12262     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
12263     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12264   %}
12265   ins_pipe(pipe_class_compare);
12266 %}
12267 
12268 //----------Float Compares----------------------------------------------------
12269 
12270 instruct cmpFUnordered_reg_reg(flagsReg crx, regF src1, regF src2) %{
12271   // Needs matchrule, see cmpDUnordered.
12272   match(Set crx (CmpF src1 src2));
12273   // no match-rule, false predicate
12274   predicate(false);
12275 
12276   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12277   size(4);
12278   ins_encode %{
12279     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12280     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12281   %}
12282   ins_pipe(pipe_class_default);
12283 %}
12284 
12285 instruct cmov_bns_less(flagsReg crx) %{
12286   // no match-rule, false predicate
12287   effect(DEF crx);
12288   predicate(false);
12289 
12290   ins_variable_size_depending_on_alignment(true);
12291 
12292   format %{ &quot;cmov    $crx&quot; %}
12293   // Worst case is branch + move + stop, no stop without scheduler.
12294   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 16 : 12));
12295   ins_encode %{
12296     // TODO: PPC port $archOpcode(ppc64Opcode_cmovecr);
12297     Label done;
12298     __ bns($crx$$CondRegister, done);        // not unordered -&gt; keep crx
12299     __ li(R0, 0);
12300     __ cmpwi($crx$$CondRegister, R0, 1);     // unordered -&gt; set crx to &#39;less&#39;
12301     // TODO PPC port __ endgroup_if_needed(_size == 16);
12302     __ bind(done);
12303   %}
12304   ins_pipe(pipe_class_default);
12305 %}
12306 
12307 // Compare floating, generate condition code.
12308 instruct cmpF_reg_reg_Ex(flagsReg crx, regF src1, regF src2) %{
12309   // FIXME: should we match &#39;If cmp (CmpF src1 src2))&#39; ??
12310   //
12311   // The following code sequence occurs a lot in mpegaudio:
12312   //
12313   // block BXX:
12314   // 0: instruct cmpFUnordered_reg_reg (cmpF_reg_reg-0):
12315   //    cmpFUrd CCR6, F11, F9
12316   // 4: instruct cmov_bns_less (cmpF_reg_reg-1):
12317   //    cmov CCR6
12318   // 8: instruct branchConSched:
12319   //    B_FARle CCR6, B56  P=0.500000 C=-1.000000
12320   match(Set crx (CmpF src1 src2));
12321   ins_cost(DEFAULT_COST+BRANCH_COST);
12322 
12323   format %{ &quot;CmpF    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12324   postalloc_expand %{
12325     //
12326     // replaces
12327     //
12328     //   region  src1  src2
12329     //    \       |     |
12330     //     crx=cmpF_reg_reg
12331     //
12332     // with
12333     //
12334     //   region  src1  src2
12335     //    \       |     |
12336     //     crx=cmpFUnordered_reg_reg
12337     //      |
12338     //      ^  region
12339     //      |   \
12340     //      crx=cmov_bns_less
12341     //
12342 
12343     // Create new nodes.
12344     MachNode *m1 = new cmpFUnordered_reg_regNode();
12345     MachNode *m2 = new cmov_bns_lessNode();
12346 
12347     // inputs for new nodes
12348     m1-&gt;add_req(n_region, n_src1, n_src2);
12349     m2-&gt;add_req(n_region);
12350     m2-&gt;add_prec(m1);
12351 
12352     // operands for new nodes
12353     m1-&gt;_opnds[0] = op_crx;
12354     m1-&gt;_opnds[1] = op_src1;
12355     m1-&gt;_opnds[2] = op_src2;
12356     m2-&gt;_opnds[0] = op_crx;
12357 
12358     // registers for new nodes
12359     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12360     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12361 
12362     // Insert new nodes.
12363     nodes-&gt;push(m1);
12364     nodes-&gt;push(m2);
12365   %}
12366 %}
12367 
12368 // Compare float, generate -1,0,1
12369 instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{
12370   match(Set dst (CmpF3 src1 src2));
12371   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12372 
12373   expand %{
12374     flagsReg tmp1;
12375     cmpFUnordered_reg_reg(tmp1, src1, src2);
12376     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12377   %}
12378 %}
12379 
12380 instruct cmpDUnordered_reg_reg(flagsReg crx, regD src1, regD src2) %{
12381   // Needs matchrule so that ideal opcode is Cmp. This causes that gcm places the
12382   // node right before the conditional move using it.
12383   // In jck test api/java_awt/geom/QuadCurve2DFloat/index.html#SetCurveTesttestCase7,
12384   // compilation of java.awt.geom.RectangularShape::getBounds()Ljava/awt/Rectangle
12385   // crashed in register allocation where the flags Reg between cmpDUnoredered and a
12386   // conditional move was supposed to be spilled.
12387   match(Set crx (CmpD src1 src2));
12388   // False predicate, shall not be matched.
12389   predicate(false);
12390 
12391   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12392   size(4);
12393   ins_encode %{
12394     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12395     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12396   %}
12397   ins_pipe(pipe_class_default);
12398 %}
12399 
12400 instruct cmpD_reg_reg_Ex(flagsReg crx, regD src1, regD src2) %{
12401   match(Set crx (CmpD src1 src2));
12402   ins_cost(DEFAULT_COST+BRANCH_COST);
12403 
12404   format %{ &quot;CmpD    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12405   postalloc_expand %{
12406     //
12407     // replaces
12408     //
12409     //   region  src1  src2
12410     //    \       |     |
12411     //     crx=cmpD_reg_reg
12412     //
12413     // with
12414     //
12415     //   region  src1  src2
12416     //    \       |     |
12417     //     crx=cmpDUnordered_reg_reg
12418     //      |
12419     //      ^  region
12420     //      |   \
12421     //      crx=cmov_bns_less
12422     //
12423 
12424     // create new nodes
12425     MachNode *m1 = new cmpDUnordered_reg_regNode();
12426     MachNode *m2 = new cmov_bns_lessNode();
12427 
12428     // inputs for new nodes
12429     m1-&gt;add_req(n_region, n_src1, n_src2);
12430     m2-&gt;add_req(n_region);
12431     m2-&gt;add_prec(m1);
12432 
12433     // operands for new nodes
12434     m1-&gt;_opnds[0] = op_crx;
12435     m1-&gt;_opnds[1] = op_src1;
12436     m1-&gt;_opnds[2] = op_src2;
12437     m2-&gt;_opnds[0] = op_crx;
12438 
12439     // registers for new nodes
12440     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12441     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12442 
12443     // Insert new nodes.
12444     nodes-&gt;push(m1);
12445     nodes-&gt;push(m2);
12446   %}
12447 %}
12448 
12449 // Compare double, generate -1,0,1
12450 instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{
12451   match(Set dst (CmpD3 src1 src2));
12452   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12453 
12454   expand %{
12455     flagsReg tmp1;
12456     cmpDUnordered_reg_reg(tmp1, src1, src2);
12457     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12458   %}
12459 %}
12460 
12461 // Compare char
12462 instruct cmprb_Digit_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12463   match(Set dst (Digit src1));
12464   effect(TEMP src2, TEMP crx);
12465   ins_cost(3 * DEFAULT_COST);
12466 
12467   format %{ &quot;LI      $src2, 0x3930\n\t&quot;
12468             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12469             &quot;SETB    $dst, $crx&quot; %}
12470   size(12);
12471   ins_encode %{
12472     // 0x30: 0, 0x39: 9
12473     __ li($src2$$Register, 0x3930);
12474     // compare src1 with ranges 0x30 to 0x39
12475     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12476     __ setb($dst$$Register, $crx$$CondRegister);
12477   %}
12478   ins_pipe(pipe_class_default);
12479 %}
12480 
12481 instruct cmprb_LowerCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12482   match(Set dst (LowerCase src1));
12483   effect(TEMP src2, TEMP crx);
12484   ins_cost(12 * DEFAULT_COST);
12485 
12486   format %{ &quot;LI      $src2, 0x7A61\n\t&quot;
12487             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12488             &quot;BGT     $crx, done\n\t&quot;
12489             &quot;LIS     $src2, (signed short)0xF6DF\n\t&quot;
12490             &quot;ORI     $src2, $src2, 0xFFF8\n\t&quot;
12491             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12492             &quot;BGT     $crx, done\n\t&quot;
12493             &quot;LIS     $src2, (signed short)0xAAB5\n\t&quot;
12494             &quot;ORI     $src2, $src2, 0xBABA\n\t&quot;
12495             &quot;INSRDI  $src2, $src2, 32, 0\n\t&quot;
12496             &quot;CMPEQB  $crx, 1, $src1, $src2\n&quot;
12497             &quot;done:\n\t&quot;
12498             &quot;SETB    $dst, $crx&quot; %}
12499 
12500   size(48);
12501   ins_encode %{
12502     Label done;
12503     // 0x61: a, 0x7A: z
12504     __ li($src2$$Register, 0x7A61);
12505     // compare src1 with ranges 0x61 to 0x7A
12506     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12507     __ bgt($crx$$CondRegister, done);
12508 
12509     // 0xDF: sharp s, 0xFF: y with diaeresis, 0xF7 is not the lower case
12510     __ lis($src2$$Register, (signed short)0xF6DF);
12511     __ ori($src2$$Register, $src2$$Register, 0xFFF8);
12512     // compare src1 with ranges 0xDF to 0xF6 and 0xF8 to 0xFF
12513     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12514     __ bgt($crx$$CondRegister, done);
12515 
12516     // 0xAA: feminine ordinal indicator
12517     // 0xB5: micro sign
12518     // 0xBA: masculine ordinal indicator
12519     __ lis($src2$$Register, (signed short)0xAAB5);
12520     __ ori($src2$$Register, $src2$$Register, 0xBABA);
12521     __ insrdi($src2$$Register, $src2$$Register, 32, 0);
12522     // compare src1 with 0xAA, 0xB5, and 0xBA
12523     __ cmpeqb($crx$$CondRegister, $src1$$Register, $src2$$Register);
12524 
12525     __ bind(done);
12526     __ setb($dst$$Register, $crx$$CondRegister);
12527   %}
12528   ins_pipe(pipe_class_default);
12529 %}
12530 
12531 instruct cmprb_UpperCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12532   match(Set dst (UpperCase src1));
12533   effect(TEMP src2, TEMP crx);
12534   ins_cost(7 * DEFAULT_COST);
12535 
12536   format %{ &quot;LI      $src2, 0x5A41\n\t&quot;
12537             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12538             &quot;BGT     $crx, done\n\t&quot;
12539             &quot;LIS     $src2, (signed short)0xD6C0\n\t&quot;
12540             &quot;ORI     $src2, $src2, 0xDED8\n\t&quot;
12541             &quot;CMPRB   $crx, 1, $src1, $src2\n&quot;
12542             &quot;done:\n\t&quot;
12543             &quot;SETB    $dst, $crx&quot; %}
12544 
12545   size(28);
12546   ins_encode %{
12547     Label done;
12548     // 0x41: A, 0x5A: Z
12549     __ li($src2$$Register, 0x5A41);
12550     // compare src1 with a range 0x41 to 0x5A
12551     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12552     __ bgt($crx$$CondRegister, done);
12553 
12554     // 0xC0: a with grave, 0xDE: thorn, 0xD7 is not the upper case
12555     __ lis($src2$$Register, (signed short)0xD6C0);
12556     __ ori($src2$$Register, $src2$$Register, 0xDED8);
12557     // compare src1 with ranges 0xC0 to 0xD6 and 0xD8 to 0xDE
12558     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12559 
12560     __ bind(done);
12561     __ setb($dst$$Register, $crx$$CondRegister);
12562   %}
12563   ins_pipe(pipe_class_default);
12564 %}
12565 
12566 instruct cmprb_Whitespace_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12567   match(Set dst (Whitespace src1));
12568   effect(TEMP src2, TEMP crx);
12569   ins_cost(4 * DEFAULT_COST);
12570 
12571   format %{ &quot;LI      $src2, 0x0D09\n\t&quot;
12572             &quot;ADDIS   $src2, 0x201C\n\t&quot;
12573             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12574             &quot;SETB    $dst, $crx&quot; %}
12575   size(16);
12576   ins_encode %{
12577     // 0x09 to 0x0D, 0x1C to 0x20
12578     __ li($src2$$Register, 0x0D09);
12579     __ addis($src2$$Register, $src2$$Register, 0x0201C);
12580     // compare src with ranges 0x09 to 0x0D and 0x1C to 0x20
12581     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12582     __ setb($dst$$Register, $crx$$CondRegister);
12583   %}
12584   ins_pipe(pipe_class_default);
12585 %}
12586 
12587 //----------Branches---------------------------------------------------------
12588 // Jump
12589 
12590 // Direct Branch.
12591 instruct branch(label labl) %{
12592   match(Goto);
12593   effect(USE labl);
12594   ins_cost(BRANCH_COST);
12595 
12596   format %{ &quot;B       $labl&quot; %}
12597   size(4);
12598   ins_encode %{
12599     // TODO: PPC port $archOpcode(ppc64Opcode_b);
12600      Label d;    // dummy
12601      __ bind(d);
12602      Label* p = $labl$$label;
12603      // `p&#39; is `NULL&#39; when this encoding class is used only to
12604      // determine the size of the encoded instruction.
12605      Label&amp; l = (NULL == p)? d : *(p);
12606      __ b(l);
12607   %}
12608   ins_pipe(pipe_class_default);
12609 %}
12610 
12611 // Conditional Near Branch
12612 instruct branchCon(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12613   // Same match rule as `branchConFar&#39;.
12614   match(If cmp crx);
12615   effect(USE lbl);
12616   ins_cost(BRANCH_COST);
12617 
12618   // If set to 1 this indicates that the current instruction is a
12619   // short variant of a long branch. This avoids using this
12620   // instruction in first-pass matching. It will then only be used in
12621   // the `Shorten_branches&#39; pass.
12622   ins_short_branch(1);
12623 
12624   format %{ &quot;B$cmp     $crx, $lbl&quot; %}
12625   size(4);
12626   ins_encode( enc_bc(crx, cmp, lbl) );
12627   ins_pipe(pipe_class_default);
12628 %}
12629 
12630 // This is for cases when the ppc64 `bc&#39; instruction does not
12631 // reach far enough. So we emit a far branch here, which is more
12632 // expensive.
12633 //
12634 // Conditional Far Branch
12635 instruct branchConFar(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12636   // Same match rule as `branchCon&#39;.
12637   match(If cmp crx);
12638   effect(USE crx, USE lbl);
12639   predicate(!false /* TODO: PPC port HB_Schedule*/);
12640   // Higher cost than `branchCon&#39;.
12641   ins_cost(5*BRANCH_COST);
12642 
12643   // This is not a short variant of a branch, but the long variant.
12644   ins_short_branch(0);
12645 
12646   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12647   size(8);
12648   ins_encode( enc_bc_far(crx, cmp, lbl) );
12649   ins_pipe(pipe_class_default);
12650 %}
12651 
12652 // Conditional Branch used with Power6 scheduler (can be far or short).
12653 instruct branchConSched(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12654   // Same match rule as `branchCon&#39;.
12655   match(If cmp crx);
12656   effect(USE crx, USE lbl);
12657   predicate(false /* TODO: PPC port HB_Schedule*/);
12658   // Higher cost than `branchCon&#39;.
12659   ins_cost(5*BRANCH_COST);
12660 
12661   // Actually size doesn&#39;t depend on alignment but on shortening.
12662   ins_variable_size_depending_on_alignment(true);
12663   // long variant.
12664   ins_short_branch(0);
12665 
12666   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12667   size(8); // worst case
12668   ins_encode( enc_bc_short_far(crx, cmp, lbl) );
12669   ins_pipe(pipe_class_default);
12670 %}
12671 
12672 instruct branchLoopEnd(cmpOp cmp, flagsRegSrc crx, label labl) %{
12673   match(CountedLoopEnd cmp crx);
12674   effect(USE labl);
12675   ins_cost(BRANCH_COST);
12676 
12677   // short variant.
12678   ins_short_branch(1);
12679 
12680   format %{ &quot;B$cmp     $crx, $labl \t// counted loop end&quot; %}
12681   size(4);
12682   ins_encode( enc_bc(crx, cmp, labl) );
12683   ins_pipe(pipe_class_default);
12684 %}
12685 
12686 instruct branchLoopEndFar(cmpOp cmp, flagsRegSrc crx, label labl) %{
12687   match(CountedLoopEnd cmp crx);
12688   effect(USE labl);
12689   predicate(!false /* TODO: PPC port HB_Schedule */);
12690   ins_cost(BRANCH_COST);
12691 
12692   // Long variant.
12693   ins_short_branch(0);
12694 
12695   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12696   size(8);
12697   ins_encode( enc_bc_far(crx, cmp, labl) );
12698   ins_pipe(pipe_class_default);
12699 %}
12700 
12701 // Conditional Branch used with Power6 scheduler (can be far or short).
12702 instruct branchLoopEndSched(cmpOp cmp, flagsRegSrc crx, label labl) %{
12703   match(CountedLoopEnd cmp crx);
12704   effect(USE labl);
12705   predicate(false /* TODO: PPC port HB_Schedule */);
12706   // Higher cost than `branchCon&#39;.
12707   ins_cost(5*BRANCH_COST);
12708 
12709   // Actually size doesn&#39;t depend on alignment but on shortening.
12710   ins_variable_size_depending_on_alignment(true);
12711   // Long variant.
12712   ins_short_branch(0);
12713 
12714   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12715   size(8); // worst case
12716   ins_encode( enc_bc_short_far(crx, cmp, labl) );
12717   ins_pipe(pipe_class_default);
12718 %}
12719 
12720 // ============================================================================
12721 // Java runtime operations, intrinsics and other complex operations.
12722 
12723 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
12724 // array for an instance of the superklass. Set a hidden internal cache on a
12725 // hit (cache is checked with exposed code in gen_subtype_check()). Return
12726 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
12727 //
12728 // GL TODO: Improve this.
12729 // - result should not be a TEMP
12730 // - Add match rule as on sparc avoiding additional Cmp.
12731 instruct partialSubtypeCheck(iRegPdst result, iRegP_N2P subklass, iRegP_N2P superklass,
12732                              iRegPdst tmp_klass, iRegPdst tmp_arrayptr) %{
12733   match(Set result (PartialSubtypeCheck subklass superklass));
12734   effect(TEMP_DEF result, TEMP tmp_klass, TEMP tmp_arrayptr);
12735   ins_cost(DEFAULT_COST*10);
12736 
12737   format %{ &quot;PartialSubtypeCheck $result = ($subklass instanceOf $superklass) tmp: $tmp_klass, $tmp_arrayptr&quot; %}
12738   ins_encode %{
12739     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12740     __ check_klass_subtype_slow_path($subklass$$Register, $superklass$$Register, $tmp_arrayptr$$Register,
12741                                      $tmp_klass$$Register, NULL, $result$$Register);
12742   %}
12743   ins_pipe(pipe_class_default);
12744 %}
12745 
12746 // inlined locking and unlocking
12747 
12748 instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{
12749   match(Set crx (FastLock oop box));
12750   effect(TEMP tmp1, TEMP tmp2);
12751   predicate(!Compile::current()-&gt;use_rtm());
12752 
12753   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12754   ins_encode %{
12755     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12756     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12757                                  $tmp1$$Register, $tmp2$$Register, /*tmp3*/ R0,
12758                                  UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
12759     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12760     // The compiler generates a branch to the runtime call to
12761     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12762   %}
12763   ins_pipe(pipe_class_compare);
12764 %}
12765 
12766 // Separate version for TM. Use bound register for box to enable USE_KILL.
12767 instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12768   match(Set crx (FastLock oop box));
12769   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);
12770   predicate(Compile::current()-&gt;use_rtm());
12771 
12772   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)&quot; %}
12773   ins_encode %{
12774     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12775     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12776                                  $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12777                                  /*Biased Locking*/ false,
12778                                  _rtm_counters, _stack_rtm_counters,
12779                                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12780                                  /*TM*/ true, ra_-&gt;C-&gt;profile_rtm());
12781     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12782     // The compiler generates a branch to the runtime call to
12783     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12784   %}
12785   ins_pipe(pipe_class_compare);
12786 %}
12787 
12788 instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12789   match(Set crx (FastUnlock oop box));
12790   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12791   predicate(!Compile::current()-&gt;use_rtm());
12792 
12793   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12794   ins_encode %{
12795     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12796     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12797                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12798                                    UseBiasedLocking &amp;&amp; !UseOptoBiasInlining,
12799                                    false);
12800     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12801     // The compiler generates a branch to the runtime call to
12802     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12803   %}
12804   ins_pipe(pipe_class_compare);
12805 %}
12806 
12807 instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12808   match(Set crx (FastUnlock oop box));
12809   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12810   predicate(Compile::current()-&gt;use_rtm());
12811 
12812   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)&quot; %}
12813   ins_encode %{
12814     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12815     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12816                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12817                                    /*Biased Locking*/ false, /*TM*/ true);
12818     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12819     // The compiler generates a branch to the runtime call to
12820     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12821   %}
12822   ins_pipe(pipe_class_compare);
12823 %}
12824 
12825 // Align address.
12826 instruct align_addr(iRegPdst dst, iRegPsrc src, immLnegpow2 mask) %{
12827   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
12828 
12829   format %{ &quot;ANDDI   $dst, $src, $mask \t// next aligned address&quot; %}
12830   size(4);
12831   ins_encode %{
12832     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
12833     __ clrrdi($dst$$Register, $src$$Register, log2_long((jlong)-$mask$$constant));
12834   %}
12835   ins_pipe(pipe_class_default);
12836 %}
12837 
12838 // Array size computation.
12839 instruct array_size(iRegLdst dst, iRegPsrc end, iRegPsrc start) %{
12840   match(Set dst (SubL (CastP2X end) (CastP2X start)));
12841 
12842   format %{ &quot;SUB     $dst, $end, $start \t// array size in bytes&quot; %}
12843   size(4);
12844   ins_encode %{
12845     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
12846     __ subf($dst$$Register, $start$$Register, $end$$Register);
12847   %}
12848   ins_pipe(pipe_class_default);
12849 %}
12850 
12851 // Clear-array with constant short array length. The versions below can use dcbz with cnt &gt; 30.
12852 instruct inlineCallClearArrayShort(immLmax30 cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12853   match(Set dummy (ClearArray cnt base));
12854   effect(USE_KILL base, KILL ctr);
12855   ins_cost(2 * MEMORY_REF_COST);
12856 
12857   format %{ &quot;ClearArray $cnt, $base&quot; %}
12858   ins_encode %{
12859     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12860     __ clear_memory_constlen($base$$Register, $cnt$$constant, R0); // kills base, R0
12861   %}
12862   ins_pipe(pipe_class_default);
12863 %}
12864 
12865 // Clear-array with constant large array length.
12866 instruct inlineCallClearArrayLarge(immL cnt, rarg2RegP base, Universe dummy, iRegLdst tmp, regCTR ctr) %{
12867   match(Set dummy (ClearArray cnt base));
12868   effect(USE_KILL base, TEMP tmp, KILL ctr);
12869   ins_cost(3 * MEMORY_REF_COST);
12870 
12871   format %{ &quot;ClearArray $cnt, $base \t// KILL $tmp&quot; %}
12872   ins_encode %{
12873     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12874     __ clear_memory_doubleword($base$$Register, $tmp$$Register, R0, $cnt$$constant); // kills base, R0
12875   %}
12876   ins_pipe(pipe_class_default);
12877 %}
12878 
12879 // Clear-array with dynamic array length.
12880 instruct inlineCallClearArray(rarg1RegL cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12881   match(Set dummy (ClearArray cnt base));
12882   effect(USE_KILL cnt, USE_KILL base, KILL ctr);
12883   ins_cost(4 * MEMORY_REF_COST);
12884 
12885   format %{ &quot;ClearArray $cnt, $base&quot; %}
12886   ins_encode %{
12887     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12888     __ clear_memory_doubleword($base$$Register, $cnt$$Register, R0); // kills cnt, base, R0
12889   %}
12890   ins_pipe(pipe_class_default);
12891 %}
12892 
12893 instruct string_compareL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12894                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12895   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12896   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12897   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12898   ins_cost(300);
12899   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12900   ins_encode %{
12901     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12902     __ string_compare($str1$$Register, $str2$$Register,
12903                       $cnt1$$Register, $cnt2$$Register,
12904                       $tmp$$Register,
12905                       $result$$Register, StrIntrinsicNode::LL);
12906   %}
12907   ins_pipe(pipe_class_default);
12908 %}
12909 
12910 instruct string_compareU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12911                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12912   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12913   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12914   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12915   ins_cost(300);
12916   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12917   ins_encode %{
12918     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12919     __ string_compare($str1$$Register, $str2$$Register,
12920                       $cnt1$$Register, $cnt2$$Register,
12921                       $tmp$$Register,
12922                       $result$$Register, StrIntrinsicNode::UU);
12923   %}
12924   ins_pipe(pipe_class_default);
12925 %}
12926 
12927 instruct string_compareLU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12928                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12929   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
12930   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12931   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12932   ins_cost(300);
12933   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12934   ins_encode %{
12935     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12936     __ string_compare($str1$$Register, $str2$$Register,
12937                       $cnt1$$Register, $cnt2$$Register,
12938                       $tmp$$Register,
12939                       $result$$Register, StrIntrinsicNode::LU);
12940   %}
12941   ins_pipe(pipe_class_default);
12942 %}
12943 
12944 instruct string_compareUL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12945                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12946   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12947   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12948   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12949   ins_cost(300);
12950   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12951   ins_encode %{
12952     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12953     __ string_compare($str2$$Register, $str1$$Register,
12954                       $cnt2$$Register, $cnt1$$Register,
12955                       $tmp$$Register,
12956                       $result$$Register, StrIntrinsicNode::UL);
12957   %}
12958   ins_pipe(pipe_class_default);
12959 %}
12960 
12961 instruct string_equalsL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12962                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12963   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12964   match(Set result (StrEquals (Binary str1 str2) cnt));
12965   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12966   ins_cost(300);
12967   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12968   ins_encode %{
12969     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12970     __ array_equals(false, $str1$$Register, $str2$$Register,
12971                     $cnt$$Register, $tmp$$Register,
12972                     $result$$Register, true /* byte */);
12973   %}
12974   ins_pipe(pipe_class_default);
12975 %}
12976 
12977 instruct string_equalsU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12978                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12979   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12980   match(Set result (StrEquals (Binary str1 str2) cnt));
12981   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12982   ins_cost(300);
12983   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12984   ins_encode %{
12985     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12986     __ array_equals(false, $str1$$Register, $str2$$Register,
12987                     $cnt$$Register, $tmp$$Register,
12988                     $result$$Register, false /* byte */);
12989   %}
12990   ins_pipe(pipe_class_default);
12991 %}
12992 
12993 instruct array_equalsB(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
12994                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
12995   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12996   match(Set result (AryEq ary1 ary2));
12997   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
12998   ins_cost(300);
12999   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
13000   ins_encode %{
13001     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13002     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13003                     $tmp1$$Register, $tmp2$$Register,
13004                     $result$$Register, true /* byte */);
13005   %}
13006   ins_pipe(pipe_class_default);
13007 %}
13008 
13009 instruct array_equalsC(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
13010                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
13011   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13012   match(Set result (AryEq ary1 ary2));
13013   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
13014   ins_cost(300);
13015   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
13016   ins_encode %{
13017     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13018     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13019                     $tmp1$$Register, $tmp2$$Register,
13020                     $result$$Register, false /* byte */);
13021   %}
13022   ins_pipe(pipe_class_default);
13023 %}
13024 
13025 instruct indexOf_imm1_char_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13026                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13027                              iRegIdst tmp1, iRegIdst tmp2,
13028                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13029   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13030   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13031   // Required for EA: check if it is still a type_array.
13032   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13033   ins_cost(150);
13034 
13035   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13036             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13037 
13038   ins_encode %{
13039     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13040     immPOper *needleOper = (immPOper *)$needleImm;
13041     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13042     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13043     jchar chr;
13044 #ifdef VM_LITTLE_ENDIAN
13045     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13046            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13047 #else
13048     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13049            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13050 #endif
13051     __ string_indexof_char($result$$Register,
13052                            $haystack$$Register, $haycnt$$Register,
13053                            R0, chr,
13054                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13055   %}
13056   ins_pipe(pipe_class_compare);
13057 %}
13058 
13059 instruct indexOf_imm1_char_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13060                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13061                              iRegIdst tmp1, iRegIdst tmp2,
13062                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13063   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13064   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13065   // Required for EA: check if it is still a type_array.
13066   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13067   ins_cost(150);
13068 
13069   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13070             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13071 
13072   ins_encode %{
13073     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13074     immPOper *needleOper = (immPOper *)$needleImm;
13075     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13076     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13077     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13078     __ string_indexof_char($result$$Register,
13079                            $haystack$$Register, $haycnt$$Register,
13080                            R0, chr,
13081                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13082   %}
13083   ins_pipe(pipe_class_compare);
13084 %}
13085 
13086 instruct indexOf_imm1_char_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13087                               immP needleImm, immL offsetImm, immI_1 needlecntImm,
13088                               iRegIdst tmp1, iRegIdst tmp2,
13089                               flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13090   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13091   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13092   // Required for EA: check if it is still a type_array.
13093   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13094   ins_cost(150);
13095 
13096   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13097             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13098 
13099   ins_encode %{
13100     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13101     immPOper *needleOper = (immPOper *)$needleImm;
13102     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13103     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13104     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13105     __ string_indexof_char($result$$Register,
13106                            $haystack$$Register, $haycnt$$Register,
13107                            R0, chr,
13108                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13109   %}
13110   ins_pipe(pipe_class_compare);
13111 %}
13112 
13113 instruct indexOf_imm1_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13114                         rscratch2RegP needle, immI_1 needlecntImm,
13115                         iRegIdst tmp1, iRegIdst tmp2,
13116                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13117   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13118   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13119   // Required for EA: check if it is still a type_array.
13120   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13121             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13122             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13123   ins_cost(180);
13124 
13125   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13126             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13127   ins_encode %{
13128     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13129     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13130     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13131     guarantee(needle_values, &quot;sanity&quot;);
13132     jchar chr;
13133 #ifdef VM_LITTLE_ENDIAN
13134     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13135            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13136 #else
13137     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13138            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13139 #endif
13140     __ string_indexof_char($result$$Register,
13141                            $haystack$$Register, $haycnt$$Register,
13142                            R0, chr,
13143                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13144   %}
13145   ins_pipe(pipe_class_compare);
13146 %}
13147 
13148 instruct indexOf_imm1_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13149                         rscratch2RegP needle, immI_1 needlecntImm,
13150                         iRegIdst tmp1, iRegIdst tmp2,
13151                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13152   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13153   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13154   // Required for EA: check if it is still a type_array.
13155   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13156             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13157             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13158   ins_cost(180);
13159 
13160   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13161             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13162   ins_encode %{
13163     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13164     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13165     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13166     guarantee(needle_values, &quot;sanity&quot;);
13167     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13168     __ string_indexof_char($result$$Register,
13169                            $haystack$$Register, $haycnt$$Register,
13170                            R0, chr,
13171                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13172   %}
13173   ins_pipe(pipe_class_compare);
13174 %}
13175 
13176 instruct indexOf_imm1_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13177                          rscratch2RegP needle, immI_1 needlecntImm,
13178                          iRegIdst tmp1, iRegIdst tmp2,
13179                          flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13180   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13181   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13182   // Required for EA: check if it is still a type_array.
13183   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13184             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13185             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13186   ins_cost(180);
13187 
13188   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13189             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13190   ins_encode %{
13191     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13192     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13193     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13194     guarantee(needle_values, &quot;sanity&quot;);
13195     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13196     __ string_indexof_char($result$$Register,
13197                            $haystack$$Register, $haycnt$$Register,
13198                            R0, chr,
13199                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13200   %}
13201   ins_pipe(pipe_class_compare);
13202 %}
13203 
13204 instruct indexOfChar_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13205                        iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,
13206                        flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13207   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
13208   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13209   ins_cost(180);
13210 
13211   format %{ &quot;String IndexOfChar $haystack[0..$haycnt], $ch&quot;
13212             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13213   ins_encode %{
13214     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13215     __ string_indexof_char($result$$Register,
13216                            $haystack$$Register, $haycnt$$Register,
13217                            $ch$$Register, 0 /* this is not used if the character is already in a register */,
13218                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13219   %}
13220   ins_pipe(pipe_class_compare);
13221 %}
13222 
13223 instruct indexOf_imm_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13224                        iRegPsrc needle, uimmI15 needlecntImm,
13225                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13226                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13227   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13228   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13229          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13230   // Required for EA: check if it is still a type_array.
13231   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13232             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13233             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13234   ins_cost(250);
13235 
13236   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13237             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13238   ins_encode %{
13239     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13240     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13241     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13242 
13243     __ string_indexof($result$$Register,
13244                       $haystack$$Register, $haycnt$$Register,
13245                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13246                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13247   %}
13248   ins_pipe(pipe_class_compare);
13249 %}
13250 
13251 instruct indexOf_imm_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13252                        iRegPsrc needle, uimmI15 needlecntImm,
13253                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13254                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13255   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13256   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13257          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13258   // Required for EA: check if it is still a type_array.
13259   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13260             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13261             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13262   ins_cost(250);
13263 
13264   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13265             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13266   ins_encode %{
13267     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13268     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13269     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13270 
13271     __ string_indexof($result$$Register,
13272                       $haystack$$Register, $haycnt$$Register,
13273                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13274                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13275   %}
13276   ins_pipe(pipe_class_compare);
13277 %}
13278 
13279 instruct indexOf_imm_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13280                         iRegPsrc needle, uimmI15 needlecntImm,
13281                         iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13282                         flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13283   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13284   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13285          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13286   // Required for EA: check if it is still a type_array.
13287   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13288             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13289             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13290   ins_cost(250);
13291 
13292   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13293             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13294   ins_encode %{
13295     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13296     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13297     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13298 
13299     __ string_indexof($result$$Register,
13300                       $haystack$$Register, $haycnt$$Register,
13301                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13302                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13303   %}
13304   ins_pipe(pipe_class_compare);
13305 %}
13306 
13307 instruct indexOf_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13308                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13309                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13310   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13311   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13312          TEMP_DEF result,
13313          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13314   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13315   ins_cost(300);
13316 
13317   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13318              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13319   ins_encode %{
13320     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13321     __ string_indexof($result$$Register,
13322                       $haystack$$Register, $haycnt$$Register,
13323                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13324                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13325   %}
13326   ins_pipe(pipe_class_compare);
13327 %}
13328 
13329 instruct indexOf_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13330                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13331                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13332   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13333   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13334          TEMP_DEF result,
13335          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13336   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13337   ins_cost(300);
13338 
13339   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13340              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13341   ins_encode %{
13342     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13343     __ string_indexof($result$$Register,
13344                       $haystack$$Register, $haycnt$$Register,
13345                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13346                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13347   %}
13348   ins_pipe(pipe_class_compare);
13349 %}
13350 
13351 instruct indexOf_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13352                     iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13353                     flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13354   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13355   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13356          TEMP_DEF result,
13357          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13358   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13359   ins_cost(300);
13360 
13361   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13362              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13363   ins_encode %{
13364     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13365     __ string_indexof($result$$Register,
13366                       $haystack$$Register, $haycnt$$Register,
13367                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13368                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13369   %}
13370   ins_pipe(pipe_class_compare);
13371 %}
13372 
13373 // char[] to byte[] compression
13374 instruct string_compress(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13375                          iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13376   match(Set result (StrCompressedCopy src (Binary dst len)));
13377   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13378          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13379   ins_cost(300);
13380   format %{ &quot;String Compress $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13381   ins_encode %{
13382     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13383     Label Lskip, Ldone;
13384     __ li($result$$Register, 0);
13385     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13386                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);
13387     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13388     __ beq(CCR0, Lskip);
13389     __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);
13390     __ bind(Lskip);
13391     __ mr($result$$Register, $len$$Register);
13392     __ bind(Ldone);
13393   %}
13394   ins_pipe(pipe_class_default);
13395 %}
13396 
13397 // byte[] to char[] inflation
13398 instruct string_inflate(Universe dummy, rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegLdst tmp1,
13399                         iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13400   match(Set dummy (StrInflatedCopy src (Binary dst len)));
13401   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13402   ins_cost(300);
13403   format %{ &quot;String Inflate $src,$dst,$len \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13404   ins_encode %{
13405     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13406     Label Ldone;
13407     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13408                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register);
13409     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13410     __ beq(CCR0, Ldone);
13411     __ string_inflate($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register);
13412     __ bind(Ldone);
13413   %}
13414   ins_pipe(pipe_class_default);
13415 %}
13416 
13417 // StringCoding.java intrinsics
13418 instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,
13419                        regCTR ctr, flagsRegCR0 cr0)
13420 %{
13421   match(Set result (HasNegatives ary1 len));
13422   effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);
13423   ins_cost(300);
13424   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result \t// KILL $tmp1, $tmp2&quot; %}
13425   ins_encode %{
13426     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13427     __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,
13428                      $tmp1$$Register, $tmp2$$Register);
13429   %}
13430   ins_pipe(pipe_class_default);
13431 %}
13432 
13433 // encode char[] to byte[] in ISO_8859_1
13434 instruct encode_iso_array(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13435                           iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13436   match(Set result (EncodeISOArray src (Binary dst len)));
13437   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13438          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13439   ins_cost(300);
13440   format %{ &quot;Encode array $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13441   ins_encode %{
13442     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13443     Label Lslow, Lfailure1, Lfailure2, Ldone;
13444     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13445                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Lfailure1);
13446     __ rldicl_($result$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13447     __ beq(CCR0, Ldone);
13448     __ bind(Lslow);
13449     __ string_compress($src$$Register, $dst$$Register, $result$$Register, $tmp2$$Register, Lfailure2);
13450     __ li($result$$Register, 0);
13451     __ b(Ldone);
13452 
13453     __ bind(Lfailure1);
13454     __ mr($result$$Register, $len$$Register);
13455     __ mfctr($tmp1$$Register);
13456     __ rldimi_($result$$Register, $tmp1$$Register, 3, 0); // Remaining characters.
13457     __ beq(CCR0, Ldone);
13458     __ b(Lslow);
13459 
13460     __ bind(Lfailure2);
13461     __ mfctr($result$$Register); // Remaining characters.
13462 
13463     __ bind(Ldone);
13464     __ subf($result$$Register, $result$$Register, $len$$Register);
13465   %}
13466   ins_pipe(pipe_class_default);
13467 %}
13468 
13469 
13470 //---------- Min/Max Instructions ---------------------------------------------
13471 
13472 instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13473   match(Set dst (MinI src1 src2));
13474   ins_cost(DEFAULT_COST*6);
13475 
13476   expand %{
13477     iRegLdst src1s;
13478     iRegLdst src2s;
13479     iRegLdst diff;
13480     iRegLdst sm;
13481     iRegLdst doz; // difference or zero
13482     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13483     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13484     subL_reg_reg(diff, src2s, src1s);
13485     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13486     signmask64L_regL(sm, diff);
13487     andL_reg_reg(doz, diff, sm); // &lt;=0
13488     addI_regL_regL(dst, doz, src1s);
13489   %}
13490 %}
13491 
13492 instruct minI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13493   match(Set dst (MinI src1 src2));
13494   effect(KILL cr0);
13495   predicate(VM_Version::has_isel());
13496   ins_cost(DEFAULT_COST*2);
13497 
13498   ins_encode %{
13499     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13500     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13501     __ isel($dst$$Register, CCR0, Assembler::less, /*invert*/false, $src1$$Register, $src2$$Register);
13502   %}
13503   ins_pipe(pipe_class_default);
13504 %}
13505 
13506 instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13507   match(Set dst (MaxI src1 src2));
13508   ins_cost(DEFAULT_COST*6);
13509 
13510   expand %{
13511     iRegLdst src1s;
13512     iRegLdst src2s;
13513     iRegLdst diff;
13514     iRegLdst sm;
13515     iRegLdst doz; // difference or zero
13516     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13517     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13518     subL_reg_reg(diff, src2s, src1s);
13519     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13520     signmask64L_regL(sm, diff);
13521     andcL_reg_reg(doz, diff, sm); // &gt;=0
13522     addI_regL_regL(dst, doz, src1s);
13523   %}
13524 %}
13525 
13526 instruct maxI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13527   match(Set dst (MaxI src1 src2));
13528   effect(KILL cr0);
13529   predicate(VM_Version::has_isel());
13530   ins_cost(DEFAULT_COST*2);
13531 
13532   ins_encode %{
13533     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13534     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13535     __ isel($dst$$Register, CCR0, Assembler::greater, /*invert*/false, $src1$$Register, $src2$$Register);
13536   %}
13537   ins_pipe(pipe_class_default);
13538 %}
13539 
13540 //---------- Population Count Instructions ------------------------------------
13541 
13542 // Popcnt for Power7.
13543 instruct popCountI(iRegIdst dst, iRegIsrc src) %{
13544   match(Set dst (PopCountI src));
13545   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13546   ins_cost(DEFAULT_COST);
13547 
13548   format %{ &quot;POPCNTW $dst, $src&quot; %}
13549   size(4);
13550   ins_encode %{
13551     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13552     __ popcntw($dst$$Register, $src$$Register);
13553   %}
13554   ins_pipe(pipe_class_default);
13555 %}
13556 
13557 // Popcnt for Power7.
13558 instruct popCountL(iRegIdst dst, iRegLsrc src) %{
13559   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13560   match(Set dst (PopCountL src));
13561   ins_cost(DEFAULT_COST);
13562 
13563   format %{ &quot;POPCNTD $dst, $src&quot; %}
13564   size(4);
13565   ins_encode %{
13566     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13567     __ popcntd($dst$$Register, $src$$Register);
13568   %}
13569   ins_pipe(pipe_class_default);
13570 %}
13571 
13572 instruct countLeadingZerosI(iRegIdst dst, iRegIsrc src) %{
13573   match(Set dst (CountLeadingZerosI src));
13574   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13575   ins_cost(DEFAULT_COST);
13576 
13577   format %{ &quot;CNTLZW  $dst, $src&quot; %}
13578   size(4);
13579   ins_encode %{
13580     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzw);
13581     __ cntlzw($dst$$Register, $src$$Register);
13582   %}
13583   ins_pipe(pipe_class_default);
13584 %}
13585 
13586 instruct countLeadingZerosL(iRegIdst dst, iRegLsrc src) %{
13587   match(Set dst (CountLeadingZerosL src));
13588   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13589   ins_cost(DEFAULT_COST);
13590 
13591   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13592   size(4);
13593   ins_encode %{
13594     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13595     __ cntlzd($dst$$Register, $src$$Register);
13596   %}
13597   ins_pipe(pipe_class_default);
13598 %}
13599 
13600 instruct countLeadingZerosP(iRegIdst dst, iRegPsrc src) %{
13601   // no match-rule, false predicate
13602   effect(DEF dst, USE src);
13603   predicate(false);
13604 
13605   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13606   size(4);
13607   ins_encode %{
13608     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13609     __ cntlzd($dst$$Register, $src$$Register);
13610   %}
13611   ins_pipe(pipe_class_default);
13612 %}
13613 
13614 instruct countTrailingZerosI_Ex(iRegIdst dst, iRegIsrc src) %{
13615   match(Set dst (CountTrailingZerosI src));
13616   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13617   ins_cost(DEFAULT_COST);
13618 
13619   expand %{
13620     immI16 imm1 %{ (int)-1 %}
13621     immI16 imm2 %{ (int)32 %}
13622     immI_minus1 m1 %{ -1 %}
13623     iRegIdst tmpI1;
13624     iRegIdst tmpI2;
13625     iRegIdst tmpI3;
13626     addI_reg_imm16(tmpI1, src, imm1);
13627     andcI_reg_reg(tmpI2, src, m1, tmpI1);
13628     countLeadingZerosI(tmpI3, tmpI2);
13629     subI_imm16_reg(dst, imm2, tmpI3);
13630   %}
13631 %}
13632 
13633 instruct countTrailingZerosI_cnttzw(iRegIdst dst, iRegIsrc src) %{
13634   match(Set dst (CountTrailingZerosI src));
13635   predicate(UseCountTrailingZerosInstructionsPPC64);
13636   ins_cost(DEFAULT_COST);
13637 
13638   format %{ &quot;CNTTZW  $dst, $src&quot; %}
13639   size(4);
13640   ins_encode %{
13641     __ cnttzw($dst$$Register, $src$$Register);
13642   %}
13643   ins_pipe(pipe_class_default);
13644 %}
13645 
13646 instruct countTrailingZerosL_Ex(iRegIdst dst, iRegLsrc src) %{
13647   match(Set dst (CountTrailingZerosL src));
13648   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13649   ins_cost(DEFAULT_COST);
13650 
13651   expand %{
13652     immL16 imm1 %{ (long)-1 %}
13653     immI16 imm2 %{ (int)64 %}
13654     iRegLdst tmpL1;
13655     iRegLdst tmpL2;
13656     iRegIdst tmpL3;
13657     addL_reg_imm16(tmpL1, src, imm1);
13658     andcL_reg_reg(tmpL2, tmpL1, src);
13659     countLeadingZerosL(tmpL3, tmpL2);
13660     subI_imm16_reg(dst, imm2, tmpL3);
13661  %}
13662 %}
13663 
13664 instruct countTrailingZerosL_cnttzd(iRegIdst dst, iRegLsrc src) %{
13665   match(Set dst (CountTrailingZerosL src));
13666   predicate(UseCountTrailingZerosInstructionsPPC64);
13667   ins_cost(DEFAULT_COST);
13668 
13669   format %{ &quot;CNTTZD  $dst, $src&quot; %}
13670   size(4);
13671   ins_encode %{
13672     __ cnttzd($dst$$Register, $src$$Register);
13673   %}
13674   ins_pipe(pipe_class_default);
13675 %}
13676 
13677 // Expand nodes for byte_reverse_int.
13678 instruct insrwi_a(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13679   effect(DEF dst, USE src, USE pos, USE shift);
13680   predicate(false);
13681 
13682   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13683   size(4);
13684   ins_encode %{
13685     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13686     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13687   %}
13688   ins_pipe(pipe_class_default);
13689 %}
13690 
13691 // As insrwi_a, but with USE_DEF.
13692 instruct insrwi(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13693   effect(USE_DEF dst, USE src, USE pos, USE shift);
13694   predicate(false);
13695 
13696   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13697   size(4);
13698   ins_encode %{
13699     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13700     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13701   %}
13702   ins_pipe(pipe_class_default);
13703 %}
13704 
13705 // Just slightly faster than java implementation.
13706 instruct bytes_reverse_int_Ex(iRegIdst dst, iRegIsrc src) %{
13707   match(Set dst (ReverseBytesI src));
13708   ins_cost(7*DEFAULT_COST);
13709 
13710   expand %{
13711     immI16 imm24 %{ (int) 24 %}
13712     immI16 imm16 %{ (int) 16 %}
13713     immI16  imm8 %{ (int)  8 %}
13714     immI16  imm4 %{ (int)  4 %}
13715     immI16  imm0 %{ (int)  0 %}
13716     iRegLdst tmpI1;
13717     iRegLdst tmpI2;
13718     iRegLdst tmpI3;
13719 
13720     urShiftI_reg_imm(tmpI1, src, imm24);
13721     insrwi_a(dst, tmpI1, imm24, imm8);
13722     urShiftI_reg_imm(tmpI2, src, imm16);
13723     insrwi(dst, tmpI2, imm8, imm16);
13724     urShiftI_reg_imm(tmpI3, src, imm8);
13725     insrwi(dst, tmpI3, imm8, imm8);
13726     insrwi(dst, src, imm0, imm8);
13727   %}
13728 %}
13729 
13730 instruct bytes_reverse_int_vec(iRegIdst dst, iRegIsrc src, vecX tmpV) %{
13731   match(Set dst (ReverseBytesI src));
13732   predicate(UseVectorByteReverseInstructionsPPC64);
13733   effect(TEMP tmpV);
13734   ins_cost(DEFAULT_COST*3);
13735   size(12);
13736   format %{ &quot;MTVSRWZ $tmpV, $src\n&quot;
13737             &quot;\tXXBRW   $tmpV, $tmpV\n&quot;
13738             &quot;\tMFVSRWZ $dst, $tmpV&quot; %}
13739 
13740   ins_encode %{
13741     __ mtvsrwz($tmpV$$VectorSRegister, $src$$Register);
13742     __ xxbrw($tmpV$$VectorSRegister, $tmpV$$VectorSRegister);
13743     __ mfvsrwz($dst$$Register, $tmpV$$VectorSRegister);
13744   %}
13745   ins_pipe(pipe_class_default);
13746 %}
13747 
13748 instruct bytes_reverse_long_Ex(iRegLdst dst, iRegLsrc src) %{
13749   match(Set dst (ReverseBytesL src));
13750   ins_cost(15*DEFAULT_COST);
13751 
13752   expand %{
13753     immI16 imm56 %{ (int) 56 %}
13754     immI16 imm48 %{ (int) 48 %}
13755     immI16 imm40 %{ (int) 40 %}
13756     immI16 imm32 %{ (int) 32 %}
13757     immI16 imm24 %{ (int) 24 %}
13758     immI16 imm16 %{ (int) 16 %}
13759     immI16  imm8 %{ (int)  8 %}
13760     immI16  imm0 %{ (int)  0 %}
13761     iRegLdst tmpL1;
13762     iRegLdst tmpL2;
13763     iRegLdst tmpL3;
13764     iRegLdst tmpL4;
13765     iRegLdst tmpL5;
13766     iRegLdst tmpL6;
13767 
13768                                         // src   : |a|b|c|d|e|f|g|h|
13769     rldicl(tmpL1, src, imm8, imm24);    // tmpL1 : | | | |e|f|g|h|a|
13770     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |a| | | |e|
13771     rldicl(tmpL3, tmpL2, imm32, imm0);  // tmpL3 : | | | |e| | | |a|
13772     rldicl(tmpL1, src, imm16, imm24);   // tmpL1 : | | | |f|g|h|a|b|
13773     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |b| | | |f|
13774     rldicl(tmpL4, tmpL2, imm40, imm0);  // tmpL4 : | | |f| | | |b| |
13775     orL_reg_reg(tmpL5, tmpL3, tmpL4);   // tmpL5 : | | |f|e| | |b|a|
13776     rldicl(tmpL1, src, imm24, imm24);   // tmpL1 : | | | |g|h|a|b|c|
13777     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |c| | | |g|
13778     rldicl(tmpL3, tmpL2, imm48, imm0);  // tmpL3 : | |g| | | |c| | |
13779     rldicl(tmpL1, src, imm32, imm24);   // tmpL1 : | | | |h|a|b|c|d|
13780     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |d| | | |h|
13781     rldicl(tmpL4, tmpL2, imm56, imm0);  // tmpL4 : |h| | | |d| | | |
13782     orL_reg_reg(tmpL6, tmpL3, tmpL4);   // tmpL6 : |h|g| | |d|c| | |
13783     orL_reg_reg(dst, tmpL5, tmpL6);     // dst   : |h|g|f|e|d|c|b|a|
13784   %}
13785 %}
13786 
13787 instruct bytes_reverse_long_vec(iRegLdst dst, iRegLsrc src, vecX tmpV) %{
13788   match(Set dst (ReverseBytesL src));
13789   predicate(UseVectorByteReverseInstructionsPPC64);
13790   effect(TEMP tmpV);
13791   ins_cost(DEFAULT_COST*3);
13792   size(12);
13793   format %{ &quot;MTVSRD  $tmpV, $src\n&quot;
13794             &quot;\tXXBRD   $tmpV, $tmpV\n&quot;
13795             &quot;\tMFVSRD  $dst, $tmpV&quot; %}
13796 
13797   ins_encode %{
13798     __ mtvsrd($tmpV$$VectorSRegister, $src$$Register);
13799     __ xxbrd($tmpV$$VectorSRegister, $tmpV$$VectorSRegister);
13800     __ mfvsrd($dst$$Register, $tmpV$$VectorSRegister);
13801   %}
13802   ins_pipe(pipe_class_default);
13803 %}
13804 
13805 instruct bytes_reverse_ushort_Ex(iRegIdst dst, iRegIsrc src) %{
13806   match(Set dst (ReverseBytesUS src));
13807   ins_cost(2*DEFAULT_COST);
13808 
13809   expand %{
13810     immI16  imm16 %{ (int) 16 %}
13811     immI16   imm8 %{ (int)  8 %}
13812 
13813     urShiftI_reg_imm(dst, src, imm8);
13814     insrwi(dst, src, imm16, imm8);
13815   %}
13816 %}
13817 
13818 instruct bytes_reverse_short_Ex(iRegIdst dst, iRegIsrc src) %{
13819   match(Set dst (ReverseBytesS src));
13820   ins_cost(3*DEFAULT_COST);
13821 
13822   expand %{
13823     immI16  imm16 %{ (int) 16 %}
13824     immI16   imm8 %{ (int)  8 %}
13825     iRegLdst tmpI1;
13826 
13827     urShiftI_reg_imm(tmpI1, src, imm8);
13828     insrwi(tmpI1, src, imm16, imm8);
13829     extsh(dst, tmpI1);
13830   %}
13831 %}
13832 
13833 // Load Integer reversed byte order
13834 instruct loadI_reversed(iRegIdst dst, indirect mem) %{
13835   match(Set dst (ReverseBytesI (LoadI mem)));
13836   predicate(n-&gt;in(1)-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n-&gt;in(1)));
13837   ins_cost(MEMORY_REF_COST);
13838 
13839   size(4);
13840   ins_encode %{
13841     __ lwbrx($dst$$Register, $mem$$Register);
13842   %}
13843   ins_pipe(pipe_class_default);
13844 %}
13845 
13846 instruct loadI_reversed_acquire(iRegIdst dst, indirect mem) %{
13847   match(Set dst (ReverseBytesI (LoadI mem)));
13848   ins_cost(2 * MEMORY_REF_COST);
13849 
13850   size(12);
13851   ins_encode %{
13852     __ lwbrx($dst$$Register, $mem$$Register);
13853     __ twi_0($dst$$Register);
13854     __ isync();
13855   %}
13856   ins_pipe(pipe_class_default);
13857 %}
13858 
13859 // Load Long - aligned and reversed
13860 instruct loadL_reversed(iRegLdst dst, indirect mem) %{
13861   match(Set dst (ReverseBytesL (LoadL mem)));
13862   predicate(VM_Version::has_ldbrx() &amp;&amp; (n-&gt;in(1)-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n-&gt;in(1))));
13863   ins_cost(MEMORY_REF_COST);
13864 
13865   size(4);
13866   ins_encode %{
13867     __ ldbrx($dst$$Register, $mem$$Register);
13868   %}
13869   ins_pipe(pipe_class_default);
13870 %}
13871 
13872 instruct loadL_reversed_acquire(iRegLdst dst, indirect mem) %{
13873   match(Set dst (ReverseBytesL (LoadL mem)));
13874   predicate(VM_Version::has_ldbrx());
13875   ins_cost(2 * MEMORY_REF_COST);
13876 
13877   size(12);
13878   ins_encode %{
13879     __ ldbrx($dst$$Register, $mem$$Register);
13880     __ twi_0($dst$$Register);
13881     __ isync();
13882   %}
13883   ins_pipe(pipe_class_default);
13884 %}
13885 
13886 // Load unsigned short / char reversed byte order
13887 instruct loadUS_reversed(iRegIdst dst, indirect mem) %{
13888   match(Set dst (ReverseBytesUS (LoadUS mem)));
13889   predicate(n-&gt;in(1)-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n-&gt;in(1)));
13890   ins_cost(MEMORY_REF_COST);
13891 
13892   size(4);
13893   ins_encode %{
13894     __ lhbrx($dst$$Register, $mem$$Register);
13895   %}
13896   ins_pipe(pipe_class_default);
13897 %}
13898 
13899 instruct loadUS_reversed_acquire(iRegIdst dst, indirect mem) %{
13900   match(Set dst (ReverseBytesUS (LoadUS mem)));
13901   ins_cost(2 * MEMORY_REF_COST);
13902 
13903   size(12);
13904   ins_encode %{
13905     __ lhbrx($dst$$Register, $mem$$Register);
13906     __ twi_0($dst$$Register);
13907     __ isync();
13908   %}
13909   ins_pipe(pipe_class_default);
13910 %}
13911 
13912 // Load short reversed byte order
13913 instruct loadS_reversed(iRegIdst dst, indirect mem) %{
13914   match(Set dst (ReverseBytesS (LoadS mem)));
13915   predicate(n-&gt;in(1)-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n-&gt;in(1)));
13916   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
13917 
13918   size(8);
13919   ins_encode %{
13920     __ lhbrx($dst$$Register, $mem$$Register);
13921     __ extsh($dst$$Register, $dst$$Register);
13922   %}
13923   ins_pipe(pipe_class_default);
13924 %}
13925 
13926 instruct loadS_reversed_acquire(iRegIdst dst, indirect mem) %{
13927   match(Set dst (ReverseBytesS (LoadS mem)));
13928   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
13929 
13930   size(16);
13931   ins_encode %{
13932     __ lhbrx($dst$$Register, $mem$$Register);
13933     __ twi_0($dst$$Register);
13934     __ extsh($dst$$Register, $dst$$Register);
13935     __ isync();
13936   %}
13937   ins_pipe(pipe_class_default);
13938 %}
13939 
13940 // Store Integer reversed byte order
13941 instruct storeI_reversed(iRegIsrc src, indirect mem) %{
13942   match(Set mem (StoreI mem (ReverseBytesI src)));
13943   ins_cost(MEMORY_REF_COST);
13944 
13945   size(4);
13946   ins_encode %{
13947     __ stwbrx($src$$Register, $mem$$Register);
13948   %}
13949   ins_pipe(pipe_class_default);
13950 %}
13951 
13952 // Store Long reversed byte order
13953 instruct storeL_reversed(iRegLsrc src, indirect mem) %{
13954   match(Set mem (StoreL mem (ReverseBytesL src)));
13955   predicate(VM_Version::has_stdbrx());
13956   ins_cost(MEMORY_REF_COST);
13957 
13958   size(4);
13959   ins_encode %{
13960     __ stdbrx($src$$Register, $mem$$Register);
13961   %}
13962   ins_pipe(pipe_class_default);
13963 %}
13964 
13965 // Store unsigned short / char reversed byte order
13966 instruct storeUS_reversed(iRegIsrc src, indirect mem) %{
13967   match(Set mem (StoreC mem (ReverseBytesUS src)));
13968   ins_cost(MEMORY_REF_COST);
13969 
13970   size(4);
13971   ins_encode %{
13972     __ sthbrx($src$$Register, $mem$$Register);
13973   %}
13974   ins_pipe(pipe_class_default);
13975 %}
13976 
13977 // Store short reversed byte order
13978 instruct storeS_reversed(iRegIsrc src, indirect mem) %{
13979   match(Set mem (StoreC mem (ReverseBytesS src)));
13980   ins_cost(MEMORY_REF_COST);
13981 
13982   size(4);
13983   ins_encode %{
13984     __ sthbrx($src$$Register, $mem$$Register);
13985   %}
13986   ins_pipe(pipe_class_default);
13987 %}
13988 
13989 instruct mtvsrwz(vecX temp1, iRegIsrc src) %{
13990   effect(DEF temp1, USE src);
13991 
13992   format %{ &quot;MTVSRWZ $temp1, $src \t// Move to 16-byte register&quot; %}
13993   size(4);
13994   ins_encode %{
13995     __ mtvsrwz($temp1$$VectorSRegister, $src$$Register);
13996   %}
13997   ins_pipe(pipe_class_default);
13998 %}
13999 
14000 instruct xxspltw(vecX dst, vecX src, immI8 imm1) %{
14001   effect(DEF dst, USE src, USE imm1);
14002 
14003   format %{ &quot;XXSPLTW $dst, $src, $imm1 \t// Splat word&quot; %}
14004   size(4);
14005   ins_encode %{
14006     __ xxspltw($dst$$VectorSRegister, $src$$VectorSRegister, $imm1$$constant);
14007   %}
14008   ins_pipe(pipe_class_default);
14009 %}
14010 
14011 instruct xscvdpspn_regF(vecX dst, regF src) %{
14012   effect(DEF dst, USE src);
14013 
14014   format %{ &quot;XSCVDPSPN $dst, $src \t// Convert scalar single precision to vector single precision&quot; %}
14015   size(4);
14016   ins_encode %{
14017     __ xscvdpspn($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr());
14018   %}
14019   ins_pipe(pipe_class_default);
14020 %}
14021 
14022 //---------- Replicate Vector Instructions ------------------------------------
14023 
14024 // Insrdi does replicate if src == dst.
14025 instruct repl32(iRegLdst dst) %{
14026   predicate(false);
14027   effect(USE_DEF dst);
14028 
14029   format %{ &quot;INSRDI  $dst, #0, $dst, #32 \t// replicate&quot; %}
14030   size(4);
14031   ins_encode %{
14032     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
14033     __ insrdi($dst$$Register, $dst$$Register, 32, 0);
14034   %}
14035   ins_pipe(pipe_class_default);
14036 %}
14037 
14038 // Insrdi does replicate if src == dst.
14039 instruct repl48(iRegLdst dst) %{
14040   predicate(false);
14041   effect(USE_DEF dst);
14042 
14043   format %{ &quot;INSRDI  $dst, #0, $dst, #48 \t// replicate&quot; %}
14044   size(4);
14045   ins_encode %{
14046     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
14047     __ insrdi($dst$$Register, $dst$$Register, 48, 0);
14048   %}
14049   ins_pipe(pipe_class_default);
14050 %}
14051 
14052 // Insrdi does replicate if src == dst.
14053 instruct repl56(iRegLdst dst) %{
14054   predicate(false);
14055   effect(USE_DEF dst);
14056 
14057   format %{ &quot;INSRDI  $dst, #0, $dst, #56 \t// replicate&quot; %}
14058   size(4);
14059   ins_encode %{
14060     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
14061     __ insrdi($dst$$Register, $dst$$Register, 56, 0);
14062   %}
14063   ins_pipe(pipe_class_default);
14064 %}
14065 
14066 instruct repl8B_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14067   match(Set dst (ReplicateB src));
14068   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14069   expand %{
14070     moveReg(dst, src);
14071     repl56(dst);
14072     repl48(dst);
14073     repl32(dst);
14074   %}
14075 %}
14076 
14077 instruct repl8B_immI0(iRegLdst dst, immI_0 zero) %{
14078   match(Set dst (ReplicateB zero));
14079   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14080   format %{ &quot;LI      $dst, #0 \t// replicate8B&quot; %}
14081   size(4);
14082   ins_encode %{
14083     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14084     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14085   %}
14086   ins_pipe(pipe_class_default);
14087 %}
14088 
14089 instruct repl8B_immIminus1(iRegLdst dst, immI_minus1 src) %{
14090   match(Set dst (ReplicateB src));
14091   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14092   format %{ &quot;LI      $dst, #-1 \t// replicate8B&quot; %}
14093   size(4);
14094   ins_encode %{
14095     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14096     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14097   %}
14098   ins_pipe(pipe_class_default);
14099 %}
14100 
14101 instruct repl16B_reg_Ex(vecX dst, iRegIsrc src) %{
14102   match(Set dst (ReplicateB src));
14103   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14104 
14105   expand %{
14106     iRegLdst tmpL;
14107     vecX tmpV;
14108     immI8  imm1 %{ (int)  1 %}
14109     moveReg(tmpL, src);
14110     repl56(tmpL);
14111     repl48(tmpL);
14112     mtvsrwz(tmpV, tmpL);
14113     xxspltw(dst, tmpV, imm1);
14114   %}
14115 %}
14116 
14117 instruct repl16B_immI0(vecX dst, immI_0 zero) %{
14118   match(Set dst (ReplicateB zero));
14119   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14120 
14121   format %{ &quot;XXLXOR      $dst, $zero \t// replicate16B&quot; %}
14122   size(4);
14123   ins_encode %{
14124     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14125   %}
14126   ins_pipe(pipe_class_default);
14127 %}
14128 
14129 instruct repl16B_immIminus1(vecX dst, immI_minus1 src) %{
14130   match(Set dst (ReplicateB src));
14131   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14132 
14133   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}
14134   size(4);
14135   ins_encode %{
14136     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14137   %}
14138   ins_pipe(pipe_class_default);
14139 %}
14140 
14141 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14142   match(Set dst (ReplicateS src));
14143   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14144   expand %{
14145     moveReg(dst, src);
14146     repl48(dst);
14147     repl32(dst);
14148   %}
14149 %}
14150 
14151 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
14152   match(Set dst (ReplicateS zero));
14153   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14154   format %{ &quot;LI      $dst, #0 \t// replicate4S&quot; %}
14155   size(4);
14156   ins_encode %{
14157     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14158     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14159   %}
14160   ins_pipe(pipe_class_default);
14161 %}
14162 
14163 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
14164   match(Set dst (ReplicateS src));
14165   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14166   format %{ &quot;LI      $dst, -1 \t// replicate4S&quot; %}
14167   size(4);
14168   ins_encode %{
14169     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14170     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14171   %}
14172   ins_pipe(pipe_class_default);
14173 %}
14174 
14175 instruct repl8S_reg_Ex(vecX dst, iRegIsrc src) %{
14176   match(Set dst (ReplicateS src));
14177   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14178 
14179   expand %{
14180     iRegLdst tmpL;
14181     vecX tmpV;
14182     immI8  zero %{ (int)  0 %}
14183     moveReg(tmpL, src);
14184     repl48(tmpL);
14185     repl32(tmpL);
14186     mtvsrd(tmpV, tmpL);
14187     xxpermdi(dst, tmpV, tmpV, zero);
14188   %}
14189 %}
14190 
14191 instruct repl8S_immI0(vecX dst, immI_0 zero) %{
14192   match(Set dst (ReplicateS zero));
14193   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14194 
14195   format %{ &quot;XXLXOR      $dst, $zero \t// replicate8S&quot; %}
14196   size(4);
14197   ins_encode %{
14198     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14199   %}
14200   ins_pipe(pipe_class_default);
14201 %}
14202 
14203 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
14204   match(Set dst (ReplicateS src));
14205   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14206 
14207   format %{ &quot;XXLEQV      $dst, $src \t// replicate8S&quot; %}
14208   size(4);
14209   ins_encode %{
14210     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14211   %}
14212   ins_pipe(pipe_class_default);
14213 %}
14214 
14215 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14216   match(Set dst (ReplicateI src));
14217   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14218   ins_cost(2 * DEFAULT_COST);
14219   expand %{
14220     moveReg(dst, src);
14221     repl32(dst);
14222   %}
14223 %}
14224 
14225 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
14226   match(Set dst (ReplicateI zero));
14227   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14228   format %{ &quot;LI      $dst, #0 \t// replicate2I&quot; %}
14229   size(4);
14230   ins_encode %{
14231     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14232     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14233   %}
14234   ins_pipe(pipe_class_default);
14235 %}
14236 
14237 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
14238   match(Set dst (ReplicateI src));
14239   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14240   format %{ &quot;LI      $dst, -1 \t// replicate2I&quot; %}
14241   size(4);
14242   ins_encode %{
14243     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14244     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14245   %}
14246   ins_pipe(pipe_class_default);
14247 %}
14248 
14249 instruct repl4I_reg_Ex(vecX dst, iRegIsrc src) %{
14250   match(Set dst (ReplicateI src));
14251   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14252   ins_cost(2 * DEFAULT_COST);
14253 
14254   expand %{
14255     iRegLdst tmpL;
14256     vecX tmpV;
14257     immI8  zero %{ (int)  0 %}
14258     moveReg(tmpL, src);
14259     repl32(tmpL);
14260     mtvsrd(tmpV, tmpL);
14261     xxpermdi(dst, tmpV, tmpV, zero);
14262   %}
14263 %}
14264 
14265 instruct repl4I_immI0(vecX dst, immI_0 zero) %{
14266   match(Set dst (ReplicateI zero));
14267   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14268 
14269   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4I&quot; %}
14270   size(4);
14271   ins_encode %{
14272     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14273   %}
14274   ins_pipe(pipe_class_default);
14275 %}
14276 
14277 instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{
14278   match(Set dst (ReplicateI src));
14279   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14280 
14281   format %{ &quot;XXLEQV      $dst, $dst, $dst \t// replicate4I&quot; %}
14282   size(4);
14283   ins_encode %{
14284     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14285   %}
14286   ins_pipe(pipe_class_default);
14287 %}
14288 
14289 // Move float to int register via stack, replicate.
14290 instruct repl2F_reg_Ex(iRegLdst dst, regF src) %{
14291   match(Set dst (ReplicateF src));
14292   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14293   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
14294   expand %{
14295     stackSlotL tmpS;
14296     iRegIdst tmpI;
14297     moveF2I_reg_stack(tmpS, src);   // Move float to stack.
14298     moveF2I_stack_reg(tmpI, tmpS);  // Move stack to int reg.
14299     moveReg(dst, tmpI);             // Move int to long reg.
14300     repl32(dst);                    // Replicate bitpattern.
14301   %}
14302 %}
14303 
14304 // Replicate scalar constant to packed float values in Double register
14305 instruct repl2F_immF_Ex(iRegLdst dst, immF src) %{
14306   match(Set dst (ReplicateF src));
14307   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14308   ins_cost(5 * DEFAULT_COST);
14309 
14310   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load replicated float $src $src from table, postalloc expanded&quot; %}
14311   postalloc_expand( postalloc_expand_load_replF_constant(dst, src, constanttablebase) );
14312 %}
14313 
14314 // Replicate scalar zero constant to packed float values in Double register
14315 instruct repl2F_immF0(iRegLdst dst, immF_0 zero) %{
14316   match(Set dst (ReplicateF zero));
14317   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14318 
14319   format %{ &quot;LI      $dst, #0 \t// replicate2F&quot; %}
14320   ins_encode %{
14321     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14322     __ li($dst$$Register, 0x0);
14323   %}
14324   ins_pipe(pipe_class_default);
14325 %}
14326 
14327 
14328 //----------Vector Arithmetic Instructions--------------------------------------
14329 
14330 // Vector Addition Instructions
14331 
14332 instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{
14333   match(Set dst (AddVB src1 src2));
14334   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14335   format %{ &quot;VADDUBM  $dst,$src1,$src2\t// add packed16B&quot; %}
14336   size(4);
14337   ins_encode %{
14338     __ vaddubm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14339   %}
14340   ins_pipe(pipe_class_default);
14341 %}
14342 
14343 instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{
14344   match(Set dst (AddVS src1 src2));
14345   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14346   format %{ &quot;VADDUHM  $dst,$src1,$src2\t// add packed8S&quot; %}
14347   size(4);
14348   ins_encode %{
14349     __ vadduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14350   %}
14351   ins_pipe(pipe_class_default);
14352 %}
14353 
14354 instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{
14355   match(Set dst (AddVI src1 src2));
14356   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14357   format %{ &quot;VADDUWM  $dst,$src1,$src2\t// add packed4I&quot; %}
14358   size(4);
14359   ins_encode %{
14360     __ vadduwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14361   %}
14362   ins_pipe(pipe_class_default);
14363 %}
14364 
14365 instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{
14366   match(Set dst (AddVF src1 src2));
14367   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14368   format %{ &quot;VADDFP  $dst,$src1,$src2\t// add packed4F&quot; %}
14369   size(4);
14370   ins_encode %{
14371     __ vaddfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14372   %}
14373   ins_pipe(pipe_class_default);
14374 %}
14375 
14376 instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{
14377   match(Set dst (AddVL src1 src2));
14378   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14379   format %{ &quot;VADDUDM  $dst,$src1,$src2\t// add packed2L&quot; %}
14380   size(4);
14381   ins_encode %{
14382     __ vaddudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14383   %}
14384   ins_pipe(pipe_class_default);
14385 %}
14386 
14387 instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{
14388   match(Set dst (AddVD src1 src2));
14389   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14390   format %{ &quot;XVADDDP  $dst,$src1,$src2\t// add packed2D&quot; %}
14391   size(4);
14392   ins_encode %{
14393     __ xvadddp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14394   %}
14395   ins_pipe(pipe_class_default);
14396 %}
14397 
14398 // Vector Subtraction Instructions
14399 
14400 instruct vsub16B_reg(vecX dst, vecX src1, vecX src2) %{
14401   match(Set dst (SubVB src1 src2));
14402   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14403   format %{ &quot;VSUBUBM  $dst,$src1,$src2\t// sub packed16B&quot; %}
14404   size(4);
14405   ins_encode %{
14406     __ vsububm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14407   %}
14408   ins_pipe(pipe_class_default);
14409 %}
14410 
14411 instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{
14412   match(Set dst (SubVS src1 src2));
14413   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14414   format %{ &quot;VSUBUHM  $dst,$src1,$src2\t// sub packed8S&quot; %}
14415   size(4);
14416   ins_encode %{
14417     __ vsubuhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14418   %}
14419   ins_pipe(pipe_class_default);
14420 %}
14421 
14422 instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{
14423   match(Set dst (SubVI src1 src2));
14424   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14425   format %{ &quot;VSUBUWM  $dst,$src1,$src2\t// sub packed4I&quot; %}
14426   size(4);
14427   ins_encode %{
14428     __ vsubuwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14429   %}
14430   ins_pipe(pipe_class_default);
14431 %}
14432 
14433 instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{
14434   match(Set dst (SubVF src1 src2));
14435   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14436   format %{ &quot;VSUBFP  $dst,$src1,$src2\t// sub packed4F&quot; %}
14437   size(4);
14438   ins_encode %{
14439     __ vsubfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14440   %}
14441   ins_pipe(pipe_class_default);
14442 %}
14443 
14444 instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{
14445   match(Set dst (SubVL src1 src2));
14446   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14447   format %{ &quot;VSUBUDM  $dst,$src1,$src2\t// sub packed2L&quot; %}
14448   size(4);
14449   ins_encode %{
14450     __ vsubudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14451   %}
14452   ins_pipe(pipe_class_default);
14453 %}
14454 
14455 instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{
14456   match(Set dst (SubVD src1 src2));
14457   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14458   format %{ &quot;XVSUBDP  $dst,$src1,$src2\t// sub packed2D&quot; %}
14459   size(4);
14460   ins_encode %{
14461     __ xvsubdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14462   %}
14463   ins_pipe(pipe_class_default);
14464 %}
14465 
14466 // Vector Multiplication Instructions
14467 
14468 instruct vmul8S_reg(vecX dst, vecX src1, vecX src2, vecX tmp) %{
14469   match(Set dst (MulVS src1 src2));
14470   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14471   effect(TEMP tmp);
14472   format %{ &quot;VSPLTISH  $tmp,0\t// mul packed8S&quot; %}
14473   format %{ &quot;VMLADDUHM  $dst,$src1,$src2\t// mul packed8S&quot; %}
14474   size(8);
14475   ins_encode %{
14476     __ vspltish($tmp$$VectorSRegister-&gt;to_vr(), 0);
14477     __ vmladduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr(), $tmp$$VectorSRegister-&gt;to_vr());
14478   %}
14479   ins_pipe(pipe_class_default);
14480 %}
14481 
14482 instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{
14483   match(Set dst (MulVI src1 src2));
14484   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14485   format %{ &quot;VMULUWM  $dst,$src1,$src2\t// mul packed4I&quot; %}
14486   size(4);
14487   ins_encode %{
14488     __ vmuluwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14489   %}
14490   ins_pipe(pipe_class_default);
14491 %}
14492 
14493 instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{
14494   match(Set dst (MulVF src1 src2));
14495   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14496   format %{ &quot;XVMULSP  $dst,$src1,$src2\t// mul packed4F&quot; %}
14497   size(4);
14498   ins_encode %{
14499     __ xvmulsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14500   %}
14501   ins_pipe(pipe_class_default);
14502 %}
14503 
14504 instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{
14505   match(Set dst (MulVD src1 src2));
14506   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14507   format %{ &quot;XVMULDP  $dst,$src1,$src2\t// mul packed2D&quot; %}
14508   size(4);
14509   ins_encode %{
14510     __ xvmuldp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14511   %}
14512   ins_pipe(pipe_class_default);
14513 %}
14514 
14515 // Vector Division Instructions
14516 
14517 instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{
14518   match(Set dst (DivVF src1 src2));
14519   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14520   format %{ &quot;XVDIVSP  $dst,$src1,$src2\t// div packed4F&quot; %}
14521   size(4);
14522   ins_encode %{
14523     __ xvdivsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14524   %}
14525   ins_pipe(pipe_class_default);
14526 %}
14527 
14528 instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{
14529   match(Set dst (DivVD src1 src2));
14530   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14531   format %{ &quot;XVDIVDP  $dst,$src1,$src2\t// div packed2D&quot; %}
14532   size(4);
14533   ins_encode %{
14534     __ xvdivdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14535   %}
14536   ins_pipe(pipe_class_default);
14537 %}
14538 
14539 // Vector Absolute Instructions
14540 
14541 instruct vabs4F_reg(vecX dst, vecX src) %{
14542   match(Set dst (AbsVF src));
14543   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14544   format %{ &quot;XVABSSP $dst,$src\t// absolute packed4F&quot; %}
14545   size(4);
14546   ins_encode %{
14547     __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);
14548   %}
14549   ins_pipe(pipe_class_default);
14550 %}
14551 
14552 instruct vabs2D_reg(vecX dst, vecX src) %{
14553   match(Set dst (AbsVD src));
14554   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14555   format %{ &quot;XVABSDP $dst,$src\t// absolute packed2D&quot; %}
14556   size(4);
14557   ins_encode %{
14558     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
14559   %}
14560   ins_pipe(pipe_class_default);
14561 %}
14562 
14563 // Round Instructions
14564 instruct roundD_reg(regD dst, regD src, immI8 rmode) %{
14565   match(Set dst (RoundDoubleMode src rmode));
14566   format %{ &quot;RoundDoubleMode $src,$rmode&quot; %}
14567   size(4);
14568   ins_encode %{
14569     switch ($rmode$$constant) {
14570       case RoundDoubleModeNode::rmode_rint:
14571         __ frin($dst$$FloatRegister, $src$$FloatRegister);
14572         break;
14573       case RoundDoubleModeNode::rmode_floor:
14574         __ frim($dst$$FloatRegister, $src$$FloatRegister);
14575         break;
14576       case RoundDoubleModeNode::rmode_ceil:
14577         __ frip($dst$$FloatRegister, $src$$FloatRegister);
14578         break;
14579       default:
14580         ShouldNotReachHere();
14581     }
14582   %}
14583   ins_pipe(pipe_class_default);
14584 %}
14585 
14586 // Vector Round Instructions
14587 instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{
14588   match(Set dst (RoundDoubleModeV src rmode));
14589   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14590   format %{ &quot;RoundDoubleModeV $src,$rmode&quot; %}
14591   size(4);
14592   ins_encode %{
14593     switch ($rmode$$constant) {
14594       case RoundDoubleModeNode::rmode_rint:
14595         __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);
14596         break;
14597       case RoundDoubleModeNode::rmode_floor:
14598         __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);
14599         break;
14600       case RoundDoubleModeNode::rmode_ceil:
14601         __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);
14602         break;
14603       default:
14604         ShouldNotReachHere();
14605     }
14606   %}
14607   ins_pipe(pipe_class_default);
14608 %}
14609 
14610 // Vector Negate Instructions
14611 
14612 instruct vneg4F_reg(vecX dst, vecX src) %{
14613   match(Set dst (NegVF src));
14614   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14615   format %{ &quot;XVNEGSP $dst,$src\t// negate packed4F&quot; %}
14616   size(4);
14617   ins_encode %{
14618     __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);
14619   %}
14620   ins_pipe(pipe_class_default);
14621 %}
14622 
14623 instruct vneg2D_reg(vecX dst, vecX src) %{
14624   match(Set dst (NegVD src));
14625   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14626   format %{ &quot;XVNEGDP $dst,$src\t// negate packed2D&quot; %}
14627   size(4);
14628   ins_encode %{
14629     __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);
14630   %}
14631   ins_pipe(pipe_class_default);
14632 %}
14633 
14634 // Vector Square Root Instructions
14635 
14636 instruct vsqrt4F_reg(vecX dst, vecX src) %{
14637   match(Set dst (SqrtVF src));
14638   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14639   format %{ &quot;XVSQRTSP $dst,$src\t// sqrt packed4F&quot; %}
14640   size(4);
14641   ins_encode %{
14642     __ xvsqrtsp($dst$$VectorSRegister, $src$$VectorSRegister);
14643   %}
14644   ins_pipe(pipe_class_default);
14645 %}
14646 
14647 instruct vsqrt2D_reg(vecX dst, vecX src) %{
14648   match(Set dst (SqrtVD src));
14649   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14650   format %{ &quot;XVSQRTDP  $dst,$src\t// sqrt packed2D&quot; %}
14651   size(4);
14652   ins_encode %{
14653     __ xvsqrtdp($dst$$VectorSRegister, $src$$VectorSRegister);
14654   %}
14655   ins_pipe(pipe_class_default);
14656 %}
14657 
14658 // Vector Population Count Instructions
14659 
14660 instruct vpopcnt4I_reg(vecX dst, vecX src) %{
14661   match(Set dst (PopCountVI src));
14662   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14663   format %{ &quot;VPOPCNTW $dst,$src\t// pop count packed4I&quot; %}
14664   size(4);
14665   ins_encode %{
14666     __ vpopcntw($dst$$VectorSRegister-&gt;to_vr(), $src$$VectorSRegister-&gt;to_vr());
14667   %}
14668   ins_pipe(pipe_class_default);
14669 %}
14670 
14671 // --------------------------------- FMA --------------------------------------
14672 // dst + src1 * src2
14673 instruct vfma4F(vecX dst, vecX src1, vecX src2) %{
14674   match(Set dst (FmaVF dst (Binary src1 src2)));
14675   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14676 
14677   format %{ &quot;XVMADDASP   $dst, $src1, $src2&quot; %}
14678 
14679   size(4);
14680   ins_encode %{
14681     __ xvmaddasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14682   %}
14683   ins_pipe(pipe_class_default);
14684 %}
14685 
14686 // dst - src1 * src2
14687 instruct vfma4F_neg1(vecX dst, vecX src1, vecX src2) %{
14688   match(Set dst (FmaVF dst (Binary (NegVF src1) src2)));
14689   match(Set dst (FmaVF dst (Binary src1 (NegVF src2))));
14690   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14691 
14692   format %{ &quot;XVNMSUBASP   $dst, $src1, $src2&quot; %}
14693 
14694   size(4);
14695   ins_encode %{
14696     __ xvnmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14697   %}
14698   ins_pipe(pipe_class_default);
14699 %}
14700 
14701 // - dst + src1 * src2
14702 instruct vfma4F_neg2(vecX dst, vecX src1, vecX src2) %{
14703   match(Set dst (FmaVF (NegVF dst) (Binary src1 src2)));
14704   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14705 
14706   format %{ &quot;XVMSUBASP   $dst, $src1, $src2&quot; %}
14707 
14708   size(4);
14709   ins_encode %{
14710     __ xvmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14711   %}
14712   ins_pipe(pipe_class_default);
14713 %}
14714 
14715 // dst + src1 * src2
14716 instruct vfma2D(vecX dst, vecX src1, vecX src2) %{
14717   match(Set dst (FmaVD  dst (Binary src1 src2)));
14718   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14719 
14720   format %{ &quot;XVMADDADP   $dst, $src1, $src2&quot; %}
14721 
14722   size(4);
14723   ins_encode %{
14724     __ xvmaddadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14725   %}
14726   ins_pipe(pipe_class_default);
14727 %}
14728 
14729 // dst - src1 * src2
14730 instruct vfma2D_neg1(vecX dst, vecX src1, vecX src2) %{
14731   match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));
14732   match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));
14733   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14734 
14735   format %{ &quot;XVNMSUBADP   $dst, $src1, $src2&quot; %}
14736 
14737   size(4);
14738   ins_encode %{
14739     __ xvnmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14740   %}
14741   ins_pipe(pipe_class_default);
14742 %}
14743 
14744 // - dst + src1 * src2
14745 instruct vfma2D_neg2(vecX dst, vecX src1, vecX src2) %{
14746   match(Set dst (FmaVD (NegVD dst) (Binary src1 src2)));
14747   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14748 
14749   format %{ &quot;XVMSUBADP   $dst, $src1, $src2&quot; %}
14750 
14751   size(4);
14752   ins_encode %{
14753     __ xvmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14754   %}
14755   ins_pipe(pipe_class_default);
14756 %}
14757 
14758 //----------Overflow Math Instructions-----------------------------------------
14759 
14760 // Note that we have to make sure that XER.SO is reset before using overflow instructions.
14761 // Simple Overflow operations can be matched by very few instructions (e.g. addExact: xor, and_, bc).
14762 // Seems like only Long intrinsincs have an advantage. (The only expensive one is OverflowMulL.)
14763 
14764 instruct overflowAddL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14765   match(Set cr0 (OverflowAddL op1 op2));
14766 
14767   format %{ &quot;add_    $op1, $op2\t# overflow check long&quot; %}
14768   ins_encode %{
14769     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14770     __ li(R0, 0);
14771     __ mtxer(R0); // clear XER.SO
14772     __ addo_(R0, $op1$$Register, $op2$$Register);
14773   %}
14774   ins_pipe(pipe_class_default);
14775 %}
14776 
14777 instruct overflowSubL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14778   match(Set cr0 (OverflowSubL op1 op2));
14779 
14780   format %{ &quot;subfo_  R0, $op2, $op1\t# overflow check long&quot; %}
14781   ins_encode %{
14782     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14783     __ li(R0, 0);
14784     __ mtxer(R0); // clear XER.SO
14785     __ subfo_(R0, $op2$$Register, $op1$$Register);
14786   %}
14787   ins_pipe(pipe_class_default);
14788 %}
14789 
14790 instruct overflowNegL_reg(flagsRegCR0 cr0, immL_0 zero, iRegLsrc op2) %{
14791   match(Set cr0 (OverflowSubL zero op2));
14792 
14793   format %{ &quot;nego_   R0, $op2\t# overflow check long&quot; %}
14794   ins_encode %{
14795     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14796     __ li(R0, 0);
14797     __ mtxer(R0); // clear XER.SO
14798     __ nego_(R0, $op2$$Register);
14799   %}
14800   ins_pipe(pipe_class_default);
14801 %}
14802 
14803 instruct overflowMulL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14804   match(Set cr0 (OverflowMulL op1 op2));
14805 
14806   format %{ &quot;mulldo_ R0, $op1, $op2\t# overflow check long&quot; %}
14807   ins_encode %{
14808     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14809     __ li(R0, 0);
14810     __ mtxer(R0); // clear XER.SO
14811     __ mulldo_(R0, $op1$$Register, $op2$$Register);
14812   %}
14813   ins_pipe(pipe_class_default);
14814 %}
14815 
14816 instruct repl4F_reg_Ex(vecX dst, regF src) %{
14817   match(Set dst (ReplicateF src));
14818   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14819   ins_cost(DEFAULT_COST);
14820   expand %{
14821     vecX tmpV;
14822     immI8  zero %{ (int)  0 %}
14823 
14824     xscvdpspn_regF(tmpV, src);
14825     xxspltw(dst, tmpV, zero);
14826   %}
14827 %}
14828 
14829 instruct repl4F_immF_Ex(vecX dst, immF src, iRegLdst tmp) %{
14830   match(Set dst (ReplicateF src));
14831   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14832   effect(TEMP tmp);
14833   ins_cost(10 * DEFAULT_COST);
14834 
14835   postalloc_expand( postalloc_expand_load_replF_constant_vsx(dst, src, constanttablebase, tmp) );
14836 %}
14837 
14838 instruct repl4F_immF0(vecX dst, immF_0 zero) %{
14839   match(Set dst (ReplicateF zero));
14840   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14841 
14842   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4F&quot; %}
14843   ins_encode %{
14844     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14845   %}
14846   ins_pipe(pipe_class_default);
14847 %}
14848 
14849 instruct repl2D_reg_Ex(vecX dst, regD src) %{
14850   match(Set dst (ReplicateD src));
14851   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14852 
14853   format %{ &quot;XXPERMDI      $dst, $src, $src, 0 \t// Splat doubleword&quot; %}
14854   size(4);
14855   ins_encode %{
14856     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
14857   %}
14858   ins_pipe(pipe_class_default);
14859 %}
14860 
14861 instruct repl2D_immD0(vecX dst, immD_0 zero) %{
14862   match(Set dst (ReplicateD zero));
14863   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14864 
14865   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
14866   size(4);
14867   ins_encode %{
14868     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14869   %}
14870   ins_pipe(pipe_class_default);
14871 %}
14872 
14873 instruct mtvsrd(vecX dst, iRegLsrc src) %{
14874   predicate(false);
14875   effect(DEF dst, USE src);
14876 
14877   format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
14878   size(4);
14879   ins_encode %{
14880     __ mtvsrd($dst$$VectorSRegister, $src$$Register);
14881   %}
14882   ins_pipe(pipe_class_default);
14883 %}
14884 
14885 instruct xxspltd(vecX dst, vecX src, immI8 zero) %{
14886   effect(DEF dst, USE src, USE zero);
14887 
14888   format %{ &quot;XXSPLATD      $dst, $src, $zero \t// Splat doubleword&quot; %}
14889   size(4);
14890   ins_encode %{
14891     __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);
14892   %}
14893   ins_pipe(pipe_class_default);
14894 %}
14895 
14896 instruct xxpermdi(vecX dst, vecX src1, vecX src2, immI8 zero) %{
14897   effect(DEF dst, USE src1, USE src2, USE zero);
14898 
14899   format %{ &quot;XXPERMDI      $dst, $src1, $src2, $zero \t// Splat doubleword&quot; %}
14900   size(4);
14901   ins_encode %{
14902     __ xxpermdi($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister, $zero$$constant);
14903   %}
14904   ins_pipe(pipe_class_default);
14905 %}
14906 
14907 instruct repl2L_reg_Ex(vecX dst, iRegLsrc src) %{
14908   match(Set dst (ReplicateL src));
14909   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14910   expand %{
14911     vecX tmpV;
14912     immI8  zero %{ (int)  0 %}
14913     mtvsrd(tmpV, src);
14914     xxpermdi(dst, tmpV, tmpV, zero);
14915   %}
14916 %}
14917 
14918 instruct repl2L_immI0(vecX dst, immI_0 zero) %{
14919   match(Set dst (ReplicateL zero));
14920   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14921 
14922   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2L&quot; %}
14923   size(4);
14924   ins_encode %{
14925     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14926   %}
14927   ins_pipe(pipe_class_default);
14928 %}
14929 
14930 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
14931   match(Set dst (ReplicateL src));
14932   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14933 
14934   format %{ &quot;XXLEQV      $dst, $src \t// replicate2L&quot; %}
14935   size(4);
14936   ins_encode %{
14937     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14938   %}
14939   ins_pipe(pipe_class_default);
14940 %}
14941 
14942 // ============================================================================
14943 // Safepoint Instruction
14944 
14945 instruct safePoint_poll(iRegPdst poll) %{
14946   match(SafePoint poll);
14947 
14948   // It caused problems to add the effect that r0 is killed, but this
14949   // effect no longer needs to be mentioned, since r0 is not contained
14950   // in a reg_class.
14951 
14952   format %{ &quot;LD      R0, #0, $poll \t// Safepoint poll for GC&quot; %}
14953   size(4);
14954   ins_encode( enc_poll(0x0, poll) );
14955   ins_pipe(pipe_class_default);
14956 %}
14957 
14958 // ============================================================================
14959 // Call Instructions
14960 
14961 // Call Java Static Instruction
14962 
14963 // Schedulable version of call static node.
14964 instruct CallStaticJavaDirect(method meth) %{
14965   match(CallStaticJava);
14966   effect(USE meth);
14967   ins_cost(CALL_COST);
14968 
14969   ins_num_consts(3 /* up to 3 patchable constants: inline cache, 2 call targets. */);
14970 
14971   format %{ &quot;CALL,static $meth \t// ==&gt; &quot; %}
14972   size(4);
14973   ins_encode( enc_java_static_call(meth) );
14974   ins_pipe(pipe_class_call);
14975 %}
14976 
14977 // Call Java Dynamic Instruction
14978 
14979 // Used by postalloc expand of CallDynamicJavaDirectSchedEx (actual call).
14980 // Loading of IC was postalloc expanded. The nodes loading the IC are reachable
14981 // via fields ins_field_load_ic_hi_node and ins_field_load_ic_node.
14982 // The call destination must still be placed in the constant pool.
14983 instruct CallDynamicJavaDirectSched(method meth) %{
14984   match(CallDynamicJava); // To get all the data fields we need ...
14985   effect(USE meth);
14986   predicate(false);       // ... but never match.
14987 
14988   ins_field_load_ic_hi_node(loadConL_hiNode*);
14989   ins_field_load_ic_node(loadConLNode*);
14990   ins_num_consts(1 /* 1 patchable constant: call destination */);
14991 
14992   format %{ &quot;BL        \t// dynamic $meth ==&gt; &quot; %}
14993   size(4);
14994   ins_encode( enc_java_dynamic_call_sched(meth) );
14995   ins_pipe(pipe_class_call);
14996 %}
14997 
14998 // Schedulable (i.e. postalloc expanded) version of call dynamic java.
14999 // We use postalloc expanded calls if we use inline caches
15000 // and do not update method data.
15001 //
15002 // This instruction has two constants: inline cache (IC) and call destination.
15003 // Loading the inline cache will be postalloc expanded, thus leaving a call with
15004 // one constant.
15005 instruct CallDynamicJavaDirectSched_Ex(method meth) %{
15006   match(CallDynamicJava);
15007   effect(USE meth);
15008   predicate(UseInlineCaches);
15009   ins_cost(CALL_COST);
15010 
15011   ins_num_consts(2 /* 2 patchable constants: inline cache, call destination. */);
15012 
15013   format %{ &quot;CALL,dynamic $meth \t// postalloc expanded&quot; %}
15014   postalloc_expand( postalloc_expand_java_dynamic_call_sched(meth, constanttablebase) );
15015 %}
15016 
15017 // Compound version of call dynamic java
15018 // We use postalloc expanded calls if we use inline caches
15019 // and do not update method data.
15020 instruct CallDynamicJavaDirect(method meth) %{
15021   match(CallDynamicJava);
15022   effect(USE meth);
15023   predicate(!UseInlineCaches);
15024   ins_cost(CALL_COST);
15025 
15026   // Enc_java_to_runtime_call needs up to 4 constants (method data oop).
15027   ins_num_consts(4);
15028 
15029   format %{ &quot;CALL,dynamic $meth \t// ==&gt; &quot; %}
15030   ins_encode( enc_java_dynamic_call(meth, constanttablebase) );
15031   ins_pipe(pipe_class_call);
15032 %}
15033 
15034 // Call Runtime Instruction
15035 
15036 instruct CallRuntimeDirect(method meth) %{
15037   match(CallRuntime);
15038   effect(USE meth);
15039   ins_cost(CALL_COST);
15040 
15041   // Enc_java_to_runtime_call needs up to 3 constants: call target,
15042   // env for callee, C-toc.
15043   ins_num_consts(3);
15044 
15045   format %{ &quot;CALL,runtime&quot; %}
15046   ins_encode( enc_java_to_runtime_call(meth) );
15047   ins_pipe(pipe_class_call);
15048 %}
15049 
15050 // Call Leaf
15051 
15052 // Used by postalloc expand of CallLeafDirect_Ex (mtctr).
15053 instruct CallLeafDirect_mtctr(iRegLdst dst, iRegLsrc src) %{
15054   effect(DEF dst, USE src);
15055 
15056   ins_num_consts(1);
15057 
15058   format %{ &quot;MTCTR   $src&quot; %}
15059   size(4);
15060   ins_encode( enc_leaf_call_mtctr(src) );
15061   ins_pipe(pipe_class_default);
15062 %}
15063 
15064 // Used by postalloc expand of CallLeafDirect_Ex (actual call).
15065 instruct CallLeafDirect(method meth) %{
15066   match(CallLeaf);   // To get the data all the data fields we need ...
15067   effect(USE meth);
15068   predicate(false);  // but never match.
15069 
15070   format %{ &quot;BCTRL     \t// leaf call $meth ==&gt; &quot; %}
15071   size(4);
15072   ins_encode %{
15073     // TODO: PPC port $archOpcode(ppc64Opcode_bctrl);
15074     __ bctrl();
15075   %}
15076   ins_pipe(pipe_class_call);
15077 %}
15078 
15079 // postalloc expand of CallLeafDirect.
15080 // Load adress to call from TOC, then bl to it.
15081 instruct CallLeafDirect_Ex(method meth) %{
15082   match(CallLeaf);
15083   effect(USE meth);
15084   ins_cost(CALL_COST);
15085 
15086   // Postalloc_expand_java_to_runtime_call needs up to 3 constants: call target,
15087   // env for callee, C-toc.
15088   ins_num_consts(3);
15089 
15090   format %{ &quot;CALL,runtime leaf $meth \t// postalloc expanded&quot; %}
15091   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
15092 %}
15093 
15094 // Call runtime without safepoint - same as CallLeaf.
15095 // postalloc expand of CallLeafNoFPDirect.
15096 // Load adress to call from TOC, then bl to it.
15097 instruct CallLeafNoFPDirect_Ex(method meth) %{
15098   match(CallLeafNoFP);
15099   effect(USE meth);
15100   ins_cost(CALL_COST);
15101 
15102   // Enc_java_to_runtime_call needs up to 3 constants: call target,
15103   // env for callee, C-toc.
15104   ins_num_consts(3);
15105 
15106   format %{ &quot;CALL,runtime leaf nofp $meth \t// postalloc expanded&quot; %}
15107   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
15108 %}
15109 
15110 // Tail Call; Jump from runtime stub to Java code.
15111 // Also known as an &#39;interprocedural jump&#39;.
15112 // Target of jump will eventually return to caller.
15113 // TailJump below removes the return address.
15114 instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
15115   match(TailCall jump_target method_oop);
15116   ins_cost(CALL_COST);
15117 
15118   format %{ &quot;MTCTR   $jump_target \t// $method_oop holds method oop\n\t&quot;
15119             &quot;BCTR         \t// tail call&quot; %}
15120   size(8);
15121   ins_encode %{
15122     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15123     __ mtctr($jump_target$$Register);
15124     __ bctr();
15125   %}
15126   ins_pipe(pipe_class_call);
15127 %}
15128 
15129 // Return Instruction
15130 instruct Ret() %{
15131   match(Return);
15132   format %{ &quot;BLR      \t// branch to link register&quot; %}
15133   size(4);
15134   ins_encode %{
15135     // TODO: PPC port $archOpcode(ppc64Opcode_blr);
15136     // LR is restored in MachEpilogNode. Just do the RET here.
15137     __ blr();
15138   %}
15139   ins_pipe(pipe_class_default);
15140 %}
15141 
15142 // Tail Jump; remove the return address; jump to target.
15143 // TailCall above leaves the return address around.
15144 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
15145 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
15146 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
15147 // in %i0.
15148 instruct tailjmpInd(iRegPdstNoScratch jump_target, rarg1RegP ex_oop) %{
15149   match(TailJump jump_target ex_oop);
15150   ins_cost(CALL_COST);
15151 
15152   format %{ &quot;LD      R4_ARG2 = LR\n\t&quot;
15153             &quot;MTCTR   $jump_target\n\t&quot;
15154             &quot;BCTR     \t// TailJump, exception oop: $ex_oop&quot; %}
15155   size(12);
15156   ins_encode %{
15157     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15158     __ ld(R4_ARG2/* issuing pc */, _abi(lr), R1_SP);
15159     __ mtctr($jump_target$$Register);
15160     __ bctr();
15161   %}
15162   ins_pipe(pipe_class_call);
15163 %}
15164 
15165 // Create exception oop: created by stack-crawling runtime code.
15166 // Created exception is now available to this handler, and is setup
15167 // just prior to jumping to this handler. No code emitted.
15168 instruct CreateException(rarg1RegP ex_oop) %{
15169   match(Set ex_oop (CreateEx));
15170   ins_cost(0);
15171 
15172   format %{ &quot; -- \t// exception oop; no code emitted&quot; %}
15173   size(0);
15174   ins_encode( /*empty*/ );
15175   ins_pipe(pipe_class_default);
15176 %}
15177 
15178 // Rethrow exception: The exception oop will come in the first
15179 // argument position. Then JUMP (not call) to the rethrow stub code.
15180 instruct RethrowException() %{
15181   match(Rethrow);
15182   ins_cost(CALL_COST);
15183 
15184   format %{ &quot;Jmp     rethrow_stub&quot; %}
15185   ins_encode %{
15186     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15187     cbuf.set_insts_mark();
15188     __ b64_patchable((address)OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
15189   %}
15190   ins_pipe(pipe_class_call);
15191 %}
15192 
15193 // Die now.
15194 instruct ShouldNotReachHere() %{
15195   match(Halt);
15196   ins_cost(CALL_COST);
15197 
15198   format %{ &quot;ShouldNotReachHere&quot; %}
15199   ins_encode %{
15200     if (is_reachable()) {
15201       // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
15202       __ stop(_halt_reason);
15203     }
15204   %}
15205   ins_pipe(pipe_class_default);
15206 %}
15207 
15208 // This name is KNOWN by the ADLC and cannot be changed.  The ADLC
15209 // forces a &#39;TypeRawPtr::BOTTOM&#39; output type for this guy.
15210 // Get a DEF on threadRegP, no costs, no encoding, use
15211 // &#39;ins_should_rematerialize(true)&#39; to avoid spilling.
15212 instruct tlsLoadP(threadRegP dst) %{
15213   match(Set dst (ThreadLocal));
15214   ins_cost(0);
15215 
15216   ins_should_rematerialize(true);
15217 
15218   format %{ &quot; -- \t// $dst=Thread::current(), empty&quot; %}
15219   size(0);
15220   ins_encode( /*empty*/ );
15221   ins_pipe(pipe_class_empty);
15222 %}
15223 
15224 //---Some PPC specific nodes---------------------------------------------------
15225 
15226 // Stop a group.
15227 instruct endGroup() %{
15228   ins_cost(0);
15229 
15230   ins_is_nop(true);
15231 
15232   format %{ &quot;End Bundle (ori r1, r1, 0)&quot; %}
15233   size(4);
15234   ins_encode %{
15235     // TODO: PPC port $archOpcode(ppc64Opcode_endgroup);
15236     __ endgroup();
15237   %}
15238   ins_pipe(pipe_class_default);
15239 %}
15240 
15241 // Nop instructions
15242 
15243 instruct fxNop() %{
15244   ins_cost(0);
15245 
15246   ins_is_nop(true);
15247 
15248   format %{ &quot;fxNop&quot; %}
15249   size(4);
15250   ins_encode %{
15251     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15252     __ nop();
15253   %}
15254   ins_pipe(pipe_class_default);
15255 %}
15256 
15257 instruct fpNop0() %{
15258   ins_cost(0);
15259 
15260   ins_is_nop(true);
15261 
15262   format %{ &quot;fpNop0&quot; %}
15263   size(4);
15264   ins_encode %{
15265     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15266     __ fpnop0();
15267   %}
15268   ins_pipe(pipe_class_default);
15269 %}
15270 
15271 instruct fpNop1() %{
15272   ins_cost(0);
15273 
15274   ins_is_nop(true);
15275 
15276   format %{ &quot;fpNop1&quot; %}
15277   size(4);
15278   ins_encode %{
15279     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15280     __ fpnop1();
15281   %}
15282   ins_pipe(pipe_class_default);
15283 %}
15284 
15285 instruct brNop0() %{
15286   ins_cost(0);
15287   size(4);
15288   format %{ &quot;brNop0&quot; %}
15289   ins_encode %{
15290     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15291     __ brnop0();
15292   %}
15293   ins_is_nop(true);
15294   ins_pipe(pipe_class_default);
15295 %}
15296 
15297 instruct brNop1() %{
15298   ins_cost(0);
15299 
15300   ins_is_nop(true);
15301 
15302   format %{ &quot;brNop1&quot; %}
15303   size(4);
15304   ins_encode %{
15305     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15306     __ brnop1();
15307   %}
15308   ins_pipe(pipe_class_default);
15309 %}
15310 
15311 instruct brNop2() %{
15312   ins_cost(0);
15313 
15314   ins_is_nop(true);
15315 
15316   format %{ &quot;brNop2&quot; %}
15317   size(4);
15318   ins_encode %{
15319     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15320     __ brnop2();
15321   %}
15322   ins_pipe(pipe_class_default);
15323 %}
15324 
15325 instruct cacheWB(indirect addr)
15326 %{
15327   match(CacheWB addr);
15328 
15329   ins_cost(100);
15330   format %{ &quot;cache writeback, address = $addr&quot; %}
15331   ins_encode %{
15332     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
15333     assert($addr$$disp == 0, &quot;should be&quot;);
15334     __ cache_wb(Address($addr$$base$$Register));
15335   %}
15336   ins_pipe(pipe_class_default);
15337 %}
15338 
15339 instruct cacheWBPreSync()
15340 %{
15341   match(CacheWBPreSync);
15342 
15343   ins_cost(0);
15344   format %{ &quot;cache writeback presync&quot; %}
15345   ins_encode %{
15346     __ cache_wbsync(true);
15347   %}
15348   ins_pipe(pipe_class_default);
15349 %}
15350 
15351 instruct cacheWBPostSync()
15352 %{
15353   match(CacheWBPostSync);
15354 
15355   ins_cost(100);
15356   format %{ &quot;cache writeback postsync&quot; %}
15357   ins_encode %{
15358     __ cache_wbsync(false);
15359   %}
15360   ins_pipe(pipe_class_default);
15361 %}
15362 
15363 //----------PEEPHOLE RULES-----------------------------------------------------
15364 // These must follow all instruction definitions as they use the names
15365 // defined in the instructions definitions.
15366 //
15367 // peepmatch ( root_instr_name [preceeding_instruction]* );
15368 //
15369 // peepconstraint %{
15370 // (instruction_number.operand_name relational_op instruction_number.operand_name
15371 //  [, ...] );
15372 // // instruction numbers are zero-based using left to right order in peepmatch
15373 //
15374 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
15375 // // provide an instruction_number.operand_name for each operand that appears
15376 // // in the replacement instruction&#39;s match rule
15377 //
15378 // ---------VM FLAGS---------------------------------------------------------
15379 //
15380 // All peephole optimizations can be turned off using -XX:-OptoPeephole
15381 //
15382 // Each peephole rule is given an identifying number starting with zero and
15383 // increasing by one in the order seen by the parser. An individual peephole
15384 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
15385 // on the command-line.
15386 //
15387 // ---------CURRENT LIMITATIONS----------------------------------------------
15388 //
15389 // Only match adjacent instructions in same basic block
15390 // Only equality constraints
15391 // Only constraints between operands, not (0.dest_reg == EAX_enc)
15392 // Only one replacement instruction
15393 //
15394 // ---------EXAMPLE----------------------------------------------------------
15395 //
15396 // // pertinent parts of existing instructions in architecture description
15397 // instruct movI(eRegI dst, eRegI src) %{
15398 //   match(Set dst (CopyI src));
15399 // %}
15400 //
15401 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
15402 //   match(Set dst (AddI dst src));
15403 //   effect(KILL cr);
15404 // %}
15405 //
15406 // // Change (inc mov) to lea
15407 // peephole %{
15408 //   // increment preceeded by register-register move
15409 //   peepmatch ( incI_eReg movI );
15410 //   // require that the destination register of the increment
15411 //   // match the destination register of the move
15412 //   peepconstraint ( 0.dst == 1.dst );
15413 //   // construct a replacement instruction that sets
15414 //   // the destination to ( move&#39;s source register + one )
15415 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15416 // %}
15417 //
15418 // Implementation no longer uses movX instructions since
15419 // machine-independent system no longer uses CopyX nodes.
15420 //
15421 // peephole %{
15422 //   peepmatch ( incI_eReg movI );
15423 //   peepconstraint ( 0.dst == 1.dst );
15424 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15425 // %}
15426 //
15427 // peephole %{
15428 //   peepmatch ( decI_eReg movI );
15429 //   peepconstraint ( 0.dst == 1.dst );
15430 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15431 // %}
15432 //
15433 // peephole %{
15434 //   peepmatch ( addI_eReg_imm movI );
15435 //   peepconstraint ( 0.dst == 1.dst );
15436 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15437 // %}
15438 //
15439 // peephole %{
15440 //   peepmatch ( addP_eReg_imm movP );
15441 //   peepconstraint ( 0.dst == 1.dst );
15442 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
15443 // %}
15444 
15445 // // Change load of spilled value to only a spill
15446 // instruct storeI(memory mem, eRegI src) %{
15447 //   match(Set mem (StoreI mem src));
15448 // %}
15449 //
15450 // instruct loadI(eRegI dst, memory mem) %{
15451 //   match(Set dst (LoadI mem));
15452 // %}
15453 //
15454 peephole %{
15455   peepmatch ( loadI storeI );
15456   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15457   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
15458 %}
15459 
15460 peephole %{
15461   peepmatch ( loadL storeL );
15462   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15463   peepreplace ( storeL( 1.mem 1.mem 1.src ) );
15464 %}
15465 
15466 peephole %{
15467   peepmatch ( loadP storeP );
15468   peepconstraint ( 1.src == 0.dst, 1.dst == 0.mem );
15469   peepreplace ( storeP( 1.dst 1.dst 1.src ) );
15470 %}
15471 
15472 //----------SMARTSPILL RULES---------------------------------------------------
15473 // These must follow all instruction definitions as they use the names
15474 // defined in the instructions definitions.
    </pre>
  </body>
</html>
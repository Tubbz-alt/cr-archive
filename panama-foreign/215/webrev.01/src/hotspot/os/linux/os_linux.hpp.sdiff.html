<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
128   static void init_thread_fpu_state();
129   static int  get_fpu_control_word();
130   static void set_fpu_control_word(int fpu_control);
131   static pthread_t main_thread(void)                                { return _main_thread; }
132   // returns kernel thread id (similar to LWP id on Solaris), which can be
133   // used to access /proc
134   static pid_t gettid();
135   static void hotspot_sigmask(Thread* thread);
136 
137   static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
138   static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
139 
140   static int page_size(void)                                        { return _page_size; }
141   static void set_page_size(int val)                                { _page_size = val; }
142 
143   static address   ucontext_get_pc(const ucontext_t* uc);
144   static void ucontext_set_pc(ucontext_t* uc, address pc);
145   static intptr_t* ucontext_get_sp(const ucontext_t* uc);
146   static intptr_t* ucontext_get_fp(const ucontext_t* uc);
147 
<span class="line-removed">148   // For Analyzer Forte AsyncGetCallTrace profiling support:</span>
<span class="line-removed">149   //</span>
<span class="line-removed">150   // This interface should be declared in os_linux_i486.hpp, but</span>
<span class="line-removed">151   // that file provides extensions to the os class and not the</span>
<span class="line-removed">152   // Linux class.</span>
<span class="line-removed">153   static ExtendedPC fetch_frame_from_ucontext(Thread* thread, const ucontext_t* uc,</span>
<span class="line-removed">154                                               intptr_t** ret_sp, intptr_t** ret_fp);</span>
<span class="line-removed">155 </span>
156   static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);
157 
158   // This boolean allows users to forward their own non-matching signals
159   // to JVM_handle_linux_signal, harmlessly.
160   static bool signal_handlers_are_installed;
161 
162   static int get_our_sigflags(int);
163   static void set_our_sigflags(int, int);
164   static void signal_sets_init();
165   static void install_signal_handlers();
166   static void set_signal_handler(int, bool);
167 
168   static sigset_t* unblocked_signals();
169   static sigset_t* vm_signals();
170 
171   // For signal-chaining
172   static struct sigaction *get_chained_signal_action(int sig);
173   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
174 
175   // GNU libc and libpthread version strings
</pre>
</td>
<td>
<hr />
<pre>
128   static void init_thread_fpu_state();
129   static int  get_fpu_control_word();
130   static void set_fpu_control_word(int fpu_control);
131   static pthread_t main_thread(void)                                { return _main_thread; }
132   // returns kernel thread id (similar to LWP id on Solaris), which can be
133   // used to access /proc
134   static pid_t gettid();
135   static void hotspot_sigmask(Thread* thread);
136 
137   static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
138   static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
139 
140   static int page_size(void)                                        { return _page_size; }
141   static void set_page_size(int val)                                { _page_size = val; }
142 
143   static address   ucontext_get_pc(const ucontext_t* uc);
144   static void ucontext_set_pc(ucontext_t* uc, address pc);
145   static intptr_t* ucontext_get_sp(const ucontext_t* uc);
146   static intptr_t* ucontext_get_fp(const ucontext_t* uc);
147 








148   static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);
149 
150   // This boolean allows users to forward their own non-matching signals
151   // to JVM_handle_linux_signal, harmlessly.
152   static bool signal_handlers_are_installed;
153 
154   static int get_our_sigflags(int);
155   static void set_our_sigflags(int, int);
156   static void signal_sets_init();
157   static void install_signal_handlers();
158   static void set_signal_handler(int, bool);
159 
160   static sigset_t* unblocked_signals();
161   static sigset_t* vm_signals();
162 
163   // For signal-chaining
164   static struct sigaction *get_chained_signal_action(int sig);
165   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
166 
167   // GNU libc and libpthread version strings
</pre>
</td>
</tr>
</table>
<center><a href="os_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows/os_windows.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
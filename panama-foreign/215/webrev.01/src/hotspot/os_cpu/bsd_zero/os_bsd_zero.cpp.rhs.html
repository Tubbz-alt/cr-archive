<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os_cpu/bsd_zero/os_bsd_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #if !defined(__APPLE__) &amp;&amp; !defined(__NetBSD__)
 27 #include &lt;pthread.h&gt;
 28 # include &lt;pthread_np.h&gt; /* For pthread_attr_get_np */
 29 #endif
 30 
 31 // no precompiled headers
 32 #include &quot;jvm.h&quot;
 33 #include &quot;assembler_zero.inline.hpp&quot;
 34 #include &quot;classfile/classLoader.hpp&quot;
 35 #include &quot;classfile/systemDictionary.hpp&quot;
 36 #include &quot;classfile/vmSymbols.hpp&quot;
 37 #include &quot;code/icBuffer.hpp&quot;
 38 #include &quot;code/vtableStubs.hpp&quot;
 39 #include &quot;interpreter/interpreter.hpp&quot;
 40 #include &quot;memory/allocation.inline.hpp&quot;
 41 #include &quot;nativeInst_zero.hpp&quot;
 42 #include &quot;os_share_bsd.hpp&quot;
 43 #include &quot;prims/jniFastGetField.hpp&quot;
 44 #include &quot;prims/jvm_misc.hpp&quot;
 45 #include &quot;runtime/arguments.hpp&quot;
<a name="1" id="anc1"></a>
 46 #include &quot;runtime/frame.inline.hpp&quot;
 47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 48 #include &quot;runtime/java.hpp&quot;
 49 #include &quot;runtime/javaCalls.hpp&quot;
 50 #include &quot;runtime/mutexLocker.hpp&quot;
 51 #include &quot;runtime/osThread.hpp&quot;
 52 #include &quot;runtime/sharedRuntime.hpp&quot;
 53 #include &quot;runtime/stubRoutines.hpp&quot;
 54 #include &quot;runtime/thread.inline.hpp&quot;
 55 #include &quot;runtime/timer.hpp&quot;
 56 #include &quot;utilities/events.hpp&quot;
 57 #include &quot;utilities/vmError.hpp&quot;
 58 
 59 // See stubGenerator_zero.cpp
 60 #include &lt;setjmp.h&gt;
 61 extern sigjmp_buf* get_jmp_buf_for_continuation();
 62 
 63 address os::current_stack_pointer() {
 64   address dummy = (address) &amp;dummy;
 65   return dummy;
 66 }
 67 
 68 frame os::get_sender_for_C_frame(frame* fr) {
 69   ShouldNotCallThis();
 70   return frame();
 71 }
 72 
 73 frame os::current_frame() {
 74   // The only thing that calls this is the stack printing code in
 75   // VMError::report:
 76   //   - Step 110 (printing stack bounds) uses the sp in the frame
 77   //     to determine the amount of free space on the stack.  We
 78   //     set the sp to a close approximation of the real value in
 79   //     order to allow this step to complete.
 80   //   - Step 120 (printing native stack) tries to walk the stack.
 81   //     The frame we create has a NULL pc, which is ignored as an
 82   //     invalid frame.
 83   frame dummy = frame();
 84   dummy.set_sp((intptr_t *) current_stack_pointer());
 85   return dummy;
 86 }
 87 
 88 char* os::non_memory_address_word() {
 89   // Must never look like an address returned by reserve_memory,
 90   // even in its subfields (as defined by the CPU immediate fields,
 91   // if the CPU splits constants across multiple instructions).
 92   // This is the value for x86; works pretty well for PPC too.
 93   return (char *) -1;
 94 }
 95 
 96 address os::Bsd::ucontext_get_pc(const ucontext_t* uc) {
 97   ShouldNotCallThis();
 98   return NULL;
 99 }
100 
101 void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
102   ShouldNotCallThis();
103 }
104 
<a name="2" id="anc2"></a><span class="line-modified">105 address os::fetch_frame_from_context(const void* ucVoid,</span>
<span class="line-modified">106                                      intptr_t** ret_sp,</span>
<span class="line-modified">107                                      intptr_t** ret_fp) {</span>
108   ShouldNotCallThis();
<a name="3" id="anc3"></a><span class="line-modified">109   return NULL;</span>
110 }
111 
112 frame os::fetch_frame_from_context(const void* ucVoid) {
113   ShouldNotCallThis();
114   return frame();
115 }
116 
117 extern &quot;C&quot; JNIEXPORT int
118 JVM_handle_bsd_signal(int sig,
119                         siginfo_t* info,
120                         void* ucVoid,
121                         int abort_if_unrecognized) {
122   ucontext_t* uc = (ucontext_t*) ucVoid;
123 
124   Thread* t = Thread::current_or_null_safe();
125 
126   SignalHandlerMark shm(t);
127 
128   // handle SafeFetch faults
129   if (sig == SIGSEGV || sig == SIGBUS) {
130     sigjmp_buf* const pjb = get_jmp_buf_for_continuation();
131     if (pjb) {
132       siglongjmp(*pjb, 1);
133     }
134   }
135 
136   // Note: it&#39;s not uncommon that JNI code uses signal/sigset to
137   // install then restore certain signal handler (e.g. to temporarily
138   // block SIGPIPE, or have a SIGILL handler when detecting CPU
139   // type). When that happens, JVM_handle_bsd_signal() might be
140   // invoked with junk info/ucVoid. To avoid unnecessary crash when
141   // libjsig is not preloaded, try handle signals that do not require
142   // siginfo/ucontext first.
143 
144   if (sig == SIGPIPE || sig == SIGXFSZ) {
145     // allow chained handler to go first
146     if (os::Bsd::chained_handler(sig, info, ucVoid)) {
147       return true;
148     } else {
149       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
150       return true;
151     }
152   }
153 
154   JavaThread* thread = NULL;
155   VMThread* vmthread = NULL;
156   if (os::Bsd::signal_handlers_are_installed) {
157     if (t != NULL ){
158       if(t-&gt;is_Java_thread()) {
159         thread = (JavaThread*)t;
160       }
161       else if(t-&gt;is_VM_thread()){
162         vmthread = (VMThread *)t;
163       }
164     }
165   }
166 
167   if (info != NULL &amp;&amp; thread != NULL) {
168     // Handle ALL stack overflow variations here
169     if (sig == SIGSEGV || sig == SIGBUS) {
170       address addr = (address) info-&gt;si_addr;
171 
172       // check if fault address is within thread stack
173       if (thread-&gt;is_in_full_stack(addr)) {
174         // stack overflow
175         if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
176           thread-&gt;disable_stack_yellow_reserved_zone();
177           ShouldNotCallThis();
178         }
179         else if (thread-&gt;in_stack_red_zone(addr)) {
180           thread-&gt;disable_stack_red_zone();
181           ShouldNotCallThis();
182         }
183       }
184     }
185 
186     /*if (thread-&gt;thread_state() == _thread_in_Java) {
187       ShouldNotCallThis();
188     }
189     else*/ if ((thread-&gt;thread_state() == _thread_in_vm ||
190                thread-&gt;thread_state() == _thread_in_native) &amp;&amp;
191                sig == SIGBUS &amp;&amp; thread-&gt;doing_unsafe_access()) {
192       ShouldNotCallThis();
193     }
194 
195     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC
196     // kicks in and the heap gets shrunk before the field access.
197     /*if (sig == SIGSEGV || sig == SIGBUS) {
198       address addr = JNI_FastGetField::find_slowcase_pc(pc);
199       if (addr != (address)-1) {
200         stub = addr;
201       }
202     }*/
203   }
204 
205   // signal-chaining
206   if (os::Bsd::chained_handler(sig, info, ucVoid)) {
207      return true;
208   }
209 
210   if (!abort_if_unrecognized) {
211     // caller wants another chance, so give it to him
212     return false;
213   }
214 
215 #ifndef PRODUCT
216   if (sig == SIGSEGV) {
217     fatal(&quot;\n#&quot;
218           &quot;\n#    /--------------------\\&quot;
219           &quot;\n#    | segmentation fault |&quot;
220           &quot;\n#    \\---\\ /--------------/&quot;
221           &quot;\n#        /&quot;
222           &quot;\n#    [-]        |\\_/|    &quot;
223           &quot;\n#    (+)=C      |o o|__  &quot;
224           &quot;\n#    | |        =-*-=__\\ &quot;
225           &quot;\n#    OOO        c_c_(___)&quot;);
226   }
227 #endif // !PRODUCT
228 
229   const char *fmt =
230       &quot;caught unhandled signal &quot; INT32_FORMAT &quot; at address &quot; PTR_FORMAT;
231   char buf[128];
232 
233   sprintf(buf, fmt, sig, info-&gt;si_addr);
234   fatal(buf);
235   return false;
236 }
237 
238 void os::Bsd::init_thread_fpu_state(void) {
239   // Nothing to do
240 }
241 
242 bool os::is_allocatable(size_t bytes) {
243 #ifdef _LP64
244   return true;
245 #else
246   if (bytes &lt; 2 * G) {
247     return true;
248   }
249 
250   char* addr = reserve_memory(bytes, NULL);
251 
252   if (addr != NULL) {
253     release_memory(addr, bytes);
254   }
255 
256   return addr != NULL;
257 #endif // _LP64
258 }
259 
260 ///////////////////////////////////////////////////////////////////////////////
261 // thread stack
262 
263 size_t os::Posix::_compiler_thread_min_stack_allowed = 64 * K;
264 size_t os::Posix::_java_thread_min_stack_allowed = 64 * K;
265 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 64 * K;
266 
267 size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
268 #ifdef _LP64
269   size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
270 #else
271   size_t s = (thr_type == os::compiler_thread ? 2 * M : 512 * K);
272 #endif // _LP64
273   return s;
274 }
275 
276 static void current_stack_region(address *bottom, size_t *size) {
277   address stack_bottom;
278   address stack_top;
279   size_t stack_bytes;
280 
281 #ifdef __APPLE__
282   pthread_t self = pthread_self();
283   stack_top = (address) pthread_get_stackaddr_np(self);
284   stack_bytes = pthread_get_stacksize_np(self);
285   stack_bottom = stack_top - stack_bytes;
286 #elif defined(__OpenBSD__)
287   stack_t ss;
288   int rslt = pthread_stackseg_np(pthread_self(), &amp;ss);
289 
290   if (rslt != 0)
291     fatal(&quot;pthread_stackseg_np failed with error = &quot; INT32_FORMAT, rslt);
292 
293   stack_top = (address) ss.ss_sp;
294   stack_bytes  = ss.ss_size;
295   stack_bottom = stack_top - stack_bytes;
296 #else
297   pthread_attr_t attr;
298 
299   int rslt = pthread_attr_init(&amp;attr);
300 
301   // JVM needs to know exact stack location, abort if it fails
302   if (rslt != 0)
303     fatal(&quot;pthread_attr_init failed with error = &quot; INT32_FORMAT, rslt);
304 
305   rslt = pthread_attr_get_np(pthread_self(), &amp;attr);
306 
307   if (rslt != 0)
308     fatal(&quot;pthread_attr_get_np failed with error = &quot; INT32_FORMAT, rslt);
309 
310   if (pthread_attr_getstackaddr(&amp;attr, (void **) &amp;stack_bottom) != 0 ||
311       pthread_attr_getstacksize(&amp;attr, &amp;stack_bytes) != 0) {
312     fatal(&quot;Can not locate current stack attributes!&quot;);
313   }
314 
315   pthread_attr_destroy(&amp;attr);
316 
317   stack_top = stack_bottom + stack_bytes;
318 #endif
319 
320   assert(os::current_stack_pointer() &gt;= stack_bottom, &quot;should do&quot;);
321   assert(os::current_stack_pointer() &lt; stack_top, &quot;should do&quot;);
322 
323   *bottom = stack_bottom;
324   *size = stack_top - stack_bottom;
325 }
326 
327 address os::current_stack_base() {
328   address bottom;
329   size_t size;
330   current_stack_region(&amp;bottom, &amp;size);
331   return bottom + size;
332 }
333 
334 size_t os::current_stack_size() {
335   // stack size includes normal stack and HotSpot guard pages
336   address bottom;
337   size_t size;
338   current_stack_region(&amp;bottom, &amp;size);
339   return size;
340 }
341 
342 /////////////////////////////////////////////////////////////////////////////
343 // helper functions for fatal error handler
344 
345 void os::print_context(outputStream* st, const void* context) {
346   ShouldNotCallThis();
347 }
348 
349 void os::print_register_info(outputStream *st, const void *context) {
350   ShouldNotCallThis();
351 }
352 
353 /////////////////////////////////////////////////////////////////////////////
354 // Stubs for things that would be in bsd_zero.s if it existed.
355 // You probably want to disassemble these monkeys to check they&#39;re ok.
356 
357 extern &quot;C&quot; {
358   int SpinPause() {
359     return 1;
360   }
361 
362   void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {
363     if (from &gt; to) {
364       const jshort *end = from + count;
365       while (from &lt; end)
366         *(to++) = *(from++);
367     }
368     else if (from &lt; to) {
369       const jshort *end = from;
370       from += count - 1;
371       to   += count - 1;
372       while (from &gt;= end)
373         *(to--) = *(from--);
374     }
375   }
376   void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {
377     if (from &gt; to) {
378       const jint *end = from + count;
379       while (from &lt; end)
380         *(to++) = *(from++);
381     }
382     else if (from &lt; to) {
383       const jint *end = from;
384       from += count - 1;
385       to   += count - 1;
386       while (from &gt;= end)
387         *(to--) = *(from--);
388     }
389   }
390   void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {
391     if (from &gt; to) {
392       const jlong *end = from + count;
393       while (from &lt; end)
394         os::atomic_copy64(from++, to++);
395     }
396     else if (from &lt; to) {
397       const jlong *end = from;
398       from += count - 1;
399       to   += count - 1;
400       while (from &gt;= end)
401         os::atomic_copy64(from--, to--);
402     }
403   }
404 
405   void _Copy_arrayof_conjoint_bytes(const HeapWord* from,
406                                     HeapWord* to,
407                                     size_t    count) {
408     memmove(to, from, count);
409   }
410   void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,
411                                       HeapWord* to,
412                                       size_t    count) {
413     memmove(to, from, count * 2);
414   }
415   void _Copy_arrayof_conjoint_jints(const HeapWord* from,
416                                     HeapWord* to,
417                                     size_t    count) {
418     memmove(to, from, count * 4);
419   }
420   void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,
421                                      HeapWord* to,
422                                      size_t    count) {
423     memmove(to, from, count * 8);
424   }
425 };
426 
427 /////////////////////////////////////////////////////////////////////////////
428 // Implementations of atomic operations not supported by processors.
429 //  -- http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Atomic-Builtins.html
430 
431 #ifndef _LP64
432 extern &quot;C&quot; {
433   long long unsigned int __sync_val_compare_and_swap_8(
434     volatile void *ptr,
435     long long unsigned int oldval,
436     long long unsigned int newval) {
437     ShouldNotCallThis();
438   }
439 };
440 #endif // !_LP64
441 
442 #ifndef PRODUCT
443 void os::verify_stack_alignment() {
444 }
445 #endif
446 
447 int os::extra_bang_size_in_bytes() {
448   // Zero does not require an additional stack bang.
449   return 0;
450 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/bsd_x86/os_bsd_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aix_ppc/os_aix_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_bsd_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/bsd_x86/os_bsd_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * questions.
  22  *
  23  */
  24 
  25 // no precompiled headers
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/icBuffer.hpp&quot;
  33 #include &quot;code/vtableStubs.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;os_share_bsd.hpp&quot;
  38 #include &quot;prims/jniFastGetField.hpp&quot;
  39 #include &quot;prims/jvm_misc.hpp&quot;
  40 #include &quot;runtime/arguments.hpp&quot;
<span class="line-removed">  41 #include &quot;runtime/extendedPC.hpp&quot;</span>
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  44 #include &quot;runtime/java.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/mutexLocker.hpp&quot;
  47 #include &quot;runtime/osThread.hpp&quot;
  48 #include &quot;runtime/safepointMechanism.hpp&quot;
  49 #include &quot;runtime/sharedRuntime.hpp&quot;
  50 #include &quot;runtime/stubRoutines.hpp&quot;
  51 #include &quot;runtime/thread.inline.hpp&quot;
  52 #include &quot;runtime/timer.hpp&quot;
  53 #include &quot;utilities/align.hpp&quot;
  54 #include &quot;utilities/events.hpp&quot;
  55 #include &quot;utilities/vmError.hpp&quot;
  56 
  57 // put OS-includes here
  58 # include &lt;sys/types.h&gt;
  59 # include &lt;sys/mman.h&gt;
  60 # include &lt;pthread.h&gt;
  61 # include &lt;signal.h&gt;
</pre>
<hr />
<pre>
 296 
 297   return (char*) -1;
 298 }
 299 
 300 address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {
 301   return (address)uc-&gt;context_pc;
 302 }
 303 
 304 void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
 305   uc-&gt;context_pc = (intptr_t)pc ;
 306 }
 307 
 308 intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {
 309   return (intptr_t*)uc-&gt;context_sp;
 310 }
 311 
 312 intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {
 313   return (intptr_t*)uc-&gt;context_fp;
 314 }
 315 
<span class="line-modified"> 316 // For Forte Analyzer AsyncGetCallTrace profiling support - thread</span>
<span class="line-removed"> 317 // is currently interrupted by SIGPROF.</span>
<span class="line-removed"> 318 // os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal</span>
<span class="line-removed"> 319 // frames. Currently we don&#39;t do that on Bsd, so it&#39;s the same as</span>
<span class="line-removed"> 320 // os::fetch_frame_from_context().</span>
<span class="line-removed"> 321 // This method is also used for stack overflow signal handling.</span>
<span class="line-removed"> 322 ExtendedPC os::Bsd::fetch_frame_from_ucontext(Thread* thread,</span>
<span class="line-removed"> 323   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {</span>
<span class="line-removed"> 324 </span>
<span class="line-removed"> 325   assert(thread != NULL, &quot;just checking&quot;);</span>
<span class="line-removed"> 326   assert(ret_sp != NULL, &quot;just checking&quot;);</span>
<span class="line-removed"> 327   assert(ret_fp != NULL, &quot;just checking&quot;);</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329   return os::fetch_frame_from_context(uc, ret_sp, ret_fp);</span>
<span class="line-removed"> 330 }</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,</span>
 333                     intptr_t** ret_sp, intptr_t** ret_fp) {
 334 
<span class="line-modified"> 335   ExtendedPC  epc;</span>
 336   const ucontext_t* uc = (const ucontext_t*)ucVoid;
 337 
 338   if (uc != NULL) {
<span class="line-modified"> 339     epc = ExtendedPC(os::Bsd::ucontext_get_pc(uc));</span>
 340     if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
 341     if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
 342   } else {
<span class="line-modified"> 343     // construct empty ExtendedPC for return value checking</span>
<span class="line-removed"> 344     epc = ExtendedPC(NULL);</span>
 345     if (ret_sp) *ret_sp = (intptr_t *)NULL;
 346     if (ret_fp) *ret_fp = (intptr_t *)NULL;
 347   }
 348 
 349   return epc;
 350 }
 351 
 352 frame os::fetch_frame_from_context(const void* ucVoid) {
 353   intptr_t* sp;
 354   intptr_t* fp;
<span class="line-modified"> 355   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);</span>
<span class="line-modified"> 356   return frame(sp, fp, epc.pc());</span>
<span class="line-removed"> 357 }</span>
<span class="line-removed"> 358 </span>
<span class="line-removed"> 359 frame os::fetch_frame_from_ucontext(Thread* thread, void* ucVoid) {</span>
<span class="line-removed"> 360   intptr_t* sp;</span>
<span class="line-removed"> 361   intptr_t* fp;</span>
<span class="line-removed"> 362   ExtendedPC epc = os::Bsd::fetch_frame_from_ucontext(thread, (ucontext_t*)ucVoid, &amp;sp, &amp;fp);</span>
<span class="line-removed"> 363   return frame(sp, fp, epc.pc());</span>
 364 }
 365 
 366 bool os::Bsd::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
 367   address pc = (address) os::Bsd::ucontext_get_pc(uc);
 368   if (Interpreter::contains(pc)) {
 369     // interpreter performs stack banging after the fixed frame header has
 370     // been generated while the compilers perform it before. To maintain
 371     // semantic consistency between interpreted and compiled frames, the
 372     // method returns the Java sender of the current frame.
<span class="line-modified"> 373     *fr = os::fetch_frame_from_ucontext(thread, uc);</span>
 374     if (!fr-&gt;is_first_java_frame()) {
 375       // get_frame_at_stack_banging_point() is only called when we
 376       // have well defined stacks so java_sender() calls do not need
 377       // to assert safe_for_sender() first.
 378       *fr = fr-&gt;java_sender();
 379     }
 380   } else {
 381     // more complex code with compiled code
 382     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
 383     CodeBlob* cb = CodeCache::find_blob(pc);
 384     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
 385       // Not sure where the pc points to, fallback to default
 386       // stack overflow handling
 387       return false;
 388     } else {
<span class="line-modified"> 389       *fr = os::fetch_frame_from_ucontext(thread, uc);</span>
 390       // in compiled code, the stack banging is performed just after the return pc
 391       // has been pushed on the stack
 392       *fr = frame(fr-&gt;sp() + 1, fr-&gt;fp(), (address)*(fr-&gt;sp()));
 393       if (!fr-&gt;is_java_frame()) {
 394         // See java_sender() comment above.
 395         *fr = fr-&gt;java_sender();
 396       }
 397     }
 398   }
 399   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
 400   return true;
 401 }
 402 
 403 // By default, gcc always save frame pointer (%ebp/%rbp) on stack. It may get
 404 // turned off by -fomit-frame-pointer,
 405 frame os::get_sender_for_C_frame(frame* fr) {
 406   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
 407 }
 408 
 409 intptr_t* _get_previous_fp() {
</pre>
</td>
<td>
<hr />
<pre>
  21  * questions.
  22  *
  23  */
  24 
  25 // no precompiled headers
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/icBuffer.hpp&quot;
  33 #include &quot;code/vtableStubs.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;os_share_bsd.hpp&quot;
  38 #include &quot;prims/jniFastGetField.hpp&quot;
  39 #include &quot;prims/jvm_misc.hpp&quot;
  40 #include &quot;runtime/arguments.hpp&quot;

  41 #include &quot;runtime/frame.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/java.hpp&quot;
  44 #include &quot;runtime/javaCalls.hpp&quot;
  45 #include &quot;runtime/mutexLocker.hpp&quot;
  46 #include &quot;runtime/osThread.hpp&quot;
  47 #include &quot;runtime/safepointMechanism.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/stubRoutines.hpp&quot;
  50 #include &quot;runtime/thread.inline.hpp&quot;
  51 #include &quot;runtime/timer.hpp&quot;
  52 #include &quot;utilities/align.hpp&quot;
  53 #include &quot;utilities/events.hpp&quot;
  54 #include &quot;utilities/vmError.hpp&quot;
  55 
  56 // put OS-includes here
  57 # include &lt;sys/types.h&gt;
  58 # include &lt;sys/mman.h&gt;
  59 # include &lt;pthread.h&gt;
  60 # include &lt;signal.h&gt;
</pre>
<hr />
<pre>
 295 
 296   return (char*) -1;
 297 }
 298 
 299 address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {
 300   return (address)uc-&gt;context_pc;
 301 }
 302 
 303 void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
 304   uc-&gt;context_pc = (intptr_t)pc ;
 305 }
 306 
 307 intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {
 308   return (intptr_t*)uc-&gt;context_sp;
 309 }
 310 
 311 intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {
 312   return (intptr_t*)uc-&gt;context_fp;
 313 }
 314 
<span class="line-modified"> 315 address os::fetch_frame_from_context(const void* ucVoid,</span>
















 316                     intptr_t** ret_sp, intptr_t** ret_fp) {
 317 
<span class="line-modified"> 318   address  epc;</span>
 319   const ucontext_t* uc = (const ucontext_t*)ucVoid;
 320 
 321   if (uc != NULL) {
<span class="line-modified"> 322     epc = os::Bsd::ucontext_get_pc(uc);</span>
 323     if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
 324     if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
 325   } else {
<span class="line-modified"> 326     epc = NULL;</span>

 327     if (ret_sp) *ret_sp = (intptr_t *)NULL;
 328     if (ret_fp) *ret_fp = (intptr_t *)NULL;
 329   }
 330 
 331   return epc;
 332 }
 333 
 334 frame os::fetch_frame_from_context(const void* ucVoid) {
 335   intptr_t* sp;
 336   intptr_t* fp;
<span class="line-modified"> 337   address epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);</span>
<span class="line-modified"> 338   return frame(sp, fp, epc);</span>







 339 }
 340 
 341 bool os::Bsd::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
 342   address pc = (address) os::Bsd::ucontext_get_pc(uc);
 343   if (Interpreter::contains(pc)) {
 344     // interpreter performs stack banging after the fixed frame header has
 345     // been generated while the compilers perform it before. To maintain
 346     // semantic consistency between interpreted and compiled frames, the
 347     // method returns the Java sender of the current frame.
<span class="line-modified"> 348     *fr = os::fetch_frame_from_context(uc);</span>
 349     if (!fr-&gt;is_first_java_frame()) {
 350       // get_frame_at_stack_banging_point() is only called when we
 351       // have well defined stacks so java_sender() calls do not need
 352       // to assert safe_for_sender() first.
 353       *fr = fr-&gt;java_sender();
 354     }
 355   } else {
 356     // more complex code with compiled code
 357     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
 358     CodeBlob* cb = CodeCache::find_blob(pc);
 359     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
 360       // Not sure where the pc points to, fallback to default
 361       // stack overflow handling
 362       return false;
 363     } else {
<span class="line-modified"> 364       *fr = os::fetch_frame_from_context(uc);</span>
 365       // in compiled code, the stack banging is performed just after the return pc
 366       // has been pushed on the stack
 367       *fr = frame(fr-&gt;sp() + 1, fr-&gt;fp(), (address)*(fr-&gt;sp()));
 368       if (!fr-&gt;is_java_frame()) {
 369         // See java_sender() comment above.
 370         *fr = fr-&gt;java_sender();
 371       }
 372     }
 373   }
 374   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
 375   return true;
 376 }
 377 
 378 // By default, gcc always save frame pointer (%ebp/%rbp) on stack. It may get
 379 // turned off by -fomit-frame-pointer,
 380 frame os::get_sender_for_C_frame(frame* fr) {
 381   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
 382 }
 383 
 384 intptr_t* _get_previous_fp() {
</pre>
</td>
</tr>
</table>
<center><a href="../aix_ppc/os_aix_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_bsd_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jshell/share/classes/jdk/internal/jshell/tool/ConsoleIOContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.jshell.tool;
  27 
  28 import jdk.jshell.SourceCodeAnalysis.Documentation;
  29 import jdk.jshell.SourceCodeAnalysis.QualifiedNames;
  30 import jdk.jshell.SourceCodeAnalysis.Suggestion;
  31 
  32 import java.io.IOException;
  33 import java.io.InputStream;
  34 import java.io.InterruptedIOException;
  35 import java.io.OutputStream;
  36 import java.io.PrintStream;
  37 import java.net.URI;
  38 import java.nio.charset.Charset;
  39 import java.time.Instant;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.Collection;
  43 import java.util.Collections;
  44 import java.util.HashMap;
  45 import java.util.Iterator;
  46 import java.util.List;
  47 import java.util.ListIterator;
  48 import java.util.Map;
  49 import java.util.Optional;
  50 import java.util.function.Function;
  51 import java.util.stream.Collectors;
  52 import java.util.stream.Stream;
  53 import java.util.stream.StreamSupport;
  54 import javax.tools.DiagnosticListener;
  55 import javax.tools.JavaFileObject;
  56 import javax.tools.SimpleJavaFileObject;
  57 
  58 import jdk.internal.shellsupport.doc.JavadocFormatter;
  59 import jdk.internal.jshell.tool.StopDetectingInputStream.State;
  60 import jdk.internal.misc.Signal;
  61 import jdk.internal.misc.Signal.Handler;
  62 import jdk.internal.org.jline.keymap.KeyMap;
  63 import jdk.internal.org.jline.reader.Binding;
  64 import jdk.internal.org.jline.reader.EOFError;
  65 import jdk.internal.org.jline.reader.EndOfFileException;
  66 import jdk.internal.org.jline.reader.History;
  67 import jdk.internal.org.jline.reader.LineReader;
  68 import jdk.internal.org.jline.reader.LineReader.Option;
  69 import jdk.internal.org.jline.reader.Parser;
  70 import jdk.internal.org.jline.reader.UserInterruptException;
  71 import jdk.internal.org.jline.reader.Widget;
  72 import jdk.internal.org.jline.reader.impl.LineReaderImpl;
  73 import jdk.internal.org.jline.reader.impl.completer.ArgumentCompleter.ArgumentLine;
  74 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  75 import jdk.internal.org.jline.terminal.impl.LineDisciplineTerminal;
  76 import jdk.internal.org.jline.terminal.Attributes;
  77 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  78 import jdk.internal.org.jline.terminal.Attributes.LocalFlag;
  79 import jdk.internal.org.jline.terminal.Size;
  80 import jdk.internal.org.jline.terminal.Terminal;
  81 import jdk.internal.org.jline.terminal.TerminalBuilder;
  82 import jdk.internal.org.jline.utils.Display;
  83 import jdk.internal.org.jline.utils.NonBlocking;
  84 import jdk.internal.org.jline.utils.NonBlockingInputStreamImpl;
  85 import jdk.internal.org.jline.utils.NonBlockingReader;
  86 import jdk.jshell.ExpressionSnippet;
  87 import jdk.jshell.Snippet;
  88 import jdk.jshell.Snippet.SubKind;
  89 import jdk.jshell.SourceCodeAnalysis.CompletionInfo;
  90 import jdk.jshell.VarSnippet;
  91 
  92 class ConsoleIOContext extends IOContext {
  93 
  94     private static final String HISTORY_LINE_PREFIX = &quot;HISTORY_LINE_&quot;;
  95 
  96     final boolean allowIncompleteInputs;
  97     final JShellTool repl;
  98     final StopDetectingInputStream input;
  99     final Attributes originalAttributes;
 100     final LineReaderImpl in;
 101     final History userInputHistory = new DefaultHistory();
 102     final Instant historyLoad;
 103 
 104     String prefix = &quot;&quot;;
 105 
 106     ConsoleIOContext(JShellTool repl, InputStream cmdin, PrintStream cmdout) throws Exception {
 107         this.allowIncompleteInputs = Boolean.getBoolean(&quot;jshell.test.allow.incomplete.inputs&quot;);
 108         this.repl = repl;
 109         Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;();
 110         this.input = new StopDetectingInputStream(() -&gt; repl.stop(),
 111                                                   ex -&gt; repl.hard(&quot;Error on input: %s&quot;, ex));
 112         InputStream nonBlockingInput = new NonBlockingInputStreamImpl(null, input) {
 113             @Override
 114             public int readBuffered(byte[] b) throws IOException {
 115                 return input.read(b);
 116             }
 117         };
 118         Terminal terminal;
 119         if (System.getProperty(&quot;test.jdk&quot;) != null) {
 120             terminal = new TestTerminal(nonBlockingInput, cmdout);
 121             input.setInputStream(cmdin);
 122         } else {
 123             terminal = TerminalBuilder.builder().inputStreamWrapper(in -&gt; {
 124                 input.setInputStream(in);
 125                 return nonBlockingInput;
 126             }).build();
 127         }
 128         originalAttributes = terminal.getAttributes();
 129         Attributes noIntr = new Attributes(originalAttributes);
 130         noIntr.setControlChar(ControlChar.VINTR, 0);
 131         terminal.setAttributes(noIntr);
 132         terminal.enterRawMode();
 133         LineReaderImpl reader = new LineReaderImpl(terminal, &quot;jshell&quot;, variables) {
 134             {
 135                 //jline can handle the CONT signal on its own, but (currently) requires sun.misc for it
 136                 try {
 137                     Signal.handle(new Signal(&quot;CONT&quot;), new Handler() {
 138                         @Override public void handle(Signal sig) {
 139                             try {
 140                                 handleSignal(jdk.internal.org.jline.terminal.Terminal.Signal.CONT);
 141                             } catch (Exception ex) {
 142                                 ex.printStackTrace();
 143                             }
 144                         }
 145                     });
 146                 } catch (IllegalArgumentException ignored) {
 147                     //the CONT signal does not exist on this platform
 148                 }
 149             }
 150             CompletionState completionState = new CompletionState();
 151             @Override
 152             protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {
 153                 return ConsoleIOContext.this.complete(completionState);
 154             }
 155             @Override
 156             public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
 157                 completionState.actionCount++;
 158                 return super.readBinding(keys, local);
 159             }
 160             @Override
 161             protected boolean insertCloseParen() {
 162                 Object oldIndent = getVariable(INDENTATION);
 163                 try {
 164                     setVariable(INDENTATION, 0);
 165                     return super.insertCloseParen();
 166                 } finally {
 167                     setVariable(INDENTATION, oldIndent);
 168                 }
 169             }
 170             @Override
 171             protected boolean insertCloseSquare() {
 172                 Object oldIndent = getVariable(INDENTATION);
 173                 try {
 174                     setVariable(INDENTATION, 0);
 175                     return super.insertCloseSquare();
 176                 } finally {
 177                     setVariable(INDENTATION, oldIndent);
 178                 }
 179             }
 180         };
 181 
 182         reader.setOpt(Option.DISABLE_EVENT_EXPANSION);
 183 
 184         reader.setParser((line, cursor, context) -&gt; {
 185             if (!allowIncompleteInputs &amp;&amp; !repl.isComplete(line)) {
 186                 int pendingBraces = countPendingOpenBraces(line);
 187                 throw new EOFError(cursor, cursor, line, null, pendingBraces, null);
 188             }
 189             return new ArgumentLine(line, cursor);
 190         });
 191 
 192         reader.getKeyMaps().get(LineReader.MAIN)
 193               .bind((Widget) () -&gt; fixes(), FIXES_SHORTCUT);
 194         reader.getKeyMaps().get(LineReader.MAIN)
 195               .bind((Widget) () -&gt; { throw new UserInterruptException(&quot;&quot;); }, &quot;\003&quot;);
 196 
 197         List&lt;String&gt; loadHistory = new ArrayList&lt;&gt;();
 198         Stream.of(repl.prefs.keys())
 199               .filter(key -&gt; key.startsWith(HISTORY_LINE_PREFIX))
 200               .sorted()
 201               .map(key -&gt; repl.prefs.get(key))
 202               .forEach(loadHistory::add);
 203 
 204         for (ListIterator&lt;String&gt; it = loadHistory.listIterator(); it.hasNext(); ) {
 205             String current = it.next();
 206 
 207             int trailingBackSlashes = countTrailintBackslashes(current);
 208             boolean continuation = trailingBackSlashes % 2 != 0;
 209             current = current.substring(0, current.length() - trailingBackSlashes / 2 - (continuation ? 1 : 0));
 210             if (continuation &amp;&amp; it.hasNext()) {
 211                 String next = it.next();
 212                 it.remove();
 213                 it.previous();
 214                 current += &quot;\n&quot; + next;
 215             }
 216 
 217             it.set(current);
 218         }
 219 
 220         historyLoad = Instant.MIN;
 221         loadHistory.forEach(line -&gt; reader.getHistory().add(historyLoad, line));
 222 
 223         in = reader;
 224     }
 225 
 226     @Override
 227     public String readLine(String firstLinePrompt, String continuationPrompt,
 228                            boolean firstLine, String prefix) throws IOException, InputInterruptedException {
 229         assert firstLine || allowIncompleteInputs;
 230         this.prefix = prefix;
 231         try {
 232             in.setVariable(LineReader.SECONDARY_PROMPT_PATTERN, continuationPrompt);
 233             return in.readLine(firstLinePrompt);
 234         } catch (UserInterruptException ex) {
 235             throw (InputInterruptedException) new InputInterruptedException().initCause(ex);
 236         } catch (EndOfFileException ex) {
 237             return null;
 238         }
 239     }
 240 
 241     @Override
 242     public boolean interactiveOutput() {
 243         return true;
 244     }
 245 
 246     @Override
 247     public Iterable&lt;String&gt; history(boolean currentSession) {
 248         return StreamSupport.stream(getHistory().spliterator(), false)
 249                             .filter(entry -&gt; !currentSession || !historyLoad.equals(entry.time()))
 250                             .map(entry -&gt; entry.line())
 251                             .collect(Collectors.toList());
 252     }
 253 
 254     @Override
 255     public void close() throws IOException {
 256         //save history:
 257         for (String key : repl.prefs.keys()) {
 258             if (key.startsWith(HISTORY_LINE_PREFIX)) {
 259                 repl.prefs.remove(key);
 260             }
 261         }
 262         Collection&lt;String&gt; savedHistory =
 263             StreamSupport.stream(in.getHistory().spliterator(), false)
 264                          .map(History.Entry::line)
 265                          .flatMap(this::toSplitEntries)
 266                          .collect(Collectors.toList());
 267         if (!savedHistory.isEmpty()) {
 268             int len = (int) Math.ceil(Math.log10(savedHistory.size()+1));
 269             String format = HISTORY_LINE_PREFIX + &quot;%0&quot; + len + &quot;d&quot;;
 270             int index = 0;
 271             for (String historyLine : savedHistory) {
 272                 repl.prefs.put(String.format(format, index++), historyLine);
 273             }
 274         }
 275         repl.prefs.flush();
 276         try {
 277             in.getTerminal().setAttributes(originalAttributes);
 278             in.getTerminal().close();
 279         } catch (Exception ex) {
 280             throw new IOException(ex);
 281         }
 282         input.shutdown();
 283     }
 284 
 285     private Stream&lt;String&gt; toSplitEntries(String entry) {
 286         String[] lines = entry.split(&quot;\n&quot;);
 287         List&lt;String&gt; result = new ArrayList&lt;&gt;();
 288 
 289         for (int i = 0; i &lt; lines.length; i++) {
 290             StringBuilder historyLine = new StringBuilder(lines[i]);
 291             int trailingBackSlashes = countTrailintBackslashes(historyLine);
 292             for (int j = 0; j &lt; trailingBackSlashes; j++) {
 293                 historyLine.append(&quot;\\&quot;);
 294             }
 295             if (i + 1 &lt; lines.length) {
 296                 historyLine.append(&quot;\\&quot;);
 297             }
 298             result.add(historyLine.toString());
 299         }
 300 
 301         return result.stream();
 302     }
 303 
 304     private int countTrailintBackslashes(CharSequence text) {
 305         int count = 0;
 306 
 307         for (int i = text.length() - 1; i &gt;= 0; i--) {
 308             if (text.charAt(i) == &#39;\\&#39;) {
 309                 count++;
 310             } else {
 311                 break;
 312             }
 313         }
 314 
 315         return count;
 316     }
 317 
 318     @Override
 319     public void setIndent(int indent) {
 320         in.variable(LineReader.INDENTATION, indent);
 321     }
 322 
 323     private static final String FIXES_SHORTCUT = &quot;\033\133\132&quot;; //Shift-TAB
 324 
 325     private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);
 326     private static final String LINE_SEPARATORS2 = LINE_SEPARATOR + LINE_SEPARATOR;
 327 
 328     /*XXX:*/private static final int AUTOPRINT_THRESHOLD = 100;
 329     @SuppressWarnings(&quot;fallthrough&quot;)
 330     private boolean complete(CompletionState completionState) {
 331         //The completion has multiple states (invoked by subsequent presses of &lt;tab&gt;).
 332         //On the first invocation in a given sequence, all steps are precomputed
 333         //and placed into the todo list (completionState.todo). The todo list is
 334         //then followed on both the first and subsequent completion invocations:
 335         try {
 336             String text = in.getBuffer().toString();
 337             int cursor = in.getBuffer().cursor();
 338 
 339             List&lt;CompletionTask&gt; todo = completionState.todo;
 340 
 341             if (todo.isEmpty() || completionState.actionCount != 1) {
 342                 ConsoleIOContextTestSupport.willComputeCompletion();
 343                 int[] anchor = new int[] {-1};
 344                 List&lt;Suggestion&gt; suggestions;
 345                 List&lt;String&gt; doc;
 346                 boolean command = prefix.isEmpty() &amp;&amp; text.startsWith(&quot;/&quot;);
 347                 if (command) {
 348                     suggestions = repl.commandCompletionSuggestions(text, cursor, anchor);
 349                     doc = repl.commandDocumentation(text, cursor, true);
 350                 } else {
 351                     int prefixLength = prefix.length();
 352                     suggestions = repl.analysis.completionSuggestions(prefix + text, cursor + prefixLength, anchor);
 353                     anchor[0] -= prefixLength;
 354                     doc = repl.analysis.documentation(prefix + text, cursor + prefix.length(), false)
 355                                        .stream()
 356                                        .map(Documentation::signature)
 357                                        .collect(Collectors.toList());
 358                 }
 359                 long smartCount = suggestions.stream().filter(Suggestion::matchesType).count();
 360                 boolean hasSmart = smartCount &gt; 0 &amp;&amp; smartCount &lt;= /*in.getAutoprintThreshold()*/AUTOPRINT_THRESHOLD;
 361                 boolean hasBoth = hasSmart &amp;&amp;
 362                                   suggestions.stream()
 363                                              .map(s -&gt; s.matchesType())
 364                                              .distinct()
 365                                              .count() == 2;
 366                 boolean tooManyItems = suggestions.size() &gt; /*in.getAutoprintThreshold()*/AUTOPRINT_THRESHOLD;
 367                 CompletionTask ordinaryCompletion =
 368                         new OrdinaryCompletionTask(suggestions,
 369                                                    anchor[0],
 370                                                    !command &amp;&amp; !doc.isEmpty(),
 371                                                    hasBoth);
 372                 CompletionTask allCompletion = new AllSuggestionsCompletionTask(suggestions, anchor[0]);
 373 
 374                 todo = new ArrayList&lt;&gt;();
 375 
 376                 //the main decission tree:
 377                 if (command) {
 378                     CompletionTask shortDocumentation = new CommandSynopsisTask(doc);
 379                     CompletionTask fullDocumentation = new CommandFullDocumentationTask(todo);
 380 
 381                     if (!doc.isEmpty()) {
 382                         if (tooManyItems) {
 383                             todo.add(new NoopCompletionTask());
 384                             todo.add(allCompletion);
 385                         } else {
 386                             todo.add(ordinaryCompletion);
 387                         }
 388                         todo.add(shortDocumentation);
 389                         todo.add(fullDocumentation);
 390                     } else {
 391                         todo.add(new NoSuchCommandCompletionTask());
 392                     }
 393                 } else {
 394                     if (doc.isEmpty()) {
 395                         if (hasSmart) {
 396                             todo.add(ordinaryCompletion);
 397                         } else if (tooManyItems) {
 398                             todo.add(new NoopCompletionTask());
 399                         }
 400                         if (!hasSmart || hasBoth) {
 401                             todo.add(allCompletion);
 402                         }
 403                     } else {
 404                         CompletionTask shortDocumentation = new ExpressionSignaturesTask(doc);
 405                         CompletionTask fullDocumentation = new ExpressionJavadocTask(todo);
 406 
 407                         if (hasSmart) {
 408                             todo.add(ordinaryCompletion);
 409                         }
 410                         todo.add(shortDocumentation);
 411                         if (!hasSmart || hasBoth) {
 412                             todo.add(allCompletion);
 413                         }
 414                         if (tooManyItems) {
 415                             todo.add(todo.size() - 1, fullDocumentation);
 416                         } else {
 417                             todo.add(fullDocumentation);
 418                         }
 419                     }
 420                 }
 421             }
 422 
 423             boolean success = false;
 424             boolean repaint = true;
 425 
 426             OUTER: while (!todo.isEmpty()) {
 427                 CompletionTask.Result result = todo.remove(0).perform(text, cursor);
 428 
 429                 switch (result) {
 430                     case CONTINUE:
 431                         break;
 432                     case SKIP_NOREPAINT:
 433                         repaint = false;
 434                     case SKIP:
 435                         todo.clear();
 436                         //intentional fall-through
 437                     case FINISH:
 438                         success = true;
 439                         //intentional fall-through
 440                     case NO_DATA:
 441                         if (!todo.isEmpty()) {
 442                             in.getTerminal().writer().println();
 443                             in.getTerminal().writer().println(todo.get(0).description());
 444                         }
 445                         break OUTER;
 446                 }
 447             }
 448 
 449             completionState.actionCount = 0;
 450             completionState.todo = todo;
 451 
 452             if (repaint) {
 453                 in.redrawLine();
 454                 in.flush();
 455             }
 456 
 457             return success;
 458         } catch (IOException ex) {
 459             throw new IllegalStateException(ex);
 460         }
 461     }
 462 
 463     private CompletionTask.Result doPrintFullDocumentation(List&lt;CompletionTask&gt; todo, List&lt;String&gt; doc, boolean command) {
 464         if (doc != null &amp;&amp; !doc.isEmpty()) {
 465             Terminal term = in.getTerminal();
 466             int pageHeight = term.getHeight() - NEEDED_LINES;
 467             List&lt;CompletionTask&gt; thisTODO = new ArrayList&lt;&gt;();
 468 
 469             for (Iterator&lt;String&gt; docIt = doc.iterator(); docIt.hasNext(); ) {
 470                 String currentDoc = docIt.next();
 471                 String[] lines = currentDoc.split(&quot;\n&quot;);
 472                 int firstLine = 0;
 473 
 474                 while (firstLine &lt; lines.length) {
 475                     boolean first = firstLine == 0;
 476                     String[] thisPageLines =
 477                             Arrays.copyOfRange(lines,
 478                                                firstLine,
 479                                                Math.min(firstLine + pageHeight, lines.length));
 480 
 481                     thisTODO.add(new CompletionTask() {
 482                         @Override
 483                         public String description() {
 484                             String key =  !first ? &quot;jshell.console.see.next.page&quot;
 485                                                  : command ? &quot;jshell.console.see.next.command.doc&quot;
 486                                                            : &quot;jshell.console.see.next.javadoc&quot;;
 487 
 488                             return repl.getResourceString(key);
 489                         }
 490 
 491                         @Override
 492                         public Result perform(String text, int cursor) throws IOException {
 493                             in.getTerminal().writer().println();
 494                             for (String line : thisPageLines) {
 495                                 in.getTerminal().writer().println(line);
 496                             }
 497                             return Result.FINISH;
 498                         }
 499                     });
 500 
 501                     firstLine += pageHeight;
 502                 }
 503             }
 504 
 505             todo.addAll(0, thisTODO);
 506 
 507             return CompletionTask.Result.CONTINUE;
 508         }
 509 
 510         return CompletionTask.Result.FINISH;
 511     }
 512     //where:
 513         private static final int NEEDED_LINES = 4;
 514 
 515     private static String commonPrefix(String str1, String str2) {
 516         for (int i = 0; i &lt; str2.length(); i++) {
 517             if (!str1.startsWith(str2.substring(0, i + 1))) {
 518                 return str2.substring(0, i);
 519             }
 520         }
 521 
 522         return str2;
 523     }
 524 
 525     private interface CompletionTask {
 526         public String description();
 527         public Result perform(String text, int cursor) throws IOException;
 528 
 529         enum Result {
 530             NO_DATA,
 531             CONTINUE,
 532             FINISH,
 533             SKIP,
 534             SKIP_NOREPAINT;
 535         }
 536     }
 537 
 538     private final class NoopCompletionTask implements CompletionTask {
 539 
 540         @Override
 541         public String description() {
 542             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 543         }
 544 
 545         @Override
 546         public Result perform(String text, int cursor) throws IOException {
 547             return Result.FINISH;
 548         }
 549 
 550     }
 551 
 552     private final class NoSuchCommandCompletionTask implements CompletionTask {
 553 
 554         @Override
 555         public String description() {
 556             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 557         }
 558 
 559         @Override
 560         public Result perform(String text, int cursor) throws IOException {
 561             in.getTerminal().writer().println();
 562             in.getTerminal().writer().println(repl.getResourceString(&quot;jshell.console.no.such.command&quot;));
 563             in.getTerminal().writer().println();
 564             return Result.SKIP;
 565         }
 566 
 567     }
 568 
 569     private final class OrdinaryCompletionTask implements CompletionTask {
 570         private final List&lt;Suggestion&gt; suggestions;
 571         private final int anchor;
 572         private final boolean cont;
 573         private final boolean showSmart;
 574 
 575         public OrdinaryCompletionTask(List&lt;Suggestion&gt; suggestions,
 576                                       int anchor,
 577                                       boolean cont,
 578                                       boolean showSmart) {
 579             this.suggestions = suggestions;
 580             this.anchor = anchor;
 581             this.cont = cont;
 582             this.showSmart = showSmart;
 583         }
 584 
 585         @Override
 586         public String description() {
 587             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 588         }
 589 
 590         @Override
 591         public Result perform(String text, int cursor) throws IOException {
 592             List&lt;CharSequence&gt; toShow;
 593 
 594             if (showSmart) {
 595                 toShow =
 596                     suggestions.stream()
 597                                .filter(Suggestion::matchesType)
 598                                .map(Suggestion::continuation)
 599                                .distinct()
 600                                .collect(Collectors.toList());
 601             } else {
 602                 toShow =
 603                     suggestions.stream()
 604                                .map(Suggestion::continuation)
 605                                .distinct()
 606                                .collect(Collectors.toList());
 607             }
 608 
 609             if (toShow.isEmpty()) {
 610                 return Result.CONTINUE;
 611             }
 612 
 613             Optional&lt;String&gt; prefix =
 614                     suggestions.stream()
 615                                .map(Suggestion::continuation)
 616                                .reduce(ConsoleIOContext::commonPrefix);
 617 
 618             String prefixStr = prefix.orElse(&quot;&quot;).substring(cursor - anchor);
 619             in.putString(prefixStr);
 620 
 621             boolean showItems = toShow.size() &gt; 1 || showSmart;
 622 
 623             if (showItems) {
 624                 in.getTerminal().writer().println();
 625                 printColumns(toShow);
 626             }
 627 
 628             if (!prefixStr.isEmpty())
 629                 return showItems ? Result.FINISH : Result.SKIP_NOREPAINT;
 630 
 631             return cont ? Result.CONTINUE : Result.FINISH;
 632         }
 633 
 634     }
 635 
 636     private final class AllSuggestionsCompletionTask implements CompletionTask {
 637         private final List&lt;Suggestion&gt; suggestions;
 638         private final int anchor;
 639 
 640         public AllSuggestionsCompletionTask(List&lt;Suggestion&gt; suggestions,
 641                                             int anchor) {
 642             this.suggestions = suggestions;
 643             this.anchor = anchor;
 644         }
 645 
 646         @Override
 647         public String description() {
 648             if (suggestions.size() &lt;= /*in.getAutoprintThreshold()*/AUTOPRINT_THRESHOLD) {
 649                 return repl.getResourceString(&quot;jshell.console.completion.all.completions&quot;);
 650             } else {
 651                 return repl.messageFormat(&quot;jshell.console.completion.all.completions.number&quot;, suggestions.size());
 652             }
 653         }
 654 
 655         @Override
 656         public Result perform(String text, int cursor) throws IOException {
 657             List&lt;String&gt; candidates =
 658                     suggestions.stream()
 659                                .map(Suggestion::continuation)
 660                                .distinct()
 661                                .collect(Collectors.toList());
 662 
 663             Optional&lt;String&gt; prefix =
 664                     candidates.stream()
 665                               .reduce(ConsoleIOContext::commonPrefix);
 666 
 667             String prefixStr = prefix.map(str -&gt; str.substring(cursor - anchor)).orElse(&quot;&quot;);
 668             in.putString(prefixStr);
 669             if (candidates.size() &gt; 1) {
 670                 in.getTerminal().writer().println();
 671                 printColumns(candidates);
 672             }
 673             return suggestions.isEmpty() ? Result.NO_DATA : Result.FINISH;
 674         }
 675 
 676     }
 677 
 678     private void printColumns(List&lt;? extends CharSequence&gt; candidates) {
 679         if (candidates.isEmpty()) return ;
 680         int size = candidates.stream().mapToInt(CharSequence::length).max().getAsInt() + 3;
 681         int columns = in.getTerminal().getWidth() / size;
 682         int c = 0;
 683         for (CharSequence cand : candidates) {
 684             in.getTerminal().writer().print(cand);
 685             for (int s = cand.length(); s &lt; size; s++) {
 686                 in.getTerminal().writer().print(&quot; &quot;);
 687             }
 688             if (++c == columns) {
 689                 in.getTerminal().writer().println();
 690                 c = 0;
 691             }
 692         }
 693         if (c != 0) {
 694             in.getTerminal().writer().println();
 695         }
 696     }
 697 
 698     private final class CommandSynopsisTask implements CompletionTask {
 699 
 700         private final List&lt;String&gt; synopsis;
 701 
 702         public CommandSynopsisTask(List&lt;String&gt; synposis) {
 703             this.synopsis = synposis;
 704         }
 705 
 706         @Override
 707         public String description() {
 708             return repl.getResourceString(&quot;jshell.console.see.synopsis&quot;);
 709         }
 710 
 711         @Override
 712         public Result perform(String text, int cursor) throws IOException {
 713 //            try {
 714                 in.getTerminal().writer().println();
 715                 in.getTerminal().writer().println(synopsis.stream()
 716                                    .map(l -&gt; l.replaceAll(&quot;\n&quot;, LINE_SEPARATOR))
 717                                    .collect(Collectors.joining(LINE_SEPARATORS2)));
 718 //            } catch (IOException ex) {
 719 //                throw new IllegalStateException(ex);
 720 //            }
 721             return Result.FINISH;
 722         }
 723 
 724     }
 725 
 726     private final class CommandFullDocumentationTask implements CompletionTask {
 727 
 728         private final List&lt;CompletionTask&gt; todo;
 729 
 730         public CommandFullDocumentationTask(List&lt;CompletionTask&gt; todo) {
 731             this.todo = todo;
 732         }
 733 
 734         @Override
 735         public String description() {
 736             return repl.getResourceString(&quot;jshell.console.see.full.documentation&quot;);
 737         }
 738 
 739         @Override
 740         public Result perform(String text, int cursor) throws IOException {
 741             List&lt;String&gt; fullDoc = repl.commandDocumentation(text, cursor, false);
 742             return doPrintFullDocumentation(todo, fullDoc, true);
 743         }
 744 
 745     }
 746 
 747     private final class ExpressionSignaturesTask implements CompletionTask {
 748 
 749         private final List&lt;String&gt; doc;
 750 
 751         public ExpressionSignaturesTask(List&lt;String&gt; doc) {
 752             this.doc = doc;
 753         }
 754 
 755         @Override
 756         public String description() {
 757             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 758         }
 759 
 760         @Override
 761         public Result perform(String text, int cursor) throws IOException {
 762             in.getTerminal().writer().println();
 763             in.getTerminal().writer().println(repl.getResourceString(&quot;jshell.console.completion.current.signatures&quot;));
 764             in.getTerminal().writer().println(doc.stream().collect(Collectors.joining(LINE_SEPARATOR)));
 765             return Result.FINISH;
 766         }
 767 
 768     }
 769 
 770     private final class ExpressionJavadocTask implements CompletionTask {
 771 
 772         private final List&lt;CompletionTask&gt; todo;
 773 
 774         public ExpressionJavadocTask(List&lt;CompletionTask&gt; todo) {
 775             this.todo = todo;
 776         }
 777 
 778         @Override
 779         public String description() {
 780             return repl.getResourceString(&quot;jshell.console.see.documentation&quot;);
 781         }
 782 
 783         @Override
 784         public Result perform(String text, int cursor) throws IOException {
 785             //schedule showing javadoc:
 786             Terminal term = in.getTerminal();
 787             JavadocFormatter formatter = new JavadocFormatter(term.getWidth(),
 788                                                               true);
 789             Function&lt;Documentation, String&gt; convertor = d -&gt; formatter.formatJavadoc(d.signature(), d.javadoc()) +
 790                              (d.javadoc() == null ? repl.messageFormat(&quot;jshell.console.no.javadoc&quot;)
 791                                                   : &quot;&quot;);
 792             List&lt;String&gt; doc = repl.analysis.documentation(prefix + text, cursor + prefix.length(), true)
 793                                             .stream()
 794                                             .map(convertor)
 795                                             .collect(Collectors.toList());
 796             return doPrintFullDocumentation(todo, doc, false);
 797         }
 798 
 799     }
 800 
 801     @Override
 802     public boolean terminalEditorRunning() {
 803         Terminal terminal = in.getTerminal();
 804         return !terminal.getAttributes().getLocalFlag(LocalFlag.ICANON);
 805     }
 806 
 807     @Override
 808     public void suspend() {
 809     }
 810 
 811     @Override
 812     public void resume() {
 813     }
 814 
 815     @Override
 816     public void beforeUserCode() {
 817         synchronized (this) {
 818             inputBytes = null;
 819         }
 820         input.setState(State.BUFFER);
 821     }
 822 
 823     @Override
 824     public void afterUserCode() {
 825         input.setState(State.WAIT);
 826     }
 827 
 828     @Override
 829     public void replaceLastHistoryEntry(String source) {
 830         var it = in.getHistory().iterator();
 831         while (it.hasNext()) {
 832             it.next();
 833         }
 834         it.remove();
 835         in.getHistory().add(source);
 836     }
 837 
 838     private static final long ESCAPE_TIMEOUT = 100;
 839 
 840     private boolean fixes() {
 841         try {
 842             int c = in.getTerminal().reader().read();
 843 
 844             if (c == (-1)) {
 845                 return true; //TODO: true or false???
 846             }
 847 
 848             for (FixComputer computer : FIX_COMPUTERS) {
 849                 if (computer.shortcut == c) {
 850                     fixes(computer);
 851                     return true; //TODO: true of false???
 852                 }
 853             }
 854 
 855             readOutRemainingEscape(c);
 856 
 857             in.beep();
 858             in.getTerminal().writer().println();
 859             in.getTerminal().writer().println(repl.getResourceString(&quot;jshell.fix.wrong.shortcut&quot;));
 860             in.redrawLine();
 861             in.flush();
 862         } catch (IOException ex) {
 863             ex.printStackTrace();
 864         }
 865         return true;
 866     }
 867 
 868     private void readOutRemainingEscape(int c) throws IOException {
 869         if (c == &#39;\033&#39;) {
 870             //escape, consume waiting input:
 871             NonBlockingReader inp = in.getTerminal().reader();
 872 
 873             while (inp.peek(ESCAPE_TIMEOUT) &gt; 0) {
 874                 inp.read();
 875             }
 876         }
 877     }
 878 
 879     //compute possible options/Fixes based on the selected FixComputer, present them to the user,
 880     //and perform the selected one:
 881     private void fixes(FixComputer computer) {
 882         String input = prefix + in.getBuffer().toString();
 883         int cursor = prefix.length() + in.getBuffer().cursor();
 884         FixResult candidates = computer.compute(repl, input, cursor);
 885 
 886         try {
 887             final boolean printError = candidates.error != null &amp;&amp; !candidates.error.isEmpty();
 888             if (printError) {
 889                 in.getTerminal().writer().println(candidates.error);
 890             }
 891             if (candidates.fixes.isEmpty()) {
 892                 in.beep();
 893                 if (printError) {
 894                     in.redrawLine();
 895                     in.flush();
 896                 }
 897             } else if (candidates.fixes.size() == 1 &amp;&amp; !computer.showMenu) {
 898                 if (printError) {
 899                     in.redrawLine();
 900                     in.flush();
 901                 }
 902                 candidates.fixes.get(0).perform(in);
 903             } else {
 904                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;(candidates.fixes);
 905                 fixes.add(0, new Fix() {
 906                     @Override
 907                     public String displayName() {
 908                         return repl.messageFormat(&quot;jshell.console.do.nothing&quot;);
 909                     }
 910 
 911                     @Override
 912                     public void perform(LineReaderImpl in) throws IOException {
 913                         in.redrawLine();
 914                     }
 915                 });
 916 
 917                 Map&lt;Character, Fix&gt; char2Fix = new HashMap&lt;&gt;();
 918                 in.getTerminal().writer().println();
 919                 for (int i = 0; i &lt; fixes.size(); i++) {
 920                     Fix fix = fixes.get(i);
 921                     char2Fix.put((char) (&#39;0&#39; + i), fix);
 922                     in.getTerminal().writer().println(&quot;&quot; + i + &quot;: &quot; + fixes.get(i).displayName());
 923                 }
 924                 in.getTerminal().writer().print(repl.messageFormat(&quot;jshell.console.choice&quot;));
 925                 in.flush();
 926                 int read;
 927 
 928                 read = in.readCharacter();
 929 
 930                 Fix fix = char2Fix.get((char) read);
 931 
 932                 if (fix == null) {
 933                     in.beep();
 934                     fix = fixes.get(0);
 935                 }
 936 
 937                 in.getTerminal().writer().println();
 938 
 939                 fix.perform(in);
 940 
 941                 in.flush();
 942             }
 943         } catch (IOException ex) {
 944             throw new IllegalStateException(ex);
 945         }
 946     }
 947 
 948     private byte[] inputBytes;
 949     private int inputBytesPointer;
 950 
 951     @Override
 952     public synchronized int readUserInput() throws IOException {
 953         while (inputBytes == null || inputBytes.length &lt;= inputBytesPointer) {
 954             History prevHistory = in.getHistory();
 955             boolean prevDisableCr = Display.DISABLE_CR;
 956             Parser prevParser = in.getParser();
 957 
 958             try {
 959                 in.setParser((line, cursor, context) -&gt; new ArgumentLine(line, cursor));
 960                 input.setState(State.WAIT);
 961                 Display.DISABLE_CR = true;
 962                 in.setHistory(userInputHistory);
 963                 inputBytes = (in.readLine(&quot;&quot;) + System.getProperty(&quot;line.separator&quot;)).getBytes();
 964                 inputBytesPointer = 0;
 965             } catch (UserInterruptException ex) {
 966                 throw new InterruptedIOException();
 967             } finally {
 968                 in.setParser(prevParser);
 969                 in.setHistory(prevHistory);
 970                 input.setState(State.BUFFER);
 971                 Display.DISABLE_CR = prevDisableCr;
 972             }
 973         }
 974         return inputBytes[inputBytesPointer++];
 975     }
 976 
 977     private int countPendingOpenBraces(String code) {
 978         int pendingBraces = 0;
 979         com.sun.tools.javac.util.Context ctx =
 980                 new com.sun.tools.javac.util.Context();
 981         SimpleJavaFileObject source = new SimpleJavaFileObject(URI.create(&quot;mem://snippet&quot;),
 982                                                                JavaFileObject.Kind.SOURCE) {
 983             @Override
 984             public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
 985                 return code;
 986             }
 987         };
 988         ctx.put(DiagnosticListener.class, d -&gt; {});
 989         com.sun.tools.javac.util.Log.instance(ctx).useSource(source);
 990         com.sun.tools.javac.parser.ScannerFactory scannerFactory =
 991                 com.sun.tools.javac.parser.ScannerFactory.instance(ctx);
 992         com.sun.tools.javac.parser.Scanner scanner =
 993                 scannerFactory.newScanner(code, false);
 994 
 995         while (true) {
 996             switch (scanner.token().kind) {
 997                 case LBRACE: pendingBraces++; break;
 998                 case RBRACE: pendingBraces--; break;
 999                 case EOF: return pendingBraces;
1000             }
1001             scanner.nextToken();
1002         }
1003     }
1004 
1005     /**
1006      * A possible action which the user can choose to perform.
1007      */
1008     public interface Fix {
1009         /**
1010          * A name that should be shown to the user.
1011          */
1012         public String displayName();
1013         /**
1014          * Perform the given action.
1015          */
1016         public void perform(LineReaderImpl in) throws IOException;
1017     }
1018 
1019     /**
1020      * A factory for {@link Fix}es.
1021      */
1022     public abstract static class FixComputer {
1023         private final char shortcut;
1024         private final boolean showMenu;
1025 
1026         /**
1027          * Construct a new FixComputer. {@code shortcut} defines the key which should trigger this FixComputer.
1028          * If {@code showMenu} is {@code false}, and this computer returns exactly one {@code Fix},
1029          * no options will be show to the user, and the given {@code Fix} will be performed.
1030          */
1031         public FixComputer(char shortcut, boolean showMenu) {
1032             this.shortcut = shortcut;
1033             this.showMenu = showMenu;
1034         }
1035 
1036         /**
1037          * Compute possible actions for the given code.
1038          */
1039         public abstract FixResult compute(JShellTool repl, String code, int cursor);
1040     }
1041 
1042     /**
1043      * A list of {@code Fix}es with a possible error that should be shown to the user.
1044      */
1045     public static class FixResult {
1046         public final List&lt;Fix&gt; fixes;
1047         public final String error;
1048 
1049         public FixResult(List&lt;Fix&gt; fixes, String error) {
1050             this.fixes = fixes;
1051             this.error = error;
1052         }
1053     }
1054 
1055     private static final FixComputer[] FIX_COMPUTERS = new FixComputer[] {
1056         new FixComputer(&#39;v&#39;, false) { //compute &quot;Introduce variable&quot; Fix:
1057             private void performToVar(LineReaderImpl in, String type) throws IOException {
1058                 in.redrawLine();
1059                 in.getBuffer().cursor(0);
1060                 in.putString(type + &quot;  = &quot;);
1061                 in.getBuffer().cursor(in.getBuffer().cursor() - 3);
1062                 in.flush();
1063             }
1064 
1065             @Override
1066             public FixResult compute(JShellTool repl, String code, int cursor) {
1067                 String type = repl.analysis.analyzeType(code, cursor);
1068                 if (type == null) {
1069                     return new FixResult(Collections.emptyList(), null);
1070                 }
1071                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;();
1072                 fixes.add(new Fix() {
1073                     @Override
1074                     public String displayName() {
1075                         return repl.messageFormat(&quot;jshell.console.create.variable&quot;);
1076                     }
1077 
1078                     @Override
1079                     public void perform(LineReaderImpl in) throws IOException {
1080                         performToVar(in, type);
1081                     }
1082                 });
1083                 int idx = type.lastIndexOf(&quot;.&quot;);
1084                 if (idx &gt; 0) {
1085                     String stype = type.substring(idx + 1);
1086                     QualifiedNames res = repl.analysis.listQualifiedNames(stype, stype.length());
1087                     if (res.isUpToDate() &amp;&amp; res.getNames().contains(type)
1088                             &amp;&amp; !res.isResolvable()) {
1089                         fixes.add(new Fix() {
1090                             @Override
1091                             public String displayName() {
1092                                 return &quot;import: &quot; + type + &quot;. &quot; +
1093                                         repl.messageFormat(&quot;jshell.console.create.variable&quot;);
1094                             }
1095 
1096                             @Override
1097                             public void perform(LineReaderImpl in) throws IOException {
1098                                 repl.processSource(&quot;import &quot; + type + &quot;;&quot;);
1099                                 in.getTerminal().writer().println(&quot;Imported: &quot; + type);
1100                                 performToVar(in, stype);
1101                             }
1102                         });
1103                     }
1104                 }
1105                 return new FixResult(fixes, null);
1106             }
1107         },
1108         new FixComputer(&#39;m&#39;, false) { //compute &quot;Introduce method&quot; Fix:
1109             private void performToMethod(LineReaderImpl in, String type, String code) throws IOException {
1110                 in.redrawLine();
1111                 if (!code.trim().endsWith(&quot;;&quot;)) {
1112                     in.putString(&quot;;&quot;);
1113                 }
1114                 in.putString(&quot; }&quot;);
1115                 in.getBuffer().cursor(0);
1116                 String afterCursor = type.equals(&quot;void&quot;)
1117                         ? &quot;() { &quot;
1118                         : &quot;() { return &quot;;
1119                 in.putString(type + &quot; &quot; + afterCursor);
1120                 // position the cursor where the method name should be entered (before parens)
1121                 in.getBuffer().cursor(in.getBuffer().cursor() - afterCursor.length());
1122                 in.flush();
1123             }
1124 
1125             private FixResult reject(JShellTool repl, String messageKey) {
1126                 return new FixResult(Collections.emptyList(), repl.messageFormat(messageKey));
1127             }
1128 
1129             @Override
1130             public FixResult compute(JShellTool repl, String code, int cursor) {
1131                 final String codeToCursor = code.substring(0, cursor);
1132                 final String type;
1133                 final CompletionInfo ci = repl.analysis.analyzeCompletion(codeToCursor);
1134                 if (!ci.remaining().isEmpty()) {
1135                     return reject(repl, &quot;jshell.console.exprstmt&quot;);
1136                 }
1137                 switch (ci.completeness()) {
1138                     case COMPLETE:
1139                     case COMPLETE_WITH_SEMI:
1140                     case CONSIDERED_INCOMPLETE:
1141                         break;
1142                     case EMPTY:
1143                         return reject(repl, &quot;jshell.console.empty&quot;);
1144                     case DEFINITELY_INCOMPLETE:
1145                     case UNKNOWN:
1146                     default:
1147                         return reject(repl, &quot;jshell.console.erroneous&quot;);
1148                 }
1149                 List&lt;Snippet&gt; snl = repl.analysis.sourceToSnippets(ci.source());
1150                 if (snl.size() != 1) {
1151                     return reject(repl, &quot;jshell.console.erroneous&quot;);
1152                 }
1153                 Snippet sn = snl.get(0);
1154                 switch (sn.kind()) {
1155                     case EXPRESSION:
1156                         type = ((ExpressionSnippet) sn).typeName();
1157                         break;
1158                     case STATEMENT:
1159                         type = &quot;void&quot;;
1160                         break;
1161                     case VAR:
1162                         if (sn.subKind() != SubKind.TEMP_VAR_EXPRESSION_SUBKIND) {
1163                             // only valid var is an expression turned into a temp var
1164                             return reject(repl, &quot;jshell.console.exprstmt&quot;);
1165                         }
1166                         type = ((VarSnippet) sn).typeName();
1167                         break;
1168                     case IMPORT:
1169                     case METHOD:
1170                     case TYPE_DECL:
1171                         return reject(repl, &quot;jshell.console.exprstmt&quot;);
1172                     case ERRONEOUS:
1173                     default:
1174                         return reject(repl, &quot;jshell.console.erroneous&quot;);
1175                 }
1176                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;();
1177                 fixes.add(new Fix() {
1178                     @Override
1179                     public String displayName() {
1180                         return repl.messageFormat(&quot;jshell.console.create.method&quot;);
1181                     }
1182 
1183                     @Override
1184                     public void perform(LineReaderImpl in) throws IOException {
1185                         performToMethod(in, type, codeToCursor);
1186                     }
1187                 });
1188                 int idx = type.lastIndexOf(&quot;.&quot;);
1189                 if (idx &gt; 0) {
1190                     String stype = type.substring(idx + 1);
1191                     QualifiedNames res = repl.analysis.listQualifiedNames(stype, stype.length());
1192                     if (res.isUpToDate() &amp;&amp; res.getNames().contains(type)
1193                             &amp;&amp; !res.isResolvable()) {
1194                         fixes.add(new Fix() {
1195                             @Override
1196                             public String displayName() {
1197                                 return &quot;import: &quot; + type + &quot;. &quot; +
1198                                         repl.messageFormat(&quot;jshell.console.create.method&quot;);
1199                             }
1200 
1201                             @Override
1202                             public void perform(LineReaderImpl in) throws IOException {
1203                                 repl.processSource(&quot;import &quot; + type + &quot;;&quot;);
1204                                 in.getTerminal().writer().println(&quot;Imported: &quot; + type);
1205                                 performToMethod(in, stype, codeToCursor);
1206                             }
1207                         });
1208                     }
1209                 }
1210                 return new FixResult(fixes, null);
1211             }
1212         },
1213         new FixComputer(&#39;i&#39;, true) { //compute &quot;Add import&quot; Fixes:
1214             @Override
1215             public FixResult compute(JShellTool repl, String code, int cursor) {
1216                 QualifiedNames res = repl.analysis.listQualifiedNames(code, cursor);
1217                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;();
1218                 for (String fqn : res.getNames()) {
1219                     fixes.add(new Fix() {
1220                         @Override
1221                         public String displayName() {
1222                             return &quot;import: &quot; + fqn;
1223                         }
1224 
1225                         @Override
1226                         public void perform(LineReaderImpl in) throws IOException {
1227                             repl.processSource(&quot;import &quot; + fqn + &quot;;&quot;);
1228                             in.getTerminal().writer().println(&quot;Imported: &quot; + fqn);
1229                             in.redrawLine();
1230                         }
1231                     });
1232                 }
1233                 if (res.isResolvable()) {
1234                     return new FixResult(Collections.emptyList(),
1235                             repl.messageFormat(&quot;jshell.console.resolvable&quot;));
1236                 } else {
1237                     String error = &quot;&quot;;
1238                     if (fixes.isEmpty()) {
1239                         error = repl.messageFormat(&quot;jshell.console.no.candidate&quot;);
1240                     }
1241                     if (!res.isUpToDate()) {
1242                         error += repl.messageFormat(&quot;jshell.console.incomplete&quot;);
1243                     }
1244                     return new FixResult(fixes, error);
1245                 }
1246             }
1247         }
1248     };
1249 
1250     private History getHistory() {
1251         return in.getHistory();
1252     }
1253 
1254     private static final class TestTerminal extends LineDisciplineTerminal {
1255 
1256         private static final int DEFAULT_HEIGHT = 24;
1257 
1258         private final NonBlockingReader inputReader;
1259 
1260         public TestTerminal(InputStream input, OutputStream output) throws Exception {
1261             super(&quot;test&quot;, &quot;ansi&quot;, output, Charset.forName(&quot;UTF-8&quot;));
1262             this.inputReader = NonBlocking.nonBlocking(getName(), input, encoding());
1263             Attributes a = new Attributes(getAttributes());
1264             a.setLocalFlag(LocalFlag.ECHO, false);
1265             setAttributes(attributes);
1266             int h = DEFAULT_HEIGHT;
1267             try {
1268                 String hp = System.getProperty(&quot;test.terminal.height&quot;);
1269                 if (hp != null &amp;&amp; !hp.isEmpty()) {
1270                     h = Integer.parseInt(hp);
1271                 }
1272             } catch (Throwable ex) {
1273                 // ignore
1274             }
1275             setSize(new Size(80, h));
1276         }
1277 
1278         @Override
1279         public NonBlockingReader reader() {
1280             return inputReader;
1281         }
1282 
1283         @Override
1284         protected void doClose() throws IOException {
1285             super.doClose();
1286             slaveInput.close();
1287             inputReader.close();
1288         }
1289 
1290     }
1291 
1292     private static final class CompletionState {
1293         /**The number of actions since the last completion invocation. Will be 1 when completion is
1294          * invoked immediately after the last completion invocation.*/
1295         public int actionCount;
1296         /**Precomputed completion actions. Should only be reused if actionCount == 1.*/
1297         public List&lt;CompletionTask&gt; todo = Collections.emptyList();
1298     }
1299 
1300 }
    </pre>
  </body>
</html>
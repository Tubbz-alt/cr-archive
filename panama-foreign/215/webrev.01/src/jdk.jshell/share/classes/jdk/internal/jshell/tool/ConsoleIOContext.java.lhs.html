<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jshell/share/classes/jdk/internal/jshell/tool/ConsoleIOContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.jshell.tool;
  27 
  28 import jdk.jshell.SourceCodeAnalysis.Documentation;
  29 import jdk.jshell.SourceCodeAnalysis.QualifiedNames;
  30 import jdk.jshell.SourceCodeAnalysis.Suggestion;
  31 
  32 import java.io.IOException;
  33 import java.io.InputStream;
  34 import java.io.InterruptedIOException;
  35 import java.io.OutputStream;
  36 import java.io.PrintStream;
<a name="2" id="anc2"></a>
  37 import java.nio.charset.Charset;
  38 import java.time.Instant;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.Collection;
  42 import java.util.Collections;
  43 import java.util.HashMap;
  44 import java.util.Iterator;
  45 import java.util.List;
  46 import java.util.ListIterator;
  47 import java.util.Map;
  48 import java.util.Optional;
  49 import java.util.function.Function;
  50 import java.util.stream.Collectors;
  51 import java.util.stream.Stream;
  52 import java.util.stream.StreamSupport;
<a name="3" id="anc3"></a>


  53 
  54 import jdk.internal.shellsupport.doc.JavadocFormatter;
  55 import jdk.internal.jshell.tool.StopDetectingInputStream.State;
  56 import jdk.internal.misc.Signal;
  57 import jdk.internal.misc.Signal.Handler;
  58 import jdk.internal.org.jline.keymap.KeyMap;
  59 import jdk.internal.org.jline.reader.Binding;
  60 import jdk.internal.org.jline.reader.EOFError;
  61 import jdk.internal.org.jline.reader.EndOfFileException;
  62 import jdk.internal.org.jline.reader.History;
  63 import jdk.internal.org.jline.reader.LineReader;
  64 import jdk.internal.org.jline.reader.LineReader.Option;
  65 import jdk.internal.org.jline.reader.Parser;
  66 import jdk.internal.org.jline.reader.UserInterruptException;
  67 import jdk.internal.org.jline.reader.Widget;
  68 import jdk.internal.org.jline.reader.impl.LineReaderImpl;
  69 import jdk.internal.org.jline.reader.impl.completer.ArgumentCompleter.ArgumentLine;
  70 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  71 import jdk.internal.org.jline.terminal.impl.LineDisciplineTerminal;
  72 import jdk.internal.org.jline.terminal.Attributes;
  73 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  74 import jdk.internal.org.jline.terminal.Attributes.LocalFlag;
  75 import jdk.internal.org.jline.terminal.Size;
  76 import jdk.internal.org.jline.terminal.Terminal;
  77 import jdk.internal.org.jline.terminal.TerminalBuilder;
  78 import jdk.internal.org.jline.utils.Display;
  79 import jdk.internal.org.jline.utils.NonBlocking;
  80 import jdk.internal.org.jline.utils.NonBlockingInputStreamImpl;
  81 import jdk.internal.org.jline.utils.NonBlockingReader;
  82 import jdk.jshell.ExpressionSnippet;
  83 import jdk.jshell.Snippet;
  84 import jdk.jshell.Snippet.SubKind;
  85 import jdk.jshell.SourceCodeAnalysis.CompletionInfo;
  86 import jdk.jshell.VarSnippet;
  87 
  88 class ConsoleIOContext extends IOContext {
  89 
  90     private static final String HISTORY_LINE_PREFIX = &quot;HISTORY_LINE_&quot;;
  91 
  92     final boolean allowIncompleteInputs;
  93     final JShellTool repl;
  94     final StopDetectingInputStream input;
  95     final Attributes originalAttributes;
  96     final LineReaderImpl in;
  97     final History userInputHistory = new DefaultHistory();
  98     final Instant historyLoad;
  99 
 100     String prefix = &quot;&quot;;
 101 
 102     ConsoleIOContext(JShellTool repl, InputStream cmdin, PrintStream cmdout) throws Exception {
 103         this.allowIncompleteInputs = Boolean.getBoolean(&quot;jshell.test.allow.incomplete.inputs&quot;);
 104         this.repl = repl;
 105         Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;();
 106         this.input = new StopDetectingInputStream(() -&gt; repl.stop(),
 107                                                   ex -&gt; repl.hard(&quot;Error on input: %s&quot;, ex));
 108         InputStream nonBlockingInput = new NonBlockingInputStreamImpl(null, input) {
 109             @Override
 110             public int readBuffered(byte[] b) throws IOException {
 111                 return input.read(b);
 112             }
 113         };
 114         Terminal terminal;
 115         if (System.getProperty(&quot;test.jdk&quot;) != null) {
 116             terminal = new TestTerminal(nonBlockingInput, cmdout);
 117             input.setInputStream(cmdin);
 118         } else {
 119             terminal = TerminalBuilder.builder().inputStreamWrapper(in -&gt; {
 120                 input.setInputStream(in);
 121                 return nonBlockingInput;
 122             }).build();
 123         }
 124         originalAttributes = terminal.getAttributes();
 125         Attributes noIntr = new Attributes(originalAttributes);
 126         noIntr.setControlChar(ControlChar.VINTR, 0);
 127         terminal.setAttributes(noIntr);
 128         terminal.enterRawMode();
 129         LineReaderImpl reader = new LineReaderImpl(terminal, &quot;jshell&quot;, variables) {
 130             {
 131                 //jline can handle the CONT signal on its own, but (currently) requires sun.misc for it
 132                 try {
 133                     Signal.handle(new Signal(&quot;CONT&quot;), new Handler() {
 134                         @Override public void handle(Signal sig) {
 135                             try {
 136                                 handleSignal(jdk.internal.org.jline.terminal.Terminal.Signal.CONT);
 137                             } catch (Exception ex) {
 138                                 ex.printStackTrace();
 139                             }
 140                         }
 141                     });
 142                 } catch (IllegalArgumentException ignored) {
 143                     //the CONT signal does not exist on this platform
 144                 }
 145             }
 146             CompletionState completionState = new CompletionState();
 147             @Override
 148             protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {
 149                 return ConsoleIOContext.this.complete(completionState);
 150             }
 151             @Override
 152             public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
 153                 completionState.actionCount++;
 154                 return super.readBinding(keys, local);
 155             }
 156             @Override
 157             protected boolean insertCloseParen() {
 158                 Object oldIndent = getVariable(INDENTATION);
 159                 try {
 160                     setVariable(INDENTATION, 0);
 161                     return super.insertCloseParen();
 162                 } finally {
 163                     setVariable(INDENTATION, oldIndent);
 164                 }
 165             }
 166             @Override
 167             protected boolean insertCloseSquare() {
 168                 Object oldIndent = getVariable(INDENTATION);
 169                 try {
 170                     setVariable(INDENTATION, 0);
 171                     return super.insertCloseSquare();
 172                 } finally {
 173                     setVariable(INDENTATION, oldIndent);
 174                 }
 175             }
 176         };
 177 
 178         reader.setOpt(Option.DISABLE_EVENT_EXPANSION);
 179 
 180         reader.setParser((line, cursor, context) -&gt; {
 181             if (!allowIncompleteInputs &amp;&amp; !repl.isComplete(line)) {
 182                 int pendingBraces = countPendingOpenBraces(line);
 183                 throw new EOFError(cursor, cursor, line, null, pendingBraces, null);
 184             }
 185             return new ArgumentLine(line, cursor);
 186         });
 187 
 188         reader.getKeyMaps().get(LineReader.MAIN)
 189               .bind((Widget) () -&gt; fixes(), FIXES_SHORTCUT);
 190         reader.getKeyMaps().get(LineReader.MAIN)
 191               .bind((Widget) () -&gt; { throw new UserInterruptException(&quot;&quot;); }, &quot;\003&quot;);
 192 
 193         List&lt;String&gt; loadHistory = new ArrayList&lt;&gt;();
 194         Stream.of(repl.prefs.keys())
 195               .filter(key -&gt; key.startsWith(HISTORY_LINE_PREFIX))
 196               .sorted()
 197               .map(key -&gt; repl.prefs.get(key))
 198               .forEach(loadHistory::add);
 199 
 200         for (ListIterator&lt;String&gt; it = loadHistory.listIterator(); it.hasNext(); ) {
 201             String current = it.next();
 202 
 203             int trailingBackSlashes = countTrailintBackslashes(current);
 204             boolean continuation = trailingBackSlashes % 2 != 0;
 205             current = current.substring(0, current.length() - trailingBackSlashes / 2 - (continuation ? 1 : 0));
 206             if (continuation &amp;&amp; it.hasNext()) {
 207                 String next = it.next();
 208                 it.remove();
 209                 it.previous();
 210                 current += &quot;\n&quot; + next;
 211             }
 212 
 213             it.set(current);
 214         }
 215 
 216         historyLoad = Instant.MIN;
 217         loadHistory.forEach(line -&gt; reader.getHistory().add(historyLoad, line));
 218 
 219         in = reader;
 220     }
 221 
 222     @Override
 223     public String readLine(String firstLinePrompt, String continuationPrompt,
 224                            boolean firstLine, String prefix) throws IOException, InputInterruptedException {
 225         assert firstLine || allowIncompleteInputs;
 226         this.prefix = prefix;
 227         try {
 228             in.setVariable(LineReader.SECONDARY_PROMPT_PATTERN, continuationPrompt);
 229             return in.readLine(firstLinePrompt);
 230         } catch (UserInterruptException ex) {
 231             throw (InputInterruptedException) new InputInterruptedException().initCause(ex);
 232         } catch (EndOfFileException ex) {
 233             return null;
 234         }
 235     }
 236 
 237     @Override
 238     public boolean interactiveOutput() {
 239         return true;
 240     }
 241 
 242     @Override
 243     public Iterable&lt;String&gt; history(boolean currentSession) {
 244         return StreamSupport.stream(getHistory().spliterator(), false)
 245                             .filter(entry -&gt; !currentSession || !historyLoad.equals(entry.time()))
 246                             .map(entry -&gt; entry.line())
 247                             .collect(Collectors.toList());
 248     }
 249 
 250     @Override
 251     public void close() throws IOException {
 252         //save history:
 253         for (String key : repl.prefs.keys()) {
 254             if (key.startsWith(HISTORY_LINE_PREFIX)) {
 255                 repl.prefs.remove(key);
 256             }
 257         }
 258         Collection&lt;String&gt; savedHistory =
 259             StreamSupport.stream(in.getHistory().spliterator(), false)
 260                          .map(History.Entry::line)
 261                          .flatMap(this::toSplitEntries)
 262                          .collect(Collectors.toList());
 263         if (!savedHistory.isEmpty()) {
 264             int len = (int) Math.ceil(Math.log10(savedHistory.size()+1));
 265             String format = HISTORY_LINE_PREFIX + &quot;%0&quot; + len + &quot;d&quot;;
 266             int index = 0;
 267             for (String historyLine : savedHistory) {
 268                 repl.prefs.put(String.format(format, index++), historyLine);
 269             }
 270         }
 271         repl.prefs.flush();
 272         try {
 273             in.getTerminal().setAttributes(originalAttributes);
 274             in.getTerminal().close();
 275         } catch (Exception ex) {
 276             throw new IOException(ex);
 277         }
 278         input.shutdown();
 279     }
 280 
 281     private Stream&lt;String&gt; toSplitEntries(String entry) {
 282         String[] lines = entry.split(&quot;\n&quot;);
 283         List&lt;String&gt; result = new ArrayList&lt;&gt;();
 284 
 285         for (int i = 0; i &lt; lines.length; i++) {
 286             StringBuilder historyLine = new StringBuilder(lines[i]);
 287             int trailingBackSlashes = countTrailintBackslashes(historyLine);
 288             for (int j = 0; j &lt; trailingBackSlashes; j++) {
 289                 historyLine.append(&quot;\\&quot;);
 290             }
 291             if (i + 1 &lt; lines.length) {
 292                 historyLine.append(&quot;\\&quot;);
 293             }
 294             result.add(historyLine.toString());
 295         }
 296 
 297         return result.stream();
 298     }
 299 
 300     private int countTrailintBackslashes(CharSequence text) {
 301         int count = 0;
 302 
 303         for (int i = text.length() - 1; i &gt;= 0; i--) {
 304             if (text.charAt(i) == &#39;\\&#39;) {
 305                 count++;
 306             } else {
 307                 break;
 308             }
 309         }
 310 
 311         return count;
 312     }
 313 
 314     @Override
 315     public void setIndent(int indent) {
 316         in.variable(LineReader.INDENTATION, indent);
 317     }
 318 
 319     private static final String FIXES_SHORTCUT = &quot;\033\133\132&quot;; //Shift-TAB
 320 
 321     private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;);
 322     private static final String LINE_SEPARATORS2 = LINE_SEPARATOR + LINE_SEPARATOR;
 323 
 324     /*XXX:*/private static final int AUTOPRINT_THRESHOLD = 100;
 325     @SuppressWarnings(&quot;fallthrough&quot;)
 326     private boolean complete(CompletionState completionState) {
 327         //The completion has multiple states (invoked by subsequent presses of &lt;tab&gt;).
 328         //On the first invocation in a given sequence, all steps are precomputed
 329         //and placed into the todo list (completionState.todo). The todo list is
 330         //then followed on both the first and subsequent completion invocations:
 331         try {
 332             String text = in.getBuffer().toString();
 333             int cursor = in.getBuffer().cursor();
 334 
 335             List&lt;CompletionTask&gt; todo = completionState.todo;
 336 
 337             if (todo.isEmpty() || completionState.actionCount != 1) {
 338                 ConsoleIOContextTestSupport.willComputeCompletion();
 339                 int[] anchor = new int[] {-1};
 340                 List&lt;Suggestion&gt; suggestions;
 341                 List&lt;String&gt; doc;
 342                 boolean command = prefix.isEmpty() &amp;&amp; text.startsWith(&quot;/&quot;);
 343                 if (command) {
 344                     suggestions = repl.commandCompletionSuggestions(text, cursor, anchor);
 345                     doc = repl.commandDocumentation(text, cursor, true);
 346                 } else {
 347                     int prefixLength = prefix.length();
 348                     suggestions = repl.analysis.completionSuggestions(prefix + text, cursor + prefixLength, anchor);
 349                     anchor[0] -= prefixLength;
 350                     doc = repl.analysis.documentation(prefix + text, cursor + prefix.length(), false)
 351                                        .stream()
 352                                        .map(Documentation::signature)
 353                                        .collect(Collectors.toList());
 354                 }
 355                 long smartCount = suggestions.stream().filter(Suggestion::matchesType).count();
 356                 boolean hasSmart = smartCount &gt; 0 &amp;&amp; smartCount &lt;= /*in.getAutoprintThreshold()*/AUTOPRINT_THRESHOLD;
 357                 boolean hasBoth = hasSmart &amp;&amp;
 358                                   suggestions.stream()
 359                                              .map(s -&gt; s.matchesType())
 360                                              .distinct()
 361                                              .count() == 2;
 362                 boolean tooManyItems = suggestions.size() &gt; /*in.getAutoprintThreshold()*/AUTOPRINT_THRESHOLD;
 363                 CompletionTask ordinaryCompletion =
 364                         new OrdinaryCompletionTask(suggestions,
 365                                                    anchor[0],
 366                                                    !command &amp;&amp; !doc.isEmpty(),
 367                                                    hasBoth);
 368                 CompletionTask allCompletion = new AllSuggestionsCompletionTask(suggestions, anchor[0]);
 369 
 370                 todo = new ArrayList&lt;&gt;();
 371 
 372                 //the main decission tree:
 373                 if (command) {
 374                     CompletionTask shortDocumentation = new CommandSynopsisTask(doc);
 375                     CompletionTask fullDocumentation = new CommandFullDocumentationTask(todo);
 376 
 377                     if (!doc.isEmpty()) {
 378                         if (tooManyItems) {
 379                             todo.add(new NoopCompletionTask());
 380                             todo.add(allCompletion);
 381                         } else {
 382                             todo.add(ordinaryCompletion);
 383                         }
 384                         todo.add(shortDocumentation);
 385                         todo.add(fullDocumentation);
 386                     } else {
 387                         todo.add(new NoSuchCommandCompletionTask());
 388                     }
 389                 } else {
 390                     if (doc.isEmpty()) {
 391                         if (hasSmart) {
 392                             todo.add(ordinaryCompletion);
 393                         } else if (tooManyItems) {
 394                             todo.add(new NoopCompletionTask());
 395                         }
 396                         if (!hasSmart || hasBoth) {
 397                             todo.add(allCompletion);
 398                         }
 399                     } else {
 400                         CompletionTask shortDocumentation = new ExpressionSignaturesTask(doc);
 401                         CompletionTask fullDocumentation = new ExpressionJavadocTask(todo);
 402 
 403                         if (hasSmart) {
 404                             todo.add(ordinaryCompletion);
 405                         }
 406                         todo.add(shortDocumentation);
 407                         if (!hasSmart || hasBoth) {
 408                             todo.add(allCompletion);
 409                         }
 410                         if (tooManyItems) {
 411                             todo.add(todo.size() - 1, fullDocumentation);
 412                         } else {
 413                             todo.add(fullDocumentation);
 414                         }
 415                     }
 416                 }
 417             }
 418 
 419             boolean success = false;
 420             boolean repaint = true;
 421 
 422             OUTER: while (!todo.isEmpty()) {
 423                 CompletionTask.Result result = todo.remove(0).perform(text, cursor);
 424 
 425                 switch (result) {
 426                     case CONTINUE:
 427                         break;
 428                     case SKIP_NOREPAINT:
 429                         repaint = false;
 430                     case SKIP:
 431                         todo.clear();
 432                         //intentional fall-through
 433                     case FINISH:
 434                         success = true;
 435                         //intentional fall-through
 436                     case NO_DATA:
 437                         if (!todo.isEmpty()) {
 438                             in.getTerminal().writer().println();
 439                             in.getTerminal().writer().println(todo.get(0).description());
 440                         }
 441                         break OUTER;
 442                 }
 443             }
 444 
 445             completionState.actionCount = 0;
 446             completionState.todo = todo;
 447 
 448             if (repaint) {
 449                 in.redrawLine();
 450                 in.flush();
 451             }
 452 
 453             return success;
 454         } catch (IOException ex) {
 455             throw new IllegalStateException(ex);
 456         }
 457     }
 458 
 459     private CompletionTask.Result doPrintFullDocumentation(List&lt;CompletionTask&gt; todo, List&lt;String&gt; doc, boolean command) {
 460         if (doc != null &amp;&amp; !doc.isEmpty()) {
 461             Terminal term = in.getTerminal();
 462             int pageHeight = term.getHeight() - NEEDED_LINES;
 463             List&lt;CompletionTask&gt; thisTODO = new ArrayList&lt;&gt;();
 464 
 465             for (Iterator&lt;String&gt; docIt = doc.iterator(); docIt.hasNext(); ) {
 466                 String currentDoc = docIt.next();
 467                 String[] lines = currentDoc.split(&quot;\n&quot;);
 468                 int firstLine = 0;
 469 
 470                 while (firstLine &lt; lines.length) {
 471                     boolean first = firstLine == 0;
 472                     String[] thisPageLines =
 473                             Arrays.copyOfRange(lines,
 474                                                firstLine,
 475                                                Math.min(firstLine + pageHeight, lines.length));
 476 
 477                     thisTODO.add(new CompletionTask() {
 478                         @Override
 479                         public String description() {
 480                             String key =  !first ? &quot;jshell.console.see.next.page&quot;
 481                                                  : command ? &quot;jshell.console.see.next.command.doc&quot;
 482                                                            : &quot;jshell.console.see.next.javadoc&quot;;
 483 
 484                             return repl.getResourceString(key);
 485                         }
 486 
 487                         @Override
 488                         public Result perform(String text, int cursor) throws IOException {
 489                             in.getTerminal().writer().println();
 490                             for (String line : thisPageLines) {
 491                                 in.getTerminal().writer().println(line);
 492                             }
 493                             return Result.FINISH;
 494                         }
 495                     });
 496 
 497                     firstLine += pageHeight;
 498                 }
 499             }
 500 
 501             todo.addAll(0, thisTODO);
 502 
 503             return CompletionTask.Result.CONTINUE;
 504         }
 505 
 506         return CompletionTask.Result.FINISH;
 507     }
 508     //where:
 509         private static final int NEEDED_LINES = 4;
 510 
 511     private static String commonPrefix(String str1, String str2) {
 512         for (int i = 0; i &lt; str2.length(); i++) {
 513             if (!str1.startsWith(str2.substring(0, i + 1))) {
 514                 return str2.substring(0, i);
 515             }
 516         }
 517 
 518         return str2;
 519     }
 520 
 521     private interface CompletionTask {
 522         public String description();
 523         public Result perform(String text, int cursor) throws IOException;
 524 
 525         enum Result {
 526             NO_DATA,
 527             CONTINUE,
 528             FINISH,
 529             SKIP,
 530             SKIP_NOREPAINT;
 531         }
 532     }
 533 
 534     private final class NoopCompletionTask implements CompletionTask {
 535 
 536         @Override
 537         public String description() {
 538             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 539         }
 540 
 541         @Override
 542         public Result perform(String text, int cursor) throws IOException {
 543             return Result.FINISH;
 544         }
 545 
 546     }
 547 
 548     private final class NoSuchCommandCompletionTask implements CompletionTask {
 549 
 550         @Override
 551         public String description() {
 552             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 553         }
 554 
 555         @Override
 556         public Result perform(String text, int cursor) throws IOException {
 557             in.getTerminal().writer().println();
 558             in.getTerminal().writer().println(repl.getResourceString(&quot;jshell.console.no.such.command&quot;));
 559             in.getTerminal().writer().println();
 560             return Result.SKIP;
 561         }
 562 
 563     }
 564 
 565     private final class OrdinaryCompletionTask implements CompletionTask {
 566         private final List&lt;Suggestion&gt; suggestions;
 567         private final int anchor;
 568         private final boolean cont;
 569         private final boolean showSmart;
 570 
 571         public OrdinaryCompletionTask(List&lt;Suggestion&gt; suggestions,
 572                                       int anchor,
 573                                       boolean cont,
 574                                       boolean showSmart) {
 575             this.suggestions = suggestions;
 576             this.anchor = anchor;
 577             this.cont = cont;
 578             this.showSmart = showSmart;
 579         }
 580 
 581         @Override
 582         public String description() {
 583             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 584         }
 585 
 586         @Override
 587         public Result perform(String text, int cursor) throws IOException {
 588             List&lt;CharSequence&gt; toShow;
 589 
 590             if (showSmart) {
 591                 toShow =
 592                     suggestions.stream()
 593                                .filter(Suggestion::matchesType)
 594                                .map(Suggestion::continuation)
 595                                .distinct()
 596                                .collect(Collectors.toList());
 597             } else {
 598                 toShow =
 599                     suggestions.stream()
 600                                .map(Suggestion::continuation)
 601                                .distinct()
 602                                .collect(Collectors.toList());
 603             }
 604 
 605             if (toShow.isEmpty()) {
 606                 return Result.CONTINUE;
 607             }
 608 
 609             Optional&lt;String&gt; prefix =
 610                     suggestions.stream()
 611                                .map(Suggestion::continuation)
 612                                .reduce(ConsoleIOContext::commonPrefix);
 613 
 614             String prefixStr = prefix.orElse(&quot;&quot;).substring(cursor - anchor);
 615             in.putString(prefixStr);
 616 
 617             boolean showItems = toShow.size() &gt; 1 || showSmart;
 618 
 619             if (showItems) {
 620                 in.getTerminal().writer().println();
 621                 printColumns(toShow);
 622             }
 623 
 624             if (!prefixStr.isEmpty())
 625                 return showItems ? Result.FINISH : Result.SKIP_NOREPAINT;
 626 
 627             return cont ? Result.CONTINUE : Result.FINISH;
 628         }
 629 
 630     }
 631 
 632     private final class AllSuggestionsCompletionTask implements CompletionTask {
 633         private final List&lt;Suggestion&gt; suggestions;
 634         private final int anchor;
 635 
 636         public AllSuggestionsCompletionTask(List&lt;Suggestion&gt; suggestions,
 637                                             int anchor) {
 638             this.suggestions = suggestions;
 639             this.anchor = anchor;
 640         }
 641 
 642         @Override
 643         public String description() {
 644             if (suggestions.size() &lt;= /*in.getAutoprintThreshold()*/AUTOPRINT_THRESHOLD) {
 645                 return repl.getResourceString(&quot;jshell.console.completion.all.completions&quot;);
 646             } else {
 647                 return repl.messageFormat(&quot;jshell.console.completion.all.completions.number&quot;, suggestions.size());
 648             }
 649         }
 650 
 651         @Override
 652         public Result perform(String text, int cursor) throws IOException {
 653             List&lt;String&gt; candidates =
 654                     suggestions.stream()
 655                                .map(Suggestion::continuation)
 656                                .distinct()
 657                                .collect(Collectors.toList());
 658 
 659             Optional&lt;String&gt; prefix =
 660                     candidates.stream()
 661                               .reduce(ConsoleIOContext::commonPrefix);
 662 
 663             String prefixStr = prefix.map(str -&gt; str.substring(cursor - anchor)).orElse(&quot;&quot;);
 664             in.putString(prefixStr);
 665             if (candidates.size() &gt; 1) {
 666                 in.getTerminal().writer().println();
 667                 printColumns(candidates);
 668             }
 669             return suggestions.isEmpty() ? Result.NO_DATA : Result.FINISH;
 670         }
 671 
 672     }
 673 
 674     private void printColumns(List&lt;? extends CharSequence&gt; candidates) {
 675         if (candidates.isEmpty()) return ;
 676         int size = candidates.stream().mapToInt(CharSequence::length).max().getAsInt() + 3;
 677         int columns = in.getTerminal().getWidth() / size;
 678         int c = 0;
 679         for (CharSequence cand : candidates) {
 680             in.getTerminal().writer().print(cand);
 681             for (int s = cand.length(); s &lt; size; s++) {
 682                 in.getTerminal().writer().print(&quot; &quot;);
 683             }
 684             if (++c == columns) {
 685                 in.getTerminal().writer().println();
 686                 c = 0;
 687             }
 688         }
 689         if (c != 0) {
 690             in.getTerminal().writer().println();
 691         }
 692     }
 693 
 694     private final class CommandSynopsisTask implements CompletionTask {
 695 
 696         private final List&lt;String&gt; synopsis;
 697 
 698         public CommandSynopsisTask(List&lt;String&gt; synposis) {
 699             this.synopsis = synposis;
 700         }
 701 
 702         @Override
 703         public String description() {
 704             return repl.getResourceString(&quot;jshell.console.see.synopsis&quot;);
 705         }
 706 
 707         @Override
 708         public Result perform(String text, int cursor) throws IOException {
 709 //            try {
 710                 in.getTerminal().writer().println();
 711                 in.getTerminal().writer().println(synopsis.stream()
 712                                    .map(l -&gt; l.replaceAll(&quot;\n&quot;, LINE_SEPARATOR))
 713                                    .collect(Collectors.joining(LINE_SEPARATORS2)));
 714 //            } catch (IOException ex) {
 715 //                throw new IllegalStateException(ex);
 716 //            }
 717             return Result.FINISH;
 718         }
 719 
 720     }
 721 
 722     private final class CommandFullDocumentationTask implements CompletionTask {
 723 
 724         private final List&lt;CompletionTask&gt; todo;
 725 
 726         public CommandFullDocumentationTask(List&lt;CompletionTask&gt; todo) {
 727             this.todo = todo;
 728         }
 729 
 730         @Override
 731         public String description() {
 732             return repl.getResourceString(&quot;jshell.console.see.full.documentation&quot;);
 733         }
 734 
 735         @Override
 736         public Result perform(String text, int cursor) throws IOException {
 737             List&lt;String&gt; fullDoc = repl.commandDocumentation(text, cursor, false);
 738             return doPrintFullDocumentation(todo, fullDoc, true);
 739         }
 740 
 741     }
 742 
 743     private final class ExpressionSignaturesTask implements CompletionTask {
 744 
 745         private final List&lt;String&gt; doc;
 746 
 747         public ExpressionSignaturesTask(List&lt;String&gt; doc) {
 748             this.doc = doc;
 749         }
 750 
 751         @Override
 752         public String description() {
 753             throw new UnsupportedOperationException(&quot;Should not get here.&quot;);
 754         }
 755 
 756         @Override
 757         public Result perform(String text, int cursor) throws IOException {
 758             in.getTerminal().writer().println();
 759             in.getTerminal().writer().println(repl.getResourceString(&quot;jshell.console.completion.current.signatures&quot;));
 760             in.getTerminal().writer().println(doc.stream().collect(Collectors.joining(LINE_SEPARATOR)));
 761             return Result.FINISH;
 762         }
 763 
 764     }
 765 
 766     private final class ExpressionJavadocTask implements CompletionTask {
 767 
 768         private final List&lt;CompletionTask&gt; todo;
 769 
 770         public ExpressionJavadocTask(List&lt;CompletionTask&gt; todo) {
 771             this.todo = todo;
 772         }
 773 
 774         @Override
 775         public String description() {
 776             return repl.getResourceString(&quot;jshell.console.see.documentation&quot;);
 777         }
 778 
 779         @Override
 780         public Result perform(String text, int cursor) throws IOException {
 781             //schedule showing javadoc:
 782             Terminal term = in.getTerminal();
 783             JavadocFormatter formatter = new JavadocFormatter(term.getWidth(),
 784                                                               true);
 785             Function&lt;Documentation, String&gt; convertor = d -&gt; formatter.formatJavadoc(d.signature(), d.javadoc()) +
 786                              (d.javadoc() == null ? repl.messageFormat(&quot;jshell.console.no.javadoc&quot;)
 787                                                   : &quot;&quot;);
 788             List&lt;String&gt; doc = repl.analysis.documentation(prefix + text, cursor + prefix.length(), true)
 789                                             .stream()
 790                                             .map(convertor)
 791                                             .collect(Collectors.toList());
 792             return doPrintFullDocumentation(todo, doc, false);
 793         }
 794 
 795     }
 796 
 797     @Override
 798     public boolean terminalEditorRunning() {
 799         Terminal terminal = in.getTerminal();
 800         return !terminal.getAttributes().getLocalFlag(LocalFlag.ICANON);
 801     }
 802 
 803     @Override
 804     public void suspend() {
 805     }
 806 
 807     @Override
 808     public void resume() {
 809     }
 810 
 811     @Override
 812     public void beforeUserCode() {
 813         synchronized (this) {
 814             inputBytes = null;
 815         }
 816         input.setState(State.BUFFER);
 817     }
 818 
 819     @Override
 820     public void afterUserCode() {
 821         input.setState(State.WAIT);
 822     }
 823 
 824     @Override
 825     public void replaceLastHistoryEntry(String source) {
 826         var it = in.getHistory().iterator();
 827         while (it.hasNext()) {
 828             it.next();
 829         }
 830         it.remove();
 831         in.getHistory().add(source);
 832     }
 833 
 834     private static final long ESCAPE_TIMEOUT = 100;
 835 
 836     private boolean fixes() {
 837         try {
 838             int c = in.getTerminal().reader().read();
 839 
 840             if (c == (-1)) {
 841                 return true; //TODO: true or false???
 842             }
 843 
 844             for (FixComputer computer : FIX_COMPUTERS) {
 845                 if (computer.shortcut == c) {
 846                     fixes(computer);
 847                     return true; //TODO: true of false???
 848                 }
 849             }
 850 
 851             readOutRemainingEscape(c);
 852 
 853             in.beep();
 854             in.getTerminal().writer().println();
 855             in.getTerminal().writer().println(repl.getResourceString(&quot;jshell.fix.wrong.shortcut&quot;));
 856             in.redrawLine();
 857             in.flush();
 858         } catch (IOException ex) {
 859             ex.printStackTrace();
 860         }
 861         return true;
 862     }
 863 
 864     private void readOutRemainingEscape(int c) throws IOException {
 865         if (c == &#39;\033&#39;) {
 866             //escape, consume waiting input:
 867             NonBlockingReader inp = in.getTerminal().reader();
 868 
 869             while (inp.peek(ESCAPE_TIMEOUT) &gt; 0) {
 870                 inp.read();
 871             }
 872         }
 873     }
 874 
 875     //compute possible options/Fixes based on the selected FixComputer, present them to the user,
 876     //and perform the selected one:
 877     private void fixes(FixComputer computer) {
 878         String input = prefix + in.getBuffer().toString();
 879         int cursor = prefix.length() + in.getBuffer().cursor();
 880         FixResult candidates = computer.compute(repl, input, cursor);
 881 
 882         try {
 883             final boolean printError = candidates.error != null &amp;&amp; !candidates.error.isEmpty();
 884             if (printError) {
 885                 in.getTerminal().writer().println(candidates.error);
 886             }
 887             if (candidates.fixes.isEmpty()) {
 888                 in.beep();
 889                 if (printError) {
 890                     in.redrawLine();
 891                     in.flush();
 892                 }
 893             } else if (candidates.fixes.size() == 1 &amp;&amp; !computer.showMenu) {
 894                 if (printError) {
 895                     in.redrawLine();
 896                     in.flush();
 897                 }
 898                 candidates.fixes.get(0).perform(in);
 899             } else {
 900                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;(candidates.fixes);
 901                 fixes.add(0, new Fix() {
 902                     @Override
 903                     public String displayName() {
 904                         return repl.messageFormat(&quot;jshell.console.do.nothing&quot;);
 905                     }
 906 
 907                     @Override
 908                     public void perform(LineReaderImpl in) throws IOException {
 909                         in.redrawLine();
 910                     }
 911                 });
 912 
 913                 Map&lt;Character, Fix&gt; char2Fix = new HashMap&lt;&gt;();
 914                 in.getTerminal().writer().println();
 915                 for (int i = 0; i &lt; fixes.size(); i++) {
 916                     Fix fix = fixes.get(i);
 917                     char2Fix.put((char) (&#39;0&#39; + i), fix);
 918                     in.getTerminal().writer().println(&quot;&quot; + i + &quot;: &quot; + fixes.get(i).displayName());
 919                 }
 920                 in.getTerminal().writer().print(repl.messageFormat(&quot;jshell.console.choice&quot;));
 921                 in.flush();
 922                 int read;
 923 
 924                 read = in.readCharacter();
 925 
 926                 Fix fix = char2Fix.get((char) read);
 927 
 928                 if (fix == null) {
 929                     in.beep();
 930                     fix = fixes.get(0);
 931                 }
 932 
 933                 in.getTerminal().writer().println();
 934 
 935                 fix.perform(in);
 936 
 937                 in.flush();
 938             }
 939         } catch (IOException ex) {
 940             throw new IllegalStateException(ex);
 941         }
 942     }
 943 
 944     private byte[] inputBytes;
 945     private int inputBytesPointer;
 946 
 947     @Override
 948     public synchronized int readUserInput() throws IOException {
 949         while (inputBytes == null || inputBytes.length &lt;= inputBytesPointer) {
 950             History prevHistory = in.getHistory();
 951             boolean prevDisableCr = Display.DISABLE_CR;
 952             Parser prevParser = in.getParser();
 953 
 954             try {
 955                 in.setParser((line, cursor, context) -&gt; new ArgumentLine(line, cursor));
 956                 input.setState(State.WAIT);
 957                 Display.DISABLE_CR = true;
 958                 in.setHistory(userInputHistory);
 959                 inputBytes = (in.readLine(&quot;&quot;) + System.getProperty(&quot;line.separator&quot;)).getBytes();
 960                 inputBytesPointer = 0;
 961             } catch (UserInterruptException ex) {
 962                 throw new InterruptedIOException();
 963             } finally {
 964                 in.setParser(prevParser);
 965                 in.setHistory(prevHistory);
 966                 input.setState(State.BUFFER);
 967                 Display.DISABLE_CR = prevDisableCr;
 968             }
 969         }
 970         return inputBytes[inputBytesPointer++];
 971     }
 972 
 973     private int countPendingOpenBraces(String code) {
 974         int pendingBraces = 0;
 975         com.sun.tools.javac.util.Context ctx =
 976                 new com.sun.tools.javac.util.Context();
<a name="4" id="anc4"></a>








 977         com.sun.tools.javac.parser.ScannerFactory scannerFactory =
 978                 com.sun.tools.javac.parser.ScannerFactory.instance(ctx);
 979         com.sun.tools.javac.parser.Scanner scanner =
 980                 scannerFactory.newScanner(code, false);
 981 
 982         while (true) {
 983             switch (scanner.token().kind) {
 984                 case LBRACE: pendingBraces++; break;
 985                 case RBRACE: pendingBraces--; break;
 986                 case EOF: return pendingBraces;
 987             }
 988             scanner.nextToken();
 989         }
 990     }
 991 
 992     /**
 993      * A possible action which the user can choose to perform.
 994      */
 995     public interface Fix {
 996         /**
 997          * A name that should be shown to the user.
 998          */
 999         public String displayName();
1000         /**
1001          * Perform the given action.
1002          */
1003         public void perform(LineReaderImpl in) throws IOException;
1004     }
1005 
1006     /**
1007      * A factory for {@link Fix}es.
1008      */
1009     public abstract static class FixComputer {
1010         private final char shortcut;
1011         private final boolean showMenu;
1012 
1013         /**
1014          * Construct a new FixComputer. {@code shortcut} defines the key which should trigger this FixComputer.
1015          * If {@code showMenu} is {@code false}, and this computer returns exactly one {@code Fix},
1016          * no options will be show to the user, and the given {@code Fix} will be performed.
1017          */
1018         public FixComputer(char shortcut, boolean showMenu) {
1019             this.shortcut = shortcut;
1020             this.showMenu = showMenu;
1021         }
1022 
1023         /**
1024          * Compute possible actions for the given code.
1025          */
1026         public abstract FixResult compute(JShellTool repl, String code, int cursor);
1027     }
1028 
1029     /**
1030      * A list of {@code Fix}es with a possible error that should be shown to the user.
1031      */
1032     public static class FixResult {
1033         public final List&lt;Fix&gt; fixes;
1034         public final String error;
1035 
1036         public FixResult(List&lt;Fix&gt; fixes, String error) {
1037             this.fixes = fixes;
1038             this.error = error;
1039         }
1040     }
1041 
1042     private static final FixComputer[] FIX_COMPUTERS = new FixComputer[] {
1043         new FixComputer(&#39;v&#39;, false) { //compute &quot;Introduce variable&quot; Fix:
1044             private void performToVar(LineReaderImpl in, String type) throws IOException {
1045                 in.redrawLine();
1046                 in.getBuffer().cursor(0);
1047                 in.putString(type + &quot;  = &quot;);
1048                 in.getBuffer().cursor(in.getBuffer().cursor() - 3);
1049                 in.flush();
1050             }
1051 
1052             @Override
1053             public FixResult compute(JShellTool repl, String code, int cursor) {
1054                 String type = repl.analysis.analyzeType(code, cursor);
1055                 if (type == null) {
1056                     return new FixResult(Collections.emptyList(), null);
1057                 }
1058                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;();
1059                 fixes.add(new Fix() {
1060                     @Override
1061                     public String displayName() {
1062                         return repl.messageFormat(&quot;jshell.console.create.variable&quot;);
1063                     }
1064 
1065                     @Override
1066                     public void perform(LineReaderImpl in) throws IOException {
1067                         performToVar(in, type);
1068                     }
1069                 });
1070                 int idx = type.lastIndexOf(&quot;.&quot;);
1071                 if (idx &gt; 0) {
1072                     String stype = type.substring(idx + 1);
1073                     QualifiedNames res = repl.analysis.listQualifiedNames(stype, stype.length());
1074                     if (res.isUpToDate() &amp;&amp; res.getNames().contains(type)
1075                             &amp;&amp; !res.isResolvable()) {
1076                         fixes.add(new Fix() {
1077                             @Override
1078                             public String displayName() {
1079                                 return &quot;import: &quot; + type + &quot;. &quot; +
1080                                         repl.messageFormat(&quot;jshell.console.create.variable&quot;);
1081                             }
1082 
1083                             @Override
1084                             public void perform(LineReaderImpl in) throws IOException {
1085                                 repl.processSource(&quot;import &quot; + type + &quot;;&quot;);
1086                                 in.getTerminal().writer().println(&quot;Imported: &quot; + type);
1087                                 performToVar(in, stype);
1088                             }
1089                         });
1090                     }
1091                 }
1092                 return new FixResult(fixes, null);
1093             }
1094         },
1095         new FixComputer(&#39;m&#39;, false) { //compute &quot;Introduce method&quot; Fix:
1096             private void performToMethod(LineReaderImpl in, String type, String code) throws IOException {
1097                 in.redrawLine();
1098                 if (!code.trim().endsWith(&quot;;&quot;)) {
1099                     in.putString(&quot;;&quot;);
1100                 }
1101                 in.putString(&quot; }&quot;);
1102                 in.getBuffer().cursor(0);
1103                 String afterCursor = type.equals(&quot;void&quot;)
1104                         ? &quot;() { &quot;
1105                         : &quot;() { return &quot;;
1106                 in.putString(type + &quot; &quot; + afterCursor);
1107                 // position the cursor where the method name should be entered (before parens)
1108                 in.getBuffer().cursor(in.getBuffer().cursor() - afterCursor.length());
1109                 in.flush();
1110             }
1111 
1112             private FixResult reject(JShellTool repl, String messageKey) {
1113                 return new FixResult(Collections.emptyList(), repl.messageFormat(messageKey));
1114             }
1115 
1116             @Override
1117             public FixResult compute(JShellTool repl, String code, int cursor) {
1118                 final String codeToCursor = code.substring(0, cursor);
1119                 final String type;
1120                 final CompletionInfo ci = repl.analysis.analyzeCompletion(codeToCursor);
1121                 if (!ci.remaining().isEmpty()) {
1122                     return reject(repl, &quot;jshell.console.exprstmt&quot;);
1123                 }
1124                 switch (ci.completeness()) {
1125                     case COMPLETE:
1126                     case COMPLETE_WITH_SEMI:
1127                     case CONSIDERED_INCOMPLETE:
1128                         break;
1129                     case EMPTY:
1130                         return reject(repl, &quot;jshell.console.empty&quot;);
1131                     case DEFINITELY_INCOMPLETE:
1132                     case UNKNOWN:
1133                     default:
1134                         return reject(repl, &quot;jshell.console.erroneous&quot;);
1135                 }
1136                 List&lt;Snippet&gt; snl = repl.analysis.sourceToSnippets(ci.source());
1137                 if (snl.size() != 1) {
1138                     return reject(repl, &quot;jshell.console.erroneous&quot;);
1139                 }
1140                 Snippet sn = snl.get(0);
1141                 switch (sn.kind()) {
1142                     case EXPRESSION:
1143                         type = ((ExpressionSnippet) sn).typeName();
1144                         break;
1145                     case STATEMENT:
1146                         type = &quot;void&quot;;
1147                         break;
1148                     case VAR:
1149                         if (sn.subKind() != SubKind.TEMP_VAR_EXPRESSION_SUBKIND) {
1150                             // only valid var is an expression turned into a temp var
1151                             return reject(repl, &quot;jshell.console.exprstmt&quot;);
1152                         }
1153                         type = ((VarSnippet) sn).typeName();
1154                         break;
1155                     case IMPORT:
1156                     case METHOD:
1157                     case TYPE_DECL:
1158                         return reject(repl, &quot;jshell.console.exprstmt&quot;);
1159                     case ERRONEOUS:
1160                     default:
1161                         return reject(repl, &quot;jshell.console.erroneous&quot;);
1162                 }
1163                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;();
1164                 fixes.add(new Fix() {
1165                     @Override
1166                     public String displayName() {
1167                         return repl.messageFormat(&quot;jshell.console.create.method&quot;);
1168                     }
1169 
1170                     @Override
1171                     public void perform(LineReaderImpl in) throws IOException {
1172                         performToMethod(in, type, codeToCursor);
1173                     }
1174                 });
1175                 int idx = type.lastIndexOf(&quot;.&quot;);
1176                 if (idx &gt; 0) {
1177                     String stype = type.substring(idx + 1);
1178                     QualifiedNames res = repl.analysis.listQualifiedNames(stype, stype.length());
1179                     if (res.isUpToDate() &amp;&amp; res.getNames().contains(type)
1180                             &amp;&amp; !res.isResolvable()) {
1181                         fixes.add(new Fix() {
1182                             @Override
1183                             public String displayName() {
1184                                 return &quot;import: &quot; + type + &quot;. &quot; +
1185                                         repl.messageFormat(&quot;jshell.console.create.method&quot;);
1186                             }
1187 
1188                             @Override
1189                             public void perform(LineReaderImpl in) throws IOException {
1190                                 repl.processSource(&quot;import &quot; + type + &quot;;&quot;);
1191                                 in.getTerminal().writer().println(&quot;Imported: &quot; + type);
1192                                 performToMethod(in, stype, codeToCursor);
1193                             }
1194                         });
1195                     }
1196                 }
1197                 return new FixResult(fixes, null);
1198             }
1199         },
1200         new FixComputer(&#39;i&#39;, true) { //compute &quot;Add import&quot; Fixes:
1201             @Override
1202             public FixResult compute(JShellTool repl, String code, int cursor) {
1203                 QualifiedNames res = repl.analysis.listQualifiedNames(code, cursor);
1204                 List&lt;Fix&gt; fixes = new ArrayList&lt;&gt;();
1205                 for (String fqn : res.getNames()) {
1206                     fixes.add(new Fix() {
1207                         @Override
1208                         public String displayName() {
1209                             return &quot;import: &quot; + fqn;
1210                         }
1211 
1212                         @Override
1213                         public void perform(LineReaderImpl in) throws IOException {
1214                             repl.processSource(&quot;import &quot; + fqn + &quot;;&quot;);
1215                             in.getTerminal().writer().println(&quot;Imported: &quot; + fqn);
1216                             in.redrawLine();
1217                         }
1218                     });
1219                 }
1220                 if (res.isResolvable()) {
1221                     return new FixResult(Collections.emptyList(),
1222                             repl.messageFormat(&quot;jshell.console.resolvable&quot;));
1223                 } else {
1224                     String error = &quot;&quot;;
1225                     if (fixes.isEmpty()) {
1226                         error = repl.messageFormat(&quot;jshell.console.no.candidate&quot;);
1227                     }
1228                     if (!res.isUpToDate()) {
1229                         error += repl.messageFormat(&quot;jshell.console.incomplete&quot;);
1230                     }
1231                     return new FixResult(fixes, error);
1232                 }
1233             }
1234         }
1235     };
1236 
1237     private History getHistory() {
1238         return in.getHistory();
1239     }
1240 
1241     private static final class TestTerminal extends LineDisciplineTerminal {
1242 
1243         private static final int DEFAULT_HEIGHT = 24;
1244 
1245         private final NonBlockingReader inputReader;
1246 
1247         public TestTerminal(InputStream input, OutputStream output) throws Exception {
1248             super(&quot;test&quot;, &quot;ansi&quot;, output, Charset.forName(&quot;UTF-8&quot;));
1249             this.inputReader = NonBlocking.nonBlocking(getName(), input, encoding());
1250             Attributes a = new Attributes(getAttributes());
1251             a.setLocalFlag(LocalFlag.ECHO, false);
1252             setAttributes(attributes);
1253             int h = DEFAULT_HEIGHT;
1254             try {
1255                 String hp = System.getProperty(&quot;test.terminal.height&quot;);
1256                 if (hp != null &amp;&amp; !hp.isEmpty()) {
1257                     h = Integer.parseInt(hp);
1258                 }
1259             } catch (Throwable ex) {
1260                 // ignore
1261             }
1262             setSize(new Size(80, h));
1263         }
1264 
1265         @Override
1266         public NonBlockingReader reader() {
1267             return inputReader;
1268         }
1269 
1270         @Override
1271         protected void doClose() throws IOException {
1272             super.doClose();
1273             slaveInput.close();
1274             inputReader.close();
1275         }
1276 
1277     }
1278 
1279     private static final class CompletionState {
1280         /**The number of actions since the last completion invocation. Will be 1 when completion is
1281          * invoked immediately after the last completion invocation.*/
1282         public int actionCount;
1283         /**Precomputed completion actions. Should only be reused if actionCount == 1.*/
1284         public List&lt;CompletionTask&gt; todo = Collections.emptyList();
1285     }
1286 
1287 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
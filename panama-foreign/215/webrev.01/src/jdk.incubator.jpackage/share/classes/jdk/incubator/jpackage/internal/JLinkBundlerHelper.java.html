<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/JLinkBundlerHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.PrintWriter;
 31 import java.io.StringWriter;
 32 import java.lang.module.Configuration;
 33 import java.lang.module.ModuleDescriptor;
 34 import java.lang.module.ModuleFinder;
 35 import java.lang.module.ModuleReference;
 36 import java.lang.module.ResolvedModule;
 37 import java.nio.file.Path;
 38 import java.util.ArrayList;
 39 import java.util.Collection;
 40 import java.util.HashSet;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.Set;
 44 import java.util.function.Supplier;
 45 import java.util.jar.JarFile;
 46 import java.util.regex.Matcher;
 47 import java.util.spi.ToolProvider;
 48 import java.util.stream.Collectors;
 49 import java.util.stream.Stream;
 50 import jdk.internal.module.ModulePath;
 51 
 52 
 53 final class JLinkBundlerHelper {
 54 
 55     static void execute(Map&lt;String, ? super Object&gt; params, Path outputDir)
 56             throws IOException, PackagerException {
 57 
 58         List&lt;Path&gt; modulePath =
 59                 StandardBundlerParam.MODULE_PATH.fetchFrom(params);
 60         Set&lt;String&gt; addModules =
 61                 StandardBundlerParam.ADD_MODULES.fetchFrom(params);
 62         Set&lt;String&gt; limitModules =
 63                 StandardBundlerParam.LIMIT_MODULES.fetchFrom(params);
 64         List&lt;String&gt; options =
 65                 StandardBundlerParam.JLINK_OPTIONS.fetchFrom(params);
 66 
 67         LauncherData launcherData = StandardBundlerParam.LAUNCHER_DATA.fetchFrom(
 68                 params);
 69 
 70         boolean bindServices =
 71                 StandardBundlerParam.BIND_SERVICES.fetchFrom(params);
 72 
 73         // Modules
 74         if (!launcherData.isModular() &amp;&amp; addModules.isEmpty()) {
 75             addModules.add(ALL_DEFAULT);
 76         }
 77 
 78         Set&lt;String&gt; modules = createModuleList(modulePath, addModules, limitModules);
 79 
 80         if (launcherData.isModular()) {
 81             modules.add(launcherData.moduleName());
 82         }
 83 
 84         runJLink(outputDir, modulePath, modules, limitModules,
 85                 options, bindServices);
 86     }
 87 
 88     /*
 89      * Returns the set of modules that would be visible by default for
 90      * a non-modular-aware application consisting of the given elements.
 91      */
 92     private static Set&lt;String&gt; getDefaultModules(
 93             Collection&lt;Path&gt; paths, Collection&lt;String&gt; addModules) {
 94 
 95         // the modules in the run-time image that export an API
 96         Stream&lt;String&gt; systemRoots = ModuleFinder.ofSystem().findAll().stream()
 97                 .map(ModuleReference::descriptor)
 98                 .filter(JLinkBundlerHelper::exportsAPI)
 99                 .map(ModuleDescriptor::name);
100 
101         Set&lt;String&gt; roots = Stream.concat(systemRoots,
102                  addModules.stream()).collect(Collectors.toSet());
103 
104         ModuleFinder finder = createModuleFinder(paths);
105 
106         return Configuration.empty()
107                 .resolveAndBind(finder, ModuleFinder.of(), roots)
108                 .modules()
109                 .stream()
110                 .map(ResolvedModule::name)
111                 .collect(Collectors.toSet());
112     }
113 
114     /*
115      * Returns true if the given module exports an API to all module.
116      */
117     private static boolean exportsAPI(ModuleDescriptor descriptor) {
118         return descriptor.exports()
119                 .stream()
120                 .anyMatch(e -&gt; !e.isQualified());
121     }
122 
123     static ModuleFinder createModuleFinder(Collection&lt;Path&gt; modulePath) {
124         return ModuleFinder.compose(
125                 ModulePath.of(JarFile.runtimeVersion(), true,
126                         modulePath.toArray(Path[]::new)),
127                 ModuleFinder.ofSystem());
128     }
129 
130     private static Set&lt;String&gt; createModuleList(List&lt;Path&gt; paths,
131             Set&lt;String&gt; addModules, Set&lt;String&gt; limitModules) {
132 
133         final Set&lt;String&gt; modules = new HashSet&lt;&gt;();
134 
135         final Map&lt;String, Supplier&lt;Collection&lt;String&gt;&gt;&gt; phonyModules = Map.of(
136                 ALL_MODULE_PATH,
137                 () -&gt; createModuleFinder(paths)
138                             .findAll()
139                             .stream()
140                             .map(ModuleReference::descriptor)
141                             .map(ModuleDescriptor::name)
142                             .collect(Collectors.toSet()),
143                 ALL_DEFAULT,
144                 () -&gt; getDefaultModules(paths, modules));
145 
146         Supplier&lt;Collection&lt;String&gt;&gt; phonyModule = null;
147         for (var module : addModules) {
148             phonyModule = phonyModules.get(module);
149             if (phonyModule == null) {
150                 modules.add(module);
151             }
152         }
153 
154         if (phonyModule != null) {
155             modules.addAll(phonyModule.get());
156         }
157 
158         return modules;
159     }
160 
161     private static void runJLink(Path output, List&lt;Path&gt; modulePath,
162             Set&lt;String&gt; modules, Set&lt;String&gt; limitModules,
163             List&lt;String&gt; options, boolean bindServices)
164             throws PackagerException, IOException {
165 
166         ArrayList&lt;String&gt; args = new ArrayList&lt;String&gt;();
167         args.add(&quot;--output&quot;);
168         args.add(output.toString());
169         if (modulePath != null &amp;&amp; !modulePath.isEmpty()) {
170             args.add(&quot;--module-path&quot;);
171             args.add(getPathList(modulePath));
172         }
173         if (modules != null &amp;&amp; !modules.isEmpty()) {
174             args.add(&quot;--add-modules&quot;);
175             args.add(getStringList(modules));
176         }
177         if (limitModules != null &amp;&amp; !limitModules.isEmpty()) {
178             args.add(&quot;--limit-modules&quot;);
179             args.add(getStringList(limitModules));
180         }
181         if (options != null) {
182             for (String option : options) {
183                 if (option.startsWith(&quot;--output&quot;) ||
184                         option.startsWith(&quot;--add-modules&quot;) ||
185                         option.startsWith(&quot;--module-path&quot;)) {
186                     throw new PackagerException(&quot;error.blocked.option&quot;, option);
187                 }
188                 args.add(option);
189             }
190         }
191         if (bindServices) {
192             args.add(&quot;--bind-services&quot;);
193         }
194 
195         StringWriter writer = new StringWriter();
196         PrintWriter pw = new PrintWriter(writer);
197 
198         Log.verbose(&quot;jlink arguments: &quot; + args);
199         int retVal = LazyLoad.JLINK_TOOL.run(pw, pw, args.toArray(new String[0]));
200         String jlinkOut = writer.toString();
201 
202         if (retVal != 0) {
203             throw new PackagerException(&quot;error.jlink.failed&quot; , jlinkOut);
204         }
205 
206         Log.verbose(&quot;jlink output: &quot; + jlinkOut);
207     }
208 
209     private static String getPathList(List&lt;Path&gt; pathList) {
210         return pathList.stream()
211                 .map(Path::toString)
212                 .map(Matcher::quoteReplacement)
213                 .collect(Collectors.joining(File.pathSeparator));
214     }
215 
216     private static String getStringList(Set&lt;String&gt; strings) {
217         return Matcher.quoteReplacement(strings.stream().collect(
218                 Collectors.joining(&quot;,&quot;)));
219     }
220 
221     // The token for &quot;all modules on the module path&quot;.
222     private final static String ALL_MODULE_PATH = &quot;ALL-MODULE-PATH&quot;;
223 
224     // The token for &quot;all valid runtime modules&quot;.
225     private final static String ALL_DEFAULT = &quot;ALL-DEFAULT&quot;;
226 
227     private static class LazyLoad {
228         static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(
229                 &quot;jlink&quot;).orElseThrow();
230     };
231 }
    </pre>
  </body>
</html>
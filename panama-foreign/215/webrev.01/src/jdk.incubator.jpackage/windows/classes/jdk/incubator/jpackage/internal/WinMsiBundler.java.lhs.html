<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.jpackage/windows/classes/jdk/incubator/jpackage/internal/WinMsiBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.nio.charset.Charset;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.text.MessageFormat;
 39 import java.util.Arrays;
 40 import java.util.HashMap;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.UUID;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 48 import static jdk.incubator.jpackage.internal.StandardBundlerParam.APP_NAME;
 49 import static jdk.incubator.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;
 50 import static jdk.incubator.jpackage.internal.StandardBundlerParam.DESCRIPTION;
<a name="1" id="anc1"></a><span class="line-removed"> 51 import static jdk.incubator.jpackage.internal.StandardBundlerParam.FA_CONTENT_TYPE;</span>
<span class="line-removed"> 52 import static jdk.incubator.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;</span>
 53 import static jdk.incubator.jpackage.internal.StandardBundlerParam.LICENSE_FILE;
 54 import static jdk.incubator.jpackage.internal.StandardBundlerParam.TEMP_ROOT;
 55 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VENDOR;
 56 import static jdk.incubator.jpackage.internal.StandardBundlerParam.VERSION;
 57 
 58 /**
 59  * WinMsiBundler
 60  *
 61  * Produces .msi installer from application image. Uses WiX Toolkit to build
 62  * .msi installer.
 63  * &lt;p&gt;
 64  * {@link #execute} method creates a number of source files with the description
 65  * of installer to be processed by WiX tools. Generated source files are stored
 66  * in &quot;config&quot; subdirectory next to &quot;app&quot; subdirectory in the root work
 67  * directory. The following WiX source files are generated:
 68  * &lt;ul&gt;
 69  * &lt;li&gt;main.wxs. Main source file with the installer description
 70  * &lt;li&gt;bundle.wxf. Source file with application and Java run-time directory tree
 71  * description.
 72  * &lt;/ul&gt;
 73  * &lt;p&gt;
 74  * main.wxs file is a copy of main.wxs resource from
 75  * jdk.incubator.jpackage.internal.resources package. It is parametrized with the
 76  * following WiX variables:
 77  * &lt;ul&gt;
 78  * &lt;li&gt;JpAppName. Name of the application. Set to the value of --name command
 79  * line option
 80  * &lt;li&gt;JpAppVersion. Version of the application. Set to the value of
 81  * --app-version command line option
 82  * &lt;li&gt;JpAppVendor. Vendor of the application. Set to the value of --vendor
 83  * command line option
 84  * &lt;li&gt;JpAppDescription. Description of the application. Set to the value of
 85  * --description command line option
 86  * &lt;li&gt;JpProductCode. Set to product code UUID of the application. Random value
 87  * generated by jpackage every time {@link #execute} method is called
 88  * &lt;li&gt;JpProductUpgradeCode. Set to upgrade code UUID of the application. Random
 89  * value generated by jpackage every time {@link #execute} method is called if
 90  * --win-upgrade-uuid command line option is not specified. Otherwise this
 91  * variable is set to the value of --win-upgrade-uuid command line option
 92  * &lt;li&gt;JpAllowDowngrades. Set to &quot;yes&quot; if --win-upgrade-uuid command line option
 93  * was specified. Undefined otherwise
 94  * &lt;li&gt;JpLicenseRtf. Set to the value of --license-file command line option.
 95  * Undefined is --license-file command line option was not specified
 96  * &lt;li&gt;JpInstallDirChooser. Set to &quot;yes&quot; if --win-dir-chooser command line
 97  * option was specified. Undefined otherwise
 98  * &lt;li&gt;JpConfigDir. Absolute path to the directory with generated WiX source
 99  * files.
100  * &lt;li&gt;JpIsSystemWide. Set to &quot;yes&quot; if --win-per-user-install command line
101  * option was not specified. Undefined otherwise
102  * &lt;/ul&gt;
103  */
104 public class WinMsiBundler  extends AbstractBundler {
105 
106     public static final BundlerParamInfo&lt;File&gt; MSI_IMAGE_DIR =
107             new StandardBundlerParam&lt;&gt;(
108             &quot;win.msi.imageDir&quot;,
109             File.class,
110             params -&gt; {
111                 File imagesRoot = IMAGES_ROOT.fetchFrom(params);
112                 if (!imagesRoot.exists()) imagesRoot.mkdirs();
113                 return new File(imagesRoot, &quot;win-msi.image&quot;);
114             },
115             (s, p) -&gt; null);
116 
117     public static final BundlerParamInfo&lt;File&gt; WIN_APP_IMAGE =
118             new StandardBundlerParam&lt;&gt;(
119             &quot;win.app.image&quot;,
120             File.class,
121             null,
122             (s, p) -&gt; null);
123 
124     public static final StandardBundlerParam&lt;Boolean&gt; MSI_SYSTEM_WIDE  =
125             new StandardBundlerParam&lt;&gt;(
126                     Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId(),
127                     Boolean.class,
128                     params -&gt; true, // MSIs default to system wide
129                     // valueOf(null) is false,
130                     // and we actually do want null
131                     (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s))? null
132                             : Boolean.valueOf(s)
133             );
134 
135 
136     public static final StandardBundlerParam&lt;String&gt; PRODUCT_VERSION =
137             new StandardBundlerParam&lt;&gt;(
138                     &quot;win.msi.productVersion&quot;,
139                     String.class,
140                     VERSION::fetchFrom,
141                     (s, p) -&gt; s
142             );
143 
144     private static final BundlerParamInfo&lt;String&gt; UPGRADE_UUID =
145             new StandardBundlerParam&lt;&gt;(
146             Arguments.CLIOptions.WIN_UPGRADE_UUID.getId(),
147             String.class,
148             null,
149             (s, p) -&gt; s);
150 
151     private static final BundlerParamInfo&lt;String&gt; INSTALLER_FILE_NAME =
152             new StandardBundlerParam&lt;&gt; (
153             &quot;win.installerName&quot;,
154             String.class,
155             params -&gt; {
156                 String nm = APP_NAME.fetchFrom(params);
157                 if (nm == null) return null;
158 
159                 String version = VERSION.fetchFrom(params);
160                 if (version == null) {
161                     return nm;
162                 } else {
163                     return nm + &quot;-&quot; + version;
164                 }
165             },
166             (s, p) -&gt; s);
167 
168     private static final BundlerParamInfo&lt;Boolean&gt; INSTALLDIR_CHOOSER =
169             new StandardBundlerParam&lt;&gt; (
170             Arguments.CLIOptions.WIN_DIR_CHOOSER.getId(),
171             Boolean.class,
172             params -&gt; Boolean.FALSE,
173             (s, p) -&gt; Boolean.valueOf(s)
174     );
175 
176     public WinMsiBundler() {
177         appImageBundler = new WinAppBundler().setDependentTask(true);
178     }
179 
180     @Override
181     public String getName() {
182         return I18N.getString(&quot;msi.bundler.name&quot;);
183     }
184 
185     @Override
186     public String getID() {
187         return &quot;msi&quot;;
188     }
189 
190     @Override
191     public String getBundleType() {
192         return &quot;INSTALLER&quot;;
193     }
194 
195     @Override
196     public boolean supported(boolean platformInstaller) {
197         try {
198             if (wixToolset == null) {
199                 wixToolset = WixTool.toolset();
200             }
201             return true;
202         } catch (ConfigException ce) {
203             Log.error(ce.getMessage());
204             if (ce.getAdvice() != null) {
205                 Log.error(ce.getAdvice());
206             }
207         } catch (Exception e) {
208             Log.error(e.getMessage());
209         }
210         return false;
211     }
212 
213     @Override
214     public boolean isDefault() {
215         return false;
216     }
217 
218     private static UUID getUpgradeCode(Map&lt;String, ? super Object&gt; params) {
219         String upgradeCode = UPGRADE_UUID.fetchFrom(params);
220         if (upgradeCode != null) {
221             return UUID.fromString(upgradeCode);
222         }
223         return createNameUUID(&quot;UpgradeCode&quot;, params, List.of(VENDOR, APP_NAME));
224     }
225 
226     private static UUID getProductCode(Map&lt;String, ? super Object&gt; params) {
227         return createNameUUID(&quot;ProductCode&quot;, params, List.of(VENDOR, APP_NAME,
228                 VERSION));
229     }
230 
231     private static UUID createNameUUID(String prefix,
232             Map&lt;String, ? super Object&gt; params,
233             List&lt;StandardBundlerParam&lt;String&gt;&gt; components) {
234         String key = Stream.concat(Stream.of(prefix), components.stream().map(
235                 c -&gt; c.fetchFrom(params))).collect(Collectors.joining(&quot;/&quot;));
236         return UUID.nameUUIDFromBytes(key.getBytes(StandardCharsets.UTF_8));
237     }
238 
239     @Override
240     public boolean validate(Map&lt;String, ? super Object&gt; params)
241             throws ConfigException {
242         try {
243             appImageBundler.validate(params);
244 
245             if (wixToolset == null) {
246                 wixToolset = WixTool.toolset();
247             }
248 
249             try {
250                 getUpgradeCode(params);
251             } catch (IllegalArgumentException ex) {
252                 throw new ConfigException(ex);
253             }
254 
255             for (var toolInfo: wixToolset.values()) {
256                 Log.verbose(MessageFormat.format(I18N.getString(
257                         &quot;message.tool-version&quot;), toolInfo.path.getFileName(),
258                         toolInfo.version));
259             }
260 
261             wixSourcesBuilder.setWixVersion(wixToolset.get(WixTool.Light).version);
262 
263             wixSourcesBuilder.logWixFeatures();
264 
265             /********* validate bundle parameters *************/
266 
267             try {
268                 String version = PRODUCT_VERSION.fetchFrom(params);
269                 MsiVersion.of(version);
270             } catch (IllegalArgumentException ex) {
271                 throw new ConfigException(ex.getMessage(), I18N.getString(
272                         &quot;error.version-string-wrong-format.advice&quot;), ex);
273             }
274 
275             FileAssociation.verify(FileAssociation.fetchFrom(params));
276 
277             return true;
278         } catch (RuntimeException re) {
279             if (re.getCause() instanceof ConfigException) {
280                 throw (ConfigException) re.getCause();
281             } else {
282                 throw new ConfigException(re);
283             }
284         }
285     }
286 
287     private void prepareProto(Map&lt;String, ? super Object&gt; params)
288                 throws PackagerException, IOException {
289         File appImage = StandardBundlerParam.getPredefinedAppImage(params);
290         File appDir = null;
291 
292         // we either have an application image or need to build one
293         if (appImage != null) {
294             appDir = new File(MSI_IMAGE_DIR.fetchFrom(params),
295                     APP_NAME.fetchFrom(params));
296             // copy everything from appImage dir into appDir/name
297             IOUtils.copyRecursive(appImage.toPath(), appDir.toPath());
298         } else {
299             appDir = appImageBundler.execute(params, MSI_IMAGE_DIR.fetchFrom(
300                     params));
301         }
302 
303         // Configure installer icon
304         if (StandardBundlerParam.isRuntimeInstaller(params)) {
305             // Use icon from java launcher.
306             // Assume java.exe exists in Java Runtime being packed.
307             // Ignore custom icon if any as we don&#39;t want to copy anything in
308             // Java Runtime image.
309             installerIcon = ApplicationLayout.javaRuntime()
<a name="2" id="anc2"></a>
310                     .runtimeDirectory()
311                     .resolve(Path.of(&quot;bin&quot;, &quot;java.exe&quot;));
312         } else {
313             installerIcon = ApplicationLayout.windowsAppImage()
<a name="3" id="anc3"></a>
314                     .launchersDirectory()
315                     .resolve(APP_NAME.fetchFrom(params) + &quot;.exe&quot;);
316         }
317 
318         params.put(WIN_APP_IMAGE.getID(), appDir);
319 
320         String licenseFile = LICENSE_FILE.fetchFrom(params);
321         if (licenseFile != null) {
322             // need to copy license file to the working directory
323             // and convert to rtf if needed
324             File lfile = new File(licenseFile);
325             File destFile = new File(CONFIG_ROOT.fetchFrom(params),
326                     lfile.getName());
327 
328             IOUtils.copyFile(lfile, destFile);
329             destFile.setWritable(true);
330             ensureByMutationFileIsRTF(destFile);
331         }
332     }
333 
334     @Override
335     public File execute(Map&lt;String, ? super Object&gt; params,
336             File outputParentDir) throws PackagerException {
337 
338         IOUtils.writableOutputDir(outputParentDir.toPath());
339 
340         Path imageDir = MSI_IMAGE_DIR.fetchFrom(params).toPath();
341         try {
342             Files.createDirectories(imageDir);
343 
344             prepareProto(params);
345 
346             wixSourcesBuilder
347             .initFromParams(WIN_APP_IMAGE.fetchFrom(params).toPath(), params)
348             .createMainFragment(CONFIG_ROOT.fetchFrom(params).toPath().resolve(
349                     &quot;bundle.wxf&quot;));
350 
351             Map&lt;String, String&gt; wixVars = prepareMainProjectFile(params);
352 
353             new ScriptRunner()
354             .setDirectory(imageDir)
355             .setResourceCategoryId(&quot;resource.post-app-image-script&quot;)
356             .setScriptNameSuffix(&quot;post-image&quot;)
357             .setEnvironmentVariable(&quot;JpAppImageDir&quot;, imageDir.toAbsolutePath().toString())
358             .run(params);
359 
360             return buildMSI(params, wixVars, outputParentDir);
361         } catch (IOException ex) {
362             Log.verbose(ex);
363             throw new PackagerException(ex);
364         }
365     }
366 
367     private Map&lt;String, String&gt; prepareMainProjectFile(
368             Map&lt;String, ? super Object&gt; params) throws IOException {
369         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
370 
371         final UUID productCode = getProductCode(params);
372         final UUID upgradeCode = getUpgradeCode(params);
373 
374         data.put(&quot;JpProductCode&quot;, productCode.toString());
375         data.put(&quot;JpProductUpgradeCode&quot;, upgradeCode.toString());
376 
377         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.product-code&quot;),
378                 productCode));
379         Log.verbose(MessageFormat.format(I18N.getString(&quot;message.upgrade-code&quot;),
380                 upgradeCode));
381 
382         data.put(&quot;JpAllowUpgrades&quot;, &quot;yes&quot;);
383         data.put(&quot;JpAllowDowngrades&quot;, &quot;yes&quot;);
384 
385         data.put(&quot;JpAppName&quot;, APP_NAME.fetchFrom(params));
386         data.put(&quot;JpAppDescription&quot;, DESCRIPTION.fetchFrom(params));
387         data.put(&quot;JpAppVendor&quot;, VENDOR.fetchFrom(params));
388         data.put(&quot;JpAppVersion&quot;, PRODUCT_VERSION.fetchFrom(params));
389         data.put(&quot;JpIcon&quot;, installerIcon.toString());
390 
391         final Path configDir = CONFIG_ROOT.fetchFrom(params).toPath();
392 
393         data.put(&quot;JpConfigDir&quot;, configDir.toAbsolutePath().toString());
394 
395         if (MSI_SYSTEM_WIDE.fetchFrom(params)) {
396             data.put(&quot;JpIsSystemWide&quot;, &quot;yes&quot;);
397         }
398 
399         String licenseFile = LICENSE_FILE.fetchFrom(params);
400         if (licenseFile != null) {
401             String lname = new File(licenseFile).getName();
402             File destFile = new File(CONFIG_ROOT.fetchFrom(params), lname);
403             data.put(&quot;JpLicenseRtf&quot;, destFile.getAbsolutePath());
404         }
405 
406         // Copy CA dll to include with installer
407         if (INSTALLDIR_CHOOSER.fetchFrom(params)) {
408             data.put(&quot;JpInstallDirChooser&quot;, &quot;yes&quot;);
409             String fname = &quot;wixhelper.dll&quot;;
410             try (InputStream is = OverridableResource.readDefault(fname)) {
411                 Files.copy(is, Paths.get(
412                         CONFIG_ROOT.fetchFrom(params).getAbsolutePath(),
413                         fname));
414             }
415         }
416 
417         // Copy l10n files.
418         for (String loc : Arrays.asList(&quot;en&quot;, &quot;ja&quot;, &quot;zh_CN&quot;)) {
419             String fname = &quot;MsiInstallerStrings_&quot; + loc + &quot;.wxl&quot;;
420             try (InputStream is = OverridableResource.readDefault(fname)) {
421                 Files.copy(is, Paths.get(
422                         CONFIG_ROOT.fetchFrom(params).getAbsolutePath(),
423                         fname));
424             }
425         }
426 
427         createResource(&quot;main.wxs&quot;, params)
428                 .setCategory(I18N.getString(&quot;resource.main-wix-file&quot;))
429                 .saveToFile(configDir.resolve(&quot;main.wxs&quot;));
430 
431         createResource(&quot;overrides.wxi&quot;, params)
432                 .setCategory(I18N.getString(&quot;resource.overrides-wix-file&quot;))
433                 .saveToFile(configDir.resolve(&quot;overrides.wxi&quot;));
434 
435         return data;
436     }
437 
438     private File buildMSI(Map&lt;String, ? super Object&gt; params,
439             Map&lt;String, String&gt; wixVars, File outdir)
440             throws IOException {
441 
442         File msiOut = new File(
443                 outdir, INSTALLER_FILE_NAME.fetchFrom(params) + &quot;.msi&quot;);
444 
445         Log.verbose(MessageFormat.format(I18N.getString(
446                 &quot;message.preparing-msi-config&quot;), msiOut.getAbsolutePath()));
447 
448         WixPipeline wixPipeline = new WixPipeline()
449         .setToolset(wixToolset.entrySet().stream().collect(
450                 Collectors.toMap(
451                         entry -&gt; entry.getKey(),
452                         entry -&gt; entry.getValue().path)))
453         .setWixObjDir(TEMP_ROOT.fetchFrom(params).toPath().resolve(&quot;wixobj&quot;))
454         .setWorkDir(WIN_APP_IMAGE.fetchFrom(params).toPath())
455         .addSource(CONFIG_ROOT.fetchFrom(params).toPath().resolve(&quot;main.wxs&quot;), wixVars)
456         .addSource(CONFIG_ROOT.fetchFrom(params).toPath().resolve(&quot;bundle.wxf&quot;), null);
457 
458         Log.verbose(MessageFormat.format(I18N.getString(
459                 &quot;message.generating-msi&quot;), msiOut.getAbsolutePath()));
460 
461         boolean enableLicenseUI = (LICENSE_FILE.fetchFrom(params) != null);
462         boolean enableInstalldirUI = INSTALLDIR_CHOOSER.fetchFrom(params);
463 
464         if (!MSI_SYSTEM_WIDE.fetchFrom(params)) {
465             wixPipeline.addLightOptions(&quot;-sice:ICE91&quot;);
466         }
467         if (enableLicenseUI || enableInstalldirUI) {
468             wixPipeline.addLightOptions(&quot;-ext&quot;, &quot;WixUIExtension&quot;);
469         }
470 
471         wixPipeline.addLightOptions(&quot;-loc&quot;,
472                 CONFIG_ROOT.fetchFrom(params).toPath().resolve(I18N.getString(
473                         &quot;resource.wxl-file-name&quot;)).toAbsolutePath().toString());
474 
475         // Only needed if we using CA dll, so Wix can find it
476         if (enableInstalldirUI) {
477             wixPipeline.addLightOptions(&quot;-b&quot;, CONFIG_ROOT.fetchFrom(params).getAbsolutePath());
478         }
479 
480         wixPipeline.buildMsi(msiOut.toPath().toAbsolutePath());
481 
482         return msiOut;
483     }
484 
485     private static void ensureByMutationFileIsRTF(File f) {
486         if (f == null || !f.isFile()) return;
487 
488         try {
489             boolean existingLicenseIsRTF = false;
490 
491             try (FileInputStream fin = new FileInputStream(f)) {
492                 byte[] firstBits = new byte[7];
493 
494                 if (fin.read(firstBits) == firstBits.length) {
495                     String header = new String(firstBits);
496                     existingLicenseIsRTF = &quot;{\\rtf1\\&quot;.equals(header);
497                 }
498             }
499 
500             if (!existingLicenseIsRTF) {
501                 List&lt;String&gt; oldLicense = Files.readAllLines(f.toPath());
502                 try (Writer w = Files.newBufferedWriter(
503                         f.toPath(), Charset.forName(&quot;Windows-1252&quot;))) {
504                     w.write(&quot;{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033&quot;
505                             + &quot;{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\n&quot;
506                             + &quot;\\viewkind4\\uc1\\pard\\sa200\\sl276&quot;
507                             + &quot;\\slmult1\\lang9\\fs20 &quot;);
508                     oldLicense.forEach(l -&gt; {
509                         try {
510                             for (char c : l.toCharArray()) {
511                                 // 0x00 &lt;= ch &lt; 0x20 Escaped (\&#39;hh)
512                                 // 0x20 &lt;= ch &lt; 0x80 Raw(non - escaped) char
513                                 // 0x80 &lt;= ch &lt;= 0xFF Escaped(\ &#39;hh)
514                                 // 0x5C, 0x7B, 0x7D (special RTF characters
515                                 // \,{,})Escaped(\&#39;hh)
516                                 // ch &gt; 0xff Escaped (\\ud###?)
517                                 if (c &lt; 0x10) {
518                                     w.write(&quot;\\&#39;0&quot;);
519                                     w.write(Integer.toHexString(c));
520                                 } else if (c &gt; 0xff) {
521                                     w.write(&quot;\\ud&quot;);
522                                     w.write(Integer.toString(c));
523                                     // \\uc1 is in the header and in effect
524                                     // so we trail with a replacement char if
525                                     // the font lacks that character - &#39;?&#39;
526                                     w.write(&quot;?&quot;);
527                                 } else if ((c &lt; 0x20) || (c &gt;= 0x80) ||
528                                         (c == 0x5C) || (c == 0x7B) ||
529                                         (c == 0x7D)) {
530                                     w.write(&quot;\\&#39;&quot;);
531                                     w.write(Integer.toHexString(c));
532                                 } else {
533                                     w.write(c);
534                                 }
535                             }
536                             // blank lines are interpreted as paragraph breaks
537                             if (l.length() &lt; 1) {
538                                 w.write(&quot;\\par&quot;);
539                             } else {
540                                 w.write(&quot; &quot;);
541                             }
542                             w.write(&quot;\r\n&quot;);
543                         } catch (IOException e) {
544                             Log.verbose(e);
545                         }
546                     });
547                     w.write(&quot;}\r\n&quot;);
548                 }
549             }
550         } catch (IOException e) {
551             Log.verbose(e);
552         }
553 
554     }
555 
556     private Path installerIcon;
557     private Map&lt;WixTool, WixTool.ToolInfo&gt; wixToolset;
558     private AppImageBundler appImageBundler;
559     private WixSourcesBuilder wixSourcesBuilder = new WixSourcesBuilder();
560 
561 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
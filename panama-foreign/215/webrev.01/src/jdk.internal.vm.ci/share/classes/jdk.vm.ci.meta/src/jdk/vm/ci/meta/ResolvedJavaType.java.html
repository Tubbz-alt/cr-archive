<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.meta/src/jdk/vm/ci/meta/ResolvedJavaType.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.meta;
 24 
 25 import java.lang.reflect.AnnotatedElement;
 26 
 27 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 28 
 29 /**
 30  * Represents a resolved Java type. Types include primitives, objects, {@code void}, and arrays
 31  * thereof. Types, like fields and methods, are resolved through {@link ConstantPool constant pools}
 32  * .
 33  */
 34 public interface ResolvedJavaType extends JavaType, ModifiersProvider, AnnotatedElement {
 35     /**
 36      * Checks whether this type has a finalizer method.
 37      *
 38      * @return {@code true} if this class has a finalizer
 39      */
 40     boolean hasFinalizer();
 41 
 42     /**
 43      * Checks whether this type has any finalizable subclasses so far. Any decisions based on this
 44      * information require the registration of a dependency, since this information may change.
 45      *
 46      * @return {@code true} if this class has any subclasses with finalizers
 47      */
 48     AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass();
 49 
 50     /**
 51      * Checks whether this type is an interface.
 52      *
 53      * @return {@code true} if this type is an interface
 54      */
 55     @Override
 56     boolean isInterface();
 57 
 58     /**
 59      * Checks whether this type is an instance class.
 60      *
 61      * @return {@code true} if this type is an instance class
 62      */
 63     boolean isInstanceClass();
 64 
 65     /**
 66      * Checks whether this type is primitive.
 67      *
 68      * @return {@code true} if this type is primitive
 69      */
 70     boolean isPrimitive();
 71 
 72     /*
 73      * The setting of the final bit for types is a bit confusing since arrays are marked as final.
 74      * This method provides a semantically equivalent test that appropriate for types.
 75      */
 76     default boolean isLeaf() {
 77         return getElementalType().isFinalFlagSet();
 78     }
 79 
 80     /**
 81      * Checks whether this type is an enum.
 82      *
 83      * @return {@code true} if this type is an enum
 84      */
 85     boolean isEnum();
 86 
 87     /**
 88      * Checks whether this type is initialized. If a type is initialized it implies that it was
 89      * {@link #isLinked() linked} and that the static initializer has run.
 90      *
 91      * @return {@code true} if this type is initialized
 92      */
 93     boolean isInitialized();
 94 
 95     /**
 96      * Initializes this type.
 97      */
 98     void initialize();
 99 
100     /**
101      * Checks whether this type is linked and verified. When a type is linked the static initializer
102      * has not necessarily run. An {@link #isInitialized() initialized} type is always linked.
103      *
104      * @return {@code true} if this type is linked
105      */
106     boolean isLinked();
107 
108     /**
109      * Links this type. If this method returns normally, then future calls of {@link #isLinked} will
110      * return true and future calls of {@link #link} are no-ops. If the method throws an exception,
111      * then future calls of {@link #isLinked} will return false and future calls of {@link #link}
112      * will reattempt the linking step which might succeed or throw an exception.
113      */
114     default void link() {
115         throw new UnsupportedOperationException(&quot;link is unsupported&quot;);
116     }
117 
118     /**
119      * Checks whether this type or any of its supertypes or superinterfaces has default methods.
120      */
121     default boolean hasDefaultMethods() {
122         throw new UnsupportedOperationException(&quot;hasDefaultMethods is unsupported&quot;);
123     }
124 
125     /**
126      * Checks whether this type declares defaults methods.
127      */
128     default boolean declaresDefaultMethods() {
129         throw new UnsupportedOperationException(&quot;declaresDefaultMethods is unsupported&quot;);
130     }
131 
132     /**
133      * Determines if this type is either the same as, or is a superclass or superinterface of, the
134      * type represented by the specified parameter. This method is identical to
135      * {@link Class#isAssignableFrom(Class)} in terms of the value return for this type.
136      */
137     boolean isAssignableFrom(ResolvedJavaType other);
138 
139     /**
140      * Returns the {@link ResolvedJavaType} object representing the host class of this VM anonymous
141      * class (as opposed to the unrelated concept specified by {@link Class#isAnonymousClass()}) or
142      * {@code null} if this object does not represent a VM anonymous class.
143      */
144     ResolvedJavaType getHostClass();
145 
146     /**
147      * Returns true if this type is exactly the type {@link java.lang.Object}.
148      */
149     default boolean isJavaLangObject() {
150         // Removed assertion due to https://bugs.eclipse.org/bugs/show_bug.cgi?id=434442
151         return getSuperclass() == null &amp;&amp; !isInterface() &amp;&amp; getJavaKind() == JavaKind.Object;
152     }
153 
154     /**
155      * Checks whether the specified object is an instance of this type.
156      *
157      * @param obj the object to test
158      * @return {@code true} if the object is an instance of this type
159      */
160     boolean isInstance(JavaConstant obj);
161 
162     /**
163      * Gets the super class of this type. If this type represents either the {@code Object} class,
164      * an interface, a primitive type, or void, then null is returned. If this object represents an
165      * array class then the type object representing the {@code Object} class is returned.
166      */
167     ResolvedJavaType getSuperclass();
168 
169     /**
170      * Gets the interfaces implemented or extended by this type. This method is analogous to
171      * {@link Class#getInterfaces()} and as such, only returns the interfaces directly implemented
172      * or extended by this type.
173      */
174     ResolvedJavaType[] getInterfaces();
175 
176     /**
177      * Gets the single implementor of this type. Calling this method on a non-interface type causes
178      * an exception.
179      * &lt;p&gt;
180      * If the compiler uses the result of this method for its compilation, the usage must be guarded
181      * because the verifier can not guarantee that the assigned type really implements this
182      * interface. Additionally, class loading can invalidate the result of this method.
183      *
184      * @return {@code null} if there is no implementor, the implementor if there is only one, or
185      *         {@code this} if there are more than one.
186      */
187     ResolvedJavaType getSingleImplementor();
188 
189     /**
190      * Walks the class hierarchy upwards and returns the least common class that is a superclass of
191      * both the current and the given type.
192      *
193      * @return the least common type that is a super type of both the current and the given type, or
194      *         {@code null} if primitive types are involved.
195      */
196     ResolvedJavaType findLeastCommonAncestor(ResolvedJavaType otherType);
197 
198     /**
199      * Attempts to get a leaf concrete subclass of this type.
200      * &lt;p&gt;
201      * For an {@linkplain #isArray() array} type A, the leaf concrete subclass is A if the
202      * {@linkplain #getElementalType() elemental} type of A is final (which includes primitive
203      * types). Otherwise {@code null} is returned for A.
204      * &lt;p&gt;
205      * For a non-array type T, the result is the leaf concrete type in the current hierarchy of T.
206      * &lt;p&gt;
207      * A runtime may decide not to manage or walk a large hierarchy and so the result is
208      * conservative. That is, a non-null result is guaranteed to be the leaf concrete class in T&#39;s
209      * hierarchy &lt;b&gt;at the current point in time&lt;/b&gt; but a null result does not necessarily imply
210      * that there is no leaf concrete class in T&#39;s hierarchy.
211      * &lt;p&gt;
212      * If the compiler uses the result of this method for its compilation, it must register the
213      * {@link AssumptionResult} in its {@link Assumptions} because dynamic class loading can
214      * invalidate the result of this method.
215      *
216      * @return an {@link AssumptionResult} containing the leaf concrete subclass for this type as
217      *         described above
218      */
219     AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype();
220 
221     @Override
222     ResolvedJavaType getComponentType();
223 
224     @Override
225     default ResolvedJavaType getElementalType() {
226         ResolvedJavaType t = this;
227         while (t.isArray()) {
228             t = t.getComponentType();
229         }
230         return t;
231     }
232 
233     @Override
234     ResolvedJavaType getArrayClass();
235 
236     /**
237      * Resolves the method implementation for virtual dispatches on objects of this dynamic type.
238      * This resolution process only searches &quot;up&quot; the class hierarchy of this type. A broader search
239      * that also walks &quot;down&quot; the hierarchy is implemented by
240      * {@link #findUniqueConcreteMethod(ResolvedJavaMethod)}. For interface types it returns null
241      * since no concrete object can be an interface.
242      *
243      * @param method the method to select the implementation of
244      * @param callerType the caller or context type used to perform access checks
245      * @return the link-time resolved method (might be abstract) or {@code null} if it is either a
246      *         signature polymorphic method or can not be linked.
247      */
248     ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType);
249 
250     /**
251      * A convenience wrapper for {@link #resolveMethod(ResolvedJavaMethod, ResolvedJavaType)} that
252      * only returns non-abstract methods.
253      *
254      * @param method the method to select the implementation of
255      * @param callerType the caller or context type used to perform access checks
256      * @return the concrete method that would be selected at runtime, or {@code null} if there is no
257      *         concrete implementation of {@code method} in this type or any of its superclasses
258      */
259     default ResolvedJavaMethod resolveConcreteMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
260         ResolvedJavaMethod resolvedMethod = resolveMethod(method, callerType);
261         if (resolvedMethod == null || resolvedMethod.isAbstract()) {
262             return null;
263         }
264         return resolvedMethod;
265     }
266 
267     /**
268      * Given a {@link ResolvedJavaMethod} A, returns a concrete {@link ResolvedJavaMethod} B that is
269      * the only possible unique target for a virtual call on A(). Returns {@code null} if either no
270      * such concrete method or more than one such method exists. Returns the method A if A is a
271      * concrete method that is not overridden.
272      * &lt;p&gt;
273      * If the compiler uses the result of this method for its compilation, it must register an
274      * assumption because dynamic class loading can invalidate the result of this method.
275      *
276      * @param method the method A for which a unique concrete target is searched
277      * @return the unique concrete target or {@code null} if no such target exists or assumptions
278      *         are not supported by this runtime
279      */
280     AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method);
281 
282     /**
283      * Returns the instance fields of this class, including
284      * {@linkplain ResolvedJavaField#isInternal() internal} fields. A zero-length array is returned
285      * for array and primitive types. The order of fields returned by this method is stable. That
286      * is, for a single JVM execution the same order is returned each time this method is called. It
287      * is also the &quot;natural&quot; order, which means that the JVM would expect the fields in this order
288      * if no specific order is given.
289      *
290      * @param includeSuperclasses if true, then instance fields for the complete hierarchy of this
291      *            type are included in the result
292      * @return an array of instance fields
293      */
294     ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses);
295 
296     /**
297      * Returns the static fields of this class, including {@linkplain ResolvedJavaField#isInternal()
298      * internal} fields. A zero-length array is returned for array and primitive types. The order of
299      * fields returned by this method is stable. That is, for a single JVM execution the same order
300      * is returned each time this method is called.
301      */
302     ResolvedJavaField[] getStaticFields();
303 
304     /**
305      * Returns the instance field of this class (or one of its super classes) at the given offset,
306      * or {@code null} if there is no such field.
307      *
308      * @param offset the offset of the field to look for
309      * @return the field with the given offset, or {@code null} if there is no such field.
310      */
311     ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedKind);
312 
313     /**
314      * Returns name of source file of this type.
315      */
316     String getSourceFileName();
317 
318     /**
319      * Returns {@code true} if the type is a local type.
320      */
321     boolean isLocal();
322 
323     /**
324      * Returns {@code true} if the type is a member type.
325      */
326     boolean isMember();
327 
328     /**
329      * Returns the enclosing type of this type, if it exists, or {@code null}.
330      */
331     ResolvedJavaType getEnclosingType();
332 
333     /**
334      * Returns an array reflecting all the constructors declared by this type. This method is
335      * similar to {@link Class#getDeclaredConstructors()} in terms of returned constructors. Calling
336      * this method forces this type to be {@link #link linked}.
337      */
338     ResolvedJavaMethod[] getDeclaredConstructors();
339 
340     /**
341      * Returns an array reflecting all the methods declared by this type. This method is similar to
342      * {@link Class#getDeclaredMethods()} in terms of returned methods. Calling this method forces
343      * this type to be {@link #link linked}.
344      */
345     ResolvedJavaMethod[] getDeclaredMethods();
346 
347     /**
348      * Returns the {@code &lt;clinit&gt;} method for this class if there is one.
349      */
350     ResolvedJavaMethod getClassInitializer();
351 
352     default ResolvedJavaMethod findMethod(String name, Signature signature) {
353         for (ResolvedJavaMethod method : getDeclaredMethods()) {
354             if (method.getName().equals(name) &amp;&amp; method.getSignature().equals(signature)) {
355                 return method;
356             }
357         }
358         return null;
359     }
360 
361     /**
362      * Returns true if this type is {@link Cloneable} and can be safely cloned by creating a normal
363      * Java allocation and populating it from the fields returned by
364      * {@link #getInstanceFields(boolean)}. Some types may require special handling by the platform
365      * so they would to go through the normal {@link Object#clone} path.
366      */
367     boolean isCloneableWithAllocation();
368 
369     /**
370      * Lookup an unresolved type relative to an existing resolved type.
371      */
372     @SuppressWarnings(&quot;unused&quot;)
373     default ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
374         return null;
375     }
376 
377     @SuppressWarnings(&quot;unused&quot;)
378     default ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
379         return null;
380     }
381 }
    </pre>
  </body>
</html>
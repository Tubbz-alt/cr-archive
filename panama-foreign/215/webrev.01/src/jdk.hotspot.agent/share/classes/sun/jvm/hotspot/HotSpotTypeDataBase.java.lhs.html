<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotTypeDataBase.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.types.*;
 31 import sun.jvm.hotspot.types.basic.*;
 32 import sun.jvm.hotspot.utilities.*;
 33 
 34 /** &lt;P&gt; This is the cross-platform TypeDataBase used by the Oop
 35     hierarchy. The decision was made to make this cross-platform by
 36     having the VM export the necessary symbols via a built-in table;
 37     see src/share/vm/runtime/vmStructs.[ch]pp for more details. &lt;/P&gt;
 38 
 39     &lt;P&gt; &lt;B&gt;WARNING&lt;/B&gt;: clients should refer to this class through the
 40     TypeDataBase interface and not directly to the HotSpotTypeDataBase
 41     type. &lt;/P&gt;
 42 
 43     &lt;P&gt; NOTE: since we are fetching the sizes of the Java primitive types
 44  */
 45 
 46 public class HotSpotTypeDataBase extends BasicTypeDataBase {
 47   private Debugger symbolLookup;
 48   private String[] jvmLibNames;
 49   private static final int UNINITIALIZED_SIZE = -1;
 50   private static final int C_INT8_SIZE  = 1;
 51   private static final int C_INT32_SIZE = 4;
 52   private static final int C_INT64_SIZE = 8;
 53   private static int pointerSize = UNINITIALIZED_SIZE;
 54   // Counter to ensure read loops terminate:
 55   private static final int MAX_DUPLICATE_DEFINITIONS = 100;
 56   private int duplicateDefCount = 0;
 57 
 58   private static final boolean DEBUG;
 59   static {
 60     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.HotSpotTypeDataBase.DEBUG&quot;)
 61             != null;
 62   }
 63 
 64   /** &lt;P&gt; This requires a SymbolLookup mechanism as well as the
 65       MachineDescription. Note that we do not need a NameMangler since
 66       we use the vmStructs mechanism to avoid looking up C++
 67       symbols. &lt;/P&gt;
 68 
 69       &lt;P&gt; NOTE that it is guaranteed that this constructor will not
 70       attempt to fetch any Java values from the remote process, only C
 71       integers and addresses. This is required because we are fetching
 72       the sizes of the Java primitive types from the remote process,
 73       implying that attempting to fetch them before their sizes are
 74       known is illegal. &lt;/P&gt;
 75 
 76       &lt;P&gt; Throws NoSuchSymbolException if a problem occurred while
 77       looking up one of the bootstrapping symbols related to the
 78       VMStructs table in the remote VM; this may indicate that the
 79       remote process is not actually a HotSpot VM. &lt;/P&gt;
 80   */
 81   public HotSpotTypeDataBase(MachineDescription machDesc,
 82                              VtblAccess vtblAccess,
 83                              Debugger symbolLookup,
 84                              String[] jvmLibNames) throws NoSuchSymbolException {
 85     super(machDesc, vtblAccess);
 86     this.symbolLookup = symbolLookup;
 87     this.jvmLibNames = jvmLibNames;
 88 
 89     readVMTypes();
 90     initializePrimitiveTypes();
 91     readVMStructs();
 92     readVMIntConstants();
 93     readVMLongConstants();
 94     readExternalDefinitions();
 95   }
 96 
 97   public Type lookupType(String cTypeName, boolean throwException) {
 98     Type fieldType = super.lookupType(cTypeName, false);
 99     if (fieldType == null &amp;&amp; cTypeName.startsWith(&quot;const &quot;)) {
100       fieldType = (BasicType)lookupType(cTypeName.substring(6), false);
101     }
102     if (fieldType == null &amp;&amp; cTypeName.endsWith(&quot; const&quot;)) {
103         fieldType = (BasicType)lookupType(cTypeName.substring(0, cTypeName.length() - 6), false);
104     }
105     if (fieldType == null) {
106       if (cTypeName.startsWith(&quot;GrowableArray&lt;&quot;) &amp;&amp; cTypeName.endsWith(&quot;&gt;&quot;)) {
107         String ttype = cTypeName.substring(&quot;GrowableArray&lt;&quot;.length(),
108                                             cTypeName.length() - 1);
109         Type templateType = lookupType(ttype, false);
110         if (templateType == null &amp;&amp; typeNameIsPointerType(ttype)) {
111           templateType = recursiveCreateBasicPointerType(ttype);
112         }
113         if (templateType == null) {
114           lookupOrFail(ttype);
115         }
116 
117         BasicType basicTargetType = createBasicType(cTypeName, false, false, false);
118 
<a name="1" id="anc1"></a><span class="line-modified">119         // transfer fields from GenericGrowableArray to template instance</span>
<span class="line-modified">120         BasicType generic = lookupOrFail(&quot;GenericGrowableArray&quot;);</span>
121         BasicType specific = lookupOrFail(&quot;GrowableArray&lt;int&gt;&quot;);
122         basicTargetType.setSize(specific.getSize());
123         Iterator fields = generic.getFields();
124         while (fields.hasNext()) {
125           Field f = (Field)fields.next();
126           basicTargetType.addField(internalCreateField(basicTargetType, f.getName(),
127                                                        f.getType(), f.isStatic(),
128                                                        f.getOffset(), null));
129         }
130         fieldType = basicTargetType;
131       }
132     }
133     if (fieldType == null &amp;&amp; typeNameIsPointerType(cTypeName)) {
134       fieldType = recursiveCreateBasicPointerType(cTypeName);
135     }
136     if (fieldType == null &amp;&amp; throwException) {
137       super.lookupType(cTypeName, true);
138     }
139     return fieldType;
140   }
141 
142   private void readVMTypes() {
143     // Get the variables we need in order to traverse the VMTypeEntry[]
144     long typeEntryTypeNameOffset;
145     long typeEntrySuperclassNameOffset;
146     long typeEntryIsOopTypeOffset;
147     long typeEntryIsIntegerTypeOffset;
148     long typeEntryIsUnsignedOffset;
149     long typeEntrySizeOffset;
150     long typeEntryArrayStride;
151 
152     // Fetch the address of the VMTypeEntry*. We get this symbol first
153     // and try to use it to make sure that symbol lookup is working.
154     Address entryAddr = lookupInProcess(&quot;gHotSpotVMTypes&quot;);
155     //    System.err.println(&quot;gHotSpotVMTypes address = &quot; + entryAddr);
156     // Dereference this once to get the pointer to the first VMTypeEntry
157     //    dumpMemory(entryAddr, 80);
158     entryAddr = entryAddr.getAddressAt(0);
159 
160     if (entryAddr == null) {
161       throw new RuntimeException(&quot;gHotSpotVMTypes was not initialized properly in the remote process; can not continue&quot;);
162     }
163 
164     typeEntryTypeNameOffset       = getLongValueFromProcess(&quot;gHotSpotVMTypeEntryTypeNameOffset&quot;);
165     typeEntrySuperclassNameOffset = getLongValueFromProcess(&quot;gHotSpotVMTypeEntrySuperclassNameOffset&quot;);
166     typeEntryIsOopTypeOffset      = getLongValueFromProcess(&quot;gHotSpotVMTypeEntryIsOopTypeOffset&quot;);
167     typeEntryIsIntegerTypeOffset  = getLongValueFromProcess(&quot;gHotSpotVMTypeEntryIsIntegerTypeOffset&quot;);
168     typeEntryIsUnsignedOffset     = getLongValueFromProcess(&quot;gHotSpotVMTypeEntryIsUnsignedOffset&quot;);
169     typeEntrySizeOffset           = getLongValueFromProcess(&quot;gHotSpotVMTypeEntrySizeOffset&quot;);
170     typeEntryArrayStride          = getLongValueFromProcess(&quot;gHotSpotVMTypeEntryArrayStride&quot;);
171 
172     if (typeEntryArrayStride == 0L) {
173       throw new RuntimeException(&quot;zero stride: cannot read types.&quot;);
174     }
175 
176     // Start iterating down it until we find an entry with no name
177     Address typeNameAddr = null;
178     do {
179       // Fetch the type name first
180       typeNameAddr = entryAddr.getAddressAt(typeEntryTypeNameOffset);
181       if (typeNameAddr != null) {
182         String typeName = CStringUtilities.getString(typeNameAddr);
183 
184         String superclassName = null;
185         Address superclassNameAddr = entryAddr.getAddressAt(typeEntrySuperclassNameOffset);
186         if (superclassNameAddr != null) {
187           superclassName = CStringUtilities.getString(superclassNameAddr);
188         }
189 
190         boolean isOopType     = (entryAddr.getCIntegerAt(typeEntryIsOopTypeOffset, C_INT32_SIZE, false) != 0);
191         boolean isIntegerType = (entryAddr.getCIntegerAt(typeEntryIsIntegerTypeOffset, C_INT32_SIZE, false) != 0);
192         boolean isUnsigned    = (entryAddr.getCIntegerAt(typeEntryIsUnsignedOffset, C_INT32_SIZE, false) != 0);
193         long size             = entryAddr.getCIntegerAt(typeEntrySizeOffset, C_INT64_SIZE, true);
194 
195         createType(typeName, superclassName, isOopType, isIntegerType, isUnsigned, size);
196         if (pointerSize == UNINITIALIZED_SIZE &amp;&amp; typeName.equals(&quot;void*&quot;)) {
197           pointerSize = (int)size;
198         }
199       }
200 
201       entryAddr = entryAddr.addOffsetTo(typeEntryArrayStride);
202     } while (typeNameAddr != null &amp;&amp; duplicateDefCount &lt; MAX_DUPLICATE_DEFINITIONS);
203 
204     if (duplicateDefCount &gt;= MAX_DUPLICATE_DEFINITIONS) {
205       throw new RuntimeException(&quot;too many duplicate definitions&quot;);
206     }
207   }
208 
209   private void initializePrimitiveTypes() {
210     // Look up the needed primitive types by name...they had better be present
211     setJBooleanType(lookupPrimitiveType(&quot;jboolean&quot;));
212     setJByteType   (lookupPrimitiveType(&quot;jbyte&quot;));
213     setJCharType   (lookupPrimitiveType(&quot;jchar&quot;));
214     setJDoubleType (lookupPrimitiveType(&quot;jdouble&quot;));
215     setJFloatType  (lookupPrimitiveType(&quot;jfloat&quot;));
216     setJIntType    (lookupPrimitiveType(&quot;jint&quot;));
217     setJLongType   (lookupPrimitiveType(&quot;jlong&quot;));
218     setJShortType  (lookupPrimitiveType(&quot;jshort&quot;));
219 
220     // Indicate that these are the Java primitive types
221     ((BasicType) getJBooleanType()).setIsJavaPrimitiveType(true);
222     ((BasicType) getJByteType()).setIsJavaPrimitiveType(true);
223     ((BasicType) getJCharType()).setIsJavaPrimitiveType(true);
224     ((BasicType) getJDoubleType()).setIsJavaPrimitiveType(true);
225     ((BasicType) getJFloatType()).setIsJavaPrimitiveType(true);
226     ((BasicType) getJIntType()).setIsJavaPrimitiveType(true);
227     ((BasicType) getJLongType()).setIsJavaPrimitiveType(true);
228     ((BasicType) getJShortType()).setIsJavaPrimitiveType(true);
229   }
230 
231   private Type lookupPrimitiveType(String typeName) {
232     Type type = lookupType(typeName, false);
233     if (type == null) {
234       throw new RuntimeException(&quot;Error initializing the HotSpotDataBase: could not find the primitive type \&quot;&quot; +
235                                  typeName + &quot;\&quot; in the remote VM&#39;s VMStructs table. This type is required in &quot; +
236                                  &quot;order to determine the size of Java primitive types. Can not continue.&quot;);
237     }
238     return type;
239   }
240 
241   private void readExternalDefinitions() {
242     String file = System.getProperty(&quot;sun.jvm.hotspot.typedb&quot;);
243     if (file != null) {
244       System.out.println(&quot;Reading &quot; + file);
245       BufferedReader in = null;
246       try {
247         StreamTokenizer t = new StreamTokenizer(in = new BufferedReader(new InputStreamReader(new FileInputStream(file))));
248         t.resetSyntax();
249         t.wordChars(&#39;\u0000&#39;,&#39;\uFFFF&#39;);
250         t.whitespaceChars(&#39; &#39;, &#39; &#39;);
251         t.whitespaceChars(&#39;\n&#39;, &#39;\n&#39;);
252         t.whitespaceChars(&#39;\r&#39;, &#39;\r&#39;);
253         t.quoteChar(&#39;\&quot;&#39;);
254         t.eolIsSignificant(true);
255         while (t.nextToken() != StreamTokenizer.TT_EOF) {
256           if (t.ttype == StreamTokenizer.TT_EOL) {
257             continue;
258           }
259 
260           if (t.sval.equals(&quot;field&quot;)) {
261             t.nextToken();
262             BasicType containingType = (BasicType)lookupType(t.sval);
263             t.nextToken();
264             String fieldName = t.sval;
265 
266             // The field&#39;s Type must already be in the database -- no exceptions
267             t.nextToken();
268             Type fieldType = lookupType(t.sval);
269             t.nextToken();
270             boolean isStatic = Boolean.valueOf(t.sval).booleanValue();
271             t.nextToken();
272             long offset = Long.parseLong(t.sval);
273             t.nextToken();
274             Address staticAddress = null;
275             if (isStatic) {
276               throw new InternalError(&quot;static fields not supported&quot;);
277             }
278 
279             // check to see if the field already exists
280             Iterator i = containingType.getFields();
281             boolean defined = false;
282             while (i.hasNext()) {
283               Field f = (Field) i.next();
284               if (f.getName().equals(fieldName)) {
285                 if (f.isStatic() != isStatic) {
286                   throw new RuntimeException(&quot;static/nonstatic mismatch: &quot; + fieldName);
287                 }
288                 if (!isStatic) {
289                   if (f.getOffset() != offset) {
290                     throw new RuntimeException(&quot;bad redefinition of field offset: &quot; + fieldName);
291                   }
292                 } else {
293                   if (!f.getStaticFieldAddress().equals(staticAddress)) {
294                     throw new RuntimeException(&quot;bad redefinition of field location: &quot; + fieldName);
295                   }
296                 }
297                 if (f.getType() != fieldType) {
298                   System.out.println(fieldType);
299                   System.out.println(f.getType());
300                   throw new RuntimeException(&quot;bad redefinition of field type: &quot; + fieldName);
301                 }
302                 defined = true;
303                 break;
304               }
305             }
306 
307             if (!defined) {
308               // Create field by type
309               createField(containingType,
310                           fieldName, fieldType,
311                           isStatic,
312                           offset,
313                           staticAddress);
314             }
315           } else if (t.sval.equals(&quot;type&quot;)) {
316             t.nextToken();
317             String typeName = t.sval;
318             t.nextToken();
319             String superclassName = t.sval;
320             if (superclassName.equals(&quot;null&quot;)) {
321               superclassName = null;
322             }
323             t.nextToken();
324             boolean isOop = Boolean.valueOf(t.sval).booleanValue();
325             t.nextToken();
326             boolean isInteger = Boolean.valueOf(t.sval).booleanValue();
327             t.nextToken();
328             boolean isUnsigned = Boolean.valueOf(t.sval).booleanValue();
329             t.nextToken();
330             long size = Long.parseLong(t.sval);
331 
332             BasicType type = null;
333             try {
334               type = (BasicType)lookupType(typeName);
335             } catch (RuntimeException e) {
336             }
337             if (type != null) {
338               if (type.isOopType() != isOop) {
339                 throw new RuntimeException(&quot;oop mismatch in type definition: &quot; + typeName);
340               }
341               if (type.isCIntegerType() != isInteger) {
342                 throw new RuntimeException(&quot;integer type mismatch in type definition: &quot; + typeName);
343               }
344               if (type.isCIntegerType() &amp;&amp; (((CIntegerType)type).isUnsigned()) != isUnsigned) {
345                 throw new RuntimeException(&quot;unsigned mismatch in type definition: &quot; + typeName);
346               }
347               if (type.getSuperclass() == null) {
348                 if (superclassName != null) {
349                   if (type.getSize() == -1) {
350                     type.setSuperclass(lookupType(superclassName));
351                   } else {
352                     throw new RuntimeException(&quot;unexpected superclass in type definition: &quot; + typeName);
353                   }
354                 }
355               } else {
356                 if (superclassName == null) {
357                   throw new RuntimeException(&quot;missing superclass in type definition: &quot; + typeName);
358                 }
359                 if (!type.getSuperclass().getName().equals(superclassName)) {
360                   throw new RuntimeException(&quot;incorrect superclass in type definition: &quot; + typeName);
361                 }
362               }
363               if (type.getSize() != size) {
364                 if (type.getSize() == -1 || type.getSize() == 0) {
365                   type.setSize(size);
366                 } else {
367                   throw new RuntimeException(&quot;size mismatch in type definition: &quot; + typeName + &quot;: &quot; + type.getSize() + &quot; != &quot; + size);
368                 }
369               }
370             }
371 
372             if (lookupType(typeName, false) == null) {
373               // Create type
374               createType(typeName, superclassName, isOop, isInteger, isUnsigned, size);
375             }
376           } else {
377             throw new InternalError(&quot;\&quot;&quot; + t.sval + &quot;\&quot;&quot;);
378           }
379         }
380       } catch (IOException ioe) {
381         ioe.printStackTrace();
382       } finally {
383         try {
384           in.close();
385         } catch (Exception e) {
386         }
387       }
388     }
389   }
390 
391   private void readVMStructs() {
392     // Get the variables we need in order to traverse the VMStructEntry[]
393     long structEntryTypeNameOffset;
394     long structEntryFieldNameOffset;
395     long structEntryTypeStringOffset;
396     long structEntryIsStaticOffset;
397     long structEntryOffsetOffset;
398     long structEntryAddressOffset;
399     long structEntryArrayStride;
400 
401     structEntryTypeNameOffset     = getLongValueFromProcess(&quot;gHotSpotVMStructEntryTypeNameOffset&quot;);
402     structEntryFieldNameOffset    = getLongValueFromProcess(&quot;gHotSpotVMStructEntryFieldNameOffset&quot;);
403     structEntryTypeStringOffset   = getLongValueFromProcess(&quot;gHotSpotVMStructEntryTypeStringOffset&quot;);
404     structEntryIsStaticOffset     = getLongValueFromProcess(&quot;gHotSpotVMStructEntryIsStaticOffset&quot;);
405     structEntryOffsetOffset       = getLongValueFromProcess(&quot;gHotSpotVMStructEntryOffsetOffset&quot;);
406     structEntryAddressOffset      = getLongValueFromProcess(&quot;gHotSpotVMStructEntryAddressOffset&quot;);
407     structEntryArrayStride        = getLongValueFromProcess(&quot;gHotSpotVMStructEntryArrayStride&quot;);
408 
409     if (structEntryArrayStride == 0L) {
410       throw new RuntimeException(&quot;zero stride: cannot read types.&quot;);
411     }
412 
413     // Fetch the address of the VMStructEntry*
414     Address entryAddr = lookupInProcess(&quot;gHotSpotVMStructs&quot;);
415     // Dereference this once to get the pointer to the first VMStructEntry
416     entryAddr = entryAddr.getAddressAt(0);
417     if (entryAddr == null) {
418       throw new RuntimeException(&quot;gHotSpotVMStructs was not initialized properly in the remote process; can not continue&quot;);
419     }
420 
421     // Start iterating down it until we find an entry with no name
422     Address fieldNameAddr = null;
423     String typeName = null;
424     String fieldName = null;
425     String typeString = null;
426     boolean isStatic = false;
427     long offset = 0;
428     Address staticFieldAddr = null;
429     long size = 0;
430     long index = 0;
431     String opaqueName = &quot;&lt;opaque&gt;&quot;;
432     lookupOrCreateClass(opaqueName, false, false, false);
433 
434     do {
435       // Fetch the field name first
436       fieldNameAddr = entryAddr.getAddressAt(structEntryFieldNameOffset);
437       if (fieldNameAddr != null) {
438         fieldName = CStringUtilities.getString(fieldNameAddr);
439 
440         // Now the rest of the names. Keep in mind that the type name
441         // may be NULL, indicating that the type is opaque.
442         Address addr = entryAddr.getAddressAt(structEntryTypeNameOffset);
443         if (addr == null) {
444           throw new RuntimeException(&quot;gHotSpotVMStructs unexpectedly had a NULL type name at index &quot; + index);
445         }
446         typeName = CStringUtilities.getString(addr);
447 
448         addr = entryAddr.getAddressAt(structEntryTypeStringOffset);
449         if (addr == null) {
450           typeString = opaqueName;
451         } else {
452           typeString = CStringUtilities.getString(addr);
453         }
454 
455         isStatic = !(entryAddr.getCIntegerAt(structEntryIsStaticOffset, C_INT32_SIZE, false) == 0);
456         if (isStatic) {
457           staticFieldAddr = entryAddr.getAddressAt(structEntryAddressOffset);
458           offset = 0;
459         } else {
460           offset = entryAddr.getCIntegerAt(structEntryOffsetOffset, C_INT64_SIZE, true);
461           staticFieldAddr = null;
462         }
463 
464         // The containing Type must already be in the database -- no exceptions
465         BasicType containingType = lookupOrFail(typeName);
466 
467         // The field&#39;s Type must already be in the database -- no exceptions
468         BasicType fieldType = (BasicType)lookupType(typeString);
469 
470         // Create field by type
471         createField(containingType, fieldName, fieldType,
472                     isStatic, offset, staticFieldAddr);
473       }
474 
475       ++index;
476       entryAddr = entryAddr.addOffsetTo(structEntryArrayStride);
477     } while (fieldNameAddr != null);
478   }
479 
480   private void readVMIntConstants() {
481     // Get the variables we need in order to traverse the VMIntConstantEntry[]
482     long intConstantEntryNameOffset;
483     long intConstantEntryValueOffset;
484     long intConstantEntryArrayStride;
485 
486     intConstantEntryNameOffset  = getLongValueFromProcess(&quot;gHotSpotVMIntConstantEntryNameOffset&quot;);
487     intConstantEntryValueOffset = getLongValueFromProcess(&quot;gHotSpotVMIntConstantEntryValueOffset&quot;);
488     intConstantEntryArrayStride = getLongValueFromProcess(&quot;gHotSpotVMIntConstantEntryArrayStride&quot;);
489 
490     if (intConstantEntryArrayStride == 0L) {
491       throw new RuntimeException(&quot;zero stride: cannot read types.&quot;);
492     }
493 
494 
495     // Fetch the address of the VMIntConstantEntry*
496     Address entryAddr = lookupInProcess(&quot;gHotSpotVMIntConstants&quot;);
497     // Dereference this once to get the pointer to the first VMIntConstantEntry
498     entryAddr = entryAddr.getAddressAt(0);
499     if (entryAddr == null) {
500       throw new RuntimeException(&quot;gHotSpotVMIntConstants was not initialized properly in the remote process; can not continue&quot;);
501     }
502 
503     // Start iterating down it until we find an entry with no name
504     Address nameAddr = null;
505     do {
506       // Fetch the type name first
507       nameAddr = entryAddr.getAddressAt(intConstantEntryNameOffset);
508       if (nameAddr != null) {
509         String name = CStringUtilities.getString(nameAddr);
510         int value = (int) entryAddr.getCIntegerAt(intConstantEntryValueOffset, C_INT32_SIZE, false);
511 
512         // Be a little resilient
513         Integer oldValue = lookupIntConstant(name, false);
514         if (oldValue == null) {
515           addIntConstant(name, value);
516         } else {
517           if (oldValue.intValue() != value) {
518             throw new RuntimeException(&quot;Error: the integer constant \&quot;&quot; + name +
519                                        &quot;\&quot; had its value redefined (old was &quot; + oldValue +
520                                        &quot;, new is &quot; + value + &quot;. Aborting.&quot;);
521           } else {
522             System.err.println(&quot;Warning: the int constant \&quot;&quot; + name + &quot;\&quot; (declared in the remote VM in VMStructs::localHotSpotVMIntConstants) &quot; +
523                                &quot;had its value declared as &quot; + value + &quot; twice. Continuing.&quot;);
524             duplicateDefCount++;
525           }
526         }
527       }
528 
529       entryAddr = entryAddr.addOffsetTo(intConstantEntryArrayStride);
530     } while (nameAddr != null &amp;&amp; duplicateDefCount &lt; MAX_DUPLICATE_DEFINITIONS);
531 
532     if (duplicateDefCount &gt;= MAX_DUPLICATE_DEFINITIONS) {
533       throw new RuntimeException(&quot;too many duplicate definitions&quot;);
534     }
535   }
536 
537   private void readVMLongConstants() {
538     // Get the variables we need in order to traverse the VMLongConstantEntry[]
539     long longConstantEntryNameOffset;
540     long longConstantEntryValueOffset;
541     long longConstantEntryArrayStride;
542 
543     longConstantEntryNameOffset  = getLongValueFromProcess(&quot;gHotSpotVMLongConstantEntryNameOffset&quot;);
544     longConstantEntryValueOffset = getLongValueFromProcess(&quot;gHotSpotVMLongConstantEntryValueOffset&quot;);
545     longConstantEntryArrayStride = getLongValueFromProcess(&quot;gHotSpotVMLongConstantEntryArrayStride&quot;);
546 
547     if (longConstantEntryArrayStride == 0L) {
548       throw new RuntimeException(&quot;zero stride: cannot read types.&quot;);
549     }
550 
551     // Fetch the address of the VMLongConstantEntry*
552     Address entryAddr = lookupInProcess(&quot;gHotSpotVMLongConstants&quot;);
553     // Dereference this once to get the pointer to the first VMLongConstantEntry
554     entryAddr = entryAddr.getAddressAt(0);
555     if (entryAddr == null) {
556       throw new RuntimeException(&quot;gHotSpotVMLongConstants was not initialized properly in the remote process; can not continue&quot;);
557     }
558 
559     // Start iterating down it until we find an entry with no name
560     Address nameAddr = null;
561     do {
562       // Fetch the type name first
563       nameAddr = entryAddr.getAddressAt(longConstantEntryNameOffset);
564       if (nameAddr != null) {
565         String name = CStringUtilities.getString(nameAddr);
566         long value = entryAddr.getCIntegerAt(longConstantEntryValueOffset, C_INT64_SIZE, true);
567 
568         // Be a little resilient
569         Long oldValue = lookupLongConstant(name, false);
570         if (oldValue == null) {
571           addLongConstant(name, value);
572         } else {
573           if (oldValue.longValue() != value) {
574             throw new RuntimeException(&quot;Error: the long constant \&quot;&quot; + name +
575                                        &quot;\&quot; had its value redefined (old was &quot; + oldValue +
576                                        &quot;, new is &quot; + value + &quot;. Aborting.&quot;);
577           } else {
578             System.err.println(&quot;Warning: the long constant \&quot;&quot; + name + &quot;\&quot; (declared in the remote VM in VMStructs::localHotSpotVMLongConstants) &quot; +
579                                &quot;had its value declared as &quot; + value + &quot; twice. Continuing.&quot;);
580             duplicateDefCount++;
581           }
582         }
583       }
584 
585       entryAddr = entryAddr.addOffsetTo(longConstantEntryArrayStride);
586     } while (nameAddr != null &amp;&amp; duplicateDefCount &lt; MAX_DUPLICATE_DEFINITIONS);
587 
588     if (duplicateDefCount &gt;= MAX_DUPLICATE_DEFINITIONS) {
589       throw new RuntimeException(&quot;too many duplicate definitions.&quot;);
590     }
591   }
592 
593   private BasicType lookupOrFail(String typeName) {
594     BasicType type = (BasicType) lookupType(typeName, false);
595     if (type == null) {
596       throw new RuntimeException(&quot;Type \&quot;&quot; + typeName + &quot;\&quot;, referenced in VMStructs::localHotSpotVMStructs in the remote VM, &quot; +
597                                  &quot;was not present in the remote VMStructs::localHotSpotVMTypes table (should have been caught &quot; +
598                                  &quot;in the debug build of that VM). Can not continue.&quot;);
599     }
600     return type;
601   }
602 
603   private long getLongValueFromProcess(String symbol) {
604     return lookupInProcess(symbol).getCIntegerAt(0, C_INT64_SIZE, true);
605   }
606 
607   private Address lookupInProcess(String symbol) throws NoSuchSymbolException {
608     // FIXME: abstract away the loadobject name
609     for (int i = 0; i &lt; jvmLibNames.length; i++) {
610       Address addr = symbolLookup.lookup(jvmLibNames[i], symbol);
611       if (addr != null) {
612         return addr;
613       }
614     }
615     String errStr = &quot;(&quot;;
616     for (int i = 0; i &lt; jvmLibNames.length; i++) {
617       errStr += jvmLibNames[i];
618       if (i &lt; jvmLibNames.length - 1) {
619         errStr += &quot;, &quot;;
620       }
621     }
622     errStr += &quot;)&quot;;
623     throw new NoSuchSymbolException(symbol,
624                                     &quot;Could not find symbol \&quot;&quot; + symbol +
625                                     &quot;\&quot; in any of the known library names &quot; +
626                                     errStr);
627   }
628 
629   private BasicType lookupOrCreateClass(String typeName, boolean isOopType,
630                                         boolean isIntegerType, boolean isUnsigned) {
631     BasicType type = (BasicType) lookupType(typeName, false);
632     if (type == null) {
633       // Create a new type
634       type = createBasicType(typeName, isOopType, isIntegerType, isUnsigned);
635     }
636     return type;
637   }
638 
639   /** Creates a new BasicType, initializes its size to -1 so we can
640       test to ensure that all types&#39; sizes are initialized by VMTypes,
641       and adds it to the database. Takes care of initializing integer
642       and oop types properly. */
643   private BasicType createBasicType(String typeName, boolean isOopType,
644                                     boolean isIntegerType, boolean isUnsigned) {
645 
646     BasicType type = null;
647 
648     if (isIntegerType) {
649       type = new BasicCIntegerType(this, typeName, isUnsigned);
650     } else {
651       if (typeNameIsPointerType(typeName)) {
652         type = recursiveCreateBasicPointerType(typeName);
653       } else {
654         type = new BasicType(this, typeName);
655       }
656 
657       if (isOopType) {
658         type.setIsOopType(true);
659       }
660     }
661 
662     type.setSize(UNINITIALIZED_SIZE);
663     addType(type);
664     return type;
665   }
666 
667   /** Recursively creates a PointerType from the string representation
668       of the type&#39;s name. Note that this currently needs some
669       workarounds due to incomplete information in the VMStructs
670       database. */
671   private BasicPointerType recursiveCreateBasicPointerType(String typeName) {
672     BasicPointerType result = (BasicPointerType)super.lookupType(typeName, false);
673     if (result != null) {
674       return result;
675     }
676     String targetTypeName = typeName.substring(0, typeName.lastIndexOf(&#39;*&#39;)).trim();
677     Type targetType = null;
678     if (typeNameIsPointerType(targetTypeName)) {
679       targetType = lookupType(targetTypeName, false);
680       if (targetType == null) {
681         targetType = recursiveCreateBasicPointerType(targetTypeName);
682       }
683     } else {
684       targetType = lookupType(targetTypeName, false);
685       if (targetType == null) {
686         // Workaround for missing C integer types in database.
687         // Also looks like we can&#39;t throw an exception for other
688         // missing target types because there are some in old
689         // VMStructs tables that didn&#39;t have the target type declared.
690         // For this case, we create basic types that never get filled
691         // in.
692 
693         if (targetTypeName.equals(&quot;char&quot;) ||
694             targetTypeName.equals(&quot;const char&quot;)) {
695           // We don&#39;t have a representation of const-ness of C types in the SA
696           BasicType basicTargetType = createBasicType(targetTypeName, false, true, false);
697           basicTargetType.setSize(1);
698           targetType = basicTargetType;
699         } else if (targetTypeName.equals(&quot;u_char&quot;)) {
700           BasicType basicTargetType = createBasicType(targetTypeName, false, true, true);
701           basicTargetType.setSize(1);
702           targetType = basicTargetType;
703         } else {
704           if (DEBUG) {
705             System.err.println(&quot;WARNING: missing target type \&quot;&quot; + targetTypeName + &quot;\&quot; for pointer type \&quot;&quot; + typeName + &quot;\&quot;&quot;);
706           }
707           targetType = createBasicType(targetTypeName, false, false, false);
708         }
709       }
710     }
711     result = new BasicPointerType(this, typeName, targetType);
712     if (pointerSize == UNINITIALIZED_SIZE &amp;&amp; !typeName.equals(&quot;void*&quot;)) {
713       // void* must be declared early so that other pointer types can use that to set their size.
714       throw new InternalError(&quot;void* type hasn&#39;t been seen when parsing &quot; + typeName);
715     }
716     result.setSize(pointerSize);
717     addType(result);
718     return result;
719   }
720 
721   private boolean typeNameIsPointerType(String typeName) {
722     int i = typeName.length() - 1;
723     while (i &gt;= 0 &amp;&amp; Character.isWhitespace(typeName.charAt(i))) {
724       --i;
725     }
726     if (i &gt;= 0 &amp;&amp; typeName.charAt(i) == &#39;*&#39;) {
727       return true;
728     }
729     return false;
730   }
731 
732     public void createType(String typeName, String superclassName,
733                            boolean isOopType, boolean isIntegerType,
734                            boolean isUnsigned, long size) {
735         // See whether we have a superclass
736         BasicType superclass = null;
737         if (superclassName != null) {
738             // Fetch or create it (FIXME: would get oop types wrong if
739             // they had a hierarchy; consider using lookupOrFail)
740             superclass = lookupOrCreateClass(superclassName, false, false, false);
741         }
742 
743         // Lookup or create the current type
744         BasicType curType = lookupOrCreateClass(typeName, isOopType, isIntegerType, isUnsigned);
745         // Set superclass and/or ensure it&#39;s correct
746         if (superclass != null) {
747             if (curType.getSuperclass() == null) {
748                 // Set the superclass in the current type
749                 curType.setSuperclass(superclass);
750             }
751 
752             if (curType.getSuperclass() != superclass) {
753                 throw new RuntimeException(&quot;Error: the type \&quot;&quot; + typeName + &quot;\&quot; (declared in the remote VM in VMStructs::localHotSpotVMTypes) &quot; +
754                                            &quot;had its superclass redefined (old was &quot; + curType.getSuperclass().getName() + &quot;, new is &quot; +
755                                            superclass.getName() + &quot;).&quot;);
756             }
757         }
758 
759         // Classes are created with a size of UNINITIALIZED_SIZE.
760         // Set size if necessary.
761         if (curType.getSize() == UNINITIALIZED_SIZE || curType.getSize() == 0) {
762             curType.setSize(size);
763         } else {
764             if (curType.getSize() != size) {
765                 throw new RuntimeException(&quot;Error: the type \&quot;&quot; + typeName + &quot;\&quot; (declared in the remote VM in VMStructs::localHotSpotVMTypes) &quot; +
766                                            &quot;had its size redefined (old was &quot; + curType.getSize() + &quot;, new is &quot; + size + &quot;).&quot;);
767             }
768 
769             if (!typeNameIsPointerType(typeName)) {
770                 System.err.println(&quot;Warning: the type \&quot;&quot; + typeName + &quot;\&quot; (declared in the remote VM in VMStructs::localHotSpotVMTypes) &quot; +
771                                    &quot;had its size declared as &quot; + size + &quot; twice. Continuing.&quot;);
772                 duplicateDefCount++;
773             }
774         }
775 
776     }
777 
778     /** &quot;Virtual constructor&quot; for fields based on type */
779     public void createField(BasicType containingType,
780                             String name, Type type, boolean isStatic,
781                             long offset, Address staticFieldAddress) {
782         // Add field to containing type
783         containingType.addField(internalCreateField(containingType, name, type, isStatic, offset, staticFieldAddress));
784     }
785 
786     Field internalCreateField(BasicType containingType,
787                               String name, Type type, boolean isStatic,
788                               long offset, Address staticFieldAddress) {
789     // &quot;Virtual constructor&quot; based on type
790     if (type.isOopType()) {
791       return new BasicOopField(this, containingType, name, type,
792                                isStatic, offset, staticFieldAddress);
793     }
794 
795     if (type instanceof CIntegerType) {
796       return new BasicCIntegerField(this, containingType, name, type,
797                                     isStatic, offset, staticFieldAddress);
798     }
799 
800     if (type.equals(getJBooleanType())) {
801       return new BasicJBooleanField(this, containingType, name, type,
802                                     isStatic, offset, staticFieldAddress);
803     }
804 
805     if (type.equals(getJByteType())) {
806       return new BasicJByteField(this, containingType, name, type,
807                                  isStatic, offset, staticFieldAddress);
808     }
809 
810     if (type.equals(getJCharType())) {
811       return new BasicJCharField(this, containingType, name, type,
812                                  isStatic, offset, staticFieldAddress);
813     }
814 
815     if (type.equals(getJDoubleType())) {
816       return new BasicJDoubleField(this, containingType, name, type,
817                                    isStatic, offset, staticFieldAddress);
818     }
819 
820     if (type.equals(getJFloatType())) {
821       return new BasicJFloatField(this, containingType, name, type,
822                                   isStatic, offset, staticFieldAddress);
823     }
824 
825     if (type.equals(getJIntType())) {
826       return new BasicJIntField(this, containingType, name, type,
827                                 isStatic, offset, staticFieldAddress);
828     }
829 
830     if (type.equals(getJLongType())) {
831       return new BasicJLongField(this, containingType, name, type,
832                                  isStatic, offset, staticFieldAddress);
833     }
834 
835     if (type.equals(getJShortType())) {
836       return new BasicJShortField(this, containingType, name, type,
837                                   isStatic, offset, staticFieldAddress);
838     }
839 
840     // Unknown (&quot;opaque&quot;) type. Instantiate ordinary Field.
841     return new BasicField(this, containingType, name, type,
842                           isStatic, offset, staticFieldAddress);
843   }
844 
845   // For debugging
846   private void dumpMemory(Address addr, int len) {
847     int i = 0;
848     while (i &lt; len) {
849       System.err.print(addr.addOffsetTo(i) + &quot;:&quot;);
850       for (int j = 0; j &lt; 8 &amp;&amp; i &lt; len; i++, j++) {
851         String s = Long.toHexString(addr.getCIntegerAt(i, 1, true));
852         System.err.print(&quot; 0x&quot;);
853         for (int k = 0; k &lt; 2 - s.length(); k++) {
854           System.err.print(&quot;0&quot;);
855         }
856         System.err.print(s);
857       }
858       System.err.println();
859     }
860   }
861 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
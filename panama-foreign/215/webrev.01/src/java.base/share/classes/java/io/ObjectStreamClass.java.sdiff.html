<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/io/ObjectStreamClass.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PipedWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/io/ObjectStreamClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.lang.invoke.MethodHandle;
  29 import java.lang.invoke.MethodHandles;

  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.SoftReference;
  33 import java.lang.ref.WeakReference;
  34 import java.lang.reflect.Constructor;
  35 import java.lang.reflect.Field;
  36 import java.lang.reflect.InvocationTargetException;
  37 import java.lang.reflect.RecordComponent;
  38 import java.lang.reflect.UndeclaredThrowableException;
  39 import java.lang.reflect.Member;
  40 import java.lang.reflect.Method;
  41 import java.lang.reflect.Modifier;
  42 import java.lang.reflect.Proxy;
  43 import java.security.AccessControlContext;
  44 import java.security.AccessController;
  45 import java.security.MessageDigest;
  46 import java.security.NoSuchAlgorithmException;
  47 import java.security.PermissionCollection;
  48 import java.security.Permissions;
  49 import java.security.PrivilegedAction;
  50 import java.security.PrivilegedActionException;
  51 import java.security.PrivilegedExceptionAction;
  52 import java.security.ProtectionDomain;
  53 import java.util.ArrayList;
  54 import java.util.Arrays;
  55 import java.util.Collections;
  56 import java.util.Comparator;
  57 import java.util.HashSet;

  58 import java.util.Set;
  59 import java.util.concurrent.ConcurrentHashMap;
  60 import java.util.concurrent.ConcurrentMap;
  61 import jdk.internal.misc.Unsafe;
  62 import jdk.internal.reflect.CallerSensitive;
  63 import jdk.internal.reflect.Reflection;
  64 import jdk.internal.reflect.ReflectionFactory;
  65 import jdk.internal.access.SharedSecrets;
  66 import jdk.internal.access.JavaSecurityAccess;
  67 import sun.reflect.misc.ReflectUtil;
  68 import static java.io.ObjectStreamField.*;
  69 
  70 /**
  71  * Serialization&#39;s descriptor for classes.  It contains the name and
  72  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  73  * loaded in this Java VM can be found/created using the lookup method.
  74  *
  75  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  76  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  77  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
</pre>
<hr />
<pre>
 174     /** exception (if any) to throw if non-enum deserialization attempted */
 175     private ExceptionInfo deserializeEx;
 176     /** exception (if any) to throw if non-enum serialization attempted */
 177     private ExceptionInfo serializeEx;
 178     /** exception (if any) to throw if default serialization attempted */
 179     private ExceptionInfo defaultSerializeEx;
 180 
 181     /** serializable fields */
 182     private ObjectStreamField[] fields;
 183     /** aggregate marshalled size of primitive fields */
 184     private int primDataSize;
 185     /** number of non-primitive fields */
 186     private int numObjFields;
 187     /** reflector for setting/getting serializable field values */
 188     private FieldReflector fieldRefl;
 189     /** data layout of serialized objects described by this class desc */
 190     private volatile ClassDataSlot[] dataLayout;
 191 
 192     /** serialization-appropriate constructor, or null if none */
 193     private Constructor&lt;?&gt; cons;
<span class="line-modified"> 194     /** record canonical constructor, or null */</span>
 195     private MethodHandle canonicalCtr;






 196     /** protection domains that need to be checked when calling the constructor */
 197     private ProtectionDomain[] domains;
 198 
 199     /** class-defined writeObject method, or null if none */
 200     private Method writeObjectMethod;
 201     /** class-defined readObject method, or null if none */
 202     private Method readObjectMethod;
 203     /** class-defined readObjectNoData method, or null if none */
 204     private Method readObjectNoDataMethod;
 205     /** class-defined writeReplace method, or null if none */
 206     private Method writeReplaceMethod;
 207     /** class-defined readResolve method, or null if none */
 208     private Method readResolveMethod;
 209 
 210     /** local class descriptor for represented class (may point to self) */
 211     private ObjectStreamClass localDesc;
 212     /** superclass descriptor appearing in stream */
 213     private ObjectStreamClass superDesc;
 214 
 215     /** true if, and only if, the object has been correctly initialized */
</pre>
<hr />
<pre>
 508                         fields = NO_FIELDS;
 509                         return null;
 510                     }
 511                     if (cl.isArray()) {
 512                         fields = NO_FIELDS;
 513                         return null;
 514                     }
 515 
 516                     suid = getDeclaredSUID(cl);
 517                     try {
 518                         fields = getSerialFields(cl);
 519                         computeFieldOffsets();
 520                     } catch (InvalidClassException e) {
 521                         serializeEx = deserializeEx =
 522                             new ExceptionInfo(e.classname, e.getMessage());
 523                         fields = NO_FIELDS;
 524                     }
 525 
 526                     if (isRecord) {
 527                         canonicalCtr = canonicalRecordCtr(cl);

 528                     } else if (externalizable) {
 529                         cons = getExternalizableConstructor(cl);
 530                     } else {
 531                         cons = getSerializableConstructor(cl);
 532                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 533                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 534                             Void.TYPE);
 535                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 536                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 537                             Void.TYPE);
 538                         readObjectNoDataMethod = getPrivateMethod(
 539                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 540                         hasWriteObjectData = (writeObjectMethod != null);
 541                     }
 542                     domains = getProtectionDomains(cons, cl);
 543                     writeReplaceMethod = getInheritableMethod(
 544                         cl, &quot;writeReplace&quot;, null, Object.class);
 545                     readResolveMethod = getInheritableMethod(
 546                         cl, &quot;readResolve&quot;, null, Object.class);
 547                     return null;
</pre>
<hr />
<pre>
 721                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 722             }
 723 
 724             if (!model.isEnum) {
 725                 if ((model.serializable == osc.serializable) &amp;&amp;
 726                         (model.externalizable != osc.externalizable)) {
 727                     throw new InvalidClassException(osc.name,
 728                             &quot;Serializable incompatible with Externalizable&quot;);
 729                 }
 730 
 731                 if ((model.serializable != osc.serializable) ||
 732                         (model.externalizable != osc.externalizable) ||
 733                         !(model.serializable || model.externalizable)) {
 734                     deserializeEx = new ExceptionInfo(
 735                             osc.name, &quot;class invalid for deserialization&quot;);
 736                 }
 737             }
 738         }
 739 
 740         this.cl = cl;
<span class="line-removed"> 741         if (cl != null) {</span>
<span class="line-removed"> 742             this.isRecord = isRecord(cl);</span>
<span class="line-removed"> 743             this.canonicalCtr = osc.canonicalCtr;</span>
<span class="line-removed"> 744         }</span>
 745         this.resolveEx = resolveEx;
 746         this.superDesc = superDesc;
 747         name = model.name;
 748         this.suid = suid;
 749         isProxy = false;
 750         isEnum = model.isEnum;
 751         serializable = model.serializable;
 752         externalizable = model.externalizable;
 753         hasBlockExternalData = model.hasBlockExternalData;
 754         hasWriteObjectData = model.hasWriteObjectData;
 755         fields = model.fields;
 756         primDataSize = model.primDataSize;
 757         numObjFields = model.numObjFields;
 758 
 759         if (osc != null) {
 760             localDesc = osc;





 761             writeObjectMethod = localDesc.writeObjectMethod;
 762             readObjectMethod = localDesc.readObjectMethod;
 763             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 764             writeReplaceMethod = localDesc.writeReplaceMethod;
 765             readResolveMethod = localDesc.readResolveMethod;
 766             if (deserializeEx == null) {
 767                 deserializeEx = localDesc.deserializeEx;
 768             }
 769             domains = localDesc.domains;
 770             assert isRecord(cl) ? localDesc.cons == null : true;
 771             cons = localDesc.cons;
 772         }
 773 
 774         fieldRefl = getReflector(fields, localDesc);
 775         // reassign to matched fields so as to reflect local unshared settings
 776         fields = fieldRefl.getFields();
 777 
 778         initialized = true;
 779     }
 780 
</pre>
<hr />
<pre>
2511          * Returns true if the given object is this identical
2512          * WeakClassKey instance, or, if this object&#39;s referent has not
2513          * been cleared, if the given object is another WeakClassKey
2514          * instance with the identical non-null referent as this one.
2515          */
2516         public boolean equals(Object obj) {
2517             if (obj == this) {
2518                 return true;
2519             }
2520 
2521             if (obj instanceof WeakClassKey) {
2522                 Object referent = get();
2523                 return (referent != null) &amp;&amp;
2524                        (referent == ((WeakClassKey) obj).get());
2525             } else {
2526                 return false;
2527             }
2528         }
2529     }
2530 
















































































































2531     /** Record specific support for retrieving and binding stream field values. */
2532     static final class RecordSupport {
<span class="line-modified">2533 </span>
<span class="line-modified">2534         /** Binds the given stream field values to the given method handle. */</span>




2535         @SuppressWarnings(&quot;preview&quot;)
<span class="line-modified">2536         static MethodHandle bindCtrValues(MethodHandle ctrMH,</span>
<span class="line-modified">2537                                           ObjectStreamClass desc,</span>
<span class="line-modified">2538                                           ObjectInputStream.FieldValues fieldValues) {</span>





2539             RecordComponent[] recordComponents;
2540             try {
2541                 Class&lt;?&gt; cls = desc.forClass();
2542                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;
2543                 recordComponents = AccessController.doPrivileged(pa);
2544             } catch (PrivilegedActionException e) {
2545                 throw new InternalError(e.getCause());
2546             }
2547 
<span class="line-modified">2548             Object[] args = new Object[recordComponents.length];</span>
<span class="line-modified">2549             for (int i = 0; i &lt; recordComponents.length; i++) {</span>











2550                 String name = recordComponents[i].getName();
<span class="line-modified">2551                 Class&lt;?&gt; type= recordComponents[i].getType();</span>
<span class="line-modified">2552                 Object o = streamFieldValue(name, type, desc, fieldValues);</span>
<span class="line-modified">2553                 args[i] = o;</span>





2554             }



2555 
<span class="line-modified">2556             return MethodHandles.insertArguments(ctrMH, 0, args);</span>


2557         }
2558 
2559         /** Returns the number of primitive fields for the given descriptor. */
2560         private static int numberPrimValues(ObjectStreamClass desc) {
2561             ObjectStreamField[] fields = desc.getFields();
2562             int primValueCount = 0;
2563             for (int i = 0; i &lt; fields.length; i++) {
2564                 if (fields[i].isPrimitive())
2565                     primValueCount++;
2566                 else
2567                     break;  // can be no more
2568             }
2569             return primValueCount;
2570         }
2571 
<span class="line-removed">2572         /** Returns the default value for the given type. */</span>
<span class="line-removed">2573         private static Object defaultValueFor(Class&lt;?&gt; pType) {</span>
<span class="line-removed">2574             if (pType == Integer.TYPE)</span>
<span class="line-removed">2575                 return 0;</span>
<span class="line-removed">2576             else if (pType == Byte.TYPE)</span>
<span class="line-removed">2577                 return (byte)0;</span>
<span class="line-removed">2578             else if (pType == Long.TYPE)</span>
<span class="line-removed">2579                 return 0L;</span>
<span class="line-removed">2580             else if (pType == Float.TYPE)</span>
<span class="line-removed">2581                 return 0.0f;</span>
<span class="line-removed">2582             else if (pType == Double.TYPE)</span>
<span class="line-removed">2583                 return 0.0d;</span>
<span class="line-removed">2584             else if (pType == Short.TYPE)</span>
<span class="line-removed">2585                 return (short)0;</span>
<span class="line-removed">2586             else if (pType == Character.TYPE)</span>
<span class="line-removed">2587                 return &#39;\u0000&#39;;</span>
<span class="line-removed">2588             else if (pType == Boolean.TYPE)</span>
<span class="line-removed">2589                 return false;</span>
<span class="line-removed">2590             else</span>
<span class="line-removed">2591                 return null;</span>
<span class="line-removed">2592         }</span>
<span class="line-removed">2593 </span>
2594         /**
<span class="line-modified">2595          * Returns the stream field value for the given name. The default value</span>
<span class="line-modified">2596          * for the given type is returned if the field value is absent.</span>

2597          */
<span class="line-modified">2598         private static Object streamFieldValue(String pName,</span>
<span class="line-modified">2599                                                Class&lt;?&gt; pType,</span>
<span class="line-modified">2600                                                ObjectStreamClass desc,</span>
<span class="line-modified">2601                                                ObjectInputStream.FieldValues fieldValues) {</span>
<span class="line-removed">2602             ObjectStreamField[] fields = desc.getFields();</span>
2603 
2604             for (int i = 0; i &lt; fields.length; i++) {
2605                 ObjectStreamField f = fields[i];
2606                 String fName = f.getName();
2607                 if (!fName.equals(pName))
2608                     continue;
2609 
2610                 Class&lt;?&gt; fType = f.getField().getType();
2611                 if (!pType.isAssignableFrom(fType))
2612                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);
2613 
2614                 if (f.isPrimitive()) {
<span class="line-modified">2615                     if (pType == Integer.TYPE)</span>
<span class="line-modified">2616                         return Bits.getInt(fieldValues.primValues, f.getOffset());</span>
<span class="line-modified">2617                     else if (fType == Byte.TYPE)</span>
<span class="line-removed">2618                         return fieldValues.primValues[f.getOffset()];</span>
<span class="line-removed">2619                     else if (fType == Long.TYPE)</span>
<span class="line-removed">2620                         return Bits.getLong(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2621                     else if (fType == Float.TYPE)</span>
<span class="line-removed">2622                         return Bits.getFloat(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2623                     else if (fType == Double.TYPE)</span>
<span class="line-removed">2624                         return Bits.getDouble(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2625                     else if (fType == Short.TYPE)</span>
<span class="line-removed">2626                         return Bits.getShort(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2627                     else if (fType == Character.TYPE)</span>
<span class="line-removed">2628                         return Bits.getChar(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2629                     else if (fType == Boolean.TYPE)</span>
<span class="line-removed">2630                         return Bits.getBoolean(fieldValues.primValues, f.getOffset());</span>
<span class="line-removed">2631                     else</span>
2632                         throw new InternalError(&quot;Unexpected type: &quot; + fType);













2633                 } else { // reference
<span class="line-modified">2634                     return fieldValues.objValues[i - numberPrimValues(desc)];</span>













2635                 }
2636             }
2637 
<span class="line-modified">2638             return defaultValueFor(pType);</span>




















2639         }
2640     }
2641 }
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.lang.invoke.MethodHandle;
  29 import java.lang.invoke.MethodHandles;
<span class="line-added">  30 import java.lang.invoke.MethodType;</span>
  31 import java.lang.ref.Reference;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.ref.SoftReference;
  34 import java.lang.ref.WeakReference;
  35 import java.lang.reflect.Constructor;
  36 import java.lang.reflect.Field;
  37 import java.lang.reflect.InvocationTargetException;
  38 import java.lang.reflect.RecordComponent;
  39 import java.lang.reflect.UndeclaredThrowableException;
  40 import java.lang.reflect.Member;
  41 import java.lang.reflect.Method;
  42 import java.lang.reflect.Modifier;
  43 import java.lang.reflect.Proxy;
  44 import java.security.AccessControlContext;
  45 import java.security.AccessController;
  46 import java.security.MessageDigest;
  47 import java.security.NoSuchAlgorithmException;
  48 import java.security.PermissionCollection;
  49 import java.security.Permissions;
  50 import java.security.PrivilegedAction;
  51 import java.security.PrivilegedActionException;
  52 import java.security.PrivilegedExceptionAction;
  53 import java.security.ProtectionDomain;
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashSet;
<span class="line-added">  59 import java.util.Map;</span>
  60 import java.util.Set;
  61 import java.util.concurrent.ConcurrentHashMap;
  62 import java.util.concurrent.ConcurrentMap;
  63 import jdk.internal.misc.Unsafe;
  64 import jdk.internal.reflect.CallerSensitive;
  65 import jdk.internal.reflect.Reflection;
  66 import jdk.internal.reflect.ReflectionFactory;
  67 import jdk.internal.access.SharedSecrets;
  68 import jdk.internal.access.JavaSecurityAccess;
  69 import sun.reflect.misc.ReflectUtil;
  70 import static java.io.ObjectStreamField.*;
  71 
  72 /**
  73  * Serialization&#39;s descriptor for classes.  It contains the name and
  74  * serialVersionUID of the class.  The ObjectStreamClass for a specific class
  75  * loaded in this Java VM can be found/created using the lookup method.
  76  *
  77  * &lt;p&gt;The algorithm to compute the SerialVersionUID is described in
  78  * &lt;a href=&quot;{@docRoot}/../specs/serialization/class.html#stream-unique-identifiers&quot;&gt;
  79  *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.
</pre>
<hr />
<pre>
 176     /** exception (if any) to throw if non-enum deserialization attempted */
 177     private ExceptionInfo deserializeEx;
 178     /** exception (if any) to throw if non-enum serialization attempted */
 179     private ExceptionInfo serializeEx;
 180     /** exception (if any) to throw if default serialization attempted */
 181     private ExceptionInfo defaultSerializeEx;
 182 
 183     /** serializable fields */
 184     private ObjectStreamField[] fields;
 185     /** aggregate marshalled size of primitive fields */
 186     private int primDataSize;
 187     /** number of non-primitive fields */
 188     private int numObjFields;
 189     /** reflector for setting/getting serializable field values */
 190     private FieldReflector fieldRefl;
 191     /** data layout of serialized objects described by this class desc */
 192     private volatile ClassDataSlot[] dataLayout;
 193 
 194     /** serialization-appropriate constructor, or null if none */
 195     private Constructor&lt;?&gt; cons;
<span class="line-modified"> 196     /** record canonical constructor (shared among OSCs for same class), or null */</span>
 197     private MethodHandle canonicalCtr;
<span class="line-added"> 198     /** cache of record deserialization constructors per unique set of stream fields</span>
<span class="line-added"> 199      * (shared among OSCs for same class), or null */</span>
<span class="line-added"> 200     private DeserializationConstructorsCache deserializationCtrs;</span>
<span class="line-added"> 201     /** session-cache of record deserialization constructor</span>
<span class="line-added"> 202      * (in de-serialized OSC only), or null */</span>
<span class="line-added"> 203     private MethodHandle deserializationCtr;</span>
 204     /** protection domains that need to be checked when calling the constructor */
 205     private ProtectionDomain[] domains;
 206 
 207     /** class-defined writeObject method, or null if none */
 208     private Method writeObjectMethod;
 209     /** class-defined readObject method, or null if none */
 210     private Method readObjectMethod;
 211     /** class-defined readObjectNoData method, or null if none */
 212     private Method readObjectNoDataMethod;
 213     /** class-defined writeReplace method, or null if none */
 214     private Method writeReplaceMethod;
 215     /** class-defined readResolve method, or null if none */
 216     private Method readResolveMethod;
 217 
 218     /** local class descriptor for represented class (may point to self) */
 219     private ObjectStreamClass localDesc;
 220     /** superclass descriptor appearing in stream */
 221     private ObjectStreamClass superDesc;
 222 
 223     /** true if, and only if, the object has been correctly initialized */
</pre>
<hr />
<pre>
 516                         fields = NO_FIELDS;
 517                         return null;
 518                     }
 519                     if (cl.isArray()) {
 520                         fields = NO_FIELDS;
 521                         return null;
 522                     }
 523 
 524                     suid = getDeclaredSUID(cl);
 525                     try {
 526                         fields = getSerialFields(cl);
 527                         computeFieldOffsets();
 528                     } catch (InvalidClassException e) {
 529                         serializeEx = deserializeEx =
 530                             new ExceptionInfo(e.classname, e.getMessage());
 531                         fields = NO_FIELDS;
 532                     }
 533 
 534                     if (isRecord) {
 535                         canonicalCtr = canonicalRecordCtr(cl);
<span class="line-added"> 536                         deserializationCtrs = new DeserializationConstructorsCache();</span>
 537                     } else if (externalizable) {
 538                         cons = getExternalizableConstructor(cl);
 539                     } else {
 540                         cons = getSerializableConstructor(cl);
 541                         writeObjectMethod = getPrivateMethod(cl, &quot;writeObject&quot;,
 542                             new Class&lt;?&gt;[] { ObjectOutputStream.class },
 543                             Void.TYPE);
 544                         readObjectMethod = getPrivateMethod(cl, &quot;readObject&quot;,
 545                             new Class&lt;?&gt;[] { ObjectInputStream.class },
 546                             Void.TYPE);
 547                         readObjectNoDataMethod = getPrivateMethod(
 548                             cl, &quot;readObjectNoData&quot;, null, Void.TYPE);
 549                         hasWriteObjectData = (writeObjectMethod != null);
 550                     }
 551                     domains = getProtectionDomains(cons, cl);
 552                     writeReplaceMethod = getInheritableMethod(
 553                         cl, &quot;writeReplace&quot;, null, Object.class);
 554                     readResolveMethod = getInheritableMethod(
 555                         cl, &quot;readResolve&quot;, null, Object.class);
 556                     return null;
</pre>
<hr />
<pre>
 730                                 &quot;name \&quot;&quot; + model.name + &quot;\&quot;&quot;);
 731             }
 732 
 733             if (!model.isEnum) {
 734                 if ((model.serializable == osc.serializable) &amp;&amp;
 735                         (model.externalizable != osc.externalizable)) {
 736                     throw new InvalidClassException(osc.name,
 737                             &quot;Serializable incompatible with Externalizable&quot;);
 738                 }
 739 
 740                 if ((model.serializable != osc.serializable) ||
 741                         (model.externalizable != osc.externalizable) ||
 742                         !(model.serializable || model.externalizable)) {
 743                     deserializeEx = new ExceptionInfo(
 744                             osc.name, &quot;class invalid for deserialization&quot;);
 745                 }
 746             }
 747         }
 748 
 749         this.cl = cl;




 750         this.resolveEx = resolveEx;
 751         this.superDesc = superDesc;
 752         name = model.name;
 753         this.suid = suid;
 754         isProxy = false;
 755         isEnum = model.isEnum;
 756         serializable = model.serializable;
 757         externalizable = model.externalizable;
 758         hasBlockExternalData = model.hasBlockExternalData;
 759         hasWriteObjectData = model.hasWriteObjectData;
 760         fields = model.fields;
 761         primDataSize = model.primDataSize;
 762         numObjFields = model.numObjFields;
 763 
 764         if (osc != null) {
 765             localDesc = osc;
<span class="line-added"> 766             isRecord = localDesc.isRecord;</span>
<span class="line-added"> 767             // canonical record constructor is shared</span>
<span class="line-added"> 768             canonicalCtr = localDesc.canonicalCtr;</span>
<span class="line-added"> 769             // cache of deserialization constructors is shared</span>
<span class="line-added"> 770             deserializationCtrs = localDesc.deserializationCtrs;</span>
 771             writeObjectMethod = localDesc.writeObjectMethod;
 772             readObjectMethod = localDesc.readObjectMethod;
 773             readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
 774             writeReplaceMethod = localDesc.writeReplaceMethod;
 775             readResolveMethod = localDesc.readResolveMethod;
 776             if (deserializeEx == null) {
 777                 deserializeEx = localDesc.deserializeEx;
 778             }
 779             domains = localDesc.domains;
 780             assert isRecord(cl) ? localDesc.cons == null : true;
 781             cons = localDesc.cons;
 782         }
 783 
 784         fieldRefl = getReflector(fields, localDesc);
 785         // reassign to matched fields so as to reflect local unshared settings
 786         fields = fieldRefl.getFields();
 787 
 788         initialized = true;
 789     }
 790 
</pre>
<hr />
<pre>
2521          * Returns true if the given object is this identical
2522          * WeakClassKey instance, or, if this object&#39;s referent has not
2523          * been cleared, if the given object is another WeakClassKey
2524          * instance with the identical non-null referent as this one.
2525          */
2526         public boolean equals(Object obj) {
2527             if (obj == this) {
2528                 return true;
2529             }
2530 
2531             if (obj instanceof WeakClassKey) {
2532                 Object referent = get();
2533                 return (referent != null) &amp;&amp;
2534                        (referent == ((WeakClassKey) obj).get());
2535             } else {
2536                 return false;
2537             }
2538         }
2539     }
2540 
<span class="line-added">2541     // a LRA cache of record deserialization constructors</span>
<span class="line-added">2542     @SuppressWarnings(&quot;serial&quot;)</span>
<span class="line-added">2543     private static final class DeserializationConstructorsCache</span>
<span class="line-added">2544         extends ConcurrentHashMap&lt;DeserializationConstructorsCache.Key, MethodHandle&gt;  {</span>
<span class="line-added">2545 </span>
<span class="line-added">2546         // keep max. 10 cached entries - when the 11th element is inserted the oldest</span>
<span class="line-added">2547         // is removed and 10 remains - 11 is the biggest map size where internal</span>
<span class="line-added">2548         // table of 16 elements is sufficient (inserting 12th element would resize it to 32)</span>
<span class="line-added">2549         private static final int MAX_SIZE = 10;</span>
<span class="line-added">2550         private Key.Impl first, last; // first and last in FIFO queue</span>
<span class="line-added">2551 </span>
<span class="line-added">2552         DeserializationConstructorsCache() {</span>
<span class="line-added">2553             // start small - if there is more than one shape of ObjectStreamClass</span>
<span class="line-added">2554             // deserialized, there will typically be two (current version and previous version)</span>
<span class="line-added">2555             super(2);</span>
<span class="line-added">2556         }</span>
<span class="line-added">2557 </span>
<span class="line-added">2558         MethodHandle get(ObjectStreamField[] fields) {</span>
<span class="line-added">2559             return get(new Key.Lookup(fields));</span>
<span class="line-added">2560         }</span>
<span class="line-added">2561 </span>
<span class="line-added">2562         synchronized MethodHandle putIfAbsentAndGet(ObjectStreamField[] fields, MethodHandle mh) {</span>
<span class="line-added">2563             Key.Impl key = new Key.Impl(fields);</span>
<span class="line-added">2564             var oldMh = putIfAbsent(key, mh);</span>
<span class="line-added">2565             if (oldMh != null) return oldMh;</span>
<span class="line-added">2566             // else we did insert new entry -&gt; link the new key as last</span>
<span class="line-added">2567             if (last == null) {</span>
<span class="line-added">2568                 last = first = key;</span>
<span class="line-added">2569             } else {</span>
<span class="line-added">2570                 last = (last.next = key);</span>
<span class="line-added">2571             }</span>
<span class="line-added">2572             // may need to remove first</span>
<span class="line-added">2573             if (size() &gt; MAX_SIZE) {</span>
<span class="line-added">2574                 assert first != null;</span>
<span class="line-added">2575                 remove(first);</span>
<span class="line-added">2576                 first = first.next;</span>
<span class="line-added">2577                 if (first == null) {</span>
<span class="line-added">2578                     last = null;</span>
<span class="line-added">2579                 }</span>
<span class="line-added">2580             }</span>
<span class="line-added">2581             return mh;</span>
<span class="line-added">2582         }</span>
<span class="line-added">2583 </span>
<span class="line-added">2584         // a key composed of ObjectStreamField[] names and types</span>
<span class="line-added">2585         static abstract class Key {</span>
<span class="line-added">2586             abstract int length();</span>
<span class="line-added">2587             abstract String fieldName(int i);</span>
<span class="line-added">2588             abstract Class&lt;?&gt; fieldType(int i);</span>
<span class="line-added">2589 </span>
<span class="line-added">2590             @Override</span>
<span class="line-added">2591             public final int hashCode() {</span>
<span class="line-added">2592                 int n = length();</span>
<span class="line-added">2593                 int h = 0;</span>
<span class="line-added">2594                 for (int i = 0; i &lt; n; i++) h = h * 31 + fieldType(i).hashCode();</span>
<span class="line-added">2595                 for (int i = 0; i &lt; n; i++) h = h * 31 + fieldName(i).hashCode();</span>
<span class="line-added">2596                 return h;</span>
<span class="line-added">2597             }</span>
<span class="line-added">2598 </span>
<span class="line-added">2599             @Override</span>
<span class="line-added">2600             public final boolean equals(Object obj) {</span>
<span class="line-added">2601                 if (!(obj instanceof Key)) return false;</span>
<span class="line-added">2602                 Key other = (Key) obj;</span>
<span class="line-added">2603                 int n = length();</span>
<span class="line-added">2604                 if (n != other.length()) return false;</span>
<span class="line-added">2605                 for (int i = 0; i &lt; n; i++) if (fieldType(i) != other.fieldType(i)) return false;</span>
<span class="line-added">2606                 for (int i = 0; i &lt; n; i++) if (!fieldName(i).equals(other.fieldName(i))) return false;</span>
<span class="line-added">2607                 return true;</span>
<span class="line-added">2608             }</span>
<span class="line-added">2609 </span>
<span class="line-added">2610             // lookup key - just wraps ObjectStreamField[]</span>
<span class="line-added">2611             static final class Lookup extends Key {</span>
<span class="line-added">2612                 final ObjectStreamField[] fields;</span>
<span class="line-added">2613 </span>
<span class="line-added">2614                 Lookup(ObjectStreamField[] fields) { this.fields = fields; }</span>
<span class="line-added">2615 </span>
<span class="line-added">2616                 @Override</span>
<span class="line-added">2617                 int length() { return fields.length; }</span>
<span class="line-added">2618 </span>
<span class="line-added">2619                 @Override</span>
<span class="line-added">2620                 String fieldName(int i) { return fields[i].getName(); }</span>
<span class="line-added">2621 </span>
<span class="line-added">2622                 @Override</span>
<span class="line-added">2623                 Class&lt;?&gt; fieldType(int i) { return fields[i].getType(); }</span>
<span class="line-added">2624             }</span>
<span class="line-added">2625 </span>
<span class="line-added">2626             // real key - copies field names and types and forms FIFO queue in cache</span>
<span class="line-added">2627             static final class Impl extends Key {</span>
<span class="line-added">2628                 Impl next;</span>
<span class="line-added">2629                 final String[] fieldNames;</span>
<span class="line-added">2630                 final Class&lt;?&gt;[] fieldTypes;</span>
<span class="line-added">2631 </span>
<span class="line-added">2632                 Impl(ObjectStreamField[] fields) {</span>
<span class="line-added">2633                     this.fieldNames = new String[fields.length];</span>
<span class="line-added">2634                     this.fieldTypes = new Class&lt;?&gt;[fields.length];</span>
<span class="line-added">2635                     for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="line-added">2636                         fieldNames[i] = fields[i].getName();</span>
<span class="line-added">2637                         fieldTypes[i] = fields[i].getType();</span>
<span class="line-added">2638                     }</span>
<span class="line-added">2639                 }</span>
<span class="line-added">2640 </span>
<span class="line-added">2641                 @Override</span>
<span class="line-added">2642                 int length() { return fieldNames.length; }</span>
<span class="line-added">2643 </span>
<span class="line-added">2644                 @Override</span>
<span class="line-added">2645                 String fieldName(int i) { return fieldNames[i]; }</span>
<span class="line-added">2646 </span>
<span class="line-added">2647                 @Override</span>
<span class="line-added">2648                 Class&lt;?&gt; fieldType(int i) { return fieldTypes[i]; }</span>
<span class="line-added">2649             }</span>
<span class="line-added">2650         }</span>
<span class="line-added">2651     }</span>
<span class="line-added">2652 </span>
2653     /** Record specific support for retrieving and binding stream field values. */
2654     static final class RecordSupport {
<span class="line-modified">2655         /**</span>
<span class="line-modified">2656          * Returns canonical record constructor adapted to take two arguments:</span>
<span class="line-added">2657          * {@code (byte[] primValues, Object[] objValues)}</span>
<span class="line-added">2658          * and return</span>
<span class="line-added">2659          * {@code Object}</span>
<span class="line-added">2660          */</span>
2661         @SuppressWarnings(&quot;preview&quot;)
<span class="line-modified">2662         static MethodHandle deserializationCtr(ObjectStreamClass desc) {</span>
<span class="line-modified">2663             // check the cached value 1st</span>
<span class="line-modified">2664             MethodHandle mh = desc.deserializationCtr;</span>
<span class="line-added">2665             if (mh != null) return mh;</span>
<span class="line-added">2666             mh = desc.deserializationCtrs.get(desc.getFields(false));</span>
<span class="line-added">2667             if (mh != null) return desc.deserializationCtr = mh;</span>
<span class="line-added">2668 </span>
<span class="line-added">2669             // retrieve record components</span>
2670             RecordComponent[] recordComponents;
2671             try {
2672                 Class&lt;?&gt; cls = desc.forClass();
2673                 PrivilegedExceptionAction&lt;RecordComponent[]&gt; pa = cls::getRecordComponents;
2674                 recordComponents = AccessController.doPrivileged(pa);
2675             } catch (PrivilegedActionException e) {
2676                 throw new InternalError(e.getCause());
2677             }
2678 
<span class="line-modified">2679             // retrieve the canonical constructor</span>
<span class="line-modified">2680             // (T1, T2, ..., Tn):TR</span>
<span class="line-added">2681             mh = desc.getRecordConstructor();</span>
<span class="line-added">2682 </span>
<span class="line-added">2683             // change return type to Object</span>
<span class="line-added">2684             // (T1, T2, ..., Tn):TR -&gt; (T1, T2, ..., Tn):Object</span>
<span class="line-added">2685             mh = mh.asType(mh.type().changeReturnType(Object.class));</span>
<span class="line-added">2686 </span>
<span class="line-added">2687             // drop last 2 arguments representing primValues and objValues arrays</span>
<span class="line-added">2688             // (T1, T2, ..., Tn):Object -&gt; (T1, T2, ..., Tn, byte[], Object[]):Object</span>
<span class="line-added">2689             mh = MethodHandles.dropArguments(mh, mh.type().parameterCount(), byte[].class, Object[].class);</span>
<span class="line-added">2690 </span>
<span class="line-added">2691             for (int i = recordComponents.length-1; i &gt;= 0; i--) {</span>
2692                 String name = recordComponents[i].getName();
<span class="line-modified">2693                 Class&lt;?&gt; type = recordComponents[i].getType();</span>
<span class="line-modified">2694                 // obtain stream field extractor that extracts argument at</span>
<span class="line-modified">2695                 // position i (Ti+1) from primValues and objValues arrays</span>
<span class="line-added">2696                 // (byte[], Object[]):Ti+1</span>
<span class="line-added">2697                 MethodHandle combiner = streamFieldExtractor(name, type, desc);</span>
<span class="line-added">2698                 // fold byte[] privValues and Object[] objValues into argument at position i (Ti+1)</span>
<span class="line-added">2699                 // (..., Ti, Ti+1, byte[], Object[]):Object -&gt; (..., Ti, byte[], Object[]):Object</span>
<span class="line-added">2700                 mh = MethodHandles.foldArguments(mh, i, combiner);</span>
2701             }
<span class="line-added">2702             // what we are left with is a MethodHandle taking just the primValues</span>
<span class="line-added">2703             // and objValues arrays and returning the constructed record instance</span>
<span class="line-added">2704             // (byte[], Object[]):Object</span>
2705 
<span class="line-modified">2706             // store it into cache and return the 1st value stored</span>
<span class="line-added">2707             return desc.deserializationCtr =</span>
<span class="line-added">2708                 desc.deserializationCtrs.putIfAbsentAndGet(desc.getFields(false), mh);</span>
2709         }
2710 
2711         /** Returns the number of primitive fields for the given descriptor. */
2712         private static int numberPrimValues(ObjectStreamClass desc) {
2713             ObjectStreamField[] fields = desc.getFields();
2714             int primValueCount = 0;
2715             for (int i = 0; i &lt; fields.length; i++) {
2716                 if (fields[i].isPrimitive())
2717                     primValueCount++;
2718                 else
2719                     break;  // can be no more
2720             }
2721             return primValueCount;
2722         }
2723 






















2724         /**
<span class="line-modified">2725          * Returns extractor MethodHandle taking the primValues and objValues arrays</span>
<span class="line-modified">2726          * and extracting the argument of canonical constructor with given name and type</span>
<span class="line-added">2727          * or producing  default value for the given type if the field is absent.</span>
2728          */
<span class="line-modified">2729         private static MethodHandle streamFieldExtractor(String pName,</span>
<span class="line-modified">2730                                                          Class&lt;?&gt; pType,</span>
<span class="line-modified">2731                                                          ObjectStreamClass desc) {</span>
<span class="line-modified">2732             ObjectStreamField[] fields = desc.getFields(false);</span>

2733 
2734             for (int i = 0; i &lt; fields.length; i++) {
2735                 ObjectStreamField f = fields[i];
2736                 String fName = f.getName();
2737                 if (!fName.equals(pName))
2738                     continue;
2739 
2740                 Class&lt;?&gt; fType = f.getField().getType();
2741                 if (!pType.isAssignableFrom(fType))
2742                     throw new InternalError(fName + &quot; unassignable, pType:&quot; + pType + &quot;, fType:&quot; + fType);
2743 
2744                 if (f.isPrimitive()) {
<span class="line-modified">2745                     // (byte[], int):fType</span>
<span class="line-modified">2746                     MethodHandle mh = PRIM_VALUE_EXTRACTORS.get(fType);</span>
<span class="line-modified">2747                     if (mh == null) {</span>














2748                         throw new InternalError(&quot;Unexpected type: &quot; + fType);
<span class="line-added">2749                     }</span>
<span class="line-added">2750                     // bind offset</span>
<span class="line-added">2751                     // (byte[], int):fType -&gt; (byte[]):fType</span>
<span class="line-added">2752                     mh = MethodHandles.insertArguments(mh, 1, f.getOffset());</span>
<span class="line-added">2753                     // drop objValues argument</span>
<span class="line-added">2754                     // (byte[]):fType -&gt; (byte[], Object[]):fType</span>
<span class="line-added">2755                     mh = MethodHandles.dropArguments(mh, 1, Object[].class);</span>
<span class="line-added">2756                     // adapt return type to pType</span>
<span class="line-added">2757                     // (byte[], Object[]):fType -&gt; (byte[], Object[]):pType</span>
<span class="line-added">2758                     if (pType != fType) {</span>
<span class="line-added">2759                         mh = mh.asType(mh.type().changeReturnType(pType));</span>
<span class="line-added">2760                     }</span>
<span class="line-added">2761                     return mh;</span>
2762                 } else { // reference
<span class="line-modified">2763                     // (Object[], int):Object</span>
<span class="line-added">2764                     MethodHandle mh = MethodHandles.arrayElementGetter(Object[].class);</span>
<span class="line-added">2765                     // bind index</span>
<span class="line-added">2766                     // (Object[], int):Object -&gt; (Object[]):Object</span>
<span class="line-added">2767                     mh = MethodHandles.insertArguments(mh, 1, i - numberPrimValues(desc));</span>
<span class="line-added">2768                     // drop primValues argument</span>
<span class="line-added">2769                     // (Object[]):Object -&gt; (byte[], Object[]):Object</span>
<span class="line-added">2770                     mh = MethodHandles.dropArguments(mh, 0, byte[].class);</span>
<span class="line-added">2771                     // adapt return type to pType</span>
<span class="line-added">2772                     // (byte[], Object[]):Object -&gt; (byte[], Object[]):pType</span>
<span class="line-added">2773                     if (pType != Object.class) {</span>
<span class="line-added">2774                         mh = mh.asType(mh.type().changeReturnType(pType));</span>
<span class="line-added">2775                     }</span>
<span class="line-added">2776                     return mh;</span>
2777                 }
2778             }
2779 
<span class="line-modified">2780             // return default value extractor if no field matches pName</span>
<span class="line-added">2781             return MethodHandles.empty(MethodType.methodType(pType, byte[].class, Object[].class));</span>
<span class="line-added">2782         }</span>
<span class="line-added">2783 </span>
<span class="line-added">2784         private static final Map&lt;Class&lt;?&gt;, MethodHandle&gt; PRIM_VALUE_EXTRACTORS;</span>
<span class="line-added">2785         static {</span>
<span class="line-added">2786             var lkp = MethodHandles.lookup();</span>
<span class="line-added">2787             try {</span>
<span class="line-added">2788                 PRIM_VALUE_EXTRACTORS = Map.of(</span>
<span class="line-added">2789                     byte.class, MethodHandles.arrayElementGetter(byte[].class),</span>
<span class="line-added">2790                     short.class, lkp.findStatic(Bits.class, &quot;getShort&quot;, MethodType.methodType(short.class, byte[].class, int.class)),</span>
<span class="line-added">2791                     int.class, lkp.findStatic(Bits.class, &quot;getInt&quot;, MethodType.methodType(int.class, byte[].class, int.class)),</span>
<span class="line-added">2792                     long.class, lkp.findStatic(Bits.class, &quot;getLong&quot;, MethodType.methodType(long.class, byte[].class, int.class)),</span>
<span class="line-added">2793                     float.class, lkp.findStatic(Bits.class, &quot;getFloat&quot;, MethodType.methodType(float.class, byte[].class, int.class)),</span>
<span class="line-added">2794                     double.class, lkp.findStatic(Bits.class, &quot;getDouble&quot;, MethodType.methodType(double.class, byte[].class, int.class)),</span>
<span class="line-added">2795                     char.class, lkp.findStatic(Bits.class, &quot;getChar&quot;, MethodType.methodType(char.class, byte[].class, int.class)),</span>
<span class="line-added">2796                     boolean.class, lkp.findStatic(Bits.class, &quot;getBoolean&quot;, MethodType.methodType(boolean.class, byte[].class, int.class))</span>
<span class="line-added">2797                 );</span>
<span class="line-added">2798             } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="line-added">2799                 throw new InternalError(&quot;Can&#39;t lookup Bits.getXXX&quot;, e);</span>
<span class="line-added">2800             }</span>
2801         }
2802     }
2803 }
</pre>
</td>
</tr>
</table>
<center><a href="ObjectInputStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PipedWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
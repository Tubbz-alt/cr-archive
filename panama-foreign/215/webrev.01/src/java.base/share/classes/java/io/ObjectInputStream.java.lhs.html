<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/io/ObjectInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.io.ObjectStreamClass.WeakClassKey;
  29 import java.io.ObjectStreamClass.RecordSupport;
  30 import java.lang.System.Logger;
  31 import java.lang.invoke.MethodHandle;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.reflect.Array;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Proxy;
  36 import java.security.AccessControlContext;
  37 import java.security.AccessController;
  38 import java.security.PrivilegedAction;
  39 import java.security.PrivilegedActionException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.util.Arrays;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 
  47 import static java.io.ObjectStreamClass.processQueue;
  48 
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.Unsafe;
  51 import sun.reflect.misc.ReflectUtil;
  52 
  53 /**
  54  * An ObjectInputStream deserializes primitive data and objects previously
  55  * written using an ObjectOutputStream.
  56  *
  57  * &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
  58  * and should be avoided. Untrusted data should be carefully validated according to the
  59  * &quot;Serialization and Deserialization&quot; section of the
  60  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
  61  * {@extLink serialization_filter_guide Serialization Filtering} describes best
  62  * practices for defensive use of serial filters.
  63  * &lt;/strong&gt;&lt;/p&gt;
  64  *
  65  * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
  66  * persistent storage for graphs of objects when used with a FileOutputStream
  67  * and FileInputStream respectively.  ObjectInputStream is used to recover
  68  * those objects previously serialized. Other uses include passing objects
  69  * between hosts using a socket stream or for marshaling and unmarshaling
  70  * arguments and parameters in a remote communication system.
  71  *
  72  * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
  73  * created from the stream match the classes present in the Java Virtual
  74  * Machine.  Classes are loaded as required using the standard mechanisms.
  75  *
  76  * &lt;p&gt;Only objects that support the java.io.Serializable or
  77  * java.io.Externalizable interface can be read from streams.
  78  *
  79  * &lt;p&gt;The method {@code readObject} is used to read an object from the
  80  * stream.  Java&#39;s safe casting should be used to get the desired type.  In
  81  * Java, strings and arrays are objects and are treated as objects during
  82  * serialization. When read they need to be cast to the expected type.
  83  *
  84  * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
  85  * method on DataInput.
  86  *
  87  * &lt;p&gt;The default deserialization mechanism for objects restores the contents
  88  * of each field to the value and type it had when it was written.  Fields
  89  * declared as transient or static are ignored by the deserialization process.
  90  * References to other objects cause those objects to be read from the stream
  91  * as necessary.  Graphs of objects are restored correctly using a reference
  92  * sharing mechanism.  New objects are always allocated when deserializing,
  93  * which prevents existing objects from being overwritten.
  94  *
  95  * &lt;p&gt;Reading an object is analogous to running the constructors of a new
  96  * object.  Memory is allocated for the object and initialized to zero (NULL).
  97  * No-arg constructors are invoked for the non-serializable classes and then
  98  * the fields of the serializable classes are restored from the stream starting
  99  * with the serializable class closest to java.lang.object and finishing with
 100  * the object&#39;s most specific class.
 101  *
 102  * &lt;p&gt;For example to read from a stream as written by the example in
 103  * ObjectOutputStream:
 104  * &lt;br&gt;
 105  * &lt;pre&gt;
 106  *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
 107  *      ObjectInputStream ois = new ObjectInputStream(fis);
 108  *
 109  *      int i = ois.readInt();
 110  *      String today = (String) ois.readObject();
 111  *      Date date = (Date) ois.readObject();
 112  *
 113  *      ois.close();
 114  * &lt;/pre&gt;
 115  *
 116  * &lt;p&gt;Classes control how they are serialized by implementing either the
 117  * java.io.Serializable or java.io.Externalizable interfaces.
 118  *
 119  * &lt;p&gt;Implementing the Serializable interface allows object serialization to
 120  * save and restore the entire state of the object and it allows classes to
 121  * evolve between the time the stream is written and the time it is read.  It
 122  * automatically traverses references between objects, saving and restoring
 123  * entire graphs.
 124  *
 125  * &lt;p&gt;Serializable classes that require special handling during the
 126  * serialization and deserialization process should implement the following
 127  * methods:
 128  *
 129  * &lt;pre&gt;
 130  * private void writeObject(java.io.ObjectOutputStream stream)
 131  *     throws IOException;
 132  * private void readObject(java.io.ObjectInputStream stream)
 133  *     throws IOException, ClassNotFoundException;
 134  * private void readObjectNoData()
 135  *     throws ObjectStreamException;
 136  * &lt;/pre&gt;
 137  *
 138  * &lt;p&gt;The readObject method is responsible for reading and restoring the state
 139  * of the object for its particular class using data written to the stream by
 140  * the corresponding writeObject method.  The method does not need to concern
 141  * itself with the state belonging to its superclasses or subclasses.  State is
 142  * restored by reading data from the ObjectInputStream for the individual
 143  * fields and making assignments to the appropriate fields of the object.
 144  * Reading primitive data types is supported by DataInput.
 145  *
 146  * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 147  * custom data written by the corresponding writeObject method will cause an
 148  * OptionalDataException to be thrown with an eof field value of true.
 149  * Non-object reads which exceed the end of the allotted data will reflect the
 150  * end of data in the same way that they would indicate the end of the stream:
 151  * bytewise reads will return -1 as the byte read or number of bytes read, and
 152  * primitive reads will throw EOFExceptions.  If there is no corresponding
 153  * writeObject method, then the end of default serialized data marks the end of
 154  * the allotted data.
 155  *
 156  * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 157  * behave in the same manner--if the stream is already positioned at the end of
 158  * data written by the corresponding writeExternal method, object reads will
 159  * throw OptionalDataExceptions with eof set to true, bytewise reads will
 160  * return -1, and primitive reads will throw EOFExceptions.  Note that this
 161  * behavior does not hold for streams written with the old
 162  * {@code ObjectStreamConstants.PROTOCOL_VERSION_1} protocol, in which the
 163  * end of data written by writeExternal methods is not demarcated, and hence
 164  * cannot be detected.
 165  *
 166  * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 167  * the object for its particular class in the event that the serialization
 168  * stream does not list the given class as a superclass of the object being
 169  * deserialized.  This may occur in cases where the receiving party uses a
 170  * different version of the deserialized instance&#39;s class than the sending
 171  * party, and the receiver&#39;s version extends classes that are not extended by
 172  * the sender&#39;s version.  This may also occur if the serialization stream has
 173  * been tampered; hence, readObjectNoData is useful for initializing
 174  * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 175  * stream.
 176  *
 177  * &lt;p&gt;Serialization does not read or assign values to the fields of any object
 178  * that does not implement the java.io.Serializable interface.  Subclasses of
 179  * Objects that are not serializable can be serializable. In this case the
 180  * non-serializable class must have a no-arg constructor to allow its fields to
 181  * be initialized.  In this case it is the responsibility of the subclass to
 182  * save and restore the state of the non-serializable class. It is frequently
 183  * the case that the fields of that class are accessible (public, package, or
 184  * protected) or that there are get and set methods that can be used to restore
 185  * the state.
 186  *
 187  * &lt;p&gt;The contents of the stream can be filtered during deserialization.
 188  * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}
 189  * on an ObjectInputStream, the {@link ObjectInputFilter} can check that
 190  * the classes, array lengths, number of references in the stream, depth, and
 191  * number of bytes consumed from the input stream are allowed and
 192  * if not, can terminate deserialization.
 193  * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}
 194  * can be configured that is applied to each {@code ObjectInputStream} unless replaced
 195  * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
 196  *
 197  * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 198  * the ObjectInputStream and abort the reading process.
 199  *
 200  * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 201  * complete control over the contents and format of the object&#39;s serialized
 202  * form.  The methods of the Externalizable interface, writeExternal and
 203  * readExternal, are called to save and restore the objects state.  When
 204  * implemented by a class they can write and read their own state using all of
 205  * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 206  * the objects to handle any versioning that occurs.
 207  *
 208  * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 209  * externalizable objects.  The serialized form of an enum constant consists
 210  * solely of its name; field values of the constant are not transmitted.  To
 211  * deserialize an enum constant, ObjectInputStream reads the constant name from
 212  * the stream; the deserialized constant is then obtained by calling the static
 213  * method {@code Enum.valueOf(Class, String)} with the enum constant&#39;s
 214  * base type and the received constant name as arguments.  Like other
 215  * serializable or externalizable objects, enum constants can function as the
 216  * targets of back references appearing subsequently in the serialization
 217  * stream.  The process by which enum constants are deserialized cannot be
 218  * customized: any class-specific readObject, readObjectNoData, and readResolve
 219  * methods defined by enum types are ignored during deserialization.
 220  * Similarly, any serialPersistentFields or serialVersionUID field declarations
 221  * are also ignored--all enum types have a fixed serialVersionUID of 0L.
 222  *
 223  * @implSpec
 224  * &lt;a id=&quot;record-serialization&quot;&gt;&lt;/a&gt;
 225  * Records are serialized differently than ordinary serializable or externalizable
 226  * objects. The serialized form of a record object is a sequence of values derived
 227  * from the record components. The stream format of a record object is the same as
 228  * that of an ordinary object in the stream. During deserialization, if the local
 229  * class equivalent of the specified stream class descriptor is a record class,
 230  * then first the stream fields are read and reconstructed to serve as the record&#39;s
 231  * component values; and second, a record object is created by invoking the
 232  * record&#39;s &lt;i&gt;canonical&lt;/i&gt; constructor with the component values as arguments (or the
 233  * default value for component&#39;s type if a component value is absent from the
 234  * stream).
 235  * Like other serializable or externalizable objects, record objects can function
 236  * as the target of back references appearing subsequently in the serialization
 237  * stream. However, a cycle in the graph where the record object is referred to,
 238  * either directly or transitively, by one of its components, is not preserved.
 239  * The record components are deserialized prior to the invocation of the record
 240  * constructor, hence this limitation (see
 241  * &lt;a href=&quot;{@docRoot}/../specs/serialization/serial-arch.html#cyclic-references&quot;&gt;
 242  * [Section 1.14, &quot;Circular References&quot;&lt;/a&gt; for additional information).
 243  * The process by which record objects are serialized or externalized cannot be
 244  * customized; any class-specific writeObject, readObject, readObjectNoData,
 245  * writeExternal, and readExternal methods defined by record classes are
 246  * ignored during serialization and deserialization. However, a substitute object
 247  * to be serialized or a designate replacement may be specified, by the
 248  * writeReplace and readResolve methods, respectively.  Any
 249  * serialPersistentFields field declaration is ignored. Documenting serializable
 250  * fields and data for record classes is unnecessary, since there is no variation
 251  * in the serial form, other than whether a substitute or replacement object is
 252  * used. The serialVersionUID of a record class is 0L unless explicitly
 253  * declared. The requirement for matching serialVersionUID values is waived for
 254  * record classes.
 255  *
 256  * @author      Mike Warres
 257  * @author      Roger Riggs
 258  * @see java.io.DataInput
 259  * @see java.io.ObjectOutputStream
 260  * @see java.io.Serializable
 261  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/input.html&quot;&gt;
 262  *     Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
 263  * @since   1.1
 264  */
 265 public class ObjectInputStream
 266     extends InputStream implements ObjectInput, ObjectStreamConstants
 267 {
 268     /** handle value representing null */
 269     private static final int NULL_HANDLE = -1;
 270 
 271     /** marker for unshared objects in internal handle table */
 272     private static final Object unsharedMarker = new Object();
 273 
 274     /**
 275      * immutable table mapping primitive type names to corresponding
 276      * class objects
 277      */
 278     private static final Map&lt;String, Class&lt;?&gt;&gt; primClasses =
 279         Map.of(&quot;boolean&quot;, boolean.class,
 280                &quot;byte&quot;, byte.class,
 281                &quot;char&quot;, char.class,
 282                &quot;short&quot;, short.class,
 283                &quot;int&quot;, int.class,
 284                &quot;long&quot;, long.class,
 285                &quot;float&quot;, float.class,
 286                &quot;double&quot;, double.class,
 287                &quot;void&quot;, void.class);
 288 
 289     private static class Caches {
 290         /** cache of subclass security audit results */
 291         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
 292             new ConcurrentHashMap&lt;&gt;();
 293 
 294         /** queue for WeakReferences to audited subclasses */
 295         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
 296             new ReferenceQueue&lt;&gt;();
 297     }
 298 
 299     /*
 300      * Separate class to defer initialization of logging until needed.
 301      */
 302     private static class Logging {
 303         /*
 304          * Logger for ObjectInputFilter results.
 305          * Setup the filter logger if it is set to DEBUG or TRACE.
 306          * (Assuming it will not change).
 307          */
 308         static final System.Logger filterLogger;
 309 
 310         static {
 311             Logger filterLog = System.getLogger(&quot;java.io.serialization&quot;);
 312             filterLogger = (filterLog.isLoggable(Logger.Level.DEBUG)
 313                     || filterLog.isLoggable(Logger.Level.TRACE)) ? filterLog : null;
 314         }
 315     }
 316 
 317     /** filter stream for handling block data conversion */
 318     private final BlockDataInputStream bin;
 319     /** validation callback list */
 320     private final ValidationList vlist;
 321     /** recursion depth */
 322     private long depth;
 323     /** Total number of references to any type of object, class, enum, proxy, etc. */
 324     private long totalObjectRefs;
 325     /** whether stream is closed */
 326     private boolean closed;
 327 
 328     /** wire handle -&gt; obj/exception map */
 329     private final HandleTable handles;
 330     /** scratch field for passing handle values up/down call stack */
 331     private int passHandle = NULL_HANDLE;
 332     /** flag set when at end of field value block with no TC_ENDBLOCKDATA */
 333     private boolean defaultDataEnd = false;
 334 
 335     /** if true, invoke readObjectOverride() instead of readObject() */
 336     private final boolean enableOverride;
 337     /** if true, invoke resolveObject() */
 338     private boolean enableResolve;
 339 
 340     /**
 341      * Context during upcalls to class-defined readObject methods; holds
 342      * object currently being deserialized and descriptor for current class.
 343      * Null when not during readObject upcall.
 344      */
 345     private SerialCallbackContext curContext;
 346 
 347     /**
 348      * Filter of class descriptors and classes read from the stream;
 349      * may be null.
 350      */
 351     private ObjectInputFilter serialFilter;
 352 
 353     /**
 354      * Creates an ObjectInputStream that reads from the specified InputStream.
 355      * A serialization stream header is read from the stream and verified.
 356      * This constructor will block until the corresponding ObjectOutputStream
 357      * has written and flushed the header.
 358      *
 359      * &lt;p&gt;The serialization filter is initialized to the value of
 360      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 361      *
 362      * &lt;p&gt;If a security manager is installed, this constructor will check for
 363      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 364      * directly or indirectly by the constructor of a subclass which overrides
 365      * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
 366      * methods.
 367      *
 368      * @param   in input stream to read from
 369      * @throws  StreamCorruptedException if the stream header is incorrect
 370      * @throws  IOException if an I/O error occurs while reading stream header
 371      * @throws  SecurityException if untrusted subclass illegally overrides
 372      *          security-sensitive methods
 373      * @throws  NullPointerException if {@code in} is {@code null}
 374      * @see     ObjectInputStream#ObjectInputStream()
 375      * @see     ObjectInputStream#readFields()
 376      * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
 377      */
 378     public ObjectInputStream(InputStream in) throws IOException {
 379         verifySubclass();
 380         bin = new BlockDataInputStream(in);
 381         handles = new HandleTable(10);
 382         vlist = new ValidationList();
 383         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 384         enableOverride = false;
 385         readStreamHeader();
 386         bin.setBlockDataMode(true);
 387     }
 388 
 389     /**
 390      * Provide a way for subclasses that are completely reimplementing
 391      * ObjectInputStream to not have to allocate private data just used by this
 392      * implementation of ObjectInputStream.
 393      *
 394      * &lt;p&gt;The serialization filter is initialized to the value of
 395      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 396      *
 397      * &lt;p&gt;If there is a security manager installed, this method first calls the
 398      * security manager&#39;s {@code checkPermission} method with the
 399      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}
 400      * permission to ensure it&#39;s ok to enable subclassing.
 401      *
 402      * @throws  SecurityException if a security manager exists and its
 403      *          {@code checkPermission} method denies enabling
 404      *          subclassing.
 405      * @throws  IOException if an I/O error occurs while creating this stream
 406      * @see SecurityManager#checkPermission
 407      * @see java.io.SerializablePermission
 408      */
 409     protected ObjectInputStream() throws IOException, SecurityException {
 410         SecurityManager sm = System.getSecurityManager();
 411         if (sm != null) {
 412             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 413         }
 414         bin = null;
 415         handles = null;
 416         vlist = null;
 417         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 418         enableOverride = true;
 419     }
 420 
 421     /**
 422      * Read an object from the ObjectInputStream.  The class of the object, the
 423      * signature of the class, and the values of the non-transient and
 424      * non-static fields of the class and all of its supertypes are read.
 425      * Default deserializing for a class can be overridden using the writeObject
 426      * and readObject methods.  Objects referenced by this object are read
 427      * transitively so that a complete equivalent graph of objects is
 428      * reconstructed by readObject.
 429      *
 430      * &lt;p&gt;The root object is completely restored when all of its fields and the
 431      * objects it references are completely restored.  At this point the object
 432      * validation callbacks are executed in order based on their registered
 433      * priorities. The callbacks are registered by objects (in the readObject
 434      * special methods) as they are individually restored.
 435      *
 436      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 437      * each object (regular or class) read to reconstruct the root object.
 438      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 439      *
 440      * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
 441      * classes that should not be deserialized.  All exceptions are fatal to
 442      * the InputStream and leave it in an indeterminate state; it is up to the
 443      * caller to ignore or recover the stream state.
 444      *
 445      * @throws  ClassNotFoundException Class of a serialized object cannot be
 446      *          found.
 447      * @throws  InvalidClassException Something is wrong with a class used by
 448      *          serialization.
 449      * @throws  StreamCorruptedException Control information in the
 450      *          stream is inconsistent.
 451      * @throws  OptionalDataException Primitive data was found in the
 452      *          stream instead of objects.
 453      * @throws  IOException Any of the usual Input/Output related exceptions.
 454      */
 455     public final Object readObject()
 456         throws IOException, ClassNotFoundException {
 457         return readObject(Object.class);
 458     }
 459 
 460     /**
 461      * Reads a String and only a string.
 462      *
 463      * @return  the String read
 464      * @throws  EOFException If end of file is reached.
 465      * @throws  IOException If other I/O error has occurred.
 466      */
 467     private String readString() throws IOException {
 468         try {
 469             return (String) readObject(String.class);
 470         } catch (ClassNotFoundException cnf) {
 471             throw new IllegalStateException(cnf);
 472         }
 473     }
 474 
 475     /**
 476      * Internal method to read an object from the ObjectInputStream of the expected type.
 477      * Called only from {@code readObject()} and {@code readString()}.
 478      * Only {@code Object.class} and {@code String.class} are supported.
 479      *
 480      * @param type the type expected; either Object.class or String.class
 481      * @return an object of the type
 482      * @throws  IOException Any of the usual Input/Output related exceptions.
 483      * @throws  ClassNotFoundException Class of a serialized object cannot be
 484      *          found.
 485      */
 486     private final Object readObject(Class&lt;?&gt; type)
 487         throws IOException, ClassNotFoundException
 488     {
 489         if (enableOverride) {
 490             return readObjectOverride();
 491         }
 492 
 493         if (! (type == Object.class || type == String.class))
 494             throw new AssertionError(&quot;internal error&quot;);
 495 
 496         // if nested read, passHandle contains handle of enclosing object
 497         int outerHandle = passHandle;
 498         try {
 499             Object obj = readObject0(type, false);
 500             handles.markDependency(outerHandle, passHandle);
 501             ClassNotFoundException ex = handles.lookupException(passHandle);
 502             if (ex != null) {
 503                 throw ex;
 504             }
 505             if (depth == 0) {
 506                 vlist.doCallbacks();
 507                 freeze();
 508             }
 509             return obj;
 510         } finally {
 511             passHandle = outerHandle;
 512             if (closed &amp;&amp; depth == 0) {
 513                 clear();
 514             }
 515         }
 516     }
 517 
 518     /**
 519      * This method is called by trusted subclasses of ObjectInputStream that
 520      * constructed ObjectInputStream using the protected no-arg constructor.
 521      * The subclass is expected to provide an override method with the modifier
 522      * &quot;final&quot;.
 523      *
 524      * @return  the Object read from the stream.
 525      * @throws  ClassNotFoundException Class definition of a serialized object
 526      *          cannot be found.
 527      * @throws  OptionalDataException Primitive data was found in the stream
 528      *          instead of objects.
 529      * @throws  IOException if I/O errors occurred while reading from the
 530      *          underlying stream
 531      * @see #ObjectInputStream()
 532      * @see #readObject()
 533      * @since 1.2
 534      */
 535     protected Object readObjectOverride()
 536         throws IOException, ClassNotFoundException
 537     {
 538         return null;
 539     }
 540 
 541     /**
 542      * Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
 543      * identical to readObject, except that it prevents subsequent calls to
 544      * readObject and readUnshared from returning additional references to the
 545      * deserialized instance obtained via this call.  Specifically:
 546      * &lt;ul&gt;
 547      *   &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
 548      *       stream representation of an object which has been written
 549      *       previously to the stream), an ObjectStreamException will be
 550      *       thrown.
 551      *
 552      *   &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
 553      *       to deserialize back-references to the stream handle deserialized
 554      *       by readUnshared will cause an ObjectStreamException to be thrown.
 555      * &lt;/ul&gt;
 556      * Deserializing an object via readUnshared invalidates the stream handle
 557      * associated with the returned object.  Note that this in itself does not
 558      * always guarantee that the reference returned by readUnshared is unique;
 559      * the deserialized object may define a readResolve method which returns an
 560      * object visible to other parties, or readUnshared may return a Class
 561      * object or enum constant obtainable elsewhere in the stream or through
 562      * external means. If the deserialized object defines a readResolve method
 563      * and the invocation of that method returns an array, then readUnshared
 564      * returns a shallow clone of that array; this guarantees that the returned
 565      * array object is unique and cannot be obtained a second time from an
 566      * invocation of readObject or readUnshared on the ObjectInputStream,
 567      * even if the underlying data stream has been manipulated.
 568      *
 569      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 570      * each object (regular or class) read to reconstruct the root object.
 571      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 572      *
 573      * &lt;p&gt;ObjectInputStream subclasses which override this method can only be
 574      * constructed in security contexts possessing the
 575      * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 576      * instantiate such a subclass without this permission will cause a
 577      * SecurityException to be thrown.
 578      *
 579      * @return  reference to deserialized object
 580      * @throws  ClassNotFoundException if class of an object to deserialize
 581      *          cannot be found
 582      * @throws  StreamCorruptedException if control information in the stream
 583      *          is inconsistent
 584      * @throws  ObjectStreamException if object to deserialize has already
 585      *          appeared in stream
 586      * @throws  OptionalDataException if primitive data is next in stream
 587      * @throws  IOException if an I/O error occurs during deserialization
 588      * @since   1.4
 589      */
 590     public Object readUnshared() throws IOException, ClassNotFoundException {
 591         // if nested read, passHandle contains handle of enclosing object
 592         int outerHandle = passHandle;
 593         try {
 594             Object obj = readObject0(Object.class, true);
 595             handles.markDependency(outerHandle, passHandle);
 596             ClassNotFoundException ex = handles.lookupException(passHandle);
 597             if (ex != null) {
 598                 throw ex;
 599             }
 600             if (depth == 0) {
 601                 vlist.doCallbacks();
 602                 freeze();
 603             }
 604             return obj;
 605         } finally {
 606             passHandle = outerHandle;
 607             if (closed &amp;&amp; depth == 0) {
 608                 clear();
 609             }
 610         }
 611     }
 612 
 613     /**
 614      * Read the non-static and non-transient fields of the current class from
 615      * this stream.  This may only be called from the readObject method of the
 616      * class being deserialized. It will throw the NotActiveException if it is
 617      * called otherwise.
 618      *
 619      * @throws  ClassNotFoundException if the class of a serialized object
 620      *          could not be found.
 621      * @throws  IOException if an I/O error occurs.
 622      * @throws  NotActiveException if the stream is not currently reading
 623      *          objects.
 624      */
 625     public void defaultReadObject()
 626         throws IOException, ClassNotFoundException
 627     {
 628         SerialCallbackContext ctx = curContext;
 629         if (ctx == null) {
 630             throw new NotActiveException(&quot;not in call to readObject&quot;);
 631         }
 632         Object curObj = ctx.getObj();
 633         ObjectStreamClass curDesc = ctx.getDesc();
 634         bin.setBlockDataMode(false);
 635         FieldValues vals = defaultReadFields(curObj, curDesc);
 636         if (curObj != null) {
 637             defaultCheckFieldValues(curObj, curDesc, vals);
 638             defaultSetFieldValues(curObj, curDesc, vals);
 639         }
 640         bin.setBlockDataMode(true);
 641         if (!curDesc.hasWriteObjectData()) {
 642             /*
 643              * Fix for 4360508: since stream does not contain terminating
 644              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 645              * knows to simulate end-of-custom-data behavior.
 646              */
 647             defaultDataEnd = true;
 648         }
 649         ClassNotFoundException ex = handles.lookupException(passHandle);
 650         if (ex != null) {
 651             throw ex;
 652         }
 653     }
 654 
 655     /**
 656      * Reads the persistent fields from the stream and makes them available by
 657      * name.
 658      *
 659      * @return  the {@code GetField} object representing the persistent
 660      *          fields of the object being deserialized
 661      * @throws  ClassNotFoundException if the class of a serialized object
 662      *          could not be found.
 663      * @throws  IOException if an I/O error occurs.
 664      * @throws  NotActiveException if the stream is not currently reading
 665      *          objects.
 666      * @since 1.2
 667      */
 668     public ObjectInputStream.GetField readFields()
 669         throws IOException, ClassNotFoundException
 670     {
 671         SerialCallbackContext ctx = curContext;
 672         if (ctx == null) {
 673             throw new NotActiveException(&quot;not in call to readObject&quot;);
 674         }
 675         ctx.checkAndSetUsed();
 676         ObjectStreamClass curDesc = ctx.getDesc();
 677         bin.setBlockDataMode(false);
 678         GetFieldImpl getField = new GetFieldImpl(curDesc);
 679         getField.readFields();
 680         bin.setBlockDataMode(true);
 681         if (!curDesc.hasWriteObjectData()) {
 682             /*
 683              * Fix for 4360508: since stream does not contain terminating
 684              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 685              * knows to simulate end-of-custom-data behavior.
 686              */
 687             defaultDataEnd = true;
 688         }
 689 
 690         return getField;
 691     }
 692 
 693     /**
 694      * Register an object to be validated before the graph is returned.  While
 695      * similar to resolveObject these validations are called after the entire
 696      * graph has been reconstituted.  Typically, a readObject method will
 697      * register the object with the stream so that when all of the objects are
 698      * restored a final set of validations can be performed.
 699      *
 700      * @param   obj the object to receive the validation callback.
 701      * @param   prio controls the order of callbacks;zero is a good default.
 702      *          Use higher numbers to be called back earlier, lower numbers for
 703      *          later callbacks. Within a priority, callbacks are processed in
 704      *          no particular order.
 705      * @throws  NotActiveException The stream is not currently reading objects
 706      *          so it is invalid to register a callback.
 707      * @throws  InvalidObjectException The validation object is null.
 708      */
 709     public void registerValidation(ObjectInputValidation obj, int prio)
 710         throws NotActiveException, InvalidObjectException
 711     {
 712         if (depth == 0) {
 713             throw new NotActiveException(&quot;stream inactive&quot;);
 714         }
 715         vlist.register(obj, prio);
 716     }
 717 
 718     /**
 719      * Load the local class equivalent of the specified stream class
 720      * description.  Subclasses may implement this method to allow classes to
 721      * be fetched from an alternate source.
 722      *
 723      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 724      * {@code annotateClass}.  This method will be invoked only once for
 725      * each unique class in the stream.  This method can be implemented by
 726      * subclasses to use an alternate loading mechanism but must return a
 727      * {@code Class} object. Once returned, if the class is not an array
 728      * class, its serialVersionUID is compared to the serialVersionUID of the
 729      * serialized class, and if there is a mismatch, the deserialization fails
 730      * and an {@link InvalidClassException} is thrown.
 731      *
 732      * &lt;p&gt;The default implementation of this method in
 733      * {@code ObjectInputStream} returns the result of calling
 734      * &lt;pre&gt;
 735      *     Class.forName(desc.getName(), false, loader)
 736      * &lt;/pre&gt;
 737      * where {@code loader} is the first class loader on the current
 738      * thread&#39;s stack (starting from the currently executing method) that is
 739      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 740      * class loader} nor its ancestor; otherwise, {@code loader} is the
 741      * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
 742      * {@code ClassNotFoundException} and the name of the passed
 743      * {@code ObjectStreamClass} instance is the Java language keyword
 744      * for a primitive type or void, then the {@code Class} object
 745      * representing that primitive type or void will be returned
 746      * (e.g., an {@code ObjectStreamClass} with the name
 747      * {@code &quot;int&quot;} will be resolved to {@code Integer.TYPE}).
 748      * Otherwise, the {@code ClassNotFoundException} will be thrown to
 749      * the caller of this method.
 750      *
 751      * @param   desc an instance of class {@code ObjectStreamClass}
 752      * @return  a {@code Class} object corresponding to {@code desc}
 753      * @throws  IOException any of the usual Input/Output exceptions.
 754      * @throws  ClassNotFoundException if class of a serialized object cannot
 755      *          be found.
 756      */
 757     protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
 758         throws IOException, ClassNotFoundException
 759     {
 760         String name = desc.getName();
 761         try {
 762             return Class.forName(name, false, latestUserDefinedLoader());
 763         } catch (ClassNotFoundException ex) {
 764             Class&lt;?&gt; cl = primClasses.get(name);
 765             if (cl != null) {
 766                 return cl;
 767             } else {
 768                 throw ex;
 769             }
 770         }
 771     }
 772 
 773     /**
 774      * Returns a proxy class that implements the interfaces named in a proxy
 775      * class descriptor; subclasses may implement this method to read custom
 776      * data from the stream along with the descriptors for dynamic proxy
 777      * classes, allowing them to use an alternate loading mechanism for the
 778      * interfaces and the proxy class.
 779      *
 780      * &lt;p&gt;This method is called exactly once for each unique proxy class
 781      * descriptor in the stream.
 782      *
 783      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 784      * {@code annotateProxyClass}.  For a given subclass of
 785      * {@code ObjectInputStream} that overrides this method, the
 786      * {@code annotateProxyClass} method in the corresponding subclass of
 787      * {@code ObjectOutputStream} must write any data or objects read by
 788      * this method.
 789      *
 790      * &lt;p&gt;The default implementation of this method in
 791      * {@code ObjectInputStream} returns the result of calling
 792      * {@code Proxy.getProxyClass} with the list of {@code Class}
 793      * objects for the interfaces that are named in the {@code interfaces}
 794      * parameter.  The {@code Class} object for each interface name
 795      * {@code i} is the value returned by calling
 796      * &lt;pre&gt;
 797      *     Class.forName(i, false, loader)
 798      * &lt;/pre&gt;
 799      * where {@code loader} is the first class loader on the current
 800      * thread&#39;s stack (starting from the currently executing method) that is
 801      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 802      * class loader} nor its ancestor; otherwise, {@code loader} is the
 803      * &lt;em&gt;platform class loader&lt;/em&gt;.
 804      * Unless any of the resolved interfaces are non-public, this same value
 805      * of {@code loader} is also the class loader passed to
 806      * {@code Proxy.getProxyClass}; if non-public interfaces are present,
 807      * their class loader is passed instead (if more than one non-public
 808      * interface class loader is encountered, an
 809      * {@code IllegalAccessError} is thrown).
 810      * If {@code Proxy.getProxyClass} throws an
 811      * {@code IllegalArgumentException}, {@code resolveProxyClass}
 812      * will throw a {@code ClassNotFoundException} containing the
 813      * {@code IllegalArgumentException}.
 814      *
 815      * @param interfaces the list of interface names that were
 816      *                deserialized in the proxy class descriptor
 817      * @return  a proxy class for the specified interfaces
 818      * @throws        IOException any exception thrown by the underlying
 819      *                {@code InputStream}
 820      * @throws        ClassNotFoundException if the proxy class or any of the
 821      *                named interfaces could not be found
 822      * @see ObjectOutputStream#annotateProxyClass(Class)
 823      * @since 1.3
 824      */
 825     protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
 826         throws IOException, ClassNotFoundException
 827     {
 828         ClassLoader latestLoader = latestUserDefinedLoader();
 829         ClassLoader nonPublicLoader = null;
 830         boolean hasNonPublicInterface = false;
 831 
 832         // define proxy in class loader of non-public interface(s), if any
 833         Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];
 834         for (int i = 0; i &lt; interfaces.length; i++) {
 835             Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);
 836             if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {
 837                 if (hasNonPublicInterface) {
 838                     if (nonPublicLoader != cl.getClassLoader()) {
 839                         throw new IllegalAccessError(
 840                             &quot;conflicting non-public interface class loaders&quot;);
 841                     }
 842                 } else {
 843                     nonPublicLoader = cl.getClassLoader();
 844                     hasNonPublicInterface = true;
 845                 }
 846             }
 847             classObjs[i] = cl;
 848         }
 849         try {
 850             @SuppressWarnings(&quot;deprecation&quot;)
 851             Class&lt;?&gt; proxyClass = Proxy.getProxyClass(
 852                 hasNonPublicInterface ? nonPublicLoader : latestLoader,
 853                 classObjs);
 854             return proxyClass;
 855         } catch (IllegalArgumentException e) {
 856             throw new ClassNotFoundException(null, e);
 857         }
 858     }
 859 
 860     /**
 861      * This method will allow trusted subclasses of ObjectInputStream to
 862      * substitute one object for another during deserialization. Replacing
 863      * objects is disabled until enableResolveObject is called. The
 864      * enableResolveObject method checks that the stream requesting to resolve
 865      * object can be trusted. Every reference to serializable objects is passed
 866      * to resolveObject.  To insure that the private state of objects is not
 867      * unintentionally exposed only trusted streams may use resolveObject.
 868      *
 869      * &lt;p&gt;This method is called after an object has been read but before it is
 870      * returned from readObject.  The default resolveObject method just returns
 871      * the same object.
 872      *
 873      * &lt;p&gt;When a subclass is replacing objects it must insure that the
 874      * substituted object is compatible with every field where the reference
 875      * will be stored.  Objects whose type is not a subclass of the type of the
 876      * field or array element abort the serialization by raising an exception
 877      * and the object is not be stored.
 878      *
 879      * &lt;p&gt;This method is called only once when each object is first
 880      * encountered.  All subsequent references to the object will be redirected
 881      * to the new object.
 882      *
 883      * @param   obj object to be substituted
 884      * @return  the substituted object
 885      * @throws  IOException Any of the usual Input/Output exceptions.
 886      */
 887     protected Object resolveObject(Object obj) throws IOException {
 888         return obj;
 889     }
 890 
 891     /**
 892      * Enables the stream to do replacement of objects read from the stream. When
 893      * enabled, the {@link #resolveObject} method is called for every object being
 894      * deserialized.
 895      *
 896      * &lt;p&gt;If object replacement is currently not enabled, and
 897      * {@code enable} is true, and there is a security manager installed,
 898      * this method first calls the security manager&#39;s
 899      * {@code checkPermission} method with the
 900      * {@code SerializablePermission(&quot;enableSubstitution&quot;)} permission to
 901      * ensure that the caller is permitted to enable the stream to do replacement
 902      * of objects read from the stream.
 903      *
 904      * @param   enable true for enabling use of {@code resolveObject} for
 905      *          every object being deserialized
 906      * @return  the previous setting before this method was invoked
 907      * @throws  SecurityException if a security manager exists and its
 908      *          {@code checkPermission} method denies enabling the stream
 909      *          to do replacement of objects read from the stream.
 910      * @see SecurityManager#checkPermission
 911      * @see java.io.SerializablePermission
 912      */
 913     protected boolean enableResolveObject(boolean enable)
 914         throws SecurityException
 915     {
 916         if (enable == enableResolve) {
 917             return enable;
 918         }
 919         if (enable) {
 920             SecurityManager sm = System.getSecurityManager();
 921             if (sm != null) {
 922                 sm.checkPermission(SUBSTITUTION_PERMISSION);
 923             }
 924         }
 925         enableResolve = enable;
 926         return !enableResolve;
 927     }
 928 
 929     /**
 930      * The readStreamHeader method is provided to allow subclasses to read and
 931      * verify their own stream headers. It reads and verifies the magic number
 932      * and version number.
 933      *
 934      * @throws  IOException if there are I/O errors while reading from the
 935      *          underlying {@code InputStream}
 936      * @throws  StreamCorruptedException if control information in the stream
 937      *          is inconsistent
 938      */
 939     protected void readStreamHeader()
 940         throws IOException, StreamCorruptedException
 941     {
 942         short s0 = bin.readShort();
 943         short s1 = bin.readShort();
 944         if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
 945             throw new StreamCorruptedException(
 946                 String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));
 947         }
 948     }
 949 
 950     /**
 951      * Read a class descriptor from the serialization stream.  This method is
 952      * called when the ObjectInputStream expects a class descriptor as the next
 953      * item in the serialization stream.  Subclasses of ObjectInputStream may
 954      * override this method to read in class descriptors that have been written
 955      * in non-standard formats (by subclasses of ObjectOutputStream which have
 956      * overridden the {@code writeClassDescriptor} method).  By default,
 957      * this method reads class descriptors according to the format defined in
 958      * the Object Serialization specification.
 959      *
 960      * @return  the class descriptor read
 961      * @throws  IOException If an I/O error has occurred.
 962      * @throws  ClassNotFoundException If the Class of a serialized object used
 963      *          in the class descriptor representation cannot be found
 964      * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 965      * @since 1.3
 966      */
 967     protected ObjectStreamClass readClassDescriptor()
 968         throws IOException, ClassNotFoundException
 969     {
 970         ObjectStreamClass desc = new ObjectStreamClass();
 971         desc.readNonProxy(this);
 972         return desc;
 973     }
 974 
 975     /**
 976      * Reads a byte of data. This method will block if no input is available.
 977      *
 978      * @return  the byte read, or -1 if the end of the stream is reached.
 979      * @throws  IOException If an I/O error has occurred.
 980      */
 981     public int read() throws IOException {
 982         return bin.read();
 983     }
 984 
 985     /**
 986      * Reads into an array of bytes.  This method will block until some input
 987      * is available. Consider using java.io.DataInputStream.readFully to read
 988      * exactly &#39;length&#39; bytes.
 989      *
 990      * @param   buf the buffer into which the data is read
 991      * @param   off the start offset in the destination array {@code buf}
 992      * @param   len the maximum number of bytes read
 993      * @return  the actual number of bytes read, -1 is returned when the end of
 994      *          the stream is reached.
 995      * @throws  NullPointerException if {@code buf} is {@code null}.
 996      * @throws  IndexOutOfBoundsException if {@code off} is negative,
 997      *          {@code len} is negative, or {@code len} is greater than
 998      *          {@code buf.length - off}.
 999      * @throws  IOException If an I/O error has occurred.
1000      * @see java.io.DataInputStream#readFully(byte[],int,int)
1001      */
1002     public int read(byte[] buf, int off, int len) throws IOException {
1003         if (buf == null) {
1004             throw new NullPointerException();
1005         }
1006         int endoff = off + len;
1007         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1008             throw new IndexOutOfBoundsException();
1009         }
1010         return bin.read(buf, off, len, false);
1011     }
1012 
1013     /**
1014      * Returns the number of bytes that can be read without blocking.
1015      *
1016      * @return  the number of available bytes.
1017      * @throws  IOException if there are I/O errors while reading from the
1018      *          underlying {@code InputStream}
1019      */
1020     public int available() throws IOException {
1021         return bin.available();
1022     }
1023 
1024     /**
1025      * Closes the input stream. Must be called to release any resources
1026      * associated with the stream.
1027      *
1028      * @throws  IOException If an I/O error has occurred.
1029      */
1030     public void close() throws IOException {
1031         /*
1032          * Even if stream already closed, propagate redundant close to
1033          * underlying stream to stay consistent with previous implementations.
1034          */
1035         closed = true;
1036         if (depth == 0) {
1037             clear();
1038         }
1039         bin.close();
1040     }
1041 
1042     /**
1043      * Reads in a boolean.
1044      *
1045      * @return  the boolean read.
1046      * @throws  EOFException If end of file is reached.
1047      * @throws  IOException If other I/O error has occurred.
1048      */
1049     public boolean readBoolean() throws IOException {
1050         return bin.readBoolean();
1051     }
1052 
1053     /**
1054      * Reads an 8 bit byte.
1055      *
1056      * @return  the 8 bit byte read.
1057      * @throws  EOFException If end of file is reached.
1058      * @throws  IOException If other I/O error has occurred.
1059      */
1060     public byte readByte() throws IOException  {
1061         return bin.readByte();
1062     }
1063 
1064     /**
1065      * Reads an unsigned 8 bit byte.
1066      *
1067      * @return  the 8 bit byte read.
1068      * @throws  EOFException If end of file is reached.
1069      * @throws  IOException If other I/O error has occurred.
1070      */
1071     public int readUnsignedByte()  throws IOException {
1072         return bin.readUnsignedByte();
1073     }
1074 
1075     /**
1076      * Reads a 16 bit char.
1077      *
1078      * @return  the 16 bit char read.
1079      * @throws  EOFException If end of file is reached.
1080      * @throws  IOException If other I/O error has occurred.
1081      */
1082     public char readChar()  throws IOException {
1083         return bin.readChar();
1084     }
1085 
1086     /**
1087      * Reads a 16 bit short.
1088      *
1089      * @return  the 16 bit short read.
1090      * @throws  EOFException If end of file is reached.
1091      * @throws  IOException If other I/O error has occurred.
1092      */
1093     public short readShort()  throws IOException {
1094         return bin.readShort();
1095     }
1096 
1097     /**
1098      * Reads an unsigned 16 bit short.
1099      *
1100      * @return  the 16 bit short read.
1101      * @throws  EOFException If end of file is reached.
1102      * @throws  IOException If other I/O error has occurred.
1103      */
1104     public int readUnsignedShort() throws IOException {
1105         return bin.readUnsignedShort();
1106     }
1107 
1108     /**
1109      * Reads a 32 bit int.
1110      *
1111      * @return  the 32 bit integer read.
1112      * @throws  EOFException If end of file is reached.
1113      * @throws  IOException If other I/O error has occurred.
1114      */
1115     public int readInt()  throws IOException {
1116         return bin.readInt();
1117     }
1118 
1119     /**
1120      * Reads a 64 bit long.
1121      *
1122      * @return  the read 64 bit long.
1123      * @throws  EOFException If end of file is reached.
1124      * @throws  IOException If other I/O error has occurred.
1125      */
1126     public long readLong()  throws IOException {
1127         return bin.readLong();
1128     }
1129 
1130     /**
1131      * Reads a 32 bit float.
1132      *
1133      * @return  the 32 bit float read.
1134      * @throws  EOFException If end of file is reached.
1135      * @throws  IOException If other I/O error has occurred.
1136      */
1137     public float readFloat() throws IOException {
1138         return bin.readFloat();
1139     }
1140 
1141     /**
1142      * Reads a 64 bit double.
1143      *
1144      * @return  the 64 bit double read.
1145      * @throws  EOFException If end of file is reached.
1146      * @throws  IOException If other I/O error has occurred.
1147      */
1148     public double readDouble() throws IOException {
1149         return bin.readDouble();
1150     }
1151 
1152     /**
1153      * Reads bytes, blocking until all bytes are read.
1154      *
1155      * @param   buf the buffer into which the data is read
1156      * @throws  NullPointerException If {@code buf} is {@code null}.
1157      * @throws  EOFException If end of file is reached.
1158      * @throws  IOException If other I/O error has occurred.
1159      */
1160     public void readFully(byte[] buf) throws IOException {
1161         bin.readFully(buf, 0, buf.length, false);
1162     }
1163 
1164     /**
1165      * Reads bytes, blocking until all bytes are read.
1166      *
1167      * @param   buf the buffer into which the data is read
1168      * @param   off the start offset into the data array {@code buf}
1169      * @param   len the maximum number of bytes to read
1170      * @throws  NullPointerException If {@code buf} is {@code null}.
1171      * @throws  IndexOutOfBoundsException If {@code off} is negative,
1172      *          {@code len} is negative, or {@code len} is greater than
1173      *          {@code buf.length - off}.
1174      * @throws  EOFException If end of file is reached.
1175      * @throws  IOException If other I/O error has occurred.
1176      */
1177     public void readFully(byte[] buf, int off, int len) throws IOException {
1178         int endoff = off + len;
1179         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1180             throw new IndexOutOfBoundsException();
1181         }
1182         bin.readFully(buf, off, len, false);
1183     }
1184 
1185     /**
1186      * Skips bytes.
1187      *
1188      * @param   len the number of bytes to be skipped
1189      * @return  the actual number of bytes skipped.
1190      * @throws  IOException If an I/O error has occurred.
1191      */
1192     public int skipBytes(int len) throws IOException {
1193         return bin.skipBytes(len);
1194     }
1195 
1196     /**
1197      * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
1198      *
1199      * @return  a String copy of the line.
1200      * @throws  IOException if there are I/O errors while reading from the
1201      *          underlying {@code InputStream}
1202      * @deprecated This method does not properly convert bytes to characters.
1203      *          see DataInputStream for the details and alternatives.
1204      */
1205     @Deprecated
1206     public String readLine() throws IOException {
1207         return bin.readLine();
1208     }
1209 
1210     /**
1211      * Reads a String in
1212      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
1213      * format.
1214      *
1215      * @return  the String.
1216      * @throws  IOException if there are I/O errors while reading from the
1217      *          underlying {@code InputStream}
1218      * @throws  UTFDataFormatException if read bytes do not represent a valid
1219      *          modified UTF-8 encoding of a string
1220      */
1221     public String readUTF() throws IOException {
1222         return bin.readUTF();
1223     }
1224 
1225     /**
1226      * Returns the serialization filter for this stream.
1227      * The serialization filter is the most recent filter set in
1228      * {@link #setObjectInputFilter setObjectInputFilter} or
1229      * the initial system-wide filter from
1230      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.
1231      *
1232      * @return the serialization filter for the stream; may be null
1233      * @since 9
1234      */
1235     public final ObjectInputFilter getObjectInputFilter() {
1236         return serialFilter;
1237     }
1238 
1239     /**
1240      * Set the serialization filter for the stream.
1241      * The filter&#39;s {@link ObjectInputFilter#checkInput checkInput} method is called
1242      * for each class and reference in the stream.
1243      * The filter can check any or all of the class, the array length, the number
1244      * of references, the depth of the graph, and the size of the input stream.
1245      * The depth is the number of nested {@linkplain #readObject readObject}
1246      * calls starting with the reading of the root of the graph being deserialized
1247      * and the current object being deserialized.
1248      * The number of references is the cumulative number of objects and references
1249      * to objects already read from the stream including the current object being read.
1250      * The filter is invoked only when reading objects from the stream and for
1251      * not primitives.
1252      * &lt;p&gt;
1253      * If the filter returns {@link ObjectInputFilter.Status#REJECTED Status.REJECTED},
1254      * {@code null} or throws a {@link RuntimeException},
1255      * the active {@code readObject} or {@code readUnshared}
1256      * throws {@link InvalidClassException}, otherwise deserialization
1257      * continues uninterrupted.
1258      * &lt;p&gt;
1259      * The serialization filter is initialized to the value of
1260      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}
1261      * when the {@code  ObjectInputStream} is constructed and can be set
1262      * to a custom filter only once.
1263      *
1264      * @implSpec
1265      * The filter, when not {@code null}, is invoked during {@link #readObject readObject}
1266      * and {@link #readUnshared readUnshared} for each object (regular or class) in the stream.
1267      * Strings are treated as primitives and do not invoke the filter.
1268      * The filter is called for:
1269      * &lt;ul&gt;
1270      *     &lt;li&gt;each object reference previously deserialized from the stream
1271      *     (class is {@code null}, arrayLength is -1),
1272      *     &lt;li&gt;each regular class (class is not {@code null}, arrayLength is -1),
1273      *     &lt;li&gt;each interface of a dynamic proxy and the dynamic proxy class itself
1274      *     (class is not {@code null}, arrayLength is -1),
1275      *     &lt;li&gt;each array is filtered using the array type and length of the array
1276      *     (class is the array type, arrayLength is the requested length),
1277      *     &lt;li&gt;each object replaced by its class&#39; {@code readResolve} method
1278      *         is filtered using the replacement object&#39;s class, if not {@code null},
1279      *         and if it is an array, the arrayLength, otherwise -1,
1280      *     &lt;li&gt;and each object replaced by {@link #resolveObject resolveObject}
1281      *         is filtered using the replacement object&#39;s class, if not {@code null},
1282      *         and if it is an array, the arrayLength, otherwise -1.
1283      * &lt;/ul&gt;
1284      *
1285      * When the {@link ObjectInputFilter#checkInput checkInput} method is invoked
1286      * it is given access to the current class, the array length,
1287      * the current number of references already read from the stream,
1288      * the depth of nested calls to {@link #readObject readObject} or
1289      * {@link #readUnshared readUnshared},
1290      * and the implementation dependent number of bytes consumed from the input stream.
1291      * &lt;p&gt;
1292      * Each call to {@link #readObject readObject} or
1293      * {@link #readUnshared readUnshared} increases the depth by 1
1294      * before reading an object and decreases by 1 before returning
1295      * normally or exceptionally.
1296      * The depth starts at {@code 1} and increases for each nested object and
1297      * decrements when each nested call returns.
1298      * The count of references in the stream starts at {@code 1} and
1299      * is increased before reading an object.
1300      *
1301      * @param filter the filter, may be null
1302      * @throws SecurityException if there is security manager and the
1303      *       {@code SerializablePermission(&quot;serialFilter&quot;)} is not granted
1304      * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}
1305      *       is not {@code null} and is not the system-wide filter
1306      * @since 9
1307      */
1308     public final void setObjectInputFilter(ObjectInputFilter filter) {
1309         SecurityManager sm = System.getSecurityManager();
1310         if (sm != null) {
1311             sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);
1312         }
1313         // Allow replacement of the system-wide filter if not already set
1314         if (serialFilter != null &amp;&amp;
1315                 serialFilter != ObjectInputFilter.Config.getSerialFilter()) {
1316             throw new IllegalStateException(&quot;filter can not be set more than once&quot;);
1317         }
1318         this.serialFilter = filter;
1319     }
1320 
1321     /**
1322      * Invoke the serialization filter if non-null.
1323      * If the filter rejects or an exception is thrown, throws InvalidClassException.
1324      *
1325      * @param clazz the class; may be null
1326      * @param arrayLength the array length requested; use {@code -1} if not creating an array
1327      * @throws InvalidClassException if it rejected by the filter or
1328      *        a {@link RuntimeException} is thrown
1329      */
1330     private void filterCheck(Class&lt;?&gt; clazz, int arrayLength)
1331             throws InvalidClassException {
1332         if (serialFilter != null) {
1333             RuntimeException ex = null;
1334             ObjectInputFilter.Status status;
1335             // Info about the stream is not available if overridden by subclass, return 0
1336             long bytesRead = (bin == null) ? 0 : bin.getBytesRead();
1337             try {
1338                 status = serialFilter.checkInput(new FilterValues(clazz, arrayLength,
1339                         totalObjectRefs, depth, bytesRead));
1340             } catch (RuntimeException e) {
1341                 // Preventive interception of an exception to log
1342                 status = ObjectInputFilter.Status.REJECTED;
1343                 ex = e;
1344             }
1345             if (Logging.filterLogger != null) {
1346                 // Debug logging of filter checks that fail; Tracing for those that succeed
1347                 Logging.filterLogger.log(status == null || status == ObjectInputFilter.Status.REJECTED
1348                                 ? Logger.Level.DEBUG
1349                                 : Logger.Level.TRACE,
1350                         &quot;ObjectInputFilter {0}: {1}, array length: {2}, nRefs: {3}, depth: {4}, bytes: {5}, ex: {6}&quot;,
1351                         status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,
1352                         Objects.toString(ex, &quot;n/a&quot;));
1353             }
1354             if (status == null ||
1355                     status == ObjectInputFilter.Status.REJECTED) {
1356                 InvalidClassException ice = new InvalidClassException(&quot;filter status: &quot; + status);
1357                 ice.initCause(ex);
1358                 throw ice;
1359             }
1360         }
1361     }
1362 
1363     /**
1364      * Checks the given array type and length to ensure that creation of such
1365      * an array is permitted by this ObjectInputStream. The arrayType argument
1366      * must represent an actual array type.
1367      *
1368      * This private method is called via SharedSecrets.
1369      *
1370      * @param arrayType the array type
1371      * @param arrayLength the array length
1372      * @throws NullPointerException if arrayType is null
1373      * @throws IllegalArgumentException if arrayType isn&#39;t actually an array type
1374      * @throws NegativeArraySizeException if arrayLength is negative
1375      * @throws InvalidClassException if the filter rejects creation
1376      */
1377     private void checkArray(Class&lt;?&gt; arrayType, int arrayLength) throws InvalidClassException {
1378         if (! arrayType.isArray()) {
1379             throw new IllegalArgumentException(&quot;not an array type&quot;);
1380         }
1381 
1382         if (arrayLength &lt; 0) {
1383             throw new NegativeArraySizeException();
1384         }
1385 
1386         filterCheck(arrayType, arrayLength);
1387     }
1388 
1389     /**
1390      * Provide access to the persistent fields read from the input stream.
1391      */
1392     public abstract static class GetField {
1393         /**
1394          * Constructor for subclasses to call.
1395          */
1396         public GetField() {}
1397 
1398         /**
1399          * Get the ObjectStreamClass that describes the fields in the stream.
1400          *
1401          * @return  the descriptor class that describes the serializable fields
1402          */
1403         public abstract ObjectStreamClass getObjectStreamClass();
1404 
1405         /**
1406          * Return true if the named field is defaulted and has no value in this
1407          * stream.
1408          *
1409          * @param  name the name of the field
1410          * @return true, if and only if the named field is defaulted
1411          * @throws IOException if there are I/O errors while reading from
1412          *         the underlying {@code InputStream}
1413          * @throws IllegalArgumentException if {@code name} does not
1414          *         correspond to a serializable field
1415          */
1416         public abstract boolean defaulted(String name) throws IOException;
1417 
1418         /**
1419          * Get the value of the named boolean field from the persistent field.
1420          *
1421          * @param  name the name of the field
1422          * @param  val the default value to use if {@code name} does not
1423          *         have a value
1424          * @return the value of the named {@code boolean} field
1425          * @throws IOException if there are I/O errors while reading from the
1426          *         underlying {@code InputStream}
1427          * @throws IllegalArgumentException if type of {@code name} is
1428          *         not serializable or if the field type is incorrect
1429          */
1430         public abstract boolean get(String name, boolean val)
1431             throws IOException;
1432 
1433         /**
1434          * Get the value of the named byte field from the persistent field.
1435          *
1436          * @param  name the name of the field
1437          * @param  val the default value to use if {@code name} does not
1438          *         have a value
1439          * @return the value of the named {@code byte} field
1440          * @throws IOException if there are I/O errors while reading from the
1441          *         underlying {@code InputStream}
1442          * @throws IllegalArgumentException if type of {@code name} is
1443          *         not serializable or if the field type is incorrect
1444          */
1445         public abstract byte get(String name, byte val) throws IOException;
1446 
1447         /**
1448          * Get the value of the named char field from the persistent field.
1449          *
1450          * @param  name the name of the field
1451          * @param  val the default value to use if {@code name} does not
1452          *         have a value
1453          * @return the value of the named {@code char} field
1454          * @throws IOException if there are I/O errors while reading from the
1455          *         underlying {@code InputStream}
1456          * @throws IllegalArgumentException if type of {@code name} is
1457          *         not serializable or if the field type is incorrect
1458          */
1459         public abstract char get(String name, char val) throws IOException;
1460 
1461         /**
1462          * Get the value of the named short field from the persistent field.
1463          *
1464          * @param  name the name of the field
1465          * @param  val the default value to use if {@code name} does not
1466          *         have a value
1467          * @return the value of the named {@code short} field
1468          * @throws IOException if there are I/O errors while reading from the
1469          *         underlying {@code InputStream}
1470          * @throws IllegalArgumentException if type of {@code name} is
1471          *         not serializable or if the field type is incorrect
1472          */
1473         public abstract short get(String name, short val) throws IOException;
1474 
1475         /**
1476          * Get the value of the named int field from the persistent field.
1477          *
1478          * @param  name the name of the field
1479          * @param  val the default value to use if {@code name} does not
1480          *         have a value
1481          * @return the value of the named {@code int} field
1482          * @throws IOException if there are I/O errors while reading from the
1483          *         underlying {@code InputStream}
1484          * @throws IllegalArgumentException if type of {@code name} is
1485          *         not serializable or if the field type is incorrect
1486          */
1487         public abstract int get(String name, int val) throws IOException;
1488 
1489         /**
1490          * Get the value of the named long field from the persistent field.
1491          *
1492          * @param  name the name of the field
1493          * @param  val the default value to use if {@code name} does not
1494          *         have a value
1495          * @return the value of the named {@code long} field
1496          * @throws IOException if there are I/O errors while reading from the
1497          *         underlying {@code InputStream}
1498          * @throws IllegalArgumentException if type of {@code name} is
1499          *         not serializable or if the field type is incorrect
1500          */
1501         public abstract long get(String name, long val) throws IOException;
1502 
1503         /**
1504          * Get the value of the named float field from the persistent field.
1505          *
1506          * @param  name the name of the field
1507          * @param  val the default value to use if {@code name} does not
1508          *         have a value
1509          * @return the value of the named {@code float} field
1510          * @throws IOException if there are I/O errors while reading from the
1511          *         underlying {@code InputStream}
1512          * @throws IllegalArgumentException if type of {@code name} is
1513          *         not serializable or if the field type is incorrect
1514          */
1515         public abstract float get(String name, float val) throws IOException;
1516 
1517         /**
1518          * Get the value of the named double field from the persistent field.
1519          *
1520          * @param  name the name of the field
1521          * @param  val the default value to use if {@code name} does not
1522          *         have a value
1523          * @return the value of the named {@code double} field
1524          * @throws IOException if there are I/O errors while reading from the
1525          *         underlying {@code InputStream}
1526          * @throws IllegalArgumentException if type of {@code name} is
1527          *         not serializable or if the field type is incorrect
1528          */
1529         public abstract double get(String name, double val) throws IOException;
1530 
1531         /**
1532          * Get the value of the named Object field from the persistent field.
1533          *
1534          * @param  name the name of the field
1535          * @param  val the default value to use if {@code name} does not
1536          *         have a value
1537          * @return the value of the named {@code Object} field
1538          * @throws IOException if there are I/O errors while reading from the
1539          *         underlying {@code InputStream}
1540          * @throws IllegalArgumentException if type of {@code name} is
1541          *         not serializable or if the field type is incorrect
1542          */
1543         public abstract Object get(String name, Object val) throws IOException;
1544     }
1545 
1546     /**
1547      * Verifies that this (possibly subclass) instance can be constructed
1548      * without violating security constraints: the subclass must not override
1549      * security-sensitive non-final methods, or else the
1550      * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
1551      */
1552     private void verifySubclass() {
1553         Class&lt;?&gt; cl = getClass();
1554         if (cl == ObjectInputStream.class) {
1555             return;
1556         }
1557         SecurityManager sm = System.getSecurityManager();
1558         if (sm == null) {
1559             return;
1560         }
1561         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
1562         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
1563         Boolean result = Caches.subclassAudits.get(key);
1564         if (result == null) {
1565             result = auditSubclass(cl);
1566             Caches.subclassAudits.putIfAbsent(key, result);
1567         }
1568         if (!result) {
1569             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
1570         }
1571     }
1572 
1573     /**
1574      * Performs reflective checks on given subclass to verify that it doesn&#39;t
1575      * override security-sensitive non-final methods.  Returns TRUE if subclass
1576      * is &quot;safe&quot;, FALSE otherwise.
1577      */
1578     private static Boolean auditSubclass(Class&lt;?&gt; subcl) {
1579         return AccessController.doPrivileged(
1580             new PrivilegedAction&lt;Boolean&gt;() {
1581                 public Boolean run() {
1582                     for (Class&lt;?&gt; cl = subcl;
1583                          cl != ObjectInputStream.class;
1584                          cl = cl.getSuperclass())
1585                     {
1586                         try {
1587                             cl.getDeclaredMethod(
1588                                 &quot;readUnshared&quot;, (Class[]) null);
1589                             return Boolean.FALSE;
1590                         } catch (NoSuchMethodException ex) {
1591                         }
1592                         try {
1593                             cl.getDeclaredMethod(&quot;readFields&quot;, (Class[]) null);
1594                             return Boolean.FALSE;
1595                         } catch (NoSuchMethodException ex) {
1596                         }
1597                     }
1598                     return Boolean.TRUE;
1599                 }
1600             }
1601         );
1602     }
1603 
1604     /**
1605      * Clears internal data structures.
1606      */
1607     private void clear() {
1608         handles.clear();
1609         vlist.clear();
1610     }
1611 
1612     /**
1613      * Underlying readObject implementation.
1614      * @param type a type expected to be deserialized; non-null
1615      * @param unshared true if the object can not be a reference to a shared object, otherwise false
1616      */
1617     private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException {
1618         boolean oldMode = bin.getBlockDataMode();
1619         if (oldMode) {
1620             int remain = bin.currentBlockRemaining();
1621             if (remain &gt; 0) {
1622                 throw new OptionalDataException(remain);
1623             } else if (defaultDataEnd) {
1624                 /*
1625                  * Fix for 4360508: stream is currently at the end of a field
1626                  * value block written via default serialization; since there
1627                  * is no terminating TC_ENDBLOCKDATA tag, simulate
1628                  * end-of-custom-data behavior explicitly.
1629                  */
1630                 throw new OptionalDataException(true);
1631             }
1632             bin.setBlockDataMode(false);
1633         }
1634 
1635         byte tc;
1636         while ((tc = bin.peekByte()) == TC_RESET) {
1637             bin.readByte();
1638             handleReset();
1639         }
1640 
1641         depth++;
1642         totalObjectRefs++;
1643         try {
1644             switch (tc) {
1645                 case TC_NULL:
1646                     return readNull();
1647 
1648                 case TC_REFERENCE:
1649                     // check the type of the existing object
1650                     return type.cast(readHandle(unshared));
1651 
1652                 case TC_CLASS:
1653                     if (type == String.class) {
1654                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1655                     }
1656                     return readClass(unshared);
1657 
1658                 case TC_CLASSDESC:
1659                 case TC_PROXYCLASSDESC:
1660                     if (type == String.class) {
1661                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1662                     }
1663                     return readClassDesc(unshared);
1664 
1665                 case TC_STRING:
1666                 case TC_LONGSTRING:
1667                     return checkResolve(readString(unshared));
1668 
1669                 case TC_ARRAY:
1670                     if (type == String.class) {
1671                         throw new ClassCastException(&quot;Cannot cast an array to java.lang.String&quot;);
1672                     }
1673                     return checkResolve(readArray(unshared));
1674 
1675                 case TC_ENUM:
1676                     if (type == String.class) {
1677                         throw new ClassCastException(&quot;Cannot cast an enum to java.lang.String&quot;);
1678                     }
1679                     return checkResolve(readEnum(unshared));
1680 
1681                 case TC_OBJECT:
1682                     if (type == String.class) {
1683                         throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;);
1684                     }
1685                     return checkResolve(readOrdinaryObject(unshared));
1686 
1687                 case TC_EXCEPTION:
1688                     if (type == String.class) {
1689                         throw new ClassCastException(&quot;Cannot cast an exception to java.lang.String&quot;);
1690                     }
1691                     IOException ex = readFatalException();
1692                     throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
1693 
1694                 case TC_BLOCKDATA:
1695                 case TC_BLOCKDATALONG:
1696                     if (oldMode) {
1697                         bin.setBlockDataMode(true);
1698                         bin.peek();             // force header read
1699                         throw new OptionalDataException(
1700                             bin.currentBlockRemaining());
1701                     } else {
1702                         throw new StreamCorruptedException(
1703                             &quot;unexpected block data&quot;);
1704                     }
1705 
1706                 case TC_ENDBLOCKDATA:
1707                     if (oldMode) {
1708                         throw new OptionalDataException(true);
1709                     } else {
1710                         throw new StreamCorruptedException(
1711                             &quot;unexpected end of block data&quot;);
1712                     }
1713 
1714                 default:
1715                     throw new StreamCorruptedException(
1716                         String.format(&quot;invalid type code: %02X&quot;, tc));
1717             }
1718         } finally {
1719             depth--;
1720             bin.setBlockDataMode(oldMode);
1721         }
1722     }
1723 
1724     /**
1725      * If resolveObject has been enabled and given object does not have an
1726      * exception associated with it, calls resolveObject to determine
1727      * replacement for object, and updates handle table accordingly.  Returns
1728      * replacement object, or echoes provided object if no replacement
1729      * occurred.  Expects that passHandle is set to given object&#39;s handle prior
1730      * to calling this method.
1731      */
1732     private Object checkResolve(Object obj) throws IOException {
1733         if (!enableResolve || handles.lookupException(passHandle) != null) {
1734             return obj;
1735         }
1736         Object rep = resolveObject(obj);
1737         if (rep != obj) {
1738             // The type of the original object has been filtered but resolveObject
1739             // may have replaced it;  filter the replacement&#39;s type
1740             if (rep != null) {
1741                 if (rep.getClass().isArray()) {
1742                     filterCheck(rep.getClass(), Array.getLength(rep));
1743                 } else {
1744                     filterCheck(rep.getClass(), -1);
1745                 }
1746             }
1747             handles.setObject(passHandle, rep);
1748         }
1749         return rep;
1750     }
1751 
1752     /**
1753      * Reads string without allowing it to be replaced in stream.  Called from
1754      * within ObjectStreamClass.read().
1755      */
1756     String readTypeString() throws IOException {
1757         int oldHandle = passHandle;
1758         try {
1759             byte tc = bin.peekByte();
1760             switch (tc) {
1761                 case TC_NULL:
1762                     return (String) readNull();
1763 
1764                 case TC_REFERENCE:
1765                     return (String) readHandle(false);
1766 
1767                 case TC_STRING:
1768                 case TC_LONGSTRING:
1769                     return readString(false);
1770 
1771                 default:
1772                     throw new StreamCorruptedException(
1773                         String.format(&quot;invalid type code: %02X&quot;, tc));
1774             }
1775         } finally {
1776             passHandle = oldHandle;
1777         }
1778     }
1779 
1780     /**
1781      * Reads in null code, sets passHandle to NULL_HANDLE and returns null.
1782      */
1783     private Object readNull() throws IOException {
1784         if (bin.readByte() != TC_NULL) {
1785             throw new InternalError();
1786         }
1787         passHandle = NULL_HANDLE;
1788         return null;
1789     }
1790 
1791     /**
1792      * Reads in object handle, sets passHandle to the read handle, and returns
1793      * object associated with the handle.
1794      */
1795     private Object readHandle(boolean unshared) throws IOException {
1796         if (bin.readByte() != TC_REFERENCE) {
1797             throw new InternalError();
1798         }
1799         passHandle = bin.readInt() - baseWireHandle;
1800         if (passHandle &lt; 0 || passHandle &gt;= handles.size()) {
1801             throw new StreamCorruptedException(
1802                 String.format(&quot;invalid handle value: %08X&quot;, passHandle +
1803                 baseWireHandle));
1804         }
1805         if (unshared) {
1806             // REMIND: what type of exception to throw here?
1807             throw new InvalidObjectException(
1808                 &quot;cannot read back reference as unshared&quot;);
1809         }
1810 
1811         Object obj = handles.lookupObject(passHandle);
1812         if (obj == unsharedMarker) {
1813             // REMIND: what type of exception to throw here?
1814             throw new InvalidObjectException(
1815                 &quot;cannot read back reference to unshared object&quot;);
1816         }
1817         filterCheck(null, -1);       // just a check for number of references, depth, no class
1818         return obj;
1819     }
1820 
1821     /**
1822      * Reads in and returns class object.  Sets passHandle to class object&#39;s
1823      * assigned handle.  Returns null if class is unresolvable (in which case a
1824      * ClassNotFoundException will be associated with the class&#39; handle in the
1825      * handle table).
1826      */
1827     private Class&lt;?&gt; readClass(boolean unshared) throws IOException {
1828         if (bin.readByte() != TC_CLASS) {
1829             throw new InternalError();
1830         }
1831         ObjectStreamClass desc = readClassDesc(false);
1832         Class&lt;?&gt; cl = desc.forClass();
1833         passHandle = handles.assign(unshared ? unsharedMarker : cl);
1834 
1835         ClassNotFoundException resolveEx = desc.getResolveException();
1836         if (resolveEx != null) {
1837             handles.markException(passHandle, resolveEx);
1838         }
1839 
1840         handles.finish(passHandle);
1841         return cl;
1842     }
1843 
1844     /**
1845      * Reads in and returns (possibly null) class descriptor.  Sets passHandle
1846      * to class descriptor&#39;s assigned handle.  If class descriptor cannot be
1847      * resolved to a class in the local VM, a ClassNotFoundException is
1848      * associated with the class descriptor&#39;s handle.
1849      */
1850     private ObjectStreamClass readClassDesc(boolean unshared)
1851         throws IOException
1852     {
1853         byte tc = bin.peekByte();
1854         ObjectStreamClass descriptor;
1855         switch (tc) {
1856             case TC_NULL:
1857                 descriptor = (ObjectStreamClass) readNull();
1858                 break;
1859             case TC_REFERENCE:
1860                 descriptor = (ObjectStreamClass) readHandle(unshared);
1861                 // Should only reference initialized class descriptors
1862                 descriptor.checkInitialized();
1863                 break;
1864             case TC_PROXYCLASSDESC:
1865                 descriptor = readProxyDesc(unshared);
1866                 break;
1867             case TC_CLASSDESC:
1868                 descriptor = readNonProxyDesc(unshared);
1869                 break;
1870             default:
1871                 throw new StreamCorruptedException(
1872                     String.format(&quot;invalid type code: %02X&quot;, tc));
1873         }
1874         return descriptor;
1875     }
1876 
1877     private boolean isCustomSubclass() {
1878         // Return true if this class is a custom subclass of ObjectInputStream
1879         return getClass().getClassLoader()
1880                     != ObjectInputStream.class.getClassLoader();
1881     }
1882 
1883     /**
1884      * Reads in and returns class descriptor for a dynamic proxy class.  Sets
1885      * passHandle to proxy class descriptor&#39;s assigned handle.  If proxy class
1886      * descriptor cannot be resolved to a class in the local VM, a
1887      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1888      */
1889     private ObjectStreamClass readProxyDesc(boolean unshared)
1890         throws IOException
1891     {
1892         if (bin.readByte() != TC_PROXYCLASSDESC) {
1893             throw new InternalError();
1894         }
1895 
1896         ObjectStreamClass desc = new ObjectStreamClass();
1897         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1898         passHandle = NULL_HANDLE;
1899 
1900         int numIfaces = bin.readInt();
1901         if (numIfaces &gt; 65535) {
1902             throw new InvalidObjectException(&quot;interface limit exceeded: &quot;
1903                     + numIfaces);
1904         }
1905         String[] ifaces = new String[numIfaces];
1906         for (int i = 0; i &lt; numIfaces; i++) {
1907             ifaces[i] = bin.readUTF();
1908         }
1909 
1910         Class&lt;?&gt; cl = null;
1911         ClassNotFoundException resolveEx = null;
1912         bin.setBlockDataMode(true);
1913         try {
1914             if ((cl = resolveProxyClass(ifaces)) == null) {
1915                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1916             } else if (!Proxy.isProxyClass(cl)) {
1917                 throw new InvalidClassException(&quot;Not a proxy&quot;);
1918             } else {
1919                 // ReflectUtil.checkProxyPackageAccess makes a test
1920                 // equivalent to isCustomSubclass so there&#39;s no need
1921                 // to condition this call to isCustomSubclass == true here.
1922                 ReflectUtil.checkProxyPackageAccess(
1923                         getClass().getClassLoader(),
1924                         cl.getInterfaces());
1925                 // Filter the interfaces
1926                 for (Class&lt;?&gt; clazz : cl.getInterfaces()) {
1927                     filterCheck(clazz, -1);
1928                 }
1929             }
1930         } catch (ClassNotFoundException ex) {
1931             resolveEx = ex;
1932         }
1933 
1934         // Call filterCheck on the class before reading anything else
1935         filterCheck(cl, -1);
1936 
1937         skipCustomData();
1938 
1939         try {
1940             totalObjectRefs++;
1941             depth++;
1942             desc.initProxy(cl, resolveEx, readClassDesc(false));
1943         } finally {
1944             depth--;
1945         }
1946 
1947         handles.finish(descHandle);
1948         passHandle = descHandle;
1949         return desc;
1950     }
1951 
1952     /**
1953      * Reads in and returns class descriptor for a class that is not a dynamic
1954      * proxy class.  Sets passHandle to class descriptor&#39;s assigned handle.  If
1955      * class descriptor cannot be resolved to a class in the local VM, a
1956      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1957      */
1958     private ObjectStreamClass readNonProxyDesc(boolean unshared)
1959         throws IOException
1960     {
1961         if (bin.readByte() != TC_CLASSDESC) {
1962             throw new InternalError();
1963         }
1964 
1965         ObjectStreamClass desc = new ObjectStreamClass();
1966         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1967         passHandle = NULL_HANDLE;
1968 
1969         ObjectStreamClass readDesc;
1970         try {
1971             readDesc = readClassDescriptor();
1972         } catch (ClassNotFoundException ex) {
1973             throw (IOException) new InvalidClassException(
1974                 &quot;failed to read class descriptor&quot;).initCause(ex);
1975         }
1976 
1977         Class&lt;?&gt; cl = null;
1978         ClassNotFoundException resolveEx = null;
1979         bin.setBlockDataMode(true);
1980         final boolean checksRequired = isCustomSubclass();
1981         try {
1982             if ((cl = resolveClass(readDesc)) == null) {
1983                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1984             } else if (checksRequired) {
1985                 ReflectUtil.checkPackageAccess(cl);
1986             }
1987         } catch (ClassNotFoundException ex) {
1988             resolveEx = ex;
1989         }
1990 
1991         // Call filterCheck on the class before reading anything else
1992         filterCheck(cl, -1);
1993 
1994         skipCustomData();
1995 
1996         try {
1997             totalObjectRefs++;
1998             depth++;
1999             desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));
2000         } finally {
2001             depth--;
2002         }
2003 
2004         handles.finish(descHandle);
2005         passHandle = descHandle;
2006 
2007         return desc;
2008     }
2009 
2010     /**
2011      * Reads in and returns new string.  Sets passHandle to new string&#39;s
2012      * assigned handle.
2013      */
2014     private String readString(boolean unshared) throws IOException {
2015         String str;
2016         byte tc = bin.readByte();
2017         switch (tc) {
2018             case TC_STRING:
2019                 str = bin.readUTF();
2020                 break;
2021 
2022             case TC_LONGSTRING:
2023                 str = bin.readLongUTF();
2024                 break;
2025 
2026             default:
2027                 throw new StreamCorruptedException(
2028                     String.format(&quot;invalid type code: %02X&quot;, tc));
2029         }
2030         passHandle = handles.assign(unshared ? unsharedMarker : str);
2031         handles.finish(passHandle);
2032         return str;
2033     }
2034 
2035     /**
2036      * Reads in and returns array object, or null if array class is
2037      * unresolvable.  Sets passHandle to array&#39;s assigned handle.
2038      */
2039     private Object readArray(boolean unshared) throws IOException {
2040         if (bin.readByte() != TC_ARRAY) {
2041             throw new InternalError();
2042         }
2043 
2044         ObjectStreamClass desc = readClassDesc(false);
2045         int len = bin.readInt();
2046 
2047         filterCheck(desc.forClass(), len);
2048 
2049         Object array = null;
2050         Class&lt;?&gt; cl, ccl = null;
2051         if ((cl = desc.forClass()) != null) {
2052             ccl = cl.getComponentType();
2053             array = Array.newInstance(ccl, len);
2054         }
2055 
2056         int arrayHandle = handles.assign(unshared ? unsharedMarker : array);
2057         ClassNotFoundException resolveEx = desc.getResolveException();
2058         if (resolveEx != null) {
2059             handles.markException(arrayHandle, resolveEx);
2060         }
2061 
2062         if (ccl == null) {
2063             for (int i = 0; i &lt; len; i++) {
2064                 readObject0(Object.class, false);
2065             }
2066         } else if (ccl.isPrimitive()) {
2067             if (ccl == Integer.TYPE) {
2068                 bin.readInts((int[]) array, 0, len);
2069             } else if (ccl == Byte.TYPE) {
2070                 bin.readFully((byte[]) array, 0, len, true);
2071             } else if (ccl == Long.TYPE) {
2072                 bin.readLongs((long[]) array, 0, len);
2073             } else if (ccl == Float.TYPE) {
2074                 bin.readFloats((float[]) array, 0, len);
2075             } else if (ccl == Double.TYPE) {
2076                 bin.readDoubles((double[]) array, 0, len);
2077             } else if (ccl == Short.TYPE) {
2078                 bin.readShorts((short[]) array, 0, len);
2079             } else if (ccl == Character.TYPE) {
2080                 bin.readChars((char[]) array, 0, len);
2081             } else if (ccl == Boolean.TYPE) {
2082                 bin.readBooleans((boolean[]) array, 0, len);
2083             } else {
2084                 throw new InternalError();
2085             }
2086         } else {
2087             Object[] oa = (Object[]) array;
2088             for (int i = 0; i &lt; len; i++) {
2089                 oa[i] = readObject0(Object.class, false);
2090                 handles.markDependency(arrayHandle, passHandle);
2091             }
2092         }
2093 
2094         handles.finish(arrayHandle);
2095         passHandle = arrayHandle;
2096         return array;
2097     }
2098 
2099     /**
2100      * Reads in and returns enum constant, or null if enum type is
2101      * unresolvable.  Sets passHandle to enum constant&#39;s assigned handle.
2102      */
2103     private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
2104         if (bin.readByte() != TC_ENUM) {
2105             throw new InternalError();
2106         }
2107 
2108         ObjectStreamClass desc = readClassDesc(false);
2109         if (!desc.isEnum()) {
2110             throw new InvalidClassException(&quot;non-enum class: &quot; + desc);
2111         }
2112 
2113         int enumHandle = handles.assign(unshared ? unsharedMarker : null);
2114         ClassNotFoundException resolveEx = desc.getResolveException();
2115         if (resolveEx != null) {
2116             handles.markException(enumHandle, resolveEx);
2117         }
2118 
2119         String name = readString(false);
2120         Enum&lt;?&gt; result = null;
2121         Class&lt;?&gt; cl = desc.forClass();
2122         if (cl != null) {
2123             try {
2124                 @SuppressWarnings(&quot;unchecked&quot;)
2125                 Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);
2126                 result = en;
2127             } catch (IllegalArgumentException ex) {
2128                 throw (IOException) new InvalidObjectException(
2129                     &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
2130                     cl).initCause(ex);
2131             }
2132             if (!unshared) {
2133                 handles.setObject(enumHandle, result);
2134             }
2135         }
2136 
2137         handles.finish(enumHandle);
2138         passHandle = enumHandle;
2139         return result;
2140     }
2141 
<a name="1" id="anc1"></a><span class="line-removed">2142     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-removed">2143     private static boolean isRecord(Class&lt;?&gt; cls) {</span>
<span class="line-removed">2144         return cls.isRecord();</span>
<span class="line-removed">2145     }</span>
<span class="line-removed">2146 </span>
2147     /**
2148      * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
2149      * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
2150      * class is unresolvable (in which case a ClassNotFoundException will be
2151      * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
2152      * handle.
2153      */
2154     private Object readOrdinaryObject(boolean unshared)
2155         throws IOException
2156     {
2157         if (bin.readByte() != TC_OBJECT) {
2158             throw new InternalError();
2159         }
2160 
2161         ObjectStreamClass desc = readClassDesc(false);
2162         desc.checkDeserialize();
2163 
2164         Class&lt;?&gt; cl = desc.forClass();
2165         if (cl == String.class || cl == Class.class
2166                 || cl == ObjectStreamClass.class) {
2167             throw new InvalidClassException(&quot;invalid class descriptor&quot;);
2168         }
2169 
2170         Object obj;
2171         try {
2172             obj = desc.isInstantiable() ? desc.newInstance() : null;
2173         } catch (Exception ex) {
2174             throw (IOException) new InvalidClassException(
2175                 desc.forClass().getName(),
2176                 &quot;unable to create instance&quot;).initCause(ex);
2177         }
2178 
2179         passHandle = handles.assign(unshared ? unsharedMarker : obj);
2180         ClassNotFoundException resolveEx = desc.getResolveException();
2181         if (resolveEx != null) {
2182             handles.markException(passHandle, resolveEx);
2183         }
2184 
<a name="2" id="anc2"></a><span class="line-modified">2185         final boolean isRecord = cl != null &amp;&amp; isRecord(cl) ? true : false;</span>
2186         if (isRecord) {
2187             assert obj == null;
2188             obj = readRecord(desc);
2189             if (!unshared)
2190                 handles.setObject(passHandle, obj);
2191         } else if (desc.isExternalizable()) {
2192             readExternalData((Externalizable) obj, desc);
2193         } else {
2194             readSerialData(obj, desc);
2195         }
2196 
2197         handles.finish(passHandle);
2198 
2199         if (obj != null &amp;&amp;
2200             handles.lookupException(passHandle) == null &amp;&amp;
2201             desc.hasReadResolveMethod())
2202         {
2203             Object rep = desc.invokeReadResolve(obj);
2204             if (unshared &amp;&amp; rep.getClass().isArray()) {
2205                 rep = cloneArray(rep);
2206             }
2207             if (rep != obj) {
2208                 // Filter the replacement object
2209                 if (rep != null) {
2210                     if (rep.getClass().isArray()) {
2211                         filterCheck(rep.getClass(), Array.getLength(rep));
2212                     } else {
2213                         filterCheck(rep.getClass(), -1);
2214                     }
2215                 }
2216                 handles.setObject(passHandle, obj = rep);
2217             }
2218         }
2219 
2220         return obj;
2221     }
2222 
2223     /**
2224      * If obj is non-null, reads externalizable data by invoking readExternal()
2225      * method of obj; otherwise, attempts to skip over externalizable data.
2226      * Expects that passHandle is set to obj&#39;s handle before this method is
2227      * called.
2228      */
2229     private void readExternalData(Externalizable obj, ObjectStreamClass desc)
2230         throws IOException
2231     {
2232         SerialCallbackContext oldContext = curContext;
2233         if (oldContext != null)
2234             oldContext.check();
2235         curContext = null;
2236         try {
2237             boolean blocked = desc.hasBlockExternalData();
2238             if (blocked) {
2239                 bin.setBlockDataMode(true);
2240             }
2241             if (obj != null) {
2242                 try {
2243                     obj.readExternal(this);
2244                 } catch (ClassNotFoundException ex) {
2245                     /*
2246                      * In most cases, the handle table has already propagated
2247                      * a CNFException to passHandle at this point; this mark
2248                      * call is included to address cases where the readExternal
2249                      * method has cons&#39;ed and thrown a new CNFException of its
2250                      * own.
2251                      */
2252                      handles.markException(passHandle, ex);
2253                 }
2254             }
2255             if (blocked) {
2256                 skipCustomData();
2257             }
2258         } finally {
2259             if (oldContext != null)
2260                 oldContext.check();
2261             curContext = oldContext;
2262         }
2263         /*
2264          * At this point, if the externalizable data was not written in
2265          * block-data form and either the externalizable class doesn&#39;t exist
2266          * locally (i.e., obj == null) or readExternal() just threw a
2267          * CNFException, then the stream is probably in an inconsistent state,
2268          * since some (or all) of the externalizable data may not have been
2269          * consumed.  Since there&#39;s no &quot;correct&quot; action to take in this case,
2270          * we mimic the behavior of past serialization implementations and
2271          * blindly hope that the stream is in sync; if it isn&#39;t and additional
2272          * externalizable data remains in the stream, a subsequent read will
2273          * most likely throw a StreamCorruptedException.
2274          */
2275     }
2276 
2277     /** Reads a record. */
2278     private Object readRecord(ObjectStreamClass desc) throws IOException {
2279         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2280         if (slots.length != 1) {
2281             // skip any superclass stream field values
2282             for (int i = 0; i &lt; slots.length-1; i++) {
2283                 ObjectStreamClass slotDesc = slots[i].desc;
2284                 if (slots[i].hasData) {
2285                     defaultReadFields(null, slotDesc);
2286                 }
2287             }
2288         }
2289 
2290         FieldValues fieldValues = defaultReadFields(null, desc);
2291 
<a name="3" id="anc3"></a><span class="line-modified">2292         // retrieve the canonical constructor</span>
<span class="line-modified">2293         MethodHandle ctrMH = desc.getRecordConstructor();</span>
<span class="line-modified">2294 </span>
<span class="line-modified">2295         // bind the stream field values</span>
<span class="line-modified">2296         ctrMH = RecordSupport.bindCtrValues(ctrMH, desc, fieldValues);</span>
2297 
2298         try {
<a name="4" id="anc4"></a><span class="line-modified">2299             return ctrMH.invoke();</span>
2300         } catch (Exception e) {
2301             InvalidObjectException ioe = new InvalidObjectException(e.getMessage());
2302             ioe.initCause(e);
2303             throw ioe;
2304         } catch (Error e) {
2305             throw e;
2306         } catch (Throwable t) {
2307             ObjectStreamException ose = new InvalidObjectException(
2308                     &quot;ReflectiveOperationException during deserialization&quot;);
2309             ose.initCause(t);
2310             throw ose;
2311         }
2312     }
2313 
2314     /**
2315      * Reads (or attempts to skip, if obj is null or is tagged with a
2316      * ClassNotFoundException) instance data for each serializable class of
2317      * object in stream, from superclass to subclass.  Expects that passHandle
2318      * is set to obj&#39;s handle before this method is called.
2319      */
2320     private void readSerialData(Object obj, ObjectStreamClass desc)
2321         throws IOException
2322     {
2323         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2324         // Best effort Failure Atomicity; slotValues will be non-null if field
2325         // values can be set after reading all field data in the hierarchy.
2326         // Field values can only be set after reading all data if there are no
2327         // user observable methods in the hierarchy, readObject(NoData). The
2328         // top most Serializable class in the hierarchy can be skipped.
2329         FieldValues[] slotValues = null;
2330 
2331         boolean hasSpecialReadMethod = false;
2332         for (int i = 1; i &lt; slots.length; i++) {
2333             ObjectStreamClass slotDesc = slots[i].desc;
2334             if (slotDesc.hasReadObjectMethod()
2335                   || slotDesc.hasReadObjectNoDataMethod()) {
2336                 hasSpecialReadMethod = true;
2337                 break;
2338             }
2339         }
2340         // No special read methods, can store values and defer setting.
2341         if (!hasSpecialReadMethod)
2342             slotValues = new FieldValues[slots.length];
2343 
2344         for (int i = 0; i &lt; slots.length; i++) {
2345             ObjectStreamClass slotDesc = slots[i].desc;
2346 
2347             if (slots[i].hasData) {
2348                 if (obj == null || handles.lookupException(passHandle) != null) {
2349                     defaultReadFields(null, slotDesc); // skip field values
2350                 } else if (slotDesc.hasReadObjectMethod()) {
2351                     ThreadDeath t = null;
2352                     boolean reset = false;
2353                     SerialCallbackContext oldContext = curContext;
2354                     if (oldContext != null)
2355                         oldContext.check();
2356                     try {
2357                         curContext = new SerialCallbackContext(obj, slotDesc);
2358 
2359                         bin.setBlockDataMode(true);
2360                         slotDesc.invokeReadObject(obj, this);
2361                     } catch (ClassNotFoundException ex) {
2362                         /*
2363                          * In most cases, the handle table has already
2364                          * propagated a CNFException to passHandle at this
2365                          * point; this mark call is included to address cases
2366                          * where the custom readObject method has cons&#39;ed and
2367                          * thrown a new CNFException of its own.
2368                          */
2369                         handles.markException(passHandle, ex);
2370                     } finally {
2371                         do {
2372                             try {
2373                                 curContext.setUsed();
2374                                 if (oldContext!= null)
2375                                     oldContext.check();
2376                                 curContext = oldContext;
2377                                 reset = true;
2378                             } catch (ThreadDeath x) {
2379                                 t = x;  // defer until reset is true
2380                             }
2381                         } while (!reset);
2382                         if (t != null)
2383                             throw t;
2384                     }
2385 
2386                     /*
2387                      * defaultDataEnd may have been set indirectly by custom
2388                      * readObject() method when calling defaultReadObject() or
2389                      * readFields(); clear it to restore normal read behavior.
2390                      */
2391                     defaultDataEnd = false;
2392                 } else {
2393                     FieldValues vals = defaultReadFields(obj, slotDesc);
2394                     if (slotValues != null) {
2395                         slotValues[i] = vals;
2396                     } else if (obj != null) {
2397                         defaultCheckFieldValues(obj, slotDesc, vals);
2398                         defaultSetFieldValues(obj, slotDesc, vals);
2399                     }
2400                 }
2401 
2402                 if (slotDesc.hasWriteObjectData()) {
2403                     skipCustomData();
2404                 } else {
2405                     bin.setBlockDataMode(false);
2406                 }
2407             } else {
2408                 if (obj != null &amp;&amp;
2409                     slotDesc.hasReadObjectNoDataMethod() &amp;&amp;
2410                     handles.lookupException(passHandle) == null)
2411                 {
2412                     slotDesc.invokeReadObjectNoData(obj);
2413                 }
2414             }
2415         }
2416 
2417         if (obj != null &amp;&amp; slotValues != null) {
2418             // Check that the non-primitive types are assignable for all slots
2419             // before assigning.
2420             for (int i = 0; i &lt; slots.length; i++) {
2421                 if (slotValues[i] != null)
2422                     defaultCheckFieldValues(obj, slots[i].desc, slotValues[i]);
2423             }
2424             for (int i = 0; i &lt; slots.length; i++) {
2425                 if (slotValues[i] != null)
2426                     defaultSetFieldValues(obj, slots[i].desc, slotValues[i]);
2427             }
2428         }
2429     }
2430 
2431     /**
2432      * Skips over all block data and objects until TC_ENDBLOCKDATA is
2433      * encountered.
2434      */
2435     private void skipCustomData() throws IOException {
2436         int oldHandle = passHandle;
2437         for (;;) {
2438             if (bin.getBlockDataMode()) {
2439                 bin.skipBlockData();
2440                 bin.setBlockDataMode(false);
2441             }
2442             switch (bin.peekByte()) {
2443                 case TC_BLOCKDATA:
2444                 case TC_BLOCKDATALONG:
2445                     bin.setBlockDataMode(true);
2446                     break;
2447 
2448                 case TC_ENDBLOCKDATA:
2449                     bin.readByte();
2450                     passHandle = oldHandle;
2451                     return;
2452 
2453                 default:
2454                     readObject0(Object.class, false);
2455                     break;
2456             }
2457         }
2458     }
2459 
2460     /*package-private*/ class FieldValues {
2461         final byte[] primValues;
2462         final Object[] objValues;
2463 
2464         FieldValues(byte[] primValues, Object[] objValues) {
2465             this.primValues = primValues;
2466             this.objValues = objValues;
2467         }
2468     }
2469 
2470     /**
2471      * Reads in values of serializable fields declared by given class
2472      * descriptor. Expects that passHandle is set to obj&#39;s handle before this
2473      * method is called.
2474      */
2475     private FieldValues defaultReadFields(Object obj, ObjectStreamClass desc)
2476         throws IOException
2477     {
2478         Class&lt;?&gt; cl = desc.forClass();
2479         if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
2480             throw new ClassCastException();
2481         }
2482 
2483         byte[] primVals = null;
2484         int primDataSize = desc.getPrimDataSize();
2485         if (primDataSize &gt; 0) {
2486             primVals = new byte[primDataSize];
2487             bin.readFully(primVals, 0, primDataSize, false);
2488         }
2489 
2490         Object[] objVals = null;
2491         int numObjFields = desc.getNumObjFields();
2492         if (numObjFields &gt; 0) {
2493             int objHandle = passHandle;
2494             ObjectStreamField[] fields = desc.getFields(false);
2495             objVals = new Object[numObjFields];
2496             int numPrimFields = fields.length - objVals.length;
2497             for (int i = 0; i &lt; objVals.length; i++) {
2498                 ObjectStreamField f = fields[numPrimFields + i];
2499                 objVals[i] = readObject0(Object.class, f.isUnshared());
2500                 if (f.getField() != null) {
2501                     handles.markDependency(objHandle, passHandle);
2502                 }
2503             }
2504             passHandle = objHandle;
2505         }
2506 
2507         return new FieldValues(primVals, objVals);
2508     }
2509 
2510     /** Throws ClassCastException if any value is not assignable. */
2511     private void defaultCheckFieldValues(Object obj, ObjectStreamClass desc,
2512                                          FieldValues values) {
2513         Object[] objectValues = values.objValues;
2514         if (objectValues != null)
2515             desc.checkObjFieldValueTypes(obj, objectValues);
2516     }
2517 
2518     /** Sets field values in obj. */
2519     private void defaultSetFieldValues(Object obj, ObjectStreamClass desc,
2520                                        FieldValues values) {
2521         byte[] primValues = values.primValues;
2522         Object[] objectValues = values.objValues;
2523 
2524         if (primValues != null)
2525             desc.setPrimFieldValues(obj, primValues);
2526         if (objectValues != null)
2527             desc.setObjFieldValues(obj, objectValues);
2528     }
2529 
2530     /**
2531      * Reads in and returns IOException that caused serialization to abort.
2532      * All stream state is discarded prior to reading in fatal exception.  Sets
2533      * passHandle to fatal exception&#39;s handle.
2534      */
2535     private IOException readFatalException() throws IOException {
2536         if (bin.readByte() != TC_EXCEPTION) {
2537             throw new InternalError();
2538         }
2539         clear();
2540         return (IOException) readObject0(Object.class, false);
2541     }
2542 
2543     /**
2544      * If recursion depth is 0, clears internal data structures; otherwise,
2545      * throws a StreamCorruptedException.  This method is called when a
2546      * TC_RESET typecode is encountered.
2547      */
2548     private void handleReset() throws StreamCorruptedException {
2549         if (depth &gt; 0) {
2550             throw new StreamCorruptedException(
2551                 &quot;unexpected reset; recursion depth: &quot; + depth);
2552         }
2553         clear();
2554     }
2555 
2556     /**
2557      * Returns the first non-null and non-platform class loader (not counting
2558      * class loaders of generated reflection implementation classes) up the
2559      * execution stack, or the platform class loader if only code from the
2560      * bootstrap and platform class loader is on the stack.
2561      */
2562     private static ClassLoader latestUserDefinedLoader() {
2563         return jdk.internal.misc.VM.latestUserDefinedLoader();
2564     }
2565 
2566     /**
2567      * Default GetField implementation.
2568      */
2569     private class GetFieldImpl extends GetField {
2570 
2571         /** class descriptor describing serializable fields */
2572         private final ObjectStreamClass desc;
2573         /** primitive field values */
2574         private final byte[] primVals;
2575         /** object field values */
2576         private final Object[] objVals;
2577         /** object field value handles */
2578         private final int[] objHandles;
2579 
2580         /**
2581          * Creates GetFieldImpl object for reading fields defined in given
2582          * class descriptor.
2583          */
2584         GetFieldImpl(ObjectStreamClass desc) {
2585             this.desc = desc;
2586             primVals = new byte[desc.getPrimDataSize()];
2587             objVals = new Object[desc.getNumObjFields()];
2588             objHandles = new int[objVals.length];
2589         }
2590 
2591         public ObjectStreamClass getObjectStreamClass() {
2592             return desc;
2593         }
2594 
2595         public boolean defaulted(String name) throws IOException {
2596             return (getFieldOffset(name, null) &lt; 0);
2597         }
2598 
2599         public boolean get(String name, boolean val) throws IOException {
2600             int off = getFieldOffset(name, Boolean.TYPE);
2601             return (off &gt;= 0) ? Bits.getBoolean(primVals, off) : val;
2602         }
2603 
2604         public byte get(String name, byte val) throws IOException {
2605             int off = getFieldOffset(name, Byte.TYPE);
2606             return (off &gt;= 0) ? primVals[off] : val;
2607         }
2608 
2609         public char get(String name, char val) throws IOException {
2610             int off = getFieldOffset(name, Character.TYPE);
2611             return (off &gt;= 0) ? Bits.getChar(primVals, off) : val;
2612         }
2613 
2614         public short get(String name, short val) throws IOException {
2615             int off = getFieldOffset(name, Short.TYPE);
2616             return (off &gt;= 0) ? Bits.getShort(primVals, off) : val;
2617         }
2618 
2619         public int get(String name, int val) throws IOException {
2620             int off = getFieldOffset(name, Integer.TYPE);
2621             return (off &gt;= 0) ? Bits.getInt(primVals, off) : val;
2622         }
2623 
2624         public float get(String name, float val) throws IOException {
2625             int off = getFieldOffset(name, Float.TYPE);
2626             return (off &gt;= 0) ? Bits.getFloat(primVals, off) : val;
2627         }
2628 
2629         public long get(String name, long val) throws IOException {
2630             int off = getFieldOffset(name, Long.TYPE);
2631             return (off &gt;= 0) ? Bits.getLong(primVals, off) : val;
2632         }
2633 
2634         public double get(String name, double val) throws IOException {
2635             int off = getFieldOffset(name, Double.TYPE);
2636             return (off &gt;= 0) ? Bits.getDouble(primVals, off) : val;
2637         }
2638 
2639         public Object get(String name, Object val) throws IOException {
2640             int off = getFieldOffset(name, Object.class);
2641             if (off &gt;= 0) {
2642                 int objHandle = objHandles[off];
2643                 handles.markDependency(passHandle, objHandle);
2644                 return (handles.lookupException(objHandle) == null) ?
2645                     objVals[off] : null;
2646             } else {
2647                 return val;
2648             }
2649         }
2650 
2651         /**
2652          * Reads primitive and object field values from stream.
2653          */
2654         void readFields() throws IOException {
2655             bin.readFully(primVals, 0, primVals.length, false);
2656 
2657             int oldHandle = passHandle;
2658             ObjectStreamField[] fields = desc.getFields(false);
2659             int numPrimFields = fields.length - objVals.length;
2660             for (int i = 0; i &lt; objVals.length; i++) {
2661                 objVals[i] =
2662                     readObject0(Object.class, fields[numPrimFields + i].isUnshared());
2663                 objHandles[i] = passHandle;
2664             }
2665             passHandle = oldHandle;
2666         }
2667 
2668         /**
2669          * Returns offset of field with given name and type.  A specified type
2670          * of null matches all types, Object.class matches all non-primitive
2671          * types, and any other non-null type matches assignable types only.
2672          * If no matching field is found in the (incoming) class
2673          * descriptor but a matching field is present in the associated local
2674          * class descriptor, returns -1.  Throws IllegalArgumentException if
2675          * neither incoming nor local class descriptor contains a match.
2676          */
2677         private int getFieldOffset(String name, Class&lt;?&gt; type) {
2678             ObjectStreamField field = desc.getField(name, type);
2679             if (field != null) {
2680                 return field.getOffset();
2681             } else if (desc.getLocalDesc().getField(name, type) != null) {
2682                 return -1;
2683             } else {
2684                 throw new IllegalArgumentException(&quot;no such field &quot; + name +
2685                                                    &quot; with type &quot; + type);
2686             }
2687         }
2688     }
2689 
2690     /**
2691      * Prioritized list of callbacks to be performed once object graph has been
2692      * completely deserialized.
2693      */
2694     private static class ValidationList {
2695 
2696         private static class Callback {
2697             final ObjectInputValidation obj;
2698             final int priority;
2699             Callback next;
2700             final AccessControlContext acc;
2701 
2702             Callback(ObjectInputValidation obj, int priority, Callback next,
2703                 AccessControlContext acc)
2704             {
2705                 this.obj = obj;
2706                 this.priority = priority;
2707                 this.next = next;
2708                 this.acc = acc;
2709             }
2710         }
2711 
2712         /** linked list of callbacks */
2713         private Callback list;
2714 
2715         /**
2716          * Creates new (empty) ValidationList.
2717          */
2718         ValidationList() {
2719         }
2720 
2721         /**
2722          * Registers callback.  Throws InvalidObjectException if callback
2723          * object is null.
2724          */
2725         void register(ObjectInputValidation obj, int priority)
2726             throws InvalidObjectException
2727         {
2728             if (obj == null) {
2729                 throw new InvalidObjectException(&quot;null callback&quot;);
2730             }
2731 
2732             Callback prev = null, cur = list;
2733             while (cur != null &amp;&amp; priority &lt; cur.priority) {
2734                 prev = cur;
2735                 cur = cur.next;
2736             }
2737             AccessControlContext acc = AccessController.getContext();
2738             if (prev != null) {
2739                 prev.next = new Callback(obj, priority, cur, acc);
2740             } else {
2741                 list = new Callback(obj, priority, list, acc);
2742             }
2743         }
2744 
2745         /**
2746          * Invokes all registered callbacks and clears the callback list.
2747          * Callbacks with higher priorities are called first; those with equal
2748          * priorities may be called in any order.  If any of the callbacks
2749          * throws an InvalidObjectException, the callback process is terminated
2750          * and the exception propagated upwards.
2751          */
2752         void doCallbacks() throws InvalidObjectException {
2753             try {
2754                 while (list != null) {
2755                     AccessController.doPrivileged(
2756                         new PrivilegedExceptionAction&lt;Void&gt;()
2757                     {
2758                         public Void run() throws InvalidObjectException {
2759                             list.obj.validateObject();
2760                             return null;
2761                         }
2762                     }, list.acc);
2763                     list = list.next;
2764                 }
2765             } catch (PrivilegedActionException ex) {
2766                 list = null;
2767                 throw (InvalidObjectException) ex.getException();
2768             }
2769         }
2770 
2771         /**
2772          * Resets the callback list to its initial (empty) state.
2773          */
2774         public void clear() {
2775             list = null;
2776         }
2777     }
2778 
2779     /**
2780      * Hold a snapshot of values to be passed to an ObjectInputFilter.
2781      */
2782     static class FilterValues implements ObjectInputFilter.FilterInfo {
2783         final Class&lt;?&gt; clazz;
2784         final long arrayLength;
2785         final long totalObjectRefs;
2786         final long depth;
2787         final long streamBytes;
2788 
2789         public FilterValues(Class&lt;?&gt; clazz, long arrayLength, long totalObjectRefs,
2790                             long depth, long streamBytes) {
2791             this.clazz = clazz;
2792             this.arrayLength = arrayLength;
2793             this.totalObjectRefs = totalObjectRefs;
2794             this.depth = depth;
2795             this.streamBytes = streamBytes;
2796         }
2797 
2798         @Override
2799         public Class&lt;?&gt; serialClass() {
2800             return clazz;
2801         }
2802 
2803         @Override
2804         public long arrayLength() {
2805             return arrayLength;
2806         }
2807 
2808         @Override
2809         public long references() {
2810             return totalObjectRefs;
2811         }
2812 
2813         @Override
2814         public long depth() {
2815             return depth;
2816         }
2817 
2818         @Override
2819         public long streamBytes() {
2820             return streamBytes;
2821         }
2822     }
2823 
2824     /**
2825      * Input stream supporting single-byte peek operations.
2826      */
2827     private static class PeekInputStream extends InputStream {
2828 
2829         /** underlying stream */
2830         private final InputStream in;
2831         /** peeked byte */
2832         private int peekb = -1;
2833         /** total bytes read from the stream */
2834         private long totalBytesRead = 0;
2835 
2836         /**
2837          * Creates new PeekInputStream on top of given underlying stream.
2838          */
2839         PeekInputStream(InputStream in) {
2840             this.in = in;
2841         }
2842 
2843         /**
2844          * Peeks at next byte value in stream.  Similar to read(), except
2845          * that it does not consume the read value.
2846          */
2847         int peek() throws IOException {
2848             if (peekb &gt;= 0) {
2849                 return peekb;
2850             }
2851             peekb = in.read();
2852             totalBytesRead += peekb &gt;= 0 ? 1 : 0;
2853             return peekb;
2854         }
2855 
2856         public int read() throws IOException {
2857             if (peekb &gt;= 0) {
2858                 int v = peekb;
2859                 peekb = -1;
2860                 return v;
2861             } else {
2862                 int nbytes = in.read();
2863                 totalBytesRead += nbytes &gt;= 0 ? 1 : 0;
2864                 return nbytes;
2865             }
2866         }
2867 
2868         public int read(byte[] b, int off, int len) throws IOException {
2869             int nbytes;
2870             if (len == 0) {
2871                 return 0;
2872             } else if (peekb &lt; 0) {
2873                 nbytes = in.read(b, off, len);
2874                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2875                 return nbytes;
2876             } else {
2877                 b[off++] = (byte) peekb;
2878                 len--;
2879                 peekb = -1;
2880                 nbytes = in.read(b, off, len);
2881                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2882                 return (nbytes &gt;= 0) ? (nbytes + 1) : 1;
2883             }
2884         }
2885 
2886         void readFully(byte[] b, int off, int len) throws IOException {
2887             int n = 0;
2888             while (n &lt; len) {
2889                 int count = read(b, off + n, len - n);
2890                 if (count &lt; 0) {
2891                     throw new EOFException();
2892                 }
2893                 n += count;
2894             }
2895         }
2896 
2897         public long skip(long n) throws IOException {
2898             if (n &lt;= 0) {
2899                 return 0;
2900             }
2901             int skipped = 0;
2902             if (peekb &gt;= 0) {
2903                 peekb = -1;
2904                 skipped++;
2905                 n--;
2906             }
2907             n = skipped + in.skip(n);
2908             totalBytesRead += n;
2909             return n;
2910         }
2911 
2912         public int available() throws IOException {
2913             return in.available() + ((peekb &gt;= 0) ? 1 : 0);
2914         }
2915 
2916         public void close() throws IOException {
2917             in.close();
2918         }
2919 
2920         public long getBytesRead() {
2921             return totalBytesRead;
2922         }
2923     }
2924 
2925     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
2926 
2927     /**
2928      * Performs a &quot;freeze&quot; action, required to adhere to final field semantics.
2929      *
2930      * &lt;p&gt; This method can be called unconditionally before returning the graph,
2931      * from the topmost readObject call, since it is expected that the
2932      * additional cost of the freeze action is negligible compared to
2933      * reconstituting even the most simple graph.
2934      *
2935      * &lt;p&gt; Nested calls to readObject do not issue freeze actions because the
2936      * sub-graph returned from a nested call is not guaranteed to be fully
2937      * initialized yet (possible cycles).
2938      */
2939     private void freeze() {
2940         // Issue a StoreStore|StoreLoad fence, which is at least sufficient
2941         // to provide final-freeze semantics.
2942         UNSAFE.storeFence();
2943     }
2944 
2945     /**
2946      * Input stream with two modes: in default mode, inputs data written in the
2947      * same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
2948      * bracketed by block data markers (see object serialization specification
2949      * for details).  Buffering depends on block data mode: when in default
2950      * mode, no data is buffered in advance; when in block data mode, all data
2951      * for the current data block is read in at once (and buffered).
2952      */
2953     private class BlockDataInputStream
2954         extends InputStream implements DataInput
2955     {
2956         /** maximum data block length */
2957         private static final int MAX_BLOCK_SIZE = 1024;
2958         /** maximum data block header length */
2959         private static final int MAX_HEADER_SIZE = 5;
2960         /** (tunable) length of char buffer (for reading strings) */
2961         private static final int CHAR_BUF_SIZE = 256;
2962         /** readBlockHeader() return value indicating header read may block */
2963         private static final int HEADER_BLOCKED = -2;
2964 
2965         /** buffer for reading general/block data */
2966         private final byte[] buf = new byte[MAX_BLOCK_SIZE];
2967         /** buffer for reading block data headers */
2968         private final byte[] hbuf = new byte[MAX_HEADER_SIZE];
2969         /** char buffer for fast string reads */
2970         private final char[] cbuf = new char[CHAR_BUF_SIZE];
2971 
2972         /** block data mode */
2973         private boolean blkmode = false;
2974 
2975         // block data state fields; values meaningful only when blkmode true
2976         /** current offset into buf */
2977         private int pos = 0;
2978         /** end offset of valid data in buf, or -1 if no more block data */
2979         private int end = -1;
2980         /** number of bytes in current block yet to be read from stream */
2981         private int unread = 0;
2982 
2983         /** underlying stream (wrapped in peekable filter stream) */
2984         private final PeekInputStream in;
2985         /** loopback stream (for data reads that span data blocks) */
2986         private final DataInputStream din;
2987 
2988         /**
2989          * Creates new BlockDataInputStream on top of given underlying stream.
2990          * Block data mode is turned off by default.
2991          */
2992         BlockDataInputStream(InputStream in) {
2993             this.in = new PeekInputStream(in);
2994             din = new DataInputStream(this);
2995         }
2996 
2997         /**
2998          * Sets block data mode to the given mode (true == on, false == off)
2999          * and returns the previous mode value.  If the new mode is the same as
3000          * the old mode, no action is taken.  Throws IllegalStateException if
3001          * block data mode is being switched from on to off while unconsumed
3002          * block data is still present in the stream.
3003          */
3004         boolean setBlockDataMode(boolean newmode) throws IOException {
3005             if (blkmode == newmode) {
3006                 return blkmode;
3007             }
3008             if (newmode) {
3009                 pos = 0;
3010                 end = 0;
3011                 unread = 0;
3012             } else if (pos &lt; end) {
3013                 throw new IllegalStateException(&quot;unread block data&quot;);
3014             }
3015             blkmode = newmode;
3016             return !blkmode;
3017         }
3018 
3019         /**
3020          * Returns true if the stream is currently in block data mode, false
3021          * otherwise.
3022          */
3023         boolean getBlockDataMode() {
3024             return blkmode;
3025         }
3026 
3027         /**
3028          * If in block data mode, skips to the end of the current group of data
3029          * blocks (but does not unset block data mode).  If not in block data
3030          * mode, throws an IllegalStateException.
3031          */
3032         void skipBlockData() throws IOException {
3033             if (!blkmode) {
3034                 throw new IllegalStateException(&quot;not in block data mode&quot;);
3035             }
3036             while (end &gt;= 0) {
3037                 refill();
3038             }
3039         }
3040 
3041         /**
3042          * Attempts to read in the next block data header (if any).  If
3043          * canBlock is false and a full header cannot be read without possibly
3044          * blocking, returns HEADER_BLOCKED, else if the next element in the
3045          * stream is a block data header, returns the block data length
3046          * specified by the header, else returns -1.
3047          */
3048         private int readBlockHeader(boolean canBlock) throws IOException {
3049             if (defaultDataEnd) {
3050                 /*
3051                  * Fix for 4360508: stream is currently at the end of a field
3052                  * value block written via default serialization; since there
3053                  * is no terminating TC_ENDBLOCKDATA tag, simulate
3054                  * end-of-custom-data behavior explicitly.
3055                  */
3056                 return -1;
3057             }
3058             try {
3059                 for (;;) {
3060                     int avail = canBlock ? Integer.MAX_VALUE : in.available();
3061                     if (avail == 0) {
3062                         return HEADER_BLOCKED;
3063                     }
3064 
3065                     int tc = in.peek();
3066                     switch (tc) {
3067                         case TC_BLOCKDATA:
3068                             if (avail &lt; 2) {
3069                                 return HEADER_BLOCKED;
3070                             }
3071                             in.readFully(hbuf, 0, 2);
3072                             return hbuf[1] &amp; 0xFF;
3073 
3074                         case TC_BLOCKDATALONG:
3075                             if (avail &lt; 5) {
3076                                 return HEADER_BLOCKED;
3077                             }
3078                             in.readFully(hbuf, 0, 5);
3079                             int len = Bits.getInt(hbuf, 1);
3080                             if (len &lt; 0) {
3081                                 throw new StreamCorruptedException(
3082                                     &quot;illegal block data header length: &quot; +
3083                                     len);
3084                             }
3085                             return len;
3086 
3087                         /*
3088                          * TC_RESETs may occur in between data blocks.
3089                          * Unfortunately, this case must be parsed at a lower
3090                          * level than other typecodes, since primitive data
3091                          * reads may span data blocks separated by a TC_RESET.
3092                          */
3093                         case TC_RESET:
3094                             in.read();
3095                             handleReset();
3096                             break;
3097 
3098                         default:
3099                             if (tc &gt;= 0 &amp;&amp; (tc &lt; TC_BASE || tc &gt; TC_MAX)) {
3100                                 throw new StreamCorruptedException(
3101                                     String.format(&quot;invalid type code: %02X&quot;,
3102                                     tc));
3103                             }
3104                             return -1;
3105                     }
3106                 }
3107             } catch (EOFException ex) {
3108                 throw new StreamCorruptedException(
3109                     &quot;unexpected EOF while reading block data header&quot;);
3110             }
3111         }
3112 
3113         /**
3114          * Refills internal buffer buf with block data.  Any data in buf at the
3115          * time of the call is considered consumed.  Sets the pos, end, and
3116          * unread fields to reflect the new amount of available block data; if
3117          * the next element in the stream is not a data block, sets pos and
3118          * unread to 0 and end to -1.
3119          */
3120         private void refill() throws IOException {
3121             try {
3122                 do {
3123                     pos = 0;
3124                     if (unread &gt; 0) {
3125                         int n =
3126                             in.read(buf, 0, Math.min(unread, MAX_BLOCK_SIZE));
3127                         if (n &gt;= 0) {
3128                             end = n;
3129                             unread -= n;
3130                         } else {
3131                             throw new StreamCorruptedException(
3132                                 &quot;unexpected EOF in middle of data block&quot;);
3133                         }
3134                     } else {
3135                         int n = readBlockHeader(true);
3136                         if (n &gt;= 0) {
3137                             end = 0;
3138                             unread = n;
3139                         } else {
3140                             end = -1;
3141                             unread = 0;
3142                         }
3143                     }
3144                 } while (pos == end);
3145             } catch (IOException ex) {
3146                 pos = 0;
3147                 end = -1;
3148                 unread = 0;
3149                 throw ex;
3150             }
3151         }
3152 
3153         /**
3154          * If in block data mode, returns the number of unconsumed bytes
3155          * remaining in the current data block.  If not in block data mode,
3156          * throws an IllegalStateException.
3157          */
3158         int currentBlockRemaining() {
3159             if (blkmode) {
3160                 return (end &gt;= 0) ? (end - pos) + unread : 0;
3161             } else {
3162                 throw new IllegalStateException();
3163             }
3164         }
3165 
3166         /**
3167          * Peeks at (but does not consume) and returns the next byte value in
3168          * the stream, or -1 if the end of the stream/block data (if in block
3169          * data mode) has been reached.
3170          */
3171         int peek() throws IOException {
3172             if (blkmode) {
3173                 if (pos == end) {
3174                     refill();
3175                 }
3176                 return (end &gt;= 0) ? (buf[pos] &amp; 0xFF) : -1;
3177             } else {
3178                 return in.peek();
3179             }
3180         }
3181 
3182         /**
3183          * Peeks at (but does not consume) and returns the next byte value in
3184          * the stream, or throws EOFException if end of stream/block data has
3185          * been reached.
3186          */
3187         byte peekByte() throws IOException {
3188             int val = peek();
3189             if (val &lt; 0) {
3190                 throw new EOFException();
3191             }
3192             return (byte) val;
3193         }
3194 
3195 
3196         /* ----------------- generic input stream methods ------------------ */
3197         /*
3198          * The following methods are equivalent to their counterparts in
3199          * InputStream, except that they interpret data block boundaries and
3200          * read the requested data from within data blocks when in block data
3201          * mode.
3202          */
3203 
3204         public int read() throws IOException {
3205             if (blkmode) {
3206                 if (pos == end) {
3207                     refill();
3208                 }
3209                 return (end &gt;= 0) ? (buf[pos++] &amp; 0xFF) : -1;
3210             } else {
3211                 return in.read();
3212             }
3213         }
3214 
3215         public int read(byte[] b, int off, int len) throws IOException {
3216             return read(b, off, len, false);
3217         }
3218 
3219         public long skip(long len) throws IOException {
3220             long remain = len;
3221             while (remain &gt; 0) {
3222                 if (blkmode) {
3223                     if (pos == end) {
3224                         refill();
3225                     }
3226                     if (end &lt; 0) {
3227                         break;
3228                     }
3229                     int nread = (int) Math.min(remain, end - pos);
3230                     remain -= nread;
3231                     pos += nread;
3232                 } else {
3233                     int nread = (int) Math.min(remain, MAX_BLOCK_SIZE);
3234                     if ((nread = in.read(buf, 0, nread)) &lt; 0) {
3235                         break;
3236                     }
3237                     remain -= nread;
3238                 }
3239             }
3240             return len - remain;
3241         }
3242 
3243         public int available() throws IOException {
3244             if (blkmode) {
3245                 if ((pos == end) &amp;&amp; (unread == 0)) {
3246                     int n;
3247                     while ((n = readBlockHeader(false)) == 0) ;
3248                     switch (n) {
3249                         case HEADER_BLOCKED:
3250                             break;
3251 
3252                         case -1:
3253                             pos = 0;
3254                             end = -1;
3255                             break;
3256 
3257                         default:
3258                             pos = 0;
3259                             end = 0;
3260                             unread = n;
3261                             break;
3262                     }
3263                 }
3264                 // avoid unnecessary call to in.available() if possible
3265                 int unreadAvail = (unread &gt; 0) ?
3266                     Math.min(in.available(), unread) : 0;
3267                 return (end &gt;= 0) ? (end - pos) + unreadAvail : 0;
3268             } else {
3269                 return in.available();
3270             }
3271         }
3272 
3273         public void close() throws IOException {
3274             if (blkmode) {
3275                 pos = 0;
3276                 end = -1;
3277                 unread = 0;
3278             }
3279             in.close();
3280         }
3281 
3282         /**
3283          * Attempts to read len bytes into byte array b at offset off.  Returns
3284          * the number of bytes read, or -1 if the end of stream/block data has
3285          * been reached.  If copy is true, reads values into an intermediate
3286          * buffer before copying them to b (to avoid exposing a reference to
3287          * b).
3288          */
3289         int read(byte[] b, int off, int len, boolean copy) throws IOException {
3290             if (len == 0) {
3291                 return 0;
3292             } else if (blkmode) {
3293                 if (pos == end) {
3294                     refill();
3295                 }
3296                 if (end &lt; 0) {
3297                     return -1;
3298                 }
3299                 int nread = Math.min(len, end - pos);
3300                 System.arraycopy(buf, pos, b, off, nread);
3301                 pos += nread;
3302                 return nread;
3303             } else if (copy) {
3304                 int nread = in.read(buf, 0, Math.min(len, MAX_BLOCK_SIZE));
3305                 if (nread &gt; 0) {
3306                     System.arraycopy(buf, 0, b, off, nread);
3307                 }
3308                 return nread;
3309             } else {
3310                 return in.read(b, off, len);
3311             }
3312         }
3313 
3314         /* ----------------- primitive data input methods ------------------ */
3315         /*
3316          * The following methods are equivalent to their counterparts in
3317          * DataInputStream, except that they interpret data block boundaries
3318          * and read the requested data from within data blocks when in block
3319          * data mode.
3320          */
3321 
3322         public void readFully(byte[] b) throws IOException {
3323             readFully(b, 0, b.length, false);
3324         }
3325 
3326         public void readFully(byte[] b, int off, int len) throws IOException {
3327             readFully(b, off, len, false);
3328         }
3329 
3330         public void readFully(byte[] b, int off, int len, boolean copy)
3331             throws IOException
3332         {
3333             while (len &gt; 0) {
3334                 int n = read(b, off, len, copy);
3335                 if (n &lt; 0) {
3336                     throw new EOFException();
3337                 }
3338                 off += n;
3339                 len -= n;
3340             }
3341         }
3342 
3343         public int skipBytes(int n) throws IOException {
3344             return din.skipBytes(n);
3345         }
3346 
3347         public boolean readBoolean() throws IOException {
3348             int v = read();
3349             if (v &lt; 0) {
3350                 throw new EOFException();
3351             }
3352             return (v != 0);
3353         }
3354 
3355         public byte readByte() throws IOException {
3356             int v = read();
3357             if (v &lt; 0) {
3358                 throw new EOFException();
3359             }
3360             return (byte) v;
3361         }
3362 
3363         public int readUnsignedByte() throws IOException {
3364             int v = read();
3365             if (v &lt; 0) {
3366                 throw new EOFException();
3367             }
3368             return v;
3369         }
3370 
3371         public char readChar() throws IOException {
3372             if (!blkmode) {
3373                 pos = 0;
3374                 in.readFully(buf, 0, 2);
3375             } else if (end - pos &lt; 2) {
3376                 return din.readChar();
3377             }
3378             char v = Bits.getChar(buf, pos);
3379             pos += 2;
3380             return v;
3381         }
3382 
3383         public short readShort() throws IOException {
3384             if (!blkmode) {
3385                 pos = 0;
3386                 in.readFully(buf, 0, 2);
3387             } else if (end - pos &lt; 2) {
3388                 return din.readShort();
3389             }
3390             short v = Bits.getShort(buf, pos);
3391             pos += 2;
3392             return v;
3393         }
3394 
3395         public int readUnsignedShort() throws IOException {
3396             if (!blkmode) {
3397                 pos = 0;
3398                 in.readFully(buf, 0, 2);
3399             } else if (end - pos &lt; 2) {
3400                 return din.readUnsignedShort();
3401             }
3402             int v = Bits.getShort(buf, pos) &amp; 0xFFFF;
3403             pos += 2;
3404             return v;
3405         }
3406 
3407         public int readInt() throws IOException {
3408             if (!blkmode) {
3409                 pos = 0;
3410                 in.readFully(buf, 0, 4);
3411             } else if (end - pos &lt; 4) {
3412                 return din.readInt();
3413             }
3414             int v = Bits.getInt(buf, pos);
3415             pos += 4;
3416             return v;
3417         }
3418 
3419         public float readFloat() throws IOException {
3420             if (!blkmode) {
3421                 pos = 0;
3422                 in.readFully(buf, 0, 4);
3423             } else if (end - pos &lt; 4) {
3424                 return din.readFloat();
3425             }
3426             float v = Bits.getFloat(buf, pos);
3427             pos += 4;
3428             return v;
3429         }
3430 
3431         public long readLong() throws IOException {
3432             if (!blkmode) {
3433                 pos = 0;
3434                 in.readFully(buf, 0, 8);
3435             } else if (end - pos &lt; 8) {
3436                 return din.readLong();
3437             }
3438             long v = Bits.getLong(buf, pos);
3439             pos += 8;
3440             return v;
3441         }
3442 
3443         public double readDouble() throws IOException {
3444             if (!blkmode) {
3445                 pos = 0;
3446                 in.readFully(buf, 0, 8);
3447             } else if (end - pos &lt; 8) {
3448                 return din.readDouble();
3449             }
3450             double v = Bits.getDouble(buf, pos);
3451             pos += 8;
3452             return v;
3453         }
3454 
3455         public String readUTF() throws IOException {
3456             return readUTFBody(readUnsignedShort());
3457         }
3458 
3459         @SuppressWarnings(&quot;deprecation&quot;)
3460         public String readLine() throws IOException {
3461             return din.readLine();      // deprecated, not worth optimizing
3462         }
3463 
3464         /* -------------- primitive data array input methods --------------- */
3465         /*
3466          * The following methods read in spans of primitive data values.
3467          * Though equivalent to calling the corresponding primitive read
3468          * methods repeatedly, these methods are optimized for reading groups
3469          * of primitive data values more efficiently.
3470          */
3471 
3472         void readBooleans(boolean[] v, int off, int len) throws IOException {
3473             int stop, endoff = off + len;
3474             while (off &lt; endoff) {
3475                 if (!blkmode) {
3476                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE);
3477                     in.readFully(buf, 0, span);
3478                     stop = off + span;
3479                     pos = 0;
3480                 } else if (end - pos &lt; 1) {
3481                     v[off++] = din.readBoolean();
3482                     continue;
3483                 } else {
3484                     stop = Math.min(endoff, off + end - pos);
3485                 }
3486 
3487                 while (off &lt; stop) {
3488                     v[off++] = Bits.getBoolean(buf, pos++);
3489                 }
3490             }
3491         }
3492 
3493         void readChars(char[] v, int off, int len) throws IOException {
3494             int stop, endoff = off + len;
3495             while (off &lt; endoff) {
3496                 if (!blkmode) {
3497                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3498                     in.readFully(buf, 0, span &lt;&lt; 1);
3499                     stop = off + span;
3500                     pos = 0;
3501                 } else if (end - pos &lt; 2) {
3502                     v[off++] = din.readChar();
3503                     continue;
3504                 } else {
3505                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3506                 }
3507 
3508                 while (off &lt; stop) {
3509                     v[off++] = Bits.getChar(buf, pos);
3510                     pos += 2;
3511                 }
3512             }
3513         }
3514 
3515         void readShorts(short[] v, int off, int len) throws IOException {
3516             int stop, endoff = off + len;
3517             while (off &lt; endoff) {
3518                 if (!blkmode) {
3519                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3520                     in.readFully(buf, 0, span &lt;&lt; 1);
3521                     stop = off + span;
3522                     pos = 0;
3523                 } else if (end - pos &lt; 2) {
3524                     v[off++] = din.readShort();
3525                     continue;
3526                 } else {
3527                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3528                 }
3529 
3530                 while (off &lt; stop) {
3531                     v[off++] = Bits.getShort(buf, pos);
3532                     pos += 2;
3533                 }
3534             }
3535         }
3536 
3537         void readInts(int[] v, int off, int len) throws IOException {
3538             int stop, endoff = off + len;
3539             while (off &lt; endoff) {
3540                 if (!blkmode) {
3541                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3542                     in.readFully(buf, 0, span &lt;&lt; 2);
3543                     stop = off + span;
3544                     pos = 0;
3545                 } else if (end - pos &lt; 4) {
3546                     v[off++] = din.readInt();
3547                     continue;
3548                 } else {
3549                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));
3550                 }
3551 
3552                 while (off &lt; stop) {
3553                     v[off++] = Bits.getInt(buf, pos);
3554                     pos += 4;
3555                 }
3556             }
3557         }
3558 
3559         void readFloats(float[] v, int off, int len) throws IOException {
3560             int stop, endoff = off + len;
3561             while (off &lt; endoff) {
3562                 if (!blkmode) {
3563                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3564                     in.readFully(buf, 0, span &lt;&lt; 2);
3565                     stop = off + span;
3566                     pos = 0;
3567                 } else if (end - pos &lt; 4) {
3568                     v[off++] = din.readFloat();
3569                     continue;
3570                 } else {
3571                     stop = Math.min(endoff, ((end - pos) &gt;&gt; 2));
3572                 }
3573 
3574                 while (off &lt; stop) {
3575                     v[off++] = Bits.getFloat(buf, pos);
3576                     pos += 4;
3577                 }
3578             }
3579         }
3580 
3581         void readLongs(long[] v, int off, int len) throws IOException {
3582             int stop, endoff = off + len;
3583             while (off &lt; endoff) {
3584                 if (!blkmode) {
3585                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3586                     in.readFully(buf, 0, span &lt;&lt; 3);
3587                     stop = off + span;
3588                     pos = 0;
3589                 } else if (end - pos &lt; 8) {
3590                     v[off++] = din.readLong();
3591                     continue;
3592                 } else {
3593                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));
3594                 }
3595 
3596                 while (off &lt; stop) {
3597                     v[off++] = Bits.getLong(buf, pos);
3598                     pos += 8;
3599                 }
3600             }
3601         }
3602 
3603         void readDoubles(double[] v, int off, int len) throws IOException {
3604             int stop, endoff = off + len;
3605             while (off &lt; endoff) {
3606                 if (!blkmode) {
3607                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3608                     in.readFully(buf, 0, span &lt;&lt; 3);
3609                     stop = off + span;
3610                     pos = 0;
3611                 } else if (end - pos &lt; 8) {
3612                     v[off++] = din.readDouble();
3613                     continue;
3614                 } else {
3615                     stop = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));
3616                 }
3617 
3618                 while (off &lt; stop) {
3619                     v[off++] = Bits.getDouble(buf, pos);
3620                     pos += 8;
3621                 }
3622             }
3623         }
3624 
3625         /**
3626          * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
3627          * identical to standard UTF, except that it uses an 8 byte header
3628          * (instead of the standard 2 bytes) to convey the UTF encoding length.
3629          */
3630         String readLongUTF() throws IOException {
3631             return readUTFBody(readLong());
3632         }
3633 
3634         /**
3635          * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
3636          * or 8-byte length header) of a UTF encoding, which occupies the next
3637          * utflen bytes.
3638          */
3639         private String readUTFBody(long utflen) throws IOException {
3640             StringBuilder sbuf;
3641             if (utflen &gt; 0 &amp;&amp; utflen &lt; Integer.MAX_VALUE) {
3642                 // a reasonable initial capacity based on the UTF length
3643                 int initialCapacity = Math.min((int)utflen, 0xFFFF);
3644                 sbuf = new StringBuilder(initialCapacity);
3645             } else {
3646                 sbuf = new StringBuilder();
3647             }
3648 
3649             if (!blkmode) {
3650                 end = pos = 0;
3651             }
3652 
3653             while (utflen &gt; 0) {
3654                 int avail = end - pos;
3655                 if (avail &gt;= 3 || (long) avail == utflen) {
3656                     utflen -= readUTFSpan(sbuf, utflen);
3657                 } else {
3658                     if (blkmode) {
3659                         // near block boundary, read one byte at a time
3660                         utflen -= readUTFChar(sbuf, utflen);
3661                     } else {
3662                         // shift and refill buffer manually
3663                         if (avail &gt; 0) {
3664                             System.arraycopy(buf, pos, buf, 0, avail);
3665                         }
3666                         pos = 0;
3667                         end = (int) Math.min(MAX_BLOCK_SIZE, utflen);
3668                         in.readFully(buf, avail, end - avail);
3669                     }
3670                 }
3671             }
3672 
3673             return sbuf.toString();
3674         }
3675 
3676         /**
3677          * Reads span of UTF-encoded characters out of internal buffer
3678          * (starting at offset pos and ending at or before offset end),
3679          * consuming no more than utflen bytes.  Appends read characters to
3680          * sbuf.  Returns the number of bytes consumed.
3681          */
3682         private long readUTFSpan(StringBuilder sbuf, long utflen)
3683             throws IOException
3684         {
3685             int cpos = 0;
3686             int start = pos;
3687             int avail = Math.min(end - pos, CHAR_BUF_SIZE);
3688             // stop short of last char unless all of utf bytes in buffer
3689             int stop = pos + ((utflen &gt; avail) ? avail - 2 : (int) utflen);
3690             boolean outOfBounds = false;
3691 
3692             try {
3693                 while (pos &lt; stop) {
3694                     int b1, b2, b3;
3695                     b1 = buf[pos++] &amp; 0xFF;
3696                     switch (b1 &gt;&gt; 4) {
3697                         case 0:
3698                         case 1:
3699                         case 2:
3700                         case 3:
3701                         case 4:
3702                         case 5:
3703                         case 6:
3704                         case 7:   // 1 byte format: 0xxxxxxx
3705                             cbuf[cpos++] = (char) b1;
3706                             break;
3707 
3708                         case 12:
3709                         case 13:  // 2 byte format: 110xxxxx 10xxxxxx
3710                             b2 = buf[pos++];
3711                             if ((b2 &amp; 0xC0) != 0x80) {
3712                                 throw new UTFDataFormatException();
3713                             }
3714                             cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3715                                                    ((b2 &amp; 0x3F) &lt;&lt; 0));
3716                             break;
3717 
3718                         case 14:  // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3719                             b3 = buf[pos + 1];
3720                             b2 = buf[pos + 0];
3721                             pos += 2;
3722                             if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3723                                 throw new UTFDataFormatException();
3724                             }
3725                             cbuf[cpos++] = (char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3726                                                    ((b2 &amp; 0x3F) &lt;&lt; 6) |
3727                                                    ((b3 &amp; 0x3F) &lt;&lt; 0));
3728                             break;
3729 
3730                         default:  // 10xx xxxx, 1111 xxxx
3731                             throw new UTFDataFormatException();
3732                     }
3733                 }
3734             } catch (ArrayIndexOutOfBoundsException ex) {
3735                 outOfBounds = true;
3736             } finally {
3737                 if (outOfBounds || (pos - start) &gt; utflen) {
3738                     /*
3739                      * Fix for 4450867: if a malformed utf char causes the
3740                      * conversion loop to scan past the expected end of the utf
3741                      * string, only consume the expected number of utf bytes.
3742                      */
3743                     pos = start + (int) utflen;
3744                     throw new UTFDataFormatException();
3745                 }
3746             }
3747 
3748             sbuf.append(cbuf, 0, cpos);
3749             return pos - start;
3750         }
3751 
3752         /**
3753          * Reads in single UTF-encoded character one byte at a time, appends
3754          * the character to sbuf, and returns the number of bytes consumed.
3755          * This method is used when reading in UTF strings written in block
3756          * data mode to handle UTF-encoded characters which (potentially)
3757          * straddle block-data boundaries.
3758          */
3759         private int readUTFChar(StringBuilder sbuf, long utflen)
3760             throws IOException
3761         {
3762             int b1, b2, b3;
3763             b1 = readByte() &amp; 0xFF;
3764             switch (b1 &gt;&gt; 4) {
3765                 case 0:
3766                 case 1:
3767                 case 2:
3768                 case 3:
3769                 case 4:
3770                 case 5:
3771                 case 6:
3772                 case 7:     // 1 byte format: 0xxxxxxx
3773                     sbuf.append((char) b1);
3774                     return 1;
3775 
3776                 case 12:
3777                 case 13:    // 2 byte format: 110xxxxx 10xxxxxx
3778                     if (utflen &lt; 2) {
3779                         throw new UTFDataFormatException();
3780                     }
3781                     b2 = readByte();
3782                     if ((b2 &amp; 0xC0) != 0x80) {
3783                         throw new UTFDataFormatException();
3784                     }
3785                     sbuf.append((char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3786                                         ((b2 &amp; 0x3F) &lt;&lt; 0)));
3787                     return 2;
3788 
3789                 case 14:    // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3790                     if (utflen &lt; 3) {
3791                         if (utflen == 2) {
3792                             readByte();         // consume remaining byte
3793                         }
3794                         throw new UTFDataFormatException();
3795                     }
3796                     b2 = readByte();
3797                     b3 = readByte();
3798                     if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3799                         throw new UTFDataFormatException();
3800                     }
3801                     sbuf.append((char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3802                                         ((b2 &amp; 0x3F) &lt;&lt; 6) |
3803                                         ((b3 &amp; 0x3F) &lt;&lt; 0)));
3804                     return 3;
3805 
3806                 default:   // 10xx xxxx, 1111 xxxx
3807                     throw new UTFDataFormatException();
3808             }
3809         }
3810 
3811         /**
3812          * Returns the number of bytes read from the input stream.
3813          * @return the number of bytes read from the input stream
3814          */
3815         long getBytesRead() {
3816             return in.getBytesRead();
3817         }
3818     }
3819 
3820     /**
3821      * Unsynchronized table which tracks wire handle to object mappings, as
3822      * well as ClassNotFoundExceptions associated with deserialized objects.
3823      * This class implements an exception-propagation algorithm for
3824      * determining which objects should have ClassNotFoundExceptions associated
3825      * with them, taking into account cycles and discontinuities (e.g., skipped
3826      * fields) in the object graph.
3827      *
3828      * &lt;p&gt;General use of the table is as follows: during deserialization, a
3829      * given object is first assigned a handle by calling the assign method.
3830      * This method leaves the assigned handle in an &quot;open&quot; state, wherein
3831      * dependencies on the exception status of other handles can be registered
3832      * by calling the markDependency method, or an exception can be directly
3833      * associated with the handle by calling markException.  When a handle is
3834      * tagged with an exception, the HandleTable assumes responsibility for
3835      * propagating the exception to any other objects which depend
3836      * (transitively) on the exception-tagged object.
3837      *
3838      * &lt;p&gt;Once all exception information/dependencies for the handle have been
3839      * registered, the handle should be &quot;closed&quot; by calling the finish method
3840      * on it.  The act of finishing a handle allows the exception propagation
3841      * algorithm to aggressively prune dependency links, lessening the
3842      * performance/memory impact of exception tracking.
3843      *
3844      * &lt;p&gt;Note that the exception propagation algorithm used depends on handles
3845      * being assigned/finished in LIFO order; however, for simplicity as well
3846      * as memory conservation, it does not enforce this constraint.
3847      */
3848     // REMIND: add full description of exception propagation algorithm?
3849     private static class HandleTable {
3850 
3851         /* status codes indicating whether object has associated exception */
3852         private static final byte STATUS_OK = 1;
3853         private static final byte STATUS_UNKNOWN = 2;
3854         private static final byte STATUS_EXCEPTION = 3;
3855 
3856         /** array mapping handle -&gt; object status */
3857         byte[] status;
3858         /** array mapping handle -&gt; object/exception (depending on status) */
3859         Object[] entries;
3860         /** array mapping handle -&gt; list of dependent handles (if any) */
3861         HandleList[] deps;
3862         /** lowest unresolved dependency */
3863         int lowDep = -1;
3864         /** number of handles in table */
3865         int size = 0;
3866 
3867         /**
3868          * Creates handle table with the given initial capacity.
3869          */
3870         HandleTable(int initialCapacity) {
3871             status = new byte[initialCapacity];
3872             entries = new Object[initialCapacity];
3873             deps = new HandleList[initialCapacity];
3874         }
3875 
3876         /**
3877          * Assigns next available handle to given object, and returns assigned
3878          * handle.  Once object has been completely deserialized (and all
3879          * dependencies on other objects identified), the handle should be
3880          * &quot;closed&quot; by passing it to finish().
3881          */
3882         int assign(Object obj) {
3883             if (size &gt;= entries.length) {
3884                 grow();
3885             }
3886             status[size] = STATUS_UNKNOWN;
3887             entries[size] = obj;
3888             return size++;
3889         }
3890 
3891         /**
3892          * Registers a dependency (in exception status) of one handle on
3893          * another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
3894          * not finished yet).  No action is taken if either dependent or target
3895          * handle is NULL_HANDLE. Additionally, no action is taken if the
3896          * dependent and target are the same.
3897          */
3898         void markDependency(int dependent, int target) {
3899             if (dependent == target || dependent == NULL_HANDLE || target == NULL_HANDLE) {
3900                 return;
3901             }
3902             switch (status[dependent]) {
3903 
3904                 case STATUS_UNKNOWN:
3905                     switch (status[target]) {
3906                         case STATUS_OK:
3907                             // ignore dependencies on objs with no exception
3908                             break;
3909 
3910                         case STATUS_EXCEPTION:
3911                             // eagerly propagate exception
3912                             markException(dependent,
3913                                 (ClassNotFoundException) entries[target]);
3914                             break;
3915 
3916                         case STATUS_UNKNOWN:
3917                             // add to dependency list of target
3918                             if (deps[target] == null) {
3919                                 deps[target] = new HandleList();
3920                             }
3921                             deps[target].add(dependent);
3922 
3923                             // remember lowest unresolved target seen
3924                             if (lowDep &lt; 0 || lowDep &gt; target) {
3925                                 lowDep = target;
3926                             }
3927                             break;
3928 
3929                         default:
3930                             throw new InternalError();
3931                     }
3932                     break;
3933 
3934                 case STATUS_EXCEPTION:
3935                     break;
3936 
3937                 default:
3938                     throw new InternalError();
3939             }
3940         }
3941 
3942         /**
3943          * Associates a ClassNotFoundException (if one not already associated)
3944          * with the currently active handle and propagates it to other
3945          * referencing objects as appropriate.  The specified handle must be
3946          * &quot;open&quot; (i.e., assigned, but not finished yet).
3947          */
3948         void markException(int handle, ClassNotFoundException ex) {
3949             switch (status[handle]) {
3950                 case STATUS_UNKNOWN:
3951                     status[handle] = STATUS_EXCEPTION;
3952                     entries[handle] = ex;
3953 
3954                     // propagate exception to dependents
3955                     HandleList dlist = deps[handle];
3956                     if (dlist != null) {
3957                         int ndeps = dlist.size();
3958                         for (int i = 0; i &lt; ndeps; i++) {
3959                             markException(dlist.get(i), ex);
3960                         }
3961                         deps[handle] = null;
3962                     }
3963                     break;
3964 
3965                 case STATUS_EXCEPTION:
3966                     break;
3967 
3968                 default:
3969                     throw new InternalError();
3970             }
3971         }
3972 
3973         /**
3974          * Marks given handle as finished, meaning that no new dependencies
3975          * will be marked for handle.  Calls to the assign and finish methods
3976          * must occur in LIFO order.
3977          */
3978         void finish(int handle) {
3979             int end;
3980             if (lowDep &lt; 0) {
3981                 // no pending unknowns, only resolve current handle
3982                 end = handle + 1;
3983             } else if (lowDep &gt;= handle) {
3984                 // pending unknowns now clearable, resolve all upward handles
3985                 end = size;
3986                 lowDep = -1;
3987             } else {
3988                 // unresolved backrefs present, can&#39;t resolve anything yet
3989                 return;
3990             }
3991 
3992             // change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles
3993             for (int i = handle; i &lt; end; i++) {
3994                 switch (status[i]) {
3995                     case STATUS_UNKNOWN:
3996                         status[i] = STATUS_OK;
3997                         deps[i] = null;
3998                         break;
3999 
4000                     case STATUS_OK:
4001                     case STATUS_EXCEPTION:
4002                         break;
4003 
4004                     default:
4005                         throw new InternalError();
4006                 }
4007             }
4008         }
4009 
4010         /**
4011          * Assigns a new object to the given handle.  The object previously
4012          * associated with the handle is forgotten.  This method has no effect
4013          * if the given handle already has an exception associated with it.
4014          * This method may be called at any time after the handle is assigned.
4015          */
4016         void setObject(int handle, Object obj) {
4017             switch (status[handle]) {
4018                 case STATUS_UNKNOWN:
4019                 case STATUS_OK:
4020                     entries[handle] = obj;
4021                     break;
4022 
4023                 case STATUS_EXCEPTION:
4024                     break;
4025 
4026                 default:
4027                     throw new InternalError();
4028             }
4029         }
4030 
4031         /**
4032          * Looks up and returns object associated with the given handle.
4033          * Returns null if the given handle is NULL_HANDLE, or if it has an
4034          * associated ClassNotFoundException.
4035          */
4036         Object lookupObject(int handle) {
4037             return (handle != NULL_HANDLE &amp;&amp;
4038                     status[handle] != STATUS_EXCEPTION) ?
4039                 entries[handle] : null;
4040         }
4041 
4042         /**
4043          * Looks up and returns ClassNotFoundException associated with the
4044          * given handle.  Returns null if the given handle is NULL_HANDLE, or
4045          * if there is no ClassNotFoundException associated with the handle.
4046          */
4047         ClassNotFoundException lookupException(int handle) {
4048             return (handle != NULL_HANDLE &amp;&amp;
4049                     status[handle] == STATUS_EXCEPTION) ?
4050                 (ClassNotFoundException) entries[handle] : null;
4051         }
4052 
4053         /**
4054          * Resets table to its initial state.
4055          */
4056         void clear() {
4057             Arrays.fill(status, 0, size, (byte) 0);
4058             Arrays.fill(entries, 0, size, null);
4059             Arrays.fill(deps, 0, size, null);
4060             lowDep = -1;
4061             size = 0;
4062         }
4063 
4064         /**
4065          * Returns number of handles registered in table.
4066          */
4067         int size() {
4068             return size;
4069         }
4070 
4071         /**
4072          * Expands capacity of internal arrays.
4073          */
4074         private void grow() {
4075             int newCapacity = (entries.length &lt;&lt; 1) + 1;
4076 
4077             byte[] newStatus = new byte[newCapacity];
4078             Object[] newEntries = new Object[newCapacity];
4079             HandleList[] newDeps = new HandleList[newCapacity];
4080 
4081             System.arraycopy(status, 0, newStatus, 0, size);
4082             System.arraycopy(entries, 0, newEntries, 0, size);
4083             System.arraycopy(deps, 0, newDeps, 0, size);
4084 
4085             status = newStatus;
4086             entries = newEntries;
4087             deps = newDeps;
4088         }
4089 
4090         /**
4091          * Simple growable list of (integer) handles.
4092          */
4093         private static class HandleList {
4094             private int[] list = new int[4];
4095             private int size = 0;
4096 
4097             public HandleList() {
4098             }
4099 
4100             public void add(int handle) {
4101                 if (size &gt;= list.length) {
4102                     int[] newList = new int[list.length &lt;&lt; 1];
4103                     System.arraycopy(list, 0, newList, 0, list.length);
4104                     list = newList;
4105                 }
4106                 list[size++] = handle;
4107             }
4108 
4109             public int get(int index) {
4110                 if (index &gt;= size) {
4111                     throw new ArrayIndexOutOfBoundsException();
4112                 }
4113                 return list[index];
4114             }
4115 
4116             public int size() {
4117                 return size;
4118             }
4119         }
4120     }
4121 
4122     /**
4123      * Method for cloning arrays in case of using unsharing reading
4124      */
4125     private static Object cloneArray(Object array) {
4126         if (array instanceof Object[]) {
4127             return ((Object[]) array).clone();
4128         } else if (array instanceof boolean[]) {
4129             return ((boolean[]) array).clone();
4130         } else if (array instanceof byte[]) {
4131             return ((byte[]) array).clone();
4132         } else if (array instanceof char[]) {
4133             return ((char[]) array).clone();
4134         } else if (array instanceof double[]) {
4135             return ((double[]) array).clone();
4136         } else if (array instanceof float[]) {
4137             return ((float[]) array).clone();
4138         } else if (array instanceof int[]) {
4139             return ((int[]) array).clone();
4140         } else if (array instanceof long[]) {
4141             return ((long[]) array).clone();
4142         } else if (array instanceof short[]) {
4143             return ((short[]) array).clone();
4144         } else {
4145             throw new AssertionError();
4146         }
4147     }
4148 
4149     static {
4150         SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
4151         SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);
4152     }
4153 
4154 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
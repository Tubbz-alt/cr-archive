<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/util/DerValue.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnchorCertificates.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../lib/security/default.policy.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/util/DerValue.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /**
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;
 30 import java.nio.charset.Charset;


 31 import java.util.Date;
 32 
 33 import static java.nio.charset.StandardCharsets.*;
 34 
 35 /**
 36  * Represents a single DER-encoded value.  DER encoding rules are a subset
 37  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
 38  * (&quot;Definite&quot; encoding) to encode any given value.
 39  *
 40  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
 41  * class represents such tagged values as they have been read (or constructed),
 42  * and provides structured access to the encoded data.
 43  *
 44  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 45  * data encodings which are defined.  That subset is sufficient for parsing
 46  * most X.509 certificates, and working with selected additional formats
 47  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 48  *
 49  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 50  * and RFC 5280, section 8, we assume that this kind of string will contain
</pre>
<hr />
<pre>
343     private DerInputStream init(byte stringTag, String value) {
344         final Charset charset;
345 
346         tag = stringTag;
347 
348         switch (stringTag) {
349         case tag_PrintableString:
350         case tag_IA5String:
351         case tag_GeneralString:
352             charset = US_ASCII;
353             break;
354         case tag_T61String:
355             charset = ISO_8859_1;
356             break;
357         case tag_BMPString:
358             charset = UTF_16BE;
359             break;
360         case tag_UTF8String:
361             charset = UTF_8;
362             break;
<span class="line-modified">363             // TBD: Need encoder for UniversalString before it can</span>
<span class="line-modified">364             // be handled.</span>

365         default:
366             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
367         }
368 
369         byte[] buf = value.getBytes(charset);
370         length = buf.length;
371         buffer = new DerInputBuffer(buf, true);
372         DerInputStream result = new DerInputStream(buffer);
373         result.mark(Integer.MAX_VALUE);
374         return result;
375     }
376 
377     /*
378      * helper routine
379      */
380     private DerInputStream init(boolean fullyBuffered, InputStream in,
381         boolean allowBER) throws IOException {
382 
383         tag = (byte)in.read();
384         byte lenByte = (byte)in.read();
</pre>
<hr />
<pre>
581             throw new IOException(
582                 &quot;DerValue.getBitString, not a bit string &quot; + tag);
583 
584         return buffer.getUnalignedBitString();
585     }
586 
587     /**
588      * Returns the name component as a Java string, regardless of its
589      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
590      */
591     // TBD: Need encoder for UniversalString before it can be handled.
592     public String getAsString() throws IOException {
593         if (tag == tag_UTF8String)
594             return getUTF8String();
595         else if (tag == tag_PrintableString)
596             return getPrintableString();
597         else if (tag == tag_T61String)
598             return getT61String();
599         else if (tag == tag_IA5String)
600             return getIA5String();
<span class="line-modified">601         /*</span>
<span class="line-removed">602           else if (tag == tag_UniversalString)</span>
603           return getUniversalString();
<span class="line-removed">604         */</span>
605         else if (tag == tag_BMPString)
606             return getBMPString();
607         else if (tag == tag_GeneralString)
608             return getGeneralString();
609         else
610             return null;
611     }
612 
613     /**
614      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
615      * based on the parameter.  The bit string must be byte-aligned.
616      *
617      * @param tagImplicit if true, the tag is assumed implicit.
618      * @return the bit string held in this value
619      */
620     public byte[] getBitString(boolean tagImplicit) throws IOException {
621         if (!tagImplicit) {
622             if (tag != tag_BitString)
623                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
624                                        + tag);
</pre>
<hr />
<pre>
723             throw new IOException(
724                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
725 
726         return new String(getDataBytes(), UTF_8);
727     }
728 
729     /**
730      * Returns the ASN.1 GENERAL STRING value as a Java String.
731      *
732      * @return a string corresponding to the encoded GeneralString held in
733      * this value
734      */
735     public String getGeneralString() throws IOException {
736         if (tag != tag_GeneralString)
737             throw new IOException(
738                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
739 
740         return new String(getDataBytes(), US_ASCII);
741     }
742 



















743     /**
744      * Returns a Date if the DerValue is UtcTime.
745      *
746      * @return the Date held in this DER value
747      */
748     public Date getUTCTime() throws IOException {
749         if (tag != tag_UtcTime) {
750             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
751         }
752         return buffer.getUTCTime(data.available());
753     }
754 
755     /**
756      * Returns a Date if the DerValue is GeneralizedTime.
757      *
758      * @return the Date held in this DER value
759      */
760     public Date getGeneralizedTime() throws IOException {
761         if (tag != tag_GeneralizedTime) {
762             throw new IOException(
</pre>
</td>
<td>
<hr />
<pre>
  1 /**
<span class="line-modified">  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.util;
 27 
 28 import java.io.*;
 29 import java.math.BigInteger;
 30 import java.nio.charset.Charset;
<span class="line-added"> 31 import java.nio.charset.IllegalCharsetNameException;</span>
<span class="line-added"> 32 import java.nio.charset.UnsupportedCharsetException;</span>
 33 import java.util.Date;
 34 
 35 import static java.nio.charset.StandardCharsets.*;
 36 
 37 /**
 38  * Represents a single DER-encoded value.  DER encoding rules are a subset
 39  * of the &quot;Basic&quot; Encoding Rules (BER), but they only support a single way
 40  * (&quot;Definite&quot; encoding) to encode any given value.
 41  *
 42  * &lt;P&gt;All DER-encoded data are triples &lt;em&gt;{type, length, data}&lt;/em&gt;.  This
 43  * class represents such tagged values as they have been read (or constructed),
 44  * and provides structured access to the encoded data.
 45  *
 46  * &lt;P&gt;At this time, this class supports only a subset of the types of DER
 47  * data encodings which are defined.  That subset is sufficient for parsing
 48  * most X.509 certificates, and working with selected additional formats
 49  * (such as PKCS #10 certificate requests, and some kinds of PKCS #7 data).
 50  *
 51  * A note with respect to T61/Teletex strings: From RFC 1617, section 4.1.3
 52  * and RFC 5280, section 8, we assume that this kind of string will contain
</pre>
<hr />
<pre>
345     private DerInputStream init(byte stringTag, String value) {
346         final Charset charset;
347 
348         tag = stringTag;
349 
350         switch (stringTag) {
351         case tag_PrintableString:
352         case tag_IA5String:
353         case tag_GeneralString:
354             charset = US_ASCII;
355             break;
356         case tag_T61String:
357             charset = ISO_8859_1;
358             break;
359         case tag_BMPString:
360             charset = UTF_16BE;
361             break;
362         case tag_UTF8String:
363             charset = UTF_8;
364             break;
<span class="line-modified">365         case tag_UniversalString:</span>
<span class="line-modified">366             charset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added">367             break;</span>
368         default:
369             throw new IllegalArgumentException(&quot;Unsupported DER string type&quot;);
370         }
371 
372         byte[] buf = value.getBytes(charset);
373         length = buf.length;
374         buffer = new DerInputBuffer(buf, true);
375         DerInputStream result = new DerInputStream(buffer);
376         result.mark(Integer.MAX_VALUE);
377         return result;
378     }
379 
380     /*
381      * helper routine
382      */
383     private DerInputStream init(boolean fullyBuffered, InputStream in,
384         boolean allowBER) throws IOException {
385 
386         tag = (byte)in.read();
387         byte lenByte = (byte)in.read();
</pre>
<hr />
<pre>
584             throw new IOException(
585                 &quot;DerValue.getBitString, not a bit string &quot; + tag);
586 
587         return buffer.getUnalignedBitString();
588     }
589 
590     /**
591      * Returns the name component as a Java string, regardless of its
592      * encoding restrictions (ASCII, T61, Printable, IA5, BMP, UTF8).
593      */
594     // TBD: Need encoder for UniversalString before it can be handled.
595     public String getAsString() throws IOException {
596         if (tag == tag_UTF8String)
597             return getUTF8String();
598         else if (tag == tag_PrintableString)
599             return getPrintableString();
600         else if (tag == tag_T61String)
601             return getT61String();
602         else if (tag == tag_IA5String)
603             return getIA5String();
<span class="line-modified">604         else if (tag == tag_UniversalString)</span>

605           return getUniversalString();

606         else if (tag == tag_BMPString)
607             return getBMPString();
608         else if (tag == tag_GeneralString)
609             return getGeneralString();
610         else
611             return null;
612     }
613 
614     /**
615      * Returns an ASN.1 BIT STRING value, with the tag assumed implicit
616      * based on the parameter.  The bit string must be byte-aligned.
617      *
618      * @param tagImplicit if true, the tag is assumed implicit.
619      * @return the bit string held in this value
620      */
621     public byte[] getBitString(boolean tagImplicit) throws IOException {
622         if (!tagImplicit) {
623             if (tag != tag_BitString)
624                 throw new IOException(&quot;DerValue.getBitString, not a bit string &quot;
625                                        + tag);
</pre>
<hr />
<pre>
724             throw new IOException(
725                 &quot;DerValue.getUTF8String, not UTF-8 &quot; + tag);
726 
727         return new String(getDataBytes(), UTF_8);
728     }
729 
730     /**
731      * Returns the ASN.1 GENERAL STRING value as a Java String.
732      *
733      * @return a string corresponding to the encoded GeneralString held in
734      * this value
735      */
736     public String getGeneralString() throws IOException {
737         if (tag != tag_GeneralString)
738             throw new IOException(
739                 &quot;DerValue.getGeneralString, not GeneralString &quot; + tag);
740 
741         return new String(getDataBytes(), US_ASCII);
742     }
743 
<span class="line-added">744     /**</span>
<span class="line-added">745      * Returns the ASN.1 UNIVERSAL (UTF-32) STRING value as a Java String.</span>
<span class="line-added">746      *</span>
<span class="line-added">747      * @return a string corresponding to the encoded UniversalString held in</span>
<span class="line-added">748      * this value or an empty string if UTF_32BE is not a supported character</span>
<span class="line-added">749      * set.</span>
<span class="line-added">750      */</span>
<span class="line-added">751     public String getUniversalString() throws IOException {</span>
<span class="line-added">752         if (tag != tag_UniversalString)</span>
<span class="line-added">753             throw new IOException(</span>
<span class="line-added">754                 &quot;DerValue.getUniversalString, not UniversalString &quot; + tag);</span>
<span class="line-added">755         try {</span>
<span class="line-added">756             Charset cset = Charset.forName(&quot;UTF_32BE&quot;);</span>
<span class="line-added">757             return new String(getDataBytes(), cset);</span>
<span class="line-added">758         } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {</span>
<span class="line-added">759             return &quot;&quot;;</span>
<span class="line-added">760         }</span>
<span class="line-added">761     }</span>
<span class="line-added">762 </span>
763     /**
764      * Returns a Date if the DerValue is UtcTime.
765      *
766      * @return the Date held in this DER value
767      */
768     public Date getUTCTime() throws IOException {
769         if (tag != tag_UtcTime) {
770             throw new IOException(&quot;DerValue.getUTCTime, not a UtcTime: &quot; + tag);
771         }
772         return buffer.getUTCTime(data.available());
773     }
774 
775     /**
776      * Returns a Date if the DerValue is GeneralizedTime.
777      *
778      * @return the Date held in this DER value
779      */
780     public Date getGeneralizedTime() throws IOException {
781         if (tag != tag_GeneralizedTime) {
782             throw new IOException(
</pre>
</td>
</tr>
</table>
<center><a href="AnchorCertificates.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../lib/security/default.policy.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/src/classes/build/tools/jfr/GenerateJfrFiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 package build.tools.jfr;
  2 
  3 import java.io.BufferedOutputStream;
<a name="1" id="anc1"></a><span class="line-added">  4 import java.io.Closeable;</span>
<span class="line-added">  5 import java.io.DataOutputStream;</span>
  6 import java.io.File;
  7 import java.io.FileNotFoundException;
  8 import java.io.FileOutputStream;
  9 import java.io.IOException;
 10 import java.io.PrintStream;
 11 import java.util.ArrayList;
<a name="2" id="anc2"></a><span class="line-added"> 12 import java.util.Arrays;</span>
 13 import java.util.LinkedHashMap;
 14 import java.util.List;
 15 import java.util.Map;
<a name="3" id="anc3"></a><span class="line-modified"> 16 import java.util.Objects;</span>
 17 import java.util.StringJoiner;
 18 import java.util.function.Predicate;
 19 
 20 import javax.xml.XMLConstants;
 21 import javax.xml.parsers.ParserConfigurationException;
 22 import javax.xml.parsers.SAXParser;
 23 import javax.xml.parsers.SAXParserFactory;
 24 import javax.xml.validation.SchemaFactory;
 25 
 26 import org.xml.sax.Attributes;
 27 import org.xml.sax.SAXException;
 28 import org.xml.sax.SAXParseException;
 29 import org.xml.sax.helpers.DefaultHandler;
 30 
<a name="4" id="anc4"></a><span class="line-added"> 31 /**</span>
<span class="line-added"> 32  * Purpose of this program is twofold:</span>
<span class="line-added"> 33  *</span>
<span class="line-added"> 34  * 1) Generate C++ classes to be used when writing native events for HotSpot.</span>
<span class="line-added"> 35  *</span>
<span class="line-added"> 36  * 2) Generate metadata (label, descriptions, field layout etc.) from XML</span>
<span class="line-added"> 37  * (metadata.xml) into a binary format (metadata.bin) that can be read quickly</span>
<span class="line-added"> 38  * during startup by the jdk.jfr module.</span>
<span class="line-added"> 39  *</span>
<span class="line-added"> 40  * INPUT FILES:</span>
<span class="line-added"> 41  *</span>
<span class="line-added"> 42  * -  metadata.xml  File that contains descriptions of events and types</span>
<span class="line-added"> 43  * -  metadata.xsd  Schema that verifies that metadata.xml is legit XML</span>
<span class="line-added"> 44  *</span>
<span class="line-added"> 45  * OUTPUT FILES:</span>
<span class="line-added"> 46  *</span>
<span class="line-added"> 47  * MODE: headers</span>
<span class="line-added"> 48  *</span>
<span class="line-added"> 49  * - jfrEventIds.hpp      List of IDs so events can be identified from native</span>
<span class="line-added"> 50  * - jfrTypes.hpp         List of IDs so types can be identified from native</span>
<span class="line-added"> 51  * - jfrPeriodic.hpp      Dispatch mechanism so Java can emit native periodic events</span>
<span class="line-added"> 52  * - jfrEventControl.hpp  Data structure for native event settings.</span>
<span class="line-added"> 53  * - jfrEventClasses.hpp  C++ event classes that can write data into native buffers</span>
<span class="line-added"> 54  *</span>
<span class="line-added"> 55  * MODE: metadata</span>
<span class="line-added"> 56  *</span>
<span class="line-added"> 57  *  - metadata.bin        Binary representation of the information in metadata.xml</span>
<span class="line-added"> 58  *</span>
<span class="line-added"> 59  */</span>
 60 public class GenerateJfrFiles {
 61 
<a name="5" id="anc5"></a><span class="line-modified"> 62     enum OutputMode {</span>
<span class="line-modified"> 63         headers, metadata</span>

























 64     }
 65 
<a name="6" id="anc6"></a><span class="line-modified"> 66     private static void printUsage(PrintStream out) {</span>
<span class="line-modified"> 67         out.println(&quot;Usage: java GenerateJfrFiles[.java]&quot;);</span>
<span class="line-modified"> 68         out.println(&quot; --mode &lt;headers|metadata&gt;&quot;);</span>
<span class="line-modified"> 69         out.println(&quot; --xml &lt;path-to-metadata.xml&gt; &quot;);</span>
<span class="line-modified"> 70         out.println(&quot; --xsd &lt;path-to-metadata.xsd&gt;&quot;);</span>
<span class="line-modified"> 71         out.println(&quot; --output &lt;output-file-or-directory&gt;&quot;);</span>
<span class="line-modified"> 72     }</span>


 73 
<a name="7" id="anc7"></a><span class="line-modified"> 74     private static String consumeOption(String option, List&lt;String&gt; argList) throws Exception {</span>
<span class="line-modified"> 75         int index = argList.indexOf(option);</span>
<span class="line-modified"> 76         if (index &gt;= 0 &amp;&amp; index &lt;= argList.size() - 2) {</span>
<span class="line-modified"> 77             String result = argList.get(index + 1);</span>
<span class="line-modified"> 78             argList.remove(index);</span>
<span class="line-modified"> 79             argList.remove(index);</span>
<span class="line-modified"> 80             return result;</span>


 81         }
<a name="8" id="anc8"></a><span class="line-added"> 82         throw new IllegalArgumentException(&quot;missing option &quot; + option);</span>
<span class="line-added"> 83     }</span>
 84 
<a name="9" id="anc9"></a><span class="line-modified"> 85     public static void main(String... args) throws Exception {</span>
<span class="line-modified"> 86         try {</span>
<span class="line-modified"> 87             List&lt;String&gt; argList = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 88             argList.addAll(Arrays.asList(args));</span>
<span class="line-added"> 89             String mode = consumeOption(&quot;--mode&quot;, argList);</span>
<span class="line-added"> 90             String output = consumeOption(&quot;--output&quot;, argList);</span>
<span class="line-added"> 91             String xml = consumeOption(&quot;--xml&quot;, argList);</span>
<span class="line-added"> 92             String xsd = consumeOption(&quot;--xsd&quot;, argList);</span>
<span class="line-added"> 93             if (!argList.isEmpty()) {</span>
<span class="line-added"> 94                 throw new IllegalArgumentException(&quot;unknown option &quot; + argList);</span>
 95             }
<a name="10" id="anc10"></a><span class="line-modified"> 96             OutputMode outputMode = OutputMode.valueOf(mode);</span>
<span class="line-modified"> 97             File xmlFile = new File(xml);</span>
<span class="line-modified"> 98             File xsdFile = new File(xsd);</span>
















 99 
<a name="11" id="anc11"></a><span class="line-modified">100             Metadata metadata = new Metadata(xmlFile, xsdFile);</span>
<span class="line-modified">101             metadata.verify();</span>
<span class="line-modified">102             metadata.wireUpTypes();</span>
103 
<a name="12" id="anc12"></a><span class="line-modified">104             if (outputMode == OutputMode.headers) {</span>
<span class="line-modified">105                 File outputDir = new File(output);</span>
<span class="line-modified">106                 printJfrEventIdsHpp(metadata, new File(outputDir, &quot;jfrEventIds.hpp&quot;));</span>
<span class="line-added">107                 printJfrTypesHpp(metadata, new File(outputDir, &quot;jfrTypes.hpp&quot;));</span>
<span class="line-added">108                 printJfrPeriodicHpp(metadata, new File(outputDir, &quot;jfrPeriodic.hpp&quot;));</span>
<span class="line-added">109                 printJfrEventControlHpp(metadata, new File(outputDir, &quot;jfrEventControl.hpp&quot;));</span>
<span class="line-added">110                 printJfrEventClassesHpp(metadata, new File(outputDir, &quot;jfrEventClasses.hpp&quot;));</span>
<span class="line-added">111             }</span>
112 
<a name="13" id="anc13"></a><span class="line-modified">113             if (outputMode == OutputMode.metadata) {</span>
<span class="line-modified">114                 File outputFile  = new File(output);</span>
<span class="line-added">115                 try (var b = new DataOutputStream(</span>
<span class="line-added">116                         new BufferedOutputStream(</span>
<span class="line-added">117                             new FileOutputStream(outputFile)))) {</span>
<span class="line-added">118                     metadata.persist(b);</span>
<span class="line-added">119                 }</span>
<span class="line-added">120             }</span>
<span class="line-added">121             System.exit(0);</span>
<span class="line-added">122         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">123             System.err.println();</span>
<span class="line-added">124             System.err.println(&quot;GenerateJfrFiles: &quot; + iae.getMessage());</span>
<span class="line-added">125             System.err.println();</span>
<span class="line-added">126             printUsage(System.err);</span>
<span class="line-added">127             System.err.println();</span>
<span class="line-added">128         } catch (Exception e) {</span>
<span class="line-added">129             e.printStackTrace();</span>
130         }
<a name="14" id="anc14"></a><span class="line-added">131         System.exit(1);</span>
132     }
133 
134     static class XmlType {
135         final String name;
136         final String fieldType;
137         final String parameterType;
138         final String javaType;
139         final boolean unsigned;
<a name="15" id="anc15"></a><span class="line-added">140         final String contentType;</span>
141 
<a name="16" id="anc16"></a><span class="line-modified">142         XmlType(String name, String fieldType, String parameterType, String javaType, String contentType,</span>
<span class="line-added">143                 boolean unsigned) {</span>
144             this.name = name;
145             this.fieldType = fieldType;
146             this.parameterType = parameterType;
147             this.javaType = javaType;
148             this.unsigned = unsigned;
<a name="17" id="anc17"></a><span class="line-added">149             this.contentType = contentType;</span>
<span class="line-added">150         }</span>
<span class="line-added">151     }</span>
<span class="line-added">152 </span>
<span class="line-added">153     static class XmlContentType {</span>
<span class="line-added">154         final String name;</span>
<span class="line-added">155         final String annotation;</span>
<span class="line-added">156 </span>
<span class="line-added">157         XmlContentType(String name, String annotation) {</span>
<span class="line-added">158             this.name = name;</span>
<span class="line-added">159             this.annotation = annotation;</span>
160         }
161     }
162 
163     static class TypeElement {
164         List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
165         String name;
<a name="18" id="anc18"></a><span class="line-modified">166         String javaType;</span>
<span class="line-modified">167         String label = &quot;&quot;;</span>
<span class="line-modified">168         String description = &quot;&quot;;</span>
<span class="line-added">169         String category = &quot;&quot;;</span>
<span class="line-added">170         boolean thread;</span>
<span class="line-added">171         boolean stackTrace;</span>
<span class="line-added">172         boolean startTime;</span>
<span class="line-added">173         String period = &quot;&quot;;</span>
<span class="line-added">174         boolean cutoff;</span>
<span class="line-added">175         boolean experimental;</span>
<span class="line-added">176         long id;</span>
<span class="line-added">177         boolean isEvent;</span>
<span class="line-added">178         boolean isRelation;</span>
<span class="line-added">179         boolean supportStruct = false;</span>
<span class="line-added">180         String commitState;</span>
<span class="line-added">181         public boolean primitive;</span>
<span class="line-added">182 </span>
<span class="line-added">183         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-added">184             pos.writeInt(fields.size());</span>
<span class="line-added">185             for (FieldElement field : fields) {</span>
<span class="line-added">186                 field.persist(pos);</span>
<span class="line-added">187             }</span>
<span class="line-added">188             pos.writeUTF(javaType);</span>
<span class="line-added">189             pos.writeUTF(label);</span>
<span class="line-added">190             pos.writeUTF(description);</span>
<span class="line-added">191             pos.writeUTF(category);</span>
<span class="line-added">192             pos.writeBoolean(thread);</span>
<span class="line-added">193             pos.writeBoolean(stackTrace);</span>
<span class="line-added">194             pos.writeBoolean(startTime);</span>
<span class="line-added">195             pos.writeUTF(period);</span>
<span class="line-added">196             pos.writeBoolean(cutoff);</span>
<span class="line-added">197             pos.writeBoolean(experimental);</span>
<span class="line-added">198             pos.writeLong(id);</span>
<span class="line-added">199             pos.writeBoolean(isEvent);</span>
<span class="line-added">200             pos.writeBoolean(isRelation);</span>
<span class="line-added">201         }</span>
202     }
203 
204     static class Metadata {
<a name="19" id="anc19"></a><span class="line-added">205         static class TypeCounter {</span>
<span class="line-added">206             final long first;</span>
<span class="line-added">207             long last = -1;</span>
<span class="line-added">208             long count = 0;</span>
<span class="line-added">209             long id = -1;</span>
<span class="line-added">210 </span>
<span class="line-added">211             TypeCounter(long startId) {</span>
<span class="line-added">212                 this.first = startId;</span>
<span class="line-added">213             }</span>
<span class="line-added">214 </span>
<span class="line-added">215             long next() {</span>
<span class="line-added">216                 id = (id == -1) ? first : id + 1;</span>
<span class="line-added">217                 count++;</span>
<span class="line-added">218                 last = id;</span>
<span class="line-added">219                 return id;</span>
<span class="line-added">220             }</span>
<span class="line-added">221         }</span>
<span class="line-added">222 </span>
<span class="line-added">223         static int RESERVED_EVENT_COUNT = 2;</span>
224         final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
225         final Map&lt;String, XmlType&gt; xmlTypes = new LinkedHashMap&lt;&gt;();
<a name="20" id="anc20"></a><span class="line-modified">226         final Map&lt;String, XmlContentType&gt; xmlContentTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-added">227         int lastEventId;</span>
<span class="line-added">228         private TypeCounter eventCounter;</span>
<span class="line-added">229         private TypeCounter typeCounter;</span>
<span class="line-added">230 </span>
<span class="line-added">231         Metadata(File metadataXml, File metadataSchema)</span>
<span class="line-added">232                 throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {</span>
233             SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
234             SAXParserFactory factory = SAXParserFactory.newInstance();
235             factory.setSchema(schemaFactory.newSchema(metadataSchema));
236             SAXParser sp = factory.newSAXParser();
237             sp.parse(metadataXml, new MetadataHandler(this));
238         }
239 
<a name="21" id="anc21"></a><span class="line-modified">240         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-modified">241             pos.writeInt(types.values().size());</span>
<span class="line-added">242             for (TypeElement t : types.values()) {</span>
<span class="line-added">243                 t.persist(pos);</span>
<span class="line-added">244             }</span>
245         }
246 
<a name="22" id="anc22"></a><span class="line-modified">247         List&lt;TypeElement&gt; getEvents() {</span>
<span class="line-modified">248             return getList(t -&gt; t.isEvent);</span>
249         }
250 
<a name="23" id="anc23"></a><span class="line-modified">251         List&lt;TypeElement&gt; getEventsAndStructs() {</span>
<span class="line-modified">252             return getList(t -&gt; t.isEvent || t.supportStruct);</span>
253         }
254 
255         @SuppressWarnings(&quot;unchecked&quot;)
256         &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
257             List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
258             for (TypeElement t : types.values()) {
259                 if (pred.test(t)) {
260                     result.add((T) t);
261                 }
262             }
263             return result;
264         }
265 
<a name="24" id="anc24"></a><span class="line-modified">266         List&lt;TypeElement&gt; getPeriodicEvents() {</span>
<span class="line-modified">267             return getList(t -&gt; t.isEvent &amp;&amp; !t.period.isEmpty());</span>
268         }
269 
270         List&lt;TypeElement&gt; getTypes() {
<a name="25" id="anc25"></a><span class="line-modified">271             return getList(t -&gt; !t.isEvent);</span>
272         }
273 
274         List&lt;TypeElement&gt; getStructs() {
<a name="26" id="anc26"></a><span class="line-modified">275             return getList(t -&gt; !t.isEvent &amp;&amp; t.supportStruct);</span>
276         }
277 
<a name="27" id="anc27"></a><span class="line-modified">278         void verify() {</span>
279             for (TypeElement t : types.values()) {
280                 for (FieldElement f : t.fields) {
281                     if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
282                         if (!types.containsKey(f.typeName)) {
<a name="28" id="anc28"></a><span class="line-modified">283                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName</span>
<span class="line-added">284                                     + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);</span>
285                         }
286                     }
287                 }
288             }
289         }
290 
291         void wireUpTypes() {
<a name="29" id="anc29"></a><span class="line-added">292             // Add Java primitives</span>
<span class="line-added">293             for (var t : xmlTypes.entrySet()) {</span>
<span class="line-added">294                 String name = t.getKey();</span>
<span class="line-added">295                 XmlType xmlType = t.getValue();</span>
<span class="line-added">296                 // Excludes Thread and Class</span>
<span class="line-added">297                 if (!types.containsKey(name)) {</span>
<span class="line-added">298                     // Excludes u8, u4, u2, u1, Ticks and Ticksspan</span>
<span class="line-added">299                     if (!xmlType.javaType.isEmpty() &amp;&amp; !xmlType.unsigned) {</span>
<span class="line-added">300                         TypeElement te = new TypeElement();</span>
<span class="line-added">301                         te.name = name;</span>
<span class="line-added">302                         te.javaType = xmlType.javaType;</span>
<span class="line-added">303                         te.primitive = true;</span>
<span class="line-added">304                         types.put(te.name, te);</span>
<span class="line-added">305                     }</span>
<span class="line-added">306                 }</span>
<span class="line-added">307             }</span>
<span class="line-added">308             // Setup Java fully qualified names</span>
<span class="line-added">309             for (TypeElement t : types.values()) {</span>
<span class="line-added">310                 if (t.isEvent) {</span>
<span class="line-added">311                     t.javaType = &quot;jdk.&quot; + t.name;</span>
<span class="line-added">312                 } else {</span>
<span class="line-added">313                     XmlType xmlType = xmlTypes.get(t.name);</span>
<span class="line-added">314                     if (xmlType != null &amp;&amp; !xmlType.javaType.isEmpty()) {</span>
<span class="line-added">315                         t.javaType = xmlType.javaType;</span>
<span class="line-added">316                     } else {</span>
<span class="line-added">317                         t.javaType = &quot;jdk.types.&quot; + t.name;</span>
<span class="line-added">318                     }</span>
<span class="line-added">319                 }</span>
<span class="line-added">320             }</span>
<span class="line-added">321             // Setup content type, annotation, constant pool etc. for fields.</span>
322             for (TypeElement t : types.values()) {
323                 for (FieldElement f : t.fields) {
324                     TypeElement type = types.get(f.typeName);
<a name="30" id="anc30"></a><span class="line-added">325                     XmlType xmlType = xmlTypes.get(f.typeName);</span>
<span class="line-added">326                     if (type == null) {</span>
<span class="line-added">327                         if (xmlType == null) {</span>
<span class="line-added">328                             throw new IllegalStateException(&quot;Unknown type&quot;);</span>
<span class="line-added">329                         }</span>
<span class="line-added">330                         if (f.contentType.isEmpty()) {</span>
<span class="line-added">331                             f.contentType = xmlType.contentType;</span>
<span class="line-added">332                         }</span>
<span class="line-added">333                         String javaType = xmlType.javaType;</span>
<span class="line-added">334                         type = types.get(javaType);</span>
<span class="line-added">335                         Objects.requireNonNull(type);</span>
<span class="line-added">336                     }</span>
<span class="line-added">337                     if (type.primitive) {</span>
<span class="line-added">338                         f.constantPool = false;</span>
<span class="line-added">339                     }</span>
<span class="line-added">340 </span>
<span class="line-added">341                     if (xmlType != null) {</span>
<span class="line-added">342                         f.unsigned = xmlType.unsigned;</span>
<span class="line-added">343                     }</span>
<span class="line-added">344 </span>
345                     if (f.struct) {
<a name="31" id="anc31"></a><span class="line-added">346                         f.constantPool = false;</span>
347                         type.supportStruct = true;
348                     }
349                     f.type = type;
<a name="32" id="anc32"></a><span class="line-added">350                     XmlContentType xmlContentType = xmlContentTypes.get(f.contentType);</span>
<span class="line-added">351                     if (xmlContentType == null) {</span>
<span class="line-added">352                         f.annotations = &quot;&quot;;</span>
<span class="line-added">353                     } else {</span>
<span class="line-added">354                         f.annotations = xmlContentType.annotation;</span>
<span class="line-added">355                     }</span>
<span class="line-added">356                     if (!f.relation.isEmpty()) {</span>
<span class="line-added">357                         f.relation = &quot;jdk.types.&quot; + f.relation;</span>
<span class="line-added">358                     }</span>
359                 }
360             }
<a name="33" id="anc33"></a><span class="line-added">361 </span>
<span class="line-added">362             // Low numbers for event so most of them</span>
<span class="line-added">363             // can fit in one byte with compressed integers</span>
<span class="line-added">364             eventCounter = new TypeCounter(RESERVED_EVENT_COUNT);</span>
<span class="line-added">365             for (TypeElement t : getEvents()) {</span>
<span class="line-added">366                 t.id = eventCounter.next();</span>
<span class="line-added">367             }</span>
<span class="line-added">368             typeCounter = new TypeCounter(eventCounter.last + 1);</span>
<span class="line-added">369             for (TypeElement t : getTypes()) {</span>
<span class="line-added">370                 t.id = typeCounter.next();</span>
<span class="line-added">371             }</span>
372         }
<a name="34" id="anc34"></a>
373 
<a name="35" id="anc35"></a><span class="line-modified">374         public String getName(long id) {</span>
<span class="line-modified">375             for (TypeElement t : types.values()) {</span>
<span class="line-modified">376                 if (t.id == id) {</span>
<span class="line-modified">377                     return t.name;</span>
<span class="line-modified">378                 }</span>
<span class="line-modified">379             }</span>
<span class="line-modified">380             throw new IllegalStateException(&quot;Unexpected id &quot; + id );</span>
<span class="line-modified">381         }</span>
382     }
383 
384     static class FieldElement {
385         final Metadata metadata;
386         TypeElement type;
387         String name;
388         String typeName;
<a name="36" id="anc36"></a><span class="line-modified">389         boolean constantPool = true;</span>
<span class="line-added">390         public String transition;</span>
<span class="line-added">391         public String contentType;</span>
<span class="line-added">392         private String label;</span>
<span class="line-added">393         private String description;</span>
<span class="line-added">394         private String relation;</span>
<span class="line-added">395         private boolean experimental;</span>
<span class="line-added">396         private boolean unsigned;</span>
<span class="line-added">397         private boolean array;</span>
<span class="line-added">398         private String annotations;</span>
<span class="line-added">399         public boolean struct;</span>
400 
401         FieldElement(Metadata metadata) {
402             this.metadata = metadata;
403         }
404 
<a name="37" id="anc37"></a><span class="line-added">405         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-added">406             pos.writeUTF(name);</span>
<span class="line-added">407             pos.writeUTF(type.javaType);</span>
<span class="line-added">408             pos.writeUTF(label);</span>
<span class="line-added">409             pos.writeUTF(description);</span>
<span class="line-added">410             pos.writeBoolean(constantPool);</span>
<span class="line-added">411             pos.writeBoolean(array);</span>
<span class="line-added">412             pos.writeBoolean(unsigned);</span>
<span class="line-added">413             pos.writeUTF(annotations);</span>
<span class="line-added">414             pos.writeUTF(transition);</span>
<span class="line-added">415             pos.writeUTF(relation);</span>
<span class="line-added">416             pos.writeBoolean(experimental);</span>
<span class="line-added">417         }</span>
<span class="line-added">418 </span>
419         String getParameterType() {
420             if (struct) {
421                 return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
422             }
423             XmlType xmlType = metadata.xmlTypes.get(typeName);
424             if (xmlType != null) {
425                 return xmlType.parameterType;
426             }
427             return type != null ? &quot;u8&quot; : typeName;
428         }
429 
430         String getParameterName() {
431             return struct ? &quot;value&quot; : &quot;new_value&quot;;
432         }
433 
434         String getFieldType() {
435             if (struct) {
436                 return &quot;JfrStruct&quot; + typeName;
437             }
438             XmlType xmlType = metadata.xmlTypes.get(typeName);
439             if (xmlType != null) {
440                 return xmlType.fieldType;
441             }
442             return type != null ? &quot;u8&quot; : typeName;
443         }
444     }
445 
446     static class MetadataHandler extends DefaultHandler {
447         final Metadata metadata;
448         FieldElement currentField;
449         TypeElement currentType;
<a name="38" id="anc38"></a><span class="line-added">450 </span>
451         MetadataHandler(Metadata metadata) {
452             this.metadata = metadata;
453         }
<a name="39" id="anc39"></a><span class="line-added">454 </span>
455         @Override
456         public void error(SAXParseException e) throws SAXException {
<a name="40" id="anc40"></a><span class="line-modified">457             throw e;</span>
458         }
<a name="41" id="anc41"></a><span class="line-added">459 </span>
460         @Override
<a name="42" id="anc42"></a><span class="line-modified">461         public void startElement(String uri, String localName, String qName, Attributes attributes)</span>
<span class="line-added">462                 throws SAXException {</span>
463             switch (qName) {
<a name="43" id="anc43"></a><span class="line-added">464             case &quot;XmlContentType&quot;:</span>
<span class="line-added">465                 String n = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-added">466                 String a = attributes.getValue(&quot;annotation&quot;); // mandatory</span>
<span class="line-added">467                 metadata.xmlContentTypes.put(n, new XmlContentType(n, a));</span>
<span class="line-added">468                 break;</span>
469             case &quot;XmlType&quot;:
<a name="44" id="anc44"></a><span class="line-modified">470                 String name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-modified">471                 String parameterType = attributes.getValue(&quot;parameterType&quot;); // mandatory</span>
<span class="line-modified">472                 String fieldType = attributes.getValue(&quot;fieldType&quot;); // mandatory</span>
<span class="line-modified">473                 String javaType = getString(attributes, &quot;javaType&quot;);</span>
<span class="line-added">474                 String contentType = getString(attributes, &quot;contentType&quot;);</span>
475                 boolean unsigned = getBoolean(attributes, &quot;unsigned&quot;, false);
<a name="45" id="anc45"></a><span class="line-modified">476                 metadata.xmlTypes.put(name,</span>
<span class="line-added">477                         new XmlType(name, fieldType, parameterType, javaType, contentType, unsigned));</span>
478                 break;
479             case &quot;Relation&quot;:
480             case &quot;Type&quot;:
<a name="46" id="anc46"></a>


481             case &quot;Event&quot;:
<a name="47" id="anc47"></a><span class="line-modified">482                 currentType = new TypeElement();</span>
<span class="line-modified">483                 currentType.name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-modified">484                 currentType.label = getString(attributes, &quot;label&quot;);</span>
<span class="line-modified">485                 currentType.description = getString(attributes, &quot;description&quot;);</span>
<span class="line-modified">486                 currentType.category = getString(attributes, &quot;category&quot;);</span>
<span class="line-modified">487                 currentType.experimental = getBoolean(attributes, &quot;experimental&quot;, false);</span>
<span class="line-modified">488                 currentType.thread = getBoolean(attributes, &quot;thread&quot;, false);</span>
<span class="line-modified">489                 currentType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);</span>
<span class="line-modified">490                 currentType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);</span>
<span class="line-added">491                 currentType.period = getString(attributes, &quot;period&quot;);</span>
<span class="line-added">492                 currentType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);</span>
<span class="line-added">493                 currentType.commitState = getString(attributes, &quot;commitState&quot;);</span>
<span class="line-added">494                 currentType.isEvent = &quot;Event&quot;.equals(qName);</span>
<span class="line-added">495                 currentType.isRelation = &quot;Relation&quot;.equals(qName);</span>
496                 break;
497             case &quot;Field&quot;:
498                 currentField = new FieldElement(metadata);
<a name="48" id="anc48"></a><span class="line-added">499                 currentField.name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-added">500                 currentField.typeName = attributes.getValue(&quot;type&quot;); // mandatory</span>
<span class="line-added">501                 currentField.label = getString(attributes, &quot;label&quot;);</span>
<span class="line-added">502                 currentField.description = getString(attributes, &quot;description&quot;);</span>
<span class="line-added">503                 currentField.contentType = getString(attributes, &quot;contentType&quot;);</span>
504                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
<a name="49" id="anc49"></a><span class="line-modified">505                 currentField.array = getBoolean(attributes, &quot;array&quot;, false);</span>
<span class="line-modified">506                 currentField.transition = getString(attributes, &quot;transition&quot;);</span>
<span class="line-added">507                 currentField.relation = getString(attributes, &quot;relation&quot;);</span>
<span class="line-added">508                 currentField.experimental = getBoolean(attributes, &quot;experimental&quot;, false);</span>
509                 break;
510             }
511         }
512 
<a name="50" id="anc50"></a><span class="line-modified">513         private static String getString(Attributes attributes, String name) {</span>
<span class="line-added">514             String value = attributes.getValue(name);</span>
<span class="line-added">515             return value != null ? value : &quot;&quot;;</span>
<span class="line-added">516         }</span>
<span class="line-added">517 </span>
<span class="line-added">518         private static boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {</span>
519             String value = attributes.getValue(name);
520             return value == null ? defaultValue : Boolean.valueOf(value);
521         }
522 
523         @Override
524         public void endElement(String uri, String localName, String qName) {
525             switch (qName) {
526             case &quot;Relation&quot;:
527             case &quot;Type&quot;:
528             case &quot;Event&quot;:
529                 metadata.types.put(currentType.name, currentType);
530                 currentType = null;
531                 break;
532             case &quot;Field&quot;:
533                 currentType.fields.add(currentField);
534                 currentField = null;
535                 break;
536             }
537         }
538     }
539 
<a name="51" id="anc51"></a><span class="line-modified">540     static class Printer implements Closeable {</span>
541         final PrintStream out;
<a name="52" id="anc52"></a><span class="line-modified">542 </span>
<span class="line-modified">543         Printer(File outputFile) throws FileNotFoundException {</span>
<span class="line-added">544             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(outputFile)));</span>
545             write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
546             write(&quot;&quot;);
547         }
548 
549         void write(String text) {
550             out.print(text);
551             out.print(&quot;\n&quot;); // Don&#39;t use Windows line endings
552         }
553 
554         @Override
<a name="53" id="anc53"></a><span class="line-modified">555         public void close() throws IOException {</span>
556             out.close();
557         }
558     }
559 
<a name="54" id="anc54"></a><span class="line-modified">560     private static void printJfrPeriodicHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">561         try (var out = new Printer(outputFile)) {</span>
562             out.write(&quot;#ifndef JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
563             out.write(&quot;#define JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
564             out.write(&quot;&quot;);
565             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
566             out.write(&quot;#if INCLUDE_JFR&quot;);
567             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
568             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
569             out.write(&quot;&quot;);
570             out.write(&quot;class JfrPeriodicEventSet : public AllStatic {&quot;);
571             out.write(&quot; public:&quot;);
572             out.write(&quot;  static void requestEvent(JfrEventId id) {&quot;);
573             out.write(&quot;    switch(id) {&quot;);
574             out.write(&quot;  &quot;);
<a name="55" id="anc55"></a><span class="line-modified">575             for (TypeElement e : metadata.getPeriodicEvents()) {</span>
576                 out.write(&quot;      case Jfr&quot; + e.name + &quot;Event:&quot;);
577                 out.write(&quot;        request&quot; + e.name + &quot;();&quot;);
578                 out.write(&quot;        break;&quot;);
579                 out.write(&quot;  &quot;);
580             }
581             out.write(&quot;      default:&quot;);
582             out.write(&quot;        break;&quot;);
583             out.write(&quot;      }&quot;);
584             out.write(&quot;    }&quot;);
585             out.write(&quot;&quot;);
586             out.write(&quot; private:&quot;);
587             out.write(&quot;&quot;);
<a name="56" id="anc56"></a><span class="line-modified">588             for (TypeElement e : metadata.getPeriodicEvents()) {</span>
589                 out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
590                 out.write(&quot;&quot;);
591             }
592             out.write(&quot;};&quot;);
593             out.write(&quot;&quot;);
594             out.write(&quot;#endif // INCLUDE_JFR&quot;);
595             out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
596         }
597     }
598 
<a name="57" id="anc57"></a><span class="line-modified">599     private static void printJfrEventControlHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">600         try (var out = new Printer(outputFile)) {</span>
601             out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
602             out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
603             out.write(&quot;&quot;);
604             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
605             out.write(&quot;#if INCLUDE_JFR&quot;);
606             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
607             out.write(&quot;&quot;);
608             out.write(&quot;/**&quot;);
609             out.write(&quot; * Event setting. We add some padding so we can use our&quot;);
610             out.write(&quot; * event IDs as indexes into this.&quot;);
611             out.write(&quot; */&quot;);
612             out.write(&quot;&quot;);
613             out.write(&quot;struct jfrNativeEventSetting {&quot;);
614             out.write(&quot;  jlong  threshold_ticks;&quot;);
615             out.write(&quot;  jlong  cutoff_ticks;&quot;);
616             out.write(&quot;  u1     stacktrace;&quot;);
617             out.write(&quot;  u1     enabled;&quot;);
618             out.write(&quot;  u1     large;&quot;);
619             out.write(&quot;  u1     pad[5]; // Because GCC on linux ia32 at least tries to pack this.&quot;);
620             out.write(&quot;};&quot;);
621             out.write(&quot;&quot;);
622             out.write(&quot;union JfrNativeSettings {&quot;);
623             out.write(&quot;  // Array version.&quot;);
624             out.write(&quot;  jfrNativeEventSetting bits[NUMBER_OF_EVENTS];&quot;);
625             out.write(&quot;  // Then, to make it easy to debug,&quot;);
626             out.write(&quot;  // add named struct members also.&quot;);
627             out.write(&quot;  struct {&quot;);
628             out.write(&quot;    jfrNativeEventSetting pad[NUMBER_OF_RESERVED_EVENTS];&quot;);
629             for (TypeElement t : metadata.getEventsAndStructs()) {
630                 out.write(&quot;    jfrNativeEventSetting &quot; + t.name + &quot;;&quot;);
631             }
632             out.write(&quot;  } ev;&quot;);
633             out.write(&quot;};&quot;);
634             out.write(&quot;&quot;);
635             out.write(&quot;#endif // INCLUDE_JFR&quot;);
636             out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
637         }
638     }
639 
<a name="58" id="anc58"></a><span class="line-modified">640     private static void printJfrEventIdsHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">641         try (var out = new Printer(outputFile)) {</span>
642             out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
643             out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
644             out.write(&quot;&quot;);
645             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
646             out.write(&quot;#if INCLUDE_JFR&quot;);
647             out.write(&quot;&quot;);
648             out.write(&quot;enum JfrEventId {&quot;);
649             out.write(&quot;  JfrMetadataEvent = 0,&quot;);
650             out.write(&quot;  JfrCheckpointEvent = 1,&quot;);
651             for (TypeElement t : metadata.getEvents()) {
<a name="59" id="anc59"></a><span class="line-modified">652                 out.write(&quot;  &quot; + jfrEventId(t.name) + &quot; = &quot; + t.id + &quot;,&quot;);</span>

653             }
654             out.write(&quot;};&quot;);
655             out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
656             out.write(&quot;&quot;);
<a name="60" id="anc60"></a><span class="line-modified">657             String first = metadata.getName(metadata.eventCounter.first);</span>
<span class="line-modified">658             String last = metadata.getName(metadata.eventCounter.last);</span>
<span class="line-modified">659             out.write(&quot;static const JfrEventId FIRST_EVENT_ID = &quot; + jfrEventId(first) + &quot;;&quot;);</span>
<span class="line-modified">660             out.write(&quot;static const JfrEventId LAST_EVENT_ID = &quot; + jfrEventId(last) + &quot;;&quot;);</span>
<span class="line-added">661             out.write(&quot;static const int NUMBER_OF_EVENTS = &quot; + metadata.eventCounter.count + &quot;;&quot;);</span>
<span class="line-added">662             out.write(&quot;static const int NUMBER_OF_RESERVED_EVENTS = &quot; + Metadata.RESERVED_EVENT_COUNT + &quot;;&quot;);</span>
663             out.write(&quot;#endif // INCLUDE_JFR&quot;);
664             out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
665         }
666     }
667 
<a name="61" id="anc61"></a><span class="line-modified">668     private static String jfrEventId(String name) {</span>
<span class="line-modified">669         return &quot;Jfr&quot; + name + &quot;Event&quot;;</span>
<span class="line-added">670     }</span>
<span class="line-added">671 </span>
<span class="line-added">672     private static void printJfrTypesHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-added">673         try (var out = new Printer(outputFile)) {</span>
674             out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
675             out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
676             out.write(&quot;&quot;);
677             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
678             out.write(&quot;#if INCLUDE_JFR&quot;);
679             out.write(&quot;&quot;);
680             out.write(&quot;#include &lt;string.h&gt;&quot;);
681             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
682             out.write(&quot;&quot;);
683             out.write(&quot;enum JfrTypeId {&quot;);
<a name="62" id="anc62"></a>










684             for (TypeElement type : metadata.getTypes()) {
<a name="63" id="anc63"></a><span class="line-modified">685                 out.write(&quot;  &quot; + jfrTypeId(type.name) + &quot; = &quot; + type.id + &quot;,&quot;);</span>





686             }
687             out.write(&quot;};&quot;);
688             out.write(&quot;&quot;);
<a name="64" id="anc64"></a><span class="line-modified">689             String first = metadata.getName(metadata.typeCounter.first);</span>
<span class="line-modified">690             String last = metadata.getName(metadata.typeCounter.last);</span>
<span class="line-modified">691             out.write(&quot;static const JfrTypeId FIRST_TYPE_ID = &quot; + jfrTypeId(first) + &quot;;&quot;);</span>
<span class="line-added">692             out.write(&quot;static const JfrTypeId LAST_TYPE_ID = &quot; + jfrTypeId(last) + &quot;;&quot;);</span>
693             out.write(&quot;&quot;);
694             out.write(&quot;class JfrType : public AllStatic {&quot;);
695             out.write(&quot; public:&quot;);
696             out.write(&quot;  static jlong name_to_id(const char* type_name) {&quot;);
<a name="65" id="anc65"></a><span class="line-modified">697 </span>
<span class="line-modified">698             Map&lt;String, XmlType&gt; javaTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-added">699             for (XmlType xmlType : metadata.xmlTypes.values()) {</span>
<span class="line-added">700                 if (!xmlType.javaType.isEmpty()) {</span>
<span class="line-added">701                     javaTypes.put(xmlType.javaType, xmlType);</span>
<span class="line-added">702                 }</span>
<span class="line-added">703             }</span>
<span class="line-added">704             for (XmlType xmlType : javaTypes.values()) {</span>
705                 String javaName = xmlType.javaType;
706                 String typeName = xmlType.name.toUpperCase();
707                 out.write(&quot;    if (strcmp(type_name, \&quot;&quot; + javaName + &quot;\&quot;) == 0) {&quot;);
708                 out.write(&quot;      return TYPE_&quot; + typeName + &quot;;&quot;);
709                 out.write(&quot;    }&quot;);
710             }
711             out.write(&quot;    return -1;&quot;);
712             out.write(&quot;  }&quot;);
713             out.write(&quot;};&quot;);
714             out.write(&quot;&quot;);
715             out.write(&quot;#endif // INCLUDE_JFR&quot;);
716             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
717         }
<a name="66" id="anc66"></a>
718     }
719 
<a name="67" id="anc67"></a><span class="line-modified">720     private static String jfrTypeId(String name) {</span>
<span class="line-modified">721         return  &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-added">722     }</span>
<span class="line-added">723 </span>
<span class="line-added">724     private static void printJfrEventClassesHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-added">725         try (var out = new Printer(outputFile)) {</span>
726             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
727             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
728             out.write(&quot;&quot;);
729             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
730             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
731             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
732             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
733             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
734             out.write(&quot;#if INCLUDE_JFR&quot;);
735             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
736             out.write(&quot;#include \&quot;jfr/support/jfrEpochSynchronization.hpp\&quot;&quot;);
737             out.write(&quot;/*&quot;);
738             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
739             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
740             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
741             out.write(&quot; * and set before attempting to commit.&quot;);
742             out.write(&quot; *&quot;);
743             out.write(&quot; * We enforce this requirement because events are generally stack allocated and therefore&quot;);
744             out.write(&quot; * *not* initialized to default values. This prevents us from inadvertently committing&quot;);
745             out.write(&quot; * uninitialized values to the data stream.&quot;);
746             out.write(&quot; *&quot;);
747             out.write(&quot; * The assert message contains both the index (zero based) as well as the name of the field.&quot;);
748             out.write(&quot; */&quot;);
749             out.write(&quot;&quot;);
750             printTypes(out, metadata, false);
751             out.write(&quot;&quot;);
752             out.write(&quot;&quot;);
753             out.write(&quot;#else // !INCLUDE_JFR&quot;);
754             out.write(&quot;&quot;);
755             out.write(&quot;template &lt;typename T&gt;&quot;);
756             out.write(&quot;class JfrEvent {&quot;);
757             out.write(&quot; public:&quot;);
758             out.write(&quot;  JfrEvent() {}&quot;);
759             out.write(&quot;  void set_starttime(const Ticks&amp;) const {}&quot;);
760             out.write(&quot;  void set_endtime(const Ticks&amp;) const {}&quot;);
761             out.write(&quot;  bool should_commit() const { return false; }&quot;);
762             out.write(&quot;  static bool is_enabled() { return false; }&quot;);
763             out.write(&quot;  void commit() {}&quot;);
764             out.write(&quot;};&quot;);
765             out.write(&quot;&quot;);
766             printTypes(out, metadata, true);
767             out.write(&quot;&quot;);
768             out.write(&quot;&quot;);
769             out.write(&quot;#endif // INCLUDE_JFR&quot;);
770             out.write(&quot;#endif // JFRFILES_JFREVENTCLASSES_HPP&quot;);
771         }
772     }
773 
774     private static void printTypes(Printer out, Metadata metadata, boolean empty) {
775         for (TypeElement t : metadata.getStructs()) {
776             printType(out, t, empty);
777             out.write(&quot;&quot;);
778         }
<a name="68" id="anc68"></a><span class="line-modified">779         for (TypeElement e : metadata.getEvents()) {</span>
780             printEvent(out, e, empty);
781             out.write(&quot;&quot;);
782         }
783     }
784 
785     private static void printType(Printer out, TypeElement t, boolean empty) {
786         out.write(&quot;struct JfrStruct&quot; + t.name);
787         out.write(&quot;{&quot;);
788         if (!empty) {
<a name="69" id="anc69"></a><span class="line-modified">789             out.write(&quot; private:&quot;);</span>
<span class="line-modified">790             for (FieldElement f : t.fields) {</span>
<span class="line-modified">791                 printField(out, f);</span>
<span class="line-modified">792             }</span>
<span class="line-modified">793             out.write(&quot;&quot;);</span>
794         }
795         out.write(&quot; public:&quot;);
796         for (FieldElement f : t.fields) {
<a name="70" id="anc70"></a><span class="line-modified">797             printTypeSetter(out, f, empty);</span>
798         }
799         out.write(&quot;&quot;);
800         if (!empty) {
<a name="71" id="anc71"></a><span class="line-modified">801             printWriteData(out, t);</span>
802         }
803         out.write(&quot;};&quot;);
804         out.write(&quot;&quot;);
805     }
806 
<a name="72" id="anc72"></a><span class="line-modified">807     private static void printEvent(Printer out, TypeElement event, boolean empty) {</span>
808         out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
809         out.write(&quot;{&quot;);
810         if (!empty) {
<a name="73" id="anc73"></a><span class="line-modified">811             out.write(&quot; private:&quot;);</span>
<span class="line-modified">812             for (FieldElement f : event.fields) {</span>
<span class="line-modified">813                 printField(out, f);</span>
<span class="line-modified">814             }</span>
<span class="line-modified">815             out.write(&quot;&quot;);</span>
816         }
817         out.write(&quot; public:&quot;);
818         if (!empty) {
<a name="74" id="anc74"></a><span class="line-modified">819             out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);</span>
<span class="line-modified">820             out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);</span>
<span class="line-modified">821             out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);</span>
<span class="line-modified">822             out.write(&quot;  static const bool hasCutoff = &quot; + event.cutoff + &quot;;&quot;);</span>
<span class="line-modified">823             out.write(&quot;  static const bool isRequestable = &quot; + !event.period.isEmpty() + &quot;;&quot;);</span>
<span class="line-modified">824             out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);</span>
<span class="line-modified">825             out.write(&quot;&quot;);</span>
826         }
827         if (!empty) {
<a name="75" id="anc75"></a><span class="line-modified">828             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name</span>
<span class="line-added">829                     + &quot;&gt;(timing) {}&quot;);</span>
830         } else {
<a name="76" id="anc76"></a><span class="line-modified">831             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);</span>
832         }
833         out.write(&quot;&quot;);
834         int index = 0;
835         for (FieldElement f : event.fields) {
836             out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
837             if (!empty) {
<a name="77" id="anc77"></a><span class="line-modified">838                 out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);</span>
<span class="line-modified">839                 out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);</span>
840             }
841             out.write(&quot;  }&quot;);
842         }
843         out.write(&quot;&quot;);
844         if (!empty) {
<a name="78" id="anc78"></a><span class="line-modified">845             printWriteData(out, event);</span>
<span class="line-modified">846             out.write(&quot;&quot;);</span>
847         }
<a name="79" id="anc79"></a><span class="line-modified">848         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name</span>
<span class="line-added">849                 + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);</span>
850         printConstructor2(out, event, empty);
851         printCommitMethod(out, event, empty);
852         if (!empty) {
<a name="80" id="anc80"></a><span class="line-modified">853             printVerify(out, event.fields);</span>
854         }
855         out.write(&quot;};&quot;);
856     }
857 
<a name="81" id="anc81"></a><span class="line-modified">858     private static void printWriteData(Printer out, TypeElement type) {</span>
859         out.write(&quot;  template &lt;typename Writer&gt;&quot;);
860         out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
<a name="82" id="anc82"></a><span class="line-modified">861         if ((&quot;_thread_in_native&quot;).equals(type.commitState)) {</span>
862             out.write(&quot;    // explicit epoch synchronization check&quot;);
863             out.write(&quot;    JfrEpochSynchronization sync;&quot;);
864         }
<a name="83" id="anc83"></a><span class="line-modified">865         for (FieldElement field : type.fields) {</span>
866             if (field.struct) {
867                 out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
868             } else {
869                 out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
870             }
871         }
872         out.write(&quot;  }&quot;);
873     }
874 
875     private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
876         if (!empty) {
<a name="84" id="anc84"></a><span class="line-modified">877             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name</span>
<span class="line-added">878                     + &quot; = new_value; }&quot;);</span>
879         } else {
<a name="85" id="anc85"></a><span class="line-modified">880             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);</span>
881         }
882     }
883 
884     private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
885         out.write(&quot;&quot;);
886         out.write(&quot;#ifdef ASSERT&quot;);
887         out.write(&quot;  void verify() const {&quot;);
888         int index = 0;
889         for (FieldElement f : fields) {
<a name="86" id="anc86"></a><span class="line-modified">890             out.write(&quot;    assert(verify_field_bit(&quot; + index++</span>
<span class="line-added">891                     + &quot;), \&quot;Attempting to write an uninitialized event field: %s\&quot;, \&quot;_&quot; + f.name + &quot;\&quot;);&quot;);</span>
892         }
893         out.write(&quot;  }&quot;);
894         out.write(&quot;#endif&quot;);
895     }
896 
<a name="87" id="anc87"></a><span class="line-modified">897     private static void printCommitMethod(Printer out, TypeElement event, boolean empty) {</span>
898         if (event.startTime) {
899             StringJoiner sj = new StringJoiner(&quot;,\n              &quot;);
900             for (FieldElement f : event.fields) {
901                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
902             }
903             out.write(&quot;&quot;);
904             out.write(&quot;  void commit(&quot; + sj.toString() + &quot;) {&quot;);
905             if (!empty) {
<a name="88" id="anc88"></a><span class="line-modified">906                 out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">907                 for (FieldElement f : event.fields) {</span>
<span class="line-modified">908                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">909                 }</span>
<span class="line-modified">910                 out.write(&quot;      commit();&quot;);</span>
<span class="line-modified">911                 out.write(&quot;    }&quot;);</span>
912             }
913             out.write(&quot;  }&quot;);
914         }
915 
916         // Avoid clash with static commit() method
917         if (event.fields.isEmpty()) {
918             return;
919         }
920 
921         out.write(&quot;&quot;);
922         StringJoiner sj = new StringJoiner(&quot;,\n                     &quot;);
923         if (event.startTime) {
924             sj.add(&quot;const Ticks&amp; startTicks&quot;);
925             sj.add(&quot;const Ticks&amp; endTicks&quot;);
926         }
927         for (FieldElement f : event.fields) {
928             sj.add(f.getParameterType() + &quot; &quot; + f.name);
929         }
930         out.write(&quot;  static void commit(&quot; + sj.toString() + &quot;) {&quot;);
931         if (!empty) {
<a name="89" id="anc89"></a><span class="line-modified">932             out.write(&quot;    Event&quot; + event.name + &quot; me(UNTIMED);&quot;);</span>
<span class="line-modified">933             out.write(&quot;&quot;);</span>
<span class="line-modified">934             out.write(&quot;    if (me.should_commit()) {&quot;);</span>
<span class="line-modified">935             if (event.startTime) {</span>
<span class="line-modified">936                 out.write(&quot;      me.set_starttime(startTicks);&quot;);</span>
<span class="line-modified">937                 out.write(&quot;      me.set_endtime(endTicks);&quot;);</span>
<span class="line-modified">938             }</span>
<span class="line-modified">939             for (FieldElement f : event.fields) {</span>
<span class="line-modified">940                 out.write(&quot;      me.set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">941             }</span>
<span class="line-modified">942             out.write(&quot;      me.commit();&quot;);</span>
<span class="line-modified">943             out.write(&quot;    }&quot;);</span>
944         }
945         out.write(&quot;  }&quot;);
946     }
947 
<a name="90" id="anc90"></a><span class="line-modified">948     private static void printConstructor2(Printer out, TypeElement event, boolean empty) {</span>
949         if (!event.startTime) {
950             out.write(&quot;&quot;);
951             out.write(&quot;&quot;);
952         }
953         if (event.startTime) {
954             out.write(&quot;&quot;);
955             out.write(&quot;  Event&quot; + event.name + &quot;(&quot;);
956             StringJoiner sj = new StringJoiner(&quot;,\n    &quot;);
957             for (FieldElement f : event.fields) {
958                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
959             }
960             if (!empty) {
<a name="91" id="anc91"></a><span class="line-modified">961                 out.write(&quot;    &quot; + sj.toString() + &quot;) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(TIMED) {&quot;);</span>
<span class="line-modified">962                 out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">963                 for (FieldElement f : event.fields) {</span>
<span class="line-modified">964                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">965                 }</span>
<span class="line-modified">966                 out.write(&quot;    }&quot;);</span>
967             } else {
<a name="92" id="anc92"></a><span class="line-modified">968                 out.write(&quot;    &quot; + sj.toString() + &quot;) {&quot;);</span>
969             }
970             out.write(&quot;  }&quot;);
971         }
972     }
973 
974     private static void printField(Printer out, FieldElement field) {
975         out.write(&quot;  &quot; + field.getFieldType() + &quot; _&quot; + field.name + &quot;;&quot;);
976     }
977 }
<a name="93" id="anc93"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="93" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New make/langtools/src/classes/build/tools/symbolgenerator/CreateSymbols.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.symbolgenerator;
  27 
  28 import build.tools.symbolgenerator.CreateSymbols
  29                                   .ModuleHeaderDescription
  30                                   .ProvidesDescription;
  31 import build.tools.symbolgenerator.CreateSymbols
  32                                   .ModuleHeaderDescription
  33                                   .RequiresDescription;
  34 import java.io.BufferedInputStream;
  35 import java.io.BufferedReader;
  36 import java.io.BufferedOutputStream;
  37 import java.io.ByteArrayInputStream;
  38 import java.io.ByteArrayOutputStream;
  39 import java.io.File;
  40 import java.io.FileOutputStream;
  41 import java.io.IOException;
  42 import java.io.InputStream;
  43 import java.io.OutputStream;
  44 import java.io.StringWriter;
  45 import java.io.Writer;
  46 import java.nio.file.Files;
  47 import java.nio.file.FileVisitResult;
  48 import java.nio.file.FileVisitor;
  49 import java.nio.file.Path;
  50 import java.nio.file.Paths;
  51 import java.nio.file.attribute.BasicFileAttributes;
  52 import java.util.stream.Stream;
  53 import java.util.ArrayList;
  54 import java.util.Arrays;
  55 import java.util.Calendar;
  56 import java.util.Collection;
  57 import java.util.Collections;
  58 import java.util.Comparator;
  59 import java.util.EnumSet;
  60 import java.util.HashMap;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.List;
  65 import java.util.Locale;
  66 import java.util.Map;
  67 import java.util.Map.Entry;
  68 import java.util.Objects;
  69 import java.util.Set;
  70 import java.util.TimeZone;
  71 import java.util.TreeMap;
  72 import java.util.TreeSet;
  73 import java.util.function.Function;
  74 import java.util.function.Predicate;
  75 import java.util.regex.Matcher;
  76 import java.util.regex.Pattern;
  77 import java.util.stream.Collectors;
  78 import java.util.zip.ZipEntry;
  79 import java.util.zip.ZipOutputStream;
  80 
  81 import javax.tools.JavaFileManager;
  82 import javax.tools.JavaFileManager.Location;
  83 import javax.tools.JavaFileObject;
  84 import javax.tools.JavaFileObject.Kind;
  85 import javax.tools.StandardLocation;
  86 
  87 import com.sun.source.util.JavacTask;
  88 import com.sun.tools.classfile.AccessFlags;
  89 import com.sun.tools.classfile.Annotation;
  90 import com.sun.tools.classfile.Annotation.Annotation_element_value;
  91 import com.sun.tools.classfile.Annotation.Array_element_value;
  92 import com.sun.tools.classfile.Annotation.Class_element_value;
  93 import com.sun.tools.classfile.Annotation.Enum_element_value;
  94 import com.sun.tools.classfile.Annotation.Primitive_element_value;
  95 import com.sun.tools.classfile.Annotation.element_value;
  96 import com.sun.tools.classfile.Annotation.element_value_pair;
  97 import com.sun.tools.classfile.AnnotationDefault_attribute;
  98 import com.sun.tools.classfile.Attribute;
  99 import com.sun.tools.classfile.Attributes;
 100 import com.sun.tools.classfile.ClassFile;
 101 import com.sun.tools.classfile.ClassWriter;
 102 import com.sun.tools.classfile.ConstantPool;
 103 import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;
 104 import com.sun.tools.classfile.ConstantPool.CONSTANT_Double_info;
 105 import com.sun.tools.classfile.ConstantPool.CONSTANT_Float_info;
 106 import com.sun.tools.classfile.ConstantPool.CONSTANT_Integer_info;
 107 import com.sun.tools.classfile.ConstantPool.CONSTANT_Long_info;
 108 import com.sun.tools.classfile.ConstantPool.CONSTANT_Module_info;
 109 import com.sun.tools.classfile.ConstantPool.CONSTANT_Package_info;
 110 import com.sun.tools.classfile.ConstantPool.CONSTANT_String_info;
 111 import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;
 112 import com.sun.tools.classfile.ConstantPool.CPInfo;
 113 import com.sun.tools.classfile.ConstantPool.InvalidIndex;
 114 import com.sun.tools.classfile.ConstantPoolException;
 115 import com.sun.tools.classfile.ConstantValue_attribute;
 116 import com.sun.tools.classfile.Deprecated_attribute;
 117 import com.sun.tools.classfile.Descriptor;
 118 import com.sun.tools.classfile.Exceptions_attribute;
 119 import com.sun.tools.classfile.Field;
 120 import com.sun.tools.classfile.InnerClasses_attribute;
 121 import com.sun.tools.classfile.InnerClasses_attribute.Info;
 122 import com.sun.tools.classfile.Method;
 123 import com.sun.tools.classfile.ModuleResolution_attribute;
 124 import com.sun.tools.classfile.ModuleTarget_attribute;
 125 import com.sun.tools.classfile.Module_attribute;
 126 import com.sun.tools.classfile.Module_attribute.ExportsEntry;
 127 import com.sun.tools.classfile.Module_attribute.OpensEntry;
 128 import com.sun.tools.classfile.Module_attribute.ProvidesEntry;
 129 import com.sun.tools.classfile.Module_attribute.RequiresEntry;
 130 import com.sun.tools.classfile.NestHost_attribute;
 131 import com.sun.tools.classfile.NestMembers_attribute;
 132 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
 133 import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;
 134 import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;
 135 import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;
 136 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
 137 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
 138 import com.sun.tools.classfile.Signature_attribute;
 139 import com.sun.tools.javac.api.JavacTool;
 140 import com.sun.tools.javac.jvm.Target;
 141 import com.sun.tools.javac.util.Assert;
 142 import com.sun.tools.javac.util.Context;
 143 import com.sun.tools.javac.util.Pair;
 144 
 145 /**
 146  * A tool for processing the .sym.txt files.
 147  *
 148  * To add historical data for JDK N, N &gt;= 11, do the following:
 149  *  * cd &lt;open-jdk-checkout&gt;/make/data/symbols
 150  *  * &lt;jdk-N&gt;/bin/java --add-exports jdk.jdeps/com.sun.tools.classfile=ALL-UNNAMED \
 151  *                     --add-exports jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED \
 152  *                     --add-exports jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED \
 153  *                     --add-exports jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED \
 154  *                     --add-modules jdk.jdeps \
 155  *                     ../../../make/langtools/src/classes/build/tools/symbolgenerator/CreateSymbols.java \
 156  *                     build-description-incremental symbols include.list
 157  *  * sanity-check the new and updates files in make/data/symbols and commit them
 158  *
 159  * The tools allows to:
 160  *  * convert the .sym.txt into class/sig files for ct.sym
 161  *  * in cooperation with the adjacent history Probe, construct .sym.txt files for previous platforms
 162  *  * enhance existing .sym.txt files with a a new set .sym.txt for the current platform
 163  *
 164  * To convert the .sym.txt files to class/sig files from ct.sym, run:
 165  *     java build.tool.symbolgenerator.CreateSymbols build-ctsym &lt;platform-description-file&gt; &lt;target-directory&gt;
 166  *
 167  * The &lt;platform-description-file&gt; is a file of this format:
 168  *     generate platforms &lt;platform-ids-to-generate separate with &#39;:&#39;&gt;
 169  *     platform version &lt;platform-id1&gt; files &lt;.sym.txt files containing history data for given platform, separate with &#39;:&#39;&gt;
 170  *     platform version &lt;platform-id2&gt; base &lt;base-platform-id&gt; files &lt;.sym.txt files containing history data for given platform, separate with &#39;:&#39;&gt;
 171  *
 172  * The content of platform &quot;&lt;base-platform-id&gt;&quot; is also automatically added to the content of
 173  * platform &quot;&lt;platform-id2&gt;&quot;, unless explicitly excluded in &quot;&lt;platform-id2&gt;&quot;&#39;s .sym.txt files.
 174  *
 175  * To create the .sym.txt files, first run the history Probe for all the previous platforms:
 176  *     &lt;jdk-N&gt;/bin/java build.tools.symbolgenerator.Probe &lt;classes-for-N&gt;
 177  *
 178  * Where &lt;classes-for-N&gt; is a name of a file into which the classes from the bootclasspath of &lt;jdk-N&gt;
 179  * will be written.
 180  *
 181  * Then create the &lt;platform-description-file&gt; file and the .sym.txt files like this:
 182  *     java build.tools.symbolgenerator.CreateSymbols build-description &lt;target-directory&gt; &lt;path-to-a-JDK-root&gt; &lt;include-list-file&gt;
 183  *                                                    &lt;platform-id1&gt; &lt;target-file-for-platform1&gt; &quot;&lt;none&gt;&quot;
 184  *                                                    &lt;platform-id2&gt; &lt;target-file-for-platform2&gt; &lt;diff-against-platform2&gt;
 185  *                                                    &lt;platform-id3&gt; &lt;target-file-for-platform3&gt; &lt;diff-against-platform3&gt;
 186  *                                                    ...
 187  *
 188  * The &lt;include-list-file&gt; is a file that specifies classes that should be included/excluded.
 189  * Lines that start with &#39;+&#39; represent class or package that should be included, &#39;-&#39; class or package
 190  * that should be excluded. &#39;/&#39; should be used as package name delimiter, packages should end with &#39;/&#39;.
 191  * Several include list files may be specified, separated by File.pathSeparator.
 192  *
 193  * When &lt;diff-against-platformN&gt; is specified, the .sym.txt files for platform N will only contain
 194  * differences between platform N and the specified platform. The first platform (denoted F further)
 195  * that is specified should use literal value &quot;&lt;none&gt;&quot;, to have all the APIs of the platform written to
 196  * the .sym.txt files. If there is an existing platform with full .sym.txt files in the repository,
 197  * that platform should be used as the first platform to avoid unnecessary changes to the .sym.txt
 198  * files. The &lt;diff-against-platformN&gt; for platform N should be determined as follows: if N &lt; F, then
 199  * &lt;diff-against-platformN&gt; should be N + 1. If F &lt; N, then &lt;diff-against-platformN&gt; should be N - 1.
 200  * If N is a custom/specialized sub-version of another platform N&#39;, then &lt;diff-against-platformN&gt; should be N&#39;.
 201  *
 202  * To generate the .sym.txt files for OpenJDK 7 and 8:
 203  *     &lt;jdk-7&gt;/bin/java build.tools.symbolgenerator.Probe OpenJDK7.classes
 204  *     &lt;jdk-8&gt;/bin/java build.tools.symbolgenerator.Probe OpenJDK8.classes
 205  *     java build.tools.symbolgenerator.CreateSymbols build-description make/data/symbols $TOPDIR make/data/symbols/include.list
 206  *                                                    8 OpenJDK8.classes &#39;&lt;none&gt;&#39;
 207  *                                                    7 OpenJDK7.classes 8
 208  *
 209  * Note: the versions are expected to be a single character.
 210  *
 211  */
 212 public class CreateSymbols {
 213 
 214     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;ct.sym construction&quot;&gt;
 215     /**Create sig files for ct.sym reading the classes description from the directory that contains
 216      * {@code ctDescriptionFile}, using the file as a recipe to create the sigfiles.
 217      */
 218     @SuppressWarnings(&quot;unchecked&quot;)
 219     public void createSymbols(String ctDescriptionFileExtra, String ctDescriptionFile, String ctSymLocation,
 220                               long timestamp, String currentVersion, String systemModules) throws IOException {
 221         LoadDescriptions data = load(ctDescriptionFileExtra != null ? Paths.get(ctDescriptionFileExtra)
 222                                                                     : null,
 223                                      Paths.get(ctDescriptionFile), null);
 224 
 225         splitHeaders(data.classes);
 226 
 227         Map&lt;String, Map&lt;Character, String&gt;&gt; package2Version2Module = new HashMap&lt;&gt;();
 228         Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData = new TreeMap&lt;&gt;();
 229 
 230         for (ModuleDescription md : data.modules.values()) {
 231             for (ModuleHeaderDescription mhd : md.header) {
 232                 List&lt;String&gt; versionsList =
 233                         Collections.singletonList(mhd.versions);
 234                 writeModulesForVersions(directory2FileData,
 235                                         md,
 236                                         mhd,
 237                                         versionsList);
 238                 mhd.exports.stream().forEach(pkg -&gt; {
 239                     for (char v : mhd.versions.toCharArray()) {
 240                         package2Version2Module.computeIfAbsent(pkg, dummy -&gt; new HashMap&lt;&gt;()).put(v, md.name);
 241                     }
 242                 });
 243             }
 244         }
 245 
 246         for (ClassDescription classDescription : data.classes) {
 247             Map&lt;Character, String&gt; version2Module = package2Version2Module.getOrDefault(classDescription.packge().replace(&#39;.&#39;, &#39;/&#39;), Collections.emptyMap());
 248             for (ClassHeaderDescription header : classDescription.header) {
 249                 Set&lt;String&gt; jointVersions = new HashSet&lt;&gt;();
 250                 jointVersions.add(header.versions);
 251                 limitJointVersion(jointVersions, classDescription.fields);
 252                 limitJointVersion(jointVersions, classDescription.methods);
 253                 Map&lt;String, StringBuilder&gt; module2Versions = new HashMap&lt;&gt;();
 254                 for (char v : header.versions.toCharArray()) {
 255                     String module = version2Module.get(v);
 256                     if (module == null) {
 257                         if (v &gt;= &#39;9&#39;) {
 258                             throw new AssertionError(&quot;No module for &quot; + classDescription.name +
 259                                                      &quot; and version &quot; + v);
 260                         }
 261                         module = version2Module.get(&#39;9&#39;);
 262                         if (module == null) {
 263                             module = &quot;java.base&quot;;
 264                         }
 265                     }
 266                     module2Versions.computeIfAbsent(module, dummy -&gt; new StringBuilder()).append(v);
 267                 }
 268                 for (Entry&lt;String, StringBuilder&gt; e : module2Versions.entrySet()) {
 269                     Set&lt;String&gt; currentVersions = new HashSet&lt;&gt;(jointVersions);
 270                     limitJointVersion(currentVersions, e.getValue().toString());
 271                     currentVersions = currentVersions.stream().filter(vers -&gt; !disjoint(vers, e.getValue().toString())).collect(Collectors.toSet());
 272                     writeClassesForVersions(directory2FileData, classDescription, header, e.getKey(), currentVersions);
 273                 }
 274             }
 275         }
 276 
 277         currentVersion = Integer.toString(Integer.parseInt(currentVersion), Character.MAX_RADIX);
 278         currentVersion = currentVersion.toUpperCase(Locale.ROOT);
 279 
 280         openDirectory(directory2FileData, currentVersion + &quot;/&quot;)
 281                 .add(new FileData(currentVersion + &quot;/system-modules&quot;,
 282                                   Files.readAllBytes(Paths.get(systemModules))));
 283 
 284         try (OutputStream fos = new FileOutputStream(ctSymLocation);
 285              OutputStream bos = new BufferedOutputStream(fos);
 286              ZipOutputStream jos = new ZipOutputStream(bos)) {
 287             for (Entry&lt;String, Set&lt;FileData&gt;&gt; e : directory2FileData.entrySet()) {
 288                 jos.putNextEntry(createZipEntry(e.getKey(), timestamp));
 289                 for (FileData fd : e.getValue()) {
 290                     jos.putNextEntry(createZipEntry(fd.fileName, timestamp));
 291                     jos.write(fd.fileData);
 292                 }
 293             }
 294         }
 295     }
 296 
 297     private ZipEntry createZipEntry(String name, long timestamp) {
 298         ZipEntry ze = new ZipEntry(name);
 299 
 300         ze.setTime(timestamp);
 301         return ze;
 302     }
 303 
 304     public static String EXTENSION = &quot;.sig&quot;;
 305 
 306     LoadDescriptions load(Path ctDescriptionWithExtraContent, Path ctDescriptionOpen, String deletePlatform) throws IOException {
 307         Map&lt;String, PlatformInput&gt; platforms = new LinkedHashMap&lt;&gt;();
 308 
 309         if (ctDescriptionWithExtraContent != null &amp;&amp; Files.isRegularFile(ctDescriptionWithExtraContent)) {
 310             try (LineBasedReader reader = new LineBasedReader(ctDescriptionWithExtraContent)) {
 311                 while (reader.hasNext()) {
 312                     switch (reader.lineKey) {
 313                         case &quot;generate&quot;:
 314                             //ignore
 315                             reader.moveNext();
 316                             break;
 317                         case &quot;platform&quot;:
 318                             PlatformInput platform = PlatformInput.load(ctDescriptionWithExtraContent,
 319                                                                         reader);
 320                             if (!platform.version.equals(deletePlatform))
 321                                 platforms.put(platform.version, platform);
 322                             reader.moveNext();
 323                             break;
 324                         default:
 325                             throw new IllegalStateException(&quot;Unknown key: &quot; + reader.lineKey);
 326                     }
 327                 }
 328             }
 329         }
 330 
 331         Set&lt;String&gt; generatePlatforms = null;
 332 
 333         try (LineBasedReader reader = new LineBasedReader(ctDescriptionOpen)) {
 334             while (reader.hasNext()) {
 335                 switch (reader.lineKey) {
 336                     case &quot;generate&quot;:
 337                         String[] platformsAttr = reader.attributes.get(&quot;platforms&quot;).split(&quot;:&quot;);
 338                         generatePlatforms = new HashSet&lt;&gt;(List.of(platformsAttr));
 339                         generatePlatforms.remove(deletePlatform);
 340                         reader.moveNext();
 341                         break;
 342                     case &quot;platform&quot;:
 343                         PlatformInput platform = PlatformInput.load(ctDescriptionOpen, reader);
 344                         if (!platform.version.equals(deletePlatform) &amp;&amp;
 345                             !platforms.containsKey(platform.version))
 346                             platforms.put(platform.version, platform);
 347                         reader.moveNext();
 348                         break;
 349                     default:
 350                         throw new IllegalStateException(&quot;Unknown key: &quot; + reader.lineKey);
 351                 }
 352             }
 353         }
 354 
 355         Map&lt;String, ClassDescription&gt; classes = new LinkedHashMap&lt;&gt;();
 356         Map&lt;String, ModuleDescription&gt; modules = new LinkedHashMap&lt;&gt;();
 357 
 358         for (PlatformInput platform : platforms.values()) {
 359             for (ClassDescription cd : classes.values()) {
 360                 addNewVersion(cd.header, platform.basePlatform, platform.version);
 361                 addNewVersion(cd.fields, platform.basePlatform, platform.version);
 362                 addNewVersion(cd.methods, platform.basePlatform, platform.version);
 363             }
 364             for (ModuleDescription md : modules.values()) {
 365                 addNewVersion(md.header, platform.basePlatform, platform.version);
 366             }
 367             for (String input : platform.files) {
 368                 Path inputFile = platform.ctDescription.getParent().resolve(input);
 369                 try (LineBasedReader reader = new LineBasedReader(inputFile)) {
 370                     while (reader.hasNext()) {
 371                         String nameAttr = reader.attributes.get(&quot;name&quot;);
 372                         switch (reader.lineKey) {
 373                             case &quot;class&quot;: case &quot;-class&quot;:
 374                                 ClassDescription cd =
 375                                         classes.computeIfAbsent(nameAttr,
 376                                                 n -&gt; new ClassDescription());
 377                                 if (&quot;-class&quot;.equals(reader.lineKey)) {
 378                                     removeVersion(cd.header, h -&gt; true,
 379                                                   platform.version);
 380                                     reader.moveNext();
 381                                     continue;
 382                                 }
 383                                 cd.read(reader, platform.basePlatform,
 384                                         platform.version);
 385                                 break;
 386                             case &quot;module&quot;: {
 387                                 ModuleDescription md =
 388                                         modules.computeIfAbsent(nameAttr,
 389                                                 n -&gt; new ModuleDescription());
 390                                 md.read(reader, platform.basePlatform,
 391                                         platform.version);
 392                                 break;
 393                             }
 394                             case &quot;-module&quot;: {
 395                                 ModuleDescription md =
 396                                         modules.computeIfAbsent(nameAttr,
 397                                                 n -&gt; new ModuleDescription());
 398                                 removeVersion(md.header, h -&gt; true,
 399                                               platform.version);
 400                                 reader.moveNext();
 401                                 break;
 402                             }
 403                         }
 404                     }
 405                 }
 406             }
 407         }
 408 
 409         ClassList result = new ClassList();
 410 
 411         for (ClassDescription desc : classes.values()) {
 412             Iterator&lt;ClassHeaderDescription&gt; chdIt = desc.header.iterator();
 413 
 414             while (chdIt.hasNext()) {
 415                 ClassHeaderDescription chd = chdIt.next();
 416 
 417                 chd.versions = reduce(chd.versions, generatePlatforms);
 418                 if (chd.versions.isEmpty())
 419                     chdIt.remove();
 420             }
 421 
 422             if (desc.header.isEmpty()) {
 423                 continue;
 424             }
 425 
 426             Iterator&lt;MethodDescription&gt; methodIt = desc.methods.iterator();
 427 
 428             while (methodIt.hasNext()) {
 429                 MethodDescription method = methodIt.next();
 430 
 431                 method.versions = reduce(method.versions, generatePlatforms);
 432                 if (method.versions.isEmpty())
 433                     methodIt.remove();
 434             }
 435 
 436             Iterator&lt;FieldDescription&gt; fieldIt = desc.fields.iterator();
 437 
 438             while (fieldIt.hasNext()) {
 439                 FieldDescription field = fieldIt.next();
 440 
 441                 field.versions = reduce(field.versions, generatePlatforms);
 442                 if (field.versions.isEmpty())
 443                     fieldIt.remove();
 444             }
 445 
 446             result.add(desc);
 447         }
 448 
 449         Map&lt;String, ModuleDescription&gt; moduleList = new HashMap&lt;&gt;();
 450 
 451         for (ModuleDescription desc : modules.values()) {
 452             Iterator&lt;ModuleHeaderDescription&gt; mhdIt = desc.header.iterator();
 453 
 454             while (mhdIt.hasNext()) {
 455                 ModuleHeaderDescription mhd = mhdIt.next();
 456 
 457                 mhd.versions = reduce(mhd.versions, generatePlatforms);
 458                 if (mhd.versions.isEmpty())
 459                     mhdIt.remove();
 460             }
 461 
 462             if (desc.header.isEmpty()) {
 463                 continue;
 464             }
 465 
 466             moduleList.put(desc.name, desc);
 467         }
 468 
 469         return new LoadDescriptions(result,
 470                                     moduleList,
 471                                     new ArrayList&lt;&gt;(platforms.values()));
 472     }
 473 
 474     static final class LoadDescriptions {
 475         public final ClassList classes;
 476         public final Map&lt;String, ModuleDescription&gt; modules;
 477         public final List&lt;PlatformInput&gt; versions;
 478 
 479         public LoadDescriptions(ClassList classes,
 480                                 Map&lt;String, ModuleDescription&gt;  modules,
 481                                 List&lt;PlatformInput&gt; versions) {
 482             this.classes = classes;
 483             this.modules = modules;
 484             this.versions = versions;
 485         }
 486 
 487     }
 488 
 489     static final class LineBasedReader implements AutoCloseable {
 490         private final BufferedReader input;
 491         public String lineKey;
 492         public Map&lt;String, String&gt; attributes = new HashMap&lt;&gt;();
 493 
 494         public LineBasedReader(Path input) throws IOException {
 495             this.input = Files.newBufferedReader(input);
 496             moveNext();
 497         }
 498 
 499         public void moveNext() throws IOException {
 500             String line = input.readLine();
 501 
 502             if (line == null) {
 503                 lineKey = null;
 504                 return ;
 505             }
 506 
 507             if (line.trim().isEmpty() || line.startsWith(&quot;#&quot;)) {
 508                 moveNext();
 509                 return ;
 510             }
 511 
 512             String[] parts = line.split(&quot; &quot;);
 513 
 514             lineKey = parts[0];
 515             attributes.clear();
 516 
 517             for (int i = 1; i &lt; parts.length; i += 2) {
 518                 attributes.put(parts[i], unquote(parts[i + 1]));
 519             }
 520         }
 521 
 522         public boolean hasNext() {
 523             return lineKey != null;
 524         }
 525 
 526         @Override
 527         public void close() throws IOException {
 528             input.close();
 529         }
 530     }
 531 
 532     private static String reduce(String original, String other) {
 533         Set&lt;String&gt; otherSet = new HashSet&lt;&gt;();
 534 
 535         for (char v : other.toCharArray()) {
 536             otherSet.add(&quot;&quot; + v);
 537         }
 538 
 539         return reduce(original, otherSet);
 540     }
 541 
 542     private static String reduce(String original, Set&lt;String&gt; generate) {
 543         StringBuilder sb = new StringBuilder();
 544 
 545         for (char v : original.toCharArray()) {
 546             if (generate.contains(&quot;&quot; + v)) {
 547                 sb.append(v);
 548             }
 549         }
 550         return sb.toString();
 551     }
 552 
 553     private static class PlatformInput {
 554         public final String version;
 555         public final String basePlatform;
 556         public final List&lt;String&gt; files;
 557         public final Path ctDescription;
 558         public PlatformInput(Path ctDescription, String version, String basePlatform, List&lt;String&gt; files) {
 559             this.ctDescription = ctDescription;
 560             this.version = version;
 561             this.basePlatform = basePlatform;
 562             this.files = files;
 563         }
 564 
 565         public static PlatformInput load(Path ctDescription, LineBasedReader in) throws IOException {
 566             return new PlatformInput(ctDescription,
 567                                      in.attributes.get(&quot;version&quot;),
 568                                      in.attributes.get(&quot;base&quot;),
 569                                      List.of(in.attributes.get(&quot;files&quot;).split(&quot;:&quot;)));
 570         }
 571     }
 572 
 573     static void addNewVersion(Collection&lt;? extends FeatureDescription&gt; features,
 574                        String baselineVersion,
 575                        String version) {
 576         features.stream()
 577                 .filter(f -&gt; f.versions.contains(baselineVersion))
 578                 .forEach(f -&gt; f.versions += version);
 579     }
 580 
 581     static &lt;T extends FeatureDescription&gt; void removeVersion(Collection&lt;T&gt; features,
 582                                                              Predicate&lt;T&gt; shouldRemove,
 583                                                              String version) {
 584         for (T existing : features) {
 585             if (shouldRemove.test(existing) &amp;&amp; existing.versions.endsWith(version)) {
 586                 existing.versions = existing.versions.replace(version, &quot;&quot;);
 587                 return;
 588             }
 589         }
 590     }
 591 
 592     /**Changes to class header of an outer class (like adding a new type parameter) may affect
 593      * its innerclasses. So if the outer class&#39;s header is different for versions A and B, need to
 594      * split its innerclasses headers to also be different for versions A and B.
 595      */
 596     static void splitHeaders(ClassList classes) {
 597         Set&lt;String&gt; ctVersions = new HashSet&lt;&gt;();
 598 
 599         for (ClassDescription cd : classes) {
 600             for (ClassHeaderDescription header : cd.header) {
 601                 for (char c : header.versions.toCharArray()) {
 602                     ctVersions.add(&quot;&quot; + c);
 603                 }
 604             }
 605         }
 606 
 607         classes.sort();
 608 
 609         for (ClassDescription cd : classes) {
 610             Map&lt;String, String&gt; outerSignatures2Version = new HashMap&lt;&gt;();
 611 
 612             for (String version : ctVersions) { //XXX
 613                 ClassDescription outer = cd;
 614                 String outerSignatures = &quot;&quot;;
 615 
 616                 while ((outer = classes.enclosingClass(outer)) != null) {
 617                     for (ClassHeaderDescription outerHeader : outer.header) {
 618                         if (outerHeader.versions.contains(version)) {
 619                             outerSignatures += outerHeader.signature;
 620                         }
 621                     }
 622                 }
 623 
 624                 outerSignatures2Version.compute(outerSignatures,
 625                                                  (key, value) -&gt; value != null ? value + version : version);
 626             }
 627 
 628             List&lt;ClassHeaderDescription&gt; newHeaders = new ArrayList&lt;&gt;();
 629 
 630             HEADER_LOOP: for (ClassHeaderDescription header : cd.header) {
 631                 for (String versions : outerSignatures2Version.values()) {
 632                     if (containsAll(versions, header.versions)) {
 633                         newHeaders.add(header);
 634                         continue HEADER_LOOP;
 635                     }
 636                     if (disjoint(versions, header.versions)) {
 637                         continue;
 638                     }
 639                     ClassHeaderDescription newHeader = new ClassHeaderDescription();
 640                     newHeader.classAnnotations = header.classAnnotations;
 641                     newHeader.deprecated = header.deprecated;
 642                     newHeader.extendsAttr = header.extendsAttr;
 643                     newHeader.flags = header.flags;
 644                     newHeader.implementsAttr = header.implementsAttr;
 645                     newHeader.innerClasses = header.innerClasses;
 646                     newHeader.runtimeAnnotations = header.runtimeAnnotations;
 647                     newHeader.signature = header.signature;
 648                     newHeader.versions = reduce(header.versions, versions);
 649 
 650                     newHeaders.add(newHeader);
 651                 }
 652             }
 653 
 654             cd.header = newHeaders;
 655         }
 656     }
 657 
 658     void limitJointVersion(Set&lt;String&gt; jointVersions, List&lt;? extends FeatureDescription&gt; features) {
 659         for (FeatureDescription feature : features) {
 660             limitJointVersion(jointVersions, feature.versions);
 661         }
 662     }
 663 
 664     void limitJointVersion(Set&lt;String&gt; jointVersions, String versions) {
 665         for (String version : jointVersions) {
 666             if (!containsAll(versions, version) &amp;&amp;
 667                 !disjoint(versions, version)) {
 668                 StringBuilder featurePart = new StringBuilder();
 669                 StringBuilder otherPart = new StringBuilder();
 670                 for (char v : version.toCharArray()) {
 671                     if (versions.indexOf(v) != (-1)) {
 672                         featurePart.append(v);
 673                     } else {
 674                         otherPart.append(v);
 675                     }
 676                 }
 677                 jointVersions.remove(version);
 678                 if (featurePart.length() == 0 || otherPart.length() == 0) {
 679                     throw new AssertionError();
 680                 }
 681                 jointVersions.add(featurePart.toString());
 682                 jointVersions.add(otherPart.toString());
 683                 break;
 684             }
 685         }
 686     }
 687 
 688     private static boolean containsAll(String versions, String subVersions) {
 689         for (char c : subVersions.toCharArray()) {
 690             if (versions.indexOf(c) == (-1))
 691                 return false;
 692         }
 693         return true;
 694     }
 695 
 696     private static boolean disjoint(String version1, String version2) {
 697         for (char c : version2.toCharArray()) {
 698             if (version1.indexOf(c) != (-1))
 699                 return false;
 700         }
 701         return true;
 702     }
 703 
 704     void writeClassesForVersions(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,
 705                                  ClassDescription classDescription,
 706                                  ClassHeaderDescription header,
 707                                  String module,
 708                                  Iterable&lt;String&gt; versions)
 709             throws IOException {
 710         for (String ver : versions) {
 711             writeClass(directory2FileData, classDescription, header, module, ver);
 712         }
 713     }
 714 
 715     void writeModulesForVersions(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,
 716                                  ModuleDescription moduleDescription,
 717                                  ModuleHeaderDescription header,
 718                                  Iterable&lt;String&gt; versions)
 719             throws IOException {
 720         for (String ver : versions) {
 721             writeModule(directory2FileData, moduleDescription, header, ver);
 722         }
 723     }
 724 
 725     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Class Writing&quot;&gt;
 726     void writeModule(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,
 727                     ModuleDescription moduleDescription,
 728                     ModuleHeaderDescription header,
 729                     String version) throws IOException {
 730         List&lt;CPInfo&gt; constantPool = new ArrayList&lt;&gt;();
 731         constantPool.add(null);
 732         int currentClass = addClass(constantPool, &quot;module-info&quot;);
 733         int superclass = 0;
 734         int[] interfaces = new int[0];
 735         AccessFlags flags = new AccessFlags(header.flags);
 736         Map&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();
 737         addAttributes(moduleDescription, header, constantPool, attributesMap);
 738         Attributes attributes = new Attributes(attributesMap);
 739         CPInfo[] cpData = constantPool.toArray(new CPInfo[constantPool.size()]);
 740         ConstantPool cp = new ConstantPool(cpData);
 741         ClassFile classFile = new ClassFile(0xCAFEBABE,
 742                 Target.DEFAULT.minorVersion,
 743                 Target.DEFAULT.majorVersion,
 744                 cp,
 745                 flags,
 746                 currentClass,
 747                 superclass,
 748                 interfaces,
 749                 new Field[0],
 750                 new Method[0],
 751                 attributes);
 752 
 753         doWrite(directory2FileData, version, moduleDescription.name, &quot;module-info&quot; + EXTENSION, classFile);
 754     }
 755 
 756     void writeClass(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,
 757                     ClassDescription classDescription,
 758                     ClassHeaderDescription header,
 759                     String module,
 760                     String version) throws IOException {
 761         List&lt;CPInfo&gt; constantPool = new ArrayList&lt;&gt;();
 762         constantPool.add(null);
 763         List&lt;Method&gt; methods = new ArrayList&lt;&gt;();
 764         for (MethodDescription methDesc : classDescription.methods) {
 765             if (disjoint(methDesc.versions, version))
 766                 continue;
 767             Descriptor descriptor = new Descriptor(addString(constantPool, methDesc.descriptor));
 768             //TODO: LinkedHashMap to avoid param annotations vs. Signature problem in javac&#39;s ClassReader:
 769             Map&lt;String, Attribute&gt; attributesMap = new LinkedHashMap&lt;&gt;();
 770             addAttributes(methDesc, constantPool, attributesMap);
 771             Attributes attributes = new Attributes(attributesMap);
 772             AccessFlags flags = new AccessFlags(methDesc.flags);
 773             int nameString = addString(constantPool, methDesc.name);
 774             methods.add(new Method(flags, nameString, descriptor, attributes));
 775         }
 776         List&lt;Field&gt; fields = new ArrayList&lt;&gt;();
 777         for (FieldDescription fieldDesc : classDescription.fields) {
 778             if (disjoint(fieldDesc.versions, version))
 779                 continue;
 780             Descriptor descriptor = new Descriptor(addString(constantPool, fieldDesc.descriptor));
 781             Map&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();
 782             addAttributes(fieldDesc, constantPool, attributesMap);
 783             Attributes attributes = new Attributes(attributesMap);
 784             AccessFlags flags = new AccessFlags(fieldDesc.flags);
 785             int nameString = addString(constantPool, fieldDesc.name);
 786             fields.add(new Field(flags, nameString, descriptor, attributes));
 787         }
 788         int currentClass = addClass(constantPool, classDescription.name);
 789         int superclass = header.extendsAttr != null ? addClass(constantPool, header.extendsAttr) : 0;
 790         int[] interfaces = new int[header.implementsAttr.size()];
 791         int i = 0;
 792         for (String intf : header.implementsAttr) {
 793             interfaces[i++] = addClass(constantPool, intf);
 794         }
 795         AccessFlags flags = new AccessFlags(header.flags);
 796         Map&lt;String, Attribute&gt; attributesMap = new HashMap&lt;&gt;();
 797         addAttributes(header, constantPool, attributesMap);
 798         Attributes attributes = new Attributes(attributesMap);
 799         ConstantPool cp = new ConstantPool(constantPool.toArray(new CPInfo[constantPool.size()]));
 800         ClassFile classFile = new ClassFile(0xCAFEBABE,
 801                 Target.DEFAULT.minorVersion,
 802                 Target.DEFAULT.majorVersion,
 803                 cp,
 804                 flags,
 805                 currentClass,
 806                 superclass,
 807                 interfaces,
 808                 fields.toArray(new Field[0]),
 809                 methods.toArray(new Method[0]),
 810                 attributes);
 811 
 812         doWrite(directory2FileData, version, module, classDescription.name + EXTENSION, classFile);
 813     }
 814 
 815     private void doWrite(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,
 816                          String version,
 817                          String moduleName,
 818                          String fileName,
 819                          ClassFile classFile) throws IOException {
 820         int lastSlash = fileName.lastIndexOf(&#39;/&#39;);
 821         String pack = lastSlash != (-1) ? fileName.substring(0, lastSlash + 1) : &quot;/&quot;;
 822         String directory = version + &quot;/&quot; + moduleName + &quot;/&quot; + pack;
 823         String fullFileName = version + &quot;/&quot; + moduleName + &quot;/&quot; + fileName;
 824         try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
 825             ClassWriter w = new ClassWriter();
 826 
 827             w.write(classFile, out);
 828 
 829             openDirectory(directory2FileData, directory)
 830                 .add(new FileData(fullFileName, out.toByteArray()));
 831         }
 832     }
 833 
 834     private Set&lt;FileData&gt; openDirectory(Map&lt;String, Set&lt;FileData&gt;&gt; directory2FileData,
 835                                String directory) {
 836         Comparator&lt;FileData&gt; fileCompare = (fd1, fd2) -&gt; fd1.fileName.compareTo(fd2.fileName);
 837         return directory2FileData.computeIfAbsent(directory, d -&gt; new TreeSet&lt;&gt;(fileCompare));
 838     }
 839 
 840     private static class FileData {
 841         public final String fileName;
 842         public final byte[] fileData;
 843 
 844         public FileData(String fileName, byte[] fileData) {
 845             this.fileName = fileName;
 846             this.fileData = fileData;
 847         }
 848 
 849     }
 850 
 851     private void addAttributes(ModuleDescription md,
 852                                ModuleHeaderDescription header,
 853                                List&lt;CPInfo&gt; cp,
 854                                Map&lt;String, Attribute&gt; attributes) {
 855         addGenericAttributes(header, cp, attributes);
 856         if (header.moduleResolution != null) {
 857             int attrIdx = addString(cp, Attribute.ModuleResolution);
 858             final ModuleResolution_attribute resIdx =
 859                     new ModuleResolution_attribute(attrIdx,
 860                                                    header.moduleResolution);
 861             attributes.put(Attribute.ModuleResolution, resIdx);
 862         }
 863         if (header.moduleTarget != null) {
 864             int attrIdx = addString(cp, Attribute.ModuleTarget);
 865             int targetIdx = addString(cp, header.moduleTarget);
 866             attributes.put(Attribute.ModuleTarget,
 867                            new ModuleTarget_attribute(attrIdx, targetIdx));
 868         }
 869         int attrIdx = addString(cp, Attribute.Module);
 870         attributes.put(Attribute.Module,
 871                        new Module_attribute(attrIdx,
 872                              addModuleName(cp, md.name),
 873                              0,
 874                              0,
 875                              header.requires
 876                                    .stream()
 877                                    .map(r -&gt; createRequiresEntry(cp, r))
 878                                    .collect(Collectors.toList())
 879                                    .toArray(new RequiresEntry[0]),
 880                              header.exports
 881                                    .stream()
 882                                    .map(e -&gt; createExportsEntry(cp, e))
 883                                    .collect(Collectors.toList())
 884                                    .toArray(new ExportsEntry[0]),
 885                              header.opens
 886                                    .stream()
 887                                    .map(e -&gt; createOpensEntry(cp, e))
 888                                    .collect(Collectors.toList())
 889                                    .toArray(new OpensEntry[0]),
 890                              header.uses
 891                                    .stream()
 892                                    .mapToInt(u -&gt; addClassName(cp, u))
 893                                    .toArray(),
 894                              header.provides
 895                                    .stream()
 896                                    .map(p -&gt; createProvidesEntry(cp, p))
 897                                    .collect(Collectors.toList())
 898                                    .toArray(new ProvidesEntry[0])));
 899         addInnerClassesAttribute(header, cp, attributes);
 900     }
 901 
 902     private static RequiresEntry createRequiresEntry(List&lt;CPInfo&gt; cp,
 903             RequiresDescription r) {
 904         final int idx = addModuleName(cp, r.moduleName);
 905         return new RequiresEntry(idx,
 906                                  r.flags,
 907                                  r.version != null
 908                                          ? addInt(cp, r.version)
 909                                          : 0);
 910     }
 911 
 912     private static ExportsEntry createExportsEntry(List&lt;CPInfo&gt; cp,
 913                                                    String e) {
 914         return new ExportsEntry(addPackageName(cp, e), 0, new int[0]);
 915     }
 916 
 917     private static OpensEntry createOpensEntry(List&lt;CPInfo&gt; cp, String e) {
 918         return new OpensEntry(addPackageName(cp, e), 0, new int[0]);
 919     }
 920 
 921     private static ProvidesEntry createProvidesEntry(List&lt;CPInfo&gt; cp,
 922             ModuleHeaderDescription.ProvidesDescription p) {
 923         final int idx = addClassName(cp, p.interfaceName);
 924         return new ProvidesEntry(idx, p.implNames
 925                                        .stream()
 926                                        .mapToInt(i -&gt; addClassName(cp, i))
 927                                        .toArray());
 928     }
 929 
 930     private void addAttributes(ClassHeaderDescription header,
 931             List&lt;CPInfo&gt; constantPool, Map&lt;String, Attribute&gt; attributes) {
 932         addGenericAttributes(header, constantPool, attributes);
 933         if (header.nestHost != null) {
 934             int attributeString = addString(constantPool, Attribute.NestHost);
 935             int nestHost = addClass(constantPool, header.nestHost);
 936             attributes.put(Attribute.NestHost,
 937                            new NestHost_attribute(attributeString, nestHost));
 938         }
 939         if (header.nestMembers != null &amp;&amp; !header.nestMembers.isEmpty()) {
 940             int attributeString = addString(constantPool, Attribute.NestMembers);
 941             int[] nestMembers = new int[header.nestMembers.size()];
 942             int i = 0;
 943             for (String intf : header.nestMembers) {
 944                 nestMembers[i++] = addClass(constantPool, intf);
 945             }
 946             attributes.put(Attribute.NestMembers,
 947                            new NestMembers_attribute(attributeString, nestMembers));
 948         }
 949         addInnerClassesAttribute(header, constantPool, attributes);
 950     }
 951 
 952     private void addInnerClassesAttribute(HeaderDescription header,
 953             List&lt;CPInfo&gt; constantPool, Map&lt;String, Attribute&gt; attributes) {
 954         if (header.innerClasses != null &amp;&amp; !header.innerClasses.isEmpty()) {
 955             Info[] innerClasses = new Info[header.innerClasses.size()];
 956             int i = 0;
 957             for (InnerClassInfo info : header.innerClasses) {
 958                 innerClasses[i++] =
 959                         new Info(info.innerClass == null ? 0 : addClass(constantPool, info.innerClass),
 960                                  info.outerClass == null ? 0 : addClass(constantPool, info.outerClass),
 961                                  info.innerClassName == null ? 0 : addString(constantPool, info.innerClassName),
 962                                  new AccessFlags(info.innerClassFlags));
 963             }
 964             int attributeString = addString(constantPool, Attribute.InnerClasses);
 965             attributes.put(Attribute.InnerClasses,
 966                            new InnerClasses_attribute(attributeString, innerClasses));
 967         }
 968     }
 969 
 970     private void addAttributes(MethodDescription desc, List&lt;CPInfo&gt; constantPool, Map&lt;String, Attribute&gt; attributes) {
 971         addGenericAttributes(desc, constantPool, attributes);
 972         if (desc.thrownTypes != null) {
 973             int[] exceptions = new int[desc.thrownTypes.size()];
 974             int i = 0;
 975             for (String exc : desc.thrownTypes) {
 976                 exceptions[i++] = addClass(constantPool, exc);
 977             }
 978             int attributeString = addString(constantPool, Attribute.Exceptions);
 979             attributes.put(Attribute.Exceptions,
 980                            new Exceptions_attribute(attributeString, exceptions));
 981         }
 982         if (desc.annotationDefaultValue != null) {
 983             int attributeString = addString(constantPool, Attribute.AnnotationDefault);
 984             element_value attributeValue = createAttributeValue(constantPool,
 985                                                                 desc.annotationDefaultValue);
 986             attributes.put(Attribute.AnnotationDefault,
 987                            new AnnotationDefault_attribute(attributeString, attributeValue));
 988         }
 989         if (desc.classParameterAnnotations != null &amp;&amp; !desc.classParameterAnnotations.isEmpty()) {
 990             int attributeString =
 991                     addString(constantPool, Attribute.RuntimeInvisibleParameterAnnotations);
 992             Annotation[][] annotations =
 993                     createParameterAnnotations(constantPool, desc.classParameterAnnotations);
 994             attributes.put(Attribute.RuntimeInvisibleParameterAnnotations,
 995                            new RuntimeInvisibleParameterAnnotations_attribute(attributeString,
 996                                    annotations));
 997         }
 998         if (desc.runtimeParameterAnnotations != null &amp;&amp; !desc.runtimeParameterAnnotations.isEmpty()) {
 999             int attributeString =
1000                     addString(constantPool, Attribute.RuntimeVisibleParameterAnnotations);
1001             Annotation[][] annotations =
1002                     createParameterAnnotations(constantPool, desc.runtimeParameterAnnotations);
1003             attributes.put(Attribute.RuntimeVisibleParameterAnnotations,
1004                            new RuntimeVisibleParameterAnnotations_attribute(attributeString,
1005                                    annotations));
1006         }
1007     }
1008 
1009     private void addAttributes(FieldDescription desc, List&lt;CPInfo&gt; constantPool, Map&lt;String, Attribute&gt; attributes) {
1010         addGenericAttributes(desc, constantPool, attributes);
1011         if (desc.constantValue != null) {
1012             Pair&lt;Integer, Character&gt; constantPoolEntry =
1013                     addConstant(constantPool, desc.constantValue, false);
1014             Assert.checkNonNull(constantPoolEntry);
1015             int constantValueString = addString(constantPool, Attribute.ConstantValue);
1016             attributes.put(Attribute.ConstantValue,
1017                            new ConstantValue_attribute(constantValueString, constantPoolEntry.fst));
1018         }
1019     }
1020 
1021     private void addGenericAttributes(FeatureDescription desc, List&lt;CPInfo&gt; constantPool, Map&lt;String, Attribute&gt; attributes) {
1022         if (desc.deprecated) {
1023             int attributeString = addString(constantPool, Attribute.Deprecated);
1024             attributes.put(Attribute.Deprecated,
1025                            new Deprecated_attribute(attributeString));
1026         }
1027         if (desc.signature != null) {
1028             int attributeString = addString(constantPool, Attribute.Signature);
1029             int signatureString = addString(constantPool, desc.signature);
1030             attributes.put(Attribute.Signature,
1031                            new Signature_attribute(attributeString, signatureString));
1032         }
1033         if (desc.classAnnotations != null &amp;&amp; !desc.classAnnotations.isEmpty()) {
1034             int attributeString = addString(constantPool, Attribute.RuntimeInvisibleAnnotations);
1035             Annotation[] annotations = createAnnotations(constantPool, desc.classAnnotations);
1036             attributes.put(Attribute.RuntimeInvisibleAnnotations,
1037                            new RuntimeInvisibleAnnotations_attribute(attributeString, annotations));
1038         }
1039         if (desc.runtimeAnnotations != null &amp;&amp; !desc.runtimeAnnotations.isEmpty()) {
1040             int attributeString = addString(constantPool, Attribute.RuntimeVisibleAnnotations);
1041             Annotation[] annotations = createAnnotations(constantPool, desc.runtimeAnnotations);
1042             attributes.put(Attribute.RuntimeVisibleAnnotations,
1043                            new RuntimeVisibleAnnotations_attribute(attributeString, annotations));
1044         }
1045     }
1046 
1047     private Annotation[] createAnnotations(List&lt;CPInfo&gt; constantPool, List&lt;AnnotationDescription&gt; desc) {
1048         Annotation[] result = new Annotation[desc.size()];
1049         int i = 0;
1050 
1051         for (AnnotationDescription ad : desc) {
1052             result[i++] = createAnnotation(constantPool, ad);
1053         }
1054 
1055         return result;
1056     }
1057 
1058     private Annotation[][] createParameterAnnotations(List&lt;CPInfo&gt; constantPool, List&lt;List&lt;AnnotationDescription&gt;&gt; desc) {
1059         Annotation[][] result = new Annotation[desc.size()][];
1060         int i = 0;
1061 
1062         for (List&lt;AnnotationDescription&gt; paramAnnos : desc) {
1063             result[i++] = createAnnotations(constantPool, paramAnnos);
1064         }
1065 
1066         return result;
1067     }
1068 
1069     private Annotation createAnnotation(List&lt;CPInfo&gt; constantPool, AnnotationDescription desc) {
1070         String annotationType = desc.annotationType;
1071 
1072         if (PREVIEW_FEATURE_ANNOTATION.equals(annotationType)) {
1073             //the non-public PreviewFeature annotation will not be available in ct.sym,
1074             //replace with purely synthetic javac-internal annotation:
1075             annotationType = PREVIEW_FEATURE_ANNOTATION_INTERNAL;
1076         }
1077 
1078         return new Annotation(null,
1079                               addString(constantPool, annotationType),
1080                               createElementPairs(constantPool, desc.values));
1081     }
1082     //where:
1083         private static final String PREVIEW_FEATURE_ANNOTATION =
1084                 &quot;Ljdk/internal/PreviewFeature;&quot;;
1085         private static final String PREVIEW_FEATURE_ANNOTATION_INTERNAL =
1086                 &quot;Ljdk/internal/PreviewFeature+Annotation;&quot;;
1087 
1088     private element_value_pair[] createElementPairs(List&lt;CPInfo&gt; constantPool, Map&lt;String, Object&gt; annotationAttributes) {
1089         element_value_pair[] pairs = new element_value_pair[annotationAttributes.size()];
1090         int i = 0;
1091 
1092         for (Entry&lt;String, Object&gt; e : annotationAttributes.entrySet()) {
1093             int elementNameString = addString(constantPool, e.getKey());
1094             element_value value = createAttributeValue(constantPool, e.getValue());
1095             pairs[i++] = new element_value_pair(elementNameString, value);
1096         }
1097 
1098         return pairs;
1099     }
1100 
1101     private element_value createAttributeValue(List&lt;CPInfo&gt; constantPool, Object value) {
1102         Pair&lt;Integer, Character&gt; constantPoolEntry = addConstant(constantPool, value, true);
1103         if (constantPoolEntry != null) {
1104             return new Primitive_element_value(constantPoolEntry.fst, constantPoolEntry.snd);
1105         } else if (value instanceof EnumConstant) {
1106             EnumConstant ec = (EnumConstant) value;
1107             return new Enum_element_value(addString(constantPool, ec.type),
1108                                           addString(constantPool, ec.constant),
1109                                           &#39;e&#39;);
1110         } else if (value instanceof ClassConstant) {
1111             ClassConstant cc = (ClassConstant) value;
1112             return new Class_element_value(addString(constantPool, cc.type), &#39;c&#39;);
1113         } else if (value instanceof AnnotationDescription) {
1114             Annotation annotation = createAnnotation(constantPool, ((AnnotationDescription) value));
1115             return new Annotation_element_value(annotation, &#39;@&#39;);
1116         } else if (value instanceof Collection) {
1117             @SuppressWarnings(&quot;unchecked&quot;)
1118                     Collection&lt;Object&gt; array = (Collection&lt;Object&gt;) value;
1119             element_value[] values = new element_value[array.size()];
1120             int i = 0;
1121 
1122             for (Object elem : array) {
1123                 values[i++] = createAttributeValue(constantPool, elem);
1124             }
1125 
1126             return new Array_element_value(values, &#39;[&#39;);
1127         }
1128         throw new IllegalStateException(value.getClass().getName());
1129     }
1130 
1131     private static Pair&lt;Integer, Character&gt; addConstant(List&lt;CPInfo&gt; constantPool, Object value, boolean annotation) {
1132         if (value instanceof Boolean) {
1133             return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info(((Boolean) value) ? 1 : 0)), &#39;Z&#39;);
1134         } else if (value instanceof Byte) {
1135             return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((byte) value)), &#39;B&#39;);
1136         } else if (value instanceof Character) {
1137             return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((char) value)), &#39;C&#39;);
1138         } else if (value instanceof Short) {
1139             return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((short) value)), &#39;S&#39;);
1140         } else if (value instanceof Integer) {
1141             return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((int) value)), &#39;I&#39;);
1142         } else if (value instanceof Long) {
1143             return Pair.of(addToCP(constantPool, new CONSTANT_Long_info((long) value)), &#39;J&#39;);
1144         } else if (value instanceof Float) {
1145             return Pair.of(addToCP(constantPool, new CONSTANT_Float_info((float) value)), &#39;F&#39;);
1146         } else if (value instanceof Double) {
1147             return Pair.of(addToCP(constantPool, new CONSTANT_Double_info((double) value)), &#39;D&#39;);
1148         } else if (value instanceof String) {
1149             int stringIndex = addString(constantPool, (String) value);
1150             if (annotation) {
1151                 return Pair.of(stringIndex, &#39;s&#39;);
1152             } else {
1153                 return Pair.of(addToCP(constantPool, new CONSTANT_String_info(null, stringIndex)), &#39;s&#39;);
1154             }
1155         }
1156 
1157         return null;
1158     }
1159 
1160     private static int addString(List&lt;CPInfo&gt; constantPool, String string) {
1161         Assert.checkNonNull(string);
1162 
1163         int i = 0;
1164         for (CPInfo info : constantPool) {
1165             if (info instanceof CONSTANT_Utf8_info) {
1166                 if (((CONSTANT_Utf8_info) info).value.equals(string)) {
1167                     return i;
1168                 }
1169             }
1170             i++;
1171         }
1172 
1173         return addToCP(constantPool, new CONSTANT_Utf8_info(string));
1174     }
1175 
1176     private static int addInt(List&lt;CPInfo&gt; constantPool, int value) {
1177         int i = 0;
1178         for (CPInfo info : constantPool) {
1179             if (info instanceof CONSTANT_Integer_info) {
1180                 if (((CONSTANT_Integer_info) info).value == value) {
1181                     return i;
1182                 }
1183             }
1184             i++;
1185         }
1186 
1187         return addToCP(constantPool, new CONSTANT_Integer_info(value));
1188     }
1189 
1190     private static int addModuleName(List&lt;CPInfo&gt; constantPool, String moduleName) {
1191         int nameIdx = addString(constantPool, moduleName);
1192         int i = 0;
1193         for (CPInfo info : constantPool) {
1194             if (info instanceof CONSTANT_Module_info) {
1195                 if (((CONSTANT_Module_info) info).name_index == nameIdx) {
1196                     return i;
1197                 }
1198             }
1199             i++;
1200         }
1201 
1202         return addToCP(constantPool, new CONSTANT_Module_info(null, nameIdx));
1203     }
1204 
1205     private static int addPackageName(List&lt;CPInfo&gt; constantPool, String packageName) {
1206         int nameIdx = addString(constantPool, packageName);
1207         int i = 0;
1208         for (CPInfo info : constantPool) {
1209             if (info instanceof CONSTANT_Package_info) {
1210                 if (((CONSTANT_Package_info) info).name_index == nameIdx) {
1211                     return i;
1212                 }
1213             }
1214             i++;
1215         }
1216 
1217         return addToCP(constantPool, new CONSTANT_Package_info(null, nameIdx));
1218     }
1219 
1220     private static int addClassName(List&lt;CPInfo&gt; constantPool, String className) {
1221         int nameIdx = addString(constantPool, className);
1222         int i = 0;
1223         for (CPInfo info : constantPool) {
1224             if (info instanceof CONSTANT_Class_info) {
1225                 if (((CONSTANT_Class_info) info).name_index == nameIdx) {
1226                     return i;
1227                 }
1228             }
1229             i++;
1230         }
1231 
1232         return addToCP(constantPool, new CONSTANT_Class_info(null, nameIdx));
1233     }
1234 
1235     private static int addToCP(List&lt;CPInfo&gt; constantPool, CPInfo entry) {
1236         int result = constantPool.size();
1237 
1238         constantPool.add(entry);
1239 
1240         if (entry.size() &gt; 1) {
1241             constantPool.add(null);
1242         }
1243 
1244         return result;
1245     }
1246 
1247     private static int addClass(List&lt;CPInfo&gt; constantPool, String className) {
1248         int classNameIndex = addString(constantPool, className);
1249 
1250         int i = 0;
1251         for (CPInfo info : constantPool) {
1252             if (info instanceof CONSTANT_Class_info) {
1253                 if (((CONSTANT_Class_info) info).name_index == classNameIndex) {
1254                     return i;
1255                 }
1256             }
1257             i++;
1258         }
1259 
1260         return addToCP(constantPool, new CONSTANT_Class_info(null, classNameIndex));
1261     }
1262     //&lt;/editor-fold&gt;
1263     //&lt;/editor-fold&gt;
1264 
1265     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Create Symbol Description&quot;&gt;
1266     public void createBaseLine(List&lt;VersionDescription&gt; versions,
1267                                ExcludeIncludeList excludesIncludes,
1268                                Path descDest,
1269                                String[] args) throws IOException {
1270         ClassList classes = new ClassList();
1271         Map&lt;String, ModuleDescription&gt; modules = new HashMap&lt;&gt;();
1272 
1273         for (VersionDescription desc : versions) {
1274             List&lt;byte[]&gt; classFileData = new ArrayList&lt;&gt;();
1275 
1276             try (BufferedReader descIn =
1277                     Files.newBufferedReader(Paths.get(desc.classes))) {
1278                 String line;
1279                 while ((line = descIn.readLine()) != null) {
1280                     ByteArrayOutputStream data = new ByteArrayOutputStream();
1281                     for (int i = 0; i &lt; line.length(); i += 2) {
1282                         String hex = line.substring(i, i + 2);
1283                         data.write(Integer.parseInt(hex, 16));
1284                     }
1285                     classFileData.add(data.toByteArray());
1286                 }
1287             } catch (IOException ex) {
1288                 throw new IllegalStateException(ex);
1289             }
1290 
1291             loadVersionClasses(classes, modules, classFileData, excludesIncludes, desc.version);
1292         }
1293 
1294         List&lt;PlatformInput&gt; platforms =
1295                 versions.stream()
1296                         .map(desc -&gt; new PlatformInput(null,
1297                                                        desc.version,
1298                                                        desc.primaryBaseline,
1299                                                        null))
1300                         .collect(Collectors.toList());
1301 
1302         dumpDescriptions(classes, modules, platforms, descDest.resolve(&quot;symbols&quot;), args);
1303     }
1304     //where:
1305         private static final String DO_NO_MODIFY =
1306             &quot;#\n&quot; +
1307             &quot;# Copyright (c) {YEAR}, Oracle and/or its affiliates. All rights reserved.\n&quot; +
1308             &quot;# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n&quot; +
1309             &quot;#\n&quot; +
1310             &quot;# This code is free software; you can redistribute it and/or modify it\n&quot; +
1311             &quot;# under the terms of the GNU General Public License version 2 only, as\n&quot; +
1312             &quot;# published by the Free Software Foundation.  Oracle designates this\n&quot; +
1313             &quot;# particular file as subject to the \&quot;Classpath\&quot; exception as provided\n&quot; +
1314             &quot;# by Oracle in the LICENSE file that accompanied this code.\n&quot; +
1315             &quot;#\n&quot; +
1316             &quot;# This code is distributed in the hope that it will be useful, but WITHOUT\n&quot; +
1317             &quot;# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n&quot; +
1318             &quot;# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n&quot; +
1319             &quot;# version 2 for more details (a copy is included in the LICENSE file that\n&quot; +
1320             &quot;# accompanied this code).\n&quot; +
1321             &quot;#\n&quot; +
1322             &quot;# You should have received a copy of the GNU General Public License version\n&quot; +
1323             &quot;# 2 along with this work; if not, write to the Free Software Foundation,\n&quot; +
1324             &quot;# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n&quot; +
1325             &quot;#\n&quot; +
1326             &quot;# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n&quot; +
1327             &quot;# or visit www.oracle.com if you need additional information or have any\n&quot; +
1328             &quot;# questions.\n&quot; +
1329             &quot;#\n&quot; +
1330             &quot;# ##########################################################\n&quot; +
1331             &quot;# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n&quot; +
1332             &quot;# ##########################################################\n&quot; +
1333             &quot;#\n&quot;;
1334 
1335     private void loadVersionClasses(ClassList classes,
1336                                     Map&lt;String, ModuleDescription&gt; modules,
1337                                     Iterable&lt;byte[]&gt; classData,
1338                                     ExcludeIncludeList excludesIncludes,
1339                                     String version) {
1340         Map&lt;String, ModuleDescription&gt; currentVersionModules =
1341                 new HashMap&lt;&gt;();
1342 
1343         for (byte[] classFileData : classData) {
1344             try (InputStream in = new ByteArrayInputStream(classFileData)) {
1345                 inspectModuleInfoClassFile(in,
1346                                            currentVersionModules, version);
1347             } catch (IOException | ConstantPoolException ex) {
1348                 throw new IllegalStateException(ex);
1349             }
1350         }
1351 
1352         ExcludeIncludeList currentEIList = excludesIncludes;
1353 
1354         if (!currentVersionModules.isEmpty()) {
1355             Set&lt;String&gt; includes = new HashSet&lt;&gt;();
1356 
1357             for (ModuleDescription md : currentVersionModules.values()) {
1358                 md.header.get(0).exports.stream().map(e -&gt; e + &#39;/&#39;)
1359                                         .forEach(includes::add);
1360             }
1361 
1362             currentEIList = new ExcludeIncludeList(includes,
1363                                                    Collections.emptySet());
1364         }
1365 
1366         ClassList currentVersionClasses = new ClassList();
1367 
1368         for (byte[] classFileData : classData) {
1369             try (InputStream in = new ByteArrayInputStream(classFileData)) {
1370                 inspectClassFile(in, currentVersionClasses,
1371                                  currentEIList, version);
1372             } catch (IOException | ConstantPoolException ex) {
1373                 throw new IllegalStateException(ex);
1374             }
1375         }
1376 
1377         ModuleDescription unsupported =
1378                 currentVersionModules.get(&quot;jdk.unsupported&quot;);
1379 
1380         if (unsupported != null) {
1381             for (ClassDescription cd : currentVersionClasses.classes) {
1382                 if (unsupported.header
1383                                .get(0)
1384                                .exports
1385                                .contains(cd.packge().replace(&#39;.&#39;, &#39;/&#39;))) {
1386                     ClassHeaderDescription ch = cd.header.get(0);
1387                     if (ch.classAnnotations == null) {
1388                         ch.classAnnotations = new ArrayList&lt;&gt;();
1389                     }
1390                     AnnotationDescription ad;
1391                     ad = new AnnotationDescription(PROPERITARY_ANNOTATION,
1392                                                    Collections.emptyMap());
1393                     ch.classAnnotations.add(ad);
1394                 }
1395             }
1396         }
1397 
1398         Set&lt;String&gt; includedClasses = new HashSet&lt;&gt;();
1399         boolean modified;
1400 
1401         do {
1402             modified = false;
1403 
1404             for (ClassDescription clazz : currentVersionClasses) {
1405                 ClassHeaderDescription header = clazz.header.get(0);
1406 
1407                 if (includeEffectiveAccess(currentVersionClasses, clazz)) {
1408                     modified |= include(includedClasses, currentVersionClasses, clazz.name);
1409                 }
1410 
1411                 if (includedClasses.contains(clazz.name)) {
1412                     modified |= include(includedClasses, currentVersionClasses, header.extendsAttr);
1413                     for (String i : header.implementsAttr) {
1414                         modified |= include(includedClasses, currentVersionClasses, i);
1415                     }
1416 
1417                     modified |= includeOutputType(Collections.singleton(header),
1418                                                   h -&gt; &quot;&quot;,
1419                                                   includedClasses,
1420                                                   currentVersionClasses);
1421                     modified |= includeOutputType(clazz.fields,
1422                                                   f -&gt; f.descriptor,
1423                                                   includedClasses,
1424                                                   currentVersionClasses);
1425                     modified |= includeOutputType(clazz.methods,
1426                                                   m -&gt; m.descriptor,
1427                                                   includedClasses,
1428                                                   currentVersionClasses);
1429                 }
1430             }
1431         } while (modified);
1432 
1433         for (ClassDescription clazz : currentVersionClasses) {
1434             if (!includedClasses.contains(clazz.name)) {
1435                 continue;
1436             }
1437 
1438             ClassHeaderDescription header = clazz.header.get(0);
1439 
1440             if (header.nestMembers != null) {
1441                 Iterator&lt;String&gt; nestMemberIt = header.nestMembers.iterator();
1442 
1443                 while(nestMemberIt.hasNext()) {
1444                     String member = nestMemberIt.next();
1445                     if (!includedClasses.contains(member))
1446                         nestMemberIt.remove();
1447                 }
1448             }
1449 
1450             if (header.innerClasses != null) {
1451                 Iterator&lt;InnerClassInfo&gt; innerClassIt = header.innerClasses.iterator();
1452 
1453                 while(innerClassIt.hasNext()) {
1454                     InnerClassInfo ici = innerClassIt.next();
1455                     if (!includedClasses.contains(ici.innerClass))
1456                         innerClassIt.remove();
1457                 }
1458             }
1459 
1460             ClassDescription existing = classes.find(clazz.name, true);
1461 
1462             if (existing != null) {
1463                 addClassHeader(existing, header, version);
1464                 for (MethodDescription currentMethod : clazz.methods) {
1465                     addMethod(existing, currentMethod, version);
1466                 }
1467                 for (FieldDescription currentField : clazz.fields) {
1468                     addField(existing, currentField, version);
1469                 }
1470             } else {
1471                 classes.add(clazz);
1472             }
1473         }
1474 
1475         for (ModuleDescription module : currentVersionModules.values()) {
1476             ModuleHeaderDescription header = module.header.get(0);
1477 
1478             if (header.innerClasses != null) {
1479                 Iterator&lt;InnerClassInfo&gt; innerClassIt =
1480                         header.innerClasses.iterator();
1481 
1482                 while(innerClassIt.hasNext()) {
1483                     InnerClassInfo ici = innerClassIt.next();
1484                     if (!includedClasses.contains(ici.innerClass))
1485                         innerClassIt.remove();
1486                 }
1487             }
1488 
1489             ModuleDescription existing = modules.get(module.name);
1490 
1491             if (existing != null) {
1492                 addModuleHeader(existing, header, version);
1493             } else {
1494                 modules.put(module.name, module);
1495             }
1496         }
1497     }
1498     //where:
1499         private static final String PROPERITARY_ANNOTATION =
1500                 &quot;Lsun/Proprietary+Annotation;&quot;;
1501 
1502     private void dumpDescriptions(ClassList classes,
1503                                   Map&lt;String, ModuleDescription&gt; modules,
1504                                   List&lt;PlatformInput&gt; versions,
1505                                   Path ctDescriptionFile,
1506                                   String[] args) throws IOException {
1507         classes.sort();
1508 
1509         Map&lt;String, String&gt; package2Modules = new HashMap&lt;&gt;();
1510 
1511         versions.stream()
1512                 .filter(v -&gt; &quot;9&quot;.compareTo(v.version) &lt;= 0)
1513                 .sorted((v1, v2) -&gt; v1.version.compareTo(v2.version))
1514                 .forEach(v -&gt; {
1515             for (ModuleDescription md : modules.values()) {
1516                 md.header
1517                   .stream()
1518                   .filter(h -&gt; h.versions.contains(v.version))
1519                   .flatMap(h -&gt; h.exports.stream())
1520                   .map(p -&gt; p.replace(&#39;/&#39;, &#39;.&#39;))
1521                   .forEach(p -&gt; package2Modules.putIfAbsent(p, md.name));
1522             }
1523         });
1524 
1525         package2Modules.put(&quot;java.awt.dnd.peer&quot;, &quot;java.desktop&quot;);
1526         package2Modules.put(&quot;java.awt.peer&quot;, &quot;java.desktop&quot;);
1527         package2Modules.put(&quot;jdk&quot;, &quot;java.base&quot;);
1528 
1529         Map&lt;String, List&lt;ClassDescription&gt;&gt; module2Classes = new HashMap&lt;&gt;();
1530 
1531         for (ClassDescription clazz : classes) {
1532             String pack = clazz.packge();
1533             String module = package2Modules.get(pack);
1534 
1535             if (module == null) {
1536                 module = &quot;java.base&quot;;
1537 
1538                 OUTER: while (!pack.isEmpty()) {
1539                     for (Entry&lt;String, String&gt; p2M : package2Modules.entrySet()) {
1540                         if (p2M.getKey().startsWith(pack)) {
1541                             module = p2M.getValue();
1542                             break OUTER;
1543                         }
1544                     }
1545                     int dot = pack.lastIndexOf(&#39;.&#39;);
1546                     if (dot == (-1))
1547                         break;
1548                     pack = pack.substring(0, dot);
1549                 }
1550             }
1551             module2Classes.computeIfAbsent(module, m -&gt; new ArrayList&lt;&gt;())
1552                     .add(clazz);
1553         }
1554 
1555         modules.keySet()
1556                .stream()
1557                .filter(m -&gt; !module2Classes.containsKey(m))
1558                .forEach(m -&gt; module2Classes.put(m, Collections.emptyList()));
1559 
1560         Files.createDirectories(ctDescriptionFile.getParent());
1561 
1562         int year = Calendar.getInstance(TimeZone.getTimeZone(&quot;UTF&quot;), Locale.ROOT)
1563                            .get(Calendar.YEAR);
1564 
1565         try (Writer symbolsOut = Files.newBufferedWriter(ctDescriptionFile)) {
1566             Map&lt;PlatformInput, List&lt;String&gt;&gt; outputFiles = new LinkedHashMap&lt;&gt;();
1567 
1568             for (PlatformInput desc : versions) {
1569                 List&lt;String&gt; files = desc.files;
1570 
1571                 if (files == null) {
1572                     files = new ArrayList&lt;&gt;();
1573                     for (Entry&lt;String, List&lt;ClassDescription&gt;&gt; e : module2Classes.entrySet()) {
1574                         StringWriter data = new StringWriter();
1575                         ModuleDescription module = modules.get(e.getKey());
1576 
1577                         module.write(data, desc.basePlatform, desc.version);
1578 
1579                         for (ClassDescription clazz : e.getValue()) {
1580                             clazz.write(data, desc.basePlatform, desc.version);
1581                         }
1582 
1583                         String fileName = e.getKey() + &quot;-&quot; + desc.version + &quot;.sym.txt&quot;;
1584                         Path f = ctDescriptionFile.getParent().resolve(fileName);
1585 
1586                         String dataString = data.toString();
1587 
1588                         if (!dataString.isEmpty()) {
1589                             try (Writer out = Files.newBufferedWriter(f)) {
1590                                 out.append(DO_NO_MODIFY.replace(&quot;{YEAR}&quot;, String.valueOf(year)));
1591                                 out.write(dataString);
1592                             }
1593                             files.add(f.getFileName().toString());
1594                         }
1595                     }
1596                 }
1597 
1598                 outputFiles.put(desc, files);
1599             }
1600             symbolsOut.append(DO_NO_MODIFY.replace(&quot;{YEAR}&quot;, &quot;2015, &quot; + year));
1601             symbolsOut.append(&quot;#command used to generate this file:\n&quot;);
1602             symbolsOut.append(&quot;#&quot;)
1603                       .append(CreateSymbols.class.getName())
1604                       .append(&quot; &quot;)
1605                       .append(Arrays.stream(args)
1606                                     .collect(Collectors.joining(&quot; &quot;)))
1607                       .append(&quot;\n&quot;);
1608             symbolsOut.append(&quot;#\n&quot;);
1609             symbolsOut.append(&quot;generate platforms &quot;)
1610                       .append(versions.stream()
1611                                       .map(v -&gt; v.version)
1612                                       .sorted()
1613                                       .collect(Collectors.joining(&quot;:&quot;)))
1614                       .append(&quot;\n&quot;);
1615             for (Entry&lt;PlatformInput, List&lt;String&gt;&gt; versionFileEntry : outputFiles.entrySet()) {
1616                 symbolsOut.append(&quot;platform version &quot;)
1617                           .append(versionFileEntry.getKey().version);
1618                 if (versionFileEntry.getKey().basePlatform != null) {
1619                     symbolsOut.append(&quot; base &quot;)
1620                               .append(versionFileEntry.getKey().basePlatform);
1621                 }
1622                 symbolsOut.append(&quot; files &quot;)
1623                           .append(versionFileEntry.getValue()
1624                                                   .stream()
1625                                                   .map(p -&gt; p)
1626                                                   .sorted()
1627                                                   .collect(Collectors.joining(&quot;:&quot;)))
1628                           .append(&quot;\n&quot;);
1629             }
1630         }
1631     }
1632 
1633     public void createIncrementalBaseLine(String ctDescriptionFile,
1634                                           String excludeFile,
1635                                           String[] args) throws IOException {
1636         String specVersion = System.getProperty(&quot;java.specification.version&quot;);
1637         String currentVersion =
1638                 Integer.toString(Integer.parseInt(specVersion), Character.MAX_RADIX);
1639         currentVersion = currentVersion.toUpperCase(Locale.ROOT);
1640         Path ctDescriptionPath = Paths.get(ctDescriptionFile).toAbsolutePath();
1641         LoadDescriptions data = load(null, ctDescriptionPath, currentVersion);
1642 
1643         ClassList classes = data.classes;
1644         Map&lt;String, ModuleDescription&gt; modules = data.modules;
1645         List&lt;PlatformInput&gt; versions = data.versions;
1646 
1647         ExcludeIncludeList excludeList =
1648                 ExcludeIncludeList.create(excludeFile);
1649 
1650         Iterable&lt;byte[]&gt; classBytes = dumpCurrentClasses();
1651         loadVersionClasses(classes, modules, classBytes, excludeList, currentVersion);
1652 
1653         String baseline;
1654 
1655         if (versions.isEmpty()) {
1656             baseline = null;
1657         } else {
1658             baseline = versions.stream()
1659                                .sorted((v1, v2) -&gt; v2.version.compareTo(v1.version))
1660                                .findFirst()
1661                                .get()
1662                                .version;
1663         }
1664 
1665         versions.add(new PlatformInput(null, currentVersion, baseline, null));
1666         dumpDescriptions(classes, modules, versions, ctDescriptionPath, args);
1667     }
1668 
1669     private List&lt;byte[]&gt; dumpCurrentClasses() throws IOException {
1670         JavacTool tool = JavacTool.create();
1671         Context ctx = new Context();
1672         String version = System.getProperty(&quot;java.specification.version&quot;);
1673         JavacTask task = tool.getTask(null, null, null,
1674                                       List.of(&quot;--release&quot;, version),
1675                                       null, null, ctx);
1676         task.getElements().getTypeElement(&quot;java.lang.Object&quot;);
1677         JavaFileManager fm = ctx.get(JavaFileManager.class);
1678 
1679         List&lt;byte[]&gt; data = new ArrayList&lt;&gt;();
1680         for (Location modLoc : LOCATIONS) {
1681             for (Set&lt;JavaFileManager.Location&gt; module :
1682                     fm.listLocationsForModules(modLoc)) {
1683                 for (JavaFileManager.Location loc : module) {
1684                     Iterable&lt;JavaFileObject&gt; files =
1685                             fm.list(loc,
1686                                     &quot;&quot;,
1687                                     EnumSet.of(Kind.CLASS),
1688                                     true);
1689 
1690                     for (JavaFileObject jfo : files) {
1691                         try (InputStream is = jfo.openInputStream();
1692                              InputStream in =
1693                                      new BufferedInputStream(is)) {
1694                             ByteArrayOutputStream baos =
1695                                     new ByteArrayOutputStream();
1696 
1697                             in.transferTo(baos);
1698                             data.add(baos.toByteArray());
1699                         }
1700                     }
1701                 }
1702             }
1703         }
1704 
1705         return data;
1706     }
1707     //where:
1708         private static final List&lt;StandardLocation&gt; LOCATIONS =
1709                 List.of(StandardLocation.SYSTEM_MODULES,
1710                         StandardLocation.UPGRADE_MODULE_PATH);
1711 
1712     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Class Reading&quot;&gt;
1713     //non-final for tests:
1714     public static String PROFILE_ANNOTATION = &quot;Ljdk/Profile+Annotation;&quot;;
1715     public static boolean ALLOW_NON_EXISTING_CLASSES = false;
1716 
1717     private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version) throws IOException, ConstantPoolException {
1718         ClassFile cf = ClassFile.read(in);
1719 
1720         if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {
1721             return ;
1722         }
1723 
1724         if (!excludesIncludes.accepts(cf.getName())) {
1725             return ;
1726         }
1727 
1728         ClassHeaderDescription headerDesc = new ClassHeaderDescription();
1729 
1730         headerDesc.flags = cf.access_flags.flags;
1731 
1732         if (cf.super_class != 0) {
1733             headerDesc.extendsAttr = cf.getSuperclassName();
1734         }
1735         List&lt;String&gt; interfaces = new ArrayList&lt;&gt;();
1736         for (int i = 0; i &lt; cf.interfaces.length; i++) {
1737             interfaces.add(cf.getInterfaceName(i));
1738         }
1739         headerDesc.implementsAttr = interfaces;
1740         for (Attribute attr : cf.attributes) {
1741             if (!readAttribute(cf, headerDesc, attr))
1742                 return ;
1743         }
1744 
1745         ClassDescription clazzDesc = null;
1746 
1747         for (ClassDescription cd : classes) {
1748             if (cd.name.equals(cf.getName())) {
1749                 clazzDesc = cd;
1750                 break;
1751             }
1752         }
1753 
1754         if (clazzDesc == null) {
1755             clazzDesc = new ClassDescription();
1756             clazzDesc.name = cf.getName();
1757             classes.add(clazzDesc);
1758         }
1759 
1760         addClassHeader(clazzDesc, headerDesc, version);
1761 
1762         for (Method m : cf.methods) {
1763             if (!include(m.access_flags.flags))
1764                 continue;
1765             MethodDescription methDesc = new MethodDescription();
1766             methDesc.flags = m.access_flags.flags;
1767             methDesc.name = m.getName(cf.constant_pool);
1768             methDesc.descriptor = m.descriptor.getValue(cf.constant_pool);
1769             for (Attribute attr : m.attributes) {
1770                 readAttribute(cf, methDesc, attr);
1771             }
1772             addMethod(clazzDesc, methDesc, version);
1773         }
1774         for (Field f : cf.fields) {
1775             if (!include(f.access_flags.flags))
1776                 continue;
1777             FieldDescription fieldDesc = new FieldDescription();
1778             fieldDesc.flags = f.access_flags.flags;
1779             fieldDesc.name = f.getName(cf.constant_pool);
1780             fieldDesc.descriptor = f.descriptor.getValue(cf.constant_pool);
1781             for (Attribute attr : f.attributes) {
1782                 readAttribute(cf, fieldDesc, attr);
1783             }
1784             addField(clazzDesc, fieldDesc, version);
1785         }
1786     }
1787 
1788     private void inspectModuleInfoClassFile(InputStream in,
1789             Map&lt;String, ModuleDescription&gt; modules,
1790             String version) throws IOException, ConstantPoolException {
1791         ClassFile cf = ClassFile.read(in);
1792 
1793         if (!cf.access_flags.is(AccessFlags.ACC_MODULE)) {
1794             return ;
1795         }
1796 
1797         ModuleHeaderDescription headerDesc = new ModuleHeaderDescription();
1798 
1799         headerDesc.versions = version;
1800         headerDesc.flags = cf.access_flags.flags;
1801 
1802         for (Attribute attr : cf.attributes) {
1803             if (!readAttribute(cf, headerDesc, attr))
1804                 return ;
1805         }
1806 
1807         String name = headerDesc.name;
1808 
1809         ModuleDescription moduleDesc = modules.get(name);
1810 
1811         if (moduleDesc == null) {
1812             moduleDesc = new ModuleDescription();
1813             moduleDesc.name = name;
1814             modules.put(moduleDesc.name, moduleDesc);
1815         }
1816 
1817         addModuleHeader(moduleDesc, headerDesc, version);
1818     }
1819 
1820     private void addModuleHeader(ModuleDescription moduleDesc,
1821                                  ModuleHeaderDescription headerDesc,
1822                                  String version) {
1823         //normalize:
1824         boolean existed = false;
1825         for (ModuleHeaderDescription existing : moduleDesc.header) {
1826             if (existing.equals(headerDesc)) {
1827                 headerDesc = existing;
1828                 existed = true;
1829             }
1830         }
1831 
1832         headerDesc.versions += version;
1833 
1834         if (!existed) {
1835             moduleDesc.header.add(headerDesc);
1836         }
1837     }
1838 
1839     private boolean include(int accessFlags) {
1840         return (accessFlags &amp; (AccessFlags.ACC_PUBLIC | AccessFlags.ACC_PROTECTED)) != 0;
1841     }
1842 
1843     private void addClassHeader(ClassDescription clazzDesc, ClassHeaderDescription headerDesc, String version) {
1844         //normalize:
1845         boolean existed = false;
1846         for (ClassHeaderDescription existing : clazzDesc.header) {
1847             if (existing.equals(headerDesc)) {
1848                 headerDesc = existing;
1849                 existed = true;
1850             }
1851         }
1852 
1853         if (!existed) {
1854             //check if the only difference between the 7 and 8 version is the Profile annotation
1855             //if so, copy it to the pre-8 version, so save space
1856             for (ClassHeaderDescription existing : clazzDesc.header) {
1857                 List&lt;AnnotationDescription&gt; annots = existing.classAnnotations;
1858 
1859                 if (annots != null) {
1860                     for (AnnotationDescription ad : annots) {
1861                         if (PROFILE_ANNOTATION.equals(ad.annotationType)) {
1862                             existing.classAnnotations = new ArrayList&lt;&gt;(annots);
1863                             existing.classAnnotations.remove(ad);
1864                             if (existing.equals(headerDesc)) {
1865                                 headerDesc = existing;
1866                                 existed = true;
1867                             }
1868                             existing.classAnnotations = annots;
1869                             break;
1870                         }
1871                     }
1872                 }
1873             }
1874         }
1875 
1876         headerDesc.versions += version;
1877 
1878         if (!existed) {
1879             clazzDesc.header.add(headerDesc);
1880         }
1881     }
1882 
1883     private void addMethod(ClassDescription clazzDesc, MethodDescription methDesc, String version) {
1884         //normalize:
1885         boolean methodExisted = false;
1886         for (MethodDescription existing : clazzDesc.methods) {
1887             if (existing.equals(methDesc)) {
1888                 methodExisted = true;
1889                 methDesc = existing;
1890                 break;
1891             }
1892         }
1893         methDesc.versions += version;
1894         if (!methodExisted) {
1895             clazzDesc.methods.add(methDesc);
1896         }
1897     }
1898 
1899     private void addField(ClassDescription clazzDesc, FieldDescription fieldDesc, String version) {
1900         boolean fieldExisted = false;
1901         for (FieldDescription existing : clazzDesc.fields) {
1902             if (existing.equals(fieldDesc)) {
1903                 fieldExisted = true;
1904                 fieldDesc = existing;
1905                 break;
1906             }
1907         }
1908         fieldDesc.versions += version;
1909         if (!fieldExisted) {
1910             clazzDesc.fields.add(fieldDesc);
1911         }
1912     }
1913 
1914     private boolean readAttribute(ClassFile cf, FeatureDescription feature, Attribute attr) throws ConstantPoolException {
1915         String attrName = attr.getName(cf.constant_pool);
1916         switch (attrName) {
1917             case Attribute.AnnotationDefault:
1918                 assert feature instanceof MethodDescription;
1919                 element_value defaultValue = ((AnnotationDefault_attribute) attr).default_value;
1920                 ((MethodDescription) feature).annotationDefaultValue =
1921                         convertElementValue(cf.constant_pool, defaultValue);
1922                 break;
1923             case &quot;Deprecated&quot;:
1924                 feature.deprecated = true;
1925                 break;
1926             case &quot;Exceptions&quot;:
1927                 assert feature instanceof MethodDescription;
1928                 List&lt;String&gt; thrownTypes = new ArrayList&lt;&gt;();
1929                 Exceptions_attribute exceptionAttr = (Exceptions_attribute) attr;
1930                 for (int i = 0; i &lt; exceptionAttr.exception_index_table.length; i++) {
1931                     thrownTypes.add(exceptionAttr.getException(i, cf.constant_pool));
1932                 }
1933                 ((MethodDescription) feature).thrownTypes = thrownTypes;
1934                 break;
1935             case Attribute.InnerClasses:
1936                 if (feature instanceof ModuleHeaderDescription)
1937                     break; //XXX
1938                 assert feature instanceof ClassHeaderDescription;
1939                 List&lt;InnerClassInfo&gt; innerClasses = new ArrayList&lt;&gt;();
1940                 InnerClasses_attribute innerClassesAttr = (InnerClasses_attribute) attr;
1941                 for (int i = 0; i &lt; innerClassesAttr.number_of_classes; i++) {
1942                     CONSTANT_Class_info outerClassInfo =
1943                             innerClassesAttr.classes[i].getOuterClassInfo(cf.constant_pool);
1944                     InnerClassInfo info = new InnerClassInfo();
1945                     CONSTANT_Class_info innerClassInfo =
1946                             innerClassesAttr.classes[i].getInnerClassInfo(cf.constant_pool);
1947                     info.innerClass = innerClassInfo != null ? innerClassInfo.getName() : null;
1948                     info.outerClass = outerClassInfo != null ? outerClassInfo.getName() : null;
1949                     info.innerClassName = innerClassesAttr.classes[i].getInnerName(cf.constant_pool);
1950                     info.innerClassFlags = innerClassesAttr.classes[i].inner_class_access_flags.flags;
1951                     innerClasses.add(info);
1952                 }
1953                 ((ClassHeaderDescription) feature).innerClasses = innerClasses;
1954                 break;
1955             case &quot;RuntimeInvisibleAnnotations&quot;:
1956                 feature.classAnnotations = annotations2Description(cf.constant_pool, attr);
1957                 break;
1958             case &quot;RuntimeVisibleAnnotations&quot;:
1959                 feature.runtimeAnnotations = annotations2Description(cf.constant_pool, attr);
1960                 break;
1961             case &quot;Signature&quot;:
1962                 feature.signature = ((Signature_attribute) attr).getSignature(cf.constant_pool);
1963                 break;
1964             case &quot;ConstantValue&quot;:
1965                 assert feature instanceof FieldDescription;
1966                 Object value = convertConstantValue(cf.constant_pool.get(((ConstantValue_attribute) attr).constantvalue_index), ((FieldDescription) feature).descriptor);
1967                 if (((FieldDescription) feature).descriptor.equals(&quot;C&quot;)) {
1968                     value = (char) (int) value;
1969                 }
1970                 ((FieldDescription) feature).constantValue = value;
1971                 break;
1972             case &quot;SourceFile&quot;:
1973                 //ignore, not needed
1974                 break;
1975             case &quot;BootstrapMethods&quot;:
1976                 //ignore, not needed
1977                 break;
1978             case &quot;Code&quot;:
1979                 //ignore, not needed
1980                 break;
1981             case &quot;EnclosingMethod&quot;:
1982                 return false;
1983             case &quot;Synthetic&quot;:
1984                 break;
1985             case &quot;RuntimeVisibleParameterAnnotations&quot;:
1986                 assert feature instanceof MethodDescription;
1987                 ((MethodDescription) feature).runtimeParameterAnnotations =
1988                         parameterAnnotations2Description(cf.constant_pool, attr);
1989                 break;
1990             case &quot;RuntimeInvisibleParameterAnnotations&quot;:
1991                 assert feature instanceof MethodDescription;
1992                 ((MethodDescription) feature).classParameterAnnotations =
1993                         parameterAnnotations2Description(cf.constant_pool, attr);
1994                 break;
1995             case Attribute.Module: {
1996                 assert feature instanceof ModuleHeaderDescription;
1997                 ModuleHeaderDescription header =
1998                         (ModuleHeaderDescription) feature;
1999                 Module_attribute mod = (Module_attribute) attr;
2000 
2001                 header.name = cf.constant_pool
2002                                 .getModuleInfo(mod.module_name)
2003                                 .getName();
2004 
2005                 header.exports =
2006                         Arrays.stream(mod.exports)
2007                               .filter(ee -&gt; ee.exports_to_count == 0)
2008                               .map(ee -&gt; getPackageName(cf, ee.exports_index))
2009                               .collect(Collectors.toList());
2010                 header.requires =
2011                         Arrays.stream(mod.requires)
2012                               .map(r -&gt; RequiresDescription.create(cf, r))
2013                               .collect(Collectors.toList());
2014                 header.uses = Arrays.stream(mod.uses_index)
2015                                     .mapToObj(use -&gt; getClassName(cf, use))
2016                                     .collect(Collectors.toList());
2017                 header.provides =
2018                         Arrays.stream(mod.provides)
2019                               .map(p -&gt; ProvidesDescription.create(cf, p))
2020                               .collect(Collectors.toList());
2021                 break;
2022             }
2023             case Attribute.ModuleTarget: {
2024                 assert feature instanceof ModuleHeaderDescription;
2025                 ModuleHeaderDescription header =
2026                         (ModuleHeaderDescription) feature;
2027                 ModuleTarget_attribute mod = (ModuleTarget_attribute) attr;
2028                 if (mod.target_platform_index != 0) {
2029                     header.moduleTarget =
2030                             cf.constant_pool
2031                               .getUTF8Value(mod.target_platform_index);
2032                 }
2033                 break;
2034             }
2035             case Attribute.ModuleResolution: {
2036                 assert feature instanceof ModuleHeaderDescription;
2037                 ModuleHeaderDescription header =
2038                         (ModuleHeaderDescription) feature;
2039                 ModuleResolution_attribute mod =
2040                         (ModuleResolution_attribute) attr;
2041                 header.moduleResolution = mod.resolution_flags;
2042                 break;
2043             }
2044             case Attribute.ModulePackages:
2045             case Attribute.ModuleHashes:
2046                 break;
2047             case Attribute.NestHost: {
2048                 assert feature instanceof ClassHeaderDescription;
2049                 NestHost_attribute nestHost = (NestHost_attribute) attr;
2050                 ClassHeaderDescription chd = (ClassHeaderDescription) feature;
2051                 chd.nestHost = nestHost.getNestTop(cf.constant_pool).getName();
2052                 break;
2053             }
2054             case Attribute.NestMembers: {
2055                 assert feature instanceof ClassHeaderDescription;
2056                 NestMembers_attribute nestMembers = (NestMembers_attribute) attr;
2057                 ClassHeaderDescription chd = (ClassHeaderDescription) feature;
2058                 chd.nestMembers = Arrays.stream(nestMembers.members_indexes)
2059                                         .mapToObj(i -&gt; getClassName(cf, i))
2060                                         .collect(Collectors.toList());
2061                 break;
2062             }
2063             default:
2064                 throw new IllegalStateException(&quot;Unhandled attribute: &quot; +
2065                                                 attrName);
2066         }
2067 
2068         return true;
2069     }
2070 
2071     private static String getClassName(ClassFile cf, int idx) {
2072         try {
2073             return cf.constant_pool.getClassInfo(idx).getName();
2074         } catch (InvalidIndex ex) {
2075             throw new IllegalStateException(ex);
2076         } catch (ConstantPool.UnexpectedEntry ex) {
2077             throw new IllegalStateException(ex);
2078         } catch (ConstantPoolException ex) {
2079             throw new IllegalStateException(ex);
2080         }
2081     }
2082 
2083     private static String getPackageName(ClassFile cf, int idx) {
2084         try {
2085             return cf.constant_pool.getPackageInfo(idx).getName();
2086         } catch (InvalidIndex ex) {
2087             throw new IllegalStateException(ex);
2088         } catch (ConstantPool.UnexpectedEntry ex) {
2089             throw new IllegalStateException(ex);
2090         } catch (ConstantPoolException ex) {
2091             throw new IllegalStateException(ex);
2092         }
2093     }
2094 
2095     private static String getModuleName(ClassFile cf, int idx) {
2096         try {
2097             return cf.constant_pool.getModuleInfo(idx).getName();
2098         } catch (InvalidIndex ex) {
2099             throw new IllegalStateException(ex);
2100         } catch (ConstantPool.UnexpectedEntry ex) {
2101             throw new IllegalStateException(ex);
2102         } catch (ConstantPoolException ex) {
2103             throw new IllegalStateException(ex);
2104         }
2105     }
2106 
2107     private static Integer getVersion(ClassFile cf, int idx) {
2108         if (idx == 0)
2109             return null;
2110         try {
2111             return ((CONSTANT_Integer_info) cf.constant_pool.get(idx)).value;
2112         } catch (InvalidIndex ex) {
2113             throw new IllegalStateException(ex);
2114         }
2115     }
2116 
2117     Object convertConstantValue(CPInfo info, String descriptor) throws ConstantPoolException {
2118         if (info instanceof CONSTANT_Integer_info) {
2119             if (&quot;Z&quot;.equals(descriptor))
2120                 return ((CONSTANT_Integer_info) info).value == 1;
2121             else
2122                 return ((CONSTANT_Integer_info) info).value;
2123         } else if (info instanceof CONSTANT_Long_info) {
2124             return ((CONSTANT_Long_info) info).value;
2125         } else if (info instanceof CONSTANT_Float_info) {
2126             return ((CONSTANT_Float_info) info).value;
2127         } else if (info instanceof CONSTANT_Double_info) {
2128             return ((CONSTANT_Double_info) info).value;
2129         } else if (info instanceof CONSTANT_String_info) {
2130             return ((CONSTANT_String_info) info).getString();
2131         }
2132         throw new IllegalStateException(info.getClass().getName());
2133     }
2134 
2135     Object convertElementValue(ConstantPool cp, element_value val) throws InvalidIndex, ConstantPoolException {
2136         switch (val.tag) {
2137             case &#39;Z&#39;:
2138                 return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value != 0;
2139             case &#39;B&#39;:
2140                 return (byte) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2141             case &#39;C&#39;:
2142                 return (char) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2143             case &#39;S&#39;:
2144                 return (short) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2145             case &#39;I&#39;:
2146                 return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2147             case &#39;J&#39;:
2148                 return ((CONSTANT_Long_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2149             case &#39;F&#39;:
2150                 return ((CONSTANT_Float_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2151             case &#39;D&#39;:
2152                 return ((CONSTANT_Double_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2153             case &#39;s&#39;:
2154                 return ((CONSTANT_Utf8_info) cp.get(((Primitive_element_value) val).const_value_index)).value;
2155 
2156             case &#39;e&#39;:
2157                 return new EnumConstant(cp.getUTF8Value(((Enum_element_value) val).type_name_index),
2158                         cp.getUTF8Value(((Enum_element_value) val).const_name_index));
2159             case &#39;c&#39;:
2160                 return new ClassConstant(cp.getUTF8Value(((Class_element_value) val).class_info_index));
2161 
2162             case &#39;@&#39;:
2163                 return annotation2Description(cp, ((Annotation_element_value) val).annotation_value);
2164 
2165             case &#39;[&#39;:
2166                 List&lt;Object&gt; values = new ArrayList&lt;&gt;();
2167                 for (element_value elem : ((Array_element_value) val).values) {
2168                     values.add(convertElementValue(cp, elem));
2169                 }
2170                 return values;
2171             default:
2172                 throw new IllegalStateException(&quot;Currently unhandled tag: &quot; + val.tag);
2173         }
2174     }
2175 
2176     private List&lt;AnnotationDescription&gt; annotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {
2177         RuntimeAnnotations_attribute annotationsAttr = (RuntimeAnnotations_attribute) attr;
2178         List&lt;AnnotationDescription&gt; descs = new ArrayList&lt;&gt;();
2179         for (Annotation a : annotationsAttr.annotations) {
2180             descs.add(annotation2Description(cp, a));
2181         }
2182         return descs;
2183     }
2184 
2185     private List&lt;List&lt;AnnotationDescription&gt;&gt; parameterAnnotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {
2186         RuntimeParameterAnnotations_attribute annotationsAttr =
2187                 (RuntimeParameterAnnotations_attribute) attr;
2188         List&lt;List&lt;AnnotationDescription&gt;&gt; descs = new ArrayList&lt;&gt;();
2189         for (Annotation[] attrAnnos : annotationsAttr.parameter_annotations) {
2190             List&lt;AnnotationDescription&gt; paramDescs = new ArrayList&lt;&gt;();
2191             for (Annotation ann : attrAnnos) {
2192                 paramDescs.add(annotation2Description(cp, ann));
2193             }
2194             descs.add(paramDescs);
2195         }
2196         return descs;
2197     }
2198 
2199     private AnnotationDescription annotation2Description(ConstantPool cp, Annotation a) throws ConstantPoolException {
2200         String annotationType = cp.getUTF8Value(a.type_index);
2201         Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
2202 
2203         for (element_value_pair e : a.element_value_pairs) {
2204             values.put(cp.getUTF8Value(e.element_name_index), convertElementValue(cp, e.value));
2205         }
2206 
2207         return new AnnotationDescription(annotationType, values);
2208     }
2209     //&lt;/editor-fold&gt;
2210 
2211     protected boolean includeEffectiveAccess(ClassList classes, ClassDescription clazz) {
2212         if (!include(clazz.header.get(0).flags))
2213             return false;
2214         for (ClassDescription outer : classes.enclosingClasses(clazz)) {
2215             if (!include(outer.header.get(0).flags))
2216                 return false;
2217         }
2218         return true;
2219     }
2220 
2221     boolean include(Set&lt;String&gt; includedClasses, ClassList classes, String clazzName) {
2222         if (clazzName == null)
2223             return false;
2224 
2225         boolean modified = includedClasses.add(clazzName);
2226 
2227         for (ClassDescription outer : classes.enclosingClasses(classes.find(clazzName, true))) {
2228             modified |= includedClasses.add(outer.name);
2229         }
2230 
2231         return modified;
2232     }
2233 
2234     &lt;T extends FeatureDescription&gt; boolean includeOutputType(Iterable&lt;T&gt; features,
2235                                                              Function&lt;T, String&gt; feature2Descriptor,
2236                                                              Set&lt;String&gt; includedClasses,
2237                                                              ClassList classes) {
2238         boolean modified = false;
2239 
2240         for (T feature : features) {
2241             CharSequence sig =
2242                     feature.signature != null ? feature.signature : feature2Descriptor.apply(feature);
2243             Matcher m = OUTPUT_TYPE_PATTERN.matcher(sig);
2244             while (m.find()) {
2245                 modified |= include(includedClasses, classes, m.group(1));
2246             }
2247         }
2248 
2249         return modified;
2250     }
2251 
2252     static final Pattern OUTPUT_TYPE_PATTERN = Pattern.compile(&quot;L([^;&lt;]+)(;|&lt;)&quot;);
2253 
2254     public static class VersionDescription {
2255         public final String classes;
2256         public final String version;
2257         public final String primaryBaseline;
2258 
2259         public VersionDescription(String classes, String version, String primaryBaseline) {
2260             this.classes = classes;
2261             this.version = version;
2262             this.primaryBaseline = &quot;&lt;none&gt;&quot;.equals(primaryBaseline) ? null : primaryBaseline;
2263         }
2264 
2265     }
2266 
2267     public static class ExcludeIncludeList {
2268         public final Set&lt;String&gt; includeList;
2269         public final Set&lt;String&gt; excludeList;
2270 
2271         protected ExcludeIncludeList(Set&lt;String&gt; includeList, Set&lt;String&gt; excludeList) {
2272             this.includeList = includeList;
2273             this.excludeList = excludeList;
2274         }
2275 
2276         public static ExcludeIncludeList create(String files) throws IOException {
2277             Set&lt;String&gt; includeList = new HashSet&lt;&gt;();
2278             Set&lt;String&gt; excludeList = new HashSet&lt;&gt;();
2279             for (String file : files.split(File.pathSeparator)) {
2280                 try (Stream&lt;String&gt; lines = Files.lines(Paths.get(file))) {
2281                     lines.map(l -&gt; l.substring(0, l.indexOf(&#39;#&#39;) != (-1) ? l.indexOf(&#39;#&#39;) : l.length()))
2282                          .filter(l -&gt; !l.trim().isEmpty())
2283                          .forEach(l -&gt; {
2284                              Set&lt;String&gt; target = l.startsWith(&quot;+&quot;) ? includeList : excludeList;
2285                              target.add(l.substring(1));
2286                          });
2287                 }
2288             }
2289             return new ExcludeIncludeList(includeList, excludeList);
2290         }
2291 
2292         public boolean accepts(String className) {
2293             return matches(includeList, className) &amp;&amp; !matches(excludeList, className);
2294         }
2295 
2296         private static boolean matches(Set&lt;String&gt; list, String className) {
2297             if (list.contains(className))
2298                 return true;
2299             String pack = className.substring(0, className.lastIndexOf(&#39;/&#39;) + 1);
2300             return list.contains(pack);
2301         }
2302     }
2303     //&lt;/editor-fold&gt;
2304 
2305     //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Class Data Structures&quot;&gt;
2306     static boolean checkChange(String versions, String version,
2307                                String baselineVersion) {
2308         return versions.contains(version) ^
2309                (baselineVersion != null &amp;&amp;
2310                 versions.contains(baselineVersion));
2311     }
2312 
2313     static abstract class FeatureDescription {
2314         int flags;
2315         boolean deprecated;
2316         String signature;
2317         String versions = &quot;&quot;;
2318         List&lt;AnnotationDescription&gt; classAnnotations;
2319         List&lt;AnnotationDescription&gt; runtimeAnnotations;
2320 
2321         protected void writeAttributes(Appendable output) throws IOException {
2322             if (flags != 0)
2323                 output.append(&quot; flags &quot; + Integer.toHexString(flags));
2324             if (deprecated) {
2325                 output.append(&quot; deprecated true&quot;);
2326             }
2327             if (signature != null) {
2328                 output.append(&quot; signature &quot; + quote(signature, false));
2329             }
2330             if (classAnnotations != null &amp;&amp; !classAnnotations.isEmpty()) {
2331                 output.append(&quot; classAnnotations &quot;);
2332                 for (AnnotationDescription a : classAnnotations) {
2333                     output.append(quote(a.toString(), false));
2334                 }
2335             }
2336             if (runtimeAnnotations != null &amp;&amp; !runtimeAnnotations.isEmpty()) {
2337                 output.append(&quot; runtimeAnnotations &quot;);
2338                 for (AnnotationDescription a : runtimeAnnotations) {
2339                     output.append(quote(a.toString(), false));
2340                 }
2341             }
2342         }
2343 
2344         protected boolean shouldIgnore(String baselineVersion, String version) {
2345             return (!versions.contains(version) &amp;&amp;
2346                     (baselineVersion == null || !versions.contains(baselineVersion))) ||
2347                    (baselineVersion != null &amp;&amp;
2348                     versions.contains(baselineVersion) &amp;&amp; versions.contains(version));
2349         }
2350 
2351         public abstract void write(Appendable output, String baselineVersion, String version) throws IOException;
2352 
2353         protected void readAttributes(LineBasedReader reader) {
2354             String inFlags = reader.attributes.get(&quot;flags&quot;);
2355             if (inFlags != null &amp;&amp; !inFlags.isEmpty()) {
2356                 flags = Integer.parseInt(inFlags, 16);
2357             }
2358             String inDeprecated = reader.attributes.get(&quot;deprecated&quot;);
2359             if (&quot;true&quot;.equals(inDeprecated)) {
2360                 deprecated = true;
2361             }
2362             signature = reader.attributes.get(&quot;signature&quot;);
2363             String inClassAnnotations = reader.attributes.get(&quot;classAnnotations&quot;);
2364             if (inClassAnnotations != null) {
2365                 classAnnotations = parseAnnotations(inClassAnnotations, new int[1]);
2366             }
2367             String inRuntimeAnnotations = reader.attributes.get(&quot;runtimeAnnotations&quot;);
2368             if (inRuntimeAnnotations != null) {
2369                 runtimeAnnotations = parseAnnotations(inRuntimeAnnotations, new int[1]);
2370             }
2371         }
2372 
2373         public abstract boolean read(LineBasedReader reader) throws IOException;
2374 
2375         @Override
2376         public int hashCode() {
2377             int hash = 3;
2378             hash = 89 * hash + this.flags;
2379             hash = 89 * hash + (this.deprecated ? 1 : 0);
2380             hash = 89 * hash + Objects.hashCode(this.signature);
2381             hash = 89 * hash + listHashCode(this.classAnnotations);
2382             hash = 89 * hash + listHashCode(this.runtimeAnnotations);
2383             return hash;
2384         }
2385 
2386         @Override
2387         public boolean equals(Object obj) {
2388             if (obj == null) {
2389                 return false;
2390             }
2391             if (getClass() != obj.getClass()) {
2392                 return false;
2393             }
2394             final FeatureDescription other = (FeatureDescription) obj;
2395             if (this.flags != other.flags) {
2396                 return false;
2397             }
2398             if (this.deprecated != other.deprecated) {
2399                 return false;
2400             }
2401             if (!Objects.equals(this.signature, other.signature)) {
2402                 return false;
2403             }
2404             if (!listEquals(this.classAnnotations, other.classAnnotations)) {
2405                 return false;
2406             }
2407             if (!listEquals(this.runtimeAnnotations, other.runtimeAnnotations)) {
2408                 return false;
2409             }
2410             return true;
2411         }
2412 
2413     }
2414 
2415     public static class ModuleDescription {
2416         String name;
2417         List&lt;ModuleHeaderDescription&gt; header = new ArrayList&lt;&gt;();
2418 
2419         public void write(Appendable output, String baselineVersion,
2420                           String version) throws IOException {
2421             boolean inBaseline = false;
2422             boolean inVersion = false;
2423             for (ModuleHeaderDescription mhd : header) {
2424                 if (baselineVersion != null &amp;&amp;
2425                     mhd.versions.contains(baselineVersion)) {
2426                     inBaseline = true;
2427                 }
2428                 if (mhd.versions.contains(version)) {
2429                     inVersion = true;
2430                 }
2431             }
2432             if (!inVersion &amp;&amp; !inBaseline)
2433                 return ;
2434             if (!inVersion) {
2435                 output.append(&quot;-module name &quot; + name + &quot;\n\n&quot;);
2436                 return;
2437             }
2438             boolean hasChange = hasChange(header, version, baselineVersion);
2439             if (!hasChange)
2440                 return;
2441 
2442             output.append(&quot;module name &quot; + name + &quot;\n&quot;);
2443             for (ModuleHeaderDescription header : header) {
2444                 header.write(output, baselineVersion, version);
2445             }
2446             output.append(&quot;\n&quot;);
2447         }
2448 
2449         boolean hasChange(List&lt;? extends FeatureDescription&gt; hasChange,
2450                           String version, String baseline) {
2451             return hasChange.stream()
2452                             .map(fd -&gt; fd.versions)
2453                             .anyMatch(versions -&gt; checkChange(versions,
2454                                                               version,
2455                                                               baseline));
2456         }
2457 
2458         public void read(LineBasedReader reader, String baselineVersion,
2459                          String version) throws IOException {
2460             if (!&quot;module&quot;.equals(reader.lineKey))
2461                 return ;
2462 
2463             name = reader.attributes.get(&quot;name&quot;);
2464 
2465             reader.moveNext();
2466 
2467             OUTER: while (reader.hasNext()) {
2468                 switch (reader.lineKey) {
2469                     case &quot;header&quot;:
2470                         removeVersion(header, h -&gt; true, version);
2471                         ModuleHeaderDescription mhd =
2472                                 new ModuleHeaderDescription();
2473                         mhd.read(reader);
2474                         mhd.name = name;
2475                         mhd.versions = version;
2476                         header.add(mhd);
2477                         break;
2478                     case &quot;class&quot;:
2479                     case &quot;-class&quot;:
2480                     case &quot;module&quot;:
2481                     case &quot;-module&quot;:
2482                         break OUTER;
2483                     default:
2484                         throw new IllegalStateException(reader.lineKey);
2485                 }
2486             }
2487         }
2488     }
2489 
2490     static class ModuleHeaderDescription extends HeaderDescription {
2491         String name;
2492         List&lt;String&gt; exports = new ArrayList&lt;&gt;();
2493         List&lt;String&gt; opens = new ArrayList&lt;&gt;();
2494         List&lt;RequiresDescription&gt; requires = new ArrayList&lt;&gt;();
2495         List&lt;String&gt; uses = new ArrayList&lt;&gt;();
2496         List&lt;ProvidesDescription&gt; provides = new ArrayList&lt;&gt;();
2497         Integer moduleResolution;
2498         String moduleTarget;
2499 
2500         @Override
2501         public int hashCode() {
2502             int hash = super.hashCode();
2503             hash = 83 * hash + Objects.hashCode(this.name);
2504             hash = 83 * hash + Objects.hashCode(this.exports);
2505             hash = 83 * hash + Objects.hashCode(this.opens);
2506             hash = 83 * hash + Objects.hashCode(this.requires);
2507             hash = 83 * hash + Objects.hashCode(this.uses);
2508             hash = 83 * hash + Objects.hashCode(this.provides);
2509             hash = 83 * hash + Objects.hashCode(this.moduleResolution);
2510             hash = 83 * hash + Objects.hashCode(this.moduleTarget);
2511             return hash;
2512         }
2513 
2514         @Override
2515         public boolean equals(Object obj) {
2516             if (this == obj) {
2517                 return true;
2518             }
2519             if (!super.equals(obj)) {
2520                 return false;
2521             }
2522             final ModuleHeaderDescription other =
2523                     (ModuleHeaderDescription) obj;
2524             if (!Objects.equals(this.name, other.name)) {
2525                 return false;
2526             }
2527             if (!listEquals(this.exports, other.exports)) {
2528                 return false;
2529             }
2530             if (!listEquals(this.opens, other.opens)) {
2531                 return false;
2532             }
2533             if (!listEquals(this.requires, other.requires)) {
2534                 return false;
2535             }
2536             if (!listEquals(this.uses, other.uses)) {
2537                 return false;
2538             }
2539             if (!listEquals(this.provides, other.provides)) {
2540                 return false;
2541             }
2542             if (!Objects.equals(this.moduleTarget, other.moduleTarget)) {
2543                 return false;
2544             }
2545             if (!Objects.equals(this.moduleResolution,
2546                                 other.moduleResolution)) {
2547                 return false;
2548             }
2549             return true;
2550         }
2551 
2552         @Override
2553         public void write(Appendable output, String baselineVersion,
2554                           String version) throws IOException {
2555             if (!versions.contains(version) ||
2556                 (baselineVersion != null &amp;&amp; versions.contains(baselineVersion)
2557                  &amp;&amp; versions.contains(version)))
2558                 return ;
2559             output.append(&quot;header&quot;);
2560             if (exports != null &amp;&amp; !exports.isEmpty())
2561                 output.append(&quot; exports &quot; + serializeList(exports));
2562             if (opens != null &amp;&amp; !opens.isEmpty())
2563                 output.append(&quot; opens &quot; + serializeList(opens));
2564             if (requires != null &amp;&amp; !requires.isEmpty()) {
2565                 List&lt;String&gt; requiresList =
2566                         requires.stream()
2567                                 .map(req -&gt; req.serialize())
2568                                 .collect(Collectors.toList());
2569                 output.append(&quot; requires &quot; + serializeList(requiresList));
2570             }
2571             if (uses != null &amp;&amp; !uses.isEmpty())
2572                 output.append(&quot; uses &quot; + serializeList(uses));
2573             if (provides != null &amp;&amp; !provides.isEmpty()) {
2574                 List&lt;String&gt; providesList =
2575                         provides.stream()
2576                                 .map(p -&gt; p.serialize())
2577                                 .collect(Collectors.toList());
2578                 output.append(&quot; provides &quot; + serializeList(providesList));
2579             }
2580             if (moduleTarget != null)
2581                 output.append(&quot; target &quot; + quote(moduleTarget, true));
2582             if (moduleResolution != null)
2583                 output.append(&quot; resolution &quot; +
2584                               quote(Integer.toHexString(moduleResolution),
2585                                     true));
2586             writeAttributes(output);
2587             output.append(&quot;\n&quot;);
2588             writeInnerClasses(output, baselineVersion, version);
2589         }
2590 
2591         private static Map&lt;String, String&gt; splitAttributes(String data) {
2592             String[] parts = data.split(&quot; &quot;);
2593 
2594             Map&lt;String, String&gt; attributes = new HashMap&lt;&gt;();
2595 
2596             for (int i = 0; i &lt; parts.length; i += 2) {
2597                 attributes.put(parts[i], unquote(parts[i + 1]));
2598             }
2599 
2600             return attributes;
2601         }
2602 
2603         @Override
2604         public boolean read(LineBasedReader reader) throws IOException {
2605             if (!&quot;header&quot;.equals(reader.lineKey))
2606                 return false;
2607 
2608             exports = deserializeList(reader.attributes.get(&quot;exports&quot;));
2609             opens = deserializeList(reader.attributes.get(&quot;opens&quot;));
2610             List&lt;String&gt; requiresList =
2611                     deserializeList(reader.attributes.get(&quot;requires&quot;));
2612             requires = requiresList.stream()
2613                                    .map(RequiresDescription::deserialize)
2614                                    .collect(Collectors.toList());
2615             uses = deserializeList(reader.attributes.get(&quot;uses&quot;));
2616             List&lt;String&gt; providesList =
2617                     deserializeList(reader.attributes.get(&quot;provides&quot;), false);
2618             provides = providesList.stream()
2619                                    .map(ProvidesDescription::deserialize)
2620                                    .collect(Collectors.toList());
2621 
2622             moduleTarget = reader.attributes.get(&quot;target&quot;);
2623 
2624             if (reader.attributes.containsKey(&quot;resolution&quot;)) {
2625                 final String resolutionFlags =
2626                         reader.attributes.get(&quot;resolution&quot;);
2627                 moduleResolution = Integer.parseInt(resolutionFlags, 16);
2628             }
2629 
2630             readAttributes(reader);
2631             reader.moveNext();
2632             readInnerClasses(reader);
2633 
2634             return true;
2635         }
2636 
2637         static class RequiresDescription {
2638             final String moduleName;
2639             final int flags;
2640             final Integer version;
2641 
2642             public RequiresDescription(String moduleName, int flags,
2643                                        Integer version) {
2644                 this.moduleName = moduleName;
2645                 this.flags = flags;
2646                 this.version = version;
2647             }
2648 
2649             public String serialize() {
2650                 String versionKeyValue = version != null
2651                         ? &quot; version &quot; + quote(String.valueOf(version), true)
2652                         : &quot;&quot;;
2653                 return &quot;name &quot; + quote(moduleName, true) +
2654                        &quot; flags &quot; + quote(Integer.toHexString(flags), true) +
2655                        versionKeyValue;
2656             }
2657 
2658             public static RequiresDescription deserialize(String data) {
2659                 Map&lt;String, String&gt; attributes = splitAttributes(data);
2660 
2661                 Integer ver = attributes.containsKey(&quot;version&quot;)
2662                         ? Integer.parseInt(attributes.get(&quot;version&quot;))
2663                         : null;
2664                 int flags = Integer.parseInt(attributes.get(&quot;flags&quot;), 16);
2665                 return new RequiresDescription(attributes.get(&quot;name&quot;),
2666                                                flags,
2667                                                ver);
2668             }
2669 
2670             public static RequiresDescription create(ClassFile cf,
2671                                                      RequiresEntry req) {
2672                 String mod = getModuleName(cf, req.requires_index);
2673                 Integer ver = getVersion(cf, req.requires_version_index);
2674                 return new RequiresDescription(mod,
2675                                                req.requires_flags,
2676                                                ver);
2677             }
2678 
2679             @Override
2680             public int hashCode() {
2681                 int hash = 7;
2682                 hash = 53 * hash + Objects.hashCode(this.moduleName);
2683                 hash = 53 * hash + this.flags;
2684                 hash = 53 * hash + Objects.hashCode(this.version);
2685                 return hash;
2686             }
2687 
2688             @Override
2689             public boolean equals(Object obj) {
2690                 if (this == obj) {
2691                     return true;
2692                 }
2693                 if (obj == null) {
2694                     return false;
2695                 }
2696                 if (getClass() != obj.getClass()) {
2697                     return false;
2698                 }
2699                 final RequiresDescription other = (RequiresDescription) obj;
2700                 if (this.flags != other.flags) {
2701                     return false;
2702                 }
2703                 if (!Objects.equals(this.moduleName, other.moduleName)) {
2704                     return false;
2705                 }
2706                 if (!Objects.equals(this.version, other.version)) {
2707                     return false;
2708                 }
2709                 return true;
2710             }
2711 
2712         }
2713 
2714         static class ProvidesDescription {
2715             final String interfaceName;
2716             final List&lt;String&gt; implNames;
2717 
2718             public ProvidesDescription(String interfaceName,
2719                                        List&lt;String&gt; implNames) {
2720                 this.interfaceName = interfaceName;
2721                 this.implNames = implNames;
2722             }
2723 
2724             public String serialize() {
2725                 return &quot;interface &quot; + quote(interfaceName, true) +
2726                        &quot; impls &quot; + quote(serializeList(implNames), true, true);
2727             }
2728 
2729             public static ProvidesDescription deserialize(String data) {
2730                 Map&lt;String, String&gt; attributes = splitAttributes(data);
2731                 List&lt;String&gt; implsList =
2732                         deserializeList(attributes.get(&quot;impls&quot;),
2733                                         false);
2734                 return new ProvidesDescription(attributes.get(&quot;interface&quot;),
2735                                                implsList);
2736             }
2737 
2738             public static ProvidesDescription create(ClassFile cf,
2739                                                      ProvidesEntry prov) {
2740                 String api = getClassName(cf, prov.provides_index);
2741                 List&lt;String&gt; impls =
2742                         Arrays.stream(prov.with_index)
2743                               .mapToObj(wi -&gt; getClassName(cf, wi))
2744                               .collect(Collectors.toList());
2745                 return new ProvidesDescription(api, impls);
2746             }
2747 
2748             @Override
2749             public int hashCode() {
2750                 int hash = 5;
2751                 hash = 53 * hash + Objects.hashCode(this.interfaceName);
2752                 hash = 53 * hash + Objects.hashCode(this.implNames);
2753                 return hash;
2754             }
2755 
2756             @Override
2757             public boolean equals(Object obj) {
2758                 if (this == obj) {
2759                     return true;
2760                 }
2761                 if (obj == null) {
2762                     return false;
2763                 }
2764                 if (getClass() != obj.getClass()) {
2765                     return false;
2766                 }
2767                 final ProvidesDescription other = (ProvidesDescription) obj;
2768                 if (!Objects.equals(this.interfaceName, other.interfaceName)) {
2769                     return false;
2770                 }
2771                 if (!Objects.equals(this.implNames, other.implNames)) {
2772                     return false;
2773                 }
2774                 return true;
2775             }
2776         }
2777     }
2778 
2779     public static class ClassDescription {
2780         String name;
2781         List&lt;ClassHeaderDescription&gt; header = new ArrayList&lt;&gt;();
2782         List&lt;MethodDescription&gt; methods = new ArrayList&lt;&gt;();
2783         List&lt;FieldDescription&gt; fields = new ArrayList&lt;&gt;();
2784 
2785         public void write(Appendable output, String baselineVersion,
2786                           String version) throws IOException {
2787             boolean inBaseline = false;
2788             boolean inVersion = false;
2789             for (ClassHeaderDescription chd : header) {
2790                 if (baselineVersion != null &amp;&amp;
2791                     chd.versions.contains(baselineVersion)) {
2792                     inBaseline = true;
2793                 }
2794                 if (chd.versions.contains(version)) {
2795                     inVersion = true;
2796                 }
2797             }
2798             if (!inVersion &amp;&amp; !inBaseline)
2799                 return ;
2800             if (!inVersion) {
2801                 output.append(&quot;-class name &quot; + name + &quot;\n\n&quot;);
2802                 return;
2803             }
2804             boolean hasChange = hasChange(header, version, baselineVersion) ||
2805                                 hasChange(fields, version, baselineVersion) ||
2806                                 hasChange(methods, version, baselineVersion);
2807             if (!hasChange)
2808                 return;
2809 
2810             output.append(&quot;class name &quot; + name + &quot;\n&quot;);
2811             for (ClassHeaderDescription header : header) {
2812                 header.write(output, baselineVersion, version);
2813             }
2814             for (FieldDescription field : fields) {
2815                 field.write(output, baselineVersion, version);
2816             }
2817             for (MethodDescription method : methods) {
2818                 method.write(output, baselineVersion, version);
2819             }
2820             output.append(&quot;\n&quot;);
2821         }
2822 
2823         boolean hasChange(List&lt;? extends FeatureDescription&gt; hasChange,
2824                           String version,
2825                           String baseline) {
2826             return hasChange.stream()
2827                             .map(fd -&gt; fd.versions)
2828                             .anyMatch(versions -&gt; checkChange(versions,
2829                                                               version,
2830                                                               baseline));
2831         }
2832 
2833         public void read(LineBasedReader reader, String baselineVersion,
2834                          String version) throws IOException {
2835             if (!&quot;class&quot;.equals(reader.lineKey))
2836                 return ;
2837 
2838             name = reader.attributes.get(&quot;name&quot;);
2839 
2840             reader.moveNext();
2841 
2842             OUTER: while (reader.hasNext()) {
2843                 switch (reader.lineKey) {
2844                     case &quot;header&quot;:
2845                         removeVersion(header, h -&gt; true, version);
2846                         ClassHeaderDescription chd = new ClassHeaderDescription();
2847                         chd.read(reader);
2848                         chd.versions = version;
2849                         header.add(chd);
2850                         break;
2851                     case &quot;field&quot;:
2852                         FieldDescription field = new FieldDescription();
2853                         field.read(reader);
2854                         field.versions += version;
2855                         fields.add(field);
2856                         break;
2857                     case &quot;-field&quot;: {
2858                         removeVersion(fields,
2859                                       f -&gt; Objects.equals(f.name, reader.attributes.get(&quot;name&quot;)) &amp;&amp;
2860                                            Objects.equals(f.descriptor, reader.attributes.get(&quot;descriptor&quot;)),
2861                                       version);
2862                         reader.moveNext();
2863                         break;
2864                     }
2865                     case &quot;method&quot;:
2866                         MethodDescription method = new MethodDescription();
2867                         method.read(reader);
2868                         method.versions += version;
2869                         methods.add(method);
2870                         break;
2871                     case &quot;-method&quot;: {
2872                         removeVersion(methods,
2873                                       m -&gt; Objects.equals(m.name, reader.attributes.get(&quot;name&quot;)) &amp;&amp;
2874                                            Objects.equals(m.descriptor, reader.attributes.get(&quot;descriptor&quot;)),
2875                                       version);
2876                         reader.moveNext();
2877                         break;
2878                     }
2879                     case &quot;class&quot;:
2880                     case &quot;-class&quot;:
2881                     case &quot;module&quot;:
2882                     case &quot;-module&quot;:
2883                         break OUTER;
2884                     default:
2885                         throw new IllegalStateException(reader.lineKey);
2886                 }
2887             }
2888         }
2889 
2890         public String packge() {
2891             String pack;
2892             int lastSlash = name.lastIndexOf(&#39;/&#39;);
2893             if (lastSlash != (-1)) {
2894                 pack = name.substring(0, lastSlash).replace(&#39;/&#39;, &#39;.&#39;);
2895             } else {
2896                 pack = &quot;&quot;;
2897             }
2898 
2899             return pack;
2900         }
2901     }
2902 
2903     static class ClassHeaderDescription extends HeaderDescription {
2904         String extendsAttr;
2905         List&lt;String&gt; implementsAttr;
2906         String nestHost;
2907         List&lt;String&gt; nestMembers;
2908 
2909         @Override
2910         public int hashCode() {
2911             int hash = super.hashCode();
2912             hash = 17 * hash + Objects.hashCode(this.extendsAttr);
2913             hash = 17 * hash + Objects.hashCode(this.implementsAttr);
2914             hash = 17 * hash + Objects.hashCode(this.nestHost);
2915             hash = 17 * hash + Objects.hashCode(this.nestMembers);
2916             return hash;
2917         }
2918 
2919         @Override
2920         public boolean equals(Object obj) {
2921             if (obj == null) {
2922                 return false;
2923             }
2924             if (!super.equals(obj)) {
2925                 return false;
2926             }
2927             final ClassHeaderDescription other = (ClassHeaderDescription) obj;
2928             if (!Objects.equals(this.extendsAttr, other.extendsAttr)) {
2929                 return false;
2930             }
2931             if (!Objects.equals(this.implementsAttr, other.implementsAttr)) {
2932                 return false;
2933             }
2934             if (!Objects.equals(this.nestHost, other.nestHost)) {
2935                 return false;
2936             }
2937             if (!listEquals(this.nestMembers, other.nestMembers)) {
2938                 return false;
2939             }
2940             return true;
2941         }
2942 
2943         @Override
2944         public void write(Appendable output, String baselineVersion, String version) throws IOException {
2945             if (!versions.contains(version) ||
2946                 (baselineVersion != null &amp;&amp; versions.contains(baselineVersion) &amp;&amp; versions.contains(version)))
2947                 return ;
2948             output.append(&quot;header&quot;);
2949             if (extendsAttr != null)
2950                 output.append(&quot; extends &quot; + extendsAttr);
2951             if (implementsAttr != null &amp;&amp; !implementsAttr.isEmpty())
2952                 output.append(&quot; implements &quot; + serializeList(implementsAttr));
2953             if (nestHost != null)
2954                 output.append(&quot; nestHost &quot; + nestHost);
2955             if (nestMembers != null &amp;&amp; !nestMembers.isEmpty())
2956                 output.append(&quot; nestMembers &quot; + serializeList(nestMembers));
2957             writeAttributes(output);
2958             output.append(&quot;\n&quot;);
2959             writeInnerClasses(output, baselineVersion, version);
2960         }
2961 
2962         @Override
2963         public boolean read(LineBasedReader reader) throws IOException {
2964             if (!&quot;header&quot;.equals(reader.lineKey))
2965                 return false;
2966 
2967             extendsAttr = reader.attributes.get(&quot;extends&quot;);
2968             String elementsList = reader.attributes.get(&quot;implements&quot;);
2969             implementsAttr = deserializeList(elementsList);
2970 
2971             nestHost = reader.attributes.get(&quot;nestHost&quot;);
2972             String nestMembersList = reader.attributes.get(&quot;nestMembers&quot;);
2973             nestMembers = deserializeList(nestMembersList);
2974 
2975             readAttributes(reader);
2976             reader.moveNext();
2977             readInnerClasses(reader);
2978 
2979             return true;
2980         }
2981 
2982     }
2983 
2984     static abstract class HeaderDescription extends FeatureDescription {
2985         List&lt;InnerClassInfo&gt; innerClasses;
2986 
2987         @Override
2988         public int hashCode() {
2989             int hash = super.hashCode();
2990             hash = 19 * hash + Objects.hashCode(this.innerClasses);
2991             return hash;
2992         }
2993 
2994         @Override
2995         public boolean equals(Object obj) {
2996             if (obj == null) {
2997                 return false;
2998             }
2999             if (!super.equals(obj)) {
3000                 return false;
3001             }
3002             final HeaderDescription other = (HeaderDescription) obj;
3003             if (!listEquals(this.innerClasses, other.innerClasses)) {
3004                 return false;
3005             }
3006             return true;
3007         }
3008 
3009         protected void writeInnerClasses(Appendable output,
3010                                          String baselineVersion,
3011                                          String version) throws IOException {
3012             if (innerClasses != null &amp;&amp; !innerClasses.isEmpty()) {
3013                 for (InnerClassInfo ici : innerClasses) {
3014                     output.append(&quot;innerclass&quot;);
3015                     output.append(&quot; innerClass &quot; + ici.innerClass);
3016                     output.append(&quot; outerClass &quot; + ici.outerClass);
3017                     output.append(&quot; innerClassName &quot; + ici.innerClassName);
3018                     output.append(&quot; flags &quot; + Integer.toHexString(ici.innerClassFlags));
3019                     output.append(&quot;\n&quot;);
3020                 }
3021             }
3022         }
3023 
3024         protected void readInnerClasses(LineBasedReader reader) throws IOException {
3025             innerClasses = new ArrayList&lt;&gt;();
3026 
3027             while (&quot;innerclass&quot;.equals(reader.lineKey)) {
3028                 InnerClassInfo info = new InnerClassInfo();
3029 
3030                 info.innerClass = reader.attributes.get(&quot;innerClass&quot;);
3031                 info.outerClass = reader.attributes.get(&quot;outerClass&quot;);
3032                 info.innerClassName = reader.attributes.get(&quot;innerClassName&quot;);
3033 
3034                 String inFlags = reader.attributes.get(&quot;flags&quot;);
3035                 if (inFlags != null &amp;&amp; !inFlags.isEmpty())
3036                     info.innerClassFlags = Integer.parseInt(inFlags, 16);
3037 
3038                 innerClasses.add(info);
3039 
3040                 reader.moveNext();
3041             }
3042         }
3043 
3044     }
3045 
3046     static class MethodDescription extends FeatureDescription {
3047         String name;
3048         String descriptor;
3049         List&lt;String&gt; thrownTypes;
3050         Object annotationDefaultValue;
3051         List&lt;List&lt;AnnotationDescription&gt;&gt; classParameterAnnotations;
3052         List&lt;List&lt;AnnotationDescription&gt;&gt; runtimeParameterAnnotations;
3053 
3054         @Override
3055         public int hashCode() {
3056             int hash = super.hashCode();
3057             hash = 59 * hash + Objects.hashCode(this.name);
3058             hash = 59 * hash + Objects.hashCode(this.descriptor);
3059             hash = 59 * hash + Objects.hashCode(this.thrownTypes);
3060             hash = 59 * hash + Objects.hashCode(this.annotationDefaultValue);
3061             return hash;
3062         }
3063 
3064         @Override
3065         public boolean equals(Object obj) {
3066             if (obj == null) {
3067                 return false;
3068             }
3069             if (!super.equals(obj)) {
3070                 return false;
3071             }
3072             final MethodDescription other = (MethodDescription) obj;
3073             if (!Objects.equals(this.name, other.name)) {
3074                 return false;
3075             }
3076             if (!Objects.equals(this.descriptor, other.descriptor)) {
3077                 return false;
3078             }
3079             if (!Objects.equals(this.thrownTypes, other.thrownTypes)) {
3080                 return false;
3081             }
3082             if (!Objects.equals(this.annotationDefaultValue, other.annotationDefaultValue)) {
3083                 return false;
3084             }
3085             return true;
3086         }
3087 
3088         @Override
3089         public void write(Appendable output, String baselineVersion, String version) throws IOException {
3090             if (shouldIgnore(baselineVersion, version))
3091                 return ;
3092             if (!versions.contains(version)) {
3093                 output.append(&quot;-method&quot;);
3094                 output.append(&quot; name &quot; + quote(name, false));
3095                 output.append(&quot; descriptor &quot; + quote(descriptor, false));
3096                 output.append(&quot;\n&quot;);
3097                 return ;
3098             }
3099             output.append(&quot;method&quot;);
3100             output.append(&quot; name &quot; + quote(name, false));
3101             output.append(&quot; descriptor &quot; + quote(descriptor, false));
3102             if (thrownTypes != null)
3103                 output.append(&quot; thrownTypes &quot; + serializeList(thrownTypes));
3104             if (annotationDefaultValue != null)
3105                 output.append(&quot; annotationDefaultValue &quot; + quote(AnnotationDescription.dumpAnnotationValue(annotationDefaultValue), false));
3106             writeAttributes(output);
3107             if (classParameterAnnotations != null &amp;&amp; !classParameterAnnotations.isEmpty()) {
3108                 output.append(&quot; classParameterAnnotations &quot;);
3109                 for (List&lt;AnnotationDescription&gt; pa : classParameterAnnotations) {
3110                     for (AnnotationDescription a : pa) {
3111                         output.append(quote(a.toString(), false));
3112                     }
3113                     output.append(&quot;;&quot;);
3114                 }
3115             }
3116             if (runtimeParameterAnnotations != null &amp;&amp; !runtimeParameterAnnotations.isEmpty()) {
3117                 output.append(&quot; runtimeParameterAnnotations &quot;);
3118                 for (List&lt;AnnotationDescription&gt; pa : runtimeParameterAnnotations) {
3119                     for (AnnotationDescription a : pa) {
3120                         output.append(quote(a.toString(), false));
3121                     }
3122                     output.append(&quot;;&quot;);
3123                 }
3124             }
3125             output.append(&quot;\n&quot;);
3126         }
3127 
3128         @Override
3129         public boolean read(LineBasedReader reader) throws IOException {
3130             if (!&quot;method&quot;.equals(reader.lineKey))
3131                 return false;
3132 
3133             name = reader.attributes.get(&quot;name&quot;);
3134             descriptor = reader.attributes.get(&quot;descriptor&quot;);
3135 
3136             String thrownTypesValue = reader.attributes.get(&quot;thrownTypes&quot;);
3137 
3138             if (thrownTypesValue != null) {
3139                 thrownTypes = deserializeList(thrownTypesValue);
3140             }
3141 
3142             String inAnnotationDefaultValue = reader.attributes.get(&quot;annotationDefaultValue&quot;);
3143 
3144             if (inAnnotationDefaultValue != null) {
3145                 annotationDefaultValue = parseAnnotationValue(inAnnotationDefaultValue, new int[1]);
3146             }
3147 
3148             readAttributes(reader);
3149 
3150             String inClassParamAnnotations = reader.attributes.get(&quot;classParameterAnnotations&quot;);
3151             if (inClassParamAnnotations != null) {
3152                 List&lt;List&lt;AnnotationDescription&gt;&gt; annos = new ArrayList&lt;&gt;();
3153                 int[] pointer = new int[1];
3154                 do {
3155                     annos.add(parseAnnotations(inClassParamAnnotations, pointer));
3156                     assert pointer[0] == inClassParamAnnotations.length() || inClassParamAnnotations.charAt(pointer[0]) == &#39;;&#39;;
3157                 } while (++pointer[0] &lt; inClassParamAnnotations.length());
3158                 classParameterAnnotations = annos;
3159             }
3160 
3161             String inRuntimeParamAnnotations = reader.attributes.get(&quot;runtimeParameterAnnotations&quot;);
3162             if (inRuntimeParamAnnotations != null) {
3163                 List&lt;List&lt;AnnotationDescription&gt;&gt; annos = new ArrayList&lt;&gt;();
3164                 int[] pointer = new int[1];
3165                 do {
3166                     annos.add(parseAnnotations(inRuntimeParamAnnotations, pointer));
3167                     assert pointer[0] == inRuntimeParamAnnotations.length() || inRuntimeParamAnnotations.charAt(pointer[0]) == &#39;;&#39;;
3168                 } while (++pointer[0] &lt; inRuntimeParamAnnotations.length());
3169                 runtimeParameterAnnotations = annos;
3170             }
3171 
3172             reader.moveNext();
3173 
3174             return true;
3175         }
3176 
3177     }
3178 
3179     static class FieldDescription extends FeatureDescription {
3180         String name;
3181         String descriptor;
3182         Object constantValue;
3183 
3184         @Override
3185         public int hashCode() {
3186             int hash = super.hashCode();
3187             hash = 59 * hash + Objects.hashCode(this.name);
3188             hash = 59 * hash + Objects.hashCode(this.descriptor);
3189             hash = 59 * hash + Objects.hashCode(this.constantValue);
3190             return hash;
3191         }
3192 
3193         @Override
3194         public boolean equals(Object obj) {
3195             if (obj == null) {
3196                 return false;
3197             }
3198             if (!super.equals(obj)) {
3199                 return false;
3200             }
3201             final FieldDescription other = (FieldDescription) obj;
3202             if (!Objects.equals(this.name, other.name)) {
3203                 return false;
3204             }
3205             if (!Objects.equals(this.descriptor, other.descriptor)) {
3206                 return false;
3207             }
3208             if (!Objects.equals(this.constantValue, other.constantValue)) {
3209                 return false;
3210             }
3211             return true;
3212         }
3213 
3214         @Override
3215         public void write(Appendable output, String baselineVersion, String version) throws IOException {
3216             if (shouldIgnore(baselineVersion, version))
3217                 return ;
3218             if (!versions.contains(version)) {
3219                 output.append(&quot;-field&quot;);
3220                 output.append(&quot; name &quot; + quote(name, false));
3221                 output.append(&quot; descriptor &quot; + quote(descriptor, false));
3222                 output.append(&quot;\n&quot;);
3223                 return ;
3224             }
3225             output.append(&quot;field&quot;);
3226             output.append(&quot; name &quot; + name);
3227             output.append(&quot; descriptor &quot; + descriptor);
3228             if (constantValue != null) {
3229                 output.append(&quot; constantValue &quot; + quote(constantValue.toString(), false));
3230             }
3231             writeAttributes(output);
3232             output.append(&quot;\n&quot;);
3233         }
3234 
3235         @Override
3236         public boolean read(LineBasedReader reader) throws IOException {
3237             if (!&quot;field&quot;.equals(reader.lineKey))
3238                 return false;
3239 
3240             name = reader.attributes.get(&quot;name&quot;);
3241             descriptor = reader.attributes.get(&quot;descriptor&quot;);
3242 
3243             String inConstantValue = reader.attributes.get(&quot;constantValue&quot;);
3244 
3245             if (inConstantValue != null) {
3246                 switch (descriptor) {
3247                     case &quot;Z&quot;: constantValue = &quot;true&quot;.equals(inConstantValue); break;
3248                     case &quot;B&quot;: constantValue = Integer.parseInt(inConstantValue); break;
3249                     case &quot;C&quot;: constantValue = inConstantValue.charAt(0); break;
3250                     case &quot;S&quot;: constantValue = Integer.parseInt(inConstantValue); break;
3251                     case &quot;I&quot;: constantValue = Integer.parseInt(inConstantValue); break;
3252                     case &quot;J&quot;: constantValue = Long.parseLong(inConstantValue); break;
3253                     case &quot;F&quot;: constantValue = Float.parseFloat(inConstantValue); break;
3254                     case &quot;D&quot;: constantValue = Double.parseDouble(inConstantValue); break;
3255                     case &quot;Ljava/lang/String;&quot;: constantValue = inConstantValue; break;
3256                     default:
3257                         throw new IllegalStateException(&quot;Unrecognized field type: &quot; + descriptor);
3258                 }
3259             }
3260 
3261             readAttributes(reader);
3262 
3263             reader.moveNext();
3264 
3265             return true;
3266         }
3267 
3268     }
3269 
3270     static final class AnnotationDescription {
3271         String annotationType;
3272         Map&lt;String, Object&gt; values;
3273 
3274         public AnnotationDescription(String annotationType, Map&lt;String, Object&gt; values) {
3275             this.annotationType = annotationType;
3276             this.values = values;
3277         }
3278 
3279         @Override
3280         public int hashCode() {
3281             int hash = 7;
3282             hash = 47 * hash + Objects.hashCode(this.annotationType);
3283             hash = 47 * hash + Objects.hashCode(this.values);
3284             return hash;
3285         }
3286 
3287         @Override
3288         public boolean equals(Object obj) {
3289             if (obj == null) {
3290                 return false;
3291             }
3292             if (getClass() != obj.getClass()) {
3293                 return false;
3294             }
3295             final AnnotationDescription other = (AnnotationDescription) obj;
3296             if (!Objects.equals(this.annotationType, other.annotationType)) {
3297                 return false;
3298             }
3299             if (!Objects.equals(this.values, other.values)) {
3300                 return false;
3301             }
3302             return true;
3303         }
3304 
3305         @Override
3306         public String toString() {
3307             StringBuilder result = new StringBuilder();
3308             result.append(&quot;@&quot; + annotationType);
3309             if (!values.isEmpty()) {
3310                 result.append(&quot;(&quot;);
3311                 boolean first = true;
3312                 for (Entry&lt;String, Object&gt; e : values.entrySet()) {
3313                     if (!first) {
3314                         result.append(&quot;,&quot;);
3315                     }
3316                     first = false;
3317                     result.append(e.getKey());
3318                     result.append(&quot;=&quot;);
3319                     result.append(dumpAnnotationValue(e.getValue()));
3320                     result.append(&quot;&quot;);
3321                 }
3322                 result.append(&quot;)&quot;);
3323             }
3324             return result.toString();
3325         }
3326 
3327         private static String dumpAnnotationValue(Object value) {
3328             if (value instanceof List) {
3329                 StringBuilder result = new StringBuilder();
3330 
3331                 result.append(&quot;{&quot;);
3332 
3333                 for (Object element : ((List) value)) {
3334                     result.append(dumpAnnotationValue(element));
3335                 }
3336 
3337                 result.append(&quot;}&quot;);
3338 
3339                 return result.toString();
3340             }
3341 
3342             if (value instanceof String) {
3343                 return &quot;\&quot;&quot; + quote((String) value, true) + &quot;\&quot;&quot;;
3344             } else if (value instanceof Boolean) {
3345                 return &quot;Z&quot; + value;
3346             } else if (value instanceof Byte) {
3347                 return &quot;B&quot; + value;
3348             } if (value instanceof Character) {
3349                 return &quot;C&quot; + value;
3350             } if (value instanceof Short) {
3351                 return &quot;S&quot; + value;
3352             } if (value instanceof Integer) {
3353                 return &quot;I&quot; + value;
3354             } if (value instanceof Long) {
3355                 return &quot;J&quot; + value;
3356             } if (value instanceof Float) {
3357                 return &quot;F&quot; + value;
3358             } if (value instanceof Double) {
3359                 return &quot;D&quot; + value;
3360             } else {
3361                 return value.toString();
3362             }
3363         }
3364     }
3365 
3366     static final class EnumConstant {
3367         String type;
3368         String constant;
3369 
3370         public EnumConstant(String type, String constant) {
3371             this.type = type;
3372             this.constant = constant;
3373         }
3374 
3375         @Override
3376         public String toString() {
3377             return &quot;e&quot; + type + constant + &quot;;&quot;;
3378         }
3379 
3380         @Override
3381         public int hashCode() {
3382             int hash = 7;
3383             hash = 19 * hash + Objects.hashCode(this.type);
3384             hash = 19 * hash + Objects.hashCode(this.constant);
3385             return hash;
3386         }
3387 
3388         @Override
3389         public boolean equals(Object obj) {
3390             if (obj == null) {
3391                 return false;
3392             }
3393             if (getClass() != obj.getClass()) {
3394                 return false;
3395             }
3396             final EnumConstant other = (EnumConstant) obj;
3397             if (!Objects.equals(this.type, other.type)) {
3398                 return false;
3399             }
3400             if (!Objects.equals(this.constant, other.constant)) {
3401                 return false;
3402             }
3403             return true;
3404         }
3405 
3406     }
3407 
3408     static final class ClassConstant {
3409         String type;
3410 
3411         public ClassConstant(String type) {
3412             this.type = type;
3413         }
3414 
3415         @Override
3416         public String toString() {
3417             return &quot;c&quot; + type;
3418         }
3419 
3420         @Override
3421         public int hashCode() {
3422             int hash = 3;
3423             hash = 53 * hash + Objects.hashCode(this.type);
3424             return hash;
3425         }
3426 
3427         @Override
3428         public boolean equals(Object obj) {
3429             if (obj == null) {
3430                 return false;
3431             }
3432             if (getClass() != obj.getClass()) {
3433                 return false;
3434             }
3435             final ClassConstant other = (ClassConstant) obj;
3436             if (!Objects.equals(this.type, other.type)) {
3437                 return false;
3438             }
3439             return true;
3440         }
3441 
3442     }
3443 
3444     static final class InnerClassInfo {
3445         String innerClass;
3446         String outerClass;
3447         String innerClassName;
3448         int    innerClassFlags;
3449 
3450         @Override
3451         public int hashCode() {
3452             int hash = 3;
3453             hash = 11 * hash + Objects.hashCode(this.innerClass);
3454             hash = 11 * hash + Objects.hashCode(this.outerClass);
3455             hash = 11 * hash + Objects.hashCode(this.innerClassName);
3456             hash = 11 * hash + Objects.hashCode(this.innerClassFlags);
3457             return hash;
3458         }
3459 
3460         @Override
3461         public boolean equals(Object obj) {
3462             if (obj == null) {
3463                 return false;
3464             }
3465             if (getClass() != obj.getClass()) {
3466                 return false;
3467             }
3468             final InnerClassInfo other = (InnerClassInfo) obj;
3469             if (!Objects.equals(this.innerClass, other.innerClass)) {
3470                 return false;
3471             }
3472             if (!Objects.equals(this.outerClass, other.outerClass)) {
3473                 return false;
3474             }
3475             if (!Objects.equals(this.innerClassName, other.innerClassName)) {
3476                 return false;
3477             }
3478             if (!Objects.equals(this.innerClassFlags, other.innerClassFlags)) {
3479                 return false;
3480             }
3481             return true;
3482         }
3483 
3484     }
3485 
3486     public static final class ClassList implements Iterable&lt;ClassDescription&gt; {
3487         private final List&lt;ClassDescription&gt; classes = new ArrayList&lt;&gt;();
3488         private final Map&lt;String, ClassDescription&gt; name2Class = new HashMap&lt;&gt;();
3489         private final Map&lt;ClassDescription, ClassDescription&gt; inner2Outter = new HashMap&lt;&gt;();
3490 
3491         @Override
3492         public Iterator&lt;ClassDescription&gt; iterator() {
3493             return classes.iterator();
3494         }
3495 
3496         public void add(ClassDescription desc) {
3497             classes.add(desc);
3498             name2Class.put(desc.name, desc);
3499         }
3500 
3501         public ClassDescription find(String name) {
3502             return find(name, ALLOW_NON_EXISTING_CLASSES);
3503         }
3504 
3505         public ClassDescription find(String name, boolean allowNull) {
3506             ClassDescription desc = name2Class.get(name);
3507 
3508             if (desc != null || allowNull)
3509                 return desc;
3510 
3511             throw new IllegalStateException(&quot;Cannot find: &quot; + name);
3512         }
3513 
3514         private static final ClassDescription NONE = new ClassDescription();
3515 
3516         public ClassDescription enclosingClass(ClassDescription clazz) {
3517             if (clazz == null)
3518                 return null;
3519             ClassDescription desc = inner2Outter.computeIfAbsent(clazz, c -&gt; {
3520                 ClassHeaderDescription header = clazz.header.get(0);
3521 
3522                 if (header.innerClasses != null) {
3523                     for (InnerClassInfo ici : header.innerClasses) {
3524                         if (ici.innerClass.equals(clazz.name)) {
3525                             return find(ici.outerClass);
3526                         }
3527                     }
3528                 }
3529 
3530                 return NONE;
3531             });
3532 
3533             return desc != NONE ? desc : null;
3534         }
3535 
3536         public Iterable&lt;ClassDescription&gt; enclosingClasses(ClassDescription clazz) {
3537             List&lt;ClassDescription&gt; result = new ArrayList&lt;&gt;();
3538             ClassDescription outer = enclosingClass(clazz);
3539 
3540             while (outer != null) {
3541                 result.add(outer);
3542                 outer = enclosingClass(outer);
3543             }
3544 
3545             return result;
3546         }
3547 
3548         public void sort() {
3549             Collections.sort(classes, (cd1, cd2) -&gt; cd1.name.compareTo(cd2.name));
3550         }
3551     }
3552 
3553     private static int listHashCode(Collection&lt;?&gt; c) {
3554         return c == null || c.isEmpty() ? 0 : c.hashCode();
3555     }
3556 
3557     private static boolean listEquals(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) {
3558         if (c1 == c2) return true;
3559         if (c1 == null &amp;&amp; c2.isEmpty()) return true;
3560         if (c2 == null &amp;&amp; c1.isEmpty()) return true;
3561         return Objects.equals(c1, c2);
3562     }
3563 
3564     private static String serializeList(List&lt;String&gt; list) {
3565         StringBuilder result = new StringBuilder();
3566         String sep = &quot;&quot;;
3567 
3568         for (Object o : list) {
3569             result.append(sep);
3570             result.append(o);
3571             sep = &quot;,&quot;;
3572         }
3573 
3574         return quote(result.toString(), false);
3575     }
3576 
3577     private static List&lt;String&gt; deserializeList(String serialized) {
3578         return deserializeList(serialized, true);
3579     }
3580 
3581     private static List&lt;String&gt; deserializeList(String serialized,
3582                                                 boolean unquote) {
3583         serialized = unquote ? unquote(serialized) : serialized;
3584         if (serialized == null)
3585             return new ArrayList&lt;&gt;();
3586         return new ArrayList&lt;&gt;(List.of(serialized.split(&quot;,&quot;)));
3587     }
3588 
3589     private static String quote(String value, boolean quoteQuotes) {
3590         return quote(value, quoteQuotes, false);
3591     }
3592 
3593     private static String quote(String value, boolean quoteQuotes,
3594                                 boolean quoteCommas) {
3595         StringBuilder result = new StringBuilder();
3596 
3597         for (char c : value.toCharArray()) {
3598             if (c &lt;= 32 || c &gt;= 127 || c == &#39;\\&#39; ||
3599                 (quoteQuotes &amp;&amp; c == &#39;&quot;&#39;) || (quoteCommas &amp;&amp; c == &#39;,&#39;)) {
3600                 result.append(&quot;\\u&quot; + String.format(&quot;%04X&quot;, (int) c) + &quot;;&quot;);
3601             } else {
3602                 result.append(c);
3603             }
3604         }
3605 
3606         return result.toString();
3607     }
3608 
3609     private static final Pattern unicodePattern =
3610             Pattern.compile(&quot;\\\\u([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])&quot;);
3611 
3612     private static String unquote(String value) {
3613         if (value == null)
3614             return null;
3615 
3616         StringBuilder result = new StringBuilder();
3617         Matcher m = unicodePattern.matcher(value);
3618         int lastStart = 0;
3619 
3620         while (m.find(lastStart)) {
3621             result.append(value.substring(lastStart, m.start()));
3622             result.append((char) Integer.parseInt(m.group(1), 16));
3623             lastStart = m.end() + 1;
3624         }
3625 
3626         result.append(value.substring(lastStart, value.length()));
3627 
3628         return result.toString();
3629     }
3630 
3631     private static String readDigits(String value, int[] valuePointer) {
3632         int start = valuePointer[0];
3633 
3634         if (value.charAt(valuePointer[0]) == &#39;-&#39;)
3635             valuePointer[0]++;
3636 
3637         while (valuePointer[0] &lt; value.length() &amp;&amp; Character.isDigit(value.charAt(valuePointer[0])))
3638             valuePointer[0]++;
3639 
3640         return value.substring(start, valuePointer[0]);
3641     }
3642 
3643     private static String className(String value, int[] valuePointer) {
3644         int start = valuePointer[0];
3645         while (value.charAt(valuePointer[0]++) != &#39;;&#39;)
3646             ;
3647         return value.substring(start, valuePointer[0]);
3648     }
3649 
3650     private static Object parseAnnotationValue(String value, int[] valuePointer) {
3651         switch (value.charAt(valuePointer[0]++)) {
3652             case &#39;Z&#39;:
3653                 if (&quot;true&quot;.equals(value.substring(valuePointer[0], valuePointer[0] + 4))) {
3654                     valuePointer[0] += 4;
3655                     return true;
3656                 } else if (&quot;false&quot;.equals(value.substring(valuePointer[0], valuePointer[0] + 5))) {
3657                     valuePointer[0] += 5;
3658                     return false;
3659                 } else {
3660                     throw new IllegalStateException(&quot;Unrecognized boolean structure: &quot; + value);
3661                 }
3662             case &#39;B&#39;: return Byte.parseByte(readDigits(value, valuePointer));
3663             case &#39;C&#39;: return value.charAt(valuePointer[0]++);
3664             case &#39;S&#39;: return Short.parseShort(readDigits(value, valuePointer));
3665             case &#39;I&#39;: return Integer.parseInt(readDigits(value, valuePointer));
3666             case &#39;J&#39;: return Long.parseLong(readDigits(value, valuePointer));
3667             case &#39;F&#39;: return Float.parseFloat(readDigits(value, valuePointer));
3668             case &#39;D&#39;: return Double.parseDouble(readDigits(value, valuePointer));
3669             case &#39;c&#39;:
3670                 return new ClassConstant(className(value, valuePointer));
3671             case &#39;e&#39;:
3672                 return new EnumConstant(className(value, valuePointer), className(value, valuePointer).replaceFirst(&quot;;$&quot;, &quot;&quot;));
3673             case &#39;{&#39;:
3674                 List&lt;Object&gt; elements = new ArrayList&lt;&gt;(); //TODO: a good test for this would be highly desirable
3675                 while (value.charAt(valuePointer[0]) != &#39;}&#39;) {
3676                     elements.add(parseAnnotationValue(value, valuePointer));
3677                 }
3678                 valuePointer[0]++;
3679                 return elements;
3680             case &#39;&quot;&#39;:
3681                 int start = valuePointer[0];
3682                 while (value.charAt(valuePointer[0]) != &#39;&quot;&#39;)
3683                     valuePointer[0]++;
3684                 return unquote(value.substring(start, valuePointer[0]++));
3685             case &#39;@&#39;:
3686                 return parseAnnotation(value, valuePointer);
3687             default:
3688                 throw new IllegalStateException(&quot;Unrecognized signature type: &quot; + value.charAt(valuePointer[0] - 1) + &quot;; value=&quot; + value);
3689         }
3690     }
3691 
3692     public static List&lt;AnnotationDescription&gt; parseAnnotations(String encoded, int[] pointer) {
3693         ArrayList&lt;AnnotationDescription&gt; result = new ArrayList&lt;&gt;();
3694 
3695         while (pointer[0] &lt; encoded.length() &amp;&amp; encoded.charAt(pointer[0]) == &#39;@&#39;) {
3696             pointer[0]++;
3697             result.add(parseAnnotation(encoded, pointer));
3698         }
3699 
3700         return result;
3701     }
3702 
3703     private static AnnotationDescription parseAnnotation(String value, int[] valuePointer) {
3704         String className = className(value, valuePointer);
3705         Map&lt;String, Object&gt; attribute2Value = new HashMap&lt;&gt;();
3706 
3707         if (valuePointer[0] &lt; value.length() &amp;&amp; value.charAt(valuePointer[0]) == &#39;(&#39;) {
3708             while (value.charAt(valuePointer[0]) != &#39;)&#39;) {
3709                 int nameStart = ++valuePointer[0];
3710 
3711                 while (value.charAt(valuePointer[0]++) != &#39;=&#39;);
3712 
3713                 String name = value.substring(nameStart, valuePointer[0] - 1);
3714 
3715                 attribute2Value.put(name, parseAnnotationValue(value, valuePointer));
3716             }
3717 
3718             valuePointer[0]++;
3719         }
3720 
3721         return new AnnotationDescription(className, attribute2Value);
3722     }
3723     //&lt;/editor-fold&gt;
3724 
3725     private static void help() {
3726         System.err.println(&quot;Help...&quot;);
3727     }
3728 
3729     public static void main(String... args) throws IOException {
3730         if (args.length &lt; 1) {
3731             help();
3732             return ;
3733         }
3734 
3735         switch (args[0]) {
3736             case &quot;build-description&quot;: {
3737                 if (args.length &lt; 3) {
3738                     help();
3739                     return ;
3740                 }
3741 
3742                 Path descDest = Paths.get(args[1]);
3743                 List&lt;VersionDescription&gt; versions = new ArrayList&lt;&gt;();
3744 
3745                 for (int i = 3; i + 2 &lt; args.length; i += 3) {
3746                     versions.add(new VersionDescription(args[i + 1], args[i], args[i + 2]));
3747                 }
3748 
3749                 Files.walkFileTree(descDest, new FileVisitor&lt;Path&gt;() {
3750                     @Override
3751                     public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
3752                         return FileVisitResult.CONTINUE;
3753                     }
3754                     @Override
3755                     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
3756                         Files.delete(file);
3757                         return FileVisitResult.CONTINUE;
3758                     }
3759                     @Override
3760                     public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
3761                         return FileVisitResult.CONTINUE;
3762                     }
3763                     @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
3764                         Files.delete(dir);
3765                         return FileVisitResult.CONTINUE;
3766                     }
3767                 });
3768 
3769                 ExcludeIncludeList excludeList =
3770                         ExcludeIncludeList.create(args[2]);
3771 
3772                 new CreateSymbols().createBaseLine(versions,
3773                                                    excludeList,
3774                                                    descDest,
3775                                                    args);
3776                 break;
3777             }
3778             case &quot;build-description-incremental&quot;: {
3779                 if (args.length != 3) {
3780                     help();
3781                     return ;
3782                 }
3783 
3784                 new CreateSymbols().createIncrementalBaseLine(args[1], args[2], args);
3785                 break;
3786             }
3787             case &quot;build-ctsym&quot;:
3788                 String ctDescriptionFileExtra;
3789                 String ctDescriptionFile;
3790                 String ctSymLocation;
3791                 String timestampSpec;
3792                 String currentVersion;
3793                 String systemModules;
3794 
3795                 if (args.length == 6) {
3796                     ctDescriptionFileExtra = null;
3797                     ctDescriptionFile = args[1];
3798                     ctSymLocation = args[2];
3799                     timestampSpec = args[3];
3800                     currentVersion = args[4];
3801                     systemModules = args[5];
3802                 } else if (args.length == 7) {
3803                     ctDescriptionFileExtra = args[1];
3804                     ctDescriptionFile = args[2];
3805                     ctSymLocation = args[3];
3806                     timestampSpec = args[4];
3807                     currentVersion = args[5];
3808                     systemModules = args[6];
3809                 } else {
3810                     help();
3811                     return ;
3812                 }
3813 
3814                 long timestamp = Long.parseLong(timestampSpec);
3815 
3816                 //SOURCE_DATE_EPOCH is in seconds, convert to milliseconds:
3817                 timestamp *= 1000;
3818 
3819                 new CreateSymbols().createSymbols(ctDescriptionFileExtra,
3820                                                   ctDescriptionFile,
3821                                                   ctSymLocation,
3822                                                   timestamp,
3823                                                   currentVersion,
3824                                                   systemModules);
3825                 break;
3826         }
3827     }
3828 
3829 }
    </pre>
  </body>
</html>
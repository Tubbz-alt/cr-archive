<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../doclet/testTypeAnnotations/TestTypeAnnotations.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../tool/doclint/DocLintTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  45 import java.nio.file.Path;
  46 import java.nio.file.Paths;
  47 import java.util.ArrayList;
  48 import java.util.Arrays;
  49 import java.util.Collection;
  50 import java.util.Collections;
  51 import java.util.EnumMap;
  52 import java.util.HashMap;
  53 import java.util.List;
  54 import java.util.Map;
  55 import java.util.Objects;
  56 import java.util.function.Function;
  57 
  58 
  59 /**
  60  * Test framework for running javadoc and performing tests on the resulting output.
  61  *
  62  * &lt;p&gt;
  63  * Tests are typically written as subtypes of JavadocTester, with a main
  64  * method that creates an instance of the test class and calls the runTests()
<span class="line-modified">  65  * method. The runTests() methods calls all the test methods declared in the class,</span>
  66  * and then calls a method to print a summary, and throw an exception if
  67  * any of the test methods reported a failure.
  68  *
  69  * &lt;p&gt;
  70  * Test methods are identified with a @Test annotation. They have no parameters.
  71  * The name of the method is not important, but if you have more than one, it is
  72  * recommended that the names be meaningful and suggestive of the test case
  73  * contained therein.
  74  *
  75  * &lt;p&gt;
  76  * Typically, a test method will invoke javadoc, and then perform various
  77  * checks on the results. The standard checks are:
  78  *
  79  * &lt;dl&gt;
  80  * &lt;dt&gt;checkExitCode
  81  * &lt;dd&gt;Check the exit code returned from javadoc.
  82  * &lt;dt&gt;checkOutput
  83  * &lt;dd&gt;Perform a series of checks on the contents on a file or output stream
  84  *     generated by javadoc.
  85  *     The checks can be either that a series of strings are found or are not found.
</pre>
<hr />
<pre>
  94  *          MyTester tester = new MyTester();
  95  *          tester.runTests();
  96  *      }
  97  *
  98  *      // test methods...
  99  *      {@literal @}Test
 100  *      void test() {
 101  *          javadoc(&lt;i&gt;args&lt;/i&gt;);
 102  *          checkExit(Exit.OK);
 103  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, true,
 104  *              &lt;i&gt;strings-to-find&lt;/i&gt;);
 105  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, false,
 106  *              &lt;i&gt;strings-to-not-find&lt;/i&gt;);
 107  *      }
 108  *  }
 109  * &lt;/code&gt;&lt;/pre&gt;
 110  *
 111  * &lt;p&gt;
 112  * If javadoc is run more than once in a test method, you can compare the
 113  * results that are generated with the diff method. Since files written by
<span class="line-modified"> 114  * javadoc typically contain a timestamp, you may want to use the -notimestamp</span>
 115  * option if you are going to compare the results from two runs of javadoc.
 116  *
 117  * &lt;p&gt;
 118  * If you have many calls of checkOutput that are very similar, you can write
 119  * your own check... method to reduce the amount of duplication. For example,
 120  * if you want to check that many files contain the same string, you could
 121  * write a method that takes a varargs list of files and calls checkOutput
 122  * on each file in turn with the string to be checked.
 123  *
 124  * &lt;p&gt;
<span class="line-modified"> 125  * You can also write you own custom check methods, which can use</span>
<span class="line-modified"> 126  * readFile to get the contents of a file generated by javadoc,</span>
<span class="line-modified"> 127  * and then use pass(...) or fail(...) to report whether the check</span>
<span class="line-modified"> 128  * succeeded or not.</span>

 129  *
 130  * &lt;p&gt;
 131  * You can have many separate test methods, each identified with a @Test
 132  * annotation. However, you should &lt;b&gt;not&lt;/b&gt; assume they will be called
 133  * in the order declared in your source file.  If the order of a series
 134  * of javadoc invocations is important, do that within a single method.
 135  * If the invocations are independent, for better clarity, use separate
 136  * test methods, each with their own set of checks on the results.
 137  */
 138 public abstract class JavadocTester {
 139 
 140     public static final String FS = System.getProperty(&quot;file.separator&quot;);
 141     public static final String PS = System.getProperty(&quot;path.separator&quot;);
 142     public static final String NL = System.getProperty(&quot;line.separator&quot;);
 143     public static final String thisRelease = System.getProperty(&quot;java.specification.version&quot;);
 144 
 145     public static final Path currDir = Paths.get(&quot;.&quot;).toAbsolutePath().normalize();
 146 
 147     public enum Output {
 148         /** The name of the output stream from javadoc. */
</pre>
<hr />
<pre>
 556         LinkChecker c = new LinkChecker(out, this::readFile);
 557         try {
 558             c.checkDirectory(outputDir.toPath());
 559             c.report();
 560             int errors = c.getErrorCount();
 561             if (errors == 0) {
 562                 passed(&quot;Links are OK&quot;);
 563             } else {
 564                 failed(errors + &quot; errors found when checking links&quot;);
 565             }
 566         } catch (IOException e) {
 567             failed(&quot;exception thrown when reading files: &quot; + e);
 568         }
 569     }
 570 
 571     /**
 572      * Shows the heading structure for each of the specified files.
 573      * The structure is is printed in plain text to the main output stream.
 574      * No errors are reported (unless there is a problem reading a file)
 575      * but missing headings are noted within the output.
<span class="line-modified"> 576      * @params the files</span>

 577      */
 578     public void showHeadings(String... paths) {
 579         ShowHeadings s = new ShowHeadings(out, this::readFile);
 580         for (String p : paths) {
 581             try {
 582                 File f = new File(outputDir, p);
 583                 s.checkFiles(List.of(f.toPath()), false, Collections.emptySet());
 584             } catch (IOException e) {
 585                 checking(&quot;Read file&quot;);
 586                 failed(&quot;Error reading file: &quot; + e);
 587             }
 588         }
 589     }
 590 
 591     /**
 592      * Gets the content of the one of the output streams written by javadoc.
 593      * @param output the name of the output stream
 594      * @return the content of the output stream
 595      */
 596     public String getOutput(Output output) {
</pre>
<hr />
<pre>
 796             fileContentCacheCharset = charset;
 797         }
 798         try {
 799             File file = new File(baseDir, fileName);
 800             SoftReference&lt;String&gt; ref = fileContentCache.get(file);
 801             String content = (ref == null) ? null : ref.get();
 802             if (content != null)
 803                 return content;
 804 
 805             // charset defaults to a value inferred from latest javadoc run
 806             content = new String(Files.readAllBytes(file.toPath()), charset);
 807             fileContentCache.put(file, new SoftReference&lt;&gt;(content));
 808             return content;
 809         } catch (FileNotFoundException e) {
 810             throw new Error(&quot;File not found: &quot; + fileName + &quot;: &quot; + e);
 811         } catch (IOException e) {
 812             throw new Error(&quot;Error reading file: &quot; + fileName + &quot;: &quot; + e);
 813         }
 814     }
 815 








 816     protected void checking(String message) {
 817         numTestsRun++;
 818         javadocTestNum++;
 819         print(&quot;Starting subtest &quot; + javadocRunNum + &quot;.&quot; + javadocTestNum, message);
 820     }
 821 








 822     protected void passed(File file, String message) {
 823         passed(file + &quot;: &quot; + message);
 824     }
 825 







 826     protected void passed(String message) {
 827         numTestsPassed++;
 828         print(&quot;Passed&quot;, message);
 829         out.println();
 830     }
 831 








 832     protected void failed(File file, String message) {
 833         failed(file + &quot;: &quot; + message);
 834     }
 835 







 836     protected void failed(String message) {
 837         print(&quot;FAILED&quot;, message);
 838         StackWalker.getInstance().walk(s -&gt; {
 839             s.dropWhile(f -&gt; f.getMethodName().equals(&quot;failed&quot;))
 840                     .takeWhile(f -&gt; !f.getMethodName().equals(&quot;runTests&quot;))
 841                     .forEach(f -&gt; out.println(&quot;        at &quot;
 842                             + f.getClassName() + &quot;.&quot; + f.getMethodName()
 843                             + &quot;(&quot; + f.getFileName() + &quot;:&quot; + f.getLineNumber() + &quot;)&quot;));
 844             return null;
 845         });
 846         out.println();
 847     }
 848 
 849     private void print(String prefix, String message) {
 850         if (message.isEmpty())
 851             out.println(prefix);
 852         else {
 853             out.print(prefix);
 854             out.print(&quot;: &quot;);
 855             out.print(message.replace(&quot;\n&quot;, NL));
</pre>
<hr />
<pre>
 884      * if the string was found.
 885      *
 886      * @param fileString    the contents of the file to search through
 887      * @param stringToFind  the string to search for
 888      * @return              true if the string was found
 889      */
 890     private boolean findString(String fileString, String stringToFind) {
 891         // javadoc (should) always use the platform newline sequence,
 892         // but in the strings to find it is more convenient to use the Java
 893         // newline character. So we translate \n to NL before we search.
 894         stringToFind = stringToFind.replace(&quot;\n&quot;, NL);
 895         return fileString.contains(stringToFind);
 896     }
 897 
 898     /**
 899      * Compares the two given files.
 900      *
 901      * @param baseDir1 the directory in which to locate the first file
 902      * @param baseDir2 the directory in which to locate the second file
 903      * @param file the file to compare in the two base directories
<span class="line-removed"> 904      * an error if the files do not match.</span>
<span class="line-removed"> 905      * @return true if the files are the same and false otherwise.</span>
 906      */
 907     private void diff(File baseDir1, File baseDir2, String file) {
 908         String file1Contents = readFile(baseDir1, file);
 909         String file2Contents = readFile(baseDir2, file);
 910         checking(&quot;diff &quot; + new File(baseDir1, file) + &quot;, &quot; + new File(baseDir2, file));
 911         if (file1Contents.trim().compareTo(file2Contents.trim()) == 0) {
 912             passed(&quot;files are equal&quot;);
 913         } else {
 914             failed(&quot;files differ&quot;);
 915         }
 916     }
 917 
 918     /**
 919      * Utility class to simplify the handling of temporarily setting a
 920      * new stream for System.out or System.err.
 921      */
 922     private static class StreamOutput {
 923         // functional interface to set a stream.
 924         private interface Initializer {
 925             void set(PrintStream s);
</pre>
</td>
<td>
<hr />
<pre>
  45 import java.nio.file.Path;
  46 import java.nio.file.Paths;
  47 import java.util.ArrayList;
  48 import java.util.Arrays;
  49 import java.util.Collection;
  50 import java.util.Collections;
  51 import java.util.EnumMap;
  52 import java.util.HashMap;
  53 import java.util.List;
  54 import java.util.Map;
  55 import java.util.Objects;
  56 import java.util.function.Function;
  57 
  58 
  59 /**
  60  * Test framework for running javadoc and performing tests on the resulting output.
  61  *
  62  * &lt;p&gt;
  63  * Tests are typically written as subtypes of JavadocTester, with a main
  64  * method that creates an instance of the test class and calls the runTests()
<span class="line-modified">  65  * method. The runTests() method calls all the test methods declared in the class,</span>
  66  * and then calls a method to print a summary, and throw an exception if
  67  * any of the test methods reported a failure.
  68  *
  69  * &lt;p&gt;
  70  * Test methods are identified with a @Test annotation. They have no parameters.
  71  * The name of the method is not important, but if you have more than one, it is
  72  * recommended that the names be meaningful and suggestive of the test case
  73  * contained therein.
  74  *
  75  * &lt;p&gt;
  76  * Typically, a test method will invoke javadoc, and then perform various
  77  * checks on the results. The standard checks are:
  78  *
  79  * &lt;dl&gt;
  80  * &lt;dt&gt;checkExitCode
  81  * &lt;dd&gt;Check the exit code returned from javadoc.
  82  * &lt;dt&gt;checkOutput
  83  * &lt;dd&gt;Perform a series of checks on the contents on a file or output stream
  84  *     generated by javadoc.
  85  *     The checks can be either that a series of strings are found or are not found.
</pre>
<hr />
<pre>
  94  *          MyTester tester = new MyTester();
  95  *          tester.runTests();
  96  *      }
  97  *
  98  *      // test methods...
  99  *      {@literal @}Test
 100  *      void test() {
 101  *          javadoc(&lt;i&gt;args&lt;/i&gt;);
 102  *          checkExit(Exit.OK);
 103  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, true,
 104  *              &lt;i&gt;strings-to-find&lt;/i&gt;);
 105  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, false,
 106  *              &lt;i&gt;strings-to-not-find&lt;/i&gt;);
 107  *      }
 108  *  }
 109  * &lt;/code&gt;&lt;/pre&gt;
 110  *
 111  * &lt;p&gt;
 112  * If javadoc is run more than once in a test method, you can compare the
 113  * results that are generated with the diff method. Since files written by
<span class="line-modified"> 114  * javadoc typically contain a timestamp, you may want to use the {@code -notimestamp}</span>
 115  * option if you are going to compare the results from two runs of javadoc.
 116  *
 117  * &lt;p&gt;
 118  * If you have many calls of checkOutput that are very similar, you can write
 119  * your own check... method to reduce the amount of duplication. For example,
 120  * if you want to check that many files contain the same string, you could
 121  * write a method that takes a varargs list of files and calls checkOutput
 122  * on each file in turn with the string to be checked.
 123  *
 124  * &lt;p&gt;
<span class="line-modified"> 125  * You can also write your own custom check methods. After any setup or</span>
<span class="line-modified"> 126  * argument checking, the method should call {@code checking(...)},</span>
<span class="line-modified"> 127  * and then eventually call either {@code passed(...)} or {@code failed(...)}</span>
<span class="line-modified"> 128  * to report whether the check succeeded or not.</span>
<span class="line-added"> 129  * Use {@code readFile} to get the contents of a file generated by javadoc.</span>
 130  *
 131  * &lt;p&gt;
 132  * You can have many separate test methods, each identified with a @Test
 133  * annotation. However, you should &lt;b&gt;not&lt;/b&gt; assume they will be called
 134  * in the order declared in your source file.  If the order of a series
 135  * of javadoc invocations is important, do that within a single method.
 136  * If the invocations are independent, for better clarity, use separate
 137  * test methods, each with their own set of checks on the results.
 138  */
 139 public abstract class JavadocTester {
 140 
 141     public static final String FS = System.getProperty(&quot;file.separator&quot;);
 142     public static final String PS = System.getProperty(&quot;path.separator&quot;);
 143     public static final String NL = System.getProperty(&quot;line.separator&quot;);
 144     public static final String thisRelease = System.getProperty(&quot;java.specification.version&quot;);
 145 
 146     public static final Path currDir = Paths.get(&quot;.&quot;).toAbsolutePath().normalize();
 147 
 148     public enum Output {
 149         /** The name of the output stream from javadoc. */
</pre>
<hr />
<pre>
 557         LinkChecker c = new LinkChecker(out, this::readFile);
 558         try {
 559             c.checkDirectory(outputDir.toPath());
 560             c.report();
 561             int errors = c.getErrorCount();
 562             if (errors == 0) {
 563                 passed(&quot;Links are OK&quot;);
 564             } else {
 565                 failed(errors + &quot; errors found when checking links&quot;);
 566             }
 567         } catch (IOException e) {
 568             failed(&quot;exception thrown when reading files: &quot; + e);
 569         }
 570     }
 571 
 572     /**
 573      * Shows the heading structure for each of the specified files.
 574      * The structure is is printed in plain text to the main output stream.
 575      * No errors are reported (unless there is a problem reading a file)
 576      * but missing headings are noted within the output.
<span class="line-modified"> 577      *</span>
<span class="line-added"> 578      * @param paths the files</span>
 579      */
 580     public void showHeadings(String... paths) {
 581         ShowHeadings s = new ShowHeadings(out, this::readFile);
 582         for (String p : paths) {
 583             try {
 584                 File f = new File(outputDir, p);
 585                 s.checkFiles(List.of(f.toPath()), false, Collections.emptySet());
 586             } catch (IOException e) {
 587                 checking(&quot;Read file&quot;);
 588                 failed(&quot;Error reading file: &quot; + e);
 589             }
 590         }
 591     }
 592 
 593     /**
 594      * Gets the content of the one of the output streams written by javadoc.
 595      * @param output the name of the output stream
 596      * @return the content of the output stream
 597      */
 598     public String getOutput(Output output) {
</pre>
<hr />
<pre>
 798             fileContentCacheCharset = charset;
 799         }
 800         try {
 801             File file = new File(baseDir, fileName);
 802             SoftReference&lt;String&gt; ref = fileContentCache.get(file);
 803             String content = (ref == null) ? null : ref.get();
 804             if (content != null)
 805                 return content;
 806 
 807             // charset defaults to a value inferred from latest javadoc run
 808             content = new String(Files.readAllBytes(file.toPath()), charset);
 809             fileContentCache.put(file, new SoftReference&lt;&gt;(content));
 810             return content;
 811         } catch (FileNotFoundException e) {
 812             throw new Error(&quot;File not found: &quot; + fileName + &quot;: &quot; + e);
 813         } catch (IOException e) {
 814             throw new Error(&quot;Error reading file: &quot; + fileName + &quot;: &quot; + e);
 815         }
 816     }
 817 
<span class="line-added"> 818     /**</span>
<span class="line-added"> 819      * Starts a check.</span>
<span class="line-added"> 820      *</span>
<span class="line-added"> 821      * &lt;p&gt;This method should be called before subsequently calling {@code pass(...)}</span>
<span class="line-added"> 822      * or {@code fail(...)}.</span>
<span class="line-added"> 823      *</span>
<span class="line-added"> 824      * @param message a short description of the check</span>
<span class="line-added"> 825      */</span>
 826     protected void checking(String message) {
 827         numTestsRun++;
 828         javadocTestNum++;
 829         print(&quot;Starting subtest &quot; + javadocRunNum + &quot;.&quot; + javadocTestNum, message);
 830     }
 831 
<span class="line-added"> 832     /**</span>
<span class="line-added"> 833      * Concludes a check for a file, reporting that the check succeeded.</span>
<span class="line-added"> 834      *</span>
<span class="line-added"> 835      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.</span>
<span class="line-added"> 836      *</span>
<span class="line-added"> 837      * @param file the file that was the focus of the check</span>
<span class="line-added"> 838      * @param message a short description of the outcome</span>
<span class="line-added"> 839      */</span>
 840     protected void passed(File file, String message) {
 841         passed(file + &quot;: &quot; + message);
 842     }
 843 
<span class="line-added"> 844     /**</span>
<span class="line-added"> 845      * Concludes a check, reporting that the check succeeded.</span>
<span class="line-added"> 846      *</span>
<span class="line-added"> 847      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.</span>
<span class="line-added"> 848      *</span>
<span class="line-added"> 849      * @param message a short description of the outcome</span>
<span class="line-added"> 850      */</span>
 851     protected void passed(String message) {
 852         numTestsPassed++;
 853         print(&quot;Passed&quot;, message);
 854         out.println();
 855     }
 856 
<span class="line-added"> 857     /**</span>
<span class="line-added"> 858      * Concludes a check for a file, reporting that the check failed.</span>
<span class="line-added"> 859      *</span>
<span class="line-added"> 860      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.</span>
<span class="line-added"> 861      *</span>
<span class="line-added"> 862      * @param file the file that was the focus of the check</span>
<span class="line-added"> 863      * @param message a short description of the outcome</span>
<span class="line-added"> 864      */</span>
 865     protected void failed(File file, String message) {
 866         failed(file + &quot;: &quot; + message);
 867     }
 868 
<span class="line-added"> 869     /**</span>
<span class="line-added"> 870      * Concludes a check for a file, reporting that the check failed.</span>
<span class="line-added"> 871      *</span>
<span class="line-added"> 872      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.</span>
<span class="line-added"> 873      *</span>
<span class="line-added"> 874      * @param message a short description of the outcome</span>
<span class="line-added"> 875      */</span>
 876     protected void failed(String message) {
 877         print(&quot;FAILED&quot;, message);
 878         StackWalker.getInstance().walk(s -&gt; {
 879             s.dropWhile(f -&gt; f.getMethodName().equals(&quot;failed&quot;))
 880                     .takeWhile(f -&gt; !f.getMethodName().equals(&quot;runTests&quot;))
 881                     .forEach(f -&gt; out.println(&quot;        at &quot;
 882                             + f.getClassName() + &quot;.&quot; + f.getMethodName()
 883                             + &quot;(&quot; + f.getFileName() + &quot;:&quot; + f.getLineNumber() + &quot;)&quot;));
 884             return null;
 885         });
 886         out.println();
 887     }
 888 
 889     private void print(String prefix, String message) {
 890         if (message.isEmpty())
 891             out.println(prefix);
 892         else {
 893             out.print(prefix);
 894             out.print(&quot;: &quot;);
 895             out.print(message.replace(&quot;\n&quot;, NL));
</pre>
<hr />
<pre>
 924      * if the string was found.
 925      *
 926      * @param fileString    the contents of the file to search through
 927      * @param stringToFind  the string to search for
 928      * @return              true if the string was found
 929      */
 930     private boolean findString(String fileString, String stringToFind) {
 931         // javadoc (should) always use the platform newline sequence,
 932         // but in the strings to find it is more convenient to use the Java
 933         // newline character. So we translate \n to NL before we search.
 934         stringToFind = stringToFind.replace(&quot;\n&quot;, NL);
 935         return fileString.contains(stringToFind);
 936     }
 937 
 938     /**
 939      * Compares the two given files.
 940      *
 941      * @param baseDir1 the directory in which to locate the first file
 942      * @param baseDir2 the directory in which to locate the second file
 943      * @param file the file to compare in the two base directories


 944      */
 945     private void diff(File baseDir1, File baseDir2, String file) {
 946         String file1Contents = readFile(baseDir1, file);
 947         String file2Contents = readFile(baseDir2, file);
 948         checking(&quot;diff &quot; + new File(baseDir1, file) + &quot;, &quot; + new File(baseDir2, file));
 949         if (file1Contents.trim().compareTo(file2Contents.trim()) == 0) {
 950             passed(&quot;files are equal&quot;);
 951         } else {
 952             failed(&quot;files differ&quot;);
 953         }
 954     }
 955 
 956     /**
 957      * Utility class to simplify the handling of temporarily setting a
 958      * new stream for System.out or System.err.
 959      */
 960     private static class StreamOutput {
 961         // functional interface to set a stream.
 962         private interface Initializer {
 963             void set(PrintStream s);
</pre>
</td>
</tr>
</table>
<center><a href="../../../doclet/testTypeAnnotations/TestTypeAnnotations.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../tool/doclint/DocLintTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
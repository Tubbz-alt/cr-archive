<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package javadoc.tester;
  25 
  26 import java.io.BufferedWriter;
  27 import java.io.ByteArrayOutputStream;
  28 import java.io.File;
  29 import java.io.FileNotFoundException;
  30 import java.io.FileWriter;
  31 import java.io.FilenameFilter;
  32 import java.io.IOException;
  33 import java.io.PrintStream;
  34 import java.io.PrintWriter;
  35 import java.io.StringWriter;
  36 import java.lang.annotation.Annotation;
  37 import java.lang.annotation.Retention;
  38 import java.lang.annotation.RetentionPolicy;
  39 import java.lang.ref.SoftReference;
  40 import java.lang.reflect.InvocationTargetException;
  41 import java.lang.reflect.Method;
  42 import java.nio.charset.Charset;
  43 import java.nio.charset.UnsupportedCharsetException;
  44 import java.nio.file.Files;
  45 import java.nio.file.Path;
  46 import java.nio.file.Paths;
  47 import java.util.ArrayList;
  48 import java.util.Arrays;
  49 import java.util.Collection;
  50 import java.util.Collections;
  51 import java.util.EnumMap;
  52 import java.util.HashMap;
  53 import java.util.List;
  54 import java.util.Map;
  55 import java.util.Objects;
  56 import java.util.function.Function;
  57 
  58 
  59 /**
  60  * Test framework for running javadoc and performing tests on the resulting output.
  61  *
  62  * &lt;p&gt;
  63  * Tests are typically written as subtypes of JavadocTester, with a main
  64  * method that creates an instance of the test class and calls the runTests()
  65  * method. The runTests() method calls all the test methods declared in the class,
  66  * and then calls a method to print a summary, and throw an exception if
  67  * any of the test methods reported a failure.
  68  *
  69  * &lt;p&gt;
  70  * Test methods are identified with a @Test annotation. They have no parameters.
  71  * The name of the method is not important, but if you have more than one, it is
  72  * recommended that the names be meaningful and suggestive of the test case
  73  * contained therein.
  74  *
  75  * &lt;p&gt;
  76  * Typically, a test method will invoke javadoc, and then perform various
  77  * checks on the results. The standard checks are:
  78  *
  79  * &lt;dl&gt;
  80  * &lt;dt&gt;checkExitCode
  81  * &lt;dd&gt;Check the exit code returned from javadoc.
  82  * &lt;dt&gt;checkOutput
  83  * &lt;dd&gt;Perform a series of checks on the contents on a file or output stream
  84  *     generated by javadoc.
  85  *     The checks can be either that a series of strings are found or are not found.
  86  * &lt;dt&gt;checkFiles
  87  * &lt;dd&gt;Perform a series of checks on the files generated by javadoc.
  88  *     The checks can be that a series of files are found or are not found.
  89  * &lt;/dl&gt;
  90  *
  91  * &lt;pre&gt;&lt;code&gt;
  92  *  public class MyTester extends JavadocTester {
  93  *      public static void main(String... args) throws Exception {
  94  *          MyTester tester = new MyTester();
  95  *          tester.runTests();
  96  *      }
  97  *
  98  *      // test methods...
  99  *      {@literal @}Test
 100  *      void test() {
 101  *          javadoc(&lt;i&gt;args&lt;/i&gt;);
 102  *          checkExit(Exit.OK);
 103  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, true,
 104  *              &lt;i&gt;strings-to-find&lt;/i&gt;);
 105  *          checkOutput(&lt;i&gt;file&lt;/i&gt;, false,
 106  *              &lt;i&gt;strings-to-not-find&lt;/i&gt;);
 107  *      }
 108  *  }
 109  * &lt;/code&gt;&lt;/pre&gt;
 110  *
 111  * &lt;p&gt;
 112  * If javadoc is run more than once in a test method, you can compare the
 113  * results that are generated with the diff method. Since files written by
 114  * javadoc typically contain a timestamp, you may want to use the {@code -notimestamp}
 115  * option if you are going to compare the results from two runs of javadoc.
 116  *
 117  * &lt;p&gt;
 118  * If you have many calls of checkOutput that are very similar, you can write
 119  * your own check... method to reduce the amount of duplication. For example,
 120  * if you want to check that many files contain the same string, you could
 121  * write a method that takes a varargs list of files and calls checkOutput
 122  * on each file in turn with the string to be checked.
 123  *
 124  * &lt;p&gt;
 125  * You can also write your own custom check methods. After any setup or
 126  * argument checking, the method should call {@code checking(...)},
 127  * and then eventually call either {@code passed(...)} or {@code failed(...)}
 128  * to report whether the check succeeded or not.
 129  * Use {@code readFile} to get the contents of a file generated by javadoc.
 130  *
 131  * &lt;p&gt;
 132  * You can have many separate test methods, each identified with a @Test
 133  * annotation. However, you should &lt;b&gt;not&lt;/b&gt; assume they will be called
 134  * in the order declared in your source file.  If the order of a series
 135  * of javadoc invocations is important, do that within a single method.
 136  * If the invocations are independent, for better clarity, use separate
 137  * test methods, each with their own set of checks on the results.
 138  */
 139 public abstract class JavadocTester {
 140 
 141     public static final String FS = System.getProperty(&quot;file.separator&quot;);
 142     public static final String PS = System.getProperty(&quot;path.separator&quot;);
 143     public static final String NL = System.getProperty(&quot;line.separator&quot;);
 144     public static final String thisRelease = System.getProperty(&quot;java.specification.version&quot;);
 145 
 146     public static final Path currDir = Paths.get(&quot;.&quot;).toAbsolutePath().normalize();
 147 
 148     public enum Output {
 149         /** The name of the output stream from javadoc. */
 150         OUT,
 151         /** The name for any output written to System.out. */
 152         STDOUT,
 153         /** The name for any output written to System.err. */
 154         STDERR
 155     }
 156 
 157     /** The output directory used in the most recent call of javadoc. */
 158     protected File outputDir;
 159 
 160     /** The output charset used in the most recent call of javadoc. */
 161     protected Charset charset = Charset.defaultCharset();
 162 
 163     /** The exit code of the most recent call of javadoc. */
 164     private int exitCode;
 165 
 166     /** The output generated by javadoc to the various writers and streams. */
 167     private final Map&lt;Output, String&gt; outputMap = new EnumMap&lt;&gt;(Output.class);
 168 
 169     /** A cache of file content, to avoid reading files unnecessarily. */
 170     private final Map&lt;File,SoftReference&lt;String&gt;&gt; fileContentCache = new HashMap&lt;&gt;();
 171     /** The charset used for files in the fileContentCache. */
 172     private Charset fileContentCacheCharset = null;
 173 
 174     /** Stream used for logging messages. */
 175     protected final PrintStream out = System.out;
 176 
 177     /** The directory containing the source code for the test. */
 178     public static final String testSrc = System.getProperty(&quot;test.src&quot;);
 179 
 180     /**
 181      * Get the path for a source file in the test source directory.
 182      * @param path the path of a file or directory in the source directory
 183      * @return the full path of the specified file
 184      */
 185     public static String testSrc(String path) {
 186         return new File(testSrc, path).getPath();
 187     }
 188 
 189     /**
 190      * Alternatives for checking the contents of a directory.
 191      */
 192     public enum DirectoryCheck {
 193         /**
 194          * Check that the directory is empty.
 195          */
 196         EMPTY((file, name) -&gt; true),
 197         /**
 198          * Check that the directory does not contain any HTML files,
 199          * such as may have been generated by a prior run of javadoc
 200          * using this directory.
 201          * For now, the check is only performed on the top level directory.
 202          */
 203         NO_HTML_FILES((file, name) -&gt; name.endsWith(&quot;.html&quot;)),
 204         /**
 205          * No check is performed on the directory contents.
 206          */
 207         NONE(null) { @Override void check(File dir) { } };
 208 
 209         /** The filter used to detect that files should &lt;i&gt;not&lt;/i&gt; be present. */
 210         FilenameFilter filter;
 211 
 212         DirectoryCheck(FilenameFilter f) {
 213             filter = f;
 214         }
 215 
 216         void check(File dir) {
 217             if (dir.isDirectory()) {
 218                 String[] contents = dir.list(filter);
 219                 if (contents == null)
 220                     throw new Error(&quot;cannot list directory: &quot; + dir);
 221                 if (contents.length &gt; 0) {
 222                     System.err.println(&quot;Found extraneous files in dir:&quot; + dir.getAbsolutePath());
 223                     for (String x : contents) {
 224                         System.err.println(x);
 225                     }
 226                     throw new Error(&quot;directory has unexpected content: &quot; + dir);
 227                 }
 228             }
 229         }
 230     }
 231 
 232     private DirectoryCheck outputDirectoryCheck = DirectoryCheck.EMPTY;
 233 
 234     private boolean automaticCheckAccessibility = true;
 235     private boolean automaticCheckLinks = true;
 236 
 237     /** The current subtest number. Incremented when checking(...) is called. */
 238     private int numTestsRun = 0;
 239 
 240     /** The number of subtests passed. Incremented when passed(...) is called. */
 241     private int numTestsPassed = 0;
 242 
 243     /** The current run of javadoc. Incremented when javadoc is called. */
 244     private int javadocRunNum = 0;
 245 
 246     /** The current subtest number for this run of javadoc. Incremented when checking(...) is called. */
 247     private int javadocTestNum = 0;
 248 
 249     /** Marker annotation for test methods to be invoked by runTests. */
 250     @Retention(RetentionPolicy.RUNTIME)
 251     public @interface Test { }
 252 
 253     /**
 254      * Run all methods annotated with @Test, followed by printSummary.
 255      * Typically called on a tester object in main()
 256      * @throws Exception if any errors occurred
 257      */
 258     public void runTests() throws Exception {
 259         runTests(m -&gt; new Object[0]);
 260     }
 261 
 262     /**
 263      * Runs all methods annotated with @Test, followed by printSummary.
 264      * Typically called on a tester object in main()
 265      * @param f a function which will be used to provide arguments to each
 266      *          invoked method
 267      * @throws Exception if any errors occurred
 268      */
 269     public void runTests(Function&lt;Method, Object[]&gt; f) throws Exception {
 270         for (Method m: getClass().getDeclaredMethods()) {
 271             Annotation a = m.getAnnotation(Test.class);
 272             if (a != null) {
 273                 try {
 274                     out.println(&quot;Running test &quot; + m.getName());
 275                     m.invoke(this, f.apply(m));
 276                 } catch (InvocationTargetException e) {
 277                     Throwable cause = e.getCause();
 278                     throw (cause instanceof Exception) ? ((Exception) cause) : e;
 279                 }
 280                 out.println();
 281             }
 282         }
 283         printSummary();
 284     }
 285 
 286     /**
 287      * Runs javadoc.
 288      * The output directory used by this call and the final exit code
 289      * will be saved for later use.
 290      * To aid the reader, it is recommended that calls to this method
 291      * put each option and the arguments it takes on a separate line.
 292      *
 293      * Example:
 294      * &lt;pre&gt;&lt;code&gt;
 295      *  javadoc(&quot;-d&quot;, &quot;out&quot;,
 296      *          &quot;-sourcepath&quot;, testSrc,
 297      *          &quot;-notimestamp&quot;,
 298      *          &quot;pkg1&quot;, &quot;pkg2&quot;, &quot;pkg3/C.java&quot;);
 299      * &lt;/code&gt;&lt;/pre&gt;
 300      *
 301      * @param args the arguments to pass to javadoc
 302      */
 303     public void javadoc(String... args) {
 304         outputMap.clear();
 305         fileContentCache.clear();
 306 
 307         javadocRunNum++;
 308         javadocTestNum = 0; // reset counter for this run of javadoc
 309         if (javadocRunNum == 1) {
 310             out.println(&quot;Running javadoc...&quot;);
 311         } else {
 312             out.println(&quot;Running javadoc (run &quot;+ javadocRunNum + &quot;)...&quot;);
 313         }
 314 
 315         outputDir = new File(&quot;.&quot;);
 316         String charsetArg = null;
 317         String docencodingArg = null;
 318         String encodingArg = null;
 319         for (int i = 0; i &lt; args.length - 2; i++) {
 320             switch (args[i]) {
 321                 case &quot;-d&quot;:
 322                     outputDir = new File(args[++i]);
 323                     break;
 324                 case &quot;-charset&quot;:
 325                     charsetArg = args[++i];
 326                     break;
 327                 case &quot;-docencoding&quot;:
 328                     docencodingArg = args[++i];
 329                     break;
 330                 case &quot;-encoding&quot;:
 331                     encodingArg = args[++i];
 332                     break;
 333             }
 334         }
 335 
 336         // The following replicates HtmlConfiguration.finishOptionSettings0
 337         // and sets up the charset used to read files.
 338         String cs;
 339         if (docencodingArg == null) {
 340             if (charsetArg == null) {
 341                 cs = (encodingArg == null) ? &quot;UTF-8&quot; : encodingArg;
 342             } else {
 343                 cs = charsetArg;
 344             }
 345         } else {
 346            cs = docencodingArg;
 347         }
 348         try {
 349             charset = Charset.forName(cs);
 350         } catch (UnsupportedCharsetException e) {
 351             charset = Charset.defaultCharset();
 352         }
 353 
 354         out.println(&quot;args: &quot; + Arrays.toString(args));
 355 //        log.setOutDir(outputDir);
 356 
 357         outputDirectoryCheck.check(outputDir);
 358 
 359         // This is the sole stream used by javadoc
 360         WriterOutput outOut = new WriterOutput();
 361 
 362         // These are to catch output to System.out and System.err,
 363         // in case these are used instead of the primary streams
 364         StreamOutput sysOut = new StreamOutput(System.out, System::setOut);
 365         StreamOutput sysErr = new StreamOutput(System.err, System::setErr);
 366 
 367         try {
 368             exitCode = jdk.javadoc.internal.tool.Main.execute(args, outOut.pw);
 369         } finally {
 370             outputMap.put(Output.STDOUT, sysOut.close());
 371             outputMap.put(Output.STDERR, sysErr.close());
 372             outputMap.put(Output.OUT, outOut.close());
 373         }
 374 
 375         outputMap.forEach((name, text) -&gt; {
 376             if (!text.isEmpty()) {
 377                 out.println(&quot;javadoc &quot; + name + &quot;:&quot;);
 378                 out.println(text);
 379             }
 380         });
 381 
 382         if (exitCode == Exit.OK.code &amp;&amp; outputDir.exists()) {
 383             if (automaticCheckLinks) {
 384                 checkLinks();
 385             }
 386             if (automaticCheckAccessibility) {
 387                 checkAccessibility();
 388             }
 389         }
 390     }
 391 
 392     /**
 393      * Sets the kind of check for the initial contents of the output directory
 394      * before javadoc is run.
 395      * The filter should return true for files that should &lt;b&gt;not&lt;/b&gt; appear.
 396      * @param c the kind of check to perform
 397      */
 398     public void setOutputDirectoryCheck(DirectoryCheck c) {
 399         outputDirectoryCheck = c;
 400     }
 401 
 402     /**
 403      * Sets whether or not to perform an automatic call of checkAccessibility.
 404      */
 405     public void setAutomaticCheckAccessibility(boolean b) {
 406         automaticCheckAccessibility = b;
 407     }
 408 
 409     /**
 410      * Sets whether or not to perform an automatic call of checkLinks.
 411      */
 412     public void setAutomaticCheckLinks(boolean b) {
 413         automaticCheckLinks = b;
 414     }
 415 
 416     /**
 417      * The exit codes returned by the javadoc tool.
 418      * @see jdk.javadoc.internal.tool.Main.Result
 419      */
 420     public enum Exit {
 421         OK(0),        // Javadoc completed with no errors.
 422         ERROR(1),     // Completed but reported errors.
 423         CMDERR(2),    // Bad command-line arguments
 424         SYSERR(3),    // System error or resource exhaustion.
 425         ABNORMAL(4);  // Javadoc terminated abnormally
 426 
 427         Exit(int code) {
 428             this.code = code;
 429         }
 430 
 431         final int code;
 432 
 433         @Override
 434         public String toString() {
 435             return name() + &#39;(&#39; + code + &#39;)&#39;;
 436         }
 437     }
 438 
 439     /**
 440      * Checks the exit code of the most recent call of javadoc.
 441      *
 442      * @param expected the exit code that is required for the test
 443      * to pass.
 444      */
 445     public void checkExit(Exit expected) {
 446         checking(&quot;check exit code&quot;);
 447         if (exitCode == expected.code) {
 448             passed(&quot;return code &quot; + exitCode);
 449         } else {
 450             failed(&quot;return code &quot; + exitCode +&quot;; expected &quot; + expected);
 451         }
 452     }
 453 
 454     /**
 455      * Checks for content in (or not in) the generated output.
 456      * Within the search strings, the newline character \n
 457      * will be translated to the platform newline character sequence.
 458      * @param path a path within the most recent output directory
 459      *  or the name of one of the output buffers, identifying
 460      *  where to look for the search strings.
 461      * @param expectedFound true if all of the search strings are expected
 462      *  to be found, or false if the file is not expected to be found
 463      * @param strings the strings to be searched for
 464      */
 465     public void checkFileAndOutput(String path, boolean expectedFound, String... strings) {
 466         if (expectedFound) {
 467             checkOutput(path, true, strings);
 468         } else {
 469             checkFiles(false, path);
 470         }
 471     }
 472 
 473     /**
 474      * Checks for content in (or not in) the generated output.
 475      * Within the search strings, the newline character \n
 476      * will be translated to the platform newline character sequence.
 477      * @param path a path within the most recent output directory, identifying
 478      *  where to look for the search strings.
 479      * @param expectedFound true if all of the search strings are expected
 480      *  to be found, or false if all of the strings are expected to be
 481      *  not found
 482      * @param strings the strings to be searched for
 483      */
 484     public void checkOutput(String path, boolean expectedFound, String... strings) {
 485         // Read contents of file
 486         try {
 487             String fileString = readFile(outputDir, path);
 488             checkOutput(new File(outputDir, path).getPath(), fileString, expectedFound, strings);
 489         } catch (Error e) {
 490             checking(&quot;Read file&quot;);
 491             failed(&quot;Error reading file: &quot; + e);
 492         }
 493     }
 494 
 495     /**
 496      * Checks for content in (or not in) the one of the output streams written by
 497      * javadoc. Within the search strings, the newline character \n
 498      * will be translated to the platform newline character sequence.
 499      * @param output the output stream to check
 500      * @param expectedFound true if all of the search strings are expected
 501      *  to be found, or false if all of the strings are expected to be
 502      *  not found
 503      * @param strings the strings to be searched for
 504      */
 505     public void checkOutput(Output output, boolean expectedFound, String... strings) {
 506         checkOutput(output.toString(), outputMap.get(output), expectedFound, strings);
 507     }
 508 
 509     // NOTE: path may be the name of an Output stream as well as a file path
 510     private void checkOutput(String path, String fileString, boolean expectedFound, String... strings) {
 511         for (String stringToFind : strings) {
 512 //            log.logCheckOutput(path, expectedFound, stringToFind);
 513             checking(&quot;checkOutput&quot;);
 514             // Find string in file&#39;s contents
 515             boolean isFound = findString(fileString, stringToFind);
 516             if (isFound == expectedFound) {
 517                 passed(path + &quot;: following text &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;
 518                         + stringToFind);
 519             } else {
 520                 failed(path + &quot;: following text &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;
 521                         + stringToFind + &#39;\n&#39; +
 522                         &quot;found \n&quot; +
 523                         fileString);
 524             }
 525         }
 526     }
 527 
 528     /**
 529      * Performs some structural accessibility checks on the files generated by the most
 530      * recent run of javadoc.
 531      * The checks can be run automatically by calling {@link #setAutomaticCheckAccessibility}.
 532      */
 533     public void checkAccessibility() {
 534         checking(&quot;Check accessibility&quot;);
 535         A11yChecker c = new A11yChecker(out, this::readFile);
 536         try {
 537             c.checkDirectory(outputDir.toPath());
 538             c.report();
 539             int errors = c.getErrorCount();
 540             if (errors == 0) {
 541                 passed(&quot;No accessibility errors found&quot;);
 542             } else {
 543                 failed(errors + &quot; errors found when checking accessibility&quot;);
 544             }
 545         } catch (IOException e) {
 546             failed(&quot;exception thrown when reading files: &quot; + e);
 547         }
 548     }
 549 
 550     /**
 551      * Checks all the links within the files generated by the most
 552      * recent run of javadoc.
 553      * The checks can be run automatically by calling {@link #setAutomaticCheckLinks}.
 554      */
 555     public void checkLinks() {
 556         checking(&quot;Check links&quot;);
 557         LinkChecker c = new LinkChecker(out, this::readFile);
 558         try {
 559             c.checkDirectory(outputDir.toPath());
 560             c.report();
 561             int errors = c.getErrorCount();
 562             if (errors == 0) {
 563                 passed(&quot;Links are OK&quot;);
 564             } else {
 565                 failed(errors + &quot; errors found when checking links&quot;);
 566             }
 567         } catch (IOException e) {
 568             failed(&quot;exception thrown when reading files: &quot; + e);
 569         }
 570     }
 571 
 572     /**
 573      * Shows the heading structure for each of the specified files.
 574      * The structure is is printed in plain text to the main output stream.
 575      * No errors are reported (unless there is a problem reading a file)
 576      * but missing headings are noted within the output.
 577      *
 578      * @param paths the files
 579      */
 580     public void showHeadings(String... paths) {
 581         ShowHeadings s = new ShowHeadings(out, this::readFile);
 582         for (String p : paths) {
 583             try {
 584                 File f = new File(outputDir, p);
 585                 s.checkFiles(List.of(f.toPath()), false, Collections.emptySet());
 586             } catch (IOException e) {
 587                 checking(&quot;Read file&quot;);
 588                 failed(&quot;Error reading file: &quot; + e);
 589             }
 590         }
 591     }
 592 
 593     /**
 594      * Gets the content of the one of the output streams written by javadoc.
 595      * @param output the name of the output stream
 596      * @return the content of the output stream
 597      */
 598     public String getOutput(Output output) {
 599         return outputMap.get(output);
 600     }
 601 
 602     /**
 603      * Gets the content of the one of the output streams written by javadoc.
 604      * @param output the name of the output stream
 605      * @return the content of the output stream, as a line of lines
 606      */
 607     public List&lt;String&gt; getOutputLines(Output output) {
 608         String text = outputMap.get(output);
 609         return (text == null) ? Collections.emptyList() : Arrays.asList(text.split(NL));
 610     }
 611 
 612     /**
 613      * Checks for files in (or not in) the generated output.
 614      * @param expectedFound true if all of the files are expected
 615      *  to be found, or false if all of the files are expected to be
 616      *  not found
 617      * @param paths the files to check, within the most recent output directory.
 618      * */
 619     public void checkFiles(boolean expectedFound, String... paths) {
 620         checkFiles(expectedFound, Arrays.asList(paths));
 621     }
 622 
 623     /**
 624      * Checks for files in (or not in) the generated output.
 625      * @param expectedFound true if all of the files are expected
 626      *  to be found, or false if all of the files are expected to be
 627      *  not found
 628      * @param paths the files to check, within the most recent output directory.
 629      * */
 630     public void checkFiles(boolean expectedFound, Collection&lt;String&gt; paths) {
 631         for (String path: paths) {
 632 //            log.logCheckFile(path, expectedFound);
 633             checking(&quot;checkFile&quot;);
 634             File file = new File(outputDir, path);
 635             boolean isFound = file.exists();
 636             if (isFound == expectedFound) {
 637                 passed(file, &quot;file &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;);
 638             } else {
 639                 failed(file, &quot;file &quot; + (isFound ? &quot;found:&quot; : &quot;not found:&quot;) + &quot;\n&quot;);
 640             }
 641         }
 642     }
 643 
 644     /**
 645      * Checks that a series of strings are found in order in a file in
 646      * the generated output.
 647      * @param path the file to check
 648      * @param strings  the strings whose order to check
 649      */
 650     public void checkOrder(String path, String... strings) {
 651         File file = new File(outputDir, path);
 652         String fileString = readOutputFile(path);
 653         int prevIndex = -1;
 654         for (String s : strings) {
 655             s = s.replace(&quot;\n&quot;, NL); // normalize new lines
 656             int currentIndex = fileString.indexOf(s, prevIndex + 1);
 657             checking(&quot;file: &quot; + file + &quot;: &quot; + s + &quot; at index &quot; + currentIndex);
 658             if (currentIndex == -1) {
 659                 failed(file, s + &quot; not found.&quot;);
 660                 continue;
 661             }
 662             if (currentIndex &gt; prevIndex) {
 663                 passed(file, s + &quot; is in the correct order&quot;);
 664             } else {
 665                 failed(file, s + &quot; is in the wrong order.&quot;);
 666             }
 667             prevIndex = currentIndex;
 668         }
 669     }
 670 
 671     /**
 672      * Ensures that a series of strings appear only once, in the generated output,
 673      * noting that, this test does not exhaustively check for all other possible
 674      * duplicates once one is found.
 675      * @param path the file to check
 676      * @param strings ensure each are unique
 677      */
 678     public void checkUnique(String path, String... strings) {
 679         File file = new File(outputDir, path);
 680         String fileString = readOutputFile(path);
 681         for (String s : strings) {
 682             int currentIndex = fileString.indexOf(s);
 683             checking(s + &quot; at index &quot; + currentIndex);
 684             if (currentIndex == -1) {
 685                 failed(file, s + &quot; not found.&quot;);
 686                 continue;
 687             }
 688             int nextindex = fileString.indexOf(s, currentIndex + s.length());
 689             if (nextindex == -1) {
 690                 passed(file, s + &quot; is unique&quot;);
 691             } else {
 692                 failed(file, s + &quot; is not unique, found at &quot; + nextindex);
 693             }
 694         }
 695     }
 696 
 697     /**
 698      * Compares a set of files in each of two directories.
 699      *
 700      * @param baseDir1 the directory containing the first set of files
 701      * @param baseDir2 the directory containing the second set of files
 702      * @param files the set of files to be compared
 703      */
 704     public void diff(String baseDir1, String baseDir2, String... files) {
 705         File bd1 = new File(baseDir1);
 706         File bd2 = new File(baseDir2);
 707         for (String file : files) {
 708             diff(bd1, bd2, file);
 709         }
 710     }
 711 
 712     /**
 713      * Copies a directory from one place to another.
 714      *
 715      * @param targetDir the directory to copy.
 716      * @param destDir the destination to copy the directory to.
 717      */
 718     // TODO: convert to using java.nio.Files.walkFileTree
 719     public void copyDir(String targetDir, String destDir) {
 720         try {
 721             File targetDirObj = new File(targetDir);
 722             File destDirParentObj = new File(destDir);
 723             File destDirObj = new File(destDirParentObj, targetDirObj.getName());
 724             if (! destDirParentObj.exists()) {
 725                 destDirParentObj.mkdir();
 726             }
 727             if (! destDirObj.exists()) {
 728                 destDirObj.mkdir();
 729             }
 730             String[] files = targetDirObj.list();
 731             for (String file : files) {
 732                 File srcFile = new File(targetDirObj, file);
 733                 File destFile = new File(destDirObj, file);
 734                 if (srcFile.isFile()) {
 735                     out.println(&quot;Copying &quot; + srcFile + &quot; to &quot; + destFile);
 736                     copyFile(destFile, srcFile);
 737                 } else if(srcFile.isDirectory()) {
 738                     copyDir(srcFile.getAbsolutePath(), destDirObj.getAbsolutePath());
 739                 }
 740             }
 741         } catch (IOException exc) {
 742             throw new Error(&quot;Could not copy &quot; + targetDir + &quot; to &quot; + destDir);
 743         }
 744     }
 745 
 746     /**
 747      * Copies a file.
 748      *
 749      * @param destfile the destination file
 750      * @param srcfile the source file
 751      * @throws IOException
 752      */
 753     public void copyFile(File destfile, File srcfile) throws IOException {
 754         Files.copy(srcfile.toPath(), destfile.toPath());
 755     }
 756 
 757     /**
 758      * Read a file from the output directory.
 759      *
 760      * @param fileName  the name of the file to read
 761      * @return          the file in string format
 762      */
 763     public String readOutputFile(String fileName) throws Error {
 764         return readFile(outputDir, fileName);
 765     }
 766 
 767     protected String readFile(String fileName) throws Error {
 768         return readFile(outputDir, fileName);
 769     }
 770 
 771     protected String readFile(String baseDir, String fileName) throws Error {
 772         return readFile(new File(baseDir), fileName);
 773     }
 774 
 775     protected String readFile(Path file) {
 776         File baseDir;
 777         if (file.startsWith(outputDir.toPath())) {
 778             baseDir = outputDir;
 779         } else if (file.startsWith(currDir)) {
 780             baseDir = currDir.toFile();
 781         } else {
 782             baseDir = file.getParent().toFile();
 783         }
 784         String fileName = baseDir.toPath().relativize(file).toString();
 785         return readFile(baseDir, fileName);
 786     }
 787 
 788     /**
 789      * Reads the file and return it as a string.
 790      *
 791      * @param baseDir   the directory in which to locate the file
 792      * @param fileName  the name of the file to read
 793      * @return          the file in string format
 794      */
 795     private String readFile(File baseDir, String fileName) throws Error {
 796         if (!Objects.equals(fileContentCacheCharset, charset)) {
 797             fileContentCache.clear();
 798             fileContentCacheCharset = charset;
 799         }
 800         try {
 801             File file = new File(baseDir, fileName);
 802             SoftReference&lt;String&gt; ref = fileContentCache.get(file);
 803             String content = (ref == null) ? null : ref.get();
 804             if (content != null)
 805                 return content;
 806 
 807             // charset defaults to a value inferred from latest javadoc run
 808             content = new String(Files.readAllBytes(file.toPath()), charset);
 809             fileContentCache.put(file, new SoftReference&lt;&gt;(content));
 810             return content;
 811         } catch (FileNotFoundException e) {
 812             throw new Error(&quot;File not found: &quot; + fileName + &quot;: &quot; + e);
 813         } catch (IOException e) {
 814             throw new Error(&quot;Error reading file: &quot; + fileName + &quot;: &quot; + e);
 815         }
 816     }
 817 
 818     /**
 819      * Starts a check.
 820      *
 821      * &lt;p&gt;This method should be called before subsequently calling {@code pass(...)}
 822      * or {@code fail(...)}.
 823      *
 824      * @param message a short description of the check
 825      */
 826     protected void checking(String message) {
 827         numTestsRun++;
 828         javadocTestNum++;
 829         print(&quot;Starting subtest &quot; + javadocRunNum + &quot;.&quot; + javadocTestNum, message);
 830     }
 831 
 832     /**
 833      * Concludes a check for a file, reporting that the check succeeded.
 834      *
 835      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.
 836      *
 837      * @param file the file that was the focus of the check
 838      * @param message a short description of the outcome
 839      */
 840     protected void passed(File file, String message) {
 841         passed(file + &quot;: &quot; + message);
 842     }
 843 
 844     /**
 845      * Concludes a check, reporting that the check succeeded.
 846      *
 847      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.
 848      *
 849      * @param message a short description of the outcome
 850      */
 851     protected void passed(String message) {
 852         numTestsPassed++;
 853         print(&quot;Passed&quot;, message);
 854         out.println();
 855     }
 856 
 857     /**
 858      * Concludes a check for a file, reporting that the check failed.
 859      *
 860      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.
 861      *
 862      * @param file the file that was the focus of the check
 863      * @param message a short description of the outcome
 864      */
 865     protected void failed(File file, String message) {
 866         failed(file + &quot;: &quot; + message);
 867     }
 868 
 869     /**
 870      * Concludes a check for a file, reporting that the check failed.
 871      *
 872      * &lt;p&gt;This method should be called after previously calling {@code checking(...)}.
 873      *
 874      * @param message a short description of the outcome
 875      */
 876     protected void failed(String message) {
 877         print(&quot;FAILED&quot;, message);
 878         StackWalker.getInstance().walk(s -&gt; {
 879             s.dropWhile(f -&gt; f.getMethodName().equals(&quot;failed&quot;))
 880                     .takeWhile(f -&gt; !f.getMethodName().equals(&quot;runTests&quot;))
 881                     .forEach(f -&gt; out.println(&quot;        at &quot;
 882                             + f.getClassName() + &quot;.&quot; + f.getMethodName()
 883                             + &quot;(&quot; + f.getFileName() + &quot;:&quot; + f.getLineNumber() + &quot;)&quot;));
 884             return null;
 885         });
 886         out.println();
 887     }
 888 
 889     private void print(String prefix, String message) {
 890         if (message.isEmpty())
 891             out.println(prefix);
 892         else {
 893             out.print(prefix);
 894             out.print(&quot;: &quot;);
 895             out.print(message.replace(&quot;\n&quot;, NL));
 896             if (!(message.endsWith(&quot;\n&quot;) || message.endsWith(NL))) {
 897                 out.println();
 898             }
 899         }
 900     }
 901 
 902     /**
 903      * Prints a summary of the test results.
 904      */
 905     protected void printSummary() {
 906         String javadocRuns = (javadocRunNum &lt;= 1) ? &quot;&quot;
 907                 : &quot;, in &quot; + javadocRunNum + &quot; runs of javadoc&quot;;
 908 
 909         if (numTestsRun != 0 &amp;&amp; numTestsPassed == numTestsRun) {
 910             // Test passed
 911             out.println();
 912             out.println(&quot;All &quot; + numTestsPassed + &quot; subtests passed&quot; + javadocRuns);
 913         } else {
 914             // Test failed
 915             throw new Error((numTestsRun - numTestsPassed)
 916                     + &quot; of &quot; + (numTestsRun)
 917                     + &quot; subtests failed&quot;
 918                     + javadocRuns);
 919         }
 920     }
 921 
 922     /**
 923      * Searches for the string in the given file and return true
 924      * if the string was found.
 925      *
 926      * @param fileString    the contents of the file to search through
 927      * @param stringToFind  the string to search for
 928      * @return              true if the string was found
 929      */
 930     private boolean findString(String fileString, String stringToFind) {
 931         // javadoc (should) always use the platform newline sequence,
 932         // but in the strings to find it is more convenient to use the Java
 933         // newline character. So we translate \n to NL before we search.
 934         stringToFind = stringToFind.replace(&quot;\n&quot;, NL);
 935         return fileString.contains(stringToFind);
 936     }
 937 
 938     /**
 939      * Compares the two given files.
 940      *
 941      * @param baseDir1 the directory in which to locate the first file
 942      * @param baseDir2 the directory in which to locate the second file
 943      * @param file the file to compare in the two base directories
 944      */
 945     private void diff(File baseDir1, File baseDir2, String file) {
 946         String file1Contents = readFile(baseDir1, file);
 947         String file2Contents = readFile(baseDir2, file);
 948         checking(&quot;diff &quot; + new File(baseDir1, file) + &quot;, &quot; + new File(baseDir2, file));
 949         if (file1Contents.trim().compareTo(file2Contents.trim()) == 0) {
 950             passed(&quot;files are equal&quot;);
 951         } else {
 952             failed(&quot;files differ&quot;);
 953         }
 954     }
 955 
 956     /**
 957      * Utility class to simplify the handling of temporarily setting a
 958      * new stream for System.out or System.err.
 959      */
 960     private static class StreamOutput {
 961         // functional interface to set a stream.
 962         private interface Initializer {
 963             void set(PrintStream s);
 964         }
 965 
 966         private final ByteArrayOutputStream baos = new ByteArrayOutputStream();
 967         private final PrintStream ps = new PrintStream(baos);
 968         private final PrintStream prev;
 969         private final Initializer init;
 970 
 971         StreamOutput(PrintStream s, Initializer init) {
 972             prev = s;
 973             init.set(ps);
 974             this.init = init;
 975         }
 976 
 977         String close() {
 978             init.set(prev);
 979             ps.close();
 980             return baos.toString();
 981         }
 982     }
 983 
 984     /**
 985      * Utility class to simplify the handling of creating an in-memory PrintWriter.
 986      */
 987     private static class WriterOutput {
 988         private final StringWriter sw = new StringWriter();
 989         final PrintWriter pw = new PrintWriter(sw);
 990         String close() {
 991             pw.close();
 992             return sw.toString();
 993         }
 994     }
 995 
 996 
 997 //    private final Logger log = new Logger();
 998 
 999     //--------- Logging --------------------------------------------------------
1000     //
1001     // This class writes out the details of calls to checkOutput and checkFile
1002     // in a canonical way, so that the resulting file can be checked against
1003     // similar files from other versions of JavadocTester using the same logging
1004     // facilities.
1005 
1006     static class Logger {
1007         private static final int PREFIX = 40;
1008         private static final int SUFFIX = 20;
1009         private static final int MAX = PREFIX + SUFFIX;
1010         List&lt;String&gt; tests = new ArrayList&lt;&gt;();
1011         String outDir;
1012         String rootDir = rootDir();
1013 
1014         static String rootDir() {
1015             File f = new File(&quot;.&quot;).getAbsoluteFile();
1016             while (!new File(f, &quot;.hg&quot;).exists())
1017                 f = f.getParentFile();
1018             return f.getPath();
1019         }
1020 
1021         void setOutDir(File outDir) {
1022             this.outDir = outDir.getPath();
1023         }
1024 
1025         void logCheckFile(String file, boolean positive) {
1026             // Strip the outdir because that will typically not be the same
1027             if (file.startsWith(outDir + &quot;/&quot;))
1028                 file = file.substring(outDir.length() + 1);
1029             tests.add(file + &quot; &quot; + positive);
1030         }
1031 
1032         void logCheckOutput(String file, boolean positive, String text) {
1033             // Compress the string to be displayed in the log file
1034             String simpleText = text.replaceAll(&quot;\\s+&quot;, &quot; &quot;).replace(rootDir, &quot;[ROOT]&quot;);
1035             if (simpleText.length() &gt; MAX)
1036                 simpleText = simpleText.substring(0, PREFIX)
1037                         + &quot;...&quot; + simpleText.substring(simpleText.length() - SUFFIX);
1038             // Strip the outdir because that will typically not be the same
1039             if (file.startsWith(outDir + &quot;/&quot;))
1040                 file = file.substring(outDir.length() + 1);
1041             // The use of text.hashCode ensure that all of &quot;text&quot; is taken into account
1042             tests.add(file + &quot; &quot; + positive + &quot; &quot; + text.hashCode() + &quot; &quot; + simpleText);
1043         }
1044 
1045         void write() {
1046             // sort the log entries because the subtests may not be executed in the same order
1047             tests.sort((a, b) -&gt; a.compareTo(b));
1048             try (BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;tester.log&quot;))) {
1049                 for (String t: tests) {
1050                     bw.write(t);
1051                     bw.newLine();
1052                 }
1053             } catch (IOException e) {
1054                 throw new Error(&quot;problem writing log: &quot; + e);
1055             }
1056         }
1057     }
1058 
1059     // Support classes for checkLinks
1060 
1061 }
    </pre>
  </body>
</html>
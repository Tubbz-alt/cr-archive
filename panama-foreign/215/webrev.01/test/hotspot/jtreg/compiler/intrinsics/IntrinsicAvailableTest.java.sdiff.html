<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/intrinsics/IntrinsicAvailableTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../escapeAnalysis/TestGetClass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="IntrinsicDisabledTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/intrinsics/IntrinsicAvailableTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8130832
 27  * @modules java.base/jdk.internal.misc
 28  * @library /test/lib /
 29  *
 30  * @build sun.hotspot.WhiteBox
 31  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 32  * @run main/othervm -Xbootclasspath/a:.
 33  *                   -XX:+UnlockDiagnosticVMOptions
 34  *                   -XX:+WhiteBoxAPI
 35  *                   -XX:+UseCRC32Intrinsics
 36  *                   compiler.intrinsics.IntrinsicAvailableTest
 37  * @run main/othervm -Xbootclasspath/a:.
 38  *                   -XX:+UnlockDiagnosticVMOptions
 39  *                   -XX:+WhiteBoxAPI
 40  *                   -XX:-UseCRC32Intrinsics
 41  *                   compiler.intrinsics.IntrinsicAvailableTest



















 42  */
 43 
 44 
 45 package compiler.intrinsics;
 46 
 47 import compiler.whitebox.CompilerWhiteBoxTest;
 48 import jdk.test.lib.Platform;
 49 
 50 import java.lang.reflect.Executable;
 51 import java.util.concurrent.Callable;
 52 
 53 public class IntrinsicAvailableTest extends CompilerWhiteBoxTest {
 54 
 55     public IntrinsicAvailableTest(IntrinsicAvailableTestTestCase testCase) {
 56         super(testCase);
 57     }
 58 
 59     public static class IntrinsicAvailableTestTestCase implements TestCase {
 60 
 61         public String name() {
</pre>
<hr />
<pre>
 76             try {
 77                 return Class.forName(&quot;java.util.zip.CRC32&quot;).getDeclaredMethod(&quot;update&quot;, int.class, int.class);
 78             } catch (NoSuchMethodException e) {
 79                 throw new RuntimeException(&quot;Test bug, method unavailable. &quot; + e);
 80             } catch (ClassNotFoundException e) {
 81                 throw new RuntimeException(&quot;Test bug, class unavailable. &quot; + e);
 82             }
 83         }
 84 
 85         public Callable&lt;Integer&gt; getCallable() {
 86             return null;
 87         }
 88 
 89         public boolean isOsr() {
 90             return false;
 91         }
 92 
 93     }
 94 
 95     protected void checkIntrinsicForCompilationLevel(Executable method, int compLevel) throws Exception {
<span class="line-modified"> 96         boolean intrinsicEnabled = Boolean.valueOf(getVMOption(&quot;UseCRC32Intrinsics&quot;));</span>










 97         boolean intrinsicAvailable = WHITE_BOX.isIntrinsicAvailable(method,
 98                                                                     compLevel);
 99 
100         String intrinsicEnabledMessage = intrinsicEnabled ? &quot;enabled&quot; : &quot;disabled&quot;;
101         String intrinsicAvailableMessage = intrinsicAvailable ? &quot;available&quot; : &quot;not available&quot;;
102 
103         if (intrinsicEnabled == intrinsicAvailable) {
104             System.out.println(&quot;Expected result: intrinsic for java.util.zip.CRC32.update() is &quot; +
105                                intrinsicEnabledMessage + &quot; and intrinsic is &quot; + intrinsicAvailableMessage +
106                                &quot; at compilation level &quot; + compLevel);
107         } else {
108             throw new RuntimeException(&quot;Unexpected result: intrinsic for java.util.zip.CRC32.update() is &quot; +
109                                        intrinsicEnabledMessage + &quot; but intrinsic is &quot; + intrinsicAvailableMessage +
110                                        &quot; at compilation level &quot; + compLevel);
111         }
112     }
113 
114     public void test() throws Exception {
115         Executable intrinsicMethod = testCase.getExecutable();
116         if (Platform.isServer() &amp;&amp; !Platform.isEmulatedClient() &amp;&amp; (TIERED_STOP_AT_LEVEL == COMP_LEVEL_FULL_OPTIMIZATION)) {
</pre>
</td>
<td>
<hr />
<pre>
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8130832
 27  * @modules java.base/jdk.internal.misc
 28  * @library /test/lib /
 29  *
 30  * @build sun.hotspot.WhiteBox
 31  * @run driver ClassFileInstaller sun.hotspot.WhiteBox
 32  * @run main/othervm -Xbootclasspath/a:.
 33  *                   -XX:+UnlockDiagnosticVMOptions
 34  *                   -XX:+WhiteBoxAPI
 35  *                   -XX:+UseCRC32Intrinsics
 36  *                   compiler.intrinsics.IntrinsicAvailableTest
 37  * @run main/othervm -Xbootclasspath/a:.
 38  *                   -XX:+UnlockDiagnosticVMOptions
 39  *                   -XX:+WhiteBoxAPI
 40  *                   -XX:-UseCRC32Intrinsics
 41  *                   compiler.intrinsics.IntrinsicAvailableTest
<span class="line-added"> 42  * @run main/othervm -Xbootclasspath/a:.</span>
<span class="line-added"> 43  *                   -XX:+UnlockDiagnosticVMOptions</span>
<span class="line-added"> 44  *                   -XX:+WhiteBoxAPI</span>
<span class="line-added"> 45  *                   -XX:ControlIntrinsic=+_updateCRC32</span>
<span class="line-added"> 46  *                   -XX:-UseCRC32Intrinsics</span>
<span class="line-added"> 47  *                   compiler.intrinsics.IntrinsicAvailableTest</span>
<span class="line-added"> 48  * @run main/othervm -Xbootclasspath/a:.</span>
<span class="line-added"> 49  *                   -XX:+UnlockDiagnosticVMOptions</span>
<span class="line-added"> 50  *                   -XX:+WhiteBoxAPI</span>
<span class="line-added"> 51  *                   -XX:ControlIntrinsic=-_updateCRC32</span>
<span class="line-added"> 52  *                   -XX:+UseCRC32Intrinsics</span>
<span class="line-added"> 53  *                   compiler.intrinsics.IntrinsicAvailableTest</span>
<span class="line-added"> 54  *</span>
<span class="line-added"> 55  * @run main/othervm -Xbootclasspath/a:.</span>
<span class="line-added"> 56  *                   -XX:+UnlockDiagnosticVMOptions</span>
<span class="line-added"> 57  *                   -XX:+WhiteBoxAPI</span>
<span class="line-added"> 58  *                   -XX:ControlIntrinsic=+_updateCRC32</span>
<span class="line-added"> 59  *                   -XX:+UseCRC32Intrinsics</span>
<span class="line-added"> 60  *                   compiler.intrinsics.IntrinsicAvailableTest</span>
 61  */
 62 
 63 
 64 package compiler.intrinsics;
 65 
 66 import compiler.whitebox.CompilerWhiteBoxTest;
 67 import jdk.test.lib.Platform;
 68 
 69 import java.lang.reflect.Executable;
 70 import java.util.concurrent.Callable;
 71 
 72 public class IntrinsicAvailableTest extends CompilerWhiteBoxTest {
 73 
 74     public IntrinsicAvailableTest(IntrinsicAvailableTestTestCase testCase) {
 75         super(testCase);
 76     }
 77 
 78     public static class IntrinsicAvailableTestTestCase implements TestCase {
 79 
 80         public String name() {
</pre>
<hr />
<pre>
 95             try {
 96                 return Class.forName(&quot;java.util.zip.CRC32&quot;).getDeclaredMethod(&quot;update&quot;, int.class, int.class);
 97             } catch (NoSuchMethodException e) {
 98                 throw new RuntimeException(&quot;Test bug, method unavailable. &quot; + e);
 99             } catch (ClassNotFoundException e) {
100                 throw new RuntimeException(&quot;Test bug, class unavailable. &quot; + e);
101             }
102         }
103 
104         public Callable&lt;Integer&gt; getCallable() {
105             return null;
106         }
107 
108         public boolean isOsr() {
109             return false;
110         }
111 
112     }
113 
114     protected void checkIntrinsicForCompilationLevel(Executable method, int compLevel) throws Exception {
<span class="line-modified">115         boolean intrinsicEnabled = true;</span>
<span class="line-added">116         String controlIntrinsic = getVMOption(&quot;ControlIntrinsic&quot;, &quot;&quot;);</span>
<span class="line-added">117 </span>
<span class="line-added">118         if (controlIntrinsic.contains(&quot;+_updateCRC32&quot;)) {</span>
<span class="line-added">119           intrinsicEnabled = true;</span>
<span class="line-added">120         } else if (controlIntrinsic.contains(&quot;-_updateCRC32&quot;)) {</span>
<span class="line-added">121           intrinsicEnabled = false;</span>
<span class="line-added">122         }</span>
<span class="line-added">123 </span>
<span class="line-added">124         intrinsicEnabled &amp;= Boolean.valueOf(getVMOption(&quot;UseCRC32Intrinsics&quot;));</span>
<span class="line-added">125 </span>
126         boolean intrinsicAvailable = WHITE_BOX.isIntrinsicAvailable(method,
127                                                                     compLevel);
128 
129         String intrinsicEnabledMessage = intrinsicEnabled ? &quot;enabled&quot; : &quot;disabled&quot;;
130         String intrinsicAvailableMessage = intrinsicAvailable ? &quot;available&quot; : &quot;not available&quot;;
131 
132         if (intrinsicEnabled == intrinsicAvailable) {
133             System.out.println(&quot;Expected result: intrinsic for java.util.zip.CRC32.update() is &quot; +
134                                intrinsicEnabledMessage + &quot; and intrinsic is &quot; + intrinsicAvailableMessage +
135                                &quot; at compilation level &quot; + compLevel);
136         } else {
137             throw new RuntimeException(&quot;Unexpected result: intrinsic for java.util.zip.CRC32.update() is &quot; +
138                                        intrinsicEnabledMessage + &quot; but intrinsic is &quot; + intrinsicAvailableMessage +
139                                        &quot; at compilation level &quot; + compLevel);
140         }
141     }
142 
143     public void test() throws Exception {
144         Executable intrinsicMethod = testCase.getExecutable();
145         if (Platform.isServer() &amp;&amp; !Platform.isEmulatedClient() &amp;&amp; (TIERED_STOP_AT_LEVEL == COMP_LEVEL_FULL_OPTIMIZATION)) {
</pre>
</td>
</tr>
</table>
<center><a href="../escapeAnalysis/TestGetClass.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="IntrinsicDisabledTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
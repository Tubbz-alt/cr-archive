<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/gtest/utilities/test_growableArray.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #include &quot;precompiled.hpp&quot;
 25 #include &quot;memory/resourceArea.hpp&quot;
 26 #include &quot;utilities/growableArray.hpp&quot;
 27 #include &quot;unittest.hpp&quot;
 28 
 29 struct WithEmbeddedArray {
 30   // Array embedded in another class
 31   GrowableArray&lt;int&gt; _a;
 32 
 33   // Resource allocated data array
 34   WithEmbeddedArray(int initial_max) : _a(initial_max) {}
 35   // Arena allocated data array
 36   WithEmbeddedArray(Arena* arena, int initial_max) : _a(arena, initial_max, 0, 0) {}
 37   // CHeap allocated data array
 38   WithEmbeddedArray(int initial_max, MEMFLAGS memflags) : _a(initial_max, memflags) {
 39     assert(memflags != mtNone, &quot;test requirement&quot;);
 40   }
 41   WithEmbeddedArray(const GrowableArray&lt;int&gt;&amp; other) : _a(other) {}
 42 };
 43 
 44 // Test fixture to work with TEST_VM_F
 45 class GrowableArrayTest : public ::testing::Test {
 46 protected:
 47   // friend -&gt; private accessors
 48   template &lt;typename E&gt;
 49   static bool elements_on_C_heap(const GrowableArray&lt;E&gt;* array) {
 50     return array-&gt;on_C_heap();
 51   }
 52   template &lt;typename E&gt;
 53   static bool elements_on_stack(const GrowableArray&lt;E&gt;* array) {
 54     return array-&gt;on_stack();
 55   }
 56   template &lt;typename E&gt;
 57   static bool elements_on_arena(const GrowableArray&lt;E&gt;* array) {
 58     return array-&gt;on_arena();
 59   }
 60 
 61   template &lt;typename ArrayClass&gt;
 62   static void test_append(ArrayClass* a) {
 63     // Add elements
 64     for (int i = 0; i &lt; 10; i++) {
 65       a-&gt;append(i);
 66     }
 67 
 68     // Check size
 69     ASSERT_EQ(a-&gt;length(), 10);
 70 
 71     // Check elements
 72     for (int i = 0; i &lt; 10; i++) {
 73       EXPECT_EQ(a-&gt;at(i), i);
 74     }
 75   }
 76 
 77   template &lt;typename ArrayClass&gt;
 78   static void test_clear(ArrayClass* a) {
 79     // Add elements
 80     for (int i = 0; i &lt; 10; i++) {
 81       a-&gt;append(i);
 82     }
 83 
 84     // Check size
 85     ASSERT_EQ(a-&gt;length(), 10);
 86     ASSERT_EQ(a-&gt;is_empty(), false);
 87 
 88     // Clear elements
 89     a-&gt;clear();
 90 
 91     // Check size
 92     ASSERT_EQ(a-&gt;length(), 0);
 93     ASSERT_EQ(a-&gt;is_empty(), true);
 94 
 95     // Add element
 96     a-&gt;append(11);
 97 
 98     // Check size
 99     ASSERT_EQ(a-&gt;length(), 1);
100     ASSERT_EQ(a-&gt;is_empty(), false);
101 
102     // Clear elements
103     a-&gt;clear();
104 
105     // Check size
106     ASSERT_EQ(a-&gt;length(), 0);
107     ASSERT_EQ(a-&gt;is_empty(), true);
108   }
109 
110   template &lt;typename ArrayClass&gt;
111   static void test_iterator(ArrayClass* a) {
112     // Add elements
113     for (int i = 0; i &lt; 10; i++) {
114       a-&gt;append(i);
115     }
116 
117     // Iterate
118     int counter = 0;
119     for (GrowableArrayIterator&lt;int&gt; i = a-&gt;begin(); i != a-&gt;end(); ++i) {
120       ASSERT_EQ(*i, counter++);
121     }
122 
123     // Check count
124     ASSERT_EQ(counter, 10);
125   }
126 
127   template &lt;typename ArrayClass&gt;
128   static void test_copy1(ArrayClass* a) {
129     ASSERT_EQ(a-&gt;length(), 1);
130     ASSERT_EQ(a-&gt;at(0), 1);
131 
132     // Only allowed to copy to stack and embedded ResourceObjs
133 
134     // Copy to stack
135     {
136       GrowableArray&lt;int&gt; c(*a);
137 
138       ASSERT_EQ(c.length(), 1);
139       ASSERT_EQ(c.at(0), 1);
140     }
141 
142     // Copy to embedded
143     {
144       WithEmbeddedArray c(*a);
145 
146       ASSERT_EQ(c._a.length(), 1);
147       ASSERT_EQ(c._a.at(0), 1);
148     }
149   }
150 
151   template &lt;typename ArrayClass&gt;
152   static void test_assignment1(ArrayClass* a) {
153     ASSERT_EQ(a-&gt;length(), 1);
154     ASSERT_EQ(a-&gt;at(0), 1);
155 
156     // Only allowed to assign to stack and embedded ResourceObjs
157 
158     // Copy to embedded/resource
159     {
160       ResourceMark rm;
161       GrowableArray&lt;int&gt; c(1);
162       c = *a;
163 
164       ASSERT_EQ(c.length(), 1);
165       ASSERT_EQ(c.at(0), 1);
166     }
167 
168     // Copy to embedded/arena
169     {
170       Arena arena(mtTest);
171       GrowableArray&lt;int&gt; c(&amp;arena, 1, 0, 0);
172       c = *a;
173 
174       ASSERT_EQ(c.length(), 1);
175       ASSERT_EQ(c.at(0), 1);
176     }
177 
178     // Copy to embedded/resource
179     {
180       ResourceMark rm;
181       WithEmbeddedArray c(1);
182       c._a = *a;
183 
184       ASSERT_EQ(c._a.length(), 1);
185       ASSERT_EQ(c._a.at(0), 1);
186     }
187 
188     // Copy to embedded/arena
189     {
190       Arena arena(mtTest);
191       WithEmbeddedArray c(&amp;arena, 1);
192       c._a = *a;
193 
194       ASSERT_EQ(c._a.length(), 1);
195       ASSERT_EQ(c._a.at(0), 1);
196     }
197   }
198 
199   // Supported by all GrowableArrays
200   enum TestEnum {
201     Append,
202     Clear,
203     Iterator,
204   };
205 
206   template &lt;typename ArrayClass&gt;
207   static void do_test(ArrayClass* a, TestEnum test) {
208     switch (test) {
209       case Append:
210         test_append(a);
211         break;
212 
213       case Clear:
214         test_clear(a);
215         break;
216 
217       case Iterator:
218         test_iterator(a);
219         break;
220 
221       default:
222         fatal(&quot;Missing dispatch&quot;);
223         break;
224     }
225   }
226 
227   // Only supported by GrowableArrays without CHeap data arrays
228   enum TestNoCHeapEnum {
229     Copy1,
230     Assignment1,
231   };
232 
233   template &lt;typename ArrayClass&gt;
234   static void do_test(ArrayClass* a, TestNoCHeapEnum test) {
235     switch (test) {
236       case Copy1:
237         test_copy1(a);
238         break;
239 
240       case Assignment1:
241         test_assignment1(a);
242         break;
243 
244       default:
245         fatal(&quot;Missing dispatch&quot;);
246         break;
247     }
248   }
249 
250   enum ModifyEnum {
251     Append1,
252     Append1Clear,
253     Append1ClearAndDeallocate,
254     NoModify
255   };
256 
257   template &lt;typename ArrayClass&gt;
258   static void do_modify(ArrayClass* a, ModifyEnum modify) {
259     switch (modify) {
260       case Append1:
261         a-&gt;append(1);
262         break;
263 
264       case Append1Clear:
265         a-&gt;append(1);
266         a-&gt;clear();
267         break;
268 
269       case Append1ClearAndDeallocate:
270         a-&gt;append(1);
271         a-&gt;clear_and_deallocate();
272         break;
273 
274       case NoModify:
275         // Nothing to do
276         break;
277 
278       default:
279         fatal(&quot;Missing dispatch&quot;);
280         break;
281     }
282   }
283 
284   static const int Max0 = 0;
285   static const int Max1 = 1;
286 
287   template &lt;typename ArrayClass, typename T&gt;
288   static void modify_and_test(ArrayClass* array, ModifyEnum modify, T test) {
289     do_modify(array, modify);
290     do_test(array, test);
291   }
292 
293   template &lt;typename T&gt;
294   static void with_no_cheap_array(int max, ModifyEnum modify, T test) {
295     // Resource/Resource allocated
296     {
297       ResourceMark rm;
298       GrowableArray&lt;int&gt;* a = new GrowableArray&lt;int&gt;(max);
299       modify_and_test(a, modify, test);
300     }
301 
302     // Resource/Arena allocated
303     //  Combination not supported
304 
305     // CHeap/Resource allocated
306     //  Combination not supported
307 
308     // CHeap/Arena allocated
309     //  Combination not supported
310 
311     // Stack/Resource allocated
312     {
313       ResourceMark rm;
314       GrowableArray&lt;int&gt; a(max);
315       modify_and_test(&amp;a, modify, test);
316     }
317 
318     // Stack/Arena allocated
319     {
320       Arena arena(mtTest);
321       GrowableArray&lt;int&gt; a(&amp;arena, max, 0, 0);
322       modify_and_test(&amp;a, modify, test);
323     }
324 
325     // Embedded/Resource allocated
326     {
327       ResourceMark rm;
328       WithEmbeddedArray w(max);
329       modify_and_test(&amp;w._a, modify, test);
330     }
331 
332     // Embedded/Arena allocated
333     {
334       Arena arena(mtTest);
335       WithEmbeddedArray w(&amp;arena, max);
336       modify_and_test(&amp;w._a, modify, test);
337     }
338   }
339 
340   static void with_cheap_array(int max, ModifyEnum modify, TestEnum test) {
341     // Resource/CHeap allocated
342     //  Combination not supported
343 
344     // CHeap/CHeap allocated
345     {
346       GrowableArray&lt;int&gt;* a = new (ResourceObj::C_HEAP, mtTest) GrowableArray&lt;int&gt;(max, mtTest);
347       modify_and_test(a, modify, test);
348       delete a;
349     }
350 
351     // Stack/CHeap allocated
352     {
353       GrowableArray&lt;int&gt; a(max, mtTest);
354       modify_and_test(&amp;a, modify, test);
355     }
356 
357     // Embedded/CHeap allocated
358     {
359       WithEmbeddedArray w(max, mtTest);
360       modify_and_test(&amp;w._a, modify, test);
361     }
362   }
363 
364   static void with_all_types(int max, ModifyEnum modify, TestEnum test) {
365     with_no_cheap_array(max, modify, test);
366     with_cheap_array(max, modify, test);
367   }
368 
369   static void with_all_types_empty(TestEnum test) {
370     with_all_types(Max0, NoModify, test);
371   }
372 
373   static void with_all_types_max_set(TestEnum test) {
374     with_all_types(Max1, NoModify, test);
375   }
376 
377   static void with_all_types_cleared(TestEnum test) {
378     with_all_types(Max1, Append1Clear, test);
379   }
380 
381   static void with_all_types_clear_and_deallocated(TestEnum test) {
382     with_all_types(Max1, Append1ClearAndDeallocate, test);
383   }
384 
385   static void with_all_types_all_0(TestEnum test) {
386     with_all_types_empty(test);
387     with_all_types_max_set(test);
388     with_all_types_cleared(test);
389     with_all_types_clear_and_deallocated(test);
390   }
391 
392   static void with_no_cheap_array_append1(TestNoCHeapEnum test) {
393     with_no_cheap_array(Max0, Append1, test);
394   }
395 };
396 
397 TEST_VM_F(GrowableArrayTest, append) {
398   with_all_types_all_0(Append);
399 }
400 
401 TEST_VM_F(GrowableArrayTest, clear) {
402   with_all_types_all_0(Clear);
403 }
404 
405 TEST_VM_F(GrowableArrayTest, iterator) {
406   with_all_types_all_0(Iterator);
407 }
408 
409 TEST_VM_F(GrowableArrayTest, copy) {
410   with_no_cheap_array_append1(Copy1);
411 }
412 
413 TEST_VM_F(GrowableArrayTest, assignment) {
414   with_no_cheap_array_append1(Assignment1);
415 }
416 
417 #ifdef ASSERT
418 TEST_VM_F(GrowableArrayTest, where) {
419   WithEmbeddedArray s(1, mtTest);
420   ASSERT_FALSE(s._a.allocated_on_C_heap());
421   ASSERT_TRUE(elements_on_C_heap(&amp;s._a));
422 
423   // Resource/Resource allocated
424   {
425     ResourceMark rm;
426     GrowableArray&lt;int&gt;* a = new GrowableArray&lt;int&gt;();
427     ASSERT_TRUE(a-&gt;allocated_on_res_area());
428     ASSERT_TRUE(elements_on_stack(a));
429   }
430 
431   // Resource/CHeap allocated
432   //  Combination not supported
433 
434   // Resource/Arena allocated
435   //  Combination not supported
436 
437   // CHeap/Resource allocated
438   //  Combination not supported
439 
440   // CHeap/CHeap allocated
441   {
442     GrowableArray&lt;int&gt;* a = new (ResourceObj::C_HEAP, mtTest) GrowableArray&lt;int&gt;(0, mtTest);
443     ASSERT_TRUE(a-&gt;allocated_on_C_heap());
444     ASSERT_TRUE(elements_on_C_heap(a));
445     delete a;
446   }
447 
448   // CHeap/Arena allocated
449   //  Combination not supported
450 
451   // Stack/Resource allocated
452   {
453     ResourceMark rm;
454     GrowableArray&lt;int&gt; a(0);
455     ASSERT_TRUE(a.allocated_on_stack());
456     ASSERT_TRUE(elements_on_stack(&amp;a));
457   }
458 
459   // Stack/CHeap allocated
460   {
461     GrowableArray&lt;int&gt; a(0, mtTest);
462     ASSERT_TRUE(a.allocated_on_stack());
463     ASSERT_TRUE(elements_on_C_heap(&amp;a));
464   }
465 
466   // Stack/Arena allocated
467   {
468     Arena arena(mtTest);
469     GrowableArray&lt;int&gt; a(&amp;arena, 0, 0, 0);
470     ASSERT_TRUE(a.allocated_on_stack());
471     ASSERT_TRUE(elements_on_arena(&amp;a));
472   }
473 
474   // Embedded/Resource allocated
475   {
476     ResourceMark rm;
477     WithEmbeddedArray w(0);
478     ASSERT_TRUE(w._a.allocated_on_stack());
479     ASSERT_TRUE(elements_on_stack(&amp;w._a));
480   }
481 
482   // Embedded/CHeap allocated
483   {
484     WithEmbeddedArray w(0, mtTest);
485     ASSERT_TRUE(w._a.allocated_on_stack());
486     ASSERT_TRUE(elements_on_C_heap(&amp;w._a));
487   }
488 
489   // Embedded/Arena allocated
490   {
491     Arena arena(mtTest);
492     WithEmbeddedArray w(&amp;arena, 0);
493     ASSERT_TRUE(w._a.allocated_on_stack());
494     ASSERT_TRUE(elements_on_arena(&amp;w._a));
495   }
496 }
497 
498 TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, copy_with_embedded_cheap,
499     &quot;Copying of CHeap arrays not supported&quot;) {
500   WithEmbeddedArray s(1, mtTest);
501   // Intentionally asserts that copy of CHeap arrays are not allowed
502   WithEmbeddedArray c(s);
503 }
504 
505 TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, assignment_with_embedded_cheap,
506     &quot;Assignment of CHeap arrays not supported&quot;) {
507   WithEmbeddedArray s(1, mtTest);
508   WithEmbeddedArray c(1, mtTest);
509 
510   // Intentionally asserts that assignment of CHeap arrays are not allowed
511   c = s;
512 }
513 
514 #endif
515 
516 TEST(GrowableArrayCHeap, sanity) {
517   // Stack/CHeap
518   {
519     GrowableArrayCHeap&lt;int, mtTest&gt; a(0);
520 #ifdef ASSERT
521     ASSERT_TRUE(a.allocated_on_stack());
522 #endif
523     ASSERT_TRUE(a.is_empty());
524 
525     a.append(1);
526     ASSERT_FALSE(a.is_empty());
527     ASSERT_EQ(a.at(0), 1);
528   }
529 
530   // CHeap/CHeap
531   {
532     GrowableArrayCHeap&lt;int, mtTest&gt;* a = new GrowableArrayCHeap&lt;int, mtTest&gt;(0);
533 #ifdef ASSERT
534     ASSERT_TRUE(a-&gt;allocated_on_C_heap());
535 #endif
536     ASSERT_TRUE(a-&gt;is_empty());
537 
538     a-&gt;append(1);
539     ASSERT_FALSE(a-&gt;is_empty());
540     ASSERT_EQ(a-&gt;at(0), 1);
541     delete a;
542   }
543 
544   // CHeap/CHeap - nothrow new operator
545   {
546     GrowableArrayCHeap&lt;int, mtTest&gt;* a = new (std::nothrow) GrowableArrayCHeap&lt;int, mtTest&gt;(0);
547 #ifdef ASSERT
548     ASSERT_TRUE(a-&gt;allocated_on_C_heap());
549 #endif
550     ASSERT_TRUE(a-&gt;is_empty());
551 
552     a-&gt;append(1);
553     ASSERT_FALSE(a-&gt;is_empty());
554     ASSERT_EQ(a-&gt;at(0), 1);
555     delete a;
556   }
557 }
    </pre>
  </body>
</html>
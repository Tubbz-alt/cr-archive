<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/gtest/utilities/test_valueObjArray.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
 1 /*
 2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
 3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 4  *
 5  * This code is free software; you can redistribute it and/or modify it
 6  * under the terms of the GNU General Public License version 2 only, as
 7  * published by the Free Software Foundation.
 8  *
 9  * This code is distributed in the hope that it will be useful, but WITHOUT
10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
12  * version 2 for more details (a copy is included in the LICENSE file that
13  * accompanied this code).
14  *
15  * You should have received a copy of the GNU General Public License version
16  * 2 along with this work; if not, write to the Free Software Foundation,
17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
18  *
19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
20  * or visit www.oracle.com if you need additional information or have any
21  * questions.
22  *
23  */
24 
25 #include &quot;precompiled.hpp&quot;
26 #include &quot;utilities/valueObjArray.hpp&quot;
27 #include &quot;unittest.hpp&quot;
28 
29 class ValueObjArrayTest : public ::testing::Test {
30 protected:
31   class IntGenerator {
32     int _current;
33 
34   public:
35     IntGenerator() : _current(0) {}
36     int operator*() const {
37       return _current;
38     }
39     IntGenerator operator++() {
40       ++_current;
41       return *this;
42     }
43   };
44 
45   struct Struct {
46     int _value;
47     const char* _string;
48   };
49 
50   class StructGenerator {
51     int _current;
52 
53     static const char* str(int i) {
54       const char* array[] = {
55         &quot;0&quot;,
56         &quot;1&quot;,
57         &quot;2&quot;,
58         &quot;3&quot;};
59       return array[i];
60     }
61 
62   public:
63     StructGenerator() : _current(0) {}
64     Struct operator*() const {
65       assert(_current &lt; 4, &quot;precondition&quot;);
66       Struct s = { _current, str(_current)};
67       return s;
68     }
69     StructGenerator operator++() {
70       ++_current;
71       return *this;
72     }
73   };
74 };
75 
76 TEST_F(ValueObjArrayTest, primitive) {
77   ValueObjArrayTest::IntGenerator g;
78   ValueObjArray&lt;int, 4&gt; array(g);
79   ASSERT_EQ(array.count(), 4);
80   ASSERT_EQ(*array.at(0), 0);
81   ASSERT_EQ(*array.at(1), 1);
82   ASSERT_EQ(*array.at(2), 2);
83   ASSERT_EQ(*array.at(3), 3);
84 }
85 
86 TEST_F(ValueObjArrayTest, struct) {
87   ValueObjArrayTest::StructGenerator g;
88   ValueObjArray&lt;Struct, 4&gt; array(g);
89   ASSERT_EQ(array.count(), 4);
90   ASSERT_EQ(array.at(0)-&gt;_value, 0);
91   ASSERT_EQ(array.at(1)-&gt;_value, 1);
92   ASSERT_EQ(array.at(2)-&gt;_value, 2);
93   ASSERT_EQ(array.at(3)-&gt;_value, 3);
94   ASSERT_EQ(array.at(0)-&gt;_string[0], &#39;0&#39;);
95   ASSERT_EQ(array.at(1)-&gt;_string[0], &#39;1&#39;);
96   ASSERT_EQ(array.at(2)-&gt;_string[0], &#39;2&#39;);
97   ASSERT_EQ(array.at(3)-&gt;_string[0], &#39;3&#39;);
98 }
    </pre>
  </body>
</html>
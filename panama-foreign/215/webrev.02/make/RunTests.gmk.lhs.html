<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/RunTests.gmk</title>
    <link rel="stylesheet" href="../style.css" />
    <script type="text/javascript" src="../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 #
   2 # Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
   3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 #
   5 # This code is free software; you can redistribute it and/or modify it
   6 # under the terms of the GNU General Public License version 2 only, as
   7 # published by the Free Software Foundation.  Oracle designates this
   8 # particular file as subject to the &quot;Classpath&quot; exception as provided
   9 # by Oracle in the LICENSE file that accompanied this code.
  10 #
  11 # This code is distributed in the hope that it will be useful, but WITHOUT
  12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14 # version 2 for more details (a copy is included in the LICENSE file that
  15 # accompanied this code).
  16 #
  17 # You should have received a copy of the GNU General Public License version
  18 # 2 along with this work; if not, write to the Free Software Foundation,
  19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20 #
  21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22 # or visit www.oracle.com if you need additional information or have any
  23 # questions.
  24 #
  25 
  26 default: all
  27 
  28 include $(SPEC)
  29 include MakeBase.gmk
  30 include FindTests.gmk
  31 
  32 # We will always run multiple tests serially
  33 .NOTPARALLEL:
  34 
  35 ################################################################################
  36 # Parse global control variables
  37 ################################################################################
  38 
  39 ifneq ($(TEST_VM_OPTS), )
  40   ifneq ($(TEST_OPTS), )
  41     TEST_OPTS := $(TEST_OPTS);VM_OPTIONS=$(TEST_VM_OPTS)
  42   else
  43     TEST_OPTS := VM_OPTIONS=$(TEST_VM_OPTS)
  44   endif
  45 endif
  46 
  47 $(eval $(call ParseKeywordVariable, TEST_OPTS, \
  48     SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR JCOV JCOV_DIFF_CHANGESET, \
  49     STRING_KEYWORDS := VM_OPTIONS JAVA_OPTIONS AOT_MODULES, \
  50 ))
  51 
  52 # Helper function to propagate TEST_OPTS values.
  53 #
  54 # Note: No spaces are allowed around the arguments.
  55 # Arg $1 The variable in TEST_OPTS to propagate
  56 # Arg $2 The control variable to propagate it to
  57 define SetTestOpt
  58   ifneq ($$(TEST_OPTS_$1), )
  59     $2_$1 := $$(TEST_OPTS_$1)
  60   endif
  61 endef
  62 
  63 # Setup _NT_SYMBOL_PATH on Windows
  64 ifeq ($(call isTargetOs, windows), true)
  65   ifndef _NT_SYMBOL_PATH
  66     # Can&#39;t use PathList here as it adds quotes around the value.
  67     _NT_SYMBOL_PATH := \
  68         $(subst $(SPACE),;,$(strip \
  69             $(foreach p, $(sort $(dir $(wildcard \
  70                 $(addprefix $(SYMBOLS_IMAGE_DIR)/bin/, *.pdb */*.pdb)))), \
  71               $(call FixPath, $p) \
  72             ) \
  73         ))
  74     export _NT_SYMBOL_PATH
  75     $(call LogDebug, Rewriting _NT_SYMBOL_PATH to $(_NT_SYMBOL_PATH))
  76   endif
  77 endif
  78 
  79 ################################################################################
  80 # Hook to include the corresponding custom file, if present.
  81 $(eval $(call IncludeCustomExtension, RunTests.gmk))
  82 ################################################################################
  83 
  84 # This is the JDK that we will test
  85 JDK_UNDER_TEST := $(JDK_IMAGE_DIR)
  86 
  87 TEST_RESULTS_DIR := $(OUTPUTDIR)/test-results
  88 TEST_SUPPORT_DIR := $(OUTPUTDIR)/test-support
  89 TEST_SUMMARY := $(TEST_RESULTS_DIR)/test-summary.txt
  90 TEST_LAST_IDS := $(TEST_SUPPORT_DIR)/test-last-ids.txt
  91 
  92 ifeq ($(CUSTOM_ROOT), )
  93   JTREG_TOPDIR := $(TOPDIR)
  94 else
  95   JTREG_TOPDIR := $(CUSTOM_ROOT)
  96 endif
  97 
  98 JTREG_FAILURE_HANDLER_DIR := $(TEST_IMAGE_DIR)/failure_handler
  99 JTREG_FAILURE_HANDLER := $(JTREG_FAILURE_HANDLER_DIR)/jtregFailureHandler.jar
 100 
 101 JTREG_FAILURE_HANDLER_TIMEOUT ?= 0
 102 
 103 ifneq ($(wildcard $(JTREG_FAILURE_HANDLER)), )
 104   JTREG_FAILURE_HANDLER_OPTIONS := \
 105       -timeoutHandlerDir:$(JTREG_FAILURE_HANDLER) \
 106       -observerDir:$(JTREG_FAILURE_HANDLER) \
 107       -timeoutHandler:jdk.test.failurehandler.jtreg.GatherProcessInfoTimeoutHandler \
 108       -observer:jdk.test.failurehandler.jtreg.GatherDiagnosticInfoObserver \
 109       -timeoutHandlerTimeout:$(JTREG_FAILURE_HANDLER_TIMEOUT)
 110 endif
 111 
 112 GTEST_LAUNCHER_DIRS := $(patsubst %/gtestLauncher, %, \
 113     $(wildcard $(TEST_IMAGE_DIR)/hotspot/gtest/*/gtestLauncher))
 114 GTEST_VARIANTS := $(strip $(patsubst $(TEST_IMAGE_DIR)/hotspot/gtest/%, %, \
 115     $(GTEST_LAUNCHER_DIRS)))
 116 
 117 COV_ENVIRONMENT :=
 118 JTREG_COV_OPTIONS :=
 119 
 120 ifeq ($(TEST_OPTS_JCOV), true)
 121   JCOV_OUTPUT_DIR := $(TEST_RESULTS_DIR)/jcov-output
 122   JCOV_GRABBER_LOG := $(JCOV_OUTPUT_DIR)/grabber.log
 123   JCOV_RESULT_FILE := $(JCOV_OUTPUT_DIR)/result.xml
 124   JCOV_REPORT := $(JCOV_OUTPUT_DIR)/report
 125   JCOV_MEM_OPTIONS := -Xms64m -Xmx4g
 126 
 127   # Replace our normal test JDK with the JCov image.
 128   JDK_UNDER_TEST := $(JCOV_IMAGE_DIR)
 129 
 130   COV_ENVIRONMENT += JAVA_TOOL_OPTIONS=&quot;$(JCOV_MEM_OPTIONS)&quot; \
 131       _JAVA_OPTIONS=&quot;$(JCOV_MEM_OPTIONS)&quot;
 132   JTREG_COV_OPTIONS += -e:JAVA_TOOL_OPTIONS=&#39;$(JCOV_MEM_OPTIONS)&#39; \
 133       -e:_JAVA_OPTIONS=&#39;$(JCOV_MEM_OPTIONS)&#39;
 134 endif
 135 
 136 ifeq ($(GCOV_ENABLED), true)
 137   GCOV_OUTPUT_DIR := $(TEST_RESULTS_DIR)/gcov-output
 138   COV_ENVIRONMENT += GCOV_PREFIX=&quot;$(GCOV_OUTPUT_DIR)&quot;
 139   JTREG_COV_OPTIONS += -e:GCOV_PREFIX=&quot;$(GCOV_OUTPUT_DIR)&quot;
 140 endif
 141 
 142 ################################################################################
 143 # Optionally create AOT libraries for specified modules before running tests.
 144 # Note, this could not be done during JDK build time.
 145 ################################################################################
<a name="1" id="anc1"></a><span class="line-removed"> 146 </span>
<span class="line-removed"> 147 # Note, this could not be done during JDK build time.</span>
<span class="line-removed"> 148 </span>
 149 # Parameter 1 is the name of the rule.
 150 #
 151 # Remaining parameters are named arguments.
 152 #   MODULE      The module to generate a library for
 153 #   BIN         Output directory in which to put the library
 154 #   VM_OPTIONS  List of JVM arguments to use when creating library
 155 #   OPTIONS_VAR Name of variable to put AOT java options in
 156 #   PREREQS_VAR Name of variable to put all AOT prerequisite rule targets in
 157 #               for test rules to depend on
 158 #
 159 SetupAotModule = $(NamedParamsMacroTemplate)
 160 define SetupAotModuleBody
 161   $1_AOT_LIB := $$($1_BIN)/$$(call SHARED_LIBRARY,$$($1_MODULE))
 162   $1_AOT_CCLIST := $$(wildcard $$(TOPDIR)/test/hotspot/jtreg/compiler/aot/scripts/$$($1_MODULE)-list.txt)
 163 
 164   # Create jaotc flags.
 165   # VM flags which don&#39;t affect AOT code generation are filtered out:
 166   # -Xcomp, -XX:+-TieredCompilation
 167   $1_JAOTC_OPTS := \
 168       -J-Xmx4g --info \
 169       $$(addprefix -J, $$(filter-out -Xcomp %TieredCompilation, $$($1_VM_OPTIONS))) \
 170       $$(addprefix --compile-commands$(SPACE), $$($1_AOT_CCLIST)) \
 171       --linker-path $$(LD_JAOTC) \
 172       #
 173 
 174   ifneq ($$(filter -ea, $$($1_VM_OPTIONS)), )
 175     $1_JAOTC_OPTS += --compile-with-assertions
 176   endif
 177 
 178   $$($1_AOT_LIB): $$(JDK_UNDER_TEST)/release \
 179       $$(call DependOnVariable, $1_JAOTC_OPTS) \
 180       $$(call DependOnVariable, JDK_UNDER_TEST)
 181 	$$(call LogWarn, Generating $$(patsubst $$(OUTPUTDIR)/%, %, $$@))
 182 	$$(call MakeTargetDir)
 183 	$$(call ExecuteWithLog, $$@, \
 184 	    $((COV_ENVIRONMENT) \
 185 	    $$(FIXPATH) $$(JDK_UNDER_TEST)/bin/jaotc \
 186 	        $$($1_JAOTC_OPTS) --output $$@ --module $$($1_MODULE) \
 187 	)
 188 	$$(call ExecuteWithLog, $$@.check, ( \
 189 	    $$(FIXPATH) $$(JDK_UNDER_TEST)/bin/java \
 190 	        $$($1_VM_OPTIONS) -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions \
 191 	        -XX:+PrintAOT -XX:+UseAOTStrictLoading \
 192 	        -XX:AOTLibrary=$$@ -version \
 193 	         &gt; $$@.verify-aot \
 194 	))
 195 
 196   $1_AOT_OPTIONS += -XX:+UnlockExperimentalVMOptions
 197   $1_AOT_OPTIONS += -XX:AOTLibrary=$$($1_AOT_LIB)
 198   $1_AOT_TARGETS += $$($1_AOT_LIB)
 199 endef
 200 
<a name="2" id="anc2"></a>



 201 # Parameter 1 is the name of the rule.
 202 #
 203 # Remaining parameters are named arguments.
 204 #   MODULES     The modules to generate a library for
 205 #   VM_OPTIONS  List of JVM arguments to use when creating libraries
 206 #
 207 # After calling this, the following variables are defined
 208 #   $1_AOT_OPTIONS List of all java options needed to use the AOT libraries
 209 #   $1_AOT_TARGETS List of all targets that the test rule will need to depend on
 210 #
 211 SetupAot = $(NamedParamsMacroTemplate)
 212 define SetupAotBody
 213   $$(info Running with AOTd libraries for $$($1_MODULES))
 214   # Put aot libraries in a separate directory so they are not deleted between
 215   # test runs and may be reused between make invocations.
 216   $$(foreach m, $$($1_MODULES), \
 217     $$(eval $$(call SetupAotModule, $1_$$m, \
 218         MODULE := $$m, \
 219         BIN := $$(TEST_SUPPORT_DIR)/aot/$1, \
 220         VM_OPTIONS := $$($1_VM_OPTIONS), \
 221     )) \
 222     $$(eval $1_AOT_OPTIONS += $$($1_$$m_AOT_OPTIONS)) \
 223     $$(eval $1_AOT_TARGETS += $$($1_$$m_AOT_TARGETS)) \
 224   )
 225 endef
 226 
 227 ################################################################################
 228 # Setup global test running parameters
 229 ################################################################################
 230 
 231 # Each factor variable comes in 3 variants. The first one is reserved for users
 232 # to use on command line. The other two are for predifined configurations in JDL
 233 # and for machine specific configurations respectively.
 234 TEST_JOBS_FACTOR ?= 1
 235 TEST_JOBS_FACTOR_JDL ?= 1
 236 TEST_JOBS_FACTOR_MACHINE ?= 1
 237 
 238 ifeq ($(TEST_JOBS), 0)
 239   CORES_DIVIDER := 2
 240   # For some big multi-core machines with low ulimit -u setting we hit the max
 241   # threads/process limit. In such a setup the memory/cores-only-guided
 242   # TEST_JOBS config is insufficient. From experience a concurrency setting of
 243   # 14 works reasonably well for low ulimit values (&lt;= 4096). Thus, use
 244   # divider 4096/14. For high ulimit -u values this shouldn&#39;t make a difference.
 245   ULIMIT_DIVIDER := (4096/14)
 246   PROC_ULIMIT := -1
 247   ifneq ($(OPENJDK_TARGET_OS), windows)
 248     PROC_ULIMIT := $(shell $(ULIMIT) -u)
 249     ifeq ($(PROC_ULIMIT), unlimited)
 250       PROC_ULIMIT := -1
 251     endif
 252   endif
 253   MEMORY_DIVIDER := 2048
 254   TEST_JOBS := $(shell $(AWK) \
 255     &#39;BEGIN { \
 256       c = $(NUM_CORES) / $(CORES_DIVIDER); \
 257       m = $(MEMORY_SIZE) / $(MEMORY_DIVIDER); \
 258       u = $(PROC_ULIMIT); \
 259       if (u &gt; -1) { \
 260         u = u / $(ULIMIT_DIVIDER); \
 261         if (u &lt; c) c = u; \
 262       } \
 263       if (c &gt; m) c = m; \
 264       c = c * $(TEST_JOBS_FACTOR); \
 265       c = c * $(TEST_JOBS_FACTOR_JDL); \
 266       c = c * $(TEST_JOBS_FACTOR_MACHINE); \
 267       if (c &lt; 1) c = 1; \
 268       printf &quot;%.0f&quot;, c; \
 269     }&#39;)
 270 endif
 271 
 272 ################################################################################
 273 # Parse control variables
 274 ################################################################################
 275 
 276 ifneq ($(TEST_OPTS), )
 277   # Inform the user
 278   $(info Running tests using TEST_OPTS control variable &#39;$(TEST_OPTS)&#39;)
 279 endif
 280 
 281 ### Jtreg
 282 
 283 $(eval $(call SetTestOpt,VM_OPTIONS,JTREG))
 284 $(eval $(call SetTestOpt,JAVA_OPTIONS,JTREG))
 285 $(eval $(call SetTestOpt,AOT_MODULES,JTREG))
 286 
 287 $(eval $(call SetTestOpt,JOBS,JTREG))
 288 $(eval $(call SetTestOpt,TIMEOUT_FACTOR,JTREG))
 289 $(eval $(call SetTestOpt,FAILURE_HANDLER_TIMEOUT,JTREG))
 290 
 291 $(eval $(call ParseKeywordVariable, JTREG, \
 292     SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR FAILURE_HANDLER_TIMEOUT \
 293         TEST_MODE ASSERT VERBOSE RETAIN MAX_MEM RUN_PROBLEM_LISTS \
<a name="3" id="anc3"></a><span class="line-modified"> 294         RETRY_COUNT, \</span>
 295     STRING_KEYWORDS := OPTIONS JAVA_OPTIONS VM_OPTIONS KEYWORDS \
<a name="4" id="anc4"></a><span class="line-modified"> 296         EXTRA_PROBLEM_LISTS AOT_MODULES, \</span>
 297 ))
 298 
 299 ifneq ($(JTREG), )
 300   # Inform the user
 301   $(info Running tests using JTREG control variable &#39;$(JTREG)&#39;)
 302 endif
 303 
 304 ### Gtest
 305 
 306 $(eval $(call SetTestOpt,VM_OPTIONS,GTEST))
 307 $(eval $(call SetTestOpt,JAVA_OPTIONS,GTEST))
 308 $(eval $(call SetTestOpt,AOT_MODULES,GTEST))
 309 
 310 $(eval $(call ParseKeywordVariable, GTEST, \
 311     SINGLE_KEYWORDS := REPEAT, \
 312     STRING_KEYWORDS := OPTIONS VM_OPTIONS JAVA_OPTIONS AOT_MODULES, \
 313 ))
 314 
 315 ifneq ($(GTEST), )
 316   # Inform the user
 317   $(info Running tests using GTEST control variable &#39;$(GTEST)&#39;)
 318 endif
 319 
 320 ### Microbenchmarks
 321 
 322 $(eval $(call SetTestOpt,VM_OPTIONS,MICRO))
 323 $(eval $(call SetTestOpt,JAVA_OPTIONS,MICRO))
 324 
 325 $(eval $(call ParseKeywordVariable, MICRO, \
 326     SINGLE_KEYWORDS := ITER FORK TIME WARMUP_ITER WARMUP_TIME, \
 327     STRING_KEYWORDS := OPTIONS JAVA_OPTIONS VM_OPTIONS RESULTS_FORMAT TEST_JDK \
 328         BENCHMARKS_JAR, \
 329 ))
 330 
 331 ifneq ($(MICRO), )
 332   # Inform the user
 333   $(info Running tests using MICRO control variable &#39;$(MICRO)&#39;)
 334 endif
 335 
 336 
 337 ################################################################################
 338 # Component-specific Jtreg settings
 339 ################################################################################
 340 
 341 hotspot_JTREG_MAX_MEM := 0
 342 hotspot_JTREG_ASSERT := false
 343 hotspot_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/hotspot/jtreg/native
 344 jdk_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/jdk/jtreg/native
 345 lib-test_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)/lib-test/jtreg/native
 346 
 347 jdk_JTREG_PROBLEM_LIST += $(TOPDIR)/test/jdk/ProblemList.txt
 348 jaxp_JTREG_PROBLEM_LIST += $(TOPDIR)/test/jaxp/ProblemList.txt
 349 langtools_JTREG_PROBLEM_LIST += $(TOPDIR)/test/langtools/ProblemList.txt
 350 hotspot_JTREG_PROBLEM_LIST += $(TOPDIR)/test/hotspot/jtreg/ProblemList.txt
 351 lib-test_JTREG_PROBLEM_LIST += $(TOPDIR)/test/lib-test/ProblemList.txt
 352 
 353 langtools_JTREG_MAX_MEM := 768m
 354 
 355 ################################################################################
 356 # Parse test selection
 357 #
 358 # The user has given a test selection in the TEST variable. We must parse it
 359 # and determine what that means in terms of actual calls to the test framework.
 360 #
 361 # The parse functions take as argument a test specification as given by the
 362 # user, and returns a fully qualified test descriptor if it was a match, or
 363 # nothing if not. A single test specification can result in multiple test
 364 # descriptors being returned. A valid test descriptor must always be accepted
 365 # and returned identically.
 366 ################################################################################
 367 
 368 # Helper function to determine if a test specification is a Gtest test
 369 #
 370 # It is a Gtest test if it is either &quot;gtest&quot;, or &quot;gtest:&quot; followed by an optional
 371 # test filter string, and an optional &quot;/&lt;variant&gt;&quot; to select a specific JVM
 372 # variant. If no variant is specified, all found variants are tested.
 373 define ParseGtestTestSelection
 374   $(if $(filter gtest%, $1), \
 375     $(if $(filter gtest, $1), \
 376       $(addprefix gtest:all/, $(GTEST_VARIANTS)) \
 377     , \
 378       $(if $(strip $(or $(filter gtest/%, $1) $(filter gtest:/%, $1))), \
 379         $(patsubst gtest:/%, gtest:all/%, $(patsubst gtest/%, gtest:/%, $1)) \
 380       , \
 381         $(if $(filter gtest:%, $1), \
 382           $(if $(findstring /, $1), \
 383             $1 \
 384           , \
 385             $(addprefix $1/, $(GTEST_VARIANTS)) \
 386           ) \
 387         ) \
 388       ) \
 389     ) \
 390   )
 391 endef
 392 
 393 # Helper function to determine if a test specification is a microbenchmark test
 394 #
 395 # It is a microbenchmark test if it is either &quot;micro&quot;, or &quot;micro:&quot; followed by
 396 # an optional test filter string.
 397 define ParseMicroTestSelection
 398   $(if $(filter micro%, $1), \
 399     $(if $(filter micro, $1), \
 400       micro:all \
 401     , \
 402       $(if $(filter micro:, $1), \
 403         micro:all \
 404       , \
 405         $1 \
 406       ) \
 407     ) \
 408   )
 409 endef
 410 
 411 # Helper function that removes the TOPDIR part
 412 CleanupJtregPath = \
 413   $(strip $(patsubst %/, %, $(subst $(JTREG_TOPDIR)/,, $1)))
 414 
 415 # Take a partial Jtreg root path and return a full, absolute path to that Jtreg
 416 # root. Also support having &quot;hotspot&quot; as an alias for &quot;hotspot/jtreg&quot;.
 417 ExpandJtregRoot = \
 418   $(call CleanupJtregPath, $(wildcard \
 419     $(if $(filter /%, $1), \
 420       $(if $(wildcard $(strip $1)/TEST.ROOT), \
 421         $1 \
 422       ) \
 423     , \
 424       $(filter $(addprefix %, $1), $(JTREG_TESTROOTS) $(addsuffix /, $(JTREG_TESTROOTS))) \
 425       $(filter $(addprefix %, $(strip $1)/jtreg), $(JTREG_TESTROOTS) $(addsuffix /, $(JTREG_TESTROOTS))) \
 426     ) \
 427   ))
 428 
 429 # Take a partial Jtreg test path and return a full, absolute path to that Jtreg
 430 # test. Also support having &quot;hotspot&quot; as an alias for &quot;hotspot/jtreg&quot;.
 431 ExpandJtregPath = \
 432   $(if $(call ExpandJtregRoot, $1), \
 433     $(call ExpandJtregRoot, $1) \
 434   , \
 435     $(call CleanupJtregPath, $(wildcard \
 436       $(if $(filter /%, $1), \
 437         $1 \
 438       , \
 439         $(addsuffix /$(strip $1), $(JTREG_TESTROOTS) $(TEST_BASEDIRS)) \
 440         $(addsuffix $(strip $(patsubst hotspot/%, /hotspot/jtreg/%, $1)), $(JTREG_TESTROOTS) $(TEST_BASEDIRS)) \
 441       ) \
 442     )) \
 443   )
 444 
 445 # Helper function to determine if a test specification is a Jtreg test
 446 #
 447 # It is a Jtreg test if it optionally begins with jtreg:, and then is either
 448 # an unspecified group name (possibly prefixed by :), or a group in a
 449 # specified test root, or a path to a test or test directory,
 450 # either absolute or relative to any of the TEST_BASEDIRS or test roots.
 451 define ParseJtregTestSelection
 452   $(eval TEST_NAME := $(strip $(patsubst jtreg:%, %, $1))) \
 453   $(if $(or $(findstring :, $(TEST_NAME)), $(findstring /, $(TEST_NAME))), , \
 454     $(eval TEST_NAME := :$(TEST_NAME)) \
 455   ) \
 456   $(if $(findstring :, $(TEST_NAME)), \
 457     $(if $(filter :%, $(TEST_NAME)), \
 458       $(eval TEST_GROUP := $(patsubst :%, %, $(TEST_NAME))) \
 459       $(eval TEST_ROOTS := $(foreach test_root, $(JTREG_TESTROOTS), \
 460           $(call CleanupJtregPath, $(test_root)))) \
 461     , \
 462       $(eval TEST_PATH := $(word 1, $(subst :, $(SPACE), $(TEST_NAME)))) \
 463       $(eval TEST_GROUP := $(word 2, $(subst :, $(SPACE), $(TEST_NAME)))) \
 464       $(eval TEST_ROOTS := $(call ExpandJtregRoot, $(TEST_PATH))) \
 465     ) \
 466     $(foreach test_root, $(TEST_ROOTS), \
 467       $(if $(filter /%, $(test_root)), \
 468         jtreg:$(test_root):$(TEST_GROUP) \
 469       , \
 470         $(if $(filter $(TEST_GROUP), $($(JTREG_TOPDIR)/$(test_root)_JTREG_TEST_GROUPS)), \
 471           jtreg:$(test_root):$(TEST_GROUP) \
 472         ) \
 473       ) \
 474     ) \
 475   , \
 476     $(eval TEST_PATHS := $(call ExpandJtregPath, $(TEST_NAME))) \
 477     $(foreach test_path, $(TEST_PATHS), \
 478       jtreg:$(test_path) \
 479     ) \
 480   )
 481 endef
 482 
 483 # Helper function to determine if a test specification is a special test
 484 #
 485 # It is a special test if it is &quot;special:&quot; followed by a test name,
 486 # if it is &quot;make:&quot; or &quot;make-&quot; followed by a make test, or any of the special
 487 # test names as a single word.
 488 define ParseSpecialTestSelection
 489   $(if $(filter special:%, $1), \
 490     $1 \
 491   ) \
 492   $(if $(filter make%, $1), \
 493     $(if $(filter make:%, $1), \
 494       special:$(strip $1) \
 495     ) \
 496     $(if $(filter make-%, $1), \
 497       special:$(patsubst make-%,make:%, $1) \
 498     ) \
 499     $(if $(filter make, $1), \
 500       special:make:all \
 501     )
 502   ) \
 503   $(if $(filter failure-handler, $1), \
 504     special:$(strip $1) \
 505   )
 506 endef
 507 
 508 ifeq ($(TEST), )
 509   $(info No test selection given in TEST!)
 510   $(info Please use e.g. &#39;make test TEST=tier1&#39; or &#39;make test-tier1&#39;)
 511   $(info See doc/testing.[md|html] for help)
 512   $(error Cannot continue)
 513 endif
 514 
 515 # Now intelligently convert the test selection given by the user in TEST
 516 # into a list of fully qualified test descriptors of the tests to run.
 517 TESTS_TO_RUN :=
 518 $(foreach test, $(TEST), \
 519   $(eval PARSED_TESTS := $(call ParseCustomTestSelection, $(test))) \
 520   $(if $(strip $(PARSED_TESTS)), , \
 521     $(eval PARSED_TESTS += $(call ParseGtestTestSelection, $(test))) \
 522   ) \
 523   $(if $(strip $(PARSED_TESTS)), , \
 524     $(eval PARSED_TESTS += $(call ParseMicroTestSelection, $(test))) \
 525   ) \
 526   $(if $(strip $(PARSED_TESTS)), , \
 527     $(eval PARSED_TESTS += $(call ParseJtregTestSelection, $(test))) \
 528   ) \
 529   $(if $(strip $(PARSED_TESTS)), , \
 530     $(eval PARSED_TESTS += $(call ParseSpecialTestSelection, $(test))) \
 531   ) \
 532   $(if $(strip $(PARSED_TESTS)), , \
 533     $(eval UNKNOWN_TEST := $(test)) \
 534   ) \
 535   $(eval TESTS_TO_RUN += $(PARSED_TESTS)) \
 536 )
 537 
 538 ifneq ($(UNKNOWN_TEST), )
 539   $(info Unknown test selection: &#39;$(UNKNOWN_TEST)&#39;)
 540   $(info See doc/testing.[md|html] for help)
 541   $(error Cannot continue)
 542 endif
 543 
 544 TESTS_TO_RUN := $(strip $(TESTS_TO_RUN))
 545 
 546 
 547 # Present the result of our parsing to the user
 548 $(info Test selection &#39;$(TEST)&#39;, will run:)
 549 $(foreach test, $(TESTS_TO_RUN), $(info * $(test)))
 550 
 551 
 552 ################################################################################
 553 # Functions for setting up rules for running the selected tests
 554 #
 555 # The SetupRun*Test functions all have the same interface:
 556 #
 557 # Parameter 1 is the name of the rule. This is the test id, based on the test
 558 # descriptor, and this is also used as variable prefix, and the targets
 559 # generated are listed in a variable by that name.
 560 #
 561 # Remaining parameters are named arguments. Currently this is only:
 562 #   TEST -- The properly formatted fully qualified test descriptor
 563 #
 564 # After the rule named by the test id has been executed, the following
 565 # variables will be available:
 566 # testid_TOTAL - the total number of tests run
 567 # testid_PASSED - the number of successful tests
 568 # testid_FAILED - the number of failed tests
 569 # testid_ERROR - the number of tests was neither successful or failed
 570 #
 571 ################################################################################
 572 
 573 ### Rules for Gtest
 574 
 575 SetupRunGtestTest = $(NamedParamsMacroTemplate)
 576 define SetupRunGtestTestBody
 577   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
 578   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
 579   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
 580 
 581   $1_VARIANT :=  $$(lastword $$(subst /, , $$($1_TEST)))
 582   ifeq ($$(filter $$($1_VARIANT), $$(GTEST_VARIANTS)), )
 583     $$(error Invalid gtest variant &#39;$$($1_VARIANT)&#39;. Valid variants: $$(GTEST_VARIANTS))
 584   endif
 585   $1_TEST_NAME := $$(strip $$(patsubst %/$$($1_VARIANT), %, \
 586       $$(patsubst gtest:%, %, $$($1_TEST))))
 587   ifneq ($$($1_TEST_NAME), all)
 588     $1_GTEST_FILTER := --gtest_filter=$$($1_TEST_NAME)*
 589   endif
 590 
 591   ifneq ($$(GTEST_REPEAT), )
 592     $1_GTEST_REPEAT :=--gtest_repeat=$$(GTEST_REPEAT)
 593   endif
 594 
 595   ifneq ($$(GTEST_AOT_MODULES), )
 596     $$(eval $$(call SetupAot, $1, \
 597         MODULES := $$(GTEST_AOT_MODULES), \
 598         VM_OPTIONS := $$(GTEST_VM_OPTIONS) $$(GTEST_JAVA_OPTIONS), \
 599     ))
 600   endif
 601 
 602   run-test-$1: pre-run-test $$($1_AOT_TARGETS)
 603 	$$(call LogWarn)
 604 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
 605 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))
 606 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/gtest, ( \
 607 	    $$(FIXPATH) $$(TEST_IMAGE_DIR)/hotspot/gtest/$$($1_VARIANT)/gtestLauncher \
 608 	        -jdk $(JDK_UNDER_TEST) $$($1_GTEST_FILTER) \
 609 	        --gtest_output=xml:$$($1_TEST_RESULTS_DIR)/gtest.xml \
 610 	        $$($1_GTEST_REPEAT) $$(GTEST_OPTIONS) $$(GTEST_VM_OPTIONS) \
 611 	        $$(GTEST_JAVA_OPTIONS) $$($1_AOT_OPTIONS) \
 612 	        &gt; &gt;($(TEE) $$($1_TEST_RESULTS_DIR)/gtest.txt) \
 613 	    &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
 614 	    || $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
 615 	))
 616 
 617   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/gtest.txt
 618 
 619   parse-test-$1: run-test-$1
 620 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
 621 	$$(call LogWarn, Test report is stored in $$(strip \
 622 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
 623 	$$(if $$(wildcard $$($1_RESULT_FILE)), \
 624 	  $$(eval $1_TOTAL := $$(shell $$(AWK) &#39;/==========.* tests? from .* \
 625 	      test cases? ran/ { print $$$$2 }&#39; $$($1_RESULT_FILE))) \
 626 	  $$(if $$($1_TOTAL), , $$(eval $1_TOTAL := 0)) \
 627 	  $$(eval $1_PASSED := $$(shell $$(AWK) &#39;/\[  PASSED  \] .* tests?./ \
 628 	      { print $$$$4 }&#39; $$($1_RESULT_FILE))) \
 629 	  $$(if $$($1_PASSED), , $$(eval $1_PASSED := 0)) \
 630 	  $$(eval $1_FAILED := $$(shell $$(AWK) &#39;/\[  FAILED  \] .* tests?, \
 631 	      listed below/ { print $$$$4 }&#39; $$($1_RESULT_FILE))) \
 632 	  $$(if $$($1_FAILED), , $$(eval $1_FAILED := 0)) \
 633 	  $$(eval $1_ERROR := $$(shell \
 634 	      $$(EXPR) $$($1_TOTAL) - $$($1_PASSED) - $$($1_FAILED))) \
 635 	, \
 636 	  $$(eval $1_PASSED := 0) \
 637 	  $$(eval $1_FAILED := 0) \
 638 	  $$(eval $1_ERROR := 1) \
 639 	  $$(eval $1_TOTAL := 1) \
 640 	)
 641 
 642   $1: run-test-$1 parse-test-$1
 643 
 644   TARGETS += $1 run-test-$1 parse-test-$1
 645   TEST_TARGETS += parse-test-$1
 646 
 647 endef
 648 
 649 ################################################################################
 650 
 651 ### Rules for Microbenchmarks
 652 
 653 # Helper function for SetupRunMicroTest. Set a MICRO_* variable from, in order:
 654 # 1) Specified by user on command line
 655 # 2) Generic default
 656 #
 657 # Note: No spaces are allowed around the arguments.
 658 # Arg $1 The test ID (i.e. $1 in SetupRunMicroTest)
 659 # Arg $2 Base variable, e.g. MICRO_TEST_JDK
 660 # Arg $3 The default value (optional)
 661 define SetMicroValue
 662   ifneq ($$($2), )
 663     $1_$2 := $$($2)
 664   else
 665     ifneq ($3, )
 666       $1_$2 := $3
 667     endif
 668   endif
 669 endef
 670 
 671 SetupRunMicroTest = $(NamedParamsMacroTemplate)
 672 define SetupRunMicroTestBody
 673   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
 674   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
 675   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
 676 
 677   $1_TEST_NAME := $$(strip $$(patsubst micro:%, %, $$($1_TEST)))
 678 
 679   $$(eval $$(call SetMicroValue,$1,MICRO_BENCHMARKS_JAR,$$(TEST_IMAGE_DIR)/micro/benchmarks.jar))
 680   $$(eval $$(call SetMicroValue,$1,MICRO_TEST_JDK,$$(JDK_UNDER_TEST)))
 681   $$(eval $$(call SetMicroValue,$1,MICRO_JAVA_OPTIONS))
 682 
 683   # Current tests needs to open java.io
 684   $1_MICRO_JAVA_OPTIONS += --add-opens=java.base/java.io=ALL-UNNAMED
 685 
 686   # Save output as JSON or CSV file
 687   ifneq ($$(MICRO_RESULTS_FORMAT), )
 688     $1_MICRO_BASIC_OPTIONS += -rf $$(MICRO_RESULTS_FORMAT)
 689     $1_MICRO_BASIC_OPTIONS += -rff $$($1_TEST_RESULTS_DIR)/jmh-result.$(MICRO_RESULTS_FORMAT)
 690   endif
 691 
 692   # Set library path for native dependencies
 693   $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)/micro/native
 694 
 695   ifneq ($$(MICRO_VM_OPTIONS)$$(MICRO_JAVA_OPTIONS), )
 696     $1_JMH_JVM_ARGS += $$(MICRO_VM_OPTIONS) $$(MICRO_JAVA_OPTIONS)
 697   endif
 698 
 699   $1_MICRO_VM_OPTIONS := -jvmArgs $(call ShellQuote,$$($1_JMH_JVM_ARGS))
 700 
 701   ifneq ($$(MICRO_ITER), )
 702     $1_MICRO_ITER := -i $$(MICRO_ITER)
 703   endif
 704   ifneq ($$(MICRO_FORK), )
 705     $1_MICRO_FORK := -f $$(MICRO_FORK)
 706   endif
 707   ifneq ($$(MICRO_TIME), )
 708     $1_MICRO_TIME := -r $$(MICRO_TIME)
 709   endif
 710   ifneq ($$(MICRO_WARMUP_ITER), )
 711     $1_MICRO_WARMUP_ITER := -wi $$(MICRO_WARMUP_ITER)
 712   endif
 713   ifneq ($$(MICRO_WARMUP_TIME), )
 714     $1_MICRO_WARMUP_TIME := -w $$(MICRO_WARMUP_TIME)
 715   endif
 716 
 717   run-test-$1: pre-run-test
 718 	$$(call LogWarn)
 719 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
 720 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))
 721 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/micro, ( \
 722 	    $$(FIXPATH) $$($1_MICRO_TEST_JDK)/bin/java $$($1_MICRO_JAVA_OPTIONS) \
 723 	        -jar $$($1_MICRO_BENCHMARKS_JAR) \
 724 	        $$($1_MICRO_ITER) $$($1_MICRO_FORK) $$($1_MICRO_TIME) \
 725 	        $$($1_MICRO_WARMUP_ITER) $$($1_MICRO_WARMUP_TIME) \
 726 	        $$($1_MICRO_VM_OPTIONS) $$($1_MICRO_BASIC_OPTIONS) $$(MICRO_OPTIONS) \
 727 	        $$($1_TEST_NAME) \
 728 	        &gt; &gt;($(TEE) $$($1_TEST_RESULTS_DIR)/micro.txt) \
 729 	    &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
 730 	    || $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
 731 	))
 732 
 733   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/micro.txt
 734 
 735   parse-test-$1: run-test-$1
 736 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
 737 	$$(call LogWarn, Test report is stored in $$(strip \
 738 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
 739 	$$(if $$(wildcard $$($1_EXITCODE)), \
 740 	  $$(eval $1_EXIT_CODE := $$(shell $$(CAT) $$($1_EXITCODE))) \
 741 	  $$(if $$(filter 0, $$($1_EXIT_CODE)), \
 742 	    $$(eval $1_PASSED := 1) \
 743 	    $$(eval $1_ERROR := 0) \
 744 	  , \
 745 	    $$(eval $1_PASSED := 0) \
 746 	    $$(eval $1_ERROR := 1) \
 747 	  ) \
 748 	  $$(eval $1_FAILED := 0) \
 749 	  $$(eval $1_TOTAL := $$(shell \
 750 	      $$(EXPR) $$($1_PASSED) + $$($1_ERROR))) \
 751 	, \
 752 	  $$(eval $1_PASSED := 0) \
 753 	  $$(eval $1_FAILED := 0) \
 754 	  $$(eval $1_ERROR := 1) \
 755 	  $$(eval $1_TOTAL := 1) \
 756 	)
 757 
 758   $1: run-test-$1 parse-test-$1
 759 
 760   TARGETS += $1 run-test-$1 parse-test-$1
 761   TEST_TARGETS += parse-test-$1
 762 
 763 endef
 764 
 765 ################################################################################
 766 
 767 ### Rules for Jtreg
 768 
 769 # Helper function for SetupRunJtregTest. Set a JTREG_* variable from, in order:
 770 # 1) Specified by user on command line
 771 # 2) Component-specific default
 772 # 3) Generic default
 773 #
 774 # Note: No spaces are allowed around the arguments.
 775 # Arg $1 The test ID (i.e. $1 in SetupRunJtregTest)
 776 # Arg $2 Base variable, e.g. JTREG_JOBS
 777 # Arg $3 The default value (optional)
 778 define SetJtregValue
 779   ifneq ($$($2), )
 780     $1_$2 := $$($2)
 781   else
 782     ifneq ($$($$($1_COMPONENT)_$2), )
 783       $1_$2 := $$($$($1_COMPONENT)_$2)
 784     else
 785       ifneq ($3, )
 786         $1_$2 := $3
 787       endif
 788     endif
 789   endif
 790 endef
 791 
 792 SetupRunJtregTest = $(NamedParamsMacroTemplate)
 793 define SetupRunJtregTestBody
 794   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
 795   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
 796   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
 797 
 798   $1_TEST_NAME := $$(strip $$(patsubst jtreg:%, %, $$($1_TEST)))
 799 
 800   $1_TEST_ROOT := \
 801       $$(strip $$(foreach root, $$(JTREG_TESTROOTS), \
 802         $$(if $$(filter $$(root)%, $$(JTREG_TOPDIR)/$$($1_TEST_NAME)), $$(root)) \
 803       ))
 804   $1_COMPONENT := $$(lastword $$(subst /, $$(SPACE), $$($1_TEST_ROOT)))
 805   # This will work only as long as just hotspot has the additional &quot;jtreg&quot; directory
 806   ifeq ($$($1_COMPONENT), jtreg)
 807     $1_COMPONENT := hotspot
 808   endif
 809 
 810   ifeq ($$(JT_HOME), )
 811     $$(info Error: jtreg framework is not found.)
 812     $$(info Please run configure using --with-jtreg.)
 813     $$(error Cannot continue)
 814   endif
 815 
 816   # Unfortunately, we need different defaults for some JTREG values,
 817   # depending on what component we&#39;re running.
 818 
 819   # Convert JTREG_foo into $1_JTREG_foo with a suitable value.
 820   $$(eval $$(call SetJtregValue,$1,JTREG_TEST_MODE,agentvm))
 821   $$(eval $$(call SetJtregValue,$1,JTREG_ASSERT,true))
 822   $$(eval $$(call SetJtregValue,$1,JTREG_MAX_MEM,512m))
 823   $$(eval $$(call SetJtregValue,$1,JTREG_NATIVEPATH))
 824   $$(eval $$(call SetJtregValue,$1,JTREG_BASIC_OPTIONS))
 825   $$(eval $$(call SetJtregValue,$1,JTREG_PROBLEM_LIST))
 826 
 827   # Only the problem list for the current test root should be used.
 828   $1_JTREG_PROBLEM_LIST := $$(filter $$($1_TEST_ROOT)%, $$($1_JTREG_PROBLEM_LIST))
 829 
 830   ifneq ($(TEST_JOBS), 0)
 831     $$(eval $$(call SetJtregValue,$1,JTREG_JOBS,$$(TEST_JOBS)))
 832   else
 833     $$(eval $$(call SetJtregValue,$1,JTREG_JOBS,$$(JOBS)))
 834   endif
 835 
 836   # Make sure MaxRAMPercentage is high enough to not cause OOM or swapping since
 837   # we may end up with a lot of JVM&#39;s
 838   $1_JTREG_MAX_RAM_PERCENTAGE := $$(shell $$(EXPR) 25 / $$($1_JTREG_JOBS))
 839 
 840   JTREG_TIMEOUT_FACTOR ?= 4
 841 
 842   JTREG_VERBOSE ?= fail,error,summary
 843   JTREG_RETAIN ?= fail,error
 844   JTREG_RUN_PROBLEM_LISTS ?= false
 845   JTREG_RETRY_COUNT ?= 0
 846 
<a name="5" id="anc5"></a>







 847   ifneq ($$($1_JTREG_MAX_MEM), 0)
 848     $1_JTREG_BASIC_OPTIONS += -vmoption:-Xmx$$($1_JTREG_MAX_MEM)
 849     $1_JTREG_LAUNCHER_OPTIONS += -Xmx$$($1_JTREG_MAX_MEM)
 850   endif
 851 
<a name="6" id="anc6"></a>


 852   $1_JTREG_BASIC_OPTIONS += -$$($1_JTREG_TEST_MODE) \
 853       -verbose:$$(JTREG_VERBOSE) -retain:$$(JTREG_RETAIN) \
 854       -concurrency:$$($1_JTREG_JOBS) -timeoutFactor:$$(JTREG_TIMEOUT_FACTOR) \
<a name="7" id="anc7"></a><span class="line-modified"> 855       -vmoption:-XX:MaxRAMPercentage=$$($1_JTREG_MAX_RAM_PERCENTAGE)</span>

 856 
 857   $1_JTREG_BASIC_OPTIONS += -automatic -ignore:quiet
 858 
 859   # Make it possible to specify the JIB_DATA_DIR for tests using the
 860   # JIB Artifact resolver
 861   $1_JTREG_BASIC_OPTIONS += -e:JIB_DATA_DIR
 862   # Some tests needs to find a boot JDK using the JDK8_HOME variable.
 863   $1_JTREG_BASIC_OPTIONS += -e:JDK8_HOME=$$(BOOT_JDK)
 864   # If running on Windows, propagate the _NT_SYMBOL_PATH to enable
 865   # symbol lookup in hserr files
 866   ifeq ($$(call isTargetOs, windows), true)
 867     $1_JTREG_BASIC_OPTIONS += -e:_NT_SYMBOL_PATH
 868   endif
 869 
 870   $1_JTREG_BASIC_OPTIONS += \
 871       $$(addprefix -javaoption:, $$(JTREG_JAVA_OPTIONS)) \
 872       $$(addprefix -vmoption:, $$(JTREG_VM_OPTIONS)) \
 873       #
 874 
 875   ifeq ($$($1_JTREG_ASSERT), true)
 876     $1_JTREG_BASIC_OPTIONS += -ea -esa
 877   endif
 878 
 879   ifneq ($$($1_JTREG_NATIVEPATH), )
 880     $1_JTREG_BASIC_OPTIONS += -nativepath:$$($1_JTREG_NATIVEPATH)
 881   endif
 882 
 883   ifeq ($$(JTREG_RUN_PROBLEM_LISTS), true)
 884     JTREG_PROBLEM_LIST_PREFIX := -match:
 885   else
 886     JTREG_PROBLEM_LIST_PREFIX := -exclude:
 887   endif
 888 
 889   ifneq ($$($1_JTREG_PROBLEM_LIST), )
 890     $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$($1_JTREG_PROBLEM_LIST))
 891   endif
 892 
 893   ifneq ($$(JTREG_EXTRA_PROBLEM_LISTS), )
 894     # Accept both absolute paths as well as relative to the current test root.
 895     $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \
 896         $$(JTREG_EXTRA_PROBLEM_LISTS) \
 897         $$(addprefix $$($1_TEST_ROOT)/, $$(JTREG_EXTRA_PROBLEM_LISTS)) \
 898     ))
 899   endif
 900 
 901   ifneq ($$(JIB_HOME), )
 902     $1_JTREG_BASIC_OPTIONS += -e:JIB_HOME=$$(JIB_HOME)
 903   endif
 904 
 905   $1_JTREG_BASIC_OPTIONS += -e:TEST_IMAGE_DIR=$(TEST_IMAGE_DIR)
 906   $1_JTREG_BASIC_OPTIONS += -e:TEST_IMAGE_GRAAL_DIR=$(TEST_IMAGE_DIR)/hotspot/jtreg/graal
 907 
 908   ifneq ($$(JTREG_FAILURE_HANDLER_OPTIONS), )
 909     $1_JTREG_LAUNCHER_OPTIONS += -Djava.library.path=&quot;$(JTREG_FAILURE_HANDLER_DIR)&quot;
 910   endif
 911 
 912   ifneq ($$(JTREG_KEYWORDS), )
 913     # The keywords string may contain problematic characters and may be quoted
 914     # already when it arrives here. Remove any existing quotes and replace them
 915     # with one set of single quotes.
 916     $1_JTREG_KEYWORDS := \
 917         $$(strip $$(subst $$(SQUOTE),,$$(subst $$(DQUOTE),,$$(JTREG_KEYWORDS))))
 918     ifneq ($$($1_JTREG_KEYWORDS), )
 919       $1_JTREG_BASIC_OPTIONS += -k:&#39;$$($1_JTREG_KEYWORDS)&#39;
 920     endif
 921   endif
 922 
 923   ifneq ($$(JTREG_AOT_MODULES), )
 924     $$(eval $$(call SetupAot, $1, \
 925         MODULES := $$(JTREG_AOT_MODULES), \
 926         VM_OPTIONS := $$(JTREG_VM_OPTIONS) $$(JTREG_JAVA_OPTIONS), \
 927     ))
 928   endif
 929 
 930   ifneq ($$($1_AOT_OPTIONS), )
 931     $1_JTREG_BASIC_OPTIONS += -vmoptions:&quot;$$($1_AOT_OPTIONS)&quot;
 932   endif
 933 
 934   clean-workdir-$1:
 935 	$$(RM) -r $$($1_TEST_SUPPORT_DIR)
 936 
 937   $1_COMMAND_LINE := \
 938       $$(JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \
 939           -Dprogram=jtreg -jar $$(JT_HOME)/lib/jtreg.jar \
 940           $$($1_JTREG_BASIC_OPTIONS) \
 941           -testjdk:$$(JDK_UNDER_TEST) \
 942           -dir:$$(JTREG_TOPDIR) \
 943           -reportDir:$$($1_TEST_RESULTS_DIR) \
 944           -workDir:$$($1_TEST_SUPPORT_DIR) \
 945           -status:$$$${JTREG_STATUS} \
 946           $$(JTREG_OPTIONS) \
 947           $$(JTREG_FAILURE_HANDLER_OPTIONS) \
 948           $$(JTREG_COV_OPTIONS) \
 949           $$($1_TEST_NAME) \
 950       &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
 951       || $$(ECHO) $$$$? &gt; $$($1_EXITCODE)
 952 
 953 
 954   ifneq ($$(JTREG_RETRY_COUNT), 0)
 955     $1_COMMAND_LINE := \
 956         for i in {0..$$(JTREG_RETRY_COUNT)}; do \
 957           if [ &quot;$$$$i&quot; != 0 ]; then \
 958             $$(PRINTF) &quot;\nRetrying Jtreg run. Attempt: $$$$i\n&quot;; \
 959           fi; \
 960           $$($1_COMMAND_LINE); \
 961           if [ &quot;`$$(CAT) $$($1_EXITCODE)`&quot; = &quot;0&quot; ]; then \
 962             break; \
 963           fi; \
 964           export JTREG_STATUS=&quot;-status:error,fail&quot;; \
 965         done
 966   endif
 967 
 968   run-test-$1: pre-run-test clean-workdir-$1 $$($1_AOT_TARGETS)
 969 	$$(call LogWarn)
 970 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
<a name="8" id="anc8"></a><span class="line-modified"> 971 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))</span>

 972 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/jtreg, ( \
 973             $$(COV_ENVIRONMENT) $$($1_COMMAND_LINE) \
 974 	))
 975 
 976   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/text/stats.txt
 977 
 978   parse-test-$1: run-test-$1
 979 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
 980 	$$(call LogWarn, Test report is stored in $$(strip \
 981 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
 982 	$$(if $$(wildcard $$($1_RESULT_FILE)), \
 983 	  $$(eval $1_PASSED := $$(shell $$(AWK) &#39;{ gsub(/[,;]/, &quot;&quot;); \
 984 	      for (i=1; i&lt;=NF; i++) { if ($$$$i == &quot;passed:&quot;) \
 985 	      print $$$$(i+1) } }&#39; $$($1_RESULT_FILE))) \
 986 	  $$(if $$($1_PASSED), , $$(eval $1_PASSED := 0)) \
 987 	  $$(eval $1_FAILED := $$(shell $$(AWK) &#39;{gsub(/[,;]/, &quot;&quot;); \
 988 	      for (i=1; i&lt;=NF; i++) { if ($$$$i == &quot;failed:&quot;) \
 989 	      print $$$$(i+1) } }&#39; $$($1_RESULT_FILE))) \
 990 	  $$(if $$($1_FAILED), , $$(eval $1_FAILED := 0)) \
 991 	  $$(eval $1_ERROR := $$(shell $$(AWK) &#39;{gsub(/[,;]/, &quot;&quot;); \
 992 	      for (i=1; i&lt;=NF; i++) { if ($$$$i == &quot;error:&quot;) \
 993 	      print $$$$(i+1) } }&#39; $$($1_RESULT_FILE))) \
 994 	  $$(if $$($1_ERROR), , $$(eval $1_ERROR := 0)) \
 995 	  $$(eval $1_TOTAL := $$(shell \
 996 	      $$(EXPR) $$($1_PASSED) + $$($1_FAILED) + $$($1_ERROR))) \
 997 	, \
 998 	  $$(eval $1_PASSED := 0) \
 999 	  $$(eval $1_FAILED := 0) \
1000 	  $$(eval $1_ERROR := 1) \
1001 	  $$(eval $1_TOTAL := 1) \
1002 	)
1003 
1004   $1: run-test-$1 parse-test-$1 clean-workdir-$1
1005 
1006   TARGETS += $1 run-test-$1 parse-test-$1 clean-workdir-$1
1007   TEST_TARGETS += parse-test-$1
1008 
1009 endef
1010 
1011 ################################################################################
1012 
1013 ### Rules for special tests
1014 
1015 SetupRunSpecialTest = $(NamedParamsMacroTemplate)
1016 define SetupRunSpecialTestBody
1017   $1_TEST_RESULTS_DIR := $$(TEST_RESULTS_DIR)/$1
1018   $1_TEST_SUPPORT_DIR := $$(TEST_SUPPORT_DIR)/$1
1019   $1_EXITCODE := $$($1_TEST_RESULTS_DIR)/exitcode.txt
1020 
1021   $1_FULL_TEST_NAME := $$(strip $$(patsubst special:%, %, $$($1_TEST)))
1022   ifneq ($$(findstring :, $$($1_FULL_TEST_NAME)), )
1023     $1_TEST_NAME := $$(firstword $$(subst :, ,$$($1_FULL_TEST_NAME)))
1024     $1_TEST_ARGS := $$(strip $$(patsubst special:$$($1_TEST_NAME):%, %, $$($1_TEST)))
1025   else
1026     $1_TEST_NAME := $$($1_FULL_TEST_NAME)
1027     $1_TEST_ARGS :=
1028   endif
1029 
1030   ifeq ($$($1_TEST_NAME), failure-handler)
1031     ifeq ($(BUILD_FAILURE_HANDLER), true)
1032       $1_TEST_COMMAND_LINE := \
1033           ($(CD) $(TOPDIR)/make/test &amp;&amp; $(MAKE) $(MAKE_ARGS) -f \
1034           BuildFailureHandler.gmk test)
1035     else
1036       $$(error Cannot test failure handler if it is not built)
1037     endif
1038   else ifeq ($$($1_TEST_NAME), make)
1039     $1_TEST_COMMAND_LINE := \
1040         ($(CD) $(TOPDIR)/test/make &amp;&amp; $(MAKE) $(MAKE_ARGS) -f \
1041         TestMake.gmk $$($1_TEST_ARGS) TEST_SUPPORT_DIR=&quot;$$($1_TEST_SUPPORT_DIR)&quot;)
1042   else
1043     $$(error Invalid special test specification: $$($1_TEST_NAME))
1044   endif
1045 
1046   run-test-$1: pre-run-test
1047 	$$(call LogWarn)
1048 	$$(call LogWarn, Running test &#39;$$($1_TEST)&#39;)
1049 	$$(call MakeDir, $$($1_TEST_RESULTS_DIR) $$($1_TEST_SUPPORT_DIR))
1050 	$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)/test-execution, ( \
1051 	    $$($1_TEST_COMMAND_LINE) \
1052 	        &gt; &gt;($(TEE) $$($1_TEST_RESULTS_DIR)/test-output.txt) \
1053 	    &amp;&amp; $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
1054 	    || $$(ECHO) $$$$? &gt; $$($1_EXITCODE) \
1055 	))
1056 
1057   $1_RESULT_FILE := $$($1_TEST_RESULTS_DIR)/gtest.txt
1058 
1059   # We can not parse the various &quot;special&quot; tests.
1060   parse-test-$1: run-test-$1
1061 	$$(call LogWarn, Finished running test &#39;$$($1_TEST)&#39;)
1062 	$$(call LogWarn, Test report is stored in $$(strip \
1063 	    $$(subst $$(TOPDIR)/, , $$($1_TEST_RESULTS_DIR))))
1064 	$$(call LogWarn, Warning: Special test results are not properly parsed!)
1065 	$$(eval $1_PASSED := $$(shell \
1066 	  if [ `$(CAT) $$($1_EXITCODE)` = &quot;0&quot; ]; then $(ECHO) 1; else $(ECHO) 0; fi \
1067 	))
1068 	$$(eval $1_FAILED := $$(shell \
1069 	  if [ `$(CAT) $$($1_EXITCODE)` = &quot;0&quot; ]; then $(ECHO) 0; else $(ECHO) 1; fi \
1070 	))
1071 	$$(eval $1_ERROR := 0)
1072 	$$(eval $1_TOTAL := 1)
1073 
1074   $1: run-test-$1 parse-test-$1
1075 
1076   TARGETS += $1 run-test-$1 parse-test-$1
1077   TEST_TARGETS += parse-test-$1
1078 
1079 endef
1080 
1081 ################################################################################
1082 # Setup and execute make rules for all selected tests
1083 ################################################################################
1084 
1085 # Helper function to determine which handler to use for the given test
1086 UseGtestTestHandler = \
1087   $(if $(filter gtest:%, $1), true)
1088 
1089 UseMicroTestHandler = \
1090   $(if $(filter micro:%, $1), true)
1091 
1092 UseJtregTestHandler = \
1093   $(if $(filter jtreg:%, $1), true)
1094 
1095 UseSpecialTestHandler = \
1096   $(if $(filter special:%, $1), true)
1097 
1098 # Now process each test to run and setup a proper make rule
1099 $(foreach test, $(TESTS_TO_RUN), \
1100   $(eval TEST_ID := $(shell $(ECHO) $(strip $(test)) | \
1101       $(TR) -cs &#39;[a-z][A-Z][0-9]\n&#39; &#39;[_*1000]&#39;)) \
1102   $(eval ALL_TEST_IDS += $(TEST_ID)) \
1103   $(if $(call UseCustomTestHandler, $(test)), \
1104     $(eval $(call SetupRunCustomTest, $(TEST_ID), \
1105         TEST := $(test), \
1106     )) \
1107   ) \
1108   $(if $(call UseGtestTestHandler, $(test)), \
1109     $(eval $(call SetupRunGtestTest, $(TEST_ID), \
1110         TEST := $(test), \
1111     )) \
1112   ) \
1113   $(if $(call UseMicroTestHandler, $(test)), \
1114     $(eval $(call SetupRunMicroTest, $(TEST_ID), \
1115         TEST := $(test), \
1116     )) \
1117   ) \
1118   $(if $(call UseJtregTestHandler, $(test)), \
1119     $(eval $(call SetupRunJtregTest, $(TEST_ID), \
1120         TEST := $(test), \
1121     )) \
1122   ) \
1123   $(if $(call UseSpecialTestHandler, $(test)), \
1124     $(eval $(call SetupRunSpecialTest, $(TEST_ID), \
1125         TEST := $(test), \
1126     )) \
1127   ) \
1128 )
1129 
1130 # Sort also removes duplicates, so if there is any we&#39;ll get fewer words.
1131 ifneq ($(words $(ALL_TEST_IDS)), $(words $(sort $(ALL_TEST_IDS))))
1132   $(error Duplicate test specification)
1133 endif
1134 
1135 
1136 ################################################################################
1137 # The main target for RunTests.gmk
1138 ################################################################################
1139 
1140 #
1141 # Provide hooks for adding functionality before and after all tests are run.
1142 #
1143 
1144 $(call LogInfo, RunTest setup starting)
1145 
1146 # This target depends on all actual test having been run (TEST_TARGETS has beeen
1147 # populated by the SetupRun*Test functions). If you need to provide a teardown
1148 # hook, you must let it depend on this target.
1149 run-all-tests: $(TEST_TARGETS)
1150 	$(call LogInfo, RunTest teardown starting)
1151 
1152 # This is an abstract target that will be run before any actual tests. Add your
1153 # target as a dependency to thisif you need &quot;setup&quot; type functionality executed
1154 # before all tests.
1155 pre-run-test:
1156 	$(call LogInfo, RunTest setup done)
1157 
1158 # This is an abstract target that will be run after all actual tests, but before
1159 # the test summary. If you need &quot;teardown&quot; type functionality, add your target
1160 # as a dependency on this, and let the teardown target depend on run-all-tests.
1161 post-run-test: run-all-tests
1162 	$(call LogInfo, RunTest teardown done)
1163 
1164 #
1165 # Create and print a table of the result of all tests run
1166 #
1167 TEST_FAILURE := false
1168 
1169 run-test-report: post-run-test
1170 	$(RM) $(TEST_SUMMARY).old 2&gt; /dev/null
1171 	$(MV) $(TEST_SUMMARY) $(TEST_SUMMARY).old 2&gt; /dev/null || true
1172 	$(RM) $(TEST_LAST_IDS).old 2&gt; /dev/null
1173 	$(MV) $(TEST_LAST_IDS) $(TEST_LAST_IDS).old 2&gt; /dev/null || true
1174 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) ==============================
1175 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) Test summary
1176 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) ==============================
1177 	$(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s %5s %5s %5s %5s %2s\n&quot; &quot;  &quot; \
1178 	    TEST TOTAL PASS FAIL ERROR &quot; &quot;
1179 	$(foreach test, $(TESTS_TO_RUN), \
1180 	  $(eval TEST_ID := $(shell $(ECHO) $(strip $(test)) | \
1181 	      $(TR) -cs &#39;[a-z][A-Z][0-9]\n&#39; &#39;[_*1000]&#39;)) \
1182 	    $(ECHO) &gt;&gt; $(TEST_LAST_IDS) $(TEST_ID) $(NEWLINE) \
1183 	  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c &#39;\n&#39; &#39;[_*1000]&#39;)) \
1184 	  $(if $(filter __________________________________________________%, $(NAME_PATTERN)), \
1185 	    $(eval TEST_NAME := ) \
1186 	    $(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s\n&quot; &quot;  &quot; &quot;$(test)&quot;  $(NEWLINE) \
1187 	  , \
1188 	    $(eval TEST_NAME := $(test)) \
1189 	  ) \
1190 	  $(if $(filter $($(TEST_ID)_PASSED), $($(TEST_ID)_TOTAL)), \
1191 	    $(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s %5d %5d %5d %5d %2s\n&quot; \
1192 	        &quot;  &quot; &quot;$(TEST_NAME)&quot; $($(TEST_ID)_TOTAL) $($(TEST_ID)_PASSED) \
1193 	        $($(TEST_ID)_FAILED) $($(TEST_ID)_ERROR) &quot;  &quot; $(NEWLINE) \
1194 	  , \
1195 	    $(PRINTF) &gt;&gt; $(TEST_SUMMARY) &quot;%2s %-49s %5d %5d %5d %5d %2s\n&quot; \
1196 	         &quot;&gt;&gt;&quot; &quot;$(TEST_NAME)&quot; $($(TEST_ID)_TOTAL) $($(TEST_ID)_PASSED) \
1197 	        $($(TEST_ID)_FAILED) $($(TEST_ID)_ERROR) &quot;&lt;&lt;&quot; $(NEWLINE) \
1198 	    $(eval TEST_FAILURE := true) \
1199 	  ) \
1200 	)
1201 	$(ECHO) &gt;&gt; $(TEST_SUMMARY) ==============================
1202 	$(if $(filter true, $(TEST_FAILURE)), \
1203 	  $(ECHO) &gt;&gt; $(TEST_SUMMARY) TEST FAILURE $(NEWLINE) \
1204 	  $(MKDIR) -p $(MAKESUPPORT_OUTPUTDIR) $(NEWLINE) \
1205 	  $(TOUCH) $(MAKESUPPORT_OUTPUTDIR)/exit-with-error \
1206 	, \
1207 	  $(ECHO) &gt;&gt; $(TEST_SUMMARY) TEST SUCCESS \
1208 	)
1209 	$(ECHO)
1210 	$(CAT) $(TEST_SUMMARY)
1211 	$(ECHO)
1212 
1213 # The main run-test target
1214 run-test: run-test-report
1215 
1216 TARGETS += run-all-tests pre-run-test post-run-test run-test-report run-test
1217 
1218 ################################################################################
1219 # Setup JCov
1220 ################################################################################
1221 
1222 ifeq ($(TEST_OPTS_JCOV), true)
1223 
1224   jcov-do-start-grabber:
1225 	$(call MakeDir, $(JCOV_OUTPUT_DIR))
1226 	if $(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -status 1&gt;/dev/null 2&gt;&amp;1 ; then \
1227 	  $(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -stop -stoptimeout 3600 ; \
1228 	fi
1229 	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar Grabber -v -t \
1230 	    $(JCOV_IMAGE_DIR)/template.xml -o $(JCOV_RESULT_FILE) \
1231 	    1&gt;$(JCOV_GRABBER_LOG) 2&gt;&amp;1 &amp;
1232 
1233   jcov-start-grabber: jcov-do-start-grabber
1234 	$(call LogWarn, Starting JCov Grabber...)
1235 	$(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -t 600 -wait
1236 
1237   jcov-stop-grabber:
1238 	$(call LogWarn, Stopping JCov Grabber...)
1239 	$(JAVA) -jar $(JCOV_HOME)/lib/jcov.jar GrabberManager -stop -stoptimeout 3600
1240 
1241   JCOV_REPORT_TITLE := JDK code coverage report&lt;br/&gt;
1242   ifneq ($(JCOV_FILTERS), )
1243     JCOV_REPORT_TITLE += Code filters: $(JCOV_FILTERS)&lt;br&gt;
1244   endif
1245   JCOV_REPORT_TITLE += Tests: $(TEST)
1246 
1247   jcov-gen-report: jcov-stop-grabber
1248 	$(call LogWarn, Generating JCov report ...)
1249 	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar RepGen -sourcepath \
1250 	    `$(ECHO) $(TOPDIR)/src/*/share/classes/ | $(TR) &#39; &#39; &#39;:&#39;` -fmt html \
1251 	    $(JCOV_FILTERS) \
1252 	    -mainReportTitle &quot;$(JCOV_REPORT_TITLE)&quot; \
1253 	    -o $(JCOV_REPORT) $(JCOV_RESULT_FILE)
1254 
1255   TARGETS += jcov-do-start-grabber jcov-start-grabber jcov-stop-grabber \
1256       jcov-gen-report
1257 
1258   ifneq ($(TEST_OPTS_JCOV_DIFF_CHANGESET), )
1259 
1260     JCOV_SOURCE_DIFF := $(JCOV_OUTPUT_DIR)/source_diff
1261     JCOV_DIFF_COVERAGE_REPORT := $(JCOV_OUTPUT_DIR)/diff_coverage_report
1262 
1263     ifneq ($(and $(HG), $(wildcard $(TOPDIR)/.hg)), )
1264       DIFF_COMMAND := $(HG) -R $(TOPDIR) diff -r $(TEST_OPTS_JCOV_DIFF_CHANGESET) &gt; $(JCOV_SOURCE_DIFF)
1265     else ifneq ($(and $(GIT), $(wildcard $(TOPDIR)/.git)), )
1266       DIFF_COMMAND := $(GIT) -C $(TOPDIR) diff $(TEST_OPTS_JCOV_DIFF_CHANGESET) &gt; $(JCOV_SOURCE_DIFF)
1267     else
1268       $(info Error: Must be either hg or git source tree for diff coverage.)
1269       $(error Neither hg nor git source tree.)
1270     endif
1271 
1272     jcov-gen-diffcoverage: jcov-stop-grabber
1273 	$(call LogWarn, Generating diff coverage with changeset $(TEST_OPTS_JCOV_DIFF_CHANGESET) ... )
1274 	$(DIFF_COMMAND)
1275 	$(JAVA) -Xmx4g -jar $(JCOV_HOME)/lib/jcov.jar \
1276 	  DiffCoverage -replaceDiff &quot;src/.*/classes/:&quot; -all \
1277 	    $(JCOV_RESULT_FILE) $(JCOV_SOURCE_DIFF) &gt; \
1278 	    $(JCOV_DIFF_COVERAGE_REPORT)
1279 
1280     TARGETS += jcov-gen-diffcoverage
1281 
1282   endif
1283 
1284   # Hook this into the framework at appropriate places
1285   pre-run-test: jcov-start-grabber
1286 
1287   post-run-test: jcov-gen-report
1288 
1289   ifneq ($(TEST_OPTS_JCOV_DIFF_CHANGESET), )
1290 
1291     post-run-test: jcov-gen-diffcoverage
1292 
1293   endif
1294 
1295   jcov-stop-grabber: run-all-tests
1296 
1297 endif
1298 
1299 ################################################################################
1300 
1301 all: run-test
1302 
1303 .PHONY: default all $(TARGETS)
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
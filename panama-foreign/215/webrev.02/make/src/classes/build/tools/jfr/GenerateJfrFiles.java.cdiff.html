<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff make/src/classes/build/tools/jfr/GenerateJfrFiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../modules/jdk.jfr/Copy.gmk.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/BuildMicrobenchmark.gmk.cdiff.html" target="_top">next &gt;</a></center>    <h2>make/src/classes/build/tools/jfr/GenerateJfrFiles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,18 ***</span>
  package build.tools.jfr;
  
  import java.io.BufferedOutputStream;
  import java.io.File;
  import java.io.FileNotFoundException;
  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.io.PrintStream;
  import java.util.ArrayList;
  import java.util.LinkedHashMap;
  import java.util.List;
  import java.util.Map;
<span class="line-modified">! import java.util.Map.Entry;</span>
  import java.util.StringJoiner;
  import java.util.function.Predicate;
  
  import javax.xml.XMLConstants;
  import javax.xml.parsers.ParserConfigurationException;
<span class="line-new-header">--- 1,21 ---</span>
  package build.tools.jfr;
  
  import java.io.BufferedOutputStream;
<span class="line-added">+ import java.io.Closeable;</span>
<span class="line-added">+ import java.io.DataOutputStream;</span>
  import java.io.File;
  import java.io.FileNotFoundException;
  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.io.PrintStream;
  import java.util.ArrayList;
<span class="line-added">+ import java.util.Arrays;</span>
  import java.util.LinkedHashMap;
  import java.util.List;
  import java.util.Map;
<span class="line-modified">! import java.util.Objects;</span>
  import java.util.StringJoiner;
  import java.util.function.Predicate;
  
  import javax.xml.XMLConstants;
  import javax.xml.parsers.ParserConfigurationException;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,145 ***</span>
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.SAXParseException;
  import org.xml.sax.helpers.DefaultHandler;
  
  public class GenerateJfrFiles {
  
<span class="line-modified">!     public static void main(String... args) throws Exception {</span>
<span class="line-modified">!         if (args.length != 3) {</span>
<span class="line-removed">-             System.err.println(&quot;Incorrect number of command line arguments.&quot;);</span>
<span class="line-removed">-             System.err.println(&quot;Usage:&quot;);</span>
<span class="line-removed">-             System.err.println(&quot;java GenerateJfrFiles[.java] &lt;path-to-metadata.xml&gt; &lt;path-to-metadata.xsd&gt; &lt;output-directory&gt;&quot;);</span>
<span class="line-removed">-             System.exit(1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             File metadataXml = new File(args[0]);</span>
<span class="line-removed">-             File metadataSchema = new File(args[1]);</span>
<span class="line-removed">-             File outputDirectory = new File(args[2]);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             Metadata metadata = new Metadata(metadataXml, metadataSchema);</span>
<span class="line-removed">-             metadata.verify();</span>
<span class="line-removed">-             metadata.wireUpTypes();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             TypeCounter typeCounter = new TypeCounter();</span>
<span class="line-removed">-             printJfrEventIdsHpp(metadata, typeCounter, outputDirectory);</span>
<span class="line-removed">-             printJfrTypesHpp(metadata, typeCounter, outputDirectory);</span>
<span class="line-removed">-             printJfrPeriodicHpp(metadata, outputDirectory);</span>
<span class="line-removed">-             printJfrEventControlHpp(metadata, typeCounter, outputDirectory);</span>
<span class="line-removed">-             printJfrEventClassesHpp(metadata, outputDirectory);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         } catch (Exception e) {</span>
<span class="line-removed">-             e.printStackTrace();</span>
<span class="line-removed">-             System.exit(1);</span>
<span class="line-removed">-         }</span>
      }
  
<span class="line-modified">!     static class TypeCounter {</span>
<span class="line-modified">!         final static long RESERVED_EVENT_COUNT = 2;</span>
<span class="line-modified">!         long typeId = -1;</span>
<span class="line-modified">!         long eventId = -1;</span>
<span class="line-modified">!         long eventCount = 0;</span>
<span class="line-modified">!         String firstTypeName;</span>
<span class="line-modified">!         String lastTypeName;</span>
<span class="line-removed">-         String firstEventName;</span>
<span class="line-removed">-         String lastEventname;</span>
  
<span class="line-modified">!         public long nextEventId(String name) {</span>
<span class="line-modified">!             eventCount++;</span>
<span class="line-modified">!             if (eventId == -1) {</span>
<span class="line-modified">!                 eventId = firstEventId();</span>
<span class="line-modified">!                 firstEventName = lastEventname = name;</span>
<span class="line-modified">!                 return eventId;</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-             lastEventname = name;</span>
<span class="line-removed">-             return ++eventId;</span>
          }
  
<span class="line-modified">!         public long nextTypeId(String typeName) {</span>
<span class="line-modified">!             if (typeId == -1) {</span>
<span class="line-modified">!                 lastTypeName = firstTypeName = typeName;</span>
<span class="line-modified">!                 typeId = lastEventId();</span>
              }
<span class="line-modified">!             lastTypeName = typeName;</span>
<span class="line-modified">!             return ++typeId;</span>
<span class="line-modified">!         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public long firstEventId() {</span>
<span class="line-removed">-             return RESERVED_EVENT_COUNT;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public long lastEventId() {</span>
<span class="line-removed">-             return eventId == -1 ? firstEventId() : eventId;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public long eventCount() {</span>
<span class="line-removed">-             return eventCount;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         public String firstTypeName() {</span>
<span class="line-removed">-             return firstTypeName;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         public String lastTypeName() {</span>
<span class="line-modified">!             return lastTypeName;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         public String firstEventName() {</span>
<span class="line-modified">!             return firstEventName;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         public String lastEventName() {</span>
<span class="line-modified">!             return lastEventname;</span>
          }
      }
  
      static class XmlType {
          final String name;
          final String fieldType;
          final String parameterType;
          final String javaType;
          final boolean unsigned;
  
<span class="line-modified">!         XmlType(String name, String fieldType, String parameterType, String javaType, boolean unsigned) {</span>
              this.name = name;
              this.fieldType = fieldType;
              this.parameterType = parameterType;
              this.javaType = javaType;
              this.unsigned = unsigned;
          }
      }
  
      static class TypeElement {
          List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
          String name;
<span class="line-modified">!         String fieldType;</span>
<span class="line-modified">!         String parameterType;</span>
<span class="line-modified">!         boolean supportStruct;</span>
      }
  
      static class Metadata {
          final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
          final Map&lt;String, XmlType&gt; xmlTypes = new LinkedHashMap&lt;&gt;();
<span class="line-modified">!         Metadata(File metadataXml, File metadataSchema) throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {</span>
              SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
              SAXParserFactory factory = SAXParserFactory.newInstance();
              factory.setSchema(schemaFactory.newSchema(metadataSchema));
              SAXParser sp = factory.newSAXParser();
              sp.parse(metadataXml, new MetadataHandler(this));
          }
  
<span class="line-modified">!         List&lt;EventElement&gt; getEvents() {</span>
<span class="line-modified">!             return getList(t -&gt; t.getClass() == EventElement.class);</span>
          }
  
<span class="line-modified">!         List&lt;TypeElement&gt; getEventsAndStructs() {</span>
<span class="line-modified">!             return getList(t -&gt; t.getClass() == EventElement.class || t.supportStruct);</span>
          }
  
<span class="line-modified">!         List&lt;TypeElement&gt; getTypesAndStructs() {</span>
<span class="line-modified">!             return getList(t -&gt; t.getClass() == TypeElement.class || t.supportStruct);</span>
          }
  
          @SuppressWarnings(&quot;unchecked&quot;)
          &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
              List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
<span class="line-new-header">--- 26,232 ---</span>
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.SAXParseException;
  import org.xml.sax.helpers.DefaultHandler;
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * Purpose of this program is twofold:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * 1) Generate C++ classes to be used when writing native events for HotSpot.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * 2) Generate metadata (label, descriptions, field layout etc.) from XML</span>
<span class="line-added">+  * (metadata.xml) into a binary format (metadata.bin) that can be read quickly</span>
<span class="line-added">+  * during startup by the jdk.jfr module.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * INPUT FILES:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * -  metadata.xml  File that contains descriptions of events and types</span>
<span class="line-added">+  * -  metadata.xsd  Schema that verifies that metadata.xml is legit XML</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * OUTPUT FILES:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * MODE: headers</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * - jfrEventIds.hpp      List of IDs so events can be identified from native</span>
<span class="line-added">+  * - jfrTypes.hpp         List of IDs so types can be identified from native</span>
<span class="line-added">+  * - jfrPeriodic.hpp      Dispatch mechanism so Java can emit native periodic events</span>
<span class="line-added">+  * - jfrEventControl.hpp  Data structure for native event settings.</span>
<span class="line-added">+  * - jfrEventClasses.hpp  C++ event classes that can write data into native buffers</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * MODE: metadata</span>
<span class="line-added">+  *</span>
<span class="line-added">+  *  - metadata.bin        Binary representation of the information in metadata.xml</span>
<span class="line-added">+  *</span>
<span class="line-added">+  */</span>
  public class GenerateJfrFiles {
  
<span class="line-modified">!     enum OutputMode {</span>
<span class="line-modified">!         headers, metadata</span>
      }
  
<span class="line-modified">!     private static void printUsage(PrintStream out) {</span>
<span class="line-modified">!         out.println(&quot;Usage: java GenerateJfrFiles[.java]&quot;);</span>
<span class="line-modified">!         out.println(&quot; --mode &lt;headers|metadata&gt;&quot;);</span>
<span class="line-modified">!         out.println(&quot; --xml &lt;path-to-metadata.xml&gt; &quot;);</span>
<span class="line-modified">!         out.println(&quot; --xsd &lt;path-to-metadata.xsd&gt;&quot;);</span>
<span class="line-modified">!         out.println(&quot; --output &lt;output-file-or-directory&gt;&quot;);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private static String consumeOption(String option, List&lt;String&gt; argList) throws Exception {</span>
<span class="line-modified">!         int index = argList.indexOf(option);</span>
<span class="line-modified">!         if (index &gt;= 0 &amp;&amp; index &lt;= argList.size() - 2) {</span>
<span class="line-modified">!             String result = argList.get(index + 1);</span>
<span class="line-modified">!             argList.remove(index);</span>
<span class="line-modified">!             argList.remove(index);</span>
<span class="line-modified">!             return result;</span>
          }
<span class="line-added">+         throw new IllegalArgumentException(&quot;missing option &quot; + option);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     public static void main(String... args) throws Exception {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             List&lt;String&gt; argList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!             argList.addAll(Arrays.asList(args));</span>
<span class="line-added">+             String mode = consumeOption(&quot;--mode&quot;, argList);</span>
<span class="line-added">+             String output = consumeOption(&quot;--output&quot;, argList);</span>
<span class="line-added">+             String xml = consumeOption(&quot;--xml&quot;, argList);</span>
<span class="line-added">+             String xsd = consumeOption(&quot;--xsd&quot;, argList);</span>
<span class="line-added">+             if (!argList.isEmpty()) {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;unknown option &quot; + argList);</span>
              }
<span class="line-modified">!             OutputMode outputMode = OutputMode.valueOf(mode);</span>
<span class="line-modified">!             File xmlFile = new File(xml);</span>
<span class="line-modified">!             File xsdFile = new File(xsd);</span>
  
<span class="line-modified">!             Metadata metadata = new Metadata(xmlFile, xsdFile);</span>
<span class="line-modified">!             metadata.verify();</span>
<span class="line-modified">!             metadata.wireUpTypes();</span>
  
<span class="line-modified">!             if (outputMode == OutputMode.headers) {</span>
<span class="line-modified">!                 File outputDir = new File(output);</span>
<span class="line-modified">!                 printJfrEventIdsHpp(metadata, new File(outputDir, &quot;jfrEventIds.hpp&quot;));</span>
<span class="line-added">+                 printJfrTypesHpp(metadata, new File(outputDir, &quot;jfrTypes.hpp&quot;));</span>
<span class="line-added">+                 printJfrPeriodicHpp(metadata, new File(outputDir, &quot;jfrPeriodic.hpp&quot;));</span>
<span class="line-added">+                 printJfrEventControlHpp(metadata, new File(outputDir, &quot;jfrEventControl.hpp&quot;));</span>
<span class="line-added">+                 printJfrEventClassesHpp(metadata, new File(outputDir, &quot;jfrEventClasses.hpp&quot;));</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (outputMode == OutputMode.metadata) {</span>
<span class="line-modified">!                 File outputFile  = new File(output);</span>
<span class="line-added">+                 try (var b = new DataOutputStream(</span>
<span class="line-added">+                         new BufferedOutputStream(</span>
<span class="line-added">+                             new FileOutputStream(outputFile)))) {</span>
<span class="line-added">+                     metadata.persist(b);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             System.exit(0);</span>
<span class="line-added">+         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">+             System.err.println();</span>
<span class="line-added">+             System.err.println(&quot;GenerateJfrFiles: &quot; + iae.getMessage());</span>
<span class="line-added">+             System.err.println();</span>
<span class="line-added">+             printUsage(System.err);</span>
<span class="line-added">+             System.err.println();</span>
<span class="line-added">+         } catch (Exception e) {</span>
<span class="line-added">+             e.printStackTrace();</span>
          }
<span class="line-added">+         System.exit(1);</span>
      }
  
      static class XmlType {
          final String name;
          final String fieldType;
          final String parameterType;
          final String javaType;
          final boolean unsigned;
<span class="line-added">+         final String contentType;</span>
  
<span class="line-modified">!         XmlType(String name, String fieldType, String parameterType, String javaType, String contentType,</span>
<span class="line-added">+                 boolean unsigned) {</span>
              this.name = name;
              this.fieldType = fieldType;
              this.parameterType = parameterType;
              this.javaType = javaType;
              this.unsigned = unsigned;
<span class="line-added">+             this.contentType = contentType;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static class XmlContentType {</span>
<span class="line-added">+         final String name;</span>
<span class="line-added">+         final String annotation;</span>
<span class="line-added">+ </span>
<span class="line-added">+         XmlContentType(String name, String annotation) {</span>
<span class="line-added">+             this.name = name;</span>
<span class="line-added">+             this.annotation = annotation;</span>
          }
      }
  
      static class TypeElement {
          List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
          String name;
<span class="line-modified">!         String javaType;</span>
<span class="line-modified">!         String label = &quot;&quot;;</span>
<span class="line-modified">!         String description = &quot;&quot;;</span>
<span class="line-added">+         String category = &quot;&quot;;</span>
<span class="line-added">+         boolean thread;</span>
<span class="line-added">+         boolean stackTrace;</span>
<span class="line-added">+         boolean startTime;</span>
<span class="line-added">+         String period = &quot;&quot;;</span>
<span class="line-added">+         boolean cutoff;</span>
<span class="line-added">+         boolean experimental;</span>
<span class="line-added">+         long id;</span>
<span class="line-added">+         boolean isEvent;</span>
<span class="line-added">+         boolean isRelation;</span>
<span class="line-added">+         boolean supportStruct = false;</span>
<span class="line-added">+         String commitState;</span>
<span class="line-added">+         public boolean primitive;</span>
<span class="line-added">+ </span>
<span class="line-added">+         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-added">+             pos.writeInt(fields.size());</span>
<span class="line-added">+             for (FieldElement field : fields) {</span>
<span class="line-added">+                 field.persist(pos);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             pos.writeUTF(javaType);</span>
<span class="line-added">+             pos.writeUTF(label);</span>
<span class="line-added">+             pos.writeUTF(description);</span>
<span class="line-added">+             pos.writeUTF(category);</span>
<span class="line-added">+             pos.writeBoolean(thread);</span>
<span class="line-added">+             pos.writeBoolean(stackTrace);</span>
<span class="line-added">+             pos.writeBoolean(startTime);</span>
<span class="line-added">+             pos.writeUTF(period);</span>
<span class="line-added">+             pos.writeBoolean(cutoff);</span>
<span class="line-added">+             pos.writeBoolean(experimental);</span>
<span class="line-added">+             pos.writeLong(id);</span>
<span class="line-added">+             pos.writeBoolean(isEvent);</span>
<span class="line-added">+             pos.writeBoolean(isRelation);</span>
<span class="line-added">+         }</span>
      }
  
      static class Metadata {
<span class="line-added">+         static class TypeCounter {</span>
<span class="line-added">+             final long first;</span>
<span class="line-added">+             long last = -1;</span>
<span class="line-added">+             long count = 0;</span>
<span class="line-added">+             long id = -1;</span>
<span class="line-added">+ </span>
<span class="line-added">+             TypeCounter(long startId) {</span>
<span class="line-added">+                 this.first = startId;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             long next() {</span>
<span class="line-added">+                 id = (id == -1) ? first : id + 1;</span>
<span class="line-added">+                 count++;</span>
<span class="line-added">+                 last = id;</span>
<span class="line-added">+                 return id;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         static int RESERVED_EVENT_COUNT = 2;</span>
          final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
          final Map&lt;String, XmlType&gt; xmlTypes = new LinkedHashMap&lt;&gt;();
<span class="line-modified">!         final Map&lt;String, XmlContentType&gt; xmlContentTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-added">+         int lastEventId;</span>
<span class="line-added">+         private TypeCounter eventCounter;</span>
<span class="line-added">+         private TypeCounter typeCounter;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Metadata(File metadataXml, File metadataSchema)</span>
<span class="line-added">+                 throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {</span>
              SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
              SAXParserFactory factory = SAXParserFactory.newInstance();
              factory.setSchema(schemaFactory.newSchema(metadataSchema));
              SAXParser sp = factory.newSAXParser();
              sp.parse(metadataXml, new MetadataHandler(this));
          }
  
<span class="line-modified">!         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-modified">!             pos.writeInt(types.values().size());</span>
<span class="line-added">+             for (TypeElement t : types.values()) {</span>
<span class="line-added">+                 t.persist(pos);</span>
<span class="line-added">+             }</span>
          }
  
<span class="line-modified">!         List&lt;TypeElement&gt; getEvents() {</span>
<span class="line-modified">!             return getList(t -&gt; t.isEvent);</span>
          }
  
<span class="line-modified">!         List&lt;TypeElement&gt; getEventsAndStructs() {</span>
<span class="line-modified">!             return getList(t -&gt; t.isEvent || t.supportStruct);</span>
          }
  
          @SuppressWarnings(&quot;unchecked&quot;)
          &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
              List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,68 ***</span>
                  }
              }
              return result;
          }
  
<span class="line-modified">!         List&lt;EventElement&gt; getPeriodicEvents() {</span>
<span class="line-modified">!             return getList(t -&gt; t.getClass() == EventElement.class &amp;&amp; ((EventElement) t).periodic);</span>
          }
  
          List&lt;TypeElement&gt; getTypes() {
<span class="line-modified">!             return getList(t -&gt; t.getClass() == TypeElement.class);</span>
          }
  
          List&lt;TypeElement&gt; getStructs() {
<span class="line-modified">!             return getList(t -&gt; t.getClass() == TypeElement.class &amp;&amp; t.supportStruct);</span>
          }
  
<span class="line-modified">!         void verify()  {</span>
              for (TypeElement t : types.values()) {
                  for (FieldElement f : t.fields) {
                      if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
                          if (!types.containsKey(f.typeName)) {
<span class="line-modified">!                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);</span>
                          }
                      }
                  }
              }
          }
  
          void wireUpTypes() {
              for (TypeElement t : types.values()) {
                  for (FieldElement f : t.fields) {
                      TypeElement type = types.get(f.typeName);
                      if (f.struct) {
                          type.supportStruct = true;
                      }
                      f.type = type;
                  }
              }
          }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     static class EventElement extends TypeElement {</span>
<span class="line-modified">!         String representation;</span>
<span class="line-modified">!         boolean thread;</span>
<span class="line-modified">!         boolean stackTrace;</span>
<span class="line-modified">!         boolean startTime;</span>
<span class="line-modified">!         boolean periodic;</span>
<span class="line-modified">!         boolean cutoff;</span>
<span class="line-modified">!         String commitState;</span>
      }
  
      static class FieldElement {
          final Metadata metadata;
          TypeElement type;
          String name;
          String typeName;
<span class="line-modified">!         boolean struct;</span>
  
          FieldElement(Metadata metadata) {
              this.metadata = metadata;
          }
  
          String getParameterType() {
              if (struct) {
                  return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
              }
              XmlType xmlType = metadata.xmlTypes.get(typeName);
<span class="line-new-header">--- 261,163 ---</span>
                  }
              }
              return result;
          }
  
<span class="line-modified">!         List&lt;TypeElement&gt; getPeriodicEvents() {</span>
<span class="line-modified">!             return getList(t -&gt; t.isEvent &amp;&amp; !t.period.isEmpty());</span>
          }
  
          List&lt;TypeElement&gt; getTypes() {
<span class="line-modified">!             return getList(t -&gt; !t.isEvent);</span>
          }
  
          List&lt;TypeElement&gt; getStructs() {
<span class="line-modified">!             return getList(t -&gt; !t.isEvent &amp;&amp; t.supportStruct);</span>
          }
  
<span class="line-modified">!         void verify() {</span>
              for (TypeElement t : types.values()) {
                  for (FieldElement f : t.fields) {
                      if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
                          if (!types.containsKey(f.typeName)) {
<span class="line-modified">!                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName</span>
<span class="line-added">+                                     + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);</span>
                          }
                      }
                  }
              }
          }
  
          void wireUpTypes() {
<span class="line-added">+             // Add Java primitives</span>
<span class="line-added">+             for (var t : xmlTypes.entrySet()) {</span>
<span class="line-added">+                 String name = t.getKey();</span>
<span class="line-added">+                 XmlType xmlType = t.getValue();</span>
<span class="line-added">+                 // Excludes Thread and Class</span>
<span class="line-added">+                 if (!types.containsKey(name)) {</span>
<span class="line-added">+                     // Excludes u8, u4, u2, u1, Ticks and Ticksspan</span>
<span class="line-added">+                     if (!xmlType.javaType.isEmpty() &amp;&amp; !xmlType.unsigned) {</span>
<span class="line-added">+                         TypeElement te = new TypeElement();</span>
<span class="line-added">+                         te.name = name;</span>
<span class="line-added">+                         te.javaType = xmlType.javaType;</span>
<span class="line-added">+                         te.primitive = true;</span>
<span class="line-added">+                         types.put(te.name, te);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Setup Java fully qualified names</span>
<span class="line-added">+             for (TypeElement t : types.values()) {</span>
<span class="line-added">+                 if (t.isEvent) {</span>
<span class="line-added">+                     t.javaType = &quot;jdk.&quot; + t.name;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     XmlType xmlType = xmlTypes.get(t.name);</span>
<span class="line-added">+                     if (xmlType != null &amp;&amp; !xmlType.javaType.isEmpty()) {</span>
<span class="line-added">+                         t.javaType = xmlType.javaType;</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         t.javaType = &quot;jdk.types.&quot; + t.name;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Setup content type, annotation, constant pool etc. for fields.</span>
              for (TypeElement t : types.values()) {
                  for (FieldElement f : t.fields) {
                      TypeElement type = types.get(f.typeName);
<span class="line-added">+                     XmlType xmlType = xmlTypes.get(f.typeName);</span>
<span class="line-added">+                     if (type == null) {</span>
<span class="line-added">+                         if (xmlType == null) {</span>
<span class="line-added">+                             throw new IllegalStateException(&quot;Unknown type&quot;);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         if (f.contentType.isEmpty()) {</span>
<span class="line-added">+                             f.contentType = xmlType.contentType;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         String javaType = xmlType.javaType;</span>
<span class="line-added">+                         type = types.get(javaType);</span>
<span class="line-added">+                         Objects.requireNonNull(type);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (type.primitive) {</span>
<span class="line-added">+                         f.constantPool = false;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (xmlType != null) {</span>
<span class="line-added">+                         f.unsigned = xmlType.unsigned;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
                      if (f.struct) {
<span class="line-added">+                         f.constantPool = false;</span>
                          type.supportStruct = true;
                      }
                      f.type = type;
<span class="line-added">+                     XmlContentType xmlContentType = xmlContentTypes.get(f.contentType);</span>
<span class="line-added">+                     if (xmlContentType == null) {</span>
<span class="line-added">+                         f.annotations = &quot;&quot;;</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         f.annotations = xmlContentType.annotation;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (!f.relation.isEmpty()) {</span>
<span class="line-added">+                         f.relation = &quot;jdk.types.&quot; + f.relation;</span>
<span class="line-added">+                     }</span>
                  }
              }
<span class="line-added">+ </span>
<span class="line-added">+             // Low numbers for event so most of them</span>
<span class="line-added">+             // can fit in one byte with compressed integers</span>
<span class="line-added">+             eventCounter = new TypeCounter(RESERVED_EVENT_COUNT);</span>
<span class="line-added">+             for (TypeElement t : getEvents()) {</span>
<span class="line-added">+                 t.id = eventCounter.next();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             typeCounter = new TypeCounter(eventCounter.last + 1);</span>
<span class="line-added">+             for (TypeElement t : getTypes()) {</span>
<span class="line-added">+                 t.id = typeCounter.next();</span>
<span class="line-added">+             }</span>
          }
  
<span class="line-modified">!         public String getName(long id) {</span>
<span class="line-modified">!             for (TypeElement t : types.values()) {</span>
<span class="line-modified">!                 if (t.id == id) {</span>
<span class="line-modified">!                     return t.name;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             throw new IllegalStateException(&quot;Unexpected id &quot; + id );</span>
<span class="line-modified">!         }</span>
      }
  
      static class FieldElement {
          final Metadata metadata;
          TypeElement type;
          String name;
          String typeName;
<span class="line-modified">!         boolean constantPool = true;</span>
<span class="line-added">+         public String transition;</span>
<span class="line-added">+         public String contentType;</span>
<span class="line-added">+         private String label;</span>
<span class="line-added">+         private String description;</span>
<span class="line-added">+         private String relation;</span>
<span class="line-added">+         private boolean experimental;</span>
<span class="line-added">+         private boolean unsigned;</span>
<span class="line-added">+         private boolean array;</span>
<span class="line-added">+         private String annotations;</span>
<span class="line-added">+         public boolean struct;</span>
  
          FieldElement(Metadata metadata) {
              this.metadata = metadata;
          }
  
<span class="line-added">+         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-added">+             pos.writeUTF(name);</span>
<span class="line-added">+             pos.writeUTF(type.javaType);</span>
<span class="line-added">+             pos.writeUTF(label);</span>
<span class="line-added">+             pos.writeUTF(description);</span>
<span class="line-added">+             pos.writeBoolean(constantPool);</span>
<span class="line-added">+             pos.writeBoolean(array);</span>
<span class="line-added">+             pos.writeBoolean(unsigned);</span>
<span class="line-added">+             pos.writeUTF(annotations);</span>
<span class="line-added">+             pos.writeUTF(transition);</span>
<span class="line-added">+             pos.writeUTF(relation);</span>
<span class="line-added">+             pos.writeBoolean(experimental);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          String getParameterType() {
              if (struct) {
                  return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
              }
              XmlType xmlType = metadata.xmlTypes.get(typeName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,54 ***</span>
  
      static class MetadataHandler extends DefaultHandler {
          final Metadata metadata;
          FieldElement currentField;
          TypeElement currentType;
          MetadataHandler(Metadata metadata) {
              this.metadata = metadata;
          }
          @Override
          public void error(SAXParseException e) throws SAXException {
<span class="line-modified">!           throw e;</span>
          }
          @Override
<span class="line-modified">!         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {</span>
              switch (qName) {
              case &quot;XmlType&quot;:
<span class="line-modified">!                 String name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">!                 String parameterType = attributes.getValue(&quot;parameterType&quot;);</span>
<span class="line-modified">!                 String fieldType = attributes.getValue(&quot;fieldType&quot;);</span>
<span class="line-modified">!                 String javaType = attributes.getValue(&quot;javaType&quot;);</span>
                  boolean unsigned = getBoolean(attributes, &quot;unsigned&quot;, false);
<span class="line-modified">!                 metadata.xmlTypes.put(name, new XmlType(name, fieldType, parameterType, javaType, unsigned));</span>
                  break;
              case &quot;Relation&quot;:
              case &quot;Type&quot;:
<span class="line-removed">-                 currentType = new TypeElement();</span>
<span class="line-removed">-                 currentType.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-removed">-                 break;</span>
              case &quot;Event&quot;:
<span class="line-modified">!                 EventElement eventType = new EventElement();</span>
<span class="line-modified">!                 eventType.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">!                 eventType.thread = getBoolean(attributes, &quot;thread&quot;, false);</span>
<span class="line-modified">!                 eventType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);</span>
<span class="line-modified">!                 eventType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);</span>
<span class="line-modified">!                 eventType.periodic = attributes.getValue(&quot;period&quot;) != null;</span>
<span class="line-modified">!                 eventType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);</span>
<span class="line-modified">!                 eventType.commitState = attributes.getValue(&quot;commitState&quot;);</span>
<span class="line-modified">!                 currentType = eventType;</span>
                  break;
              case &quot;Field&quot;:
                  currentField = new FieldElement(metadata);
                  currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
<span class="line-modified">!                 currentField.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">!                 currentField.typeName = attributes.getValue(&quot;type&quot;);</span>
                  break;
              }
          }
  
<span class="line-modified">!         private boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {</span>
              String value = attributes.getValue(name);
              return value == null ? defaultValue : Boolean.valueOf(value);
          }
  
          @Override
<span class="line-new-header">--- 445,79 ---</span>
  
      static class MetadataHandler extends DefaultHandler {
          final Metadata metadata;
          FieldElement currentField;
          TypeElement currentType;
<span class="line-added">+ </span>
          MetadataHandler(Metadata metadata) {
              this.metadata = metadata;
          }
<span class="line-added">+ </span>
          @Override
          public void error(SAXParseException e) throws SAXException {
<span class="line-modified">!             throw e;</span>
          }
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public void startElement(String uri, String localName, String qName, Attributes attributes)</span>
<span class="line-added">+                 throws SAXException {</span>
              switch (qName) {
<span class="line-added">+             case &quot;XmlContentType&quot;:</span>
<span class="line-added">+                 String n = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-added">+                 String a = attributes.getValue(&quot;annotation&quot;); // mandatory</span>
<span class="line-added">+                 metadata.xmlContentTypes.put(n, new XmlContentType(n, a));</span>
<span class="line-added">+                 break;</span>
              case &quot;XmlType&quot;:
<span class="line-modified">!                 String name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-modified">!                 String parameterType = attributes.getValue(&quot;parameterType&quot;); // mandatory</span>
<span class="line-modified">!                 String fieldType = attributes.getValue(&quot;fieldType&quot;); // mandatory</span>
<span class="line-modified">!                 String javaType = getString(attributes, &quot;javaType&quot;);</span>
<span class="line-added">+                 String contentType = getString(attributes, &quot;contentType&quot;);</span>
                  boolean unsigned = getBoolean(attributes, &quot;unsigned&quot;, false);
<span class="line-modified">!                 metadata.xmlTypes.put(name,</span>
<span class="line-added">+                         new XmlType(name, fieldType, parameterType, javaType, contentType, unsigned));</span>
                  break;
              case &quot;Relation&quot;:
              case &quot;Type&quot;:
              case &quot;Event&quot;:
<span class="line-modified">!                 currentType = new TypeElement();</span>
<span class="line-modified">!                 currentType.name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-modified">!                 currentType.label = getString(attributes, &quot;label&quot;);</span>
<span class="line-modified">!                 currentType.description = getString(attributes, &quot;description&quot;);</span>
<span class="line-modified">!                 currentType.category = getString(attributes, &quot;category&quot;);</span>
<span class="line-modified">!                 currentType.experimental = getBoolean(attributes, &quot;experimental&quot;, false);</span>
<span class="line-modified">!                 currentType.thread = getBoolean(attributes, &quot;thread&quot;, false);</span>
<span class="line-modified">!                 currentType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);</span>
<span class="line-modified">!                 currentType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);</span>
<span class="line-added">+                 currentType.period = getString(attributes, &quot;period&quot;);</span>
<span class="line-added">+                 currentType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);</span>
<span class="line-added">+                 currentType.commitState = getString(attributes, &quot;commitState&quot;);</span>
<span class="line-added">+                 currentType.isEvent = &quot;Event&quot;.equals(qName);</span>
<span class="line-added">+                 currentType.isRelation = &quot;Relation&quot;.equals(qName);</span>
                  break;
              case &quot;Field&quot;:
                  currentField = new FieldElement(metadata);
<span class="line-added">+                 currentField.name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-added">+                 currentField.typeName = attributes.getValue(&quot;type&quot;); // mandatory</span>
<span class="line-added">+                 currentField.label = getString(attributes, &quot;label&quot;);</span>
<span class="line-added">+                 currentField.description = getString(attributes, &quot;description&quot;);</span>
<span class="line-added">+                 currentField.contentType = getString(attributes, &quot;contentType&quot;);</span>
                  currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
<span class="line-modified">!                 currentField.array = getBoolean(attributes, &quot;array&quot;, false);</span>
<span class="line-modified">!                 currentField.transition = getString(attributes, &quot;transition&quot;);</span>
<span class="line-added">+                 currentField.relation = getString(attributes, &quot;relation&quot;);</span>
<span class="line-added">+                 currentField.experimental = getBoolean(attributes, &quot;experimental&quot;, false);</span>
                  break;
              }
          }
  
<span class="line-modified">!         private static String getString(Attributes attributes, String name) {</span>
<span class="line-added">+             String value = attributes.getValue(name);</span>
<span class="line-added">+             return value != null ? value : &quot;&quot;;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {</span>
              String value = attributes.getValue(name);
              return value == null ? defaultValue : Boolean.valueOf(value);
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,31 ***</span>
                  break;
              }
          }
      }
  
<span class="line-modified">!     static class Printer implements AutoCloseable {</span>
          final PrintStream out;
<span class="line-modified">!         Printer(File outputDirectory, String filename) throws FileNotFoundException {</span>
<span class="line-modified">!             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(outputDirectory, filename))));</span>
              write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
              write(&quot;&quot;);
          }
  
          void write(String text) {
              out.print(text);
              out.print(&quot;\n&quot;); // Don&#39;t use Windows line endings
          }
  
          @Override
<span class="line-modified">!         public void close() throws Exception {</span>
              out.close();
          }
      }
  
<span class="line-modified">!     private static void printJfrPeriodicHpp(Metadata metadata, File outputDirectory) throws Exception {</span>
<span class="line-modified">!         try (Printer out = new Printer(outputDirectory, &quot;jfrPeriodic.hpp&quot;)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
<span class="line-new-header">--- 535,32 ---</span>
                  break;
              }
          }
      }
  
<span class="line-modified">!     static class Printer implements Closeable {</span>
          final PrintStream out;
<span class="line-modified">! </span>
<span class="line-modified">!         Printer(File outputFile) throws FileNotFoundException {</span>
<span class="line-added">+             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(outputFile)));</span>
              write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
              write(&quot;&quot;);
          }
  
          void write(String text) {
              out.print(text);
              out.print(&quot;\n&quot;); // Don&#39;t use Windows line endings
          }
  
          @Override
<span class="line-modified">!         public void close() throws IOException {</span>
              out.close();
          }
      }
  
<span class="line-modified">!     private static void printJfrPeriodicHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">!         try (var out = new Printer(outputFile)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,11 ***</span>
              out.write(&quot;class JfrPeriodicEventSet : public AllStatic {&quot;);
              out.write(&quot; public:&quot;);
              out.write(&quot;  static void requestEvent(JfrEventId id) {&quot;);
              out.write(&quot;    switch(id) {&quot;);
              out.write(&quot;  &quot;);
<span class="line-modified">!             for (EventElement e : metadata.getPeriodicEvents()) {</span>
                  out.write(&quot;      case Jfr&quot; + e.name + &quot;Event:&quot;);
                  out.write(&quot;        request&quot; + e.name + &quot;();&quot;);
                  out.write(&quot;        break;&quot;);
                  out.write(&quot;  &quot;);
              }
<span class="line-new-header">--- 570,11 ---</span>
              out.write(&quot;class JfrPeriodicEventSet : public AllStatic {&quot;);
              out.write(&quot; public:&quot;);
              out.write(&quot;  static void requestEvent(JfrEventId id) {&quot;);
              out.write(&quot;    switch(id) {&quot;);
              out.write(&quot;  &quot;);
<span class="line-modified">!             for (TypeElement e : metadata.getPeriodicEvents()) {</span>
                  out.write(&quot;      case Jfr&quot; + e.name + &quot;Event:&quot;);
                  out.write(&quot;        request&quot; + e.name + &quot;();&quot;);
                  out.write(&quot;        break;&quot;);
                  out.write(&quot;  &quot;);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 372,23 ***</span>
              out.write(&quot;      }&quot;);
              out.write(&quot;    }&quot;);
              out.write(&quot;&quot;);
              out.write(&quot; private:&quot;);
              out.write(&quot;&quot;);
<span class="line-modified">!             for (EventElement e : metadata.getPeriodicEvents()) {</span>
                  out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
                  out.write(&quot;&quot;);
              }
              out.write(&quot;};&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
          }
      }
  
<span class="line-modified">!     private static void printJfrEventControlHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
<span class="line-modified">!         try (Printer out = new Printer(outputDirectory, &quot;jfrEventControl.hpp&quot;)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
<span class="line-new-header">--- 583,23 ---</span>
              out.write(&quot;      }&quot;);
              out.write(&quot;    }&quot;);
              out.write(&quot;&quot;);
              out.write(&quot; private:&quot;);
              out.write(&quot;&quot;);
<span class="line-modified">!             for (TypeElement e : metadata.getPeriodicEvents()) {</span>
                  out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
                  out.write(&quot;&quot;);
              }
              out.write(&quot;};&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
          }
      }
  
<span class="line-modified">!     private static void printJfrEventControlHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">!         try (var out = new Printer(outputFile)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,79 ***</span>
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
          }
      }
  
<span class="line-modified">!     private static void printJfrEventIdsHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
<span class="line-modified">!         try (Printer out = new Printer(outputDirectory, &quot;jfrEventIds.hpp&quot;)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;enum JfrEventId {&quot;);
              out.write(&quot;  JfrMetadataEvent = 0,&quot;);
              out.write(&quot;  JfrCheckpointEvent = 1,&quot;);
              for (TypeElement t : metadata.getEvents()) {
<span class="line-modified">!                 String name = &quot;Jfr&quot; + t.name +&quot;Event&quot;;</span>
<span class="line-removed">-                 out.write(&quot;  &quot; + name + &quot; = &quot; + typeCounter.nextEventId(name) + &quot;,&quot;);</span>
              }
              out.write(&quot;};&quot;);
              out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
              out.write(&quot;&quot;);
<span class="line-modified">!             out.write(&quot;static const JfrEventId FIRST_EVENT_ID = &quot; + typeCounter.firstEventName() + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;static const JfrEventId LAST_EVENT_ID = &quot; + typeCounter.lastEventName() + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;static const int NUMBER_OF_EVENTS = &quot; + typeCounter.eventCount() + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;static const int NUMBER_OF_RESERVED_EVENTS = &quot; + TypeCounter.RESERVED_EVENT_COUNT + &quot;;&quot;);</span>
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
          }
      }
  
<span class="line-modified">!     private static void printJfrTypesHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
<span class="line-modified">!         try (Printer out = new Printer(outputDirectory, &quot;jfrTypes.hpp&quot;)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include &lt;string.h&gt;&quot;);
              out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;enum JfrTypeId {&quot;);
<span class="line-removed">-             Map&lt;String, XmlType&gt; javaTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-removed">-             for (var t : metadata.xmlTypes.entrySet()) {</span>
<span class="line-removed">-                 String name = t.getKey();</span>
<span class="line-removed">-                 XmlType xmlType = t.getValue();</span>
<span class="line-removed">-                 if (xmlType.javaType != null &amp;&amp; !xmlType.unsigned) {</span>
<span class="line-removed">-                     String typeName = &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-removed">-                     long typeId = typeCounter.nextTypeId(typeName);</span>
<span class="line-removed">-                     out.write(&quot;  &quot; + typeName + &quot; = &quot; + typeId + &quot;,&quot;);</span>
<span class="line-removed">-                     javaTypes.put(name, xmlType);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
              for (TypeElement type : metadata.getTypes()) {
<span class="line-modified">!                 String name = type.name;</span>
<span class="line-removed">-                 if (!javaTypes.containsKey(name)) {</span>
<span class="line-removed">-                     String typeName = &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-removed">-                     long typeId = typeCounter.nextTypeId(typeName);</span>
<span class="line-removed">-                     out.write(&quot;  &quot; + typeName + &quot; = &quot; + typeId + &quot;,&quot;);</span>
<span class="line-removed">-                 }</span>
              }
              out.write(&quot;};&quot;);
              out.write(&quot;&quot;);
<span class="line-modified">!             out.write(&quot;static const JfrTypeId FIRST_TYPE_ID = &quot; + typeCounter.firstTypeName() + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;static const JfrTypeId LAST_TYPE_ID = &quot; + typeCounter.lastTypeName() + &quot;;&quot;);</span>
<span class="line-modified">! </span>
              out.write(&quot;&quot;);
              out.write(&quot;class JfrType : public AllStatic {&quot;);
              out.write(&quot; public:&quot;);
              out.write(&quot;  static jlong name_to_id(const char* type_name) {&quot;);
<span class="line-modified">!             for (Entry&lt;String, XmlType&gt; m : javaTypes.entrySet()) {</span>
<span class="line-modified">!                 XmlType xmlType = m.getValue();</span>
                  String javaName = xmlType.javaType;
                  String typeName = xmlType.name.toUpperCase();
                  out.write(&quot;    if (strcmp(type_name, \&quot;&quot; + javaName + &quot;\&quot;) == 0) {&quot;);
                  out.write(&quot;      return TYPE_&quot; + typeName + &quot;;&quot;);
                  out.write(&quot;    }&quot;);
<span class="line-new-header">--- 635,75 ---</span>
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
          }
      }
  
<span class="line-modified">!     private static void printJfrEventIdsHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">!         try (var out = new Printer(outputFile)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;enum JfrEventId {&quot;);
              out.write(&quot;  JfrMetadataEvent = 0,&quot;);
              out.write(&quot;  JfrCheckpointEvent = 1,&quot;);
              for (TypeElement t : metadata.getEvents()) {
<span class="line-modified">!                 out.write(&quot;  &quot; + jfrEventId(t.name) + &quot; = &quot; + t.id + &quot;,&quot;);</span>
              }
              out.write(&quot;};&quot;);
              out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
              out.write(&quot;&quot;);
<span class="line-modified">!             String first = metadata.getName(metadata.eventCounter.first);</span>
<span class="line-modified">!             String last = metadata.getName(metadata.eventCounter.last);</span>
<span class="line-modified">!             out.write(&quot;static const JfrEventId FIRST_EVENT_ID = &quot; + jfrEventId(first) + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;static const JfrEventId LAST_EVENT_ID = &quot; + jfrEventId(last) + &quot;;&quot;);</span>
<span class="line-added">+             out.write(&quot;static const int NUMBER_OF_EVENTS = &quot; + metadata.eventCounter.count + &quot;;&quot;);</span>
<span class="line-added">+             out.write(&quot;static const int NUMBER_OF_RESERVED_EVENTS = &quot; + Metadata.RESERVED_EVENT_COUNT + &quot;;&quot;);</span>
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
          }
      }
  
<span class="line-modified">!     private static String jfrEventId(String name) {</span>
<span class="line-modified">!         return &quot;Jfr&quot; + name + &quot;Event&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static void printJfrTypesHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-added">+         try (var out = new Printer(outputFile)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
              out.write(&quot;#if INCLUDE_JFR&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include &lt;string.h&gt;&quot;);
              out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;enum JfrTypeId {&quot;);
              for (TypeElement type : metadata.getTypes()) {
<span class="line-modified">!                 out.write(&quot;  &quot; + jfrTypeId(type.name) + &quot; = &quot; + type.id + &quot;,&quot;);</span>
              }
              out.write(&quot;};&quot;);
              out.write(&quot;&quot;);
<span class="line-modified">!             String first = metadata.getName(metadata.typeCounter.first);</span>
<span class="line-modified">!             String last = metadata.getName(metadata.typeCounter.last);</span>
<span class="line-modified">!             out.write(&quot;static const JfrTypeId FIRST_TYPE_ID = &quot; + jfrTypeId(first) + &quot;;&quot;);</span>
<span class="line-added">+             out.write(&quot;static const JfrTypeId LAST_TYPE_ID = &quot; + jfrTypeId(last) + &quot;;&quot;);</span>
              out.write(&quot;&quot;);
              out.write(&quot;class JfrType : public AllStatic {&quot;);
              out.write(&quot; public:&quot;);
              out.write(&quot;  static jlong name_to_id(const char* type_name) {&quot;);
<span class="line-modified">! </span>
<span class="line-modified">!             Map&lt;String, XmlType&gt; javaTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-added">+             for (XmlType xmlType : metadata.xmlTypes.values()) {</span>
<span class="line-added">+                 if (!xmlType.javaType.isEmpty()) {</span>
<span class="line-added">+                     javaTypes.put(xmlType.javaType, xmlType);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             for (XmlType xmlType : javaTypes.values()) {</span>
                  String javaName = xmlType.javaType;
                  String typeName = xmlType.name.toUpperCase();
                  out.write(&quot;    if (strcmp(type_name, \&quot;&quot; + javaName + &quot;\&quot;) == 0) {&quot;);
                  out.write(&quot;      return TYPE_&quot; + typeName + &quot;;&quot;);
                  out.write(&quot;    }&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 506,15 ***</span>
              out.write(&quot;};&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
          }
<span class="line-removed">-         ;</span>
      }
  
<span class="line-modified">!     private static void printJfrEventClassesHpp(Metadata metadata, File outputDirectory) throws Exception {</span>
<span class="line-modified">!         try (Printer out = new Printer(outputDirectory, &quot;jfrEventClasses.hpp&quot;)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
              out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
<span class="line-new-header">--- 713,18 ---</span>
              out.write(&quot;};&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#endif // INCLUDE_JFR&quot;);
              out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
          }
      }
  
<span class="line-modified">!     private static String jfrTypeId(String name) {</span>
<span class="line-modified">!         return  &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static void printJfrEventClassesHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-added">+         try (var out = new Printer(outputFile)) {</span>
              out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
              out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
              out.write(&quot;&quot;);
              out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
              out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 564,95 ***</span>
      private static void printTypes(Printer out, Metadata metadata, boolean empty) {
          for (TypeElement t : metadata.getStructs()) {
              printType(out, t, empty);
              out.write(&quot;&quot;);
          }
<span class="line-modified">!         for (EventElement e : metadata.getEvents()) {</span>
              printEvent(out, e, empty);
              out.write(&quot;&quot;);
          }
      }
  
      private static void printType(Printer out, TypeElement t, boolean empty) {
          out.write(&quot;struct JfrStruct&quot; + t.name);
          out.write(&quot;{&quot;);
          if (!empty) {
<span class="line-modified">!           out.write(&quot; private:&quot;);</span>
<span class="line-modified">!           for (FieldElement f : t.fields) {</span>
<span class="line-modified">!               printField(out, f);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           out.write(&quot;&quot;);</span>
          }
          out.write(&quot; public:&quot;);
          for (FieldElement f : t.fields) {
<span class="line-modified">!            printTypeSetter(out, f, empty);</span>
          }
          out.write(&quot;&quot;);
          if (!empty) {
<span class="line-modified">!           printWriteData(out, t.fields, null);</span>
          }
          out.write(&quot;};&quot;);
          out.write(&quot;&quot;);
      }
  
<span class="line-modified">!     private static void printEvent(Printer out, EventElement event, boolean empty) {</span>
          out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
          out.write(&quot;{&quot;);
          if (!empty) {
<span class="line-modified">!           out.write(&quot; private:&quot;);</span>
<span class="line-modified">!           for (FieldElement f : event.fields) {</span>
<span class="line-modified">!               printField(out, f);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           out.write(&quot;&quot;);</span>
          }
          out.write(&quot; public:&quot;);
          if (!empty) {
<span class="line-modified">!           out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);</span>
<span class="line-modified">!           out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);</span>
<span class="line-modified">!           out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);</span>
<span class="line-modified">!           out.write(&quot;  static const bool hasCutoff = &quot; + event.cutoff + &quot;;&quot;);</span>
<span class="line-modified">!           out.write(&quot;  static const bool isRequestable = &quot; + event.periodic + &quot;;&quot;);</span>
<span class="line-modified">!           out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);</span>
<span class="line-modified">!           out.write(&quot;&quot;);</span>
          }
          if (!empty) {
<span class="line-modified">!           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(timing) {}&quot;);</span>
          } else {
<span class="line-modified">!           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);</span>
          }
          out.write(&quot;&quot;);
          int index = 0;
          for (FieldElement f : event.fields) {
              out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
              if (!empty) {
<span class="line-modified">!               out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);</span>
<span class="line-modified">!               out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);</span>
              }
              out.write(&quot;  }&quot;);
          }
          out.write(&quot;&quot;);
          if (!empty) {
<span class="line-modified">!           printWriteData(out, event.fields, event.commitState);</span>
<span class="line-modified">!           out.write(&quot;&quot;);</span>
          }
<span class="line-modified">!         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);</span>
          printConstructor2(out, event, empty);
          printCommitMethod(out, event, empty);
          if (!empty) {
<span class="line-modified">!           printVerify(out, event.fields);</span>
          }
          out.write(&quot;};&quot;);
      }
  
<span class="line-modified">!     private static void printWriteData(Printer out, List&lt;FieldElement&gt; fields, String commitState) {</span>
          out.write(&quot;  template &lt;typename Writer&gt;&quot;);
          out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
<span class="line-modified">!         if ((&quot;_thread_in_native&quot;).equals(commitState)) {</span>
              out.write(&quot;    // explicit epoch synchronization check&quot;);
              out.write(&quot;    JfrEpochSynchronization sync;&quot;);
          }
<span class="line-modified">!         for (FieldElement field : fields) {</span>
              if (field.struct) {
                  out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
              } else {
                  out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
              }
<span class="line-new-header">--- 774,97 ---</span>
      private static void printTypes(Printer out, Metadata metadata, boolean empty) {
          for (TypeElement t : metadata.getStructs()) {
              printType(out, t, empty);
              out.write(&quot;&quot;);
          }
<span class="line-modified">!         for (TypeElement e : metadata.getEvents()) {</span>
              printEvent(out, e, empty);
              out.write(&quot;&quot;);
          }
      }
  
      private static void printType(Printer out, TypeElement t, boolean empty) {
          out.write(&quot;struct JfrStruct&quot; + t.name);
          out.write(&quot;{&quot;);
          if (!empty) {
<span class="line-modified">!             out.write(&quot; private:&quot;);</span>
<span class="line-modified">!             for (FieldElement f : t.fields) {</span>
<span class="line-modified">!                 printField(out, f);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             out.write(&quot;&quot;);</span>
          }
          out.write(&quot; public:&quot;);
          for (FieldElement f : t.fields) {
<span class="line-modified">!             printTypeSetter(out, f, empty);</span>
          }
          out.write(&quot;&quot;);
          if (!empty) {
<span class="line-modified">!             printWriteData(out, t);</span>
          }
          out.write(&quot;};&quot;);
          out.write(&quot;&quot;);
      }
  
<span class="line-modified">!     private static void printEvent(Printer out, TypeElement event, boolean empty) {</span>
          out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
          out.write(&quot;{&quot;);
          if (!empty) {
<span class="line-modified">!             out.write(&quot; private:&quot;);</span>
<span class="line-modified">!             for (FieldElement f : event.fields) {</span>
<span class="line-modified">!                 printField(out, f);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             out.write(&quot;&quot;);</span>
          }
          out.write(&quot; public:&quot;);
          if (!empty) {
<span class="line-modified">!             out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;  static const bool hasCutoff = &quot; + event.cutoff + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;  static const bool isRequestable = &quot; + !event.period.isEmpty() + &quot;;&quot;);</span>
<span class="line-modified">!             out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);</span>
<span class="line-modified">!             out.write(&quot;&quot;);</span>
          }
          if (!empty) {
<span class="line-modified">!             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name</span>
<span class="line-added">+                     + &quot;&gt;(timing) {}&quot;);</span>
          } else {
<span class="line-modified">!             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);</span>
          }
          out.write(&quot;&quot;);
          int index = 0;
          for (FieldElement f : event.fields) {
              out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
              if (!empty) {
<span class="line-modified">!                 out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);</span>
<span class="line-modified">!                 out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);</span>
              }
              out.write(&quot;  }&quot;);
          }
          out.write(&quot;&quot;);
          if (!empty) {
<span class="line-modified">!             printWriteData(out, event);</span>
<span class="line-modified">!             out.write(&quot;&quot;);</span>
          }
<span class="line-modified">!         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name</span>
<span class="line-added">+                 + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);</span>
          printConstructor2(out, event, empty);
          printCommitMethod(out, event, empty);
          if (!empty) {
<span class="line-modified">!             printVerify(out, event.fields);</span>
          }
          out.write(&quot;};&quot;);
      }
  
<span class="line-modified">!     private static void printWriteData(Printer out, TypeElement type) {</span>
          out.write(&quot;  template &lt;typename Writer&gt;&quot;);
          out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
<span class="line-modified">!         if ((&quot;_thread_in_native&quot;).equals(type.commitState)) {</span>
              out.write(&quot;    // explicit epoch synchronization check&quot;);
              out.write(&quot;    JfrEpochSynchronization sync;&quot;);
          }
<span class="line-modified">!         for (FieldElement field : type.fields) {</span>
              if (field.struct) {
                  out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
              } else {
                  out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 660,43 ***</span>
          out.write(&quot;  }&quot;);
      }
  
      private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
          if (!empty) {
<span class="line-modified">!           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name + &quot; = new_value; }&quot;);</span>
          } else {
<span class="line-modified">!           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);</span>
          }
      }
  
      private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
          out.write(&quot;&quot;);
          out.write(&quot;#ifdef ASSERT&quot;);
          out.write(&quot;  void verify() const {&quot;);
          int index = 0;
          for (FieldElement f : fields) {
<span class="line-modified">!             out.write(&quot;    assert(verify_field_bit(&quot; + index++ + &quot;), \&quot;Attempting to write an uninitialized event field: %s\&quot;, \&quot;_&quot; + f.name + &quot;\&quot;);&quot;);</span>
          }
          out.write(&quot;  }&quot;);
          out.write(&quot;#endif&quot;);
      }
  
<span class="line-modified">!     private static void printCommitMethod(Printer out, EventElement event, boolean empty) {</span>
          if (event.startTime) {
              StringJoiner sj = new StringJoiner(&quot;,\n              &quot;);
              for (FieldElement f : event.fields) {
                  sj.add(f.getParameterType() + &quot; &quot; + f.name);
              }
              out.write(&quot;&quot;);
              out.write(&quot;  void commit(&quot; + sj.toString() + &quot;) {&quot;);
              if (!empty) {
<span class="line-modified">!               out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">!               for (FieldElement f : event.fields) {</span>
<span class="line-modified">!                   out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">!               }</span>
<span class="line-modified">!               out.write(&quot;      commit();&quot;);</span>
<span class="line-modified">!               out.write(&quot;    }&quot;);</span>
              }
              out.write(&quot;  }&quot;);
          }
  
          // Avoid clash with static commit() method
<span class="line-new-header">--- 872,45 ---</span>
          out.write(&quot;  }&quot;);
      }
  
      private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
          if (!empty) {
<span class="line-modified">!             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name</span>
<span class="line-added">+                     + &quot; = new_value; }&quot;);</span>
          } else {
<span class="line-modified">!             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);</span>
          }
      }
  
      private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
          out.write(&quot;&quot;);
          out.write(&quot;#ifdef ASSERT&quot;);
          out.write(&quot;  void verify() const {&quot;);
          int index = 0;
          for (FieldElement f : fields) {
<span class="line-modified">!             out.write(&quot;    assert(verify_field_bit(&quot; + index++</span>
<span class="line-added">+                     + &quot;), \&quot;Attempting to write an uninitialized event field: %s\&quot;, \&quot;_&quot; + f.name + &quot;\&quot;);&quot;);</span>
          }
          out.write(&quot;  }&quot;);
          out.write(&quot;#endif&quot;);
      }
  
<span class="line-modified">!     private static void printCommitMethod(Printer out, TypeElement event, boolean empty) {</span>
          if (event.startTime) {
              StringJoiner sj = new StringJoiner(&quot;,\n              &quot;);
              for (FieldElement f : event.fields) {
                  sj.add(f.getParameterType() + &quot; &quot; + f.name);
              }
              out.write(&quot;&quot;);
              out.write(&quot;  void commit(&quot; + sj.toString() + &quot;) {&quot;);
              if (!empty) {
<span class="line-modified">!                 out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">!                 for (FieldElement f : event.fields) {</span>
<span class="line-modified">!                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 out.write(&quot;      commit();&quot;);</span>
<span class="line-modified">!                 out.write(&quot;    }&quot;);</span>
              }
              out.write(&quot;  }&quot;);
          }
  
          // Avoid clash with static commit() method
</pre>
<hr />
<pre>
<span class="line-old-header">*** 713,27 ***</span>
          for (FieldElement f : event.fields) {
              sj.add(f.getParameterType() + &quot; &quot; + f.name);
          }
          out.write(&quot;  static void commit(&quot; + sj.toString() + &quot;) {&quot;);
          if (!empty) {
<span class="line-modified">!           out.write(&quot;    Event&quot; + event.name + &quot; me(UNTIMED);&quot;);</span>
<span class="line-modified">!           out.write(&quot;&quot;);</span>
<span class="line-modified">!           out.write(&quot;    if (me.should_commit()) {&quot;);</span>
<span class="line-modified">!           if (event.startTime) {</span>
<span class="line-modified">!               out.write(&quot;      me.set_starttime(startTicks);&quot;);</span>
<span class="line-modified">!               out.write(&quot;      me.set_endtime(endTicks);&quot;);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           for (FieldElement f : event.fields) {</span>
<span class="line-modified">!               out.write(&quot;      me.set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           out.write(&quot;      me.commit();&quot;);</span>
<span class="line-modified">!           out.write(&quot;    }&quot;);</span>
          }
          out.write(&quot;  }&quot;);
      }
  
<span class="line-modified">!     private static void printConstructor2(Printer out, EventElement event, boolean empty) {</span>
          if (!event.startTime) {
              out.write(&quot;&quot;);
              out.write(&quot;&quot;);
          }
          if (event.startTime) {
<span class="line-new-header">--- 927,27 ---</span>
          for (FieldElement f : event.fields) {
              sj.add(f.getParameterType() + &quot; &quot; + f.name);
          }
          out.write(&quot;  static void commit(&quot; + sj.toString() + &quot;) {&quot;);
          if (!empty) {
<span class="line-modified">!             out.write(&quot;    Event&quot; + event.name + &quot; me(UNTIMED);&quot;);</span>
<span class="line-modified">!             out.write(&quot;&quot;);</span>
<span class="line-modified">!             out.write(&quot;    if (me.should_commit()) {&quot;);</span>
<span class="line-modified">!             if (event.startTime) {</span>
<span class="line-modified">!                 out.write(&quot;      me.set_starttime(startTicks);&quot;);</span>
<span class="line-modified">!                 out.write(&quot;      me.set_endtime(endTicks);&quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             for (FieldElement f : event.fields) {</span>
<span class="line-modified">!                 out.write(&quot;      me.set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             out.write(&quot;      me.commit();&quot;);</span>
<span class="line-modified">!             out.write(&quot;    }&quot;);</span>
          }
          out.write(&quot;  }&quot;);
      }
  
<span class="line-modified">!     private static void printConstructor2(Printer out, TypeElement event, boolean empty) {</span>
          if (!event.startTime) {
              out.write(&quot;&quot;);
              out.write(&quot;&quot;);
          }
          if (event.startTime) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 742,18 ***</span>
              StringJoiner sj = new StringJoiner(&quot;,\n    &quot;);
              for (FieldElement f : event.fields) {
                  sj.add(f.getParameterType() + &quot; &quot; + f.name);
              }
              if (!empty) {
<span class="line-modified">!               out.write(&quot;    &quot; + sj.toString() + &quot;) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(TIMED) {&quot;);</span>
<span class="line-modified">!               out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">!               for (FieldElement f : event.fields) {</span>
<span class="line-modified">!                   out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">!               }</span>
<span class="line-modified">!               out.write(&quot;    }&quot;);</span>
              } else {
<span class="line-modified">!               out.write(&quot;    &quot; + sj.toString() + &quot;) {&quot;);</span>
              }
              out.write(&quot;  }&quot;);
          }
      }
  
<span class="line-new-header">--- 956,18 ---</span>
              StringJoiner sj = new StringJoiner(&quot;,\n    &quot;);
              for (FieldElement f : event.fields) {
                  sj.add(f.getParameterType() + &quot; &quot; + f.name);
              }
              if (!empty) {
<span class="line-modified">!                 out.write(&quot;    &quot; + sj.toString() + &quot;) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(TIMED) {&quot;);</span>
<span class="line-modified">!                 out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">!                 for (FieldElement f : event.fields) {</span>
<span class="line-modified">!                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 out.write(&quot;    }&quot;);</span>
              } else {
<span class="line-modified">!                 out.write(&quot;    &quot; + sj.toString() + &quot;) {&quot;);</span>
              }
              out.write(&quot;  }&quot;);
          }
      }
  
</pre>
<center><a href="../../../../../modules/jdk.jfr/Copy.gmk.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/BuildMicrobenchmark.gmk.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New make/src/classes/build/tools/jfr/GenerateJfrFiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 package build.tools.jfr;
  2 
  3 import java.io.BufferedOutputStream;
  4 import java.io.Closeable;
  5 import java.io.DataOutputStream;
  6 import java.io.File;
  7 import java.io.FileNotFoundException;
  8 import java.io.FileOutputStream;
  9 import java.io.IOException;
 10 import java.io.PrintStream;
 11 import java.util.ArrayList;
 12 import java.util.Arrays;
 13 import java.util.LinkedHashMap;
 14 import java.util.List;
 15 import java.util.Map;
 16 import java.util.Objects;
 17 import java.util.StringJoiner;
 18 import java.util.function.Predicate;
 19 
 20 import javax.xml.XMLConstants;
 21 import javax.xml.parsers.ParserConfigurationException;
 22 import javax.xml.parsers.SAXParser;
 23 import javax.xml.parsers.SAXParserFactory;
 24 import javax.xml.validation.SchemaFactory;
 25 
 26 import org.xml.sax.Attributes;
 27 import org.xml.sax.SAXException;
 28 import org.xml.sax.SAXParseException;
 29 import org.xml.sax.helpers.DefaultHandler;
 30 
 31 /**
 32  * Purpose of this program is twofold:
 33  *
 34  * 1) Generate C++ classes to be used when writing native events for HotSpot.
 35  *
 36  * 2) Generate metadata (label, descriptions, field layout etc.) from XML
 37  * (metadata.xml) into a binary format (metadata.bin) that can be read quickly
 38  * during startup by the jdk.jfr module.
 39  *
 40  * INPUT FILES:
 41  *
 42  * -  metadata.xml  File that contains descriptions of events and types
 43  * -  metadata.xsd  Schema that verifies that metadata.xml is legit XML
 44  *
 45  * OUTPUT FILES:
 46  *
 47  * MODE: headers
 48  *
 49  * - jfrEventIds.hpp      List of IDs so events can be identified from native
 50  * - jfrTypes.hpp         List of IDs so types can be identified from native
 51  * - jfrPeriodic.hpp      Dispatch mechanism so Java can emit native periodic events
 52  * - jfrEventControl.hpp  Data structure for native event settings.
 53  * - jfrEventClasses.hpp  C++ event classes that can write data into native buffers
 54  *
 55  * MODE: metadata
 56  *
 57  *  - metadata.bin        Binary representation of the information in metadata.xml
 58  *
 59  */
 60 public class GenerateJfrFiles {
 61 
 62     enum OutputMode {
 63         headers, metadata
 64     }
 65 
 66     private static void printUsage(PrintStream out) {
 67         out.println(&quot;Usage: java GenerateJfrFiles[.java]&quot;);
 68         out.println(&quot; --mode &lt;headers|metadata&gt;&quot;);
 69         out.println(&quot; --xml &lt;path-to-metadata.xml&gt; &quot;);
 70         out.println(&quot; --xsd &lt;path-to-metadata.xsd&gt;&quot;);
 71         out.println(&quot; --output &lt;output-file-or-directory&gt;&quot;);
 72     }
 73 
 74     private static String consumeOption(String option, List&lt;String&gt; argList) throws Exception {
 75         int index = argList.indexOf(option);
 76         if (index &gt;= 0 &amp;&amp; index &lt;= argList.size() - 2) {
 77             String result = argList.get(index + 1);
 78             argList.remove(index);
 79             argList.remove(index);
 80             return result;
 81         }
 82         throw new IllegalArgumentException(&quot;missing option &quot; + option);
 83     }
 84 
 85     public static void main(String... args) throws Exception {
 86         try {
 87             List&lt;String&gt; argList = new ArrayList&lt;&gt;();
 88             argList.addAll(Arrays.asList(args));
 89             String mode = consumeOption(&quot;--mode&quot;, argList);
 90             String output = consumeOption(&quot;--output&quot;, argList);
 91             String xml = consumeOption(&quot;--xml&quot;, argList);
 92             String xsd = consumeOption(&quot;--xsd&quot;, argList);
 93             if (!argList.isEmpty()) {
 94                 throw new IllegalArgumentException(&quot;unknown option &quot; + argList);
 95             }
 96             OutputMode outputMode = OutputMode.valueOf(mode);
 97             File xmlFile = new File(xml);
 98             File xsdFile = new File(xsd);
 99 
100             Metadata metadata = new Metadata(xmlFile, xsdFile);
101             metadata.verify();
102             metadata.wireUpTypes();
103 
104             if (outputMode == OutputMode.headers) {
105                 File outputDir = new File(output);
106                 printJfrEventIdsHpp(metadata, new File(outputDir, &quot;jfrEventIds.hpp&quot;));
107                 printJfrTypesHpp(metadata, new File(outputDir, &quot;jfrTypes.hpp&quot;));
108                 printJfrPeriodicHpp(metadata, new File(outputDir, &quot;jfrPeriodic.hpp&quot;));
109                 printJfrEventControlHpp(metadata, new File(outputDir, &quot;jfrEventControl.hpp&quot;));
110                 printJfrEventClassesHpp(metadata, new File(outputDir, &quot;jfrEventClasses.hpp&quot;));
111             }
112 
113             if (outputMode == OutputMode.metadata) {
114                 File outputFile  = new File(output);
115                 try (var b = new DataOutputStream(
116                         new BufferedOutputStream(
117                             new FileOutputStream(outputFile)))) {
118                     metadata.persist(b);
119                 }
120             }
121             System.exit(0);
122         } catch (IllegalArgumentException iae) {
123             System.err.println();
124             System.err.println(&quot;GenerateJfrFiles: &quot; + iae.getMessage());
125             System.err.println();
126             printUsage(System.err);
127             System.err.println();
128         } catch (Exception e) {
129             e.printStackTrace();
130         }
131         System.exit(1);
132     }
133 
134     static class XmlType {
135         final String name;
136         final String fieldType;
137         final String parameterType;
138         final String javaType;
139         final boolean unsigned;
140         final String contentType;
141 
142         XmlType(String name, String fieldType, String parameterType, String javaType, String contentType,
143                 boolean unsigned) {
144             this.name = name;
145             this.fieldType = fieldType;
146             this.parameterType = parameterType;
147             this.javaType = javaType;
148             this.unsigned = unsigned;
149             this.contentType = contentType;
150         }
151     }
152 
153     static class XmlContentType {
154         final String name;
155         final String annotation;
156 
157         XmlContentType(String name, String annotation) {
158             this.name = name;
159             this.annotation = annotation;
160         }
161     }
162 
163     static class TypeElement {
164         List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
165         String name;
166         String javaType;
167         String label = &quot;&quot;;
168         String description = &quot;&quot;;
169         String category = &quot;&quot;;
170         boolean thread;
171         boolean stackTrace;
172         boolean startTime;
173         String period = &quot;&quot;;
174         boolean cutoff;
175         boolean experimental;
176         long id;
177         boolean isEvent;
178         boolean isRelation;
179         boolean supportStruct = false;
180         String commitState;
181         public boolean primitive;
182 
183         public void persist(DataOutputStream pos) throws IOException {
184             pos.writeInt(fields.size());
185             for (FieldElement field : fields) {
186                 field.persist(pos);
187             }
188             pos.writeUTF(javaType);
189             pos.writeUTF(label);
190             pos.writeUTF(description);
191             pos.writeUTF(category);
192             pos.writeBoolean(thread);
193             pos.writeBoolean(stackTrace);
194             pos.writeBoolean(startTime);
195             pos.writeUTF(period);
196             pos.writeBoolean(cutoff);
197             pos.writeBoolean(experimental);
198             pos.writeLong(id);
199             pos.writeBoolean(isEvent);
200             pos.writeBoolean(isRelation);
201         }
202     }
203 
204     static class Metadata {
205         static class TypeCounter {
206             final long first;
207             long last = -1;
208             long count = 0;
209             long id = -1;
210 
211             TypeCounter(long startId) {
212                 this.first = startId;
213             }
214 
215             long next() {
216                 id = (id == -1) ? first : id + 1;
217                 count++;
218                 last = id;
219                 return id;
220             }
221         }
222 
223         static int RESERVED_EVENT_COUNT = 2;
224         final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
225         final Map&lt;String, XmlType&gt; xmlTypes = new LinkedHashMap&lt;&gt;();
226         final Map&lt;String, XmlContentType&gt; xmlContentTypes = new LinkedHashMap&lt;&gt;();
227         int lastEventId;
228         private TypeCounter eventCounter;
229         private TypeCounter typeCounter;
230 
231         Metadata(File metadataXml, File metadataSchema)
232                 throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {
233             SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
234             SAXParserFactory factory = SAXParserFactory.newInstance();
235             factory.setSchema(schemaFactory.newSchema(metadataSchema));
236             SAXParser sp = factory.newSAXParser();
237             sp.parse(metadataXml, new MetadataHandler(this));
238         }
239 
240         public void persist(DataOutputStream pos) throws IOException {
241             pos.writeInt(types.values().size());
242             for (TypeElement t : types.values()) {
243                 t.persist(pos);
244             }
245         }
246 
247         List&lt;TypeElement&gt; getEvents() {
248             return getList(t -&gt; t.isEvent);
249         }
250 
251         List&lt;TypeElement&gt; getEventsAndStructs() {
252             return getList(t -&gt; t.isEvent || t.supportStruct);
253         }
254 
255         @SuppressWarnings(&quot;unchecked&quot;)
256         &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
257             List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
258             for (TypeElement t : types.values()) {
259                 if (pred.test(t)) {
260                     result.add((T) t);
261                 }
262             }
263             return result;
264         }
265 
266         List&lt;TypeElement&gt; getPeriodicEvents() {
267             return getList(t -&gt; t.isEvent &amp;&amp; !t.period.isEmpty());
268         }
269 
270         List&lt;TypeElement&gt; getTypes() {
271             return getList(t -&gt; !t.isEvent);
272         }
273 
274         List&lt;TypeElement&gt; getStructs() {
275             return getList(t -&gt; !t.isEvent &amp;&amp; t.supportStruct);
276         }
277 
278         void verify() {
279             for (TypeElement t : types.values()) {
280                 for (FieldElement f : t.fields) {
281                     if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
282                         if (!types.containsKey(f.typeName)) {
283                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName
284                                     + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);
285                         }
286                     }
287                 }
288             }
289         }
290 
291         void wireUpTypes() {
292             // Add Java primitives
293             for (var t : xmlTypes.entrySet()) {
294                 String name = t.getKey();
295                 XmlType xmlType = t.getValue();
296                 // Excludes Thread and Class
297                 if (!types.containsKey(name)) {
298                     // Excludes u8, u4, u2, u1, Ticks and Ticksspan
299                     if (!xmlType.javaType.isEmpty() &amp;&amp; !xmlType.unsigned) {
300                         TypeElement te = new TypeElement();
301                         te.name = name;
302                         te.javaType = xmlType.javaType;
303                         te.primitive = true;
304                         types.put(te.name, te);
305                     }
306                 }
307             }
308             // Setup Java fully qualified names
309             for (TypeElement t : types.values()) {
310                 if (t.isEvent) {
311                     t.javaType = &quot;jdk.&quot; + t.name;
312                 } else {
313                     XmlType xmlType = xmlTypes.get(t.name);
314                     if (xmlType != null &amp;&amp; !xmlType.javaType.isEmpty()) {
315                         t.javaType = xmlType.javaType;
316                     } else {
317                         t.javaType = &quot;jdk.types.&quot; + t.name;
318                     }
319                 }
320             }
321             // Setup content type, annotation, constant pool etc. for fields.
322             for (TypeElement t : types.values()) {
323                 for (FieldElement f : t.fields) {
324                     TypeElement type = types.get(f.typeName);
325                     XmlType xmlType = xmlTypes.get(f.typeName);
326                     if (type == null) {
327                         if (xmlType == null) {
328                             throw new IllegalStateException(&quot;Unknown type&quot;);
329                         }
330                         if (f.contentType.isEmpty()) {
331                             f.contentType = xmlType.contentType;
332                         }
333                         String javaType = xmlType.javaType;
334                         type = types.get(javaType);
335                         Objects.requireNonNull(type);
336                     }
337                     if (type.primitive) {
338                         f.constantPool = false;
339                     }
340 
341                     if (xmlType != null) {
342                         f.unsigned = xmlType.unsigned;
343                     }
344 
345                     if (f.struct) {
346                         f.constantPool = false;
347                         type.supportStruct = true;
348                     }
349                     f.type = type;
350                     XmlContentType xmlContentType = xmlContentTypes.get(f.contentType);
351                     if (xmlContentType == null) {
352                         f.annotations = &quot;&quot;;
353                     } else {
354                         f.annotations = xmlContentType.annotation;
355                     }
356                     if (!f.relation.isEmpty()) {
357                         f.relation = &quot;jdk.types.&quot; + f.relation;
358                     }
359                 }
360             }
361 
362             // Low numbers for event so most of them
363             // can fit in one byte with compressed integers
364             eventCounter = new TypeCounter(RESERVED_EVENT_COUNT);
365             for (TypeElement t : getEvents()) {
366                 t.id = eventCounter.next();
367             }
368             typeCounter = new TypeCounter(eventCounter.last + 1);
369             for (TypeElement t : getTypes()) {
370                 t.id = typeCounter.next();
371             }
372         }
373 
374         public String getName(long id) {
375             for (TypeElement t : types.values()) {
376                 if (t.id == id) {
377                     return t.name;
378                 }
379             }
380             throw new IllegalStateException(&quot;Unexpected id &quot; + id );
381         }
382     }
383 
384     static class FieldElement {
385         final Metadata metadata;
386         TypeElement type;
387         String name;
388         String typeName;
389         boolean constantPool = true;
390         public String transition;
391         public String contentType;
392         private String label;
393         private String description;
394         private String relation;
395         private boolean experimental;
396         private boolean unsigned;
397         private boolean array;
398         private String annotations;
399         public boolean struct;
400 
401         FieldElement(Metadata metadata) {
402             this.metadata = metadata;
403         }
404 
405         public void persist(DataOutputStream pos) throws IOException {
406             pos.writeUTF(name);
407             pos.writeUTF(type.javaType);
408             pos.writeUTF(label);
409             pos.writeUTF(description);
410             pos.writeBoolean(constantPool);
411             pos.writeBoolean(array);
412             pos.writeBoolean(unsigned);
413             pos.writeUTF(annotations);
414             pos.writeUTF(transition);
415             pos.writeUTF(relation);
416             pos.writeBoolean(experimental);
417         }
418 
419         String getParameterType() {
420             if (struct) {
421                 return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
422             }
423             XmlType xmlType = metadata.xmlTypes.get(typeName);
424             if (xmlType != null) {
425                 return xmlType.parameterType;
426             }
427             return type != null ? &quot;u8&quot; : typeName;
428         }
429 
430         String getParameterName() {
431             return struct ? &quot;value&quot; : &quot;new_value&quot;;
432         }
433 
434         String getFieldType() {
435             if (struct) {
436                 return &quot;JfrStruct&quot; + typeName;
437             }
438             XmlType xmlType = metadata.xmlTypes.get(typeName);
439             if (xmlType != null) {
440                 return xmlType.fieldType;
441             }
442             return type != null ? &quot;u8&quot; : typeName;
443         }
444     }
445 
446     static class MetadataHandler extends DefaultHandler {
447         final Metadata metadata;
448         FieldElement currentField;
449         TypeElement currentType;
450 
451         MetadataHandler(Metadata metadata) {
452             this.metadata = metadata;
453         }
454 
455         @Override
456         public void error(SAXParseException e) throws SAXException {
457             throw e;
458         }
459 
460         @Override
461         public void startElement(String uri, String localName, String qName, Attributes attributes)
462                 throws SAXException {
463             switch (qName) {
464             case &quot;XmlContentType&quot;:
465                 String n = attributes.getValue(&quot;name&quot;); // mandatory
466                 String a = attributes.getValue(&quot;annotation&quot;); // mandatory
467                 metadata.xmlContentTypes.put(n, new XmlContentType(n, a));
468                 break;
469             case &quot;XmlType&quot;:
470                 String name = attributes.getValue(&quot;name&quot;); // mandatory
471                 String parameterType = attributes.getValue(&quot;parameterType&quot;); // mandatory
472                 String fieldType = attributes.getValue(&quot;fieldType&quot;); // mandatory
473                 String javaType = getString(attributes, &quot;javaType&quot;);
474                 String contentType = getString(attributes, &quot;contentType&quot;);
475                 boolean unsigned = getBoolean(attributes, &quot;unsigned&quot;, false);
476                 metadata.xmlTypes.put(name,
477                         new XmlType(name, fieldType, parameterType, javaType, contentType, unsigned));
478                 break;
479             case &quot;Relation&quot;:
480             case &quot;Type&quot;:
481             case &quot;Event&quot;:
482                 currentType = new TypeElement();
483                 currentType.name = attributes.getValue(&quot;name&quot;); // mandatory
484                 currentType.label = getString(attributes, &quot;label&quot;);
485                 currentType.description = getString(attributes, &quot;description&quot;);
486                 currentType.category = getString(attributes, &quot;category&quot;);
487                 currentType.experimental = getBoolean(attributes, &quot;experimental&quot;, false);
488                 currentType.thread = getBoolean(attributes, &quot;thread&quot;, false);
489                 currentType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);
490                 currentType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);
491                 currentType.period = getString(attributes, &quot;period&quot;);
492                 currentType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);
493                 currentType.commitState = getString(attributes, &quot;commitState&quot;);
494                 currentType.isEvent = &quot;Event&quot;.equals(qName);
495                 currentType.isRelation = &quot;Relation&quot;.equals(qName);
496                 break;
497             case &quot;Field&quot;:
498                 currentField = new FieldElement(metadata);
499                 currentField.name = attributes.getValue(&quot;name&quot;); // mandatory
500                 currentField.typeName = attributes.getValue(&quot;type&quot;); // mandatory
501                 currentField.label = getString(attributes, &quot;label&quot;);
502                 currentField.description = getString(attributes, &quot;description&quot;);
503                 currentField.contentType = getString(attributes, &quot;contentType&quot;);
504                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
505                 currentField.array = getBoolean(attributes, &quot;array&quot;, false);
506                 currentField.transition = getString(attributes, &quot;transition&quot;);
507                 currentField.relation = getString(attributes, &quot;relation&quot;);
508                 currentField.experimental = getBoolean(attributes, &quot;experimental&quot;, false);
509                 break;
510             }
511         }
512 
513         private static String getString(Attributes attributes, String name) {
514             String value = attributes.getValue(name);
515             return value != null ? value : &quot;&quot;;
516         }
517 
518         private static boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {
519             String value = attributes.getValue(name);
520             return value == null ? defaultValue : Boolean.valueOf(value);
521         }
522 
523         @Override
524         public void endElement(String uri, String localName, String qName) {
525             switch (qName) {
526             case &quot;Relation&quot;:
527             case &quot;Type&quot;:
528             case &quot;Event&quot;:
529                 metadata.types.put(currentType.name, currentType);
530                 currentType = null;
531                 break;
532             case &quot;Field&quot;:
533                 currentType.fields.add(currentField);
534                 currentField = null;
535                 break;
536             }
537         }
538     }
539 
540     static class Printer implements Closeable {
541         final PrintStream out;
542 
543         Printer(File outputFile) throws FileNotFoundException {
544             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(outputFile)));
545             write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
546             write(&quot;&quot;);
547         }
548 
549         void write(String text) {
550             out.print(text);
551             out.print(&quot;\n&quot;); // Don&#39;t use Windows line endings
552         }
553 
554         @Override
555         public void close() throws IOException {
556             out.close();
557         }
558     }
559 
560     private static void printJfrPeriodicHpp(Metadata metadata, File outputFile) throws Exception {
561         try (var out = new Printer(outputFile)) {
562             out.write(&quot;#ifndef JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
563             out.write(&quot;#define JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
564             out.write(&quot;&quot;);
565             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
566             out.write(&quot;#if INCLUDE_JFR&quot;);
567             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
568             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
569             out.write(&quot;&quot;);
570             out.write(&quot;class JfrPeriodicEventSet : public AllStatic {&quot;);
571             out.write(&quot; public:&quot;);
572             out.write(&quot;  static void requestEvent(JfrEventId id) {&quot;);
573             out.write(&quot;    switch(id) {&quot;);
574             out.write(&quot;  &quot;);
575             for (TypeElement e : metadata.getPeriodicEvents()) {
576                 out.write(&quot;      case Jfr&quot; + e.name + &quot;Event:&quot;);
577                 out.write(&quot;        request&quot; + e.name + &quot;();&quot;);
578                 out.write(&quot;        break;&quot;);
579                 out.write(&quot;  &quot;);
580             }
581             out.write(&quot;      default:&quot;);
582             out.write(&quot;        break;&quot;);
583             out.write(&quot;      }&quot;);
584             out.write(&quot;    }&quot;);
585             out.write(&quot;&quot;);
586             out.write(&quot; private:&quot;);
587             out.write(&quot;&quot;);
588             for (TypeElement e : metadata.getPeriodicEvents()) {
589                 out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
590                 out.write(&quot;&quot;);
591             }
592             out.write(&quot;};&quot;);
593             out.write(&quot;&quot;);
594             out.write(&quot;#endif // INCLUDE_JFR&quot;);
595             out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
596         }
597     }
598 
599     private static void printJfrEventControlHpp(Metadata metadata, File outputFile) throws Exception {
600         try (var out = new Printer(outputFile)) {
601             out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
602             out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
603             out.write(&quot;&quot;);
604             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
605             out.write(&quot;#if INCLUDE_JFR&quot;);
606             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
607             out.write(&quot;&quot;);
608             out.write(&quot;/**&quot;);
609             out.write(&quot; * Event setting. We add some padding so we can use our&quot;);
610             out.write(&quot; * event IDs as indexes into this.&quot;);
611             out.write(&quot; */&quot;);
612             out.write(&quot;&quot;);
613             out.write(&quot;struct jfrNativeEventSetting {&quot;);
614             out.write(&quot;  jlong  threshold_ticks;&quot;);
615             out.write(&quot;  jlong  cutoff_ticks;&quot;);
616             out.write(&quot;  u1     stacktrace;&quot;);
617             out.write(&quot;  u1     enabled;&quot;);
618             out.write(&quot;  u1     large;&quot;);
619             out.write(&quot;  u1     pad[5]; // Because GCC on linux ia32 at least tries to pack this.&quot;);
620             out.write(&quot;};&quot;);
621             out.write(&quot;&quot;);
622             out.write(&quot;union JfrNativeSettings {&quot;);
623             out.write(&quot;  // Array version.&quot;);
624             out.write(&quot;  jfrNativeEventSetting bits[NUMBER_OF_EVENTS];&quot;);
625             out.write(&quot;  // Then, to make it easy to debug,&quot;);
626             out.write(&quot;  // add named struct members also.&quot;);
627             out.write(&quot;  struct {&quot;);
628             out.write(&quot;    jfrNativeEventSetting pad[NUMBER_OF_RESERVED_EVENTS];&quot;);
629             for (TypeElement t : metadata.getEventsAndStructs()) {
630                 out.write(&quot;    jfrNativeEventSetting &quot; + t.name + &quot;;&quot;);
631             }
632             out.write(&quot;  } ev;&quot;);
633             out.write(&quot;};&quot;);
634             out.write(&quot;&quot;);
635             out.write(&quot;#endif // INCLUDE_JFR&quot;);
636             out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
637         }
638     }
639 
640     private static void printJfrEventIdsHpp(Metadata metadata, File outputFile) throws Exception {
641         try (var out = new Printer(outputFile)) {
642             out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
643             out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
644             out.write(&quot;&quot;);
645             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
646             out.write(&quot;#if INCLUDE_JFR&quot;);
647             out.write(&quot;&quot;);
648             out.write(&quot;enum JfrEventId {&quot;);
649             out.write(&quot;  JfrMetadataEvent = 0,&quot;);
650             out.write(&quot;  JfrCheckpointEvent = 1,&quot;);
651             for (TypeElement t : metadata.getEvents()) {
652                 out.write(&quot;  &quot; + jfrEventId(t.name) + &quot; = &quot; + t.id + &quot;,&quot;);
653             }
654             out.write(&quot;};&quot;);
655             out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
656             out.write(&quot;&quot;);
657             String first = metadata.getName(metadata.eventCounter.first);
658             String last = metadata.getName(metadata.eventCounter.last);
659             out.write(&quot;static const JfrEventId FIRST_EVENT_ID = &quot; + jfrEventId(first) + &quot;;&quot;);
660             out.write(&quot;static const JfrEventId LAST_EVENT_ID = &quot; + jfrEventId(last) + &quot;;&quot;);
661             out.write(&quot;static const int NUMBER_OF_EVENTS = &quot; + metadata.eventCounter.count + &quot;;&quot;);
662             out.write(&quot;static const int NUMBER_OF_RESERVED_EVENTS = &quot; + Metadata.RESERVED_EVENT_COUNT + &quot;;&quot;);
663             out.write(&quot;#endif // INCLUDE_JFR&quot;);
664             out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
665         }
666     }
667 
668     private static String jfrEventId(String name) {
669         return &quot;Jfr&quot; + name + &quot;Event&quot;;
670     }
671 
672     private static void printJfrTypesHpp(Metadata metadata, File outputFile) throws Exception {
673         try (var out = new Printer(outputFile)) {
674             out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
675             out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
676             out.write(&quot;&quot;);
677             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
678             out.write(&quot;#if INCLUDE_JFR&quot;);
679             out.write(&quot;&quot;);
680             out.write(&quot;#include &lt;string.h&gt;&quot;);
681             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
682             out.write(&quot;&quot;);
683             out.write(&quot;enum JfrTypeId {&quot;);
684             for (TypeElement type : metadata.getTypes()) {
685                 out.write(&quot;  &quot; + jfrTypeId(type.name) + &quot; = &quot; + type.id + &quot;,&quot;);
686             }
687             out.write(&quot;};&quot;);
688             out.write(&quot;&quot;);
689             String first = metadata.getName(metadata.typeCounter.first);
690             String last = metadata.getName(metadata.typeCounter.last);
691             out.write(&quot;static const JfrTypeId FIRST_TYPE_ID = &quot; + jfrTypeId(first) + &quot;;&quot;);
692             out.write(&quot;static const JfrTypeId LAST_TYPE_ID = &quot; + jfrTypeId(last) + &quot;;&quot;);
693             out.write(&quot;&quot;);
694             out.write(&quot;class JfrType : public AllStatic {&quot;);
695             out.write(&quot; public:&quot;);
696             out.write(&quot;  static jlong name_to_id(const char* type_name) {&quot;);
697 
698             Map&lt;String, XmlType&gt; javaTypes = new LinkedHashMap&lt;&gt;();
699             for (XmlType xmlType : metadata.xmlTypes.values()) {
700                 if (!xmlType.javaType.isEmpty()) {
701                     javaTypes.put(xmlType.javaType, xmlType);
702                 }
703             }
704             for (XmlType xmlType : javaTypes.values()) {
705                 String javaName = xmlType.javaType;
706                 String typeName = xmlType.name.toUpperCase();
707                 out.write(&quot;    if (strcmp(type_name, \&quot;&quot; + javaName + &quot;\&quot;) == 0) {&quot;);
708                 out.write(&quot;      return TYPE_&quot; + typeName + &quot;;&quot;);
709                 out.write(&quot;    }&quot;);
710             }
711             out.write(&quot;    return -1;&quot;);
712             out.write(&quot;  }&quot;);
713             out.write(&quot;};&quot;);
714             out.write(&quot;&quot;);
715             out.write(&quot;#endif // INCLUDE_JFR&quot;);
716             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
717         }
718     }
719 
720     private static String jfrTypeId(String name) {
721         return  &quot;TYPE_&quot; + name.toUpperCase();
722     }
723 
724     private static void printJfrEventClassesHpp(Metadata metadata, File outputFile) throws Exception {
725         try (var out = new Printer(outputFile)) {
726             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
727             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
728             out.write(&quot;&quot;);
729             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
730             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
731             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
732             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
733             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
734             out.write(&quot;#if INCLUDE_JFR&quot;);
735             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
736             out.write(&quot;#include \&quot;jfr/support/jfrEpochSynchronization.hpp\&quot;&quot;);
737             out.write(&quot;/*&quot;);
738             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
739             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
740             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
741             out.write(&quot; * and set before attempting to commit.&quot;);
742             out.write(&quot; *&quot;);
743             out.write(&quot; * We enforce this requirement because events are generally stack allocated and therefore&quot;);
744             out.write(&quot; * *not* initialized to default values. This prevents us from inadvertently committing&quot;);
745             out.write(&quot; * uninitialized values to the data stream.&quot;);
746             out.write(&quot; *&quot;);
747             out.write(&quot; * The assert message contains both the index (zero based) as well as the name of the field.&quot;);
748             out.write(&quot; */&quot;);
749             out.write(&quot;&quot;);
750             printTypes(out, metadata, false);
751             out.write(&quot;&quot;);
752             out.write(&quot;&quot;);
753             out.write(&quot;#else // !INCLUDE_JFR&quot;);
754             out.write(&quot;&quot;);
755             out.write(&quot;template &lt;typename T&gt;&quot;);
756             out.write(&quot;class JfrEvent {&quot;);
757             out.write(&quot; public:&quot;);
758             out.write(&quot;  JfrEvent() {}&quot;);
759             out.write(&quot;  void set_starttime(const Ticks&amp;) const {}&quot;);
760             out.write(&quot;  void set_endtime(const Ticks&amp;) const {}&quot;);
761             out.write(&quot;  bool should_commit() const { return false; }&quot;);
762             out.write(&quot;  static bool is_enabled() { return false; }&quot;);
763             out.write(&quot;  void commit() {}&quot;);
764             out.write(&quot;};&quot;);
765             out.write(&quot;&quot;);
766             printTypes(out, metadata, true);
767             out.write(&quot;&quot;);
768             out.write(&quot;&quot;);
769             out.write(&quot;#endif // INCLUDE_JFR&quot;);
770             out.write(&quot;#endif // JFRFILES_JFREVENTCLASSES_HPP&quot;);
771         }
772     }
773 
774     private static void printTypes(Printer out, Metadata metadata, boolean empty) {
775         for (TypeElement t : metadata.getStructs()) {
776             printType(out, t, empty);
777             out.write(&quot;&quot;);
778         }
779         for (TypeElement e : metadata.getEvents()) {
780             printEvent(out, e, empty);
781             out.write(&quot;&quot;);
782         }
783     }
784 
785     private static void printType(Printer out, TypeElement t, boolean empty) {
786         out.write(&quot;struct JfrStruct&quot; + t.name);
787         out.write(&quot;{&quot;);
788         if (!empty) {
789             out.write(&quot; private:&quot;);
790             for (FieldElement f : t.fields) {
791                 printField(out, f);
792             }
793             out.write(&quot;&quot;);
794         }
795         out.write(&quot; public:&quot;);
796         for (FieldElement f : t.fields) {
797             printTypeSetter(out, f, empty);
798         }
799         out.write(&quot;&quot;);
800         if (!empty) {
801             printWriteData(out, t);
802         }
803         out.write(&quot;};&quot;);
804         out.write(&quot;&quot;);
805     }
806 
807     private static void printEvent(Printer out, TypeElement event, boolean empty) {
808         out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
809         out.write(&quot;{&quot;);
810         if (!empty) {
811             out.write(&quot; private:&quot;);
812             for (FieldElement f : event.fields) {
813                 printField(out, f);
814             }
815             out.write(&quot;&quot;);
816         }
817         out.write(&quot; public:&quot;);
818         if (!empty) {
819             out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);
820             out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);
821             out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);
822             out.write(&quot;  static const bool hasCutoff = &quot; + event.cutoff + &quot;;&quot;);
823             out.write(&quot;  static const bool isRequestable = &quot; + !event.period.isEmpty() + &quot;;&quot;);
824             out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);
825             out.write(&quot;&quot;);
826         }
827         if (!empty) {
828             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name
829                     + &quot;&gt;(timing) {}&quot;);
830         } else {
831             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);
832         }
833         out.write(&quot;&quot;);
834         int index = 0;
835         for (FieldElement f : event.fields) {
836             out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
837             if (!empty) {
838                 out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);
839                 out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);
840             }
841             out.write(&quot;  }&quot;);
842         }
843         out.write(&quot;&quot;);
844         if (!empty) {
845             printWriteData(out, event);
846             out.write(&quot;&quot;);
847         }
848         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name
849                 + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);
850         printConstructor2(out, event, empty);
851         printCommitMethod(out, event, empty);
852         if (!empty) {
853             printVerify(out, event.fields);
854         }
855         out.write(&quot;};&quot;);
856     }
857 
858     private static void printWriteData(Printer out, TypeElement type) {
859         out.write(&quot;  template &lt;typename Writer&gt;&quot;);
860         out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
861         if ((&quot;_thread_in_native&quot;).equals(type.commitState)) {
862             out.write(&quot;    // explicit epoch synchronization check&quot;);
863             out.write(&quot;    JfrEpochSynchronization sync;&quot;);
864         }
865         for (FieldElement field : type.fields) {
866             if (field.struct) {
867                 out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
868             } else {
869                 out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
870             }
871         }
872         out.write(&quot;  }&quot;);
873     }
874 
875     private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
876         if (!empty) {
877             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name
878                     + &quot; = new_value; }&quot;);
879         } else {
880             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);
881         }
882     }
883 
884     private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
885         out.write(&quot;&quot;);
886         out.write(&quot;#ifdef ASSERT&quot;);
887         out.write(&quot;  void verify() const {&quot;);
888         int index = 0;
889         for (FieldElement f : fields) {
890             out.write(&quot;    assert(verify_field_bit(&quot; + index++
891                     + &quot;), \&quot;Attempting to write an uninitialized event field: %s\&quot;, \&quot;_&quot; + f.name + &quot;\&quot;);&quot;);
892         }
893         out.write(&quot;  }&quot;);
894         out.write(&quot;#endif&quot;);
895     }
896 
897     private static void printCommitMethod(Printer out, TypeElement event, boolean empty) {
898         if (event.startTime) {
899             StringJoiner sj = new StringJoiner(&quot;,\n              &quot;);
900             for (FieldElement f : event.fields) {
901                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
902             }
903             out.write(&quot;&quot;);
904             out.write(&quot;  void commit(&quot; + sj.toString() + &quot;) {&quot;);
905             if (!empty) {
906                 out.write(&quot;    if (should_commit()) {&quot;);
907                 for (FieldElement f : event.fields) {
908                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);
909                 }
910                 out.write(&quot;      commit();&quot;);
911                 out.write(&quot;    }&quot;);
912             }
913             out.write(&quot;  }&quot;);
914         }
915 
916         // Avoid clash with static commit() method
917         if (event.fields.isEmpty()) {
918             return;
919         }
920 
921         out.write(&quot;&quot;);
922         StringJoiner sj = new StringJoiner(&quot;,\n                     &quot;);
923         if (event.startTime) {
924             sj.add(&quot;const Ticks&amp; startTicks&quot;);
925             sj.add(&quot;const Ticks&amp; endTicks&quot;);
926         }
927         for (FieldElement f : event.fields) {
928             sj.add(f.getParameterType() + &quot; &quot; + f.name);
929         }
930         out.write(&quot;  static void commit(&quot; + sj.toString() + &quot;) {&quot;);
931         if (!empty) {
932             out.write(&quot;    Event&quot; + event.name + &quot; me(UNTIMED);&quot;);
933             out.write(&quot;&quot;);
934             out.write(&quot;    if (me.should_commit()) {&quot;);
935             if (event.startTime) {
936                 out.write(&quot;      me.set_starttime(startTicks);&quot;);
937                 out.write(&quot;      me.set_endtime(endTicks);&quot;);
938             }
939             for (FieldElement f : event.fields) {
940                 out.write(&quot;      me.set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);
941             }
942             out.write(&quot;      me.commit();&quot;);
943             out.write(&quot;    }&quot;);
944         }
945         out.write(&quot;  }&quot;);
946     }
947 
948     private static void printConstructor2(Printer out, TypeElement event, boolean empty) {
949         if (!event.startTime) {
950             out.write(&quot;&quot;);
951             out.write(&quot;&quot;);
952         }
953         if (event.startTime) {
954             out.write(&quot;&quot;);
955             out.write(&quot;  Event&quot; + event.name + &quot;(&quot;);
956             StringJoiner sj = new StringJoiner(&quot;,\n    &quot;);
957             for (FieldElement f : event.fields) {
958                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
959             }
960             if (!empty) {
961                 out.write(&quot;    &quot; + sj.toString() + &quot;) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(TIMED) {&quot;);
962                 out.write(&quot;    if (should_commit()) {&quot;);
963                 for (FieldElement f : event.fields) {
964                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);
965                 }
966                 out.write(&quot;    }&quot;);
967             } else {
968                 out.write(&quot;    &quot; + sj.toString() + &quot;) {&quot;);
969             }
970             out.write(&quot;  }&quot;);
971         }
972     }
973 
974     private static void printField(Printer out, FieldElement field) {
975         out.write(&quot;  &quot; + field.getFieldType() + &quot; _&quot; + field.name + &quot;;&quot;);
976     }
977 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/src/classes/build/tools/jfr/GenerateJfrFiles.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../modules/jdk.jfr/Copy.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/BuildMicrobenchmark.gmk.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/src/classes/build/tools/jfr/GenerateJfrFiles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 package build.tools.jfr;
  2 
  3 import java.io.BufferedOutputStream;


  4 import java.io.File;
  5 import java.io.FileNotFoundException;
  6 import java.io.FileOutputStream;
  7 import java.io.IOException;
  8 import java.io.PrintStream;
  9 import java.util.ArrayList;

 10 import java.util.LinkedHashMap;
 11 import java.util.List;
 12 import java.util.Map;
<span class="line-modified"> 13 import java.util.Map.Entry;</span>
 14 import java.util.StringJoiner;
 15 import java.util.function.Predicate;
 16 
 17 import javax.xml.XMLConstants;
 18 import javax.xml.parsers.ParserConfigurationException;
 19 import javax.xml.parsers.SAXParser;
 20 import javax.xml.parsers.SAXParserFactory;
 21 import javax.xml.validation.SchemaFactory;
 22 
 23 import org.xml.sax.Attributes;
 24 import org.xml.sax.SAXException;
 25 import org.xml.sax.SAXParseException;
 26 import org.xml.sax.helpers.DefaultHandler;
 27 





























 28 public class GenerateJfrFiles {
 29 
<span class="line-modified"> 30     public static void main(String... args) throws Exception {</span>
<span class="line-modified"> 31         if (args.length != 3) {</span>
<span class="line-removed"> 32             System.err.println(&quot;Incorrect number of command line arguments.&quot;);</span>
<span class="line-removed"> 33             System.err.println(&quot;Usage:&quot;);</span>
<span class="line-removed"> 34             System.err.println(&quot;java GenerateJfrFiles[.java] &lt;path-to-metadata.xml&gt; &lt;path-to-metadata.xsd&gt; &lt;output-directory&gt;&quot;);</span>
<span class="line-removed"> 35             System.exit(1);</span>
<span class="line-removed"> 36         }</span>
<span class="line-removed"> 37         try {</span>
<span class="line-removed"> 38             File metadataXml = new File(args[0]);</span>
<span class="line-removed"> 39             File metadataSchema = new File(args[1]);</span>
<span class="line-removed"> 40             File outputDirectory = new File(args[2]);</span>
<span class="line-removed"> 41 </span>
<span class="line-removed"> 42             Metadata metadata = new Metadata(metadataXml, metadataSchema);</span>
<span class="line-removed"> 43             metadata.verify();</span>
<span class="line-removed"> 44             metadata.wireUpTypes();</span>
<span class="line-removed"> 45 </span>
<span class="line-removed"> 46             TypeCounter typeCounter = new TypeCounter();</span>
<span class="line-removed"> 47             printJfrEventIdsHpp(metadata, typeCounter, outputDirectory);</span>
<span class="line-removed"> 48             printJfrTypesHpp(metadata, typeCounter, outputDirectory);</span>
<span class="line-removed"> 49             printJfrPeriodicHpp(metadata, outputDirectory);</span>
<span class="line-removed"> 50             printJfrEventControlHpp(metadata, typeCounter, outputDirectory);</span>
<span class="line-removed"> 51             printJfrEventClassesHpp(metadata, outputDirectory);</span>
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53         } catch (Exception e) {</span>
<span class="line-removed"> 54             e.printStackTrace();</span>
<span class="line-removed"> 55             System.exit(1);</span>
<span class="line-removed"> 56         }</span>
 57     }
 58 
<span class="line-modified"> 59     static class TypeCounter {</span>
<span class="line-modified"> 60         final static long RESERVED_EVENT_COUNT = 2;</span>
<span class="line-modified"> 61         long typeId = -1;</span>
<span class="line-modified"> 62         long eventId = -1;</span>
<span class="line-modified"> 63         long eventCount = 0;</span>
<span class="line-modified"> 64         String firstTypeName;</span>
<span class="line-modified"> 65         String lastTypeName;</span>
<span class="line-removed"> 66         String firstEventName;</span>
<span class="line-removed"> 67         String lastEventname;</span>
 68 
<span class="line-modified"> 69         public long nextEventId(String name) {</span>
<span class="line-modified"> 70             eventCount++;</span>
<span class="line-modified"> 71             if (eventId == -1) {</span>
<span class="line-modified"> 72                 eventId = firstEventId();</span>
<span class="line-modified"> 73                 firstEventName = lastEventname = name;</span>
<span class="line-modified"> 74                 return eventId;</span>
<span class="line-modified"> 75             }</span>
<span class="line-removed"> 76             lastEventname = name;</span>
<span class="line-removed"> 77             return ++eventId;</span>
 78         }


 79 
<span class="line-modified"> 80         public long nextTypeId(String typeName) {</span>
<span class="line-modified"> 81             if (typeId == -1) {</span>
<span class="line-modified"> 82                 lastTypeName = firstTypeName = typeName;</span>
<span class="line-modified"> 83                 typeId = lastEventId();</span>






 84             }
<span class="line-modified"> 85             lastTypeName = typeName;</span>
<span class="line-modified"> 86             return ++typeId;</span>
<span class="line-modified"> 87         }</span>
<span class="line-removed"> 88 </span>
<span class="line-removed"> 89         public long firstEventId() {</span>
<span class="line-removed"> 90             return RESERVED_EVENT_COUNT;</span>
<span class="line-removed"> 91         }</span>
<span class="line-removed"> 92 </span>
<span class="line-removed"> 93         public long lastEventId() {</span>
<span class="line-removed"> 94             return eventId == -1 ? firstEventId() : eventId;</span>
<span class="line-removed"> 95         }</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97         public long eventCount() {</span>
<span class="line-removed"> 98             return eventCount;</span>
<span class="line-removed"> 99         }</span>
<span class="line-removed">100 </span>
<span class="line-removed">101         public String firstTypeName() {</span>
<span class="line-removed">102             return firstTypeName;</span>
<span class="line-removed">103         }</span>
104 
<span class="line-modified">105         public String lastTypeName() {</span>
<span class="line-modified">106             return lastTypeName;</span>
<span class="line-modified">107         }</span>
108 
<span class="line-modified">109         public String firstEventName() {</span>
<span class="line-modified">110             return firstEventName;</span>
<span class="line-modified">111         }</span>





112 
<span class="line-modified">113         public String lastEventName() {</span>
<span class="line-modified">114             return lastEventname;</span>















115         }

116     }
117 
118     static class XmlType {
119         final String name;
120         final String fieldType;
121         final String parameterType;
122         final String javaType;
123         final boolean unsigned;

124 
<span class="line-modified">125         XmlType(String name, String fieldType, String parameterType, String javaType, boolean unsigned) {</span>

126             this.name = name;
127             this.fieldType = fieldType;
128             this.parameterType = parameterType;
129             this.javaType = javaType;
130             this.unsigned = unsigned;











131         }
132     }
133 
134     static class TypeElement {
135         List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
136         String name;
<span class="line-modified">137         String fieldType;</span>
<span class="line-modified">138         String parameterType;</span>
<span class="line-modified">139         boolean supportStruct;</span>

































140     }
141 
142     static class Metadata {



















143         final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
144         final Map&lt;String, XmlType&gt; xmlTypes = new LinkedHashMap&lt;&gt;();
<span class="line-modified">145         Metadata(File metadataXml, File metadataSchema) throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {</span>






146             SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
147             SAXParserFactory factory = SAXParserFactory.newInstance();
148             factory.setSchema(schemaFactory.newSchema(metadataSchema));
149             SAXParser sp = factory.newSAXParser();
150             sp.parse(metadataXml, new MetadataHandler(this));
151         }
152 
<span class="line-modified">153         List&lt;EventElement&gt; getEvents() {</span>
<span class="line-modified">154             return getList(t -&gt; t.getClass() == EventElement.class);</span>



155         }
156 
<span class="line-modified">157         List&lt;TypeElement&gt; getEventsAndStructs() {</span>
<span class="line-modified">158             return getList(t -&gt; t.getClass() == EventElement.class || t.supportStruct);</span>
159         }
160 
<span class="line-modified">161         List&lt;TypeElement&gt; getTypesAndStructs() {</span>
<span class="line-modified">162             return getList(t -&gt; t.getClass() == TypeElement.class || t.supportStruct);</span>
163         }
164 
165         @SuppressWarnings(&quot;unchecked&quot;)
166         &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
167             List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
168             for (TypeElement t : types.values()) {
169                 if (pred.test(t)) {
170                     result.add((T) t);
171                 }
172             }
173             return result;
174         }
175 
<span class="line-modified">176         List&lt;EventElement&gt; getPeriodicEvents() {</span>
<span class="line-modified">177             return getList(t -&gt; t.getClass() == EventElement.class &amp;&amp; ((EventElement) t).periodic);</span>
178         }
179 
180         List&lt;TypeElement&gt; getTypes() {
<span class="line-modified">181             return getList(t -&gt; t.getClass() == TypeElement.class);</span>
182         }
183 
184         List&lt;TypeElement&gt; getStructs() {
<span class="line-modified">185             return getList(t -&gt; t.getClass() == TypeElement.class &amp;&amp; t.supportStruct);</span>
186         }
187 
<span class="line-modified">188         void verify()  {</span>
189             for (TypeElement t : types.values()) {
190                 for (FieldElement f : t.fields) {
191                     if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
192                         if (!types.containsKey(f.typeName)) {
<span class="line-modified">193                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);</span>

194                         }
195                     }
196                 }
197             }
198         }
199 
200         void wireUpTypes() {






























201             for (TypeElement t : types.values()) {
202                 for (FieldElement f : t.fields) {
203                     TypeElement type = types.get(f.typeName);




















204                     if (f.struct) {

205                         type.supportStruct = true;
206                     }
207                     f.type = type;









208                 }
209             }











210         }
<span class="line-removed">211     }</span>
212 
<span class="line-modified">213     static class EventElement extends TypeElement {</span>
<span class="line-modified">214         String representation;</span>
<span class="line-modified">215         boolean thread;</span>
<span class="line-modified">216         boolean stackTrace;</span>
<span class="line-modified">217         boolean startTime;</span>
<span class="line-modified">218         boolean periodic;</span>
<span class="line-modified">219         boolean cutoff;</span>
<span class="line-modified">220         String commitState;</span>
221     }
222 
223     static class FieldElement {
224         final Metadata metadata;
225         TypeElement type;
226         String name;
227         String typeName;
<span class="line-modified">228         boolean struct;</span>










229 
230         FieldElement(Metadata metadata) {
231             this.metadata = metadata;
232         }
233 














234         String getParameterType() {
235             if (struct) {
236                 return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
237             }
238             XmlType xmlType = metadata.xmlTypes.get(typeName);
239             if (xmlType != null) {
240                 return xmlType.parameterType;
241             }
242             return type != null ? &quot;u8&quot; : typeName;
243         }
244 
245         String getParameterName() {
246             return struct ? &quot;value&quot; : &quot;new_value&quot;;
247         }
248 
249         String getFieldType() {
250             if (struct) {
251                 return &quot;JfrStruct&quot; + typeName;
252             }
253             XmlType xmlType = metadata.xmlTypes.get(typeName);
254             if (xmlType != null) {
255                 return xmlType.fieldType;
256             }
257             return type != null ? &quot;u8&quot; : typeName;
258         }
259     }
260 
261     static class MetadataHandler extends DefaultHandler {
262         final Metadata metadata;
263         FieldElement currentField;
264         TypeElement currentType;

265         MetadataHandler(Metadata metadata) {
266             this.metadata = metadata;
267         }

268         @Override
269         public void error(SAXParseException e) throws SAXException {
<span class="line-modified">270           throw e;</span>
271         }

272         @Override
<span class="line-modified">273         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {</span>

274             switch (qName) {





275             case &quot;XmlType&quot;:
<span class="line-modified">276                 String name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">277                 String parameterType = attributes.getValue(&quot;parameterType&quot;);</span>
<span class="line-modified">278                 String fieldType = attributes.getValue(&quot;fieldType&quot;);</span>
<span class="line-modified">279                 String javaType = attributes.getValue(&quot;javaType&quot;);</span>

280                 boolean unsigned = getBoolean(attributes, &quot;unsigned&quot;, false);
<span class="line-modified">281                 metadata.xmlTypes.put(name, new XmlType(name, fieldType, parameterType, javaType, unsigned));</span>

282                 break;
283             case &quot;Relation&quot;:
284             case &quot;Type&quot;:
<span class="line-removed">285                 currentType = new TypeElement();</span>
<span class="line-removed">286                 currentType.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-removed">287                 break;</span>
288             case &quot;Event&quot;:
<span class="line-modified">289                 EventElement eventType = new EventElement();</span>
<span class="line-modified">290                 eventType.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">291                 eventType.thread = getBoolean(attributes, &quot;thread&quot;, false);</span>
<span class="line-modified">292                 eventType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);</span>
<span class="line-modified">293                 eventType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);</span>
<span class="line-modified">294                 eventType.periodic = attributes.getValue(&quot;period&quot;) != null;</span>
<span class="line-modified">295                 eventType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);</span>
<span class="line-modified">296                 eventType.commitState = attributes.getValue(&quot;commitState&quot;);</span>
<span class="line-modified">297                 currentType = eventType;</span>





298                 break;
299             case &quot;Field&quot;:
300                 currentField = new FieldElement(metadata);





301                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
<span class="line-modified">302                 currentField.name = attributes.getValue(&quot;name&quot;);</span>
<span class="line-modified">303                 currentField.typeName = attributes.getValue(&quot;type&quot;);</span>


304                 break;
305             }
306         }
307 
<span class="line-modified">308         private boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {</span>





309             String value = attributes.getValue(name);
310             return value == null ? defaultValue : Boolean.valueOf(value);
311         }
312 
313         @Override
314         public void endElement(String uri, String localName, String qName) {
315             switch (qName) {
316             case &quot;Relation&quot;:
317             case &quot;Type&quot;:
318             case &quot;Event&quot;:
319                 metadata.types.put(currentType.name, currentType);
320                 currentType = null;
321                 break;
322             case &quot;Field&quot;:
323                 currentType.fields.add(currentField);
324                 currentField = null;
325                 break;
326             }
327         }
328     }
329 
<span class="line-modified">330     static class Printer implements AutoCloseable {</span>
331         final PrintStream out;
<span class="line-modified">332         Printer(File outputDirectory, String filename) throws FileNotFoundException {</span>
<span class="line-modified">333             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(outputDirectory, filename))));</span>

334             write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
335             write(&quot;&quot;);
336         }
337 
338         void write(String text) {
339             out.print(text);
340             out.print(&quot;\n&quot;); // Don&#39;t use Windows line endings
341         }
342 
343         @Override
<span class="line-modified">344         public void close() throws Exception {</span>
345             out.close();
346         }
347     }
348 
<span class="line-modified">349     private static void printJfrPeriodicHpp(Metadata metadata, File outputDirectory) throws Exception {</span>
<span class="line-modified">350         try (Printer out = new Printer(outputDirectory, &quot;jfrPeriodic.hpp&quot;)) {</span>
351             out.write(&quot;#ifndef JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
352             out.write(&quot;#define JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
353             out.write(&quot;&quot;);
354             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
355             out.write(&quot;#if INCLUDE_JFR&quot;);
356             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
357             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
358             out.write(&quot;&quot;);
359             out.write(&quot;class JfrPeriodicEventSet : public AllStatic {&quot;);
360             out.write(&quot; public:&quot;);
361             out.write(&quot;  static void requestEvent(JfrEventId id) {&quot;);
362             out.write(&quot;    switch(id) {&quot;);
363             out.write(&quot;  &quot;);
<span class="line-modified">364             for (EventElement e : metadata.getPeriodicEvents()) {</span>
365                 out.write(&quot;      case Jfr&quot; + e.name + &quot;Event:&quot;);
366                 out.write(&quot;        request&quot; + e.name + &quot;();&quot;);
367                 out.write(&quot;        break;&quot;);
368                 out.write(&quot;  &quot;);
369             }
370             out.write(&quot;      default:&quot;);
371             out.write(&quot;        break;&quot;);
372             out.write(&quot;      }&quot;);
373             out.write(&quot;    }&quot;);
374             out.write(&quot;&quot;);
375             out.write(&quot; private:&quot;);
376             out.write(&quot;&quot;);
<span class="line-modified">377             for (EventElement e : metadata.getPeriodicEvents()) {</span>
378                 out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
379                 out.write(&quot;&quot;);
380             }
381             out.write(&quot;};&quot;);
382             out.write(&quot;&quot;);
383             out.write(&quot;#endif // INCLUDE_JFR&quot;);
384             out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
385         }
386     }
387 
<span class="line-modified">388     private static void printJfrEventControlHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
<span class="line-modified">389         try (Printer out = new Printer(outputDirectory, &quot;jfrEventControl.hpp&quot;)) {</span>
390             out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
391             out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
392             out.write(&quot;&quot;);
393             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
394             out.write(&quot;#if INCLUDE_JFR&quot;);
395             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
396             out.write(&quot;&quot;);
397             out.write(&quot;/**&quot;);
398             out.write(&quot; * Event setting. We add some padding so we can use our&quot;);
399             out.write(&quot; * event IDs as indexes into this.&quot;);
400             out.write(&quot; */&quot;);
401             out.write(&quot;&quot;);
402             out.write(&quot;struct jfrNativeEventSetting {&quot;);
403             out.write(&quot;  jlong  threshold_ticks;&quot;);
404             out.write(&quot;  jlong  cutoff_ticks;&quot;);
405             out.write(&quot;  u1     stacktrace;&quot;);
406             out.write(&quot;  u1     enabled;&quot;);
407             out.write(&quot;  u1     large;&quot;);
408             out.write(&quot;  u1     pad[5]; // Because GCC on linux ia32 at least tries to pack this.&quot;);
409             out.write(&quot;};&quot;);
410             out.write(&quot;&quot;);
411             out.write(&quot;union JfrNativeSettings {&quot;);
412             out.write(&quot;  // Array version.&quot;);
413             out.write(&quot;  jfrNativeEventSetting bits[NUMBER_OF_EVENTS];&quot;);
414             out.write(&quot;  // Then, to make it easy to debug,&quot;);
415             out.write(&quot;  // add named struct members also.&quot;);
416             out.write(&quot;  struct {&quot;);
417             out.write(&quot;    jfrNativeEventSetting pad[NUMBER_OF_RESERVED_EVENTS];&quot;);
418             for (TypeElement t : metadata.getEventsAndStructs()) {
419                 out.write(&quot;    jfrNativeEventSetting &quot; + t.name + &quot;;&quot;);
420             }
421             out.write(&quot;  } ev;&quot;);
422             out.write(&quot;};&quot;);
423             out.write(&quot;&quot;);
424             out.write(&quot;#endif // INCLUDE_JFR&quot;);
425             out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
426         }
427     }
428 
<span class="line-modified">429     private static void printJfrEventIdsHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
<span class="line-modified">430         try (Printer out = new Printer(outputDirectory, &quot;jfrEventIds.hpp&quot;)) {</span>
431             out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
432             out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
433             out.write(&quot;&quot;);
434             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
435             out.write(&quot;#if INCLUDE_JFR&quot;);
436             out.write(&quot;&quot;);
437             out.write(&quot;enum JfrEventId {&quot;);
438             out.write(&quot;  JfrMetadataEvent = 0,&quot;);
439             out.write(&quot;  JfrCheckpointEvent = 1,&quot;);
440             for (TypeElement t : metadata.getEvents()) {
<span class="line-modified">441                 String name = &quot;Jfr&quot; + t.name +&quot;Event&quot;;</span>
<span class="line-removed">442                 out.write(&quot;  &quot; + name + &quot; = &quot; + typeCounter.nextEventId(name) + &quot;,&quot;);</span>
443             }
444             out.write(&quot;};&quot;);
445             out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
446             out.write(&quot;&quot;);
<span class="line-modified">447             out.write(&quot;static const JfrEventId FIRST_EVENT_ID = &quot; + typeCounter.firstEventName() + &quot;;&quot;);</span>
<span class="line-modified">448             out.write(&quot;static const JfrEventId LAST_EVENT_ID = &quot; + typeCounter.lastEventName() + &quot;;&quot;);</span>
<span class="line-modified">449             out.write(&quot;static const int NUMBER_OF_EVENTS = &quot; + typeCounter.eventCount() + &quot;;&quot;);</span>
<span class="line-modified">450             out.write(&quot;static const int NUMBER_OF_RESERVED_EVENTS = &quot; + TypeCounter.RESERVED_EVENT_COUNT + &quot;;&quot;);</span>


451             out.write(&quot;#endif // INCLUDE_JFR&quot;);
452             out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
453         }
454     }
455 
<span class="line-modified">456     private static void printJfrTypesHpp(Metadata metadata, TypeCounter typeCounter, File outputDirectory) throws Exception {</span>
<span class="line-modified">457         try (Printer out = new Printer(outputDirectory, &quot;jfrTypes.hpp&quot;)) {</span>




458             out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
459             out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
460             out.write(&quot;&quot;);
461             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
462             out.write(&quot;#if INCLUDE_JFR&quot;);
463             out.write(&quot;&quot;);
464             out.write(&quot;#include &lt;string.h&gt;&quot;);
465             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
466             out.write(&quot;&quot;);
467             out.write(&quot;enum JfrTypeId {&quot;);
<span class="line-removed">468             Map&lt;String, XmlType&gt; javaTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-removed">469             for (var t : metadata.xmlTypes.entrySet()) {</span>
<span class="line-removed">470                 String name = t.getKey();</span>
<span class="line-removed">471                 XmlType xmlType = t.getValue();</span>
<span class="line-removed">472                 if (xmlType.javaType != null &amp;&amp; !xmlType.unsigned) {</span>
<span class="line-removed">473                     String typeName = &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-removed">474                     long typeId = typeCounter.nextTypeId(typeName);</span>
<span class="line-removed">475                     out.write(&quot;  &quot; + typeName + &quot; = &quot; + typeId + &quot;,&quot;);</span>
<span class="line-removed">476                     javaTypes.put(name, xmlType);</span>
<span class="line-removed">477                 }</span>
<span class="line-removed">478             }</span>
479             for (TypeElement type : metadata.getTypes()) {
<span class="line-modified">480                 String name = type.name;</span>
<span class="line-removed">481                 if (!javaTypes.containsKey(name)) {</span>
<span class="line-removed">482                     String typeName = &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-removed">483                     long typeId = typeCounter.nextTypeId(typeName);</span>
<span class="line-removed">484                     out.write(&quot;  &quot; + typeName + &quot; = &quot; + typeId + &quot;,&quot;);</span>
<span class="line-removed">485                 }</span>
486             }
487             out.write(&quot;};&quot;);
488             out.write(&quot;&quot;);
<span class="line-modified">489             out.write(&quot;static const JfrTypeId FIRST_TYPE_ID = &quot; + typeCounter.firstTypeName() + &quot;;&quot;);</span>
<span class="line-modified">490             out.write(&quot;static const JfrTypeId LAST_TYPE_ID = &quot; + typeCounter.lastTypeName() + &quot;;&quot;);</span>
<span class="line-modified">491 </span>

492             out.write(&quot;&quot;);
493             out.write(&quot;class JfrType : public AllStatic {&quot;);
494             out.write(&quot; public:&quot;);
495             out.write(&quot;  static jlong name_to_id(const char* type_name) {&quot;);
<span class="line-modified">496             for (Entry&lt;String, XmlType&gt; m : javaTypes.entrySet()) {</span>
<span class="line-modified">497                 XmlType xmlType = m.getValue();</span>






498                 String javaName = xmlType.javaType;
499                 String typeName = xmlType.name.toUpperCase();
500                 out.write(&quot;    if (strcmp(type_name, \&quot;&quot; + javaName + &quot;\&quot;) == 0) {&quot;);
501                 out.write(&quot;      return TYPE_&quot; + typeName + &quot;;&quot;);
502                 out.write(&quot;    }&quot;);
503             }
504             out.write(&quot;    return -1;&quot;);
505             out.write(&quot;  }&quot;);
506             out.write(&quot;};&quot;);
507             out.write(&quot;&quot;);
508             out.write(&quot;#endif // INCLUDE_JFR&quot;);
509             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
510         }
<span class="line-removed">511         ;</span>
512     }
513 
<span class="line-modified">514     private static void printJfrEventClassesHpp(Metadata metadata, File outputDirectory) throws Exception {</span>
<span class="line-modified">515         try (Printer out = new Printer(outputDirectory, &quot;jfrEventClasses.hpp&quot;)) {</span>




516             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
517             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
518             out.write(&quot;&quot;);
519             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
520             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
521             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
522             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
523             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
524             out.write(&quot;#if INCLUDE_JFR&quot;);
525             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
526             out.write(&quot;#include \&quot;jfr/support/jfrEpochSynchronization.hpp\&quot;&quot;);
527             out.write(&quot;/*&quot;);
528             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
529             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
530             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
531             out.write(&quot; * and set before attempting to commit.&quot;);
532             out.write(&quot; *&quot;);
533             out.write(&quot; * We enforce this requirement because events are generally stack allocated and therefore&quot;);
534             out.write(&quot; * *not* initialized to default values. This prevents us from inadvertently committing&quot;);
535             out.write(&quot; * uninitialized values to the data stream.&quot;);
</pre>
<hr />
<pre>
549             out.write(&quot;  void set_starttime(const Ticks&amp;) const {}&quot;);
550             out.write(&quot;  void set_endtime(const Ticks&amp;) const {}&quot;);
551             out.write(&quot;  bool should_commit() const { return false; }&quot;);
552             out.write(&quot;  static bool is_enabled() { return false; }&quot;);
553             out.write(&quot;  void commit() {}&quot;);
554             out.write(&quot;};&quot;);
555             out.write(&quot;&quot;);
556             printTypes(out, metadata, true);
557             out.write(&quot;&quot;);
558             out.write(&quot;&quot;);
559             out.write(&quot;#endif // INCLUDE_JFR&quot;);
560             out.write(&quot;#endif // JFRFILES_JFREVENTCLASSES_HPP&quot;);
561         }
562     }
563 
564     private static void printTypes(Printer out, Metadata metadata, boolean empty) {
565         for (TypeElement t : metadata.getStructs()) {
566             printType(out, t, empty);
567             out.write(&quot;&quot;);
568         }
<span class="line-modified">569         for (EventElement e : metadata.getEvents()) {</span>
570             printEvent(out, e, empty);
571             out.write(&quot;&quot;);
572         }
573     }
574 
575     private static void printType(Printer out, TypeElement t, boolean empty) {
576         out.write(&quot;struct JfrStruct&quot; + t.name);
577         out.write(&quot;{&quot;);
578         if (!empty) {
<span class="line-modified">579           out.write(&quot; private:&quot;);</span>
<span class="line-modified">580           for (FieldElement f : t.fields) {</span>
<span class="line-modified">581               printField(out, f);</span>
<span class="line-modified">582           }</span>
<span class="line-modified">583           out.write(&quot;&quot;);</span>
584         }
585         out.write(&quot; public:&quot;);
586         for (FieldElement f : t.fields) {
<span class="line-modified">587            printTypeSetter(out, f, empty);</span>
588         }
589         out.write(&quot;&quot;);
590         if (!empty) {
<span class="line-modified">591           printWriteData(out, t.fields, null);</span>
592         }
593         out.write(&quot;};&quot;);
594         out.write(&quot;&quot;);
595     }
596 
<span class="line-modified">597     private static void printEvent(Printer out, EventElement event, boolean empty) {</span>
598         out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
599         out.write(&quot;{&quot;);
600         if (!empty) {
<span class="line-modified">601           out.write(&quot; private:&quot;);</span>
<span class="line-modified">602           for (FieldElement f : event.fields) {</span>
<span class="line-modified">603               printField(out, f);</span>
<span class="line-modified">604           }</span>
<span class="line-modified">605           out.write(&quot;&quot;);</span>
606         }
607         out.write(&quot; public:&quot;);
608         if (!empty) {
<span class="line-modified">609           out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);</span>
<span class="line-modified">610           out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);</span>
<span class="line-modified">611           out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);</span>
<span class="line-modified">612           out.write(&quot;  static const bool hasCutoff = &quot; + event.cutoff + &quot;;&quot;);</span>
<span class="line-modified">613           out.write(&quot;  static const bool isRequestable = &quot; + event.periodic + &quot;;&quot;);</span>
<span class="line-modified">614           out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);</span>
<span class="line-modified">615           out.write(&quot;&quot;);</span>
616         }
617         if (!empty) {
<span class="line-modified">618           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(timing) {}&quot;);</span>

619         } else {
<span class="line-modified">620           out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);</span>
621         }
622         out.write(&quot;&quot;);
623         int index = 0;
624         for (FieldElement f : event.fields) {
625             out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
626             if (!empty) {
<span class="line-modified">627               out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);</span>
<span class="line-modified">628               out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);</span>
629             }
630             out.write(&quot;  }&quot;);
631         }
632         out.write(&quot;&quot;);
633         if (!empty) {
<span class="line-modified">634           printWriteData(out, event.fields, event.commitState);</span>
<span class="line-modified">635           out.write(&quot;&quot;);</span>
636         }
<span class="line-modified">637         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);</span>

638         printConstructor2(out, event, empty);
639         printCommitMethod(out, event, empty);
640         if (!empty) {
<span class="line-modified">641           printVerify(out, event.fields);</span>
642         }
643         out.write(&quot;};&quot;);
644     }
645 
<span class="line-modified">646     private static void printWriteData(Printer out, List&lt;FieldElement&gt; fields, String commitState) {</span>
647         out.write(&quot;  template &lt;typename Writer&gt;&quot;);
648         out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
<span class="line-modified">649         if ((&quot;_thread_in_native&quot;).equals(commitState)) {</span>
650             out.write(&quot;    // explicit epoch synchronization check&quot;);
651             out.write(&quot;    JfrEpochSynchronization sync;&quot;);
652         }
<span class="line-modified">653         for (FieldElement field : fields) {</span>
654             if (field.struct) {
655                 out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
656             } else {
657                 out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
658             }
659         }
660         out.write(&quot;  }&quot;);
661     }
662 
663     private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
664         if (!empty) {
<span class="line-modified">665           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name + &quot; = new_value; }&quot;);</span>

666         } else {
<span class="line-modified">667           out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);</span>
668         }
669     }
670 
671     private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
672         out.write(&quot;&quot;);
673         out.write(&quot;#ifdef ASSERT&quot;);
674         out.write(&quot;  void verify() const {&quot;);
675         int index = 0;
676         for (FieldElement f : fields) {
<span class="line-modified">677             out.write(&quot;    assert(verify_field_bit(&quot; + index++ + &quot;), \&quot;Attempting to write an uninitialized event field: %s\&quot;, \&quot;_&quot; + f.name + &quot;\&quot;);&quot;);</span>

678         }
679         out.write(&quot;  }&quot;);
680         out.write(&quot;#endif&quot;);
681     }
682 
<span class="line-modified">683     private static void printCommitMethod(Printer out, EventElement event, boolean empty) {</span>
684         if (event.startTime) {
685             StringJoiner sj = new StringJoiner(&quot;,\n              &quot;);
686             for (FieldElement f : event.fields) {
687                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
688             }
689             out.write(&quot;&quot;);
690             out.write(&quot;  void commit(&quot; + sj.toString() + &quot;) {&quot;);
691             if (!empty) {
<span class="line-modified">692               out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">693               for (FieldElement f : event.fields) {</span>
<span class="line-modified">694                   out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">695               }</span>
<span class="line-modified">696               out.write(&quot;      commit();&quot;);</span>
<span class="line-modified">697               out.write(&quot;    }&quot;);</span>
698             }
699             out.write(&quot;  }&quot;);
700         }
701 
702         // Avoid clash with static commit() method
703         if (event.fields.isEmpty()) {
704             return;
705         }
706 
707         out.write(&quot;&quot;);
708         StringJoiner sj = new StringJoiner(&quot;,\n                     &quot;);
709         if (event.startTime) {
710             sj.add(&quot;const Ticks&amp; startTicks&quot;);
711             sj.add(&quot;const Ticks&amp; endTicks&quot;);
712         }
713         for (FieldElement f : event.fields) {
714             sj.add(f.getParameterType() + &quot; &quot; + f.name);
715         }
716         out.write(&quot;  static void commit(&quot; + sj.toString() + &quot;) {&quot;);
717         if (!empty) {
<span class="line-modified">718           out.write(&quot;    Event&quot; + event.name + &quot; me(UNTIMED);&quot;);</span>
<span class="line-modified">719           out.write(&quot;&quot;);</span>
<span class="line-modified">720           out.write(&quot;    if (me.should_commit()) {&quot;);</span>
<span class="line-modified">721           if (event.startTime) {</span>
<span class="line-modified">722               out.write(&quot;      me.set_starttime(startTicks);&quot;);</span>
<span class="line-modified">723               out.write(&quot;      me.set_endtime(endTicks);&quot;);</span>
<span class="line-modified">724           }</span>
<span class="line-modified">725           for (FieldElement f : event.fields) {</span>
<span class="line-modified">726               out.write(&quot;      me.set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">727           }</span>
<span class="line-modified">728           out.write(&quot;      me.commit();&quot;);</span>
<span class="line-modified">729           out.write(&quot;    }&quot;);</span>
730         }
731         out.write(&quot;  }&quot;);
732     }
733 
<span class="line-modified">734     private static void printConstructor2(Printer out, EventElement event, boolean empty) {</span>
735         if (!event.startTime) {
736             out.write(&quot;&quot;);
737             out.write(&quot;&quot;);
738         }
739         if (event.startTime) {
740             out.write(&quot;&quot;);
741             out.write(&quot;  Event&quot; + event.name + &quot;(&quot;);
742             StringJoiner sj = new StringJoiner(&quot;,\n    &quot;);
743             for (FieldElement f : event.fields) {
744                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
745             }
746             if (!empty) {
<span class="line-modified">747               out.write(&quot;    &quot; + sj.toString() + &quot;) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(TIMED) {&quot;);</span>
<span class="line-modified">748               out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">749               for (FieldElement f : event.fields) {</span>
<span class="line-modified">750                   out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">751               }</span>
<span class="line-modified">752               out.write(&quot;    }&quot;);</span>
753             } else {
<span class="line-modified">754               out.write(&quot;    &quot; + sj.toString() + &quot;) {&quot;);</span>
755             }
756             out.write(&quot;  }&quot;);
757         }
758     }
759 
760     private static void printField(Printer out, FieldElement field) {
761         out.write(&quot;  &quot; + field.getFieldType() + &quot; _&quot; + field.name + &quot;;&quot;);
762     }
763 }
</pre>
</td>
<td>
<hr />
<pre>
  1 package build.tools.jfr;
  2 
  3 import java.io.BufferedOutputStream;
<span class="line-added">  4 import java.io.Closeable;</span>
<span class="line-added">  5 import java.io.DataOutputStream;</span>
  6 import java.io.File;
  7 import java.io.FileNotFoundException;
  8 import java.io.FileOutputStream;
  9 import java.io.IOException;
 10 import java.io.PrintStream;
 11 import java.util.ArrayList;
<span class="line-added"> 12 import java.util.Arrays;</span>
 13 import java.util.LinkedHashMap;
 14 import java.util.List;
 15 import java.util.Map;
<span class="line-modified"> 16 import java.util.Objects;</span>
 17 import java.util.StringJoiner;
 18 import java.util.function.Predicate;
 19 
 20 import javax.xml.XMLConstants;
 21 import javax.xml.parsers.ParserConfigurationException;
 22 import javax.xml.parsers.SAXParser;
 23 import javax.xml.parsers.SAXParserFactory;
 24 import javax.xml.validation.SchemaFactory;
 25 
 26 import org.xml.sax.Attributes;
 27 import org.xml.sax.SAXException;
 28 import org.xml.sax.SAXParseException;
 29 import org.xml.sax.helpers.DefaultHandler;
 30 
<span class="line-added"> 31 /**</span>
<span class="line-added"> 32  * Purpose of this program is twofold:</span>
<span class="line-added"> 33  *</span>
<span class="line-added"> 34  * 1) Generate C++ classes to be used when writing native events for HotSpot.</span>
<span class="line-added"> 35  *</span>
<span class="line-added"> 36  * 2) Generate metadata (label, descriptions, field layout etc.) from XML</span>
<span class="line-added"> 37  * (metadata.xml) into a binary format (metadata.bin) that can be read quickly</span>
<span class="line-added"> 38  * during startup by the jdk.jfr module.</span>
<span class="line-added"> 39  *</span>
<span class="line-added"> 40  * INPUT FILES:</span>
<span class="line-added"> 41  *</span>
<span class="line-added"> 42  * -  metadata.xml  File that contains descriptions of events and types</span>
<span class="line-added"> 43  * -  metadata.xsd  Schema that verifies that metadata.xml is legit XML</span>
<span class="line-added"> 44  *</span>
<span class="line-added"> 45  * OUTPUT FILES:</span>
<span class="line-added"> 46  *</span>
<span class="line-added"> 47  * MODE: headers</span>
<span class="line-added"> 48  *</span>
<span class="line-added"> 49  * - jfrEventIds.hpp      List of IDs so events can be identified from native</span>
<span class="line-added"> 50  * - jfrTypes.hpp         List of IDs so types can be identified from native</span>
<span class="line-added"> 51  * - jfrPeriodic.hpp      Dispatch mechanism so Java can emit native periodic events</span>
<span class="line-added"> 52  * - jfrEventControl.hpp  Data structure for native event settings.</span>
<span class="line-added"> 53  * - jfrEventClasses.hpp  C++ event classes that can write data into native buffers</span>
<span class="line-added"> 54  *</span>
<span class="line-added"> 55  * MODE: metadata</span>
<span class="line-added"> 56  *</span>
<span class="line-added"> 57  *  - metadata.bin        Binary representation of the information in metadata.xml</span>
<span class="line-added"> 58  *</span>
<span class="line-added"> 59  */</span>
 60 public class GenerateJfrFiles {
 61 
<span class="line-modified"> 62     enum OutputMode {</span>
<span class="line-modified"> 63         headers, metadata</span>

























 64     }
 65 
<span class="line-modified"> 66     private static void printUsage(PrintStream out) {</span>
<span class="line-modified"> 67         out.println(&quot;Usage: java GenerateJfrFiles[.java]&quot;);</span>
<span class="line-modified"> 68         out.println(&quot; --mode &lt;headers|metadata&gt;&quot;);</span>
<span class="line-modified"> 69         out.println(&quot; --xml &lt;path-to-metadata.xml&gt; &quot;);</span>
<span class="line-modified"> 70         out.println(&quot; --xsd &lt;path-to-metadata.xsd&gt;&quot;);</span>
<span class="line-modified"> 71         out.println(&quot; --output &lt;output-file-or-directory&gt;&quot;);</span>
<span class="line-modified"> 72     }</span>


 73 
<span class="line-modified"> 74     private static String consumeOption(String option, List&lt;String&gt; argList) throws Exception {</span>
<span class="line-modified"> 75         int index = argList.indexOf(option);</span>
<span class="line-modified"> 76         if (index &gt;= 0 &amp;&amp; index &lt;= argList.size() - 2) {</span>
<span class="line-modified"> 77             String result = argList.get(index + 1);</span>
<span class="line-modified"> 78             argList.remove(index);</span>
<span class="line-modified"> 79             argList.remove(index);</span>
<span class="line-modified"> 80             return result;</span>


 81         }
<span class="line-added"> 82         throw new IllegalArgumentException(&quot;missing option &quot; + option);</span>
<span class="line-added"> 83     }</span>
 84 
<span class="line-modified"> 85     public static void main(String... args) throws Exception {</span>
<span class="line-modified"> 86         try {</span>
<span class="line-modified"> 87             List&lt;String&gt; argList = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 88             argList.addAll(Arrays.asList(args));</span>
<span class="line-added"> 89             String mode = consumeOption(&quot;--mode&quot;, argList);</span>
<span class="line-added"> 90             String output = consumeOption(&quot;--output&quot;, argList);</span>
<span class="line-added"> 91             String xml = consumeOption(&quot;--xml&quot;, argList);</span>
<span class="line-added"> 92             String xsd = consumeOption(&quot;--xsd&quot;, argList);</span>
<span class="line-added"> 93             if (!argList.isEmpty()) {</span>
<span class="line-added"> 94                 throw new IllegalArgumentException(&quot;unknown option &quot; + argList);</span>
 95             }
<span class="line-modified"> 96             OutputMode outputMode = OutputMode.valueOf(mode);</span>
<span class="line-modified"> 97             File xmlFile = new File(xml);</span>
<span class="line-modified"> 98             File xsdFile = new File(xsd);</span>
















 99 
<span class="line-modified">100             Metadata metadata = new Metadata(xmlFile, xsdFile);</span>
<span class="line-modified">101             metadata.verify();</span>
<span class="line-modified">102             metadata.wireUpTypes();</span>
103 
<span class="line-modified">104             if (outputMode == OutputMode.headers) {</span>
<span class="line-modified">105                 File outputDir = new File(output);</span>
<span class="line-modified">106                 printJfrEventIdsHpp(metadata, new File(outputDir, &quot;jfrEventIds.hpp&quot;));</span>
<span class="line-added">107                 printJfrTypesHpp(metadata, new File(outputDir, &quot;jfrTypes.hpp&quot;));</span>
<span class="line-added">108                 printJfrPeriodicHpp(metadata, new File(outputDir, &quot;jfrPeriodic.hpp&quot;));</span>
<span class="line-added">109                 printJfrEventControlHpp(metadata, new File(outputDir, &quot;jfrEventControl.hpp&quot;));</span>
<span class="line-added">110                 printJfrEventClassesHpp(metadata, new File(outputDir, &quot;jfrEventClasses.hpp&quot;));</span>
<span class="line-added">111             }</span>
112 
<span class="line-modified">113             if (outputMode == OutputMode.metadata) {</span>
<span class="line-modified">114                 File outputFile  = new File(output);</span>
<span class="line-added">115                 try (var b = new DataOutputStream(</span>
<span class="line-added">116                         new BufferedOutputStream(</span>
<span class="line-added">117                             new FileOutputStream(outputFile)))) {</span>
<span class="line-added">118                     metadata.persist(b);</span>
<span class="line-added">119                 }</span>
<span class="line-added">120             }</span>
<span class="line-added">121             System.exit(0);</span>
<span class="line-added">122         } catch (IllegalArgumentException iae) {</span>
<span class="line-added">123             System.err.println();</span>
<span class="line-added">124             System.err.println(&quot;GenerateJfrFiles: &quot; + iae.getMessage());</span>
<span class="line-added">125             System.err.println();</span>
<span class="line-added">126             printUsage(System.err);</span>
<span class="line-added">127             System.err.println();</span>
<span class="line-added">128         } catch (Exception e) {</span>
<span class="line-added">129             e.printStackTrace();</span>
130         }
<span class="line-added">131         System.exit(1);</span>
132     }
133 
134     static class XmlType {
135         final String name;
136         final String fieldType;
137         final String parameterType;
138         final String javaType;
139         final boolean unsigned;
<span class="line-added">140         final String contentType;</span>
141 
<span class="line-modified">142         XmlType(String name, String fieldType, String parameterType, String javaType, String contentType,</span>
<span class="line-added">143                 boolean unsigned) {</span>
144             this.name = name;
145             this.fieldType = fieldType;
146             this.parameterType = parameterType;
147             this.javaType = javaType;
148             this.unsigned = unsigned;
<span class="line-added">149             this.contentType = contentType;</span>
<span class="line-added">150         }</span>
<span class="line-added">151     }</span>
<span class="line-added">152 </span>
<span class="line-added">153     static class XmlContentType {</span>
<span class="line-added">154         final String name;</span>
<span class="line-added">155         final String annotation;</span>
<span class="line-added">156 </span>
<span class="line-added">157         XmlContentType(String name, String annotation) {</span>
<span class="line-added">158             this.name = name;</span>
<span class="line-added">159             this.annotation = annotation;</span>
160         }
161     }
162 
163     static class TypeElement {
164         List&lt;FieldElement&gt; fields = new ArrayList&lt;&gt;();
165         String name;
<span class="line-modified">166         String javaType;</span>
<span class="line-modified">167         String label = &quot;&quot;;</span>
<span class="line-modified">168         String description = &quot;&quot;;</span>
<span class="line-added">169         String category = &quot;&quot;;</span>
<span class="line-added">170         boolean thread;</span>
<span class="line-added">171         boolean stackTrace;</span>
<span class="line-added">172         boolean startTime;</span>
<span class="line-added">173         String period = &quot;&quot;;</span>
<span class="line-added">174         boolean cutoff;</span>
<span class="line-added">175         boolean experimental;</span>
<span class="line-added">176         long id;</span>
<span class="line-added">177         boolean isEvent;</span>
<span class="line-added">178         boolean isRelation;</span>
<span class="line-added">179         boolean supportStruct = false;</span>
<span class="line-added">180         String commitState;</span>
<span class="line-added">181         public boolean primitive;</span>
<span class="line-added">182 </span>
<span class="line-added">183         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-added">184             pos.writeInt(fields.size());</span>
<span class="line-added">185             for (FieldElement field : fields) {</span>
<span class="line-added">186                 field.persist(pos);</span>
<span class="line-added">187             }</span>
<span class="line-added">188             pos.writeUTF(javaType);</span>
<span class="line-added">189             pos.writeUTF(label);</span>
<span class="line-added">190             pos.writeUTF(description);</span>
<span class="line-added">191             pos.writeUTF(category);</span>
<span class="line-added">192             pos.writeBoolean(thread);</span>
<span class="line-added">193             pos.writeBoolean(stackTrace);</span>
<span class="line-added">194             pos.writeBoolean(startTime);</span>
<span class="line-added">195             pos.writeUTF(period);</span>
<span class="line-added">196             pos.writeBoolean(cutoff);</span>
<span class="line-added">197             pos.writeBoolean(experimental);</span>
<span class="line-added">198             pos.writeLong(id);</span>
<span class="line-added">199             pos.writeBoolean(isEvent);</span>
<span class="line-added">200             pos.writeBoolean(isRelation);</span>
<span class="line-added">201         }</span>
202     }
203 
204     static class Metadata {
<span class="line-added">205         static class TypeCounter {</span>
<span class="line-added">206             final long first;</span>
<span class="line-added">207             long last = -1;</span>
<span class="line-added">208             long count = 0;</span>
<span class="line-added">209             long id = -1;</span>
<span class="line-added">210 </span>
<span class="line-added">211             TypeCounter(long startId) {</span>
<span class="line-added">212                 this.first = startId;</span>
<span class="line-added">213             }</span>
<span class="line-added">214 </span>
<span class="line-added">215             long next() {</span>
<span class="line-added">216                 id = (id == -1) ? first : id + 1;</span>
<span class="line-added">217                 count++;</span>
<span class="line-added">218                 last = id;</span>
<span class="line-added">219                 return id;</span>
<span class="line-added">220             }</span>
<span class="line-added">221         }</span>
<span class="line-added">222 </span>
<span class="line-added">223         static int RESERVED_EVENT_COUNT = 2;</span>
224         final Map&lt;String, TypeElement&gt; types = new LinkedHashMap&lt;&gt;();
225         final Map&lt;String, XmlType&gt; xmlTypes = new LinkedHashMap&lt;&gt;();
<span class="line-modified">226         final Map&lt;String, XmlContentType&gt; xmlContentTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-added">227         int lastEventId;</span>
<span class="line-added">228         private TypeCounter eventCounter;</span>
<span class="line-added">229         private TypeCounter typeCounter;</span>
<span class="line-added">230 </span>
<span class="line-added">231         Metadata(File metadataXml, File metadataSchema)</span>
<span class="line-added">232                 throws ParserConfigurationException, SAXException, FileNotFoundException, IOException {</span>
233             SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
234             SAXParserFactory factory = SAXParserFactory.newInstance();
235             factory.setSchema(schemaFactory.newSchema(metadataSchema));
236             SAXParser sp = factory.newSAXParser();
237             sp.parse(metadataXml, new MetadataHandler(this));
238         }
239 
<span class="line-modified">240         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-modified">241             pos.writeInt(types.values().size());</span>
<span class="line-added">242             for (TypeElement t : types.values()) {</span>
<span class="line-added">243                 t.persist(pos);</span>
<span class="line-added">244             }</span>
245         }
246 
<span class="line-modified">247         List&lt;TypeElement&gt; getEvents() {</span>
<span class="line-modified">248             return getList(t -&gt; t.isEvent);</span>
249         }
250 
<span class="line-modified">251         List&lt;TypeElement&gt; getEventsAndStructs() {</span>
<span class="line-modified">252             return getList(t -&gt; t.isEvent || t.supportStruct);</span>
253         }
254 
255         @SuppressWarnings(&quot;unchecked&quot;)
256         &lt;T&gt; List&lt;T&gt; getList(Predicate&lt;? super TypeElement&gt; pred) {
257             List&lt;T&gt; result = new ArrayList&lt;&gt;(types.size());
258             for (TypeElement t : types.values()) {
259                 if (pred.test(t)) {
260                     result.add((T) t);
261                 }
262             }
263             return result;
264         }
265 
<span class="line-modified">266         List&lt;TypeElement&gt; getPeriodicEvents() {</span>
<span class="line-modified">267             return getList(t -&gt; t.isEvent &amp;&amp; !t.period.isEmpty());</span>
268         }
269 
270         List&lt;TypeElement&gt; getTypes() {
<span class="line-modified">271             return getList(t -&gt; !t.isEvent);</span>
272         }
273 
274         List&lt;TypeElement&gt; getStructs() {
<span class="line-modified">275             return getList(t -&gt; !t.isEvent &amp;&amp; t.supportStruct);</span>
276         }
277 
<span class="line-modified">278         void verify() {</span>
279             for (TypeElement t : types.values()) {
280                 for (FieldElement f : t.fields) {
281                     if (!xmlTypes.containsKey(f.typeName)) { // ignore primitives
282                         if (!types.containsKey(f.typeName)) {
<span class="line-modified">283                             throw new IllegalStateException(&quot;Could not find definition of type &#39;&quot; + f.typeName</span>
<span class="line-added">284                                     + &quot;&#39; used by &quot; + t.name + &quot;#&quot; + f.name);</span>
285                         }
286                     }
287                 }
288             }
289         }
290 
291         void wireUpTypes() {
<span class="line-added">292             // Add Java primitives</span>
<span class="line-added">293             for (var t : xmlTypes.entrySet()) {</span>
<span class="line-added">294                 String name = t.getKey();</span>
<span class="line-added">295                 XmlType xmlType = t.getValue();</span>
<span class="line-added">296                 // Excludes Thread and Class</span>
<span class="line-added">297                 if (!types.containsKey(name)) {</span>
<span class="line-added">298                     // Excludes u8, u4, u2, u1, Ticks and Ticksspan</span>
<span class="line-added">299                     if (!xmlType.javaType.isEmpty() &amp;&amp; !xmlType.unsigned) {</span>
<span class="line-added">300                         TypeElement te = new TypeElement();</span>
<span class="line-added">301                         te.name = name;</span>
<span class="line-added">302                         te.javaType = xmlType.javaType;</span>
<span class="line-added">303                         te.primitive = true;</span>
<span class="line-added">304                         types.put(te.name, te);</span>
<span class="line-added">305                     }</span>
<span class="line-added">306                 }</span>
<span class="line-added">307             }</span>
<span class="line-added">308             // Setup Java fully qualified names</span>
<span class="line-added">309             for (TypeElement t : types.values()) {</span>
<span class="line-added">310                 if (t.isEvent) {</span>
<span class="line-added">311                     t.javaType = &quot;jdk.&quot; + t.name;</span>
<span class="line-added">312                 } else {</span>
<span class="line-added">313                     XmlType xmlType = xmlTypes.get(t.name);</span>
<span class="line-added">314                     if (xmlType != null &amp;&amp; !xmlType.javaType.isEmpty()) {</span>
<span class="line-added">315                         t.javaType = xmlType.javaType;</span>
<span class="line-added">316                     } else {</span>
<span class="line-added">317                         t.javaType = &quot;jdk.types.&quot; + t.name;</span>
<span class="line-added">318                     }</span>
<span class="line-added">319                 }</span>
<span class="line-added">320             }</span>
<span class="line-added">321             // Setup content type, annotation, constant pool etc. for fields.</span>
322             for (TypeElement t : types.values()) {
323                 for (FieldElement f : t.fields) {
324                     TypeElement type = types.get(f.typeName);
<span class="line-added">325                     XmlType xmlType = xmlTypes.get(f.typeName);</span>
<span class="line-added">326                     if (type == null) {</span>
<span class="line-added">327                         if (xmlType == null) {</span>
<span class="line-added">328                             throw new IllegalStateException(&quot;Unknown type&quot;);</span>
<span class="line-added">329                         }</span>
<span class="line-added">330                         if (f.contentType.isEmpty()) {</span>
<span class="line-added">331                             f.contentType = xmlType.contentType;</span>
<span class="line-added">332                         }</span>
<span class="line-added">333                         String javaType = xmlType.javaType;</span>
<span class="line-added">334                         type = types.get(javaType);</span>
<span class="line-added">335                         Objects.requireNonNull(type);</span>
<span class="line-added">336                     }</span>
<span class="line-added">337                     if (type.primitive) {</span>
<span class="line-added">338                         f.constantPool = false;</span>
<span class="line-added">339                     }</span>
<span class="line-added">340 </span>
<span class="line-added">341                     if (xmlType != null) {</span>
<span class="line-added">342                         f.unsigned = xmlType.unsigned;</span>
<span class="line-added">343                     }</span>
<span class="line-added">344 </span>
345                     if (f.struct) {
<span class="line-added">346                         f.constantPool = false;</span>
347                         type.supportStruct = true;
348                     }
349                     f.type = type;
<span class="line-added">350                     XmlContentType xmlContentType = xmlContentTypes.get(f.contentType);</span>
<span class="line-added">351                     if (xmlContentType == null) {</span>
<span class="line-added">352                         f.annotations = &quot;&quot;;</span>
<span class="line-added">353                     } else {</span>
<span class="line-added">354                         f.annotations = xmlContentType.annotation;</span>
<span class="line-added">355                     }</span>
<span class="line-added">356                     if (!f.relation.isEmpty()) {</span>
<span class="line-added">357                         f.relation = &quot;jdk.types.&quot; + f.relation;</span>
<span class="line-added">358                     }</span>
359                 }
360             }
<span class="line-added">361 </span>
<span class="line-added">362             // Low numbers for event so most of them</span>
<span class="line-added">363             // can fit in one byte with compressed integers</span>
<span class="line-added">364             eventCounter = new TypeCounter(RESERVED_EVENT_COUNT);</span>
<span class="line-added">365             for (TypeElement t : getEvents()) {</span>
<span class="line-added">366                 t.id = eventCounter.next();</span>
<span class="line-added">367             }</span>
<span class="line-added">368             typeCounter = new TypeCounter(eventCounter.last + 1);</span>
<span class="line-added">369             for (TypeElement t : getTypes()) {</span>
<span class="line-added">370                 t.id = typeCounter.next();</span>
<span class="line-added">371             }</span>
372         }

373 
<span class="line-modified">374         public String getName(long id) {</span>
<span class="line-modified">375             for (TypeElement t : types.values()) {</span>
<span class="line-modified">376                 if (t.id == id) {</span>
<span class="line-modified">377                     return t.name;</span>
<span class="line-modified">378                 }</span>
<span class="line-modified">379             }</span>
<span class="line-modified">380             throw new IllegalStateException(&quot;Unexpected id &quot; + id );</span>
<span class="line-modified">381         }</span>
382     }
383 
384     static class FieldElement {
385         final Metadata metadata;
386         TypeElement type;
387         String name;
388         String typeName;
<span class="line-modified">389         boolean constantPool = true;</span>
<span class="line-added">390         public String transition;</span>
<span class="line-added">391         public String contentType;</span>
<span class="line-added">392         private String label;</span>
<span class="line-added">393         private String description;</span>
<span class="line-added">394         private String relation;</span>
<span class="line-added">395         private boolean experimental;</span>
<span class="line-added">396         private boolean unsigned;</span>
<span class="line-added">397         private boolean array;</span>
<span class="line-added">398         private String annotations;</span>
<span class="line-added">399         public boolean struct;</span>
400 
401         FieldElement(Metadata metadata) {
402             this.metadata = metadata;
403         }
404 
<span class="line-added">405         public void persist(DataOutputStream pos) throws IOException {</span>
<span class="line-added">406             pos.writeUTF(name);</span>
<span class="line-added">407             pos.writeUTF(type.javaType);</span>
<span class="line-added">408             pos.writeUTF(label);</span>
<span class="line-added">409             pos.writeUTF(description);</span>
<span class="line-added">410             pos.writeBoolean(constantPool);</span>
<span class="line-added">411             pos.writeBoolean(array);</span>
<span class="line-added">412             pos.writeBoolean(unsigned);</span>
<span class="line-added">413             pos.writeUTF(annotations);</span>
<span class="line-added">414             pos.writeUTF(transition);</span>
<span class="line-added">415             pos.writeUTF(relation);</span>
<span class="line-added">416             pos.writeBoolean(experimental);</span>
<span class="line-added">417         }</span>
<span class="line-added">418 </span>
419         String getParameterType() {
420             if (struct) {
421                 return &quot;const JfrStruct&quot; + typeName + &quot;&amp;&quot;;
422             }
423             XmlType xmlType = metadata.xmlTypes.get(typeName);
424             if (xmlType != null) {
425                 return xmlType.parameterType;
426             }
427             return type != null ? &quot;u8&quot; : typeName;
428         }
429 
430         String getParameterName() {
431             return struct ? &quot;value&quot; : &quot;new_value&quot;;
432         }
433 
434         String getFieldType() {
435             if (struct) {
436                 return &quot;JfrStruct&quot; + typeName;
437             }
438             XmlType xmlType = metadata.xmlTypes.get(typeName);
439             if (xmlType != null) {
440                 return xmlType.fieldType;
441             }
442             return type != null ? &quot;u8&quot; : typeName;
443         }
444     }
445 
446     static class MetadataHandler extends DefaultHandler {
447         final Metadata metadata;
448         FieldElement currentField;
449         TypeElement currentType;
<span class="line-added">450 </span>
451         MetadataHandler(Metadata metadata) {
452             this.metadata = metadata;
453         }
<span class="line-added">454 </span>
455         @Override
456         public void error(SAXParseException e) throws SAXException {
<span class="line-modified">457             throw e;</span>
458         }
<span class="line-added">459 </span>
460         @Override
<span class="line-modified">461         public void startElement(String uri, String localName, String qName, Attributes attributes)</span>
<span class="line-added">462                 throws SAXException {</span>
463             switch (qName) {
<span class="line-added">464             case &quot;XmlContentType&quot;:</span>
<span class="line-added">465                 String n = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-added">466                 String a = attributes.getValue(&quot;annotation&quot;); // mandatory</span>
<span class="line-added">467                 metadata.xmlContentTypes.put(n, new XmlContentType(n, a));</span>
<span class="line-added">468                 break;</span>
469             case &quot;XmlType&quot;:
<span class="line-modified">470                 String name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-modified">471                 String parameterType = attributes.getValue(&quot;parameterType&quot;); // mandatory</span>
<span class="line-modified">472                 String fieldType = attributes.getValue(&quot;fieldType&quot;); // mandatory</span>
<span class="line-modified">473                 String javaType = getString(attributes, &quot;javaType&quot;);</span>
<span class="line-added">474                 String contentType = getString(attributes, &quot;contentType&quot;);</span>
475                 boolean unsigned = getBoolean(attributes, &quot;unsigned&quot;, false);
<span class="line-modified">476                 metadata.xmlTypes.put(name,</span>
<span class="line-added">477                         new XmlType(name, fieldType, parameterType, javaType, contentType, unsigned));</span>
478                 break;
479             case &quot;Relation&quot;:
480             case &quot;Type&quot;:



481             case &quot;Event&quot;:
<span class="line-modified">482                 currentType = new TypeElement();</span>
<span class="line-modified">483                 currentType.name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-modified">484                 currentType.label = getString(attributes, &quot;label&quot;);</span>
<span class="line-modified">485                 currentType.description = getString(attributes, &quot;description&quot;);</span>
<span class="line-modified">486                 currentType.category = getString(attributes, &quot;category&quot;);</span>
<span class="line-modified">487                 currentType.experimental = getBoolean(attributes, &quot;experimental&quot;, false);</span>
<span class="line-modified">488                 currentType.thread = getBoolean(attributes, &quot;thread&quot;, false);</span>
<span class="line-modified">489                 currentType.stackTrace = getBoolean(attributes, &quot;stackTrace&quot;, false);</span>
<span class="line-modified">490                 currentType.startTime = getBoolean(attributes, &quot;startTime&quot;, true);</span>
<span class="line-added">491                 currentType.period = getString(attributes, &quot;period&quot;);</span>
<span class="line-added">492                 currentType.cutoff = getBoolean(attributes, &quot;cutoff&quot;, false);</span>
<span class="line-added">493                 currentType.commitState = getString(attributes, &quot;commitState&quot;);</span>
<span class="line-added">494                 currentType.isEvent = &quot;Event&quot;.equals(qName);</span>
<span class="line-added">495                 currentType.isRelation = &quot;Relation&quot;.equals(qName);</span>
496                 break;
497             case &quot;Field&quot;:
498                 currentField = new FieldElement(metadata);
<span class="line-added">499                 currentField.name = attributes.getValue(&quot;name&quot;); // mandatory</span>
<span class="line-added">500                 currentField.typeName = attributes.getValue(&quot;type&quot;); // mandatory</span>
<span class="line-added">501                 currentField.label = getString(attributes, &quot;label&quot;);</span>
<span class="line-added">502                 currentField.description = getString(attributes, &quot;description&quot;);</span>
<span class="line-added">503                 currentField.contentType = getString(attributes, &quot;contentType&quot;);</span>
504                 currentField.struct = getBoolean(attributes, &quot;struct&quot;, false);
<span class="line-modified">505                 currentField.array = getBoolean(attributes, &quot;array&quot;, false);</span>
<span class="line-modified">506                 currentField.transition = getString(attributes, &quot;transition&quot;);</span>
<span class="line-added">507                 currentField.relation = getString(attributes, &quot;relation&quot;);</span>
<span class="line-added">508                 currentField.experimental = getBoolean(attributes, &quot;experimental&quot;, false);</span>
509                 break;
510             }
511         }
512 
<span class="line-modified">513         private static String getString(Attributes attributes, String name) {</span>
<span class="line-added">514             String value = attributes.getValue(name);</span>
<span class="line-added">515             return value != null ? value : &quot;&quot;;</span>
<span class="line-added">516         }</span>
<span class="line-added">517 </span>
<span class="line-added">518         private static boolean getBoolean(Attributes attributes, String name, boolean defaultValue) {</span>
519             String value = attributes.getValue(name);
520             return value == null ? defaultValue : Boolean.valueOf(value);
521         }
522 
523         @Override
524         public void endElement(String uri, String localName, String qName) {
525             switch (qName) {
526             case &quot;Relation&quot;:
527             case &quot;Type&quot;:
528             case &quot;Event&quot;:
529                 metadata.types.put(currentType.name, currentType);
530                 currentType = null;
531                 break;
532             case &quot;Field&quot;:
533                 currentType.fields.add(currentField);
534                 currentField = null;
535                 break;
536             }
537         }
538     }
539 
<span class="line-modified">540     static class Printer implements Closeable {</span>
541         final PrintStream out;
<span class="line-modified">542 </span>
<span class="line-modified">543         Printer(File outputFile) throws FileNotFoundException {</span>
<span class="line-added">544             out = new PrintStream(new BufferedOutputStream(new FileOutputStream(outputFile)));</span>
545             write(&quot;/* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */&quot;);
546             write(&quot;&quot;);
547         }
548 
549         void write(String text) {
550             out.print(text);
551             out.print(&quot;\n&quot;); // Don&#39;t use Windows line endings
552         }
553 
554         @Override
<span class="line-modified">555         public void close() throws IOException {</span>
556             out.close();
557         }
558     }
559 
<span class="line-modified">560     private static void printJfrPeriodicHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">561         try (var out = new Printer(outputFile)) {</span>
562             out.write(&quot;#ifndef JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
563             out.write(&quot;#define JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
564             out.write(&quot;&quot;);
565             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
566             out.write(&quot;#if INCLUDE_JFR&quot;);
567             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
568             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
569             out.write(&quot;&quot;);
570             out.write(&quot;class JfrPeriodicEventSet : public AllStatic {&quot;);
571             out.write(&quot; public:&quot;);
572             out.write(&quot;  static void requestEvent(JfrEventId id) {&quot;);
573             out.write(&quot;    switch(id) {&quot;);
574             out.write(&quot;  &quot;);
<span class="line-modified">575             for (TypeElement e : metadata.getPeriodicEvents()) {</span>
576                 out.write(&quot;      case Jfr&quot; + e.name + &quot;Event:&quot;);
577                 out.write(&quot;        request&quot; + e.name + &quot;();&quot;);
578                 out.write(&quot;        break;&quot;);
579                 out.write(&quot;  &quot;);
580             }
581             out.write(&quot;      default:&quot;);
582             out.write(&quot;        break;&quot;);
583             out.write(&quot;      }&quot;);
584             out.write(&quot;    }&quot;);
585             out.write(&quot;&quot;);
586             out.write(&quot; private:&quot;);
587             out.write(&quot;&quot;);
<span class="line-modified">588             for (TypeElement e : metadata.getPeriodicEvents()) {</span>
589                 out.write(&quot;  static void request&quot; + e.name + &quot;(void);&quot;);
590                 out.write(&quot;&quot;);
591             }
592             out.write(&quot;};&quot;);
593             out.write(&quot;&quot;);
594             out.write(&quot;#endif // INCLUDE_JFR&quot;);
595             out.write(&quot;#endif // JFRFILES_JFRPERIODICEVENTSET_HPP&quot;);
596         }
597     }
598 
<span class="line-modified">599     private static void printJfrEventControlHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">600         try (var out = new Printer(outputFile)) {</span>
601             out.write(&quot;#ifndef JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
602             out.write(&quot;#define JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
603             out.write(&quot;&quot;);
604             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
605             out.write(&quot;#if INCLUDE_JFR&quot;);
606             out.write(&quot;#include \&quot;jfrfiles/jfrEventIds.hpp\&quot;&quot;);
607             out.write(&quot;&quot;);
608             out.write(&quot;/**&quot;);
609             out.write(&quot; * Event setting. We add some padding so we can use our&quot;);
610             out.write(&quot; * event IDs as indexes into this.&quot;);
611             out.write(&quot; */&quot;);
612             out.write(&quot;&quot;);
613             out.write(&quot;struct jfrNativeEventSetting {&quot;);
614             out.write(&quot;  jlong  threshold_ticks;&quot;);
615             out.write(&quot;  jlong  cutoff_ticks;&quot;);
616             out.write(&quot;  u1     stacktrace;&quot;);
617             out.write(&quot;  u1     enabled;&quot;);
618             out.write(&quot;  u1     large;&quot;);
619             out.write(&quot;  u1     pad[5]; // Because GCC on linux ia32 at least tries to pack this.&quot;);
620             out.write(&quot;};&quot;);
621             out.write(&quot;&quot;);
622             out.write(&quot;union JfrNativeSettings {&quot;);
623             out.write(&quot;  // Array version.&quot;);
624             out.write(&quot;  jfrNativeEventSetting bits[NUMBER_OF_EVENTS];&quot;);
625             out.write(&quot;  // Then, to make it easy to debug,&quot;);
626             out.write(&quot;  // add named struct members also.&quot;);
627             out.write(&quot;  struct {&quot;);
628             out.write(&quot;    jfrNativeEventSetting pad[NUMBER_OF_RESERVED_EVENTS];&quot;);
629             for (TypeElement t : metadata.getEventsAndStructs()) {
630                 out.write(&quot;    jfrNativeEventSetting &quot; + t.name + &quot;;&quot;);
631             }
632             out.write(&quot;  } ev;&quot;);
633             out.write(&quot;};&quot;);
634             out.write(&quot;&quot;);
635             out.write(&quot;#endif // INCLUDE_JFR&quot;);
636             out.write(&quot;#endif // JFRFILES_JFR_NATIVE_EVENTSETTING_HPP&quot;);
637         }
638     }
639 
<span class="line-modified">640     private static void printJfrEventIdsHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-modified">641         try (var out = new Printer(outputFile)) {</span>
642             out.write(&quot;#ifndef JFRFILES_JFREVENTIDS_HPP&quot;);
643             out.write(&quot;#define JFRFILES_JFREVENTIDS_HPP&quot;);
644             out.write(&quot;&quot;);
645             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
646             out.write(&quot;#if INCLUDE_JFR&quot;);
647             out.write(&quot;&quot;);
648             out.write(&quot;enum JfrEventId {&quot;);
649             out.write(&quot;  JfrMetadataEvent = 0,&quot;);
650             out.write(&quot;  JfrCheckpointEvent = 1,&quot;);
651             for (TypeElement t : metadata.getEvents()) {
<span class="line-modified">652                 out.write(&quot;  &quot; + jfrEventId(t.name) + &quot; = &quot; + t.id + &quot;,&quot;);</span>

653             }
654             out.write(&quot;};&quot;);
655             out.write(&quot;typedef enum JfrEventId JfrEventId;&quot;);
656             out.write(&quot;&quot;);
<span class="line-modified">657             String first = metadata.getName(metadata.eventCounter.first);</span>
<span class="line-modified">658             String last = metadata.getName(metadata.eventCounter.last);</span>
<span class="line-modified">659             out.write(&quot;static const JfrEventId FIRST_EVENT_ID = &quot; + jfrEventId(first) + &quot;;&quot;);</span>
<span class="line-modified">660             out.write(&quot;static const JfrEventId LAST_EVENT_ID = &quot; + jfrEventId(last) + &quot;;&quot;);</span>
<span class="line-added">661             out.write(&quot;static const int NUMBER_OF_EVENTS = &quot; + metadata.eventCounter.count + &quot;;&quot;);</span>
<span class="line-added">662             out.write(&quot;static const int NUMBER_OF_RESERVED_EVENTS = &quot; + Metadata.RESERVED_EVENT_COUNT + &quot;;&quot;);</span>
663             out.write(&quot;#endif // INCLUDE_JFR&quot;);
664             out.write(&quot;#endif // JFRFILES_JFREVENTIDS_HPP&quot;);
665         }
666     }
667 
<span class="line-modified">668     private static String jfrEventId(String name) {</span>
<span class="line-modified">669         return &quot;Jfr&quot; + name + &quot;Event&quot;;</span>
<span class="line-added">670     }</span>
<span class="line-added">671 </span>
<span class="line-added">672     private static void printJfrTypesHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-added">673         try (var out = new Printer(outputFile)) {</span>
674             out.write(&quot;#ifndef JFRFILES_JFRTYPES_HPP&quot;);
675             out.write(&quot;#define JFRFILES_JFRTYPES_HPP&quot;);
676             out.write(&quot;&quot;);
677             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
678             out.write(&quot;#if INCLUDE_JFR&quot;);
679             out.write(&quot;&quot;);
680             out.write(&quot;#include &lt;string.h&gt;&quot;);
681             out.write(&quot;#include \&quot;memory/allocation.hpp\&quot;&quot;);
682             out.write(&quot;&quot;);
683             out.write(&quot;enum JfrTypeId {&quot;);











684             for (TypeElement type : metadata.getTypes()) {
<span class="line-modified">685                 out.write(&quot;  &quot; + jfrTypeId(type.name) + &quot; = &quot; + type.id + &quot;,&quot;);</span>





686             }
687             out.write(&quot;};&quot;);
688             out.write(&quot;&quot;);
<span class="line-modified">689             String first = metadata.getName(metadata.typeCounter.first);</span>
<span class="line-modified">690             String last = metadata.getName(metadata.typeCounter.last);</span>
<span class="line-modified">691             out.write(&quot;static const JfrTypeId FIRST_TYPE_ID = &quot; + jfrTypeId(first) + &quot;;&quot;);</span>
<span class="line-added">692             out.write(&quot;static const JfrTypeId LAST_TYPE_ID = &quot; + jfrTypeId(last) + &quot;;&quot;);</span>
693             out.write(&quot;&quot;);
694             out.write(&quot;class JfrType : public AllStatic {&quot;);
695             out.write(&quot; public:&quot;);
696             out.write(&quot;  static jlong name_to_id(const char* type_name) {&quot;);
<span class="line-modified">697 </span>
<span class="line-modified">698             Map&lt;String, XmlType&gt; javaTypes = new LinkedHashMap&lt;&gt;();</span>
<span class="line-added">699             for (XmlType xmlType : metadata.xmlTypes.values()) {</span>
<span class="line-added">700                 if (!xmlType.javaType.isEmpty()) {</span>
<span class="line-added">701                     javaTypes.put(xmlType.javaType, xmlType);</span>
<span class="line-added">702                 }</span>
<span class="line-added">703             }</span>
<span class="line-added">704             for (XmlType xmlType : javaTypes.values()) {</span>
705                 String javaName = xmlType.javaType;
706                 String typeName = xmlType.name.toUpperCase();
707                 out.write(&quot;    if (strcmp(type_name, \&quot;&quot; + javaName + &quot;\&quot;) == 0) {&quot;);
708                 out.write(&quot;      return TYPE_&quot; + typeName + &quot;;&quot;);
709                 out.write(&quot;    }&quot;);
710             }
711             out.write(&quot;    return -1;&quot;);
712             out.write(&quot;  }&quot;);
713             out.write(&quot;};&quot;);
714             out.write(&quot;&quot;);
715             out.write(&quot;#endif // INCLUDE_JFR&quot;);
716             out.write(&quot;#endif // JFRFILES_JFRTYPES_HPP&quot;);
717         }

718     }
719 
<span class="line-modified">720     private static String jfrTypeId(String name) {</span>
<span class="line-modified">721         return  &quot;TYPE_&quot; + name.toUpperCase();</span>
<span class="line-added">722     }</span>
<span class="line-added">723 </span>
<span class="line-added">724     private static void printJfrEventClassesHpp(Metadata metadata, File outputFile) throws Exception {</span>
<span class="line-added">725         try (var out = new Printer(outputFile)) {</span>
726             out.write(&quot;#ifndef JFRFILES_JFREVENTCLASSES_HPP&quot;);
727             out.write(&quot;#define JFRFILES_JFREVENTCLASSES_HPP&quot;);
728             out.write(&quot;&quot;);
729             out.write(&quot;#include \&quot;oops/klass.hpp\&quot;&quot;);
730             out.write(&quot;#include \&quot;jfrfiles/jfrTypes.hpp\&quot;&quot;);
731             out.write(&quot;#include \&quot;jfr/utilities/jfrTypes.hpp\&quot;&quot;);
732             out.write(&quot;#include \&quot;utilities/macros.hpp\&quot;&quot;);
733             out.write(&quot;#include \&quot;utilities/ticks.hpp\&quot;&quot;);
734             out.write(&quot;#if INCLUDE_JFR&quot;);
735             out.write(&quot;#include \&quot;jfr/recorder/service/jfrEvent.hpp\&quot;&quot;);
736             out.write(&quot;#include \&quot;jfr/support/jfrEpochSynchronization.hpp\&quot;&quot;);
737             out.write(&quot;/*&quot;);
738             out.write(&quot; * Each event class has an assert member function verify() which is invoked&quot;);
739             out.write(&quot; * just before the engine writes the event and its fields to the data stream.&quot;);
740             out.write(&quot; * The purpose of verify() is to ensure that all fields in the event are initialized&quot;);
741             out.write(&quot; * and set before attempting to commit.&quot;);
742             out.write(&quot; *&quot;);
743             out.write(&quot; * We enforce this requirement because events are generally stack allocated and therefore&quot;);
744             out.write(&quot; * *not* initialized to default values. This prevents us from inadvertently committing&quot;);
745             out.write(&quot; * uninitialized values to the data stream.&quot;);
</pre>
<hr />
<pre>
759             out.write(&quot;  void set_starttime(const Ticks&amp;) const {}&quot;);
760             out.write(&quot;  void set_endtime(const Ticks&amp;) const {}&quot;);
761             out.write(&quot;  bool should_commit() const { return false; }&quot;);
762             out.write(&quot;  static bool is_enabled() { return false; }&quot;);
763             out.write(&quot;  void commit() {}&quot;);
764             out.write(&quot;};&quot;);
765             out.write(&quot;&quot;);
766             printTypes(out, metadata, true);
767             out.write(&quot;&quot;);
768             out.write(&quot;&quot;);
769             out.write(&quot;#endif // INCLUDE_JFR&quot;);
770             out.write(&quot;#endif // JFRFILES_JFREVENTCLASSES_HPP&quot;);
771         }
772     }
773 
774     private static void printTypes(Printer out, Metadata metadata, boolean empty) {
775         for (TypeElement t : metadata.getStructs()) {
776             printType(out, t, empty);
777             out.write(&quot;&quot;);
778         }
<span class="line-modified">779         for (TypeElement e : metadata.getEvents()) {</span>
780             printEvent(out, e, empty);
781             out.write(&quot;&quot;);
782         }
783     }
784 
785     private static void printType(Printer out, TypeElement t, boolean empty) {
786         out.write(&quot;struct JfrStruct&quot; + t.name);
787         out.write(&quot;{&quot;);
788         if (!empty) {
<span class="line-modified">789             out.write(&quot; private:&quot;);</span>
<span class="line-modified">790             for (FieldElement f : t.fields) {</span>
<span class="line-modified">791                 printField(out, f);</span>
<span class="line-modified">792             }</span>
<span class="line-modified">793             out.write(&quot;&quot;);</span>
794         }
795         out.write(&quot; public:&quot;);
796         for (FieldElement f : t.fields) {
<span class="line-modified">797             printTypeSetter(out, f, empty);</span>
798         }
799         out.write(&quot;&quot;);
800         if (!empty) {
<span class="line-modified">801             printWriteData(out, t);</span>
802         }
803         out.write(&quot;};&quot;);
804         out.write(&quot;&quot;);
805     }
806 
<span class="line-modified">807     private static void printEvent(Printer out, TypeElement event, boolean empty) {</span>
808         out.write(&quot;class Event&quot; + event.name + &quot; : public JfrEvent&lt;Event&quot; + event.name + &quot;&gt;&quot;);
809         out.write(&quot;{&quot;);
810         if (!empty) {
<span class="line-modified">811             out.write(&quot; private:&quot;);</span>
<span class="line-modified">812             for (FieldElement f : event.fields) {</span>
<span class="line-modified">813                 printField(out, f);</span>
<span class="line-modified">814             }</span>
<span class="line-modified">815             out.write(&quot;&quot;);</span>
816         }
817         out.write(&quot; public:&quot;);
818         if (!empty) {
<span class="line-modified">819             out.write(&quot;  static const bool hasThread = &quot; + event.thread + &quot;;&quot;);</span>
<span class="line-modified">820             out.write(&quot;  static const bool hasStackTrace = &quot; + event.stackTrace + &quot;;&quot;);</span>
<span class="line-modified">821             out.write(&quot;  static const bool isInstant = &quot; + !event.startTime + &quot;;&quot;);</span>
<span class="line-modified">822             out.write(&quot;  static const bool hasCutoff = &quot; + event.cutoff + &quot;;&quot;);</span>
<span class="line-modified">823             out.write(&quot;  static const bool isRequestable = &quot; + !event.period.isEmpty() + &quot;;&quot;);</span>
<span class="line-modified">824             out.write(&quot;  static const JfrEventId eventId = Jfr&quot; + event.name + &quot;Event;&quot;);</span>
<span class="line-modified">825             out.write(&quot;&quot;);</span>
826         }
827         if (!empty) {
<span class="line-modified">828             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) : JfrEvent&lt;Event&quot; + event.name</span>
<span class="line-added">829                     + &quot;&gt;(timing) {}&quot;);</span>
830         } else {
<span class="line-modified">831             out.write(&quot;  Event&quot; + event.name + &quot;(EventStartTime timing=TIMED) {}&quot;);</span>
832         }
833         out.write(&quot;&quot;);
834         int index = 0;
835         for (FieldElement f : event.fields) {
836             out.write(&quot;  void set_&quot; + f.name + &quot;(&quot; + f.getParameterType() + &quot; &quot; + f.getParameterName() + &quot;) {&quot;);
837             if (!empty) {
<span class="line-modified">838                 out.write(&quot;    this-&gt;_&quot; + f.name + &quot; = &quot; + f.getParameterName() + &quot;;&quot;);</span>
<span class="line-modified">839                 out.write(&quot;    DEBUG_ONLY(set_field_bit(&quot; + index++ + &quot;));&quot;);</span>
840             }
841             out.write(&quot;  }&quot;);
842         }
843         out.write(&quot;&quot;);
844         if (!empty) {
<span class="line-modified">845             printWriteData(out, event);</span>
<span class="line-modified">846             out.write(&quot;&quot;);</span>
847         }
<span class="line-modified">848         out.write(&quot;  using JfrEvent&lt;Event&quot; + event.name</span>
<span class="line-added">849                 + &quot;&gt;::commit; // else commit() is hidden by overloaded versions in this class&quot;);</span>
850         printConstructor2(out, event, empty);
851         printCommitMethod(out, event, empty);
852         if (!empty) {
<span class="line-modified">853             printVerify(out, event.fields);</span>
854         }
855         out.write(&quot;};&quot;);
856     }
857 
<span class="line-modified">858     private static void printWriteData(Printer out, TypeElement type) {</span>
859         out.write(&quot;  template &lt;typename Writer&gt;&quot;);
860         out.write(&quot;  void writeData(Writer&amp; w) {&quot;);
<span class="line-modified">861         if ((&quot;_thread_in_native&quot;).equals(type.commitState)) {</span>
862             out.write(&quot;    // explicit epoch synchronization check&quot;);
863             out.write(&quot;    JfrEpochSynchronization sync;&quot;);
864         }
<span class="line-modified">865         for (FieldElement field : type.fields) {</span>
866             if (field.struct) {
867                 out.write(&quot;    _&quot; + field.name + &quot;.writeData(w);&quot;);
868             } else {
869                 out.write(&quot;    w.write(_&quot; + field.name + &quot;);&quot;);
870             }
871         }
872         out.write(&quot;  }&quot;);
873     }
874 
875     private static void printTypeSetter(Printer out, FieldElement field, boolean empty) {
876         if (!empty) {
<span class="line-modified">877             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { this-&gt;_&quot; + field.name</span>
<span class="line-added">878                     + &quot; = new_value; }&quot;);</span>
879         } else {
<span class="line-modified">880             out.write(&quot;  void set_&quot; + field.name + &quot;(&quot; + field.getParameterType() + &quot; new_value) { }&quot;);</span>
881         }
882     }
883 
884     private static void printVerify(Printer out, List&lt;FieldElement&gt; fields) {
885         out.write(&quot;&quot;);
886         out.write(&quot;#ifdef ASSERT&quot;);
887         out.write(&quot;  void verify() const {&quot;);
888         int index = 0;
889         for (FieldElement f : fields) {
<span class="line-modified">890             out.write(&quot;    assert(verify_field_bit(&quot; + index++</span>
<span class="line-added">891                     + &quot;), \&quot;Attempting to write an uninitialized event field: %s\&quot;, \&quot;_&quot; + f.name + &quot;\&quot;);&quot;);</span>
892         }
893         out.write(&quot;  }&quot;);
894         out.write(&quot;#endif&quot;);
895     }
896 
<span class="line-modified">897     private static void printCommitMethod(Printer out, TypeElement event, boolean empty) {</span>
898         if (event.startTime) {
899             StringJoiner sj = new StringJoiner(&quot;,\n              &quot;);
900             for (FieldElement f : event.fields) {
901                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
902             }
903             out.write(&quot;&quot;);
904             out.write(&quot;  void commit(&quot; + sj.toString() + &quot;) {&quot;);
905             if (!empty) {
<span class="line-modified">906                 out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">907                 for (FieldElement f : event.fields) {</span>
<span class="line-modified">908                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">909                 }</span>
<span class="line-modified">910                 out.write(&quot;      commit();&quot;);</span>
<span class="line-modified">911                 out.write(&quot;    }&quot;);</span>
912             }
913             out.write(&quot;  }&quot;);
914         }
915 
916         // Avoid clash with static commit() method
917         if (event.fields.isEmpty()) {
918             return;
919         }
920 
921         out.write(&quot;&quot;);
922         StringJoiner sj = new StringJoiner(&quot;,\n                     &quot;);
923         if (event.startTime) {
924             sj.add(&quot;const Ticks&amp; startTicks&quot;);
925             sj.add(&quot;const Ticks&amp; endTicks&quot;);
926         }
927         for (FieldElement f : event.fields) {
928             sj.add(f.getParameterType() + &quot; &quot; + f.name);
929         }
930         out.write(&quot;  static void commit(&quot; + sj.toString() + &quot;) {&quot;);
931         if (!empty) {
<span class="line-modified">932             out.write(&quot;    Event&quot; + event.name + &quot; me(UNTIMED);&quot;);</span>
<span class="line-modified">933             out.write(&quot;&quot;);</span>
<span class="line-modified">934             out.write(&quot;    if (me.should_commit()) {&quot;);</span>
<span class="line-modified">935             if (event.startTime) {</span>
<span class="line-modified">936                 out.write(&quot;      me.set_starttime(startTicks);&quot;);</span>
<span class="line-modified">937                 out.write(&quot;      me.set_endtime(endTicks);&quot;);</span>
<span class="line-modified">938             }</span>
<span class="line-modified">939             for (FieldElement f : event.fields) {</span>
<span class="line-modified">940                 out.write(&quot;      me.set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">941             }</span>
<span class="line-modified">942             out.write(&quot;      me.commit();&quot;);</span>
<span class="line-modified">943             out.write(&quot;    }&quot;);</span>
944         }
945         out.write(&quot;  }&quot;);
946     }
947 
<span class="line-modified">948     private static void printConstructor2(Printer out, TypeElement event, boolean empty) {</span>
949         if (!event.startTime) {
950             out.write(&quot;&quot;);
951             out.write(&quot;&quot;);
952         }
953         if (event.startTime) {
954             out.write(&quot;&quot;);
955             out.write(&quot;  Event&quot; + event.name + &quot;(&quot;);
956             StringJoiner sj = new StringJoiner(&quot;,\n    &quot;);
957             for (FieldElement f : event.fields) {
958                 sj.add(f.getParameterType() + &quot; &quot; + f.name);
959             }
960             if (!empty) {
<span class="line-modified">961                 out.write(&quot;    &quot; + sj.toString() + &quot;) : JfrEvent&lt;Event&quot; + event.name + &quot;&gt;(TIMED) {&quot;);</span>
<span class="line-modified">962                 out.write(&quot;    if (should_commit()) {&quot;);</span>
<span class="line-modified">963                 for (FieldElement f : event.fields) {</span>
<span class="line-modified">964                     out.write(&quot;      set_&quot; + f.name + &quot;(&quot; + f.name + &quot;);&quot;);</span>
<span class="line-modified">965                 }</span>
<span class="line-modified">966                 out.write(&quot;    }&quot;);</span>
967             } else {
<span class="line-modified">968                 out.write(&quot;    &quot; + sj.toString() + &quot;) {&quot;);</span>
969             }
970             out.write(&quot;  }&quot;);
971         }
972     }
973 
974     private static void printField(Printer out, FieldElement field) {
975         out.write(&quot;  &quot; + field.getFieldType() + &quot; _&quot; + field.name + &quot;;&quot;);
976     }
977 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../modules/jdk.jfr/Copy.gmk.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../test/BuildMicrobenchmark.gmk.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
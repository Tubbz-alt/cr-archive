<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/sealed/SealedCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * SealedCompilationTests
 28  *
 29  * @test
 30  * @bug 8246353
 31  * @summary Negative compilation tests, and positive compilation (smoke) tests for sealed classes
 32  * @library /lib/combo /tools/lib
 33  * @modules
 34  *     jdk.compiler/com.sun.tools.javac.util
 35  *     jdk.compiler/com.sun.tools.javac.api
 36  *     jdk.compiler/com.sun.tools.javac.main
 37  * @build toolbox.ToolBox toolbox.JavacTask
 38  * @compile --enable-preview -source ${jdk.version} SealedCompilationTests.java
 39  * @run testng/othervm -DuseAP=false --enable-preview SealedCompilationTests
 40  * @run testng/othervm -DuseAP=true --enable-preview SealedCompilationTests
 41  */
 42 
 43 import java.lang.constant.ClassDesc;
 44 
 45 import java.io.File;
 46 
 47 import java.io.IOException;
 48 import java.nio.file.Files;
 49 import java.nio.file.Path;
 50 import java.nio.file.Paths;
 51 
 52 import java.util.ArrayList;
 53 import java.util.List;
 54 import java.util.Set;
 55 import java.util.stream.Collectors;
 56 
 57 import javax.annotation.processing.AbstractProcessor;
 58 import javax.annotation.processing.RoundEnvironment;
 59 import javax.annotation.processing.SupportedAnnotationTypes;
 60 
 61 import javax.lang.model.element.TypeElement;
 62 import javax.lang.model.SourceVersion;
 63 
 64 import com.sun.tools.javac.util.Assert;
 65 
 66 import static org.testng.Assert.assertEquals;
 67 import static org.testng.Assert.assertTrue;
 68 import static org.testng.Assert.fail;
 69 import org.testng.annotations.Test;
 70 import tools.javac.combo.CompilationTestCase;
 71 
 72 import toolbox.ToolBox;
 73 import toolbox.JavacTask;
 74 import toolbox.Task;
 75 import toolbox.Task.OutputKind;
 76 
 77 @Test
 78 public class SealedCompilationTests extends CompilationTestCase {
 79 
 80     ToolBox tb = new ToolBox();
 81 
 82     // When sealed classes become a permanent feature, we don&#39;t need these any more
 83     private static String[] PREVIEW_OPTIONS = {
 84             &quot;--enable-preview&quot;,
 85             &quot;-source&quot;, Integer.toString(Runtime.version().feature())
 86     };
 87 
 88     private static String[] PREVIEW_OPTIONS_WITH_AP = {
 89             &quot;--enable-preview&quot;,
 90             &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
 91             &quot;-processor&quot;, SimplestAP.class.getName()
 92     };
 93 
 94     /* simplest annotation processor just to force a round of annotation processing for all tests
 95      */
 96     @SupportedAnnotationTypes(&quot;*&quot;)
 97     public static class SimplestAP extends AbstractProcessor {
 98         @Override
 99         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
100             return true;
101         }
102 
103         @Override
104         public SourceVersion getSupportedSourceVersion() {
105             return SourceVersion.latest();
106         }
107 
108     }
109 
110     public SealedCompilationTests() {
111         boolean useAP = System.getProperty(&quot;useAP&quot;) == null ? false : System.getProperty(&quot;useAP&quot;).equals(&quot;true&quot;);
112         setDefaultFilename(&quot;SealedTest.java&quot;);
113         setCompileOptions(useAP ? PREVIEW_OPTIONS_WITH_AP : PREVIEW_OPTIONS);
114         System.out.println(useAP ? &quot;running all tests using an annotation processor&quot; : &quot;running all tests without annotation processor&quot;);
115     }
116 
117     private static final String NO_SHELL = &quot;&quot;&quot;
118                  #
119                  &quot;&quot;&quot;;
120     private static final String NEST_SHELL = &quot;&quot;&quot;
121                  class SealedTest {
122                      #
123                  }
124                  &quot;&quot;&quot;;
125     private static final String AUX_SHELL = &quot;&quot;&quot;
126                  class SealedTest {
127                  }
128                  #
129                  &quot;&quot;&quot;;
130     private static final List&lt;String&gt; SHELLS = List.of(NO_SHELL, NEST_SHELL, AUX_SHELL);
131 
132     public void testSimpleExtension() {
133         String CC1 =
134             &quot;&quot;&quot;
135             sealed class Sup # { }
136             # class Sub extends Sup { }
137             &quot;&quot;&quot;;
138 
139         String CC2 =
140                 &quot;&quot;&quot;
141                 sealed class Sup&lt;T&gt; # { }
142                 # class Sub&lt;T&gt; extends Sup&lt;T&gt; { }
143                 &quot;&quot;&quot;;
144         String CC3 =
145                 &quot;&quot;&quot;
146                 sealed class Sup&lt;T&gt; # { }
147                     # class Sub extends Sup&lt;String&gt; { }
148                 &quot;&quot;&quot;;
149         String AC1 =
150             &quot;&quot;&quot;
151             sealed abstract class Sup # { }
152             # class Sub extends Sup { }
153             &quot;&quot;&quot;;
154         String AC2 =
155                 &quot;&quot;&quot;
156                 sealed abstract class Sup&lt;T&gt; # { }
157                     # class Sub&lt;T&gt; extends Sup&lt;T&gt; { }
158                 &quot;&quot;&quot;;
159         String AC3 =
160                 &quot;&quot;&quot;
161                 sealed abstract class Sup&lt;T&gt; # { }
162                     # class Sub extends Sup&lt;String&gt; { }
163                 &quot;&quot;&quot;;
164         String I1 =
165             &quot;&quot;&quot;
166             sealed interface Sup # { }
167             # class Sub implements Sup { }
168             &quot;&quot;&quot;;
169         String I11 =
170                 &quot;&quot;&quot;
171                 sealed interface Sup&lt;T&gt; # { }
172                 # class Sub&lt;T&gt; implements Sup&lt;T&gt; { }
173                 &quot;&quot;&quot;;
174         String I12 =
175                 &quot;&quot;&quot;
176                 sealed interface Sup&lt;T&gt; # { }
177                 # class Sub&lt;T&gt; implements Sup&lt;String&gt; { }
178                 &quot;&quot;&quot;;
179         String I2 =
180             &quot;&quot;&quot;
181             sealed interface Sup # { }
182             # class Sub1 implements Sup { }
183             # class Sub2 implements Sup { }
184             &quot;&quot;&quot;;
185 
186         // Assert that all combinations work:
187         // { class, abs class, interface } x { implicit permits, explicit permits }
188         //                                 x { final, non-sealed subtype }
189         for (String shell : SHELLS)
190             for (String b : List.of(CC1, CC2, CC3, AC1, AC2, AC3, I1, I11, I12))
191                 for (String p : List.of(&quot;&quot;, &quot;permits Sub&quot;))
192                     for (String m : List.of(&quot;final&quot;, &quot;non-sealed&quot;, &quot;non\u002Dsealed&quot;))
193                         assertOK(shell, b, p, m);
194 
195 
196         // Same for type with two subtypes
197         for (String shell : SHELLS)
198             for (String p : List.of(&quot;&quot;, &quot;permits Sub1, Sub2&quot;))
199                 for (String m : List.of(&quot;final&quot;, &quot;non-sealed&quot;, &quot;non\u002Dsealed&quot;))
200                     assertOK(shell, expandMarkers(I2, p, m, m));
201 
202         // Expect failure if there is no explicit final / sealed / non-sealed
203         for (String shell : SHELLS)
204             for (String b : List.of(CC1, CC2, CC3, AC1, AC2, AC3, I1, I11, I12))
205                 for (String p : List.of(&quot;&quot;, &quot;permits Sub&quot;))
206                     for (String m : List.of(&quot;&quot;))
207                         assertFail(&quot;compiler.err.non.sealed.sealed.or.final.expected&quot;, shell, expandMarkers(b, p, m));
208     }
209 
210     public void testSealedAndRecords() {
211         String P =
212             &quot;&quot;&quot;
213             sealed interface Sup # { }
214             record A(int a) implements Sup { }
215             record B(int b) implements Sup { }
216             record C(int c) implements Sup { }
217             &quot;&quot;&quot;;
218 
219         for (String shell : SHELLS)
220             for (String b : List.of(P))
221                 for (String p : List.of(&quot;&quot;, &quot;permits A, B, C&quot;))
222                     assertOK(shell, b, p);
223     }
224 
225     // Test that a type that explicitly permits one type, can&#39;t be extended by another
226     public void testBadExtension() {
227         String CC2 =
228                 &quot;&quot;&quot;
229                 sealed class Sup permits Sub1 { }
230                 final class Sub1 extends Sup { }
231                 final class Sub2 extends Sup { }
232                 &quot;&quot;&quot;;
233         String AC2 =
234                 &quot;&quot;&quot;
235                 sealed abstract class Sup permits Sub1 { }
236                 final class Sub1 extends Sup { }
237                 final class Sub2 extends Sup { }
238                 &quot;&quot;&quot;;
239         String I2c =
240                 &quot;&quot;&quot;
241                 sealed interface Sup permits Sub1 { }
242                 final class Sub1 implements Sup { }
243                 final class Sub2 implements Sup { }
244                 &quot;&quot;&quot;;
245         String I2i =
246                 &quot;&quot;&quot;
247                 sealed interface Sup permits Sub1 { }
248                 non-sealed interface Sub1 extends Sup { }
249                 non-sealed interface Sub2 extends Sup { }
250                 &quot;&quot;&quot;;
251 
252         for (String shell : SHELLS)
253             for (String b : List.of(CC2, AC2, I2c, I2i))
254                 assertFail(&quot;compiler.err.cant.inherit.from.sealed&quot;, shell, b);
255     }
256 
257     public void testRestrictedKeyword() {
258         for (String s : List.of(
259                 &quot;class SealedTest { String sealed; }&quot;,
260                 &quot;class SealedTest { int sealed = 0; int non = 0; int ns = non-sealed; }&quot;,
261                 &quot;class SealedTest { void test(String sealed) { } }&quot;,
262                 &quot;class SealedTest { void sealed(String sealed) { } }&quot;,
263                 &quot;class SealedTest { void test() { String sealed = null; } }&quot;
264         )) {
265             assertOK(s);
266         }
267 
268         for (String s : List.of(
269                 &quot;class sealed {}&quot;,
270                 &quot;enum sealed {}&quot;,
271                 &quot;record sealed() {}&quot;,
272                 &quot;interface sealed {}&quot;,
273                 &quot;@interface sealed {}&quot;
274         )) {
275             assertFail(&quot;compiler.err.restricted.type.not.allowed&quot;, s);
276         }
277 
278         for (String s : List.of(
279                 &quot;class Foo { sealed m() {} }&quot;,
280                 &quot;class Foo { sealed i; }&quot;,
281                 &quot;class Foo { void m(sealed i) {} }&quot;
282                 )) {
283             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, s);
284         }
285 
286         for (String s : List.of(
287                 &quot;class SealedTest { String permits; }&quot;,
288                 &quot;class SealedTest { int permits = 0; }&quot;,
289                 &quot;class SealedTest { void test(String permits) { } }&quot;,
290                 &quot;class SealedTest { void permits(String permits) { } }&quot;,
291                 &quot;class SealedTest { void test() { String permits = null; } }&quot;
292         )) {
293             assertOK(s);
294         }
295 
296         for (String s : List.of(
297                 &quot;class permits {}&quot;,
298                 &quot;enum permits {}&quot;,
299                 &quot;record permits() {}&quot;,
300                 &quot;interface permits {}&quot;,
301                 &quot;@interface permits {}&quot;
302         )) {
303             assertFail(&quot;compiler.err.restricted.type.not.allowed&quot;, s);
304         }
305 
306         for (String s : List.of(
307                 &quot;class Foo { permits m() {} }&quot;,
308                 &quot;class Foo { permits i; }&quot;,
309                 &quot;class Foo { void m(permits i) {} }&quot;
310         )) {
311             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, s);
312         }
313 
314         String[] testOptions = {/* no options */};
315         String[] previousCompOptions = getCompileOptions();
316         setCompileOptions(testOptions);
317         // now testing with preview disabled
318         for (String s : List.of(
319                 &quot;sealed class S {}&quot;,
320                 &quot;class Outer { sealed class S {} }&quot;,
321                 &quot;class Outer { void m() { sealed class S {} } }&quot;,
322                 &quot;non-sealed class S {}&quot;,
323                 &quot;class Outer { non-sealed class S {} }&quot;,
324                 &quot;class Outer { void m() { non-sealed class S {} } }&quot;
325         )) {
326             assertFail(&quot;compiler.err.preview.feature.disabled.plural&quot;, s);
327         }
328         setCompileOptions(previousCompOptions);
329     }
330 
331     public void testRejectPermitsInNonSealedClass() {
332         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
333                 &quot;class SealedTest {\n&quot; +
334                 &quot;    class NotSealed permits Sub {}\n&quot; +
335                 &quot;    class Sub extends NotSealed {}\n&quot; +
336                 &quot;}&quot;);
337         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
338                 &quot;class SealedTest {\n&quot; +
339                 &quot;    interface NotSealed permits Sub {}\n&quot; +
340                 &quot;    class Sub implements NotSealed {}\n&quot; +
341                 &quot;}&quot;);
342     }
343 
344     public void testTypeInPermitsIsSameClassOrSuper() {
345         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
346                 &quot;&quot;&quot;
347                 sealed class Sealed permits Sealed {}
348                 &quot;&quot;&quot;
349                 );
350         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
351                 &quot;&quot;&quot;
352                 interface I {}
353                 sealed class Sealed implements I permits I {}
354                 &quot;&quot;&quot;
355                 );
356         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
357                 &quot;&quot;&quot;
358                 interface I {}
359                 interface I2 extends I {}
360                 sealed class Sealed implements I2 permits I {}
361                 &quot;&quot;&quot;
362                 );
363     }
364 
365     /* It is a compile-time error if a class declaration has more than one of the class modifiers
366      * sealed, non-sealed and final
367      */
368     public void testBadModifiers() {
369         assertFail(&quot;compiler.err.non.sealed.with.no.sealed.supertype&quot;,
370                 &quot;class SealedTest { non-sealed class NoSealedSuper {} }&quot;);
371         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;,
372                    &quot;class SealedTest { sealed public void m() {} }&quot;);
373         for (String s : List.of(
374                 &quot;class SealedTest { sealed non-sealed class Super {} }&quot;,
375                 &quot;class SealedTest { final non-sealed class Super {} }&quot;,
376                 &quot;class SealedTest { final sealed class Super {} }&quot;,
377                 &quot;class SealedTest { final sealed non-sealed class Super {} }&quot;,
378                 &quot;class SealedTest {\n&quot; +
379                 &quot;    sealed class Super {}\n&quot; +
380                 &quot;    sealed non-sealed class Sub extends Super {}\n&quot; +
381                 &quot;}&quot;))
382             assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, s);
383     }
384 
385     public void testAnonymous_FunctionalExpr_and_Sealed() {
386         for (String s : List.of(
387                 &quot;&quot;&quot;
388                 sealed interface I extends Runnable {
389                     public static I i = () -&gt; {};
390                 }
391 
392                 final class Sub implements I {}
393                 &quot;&quot;&quot;,
394                 &quot;&quot;&quot;
395                 sealed interface I extends Runnable {}
396 
397                 final class Sub implements I {
398                     I a = Sub::action;
399                     static void action() {}
400                 }
401                 &quot;&quot;&quot;
402                 ))
403             assertFail(&quot;compiler.err.prob.found.req&quot;, s);
404 
405         for (String s : List.of(
406                 &quot;&quot;&quot;
407                 @FunctionalInterface
408                 sealed interface Action {
409                     void doAction();
410                 }
411 
412                 final class C implements Action {
413                     public void doAction() {}
414                 }
415                 &quot;&quot;&quot;
416                 ))
417             assertFail(&quot;compiler.err.bad.functional.intf.anno.1&quot;, s);
418 
419         for (String s : List.of(
420                 &quot;&quot;&quot;
421                 sealed interface I extends Runnable {
422                     public static I i = new I() { public void run() { } };
423                 }
424                 final class C implements I {
425                     @Override public void run() {}
426                 }
427                 &quot;&quot;&quot;
428                 ))
429             assertFail(&quot;compiler.err.local.classes.cant.extend.sealed&quot;, s);
430 
431         for (String s : List.of(
432                 &quot;&quot;&quot;
433                 sealed interface I extends Runnable {
434                     public static void foo() { new I() { public void run() { } }; }
435                 }
436                 final class C implements I {
437                     @Override public void run() {}
438                 }
439                 &quot;&quot;&quot;
440                 ))
441         assertFail(&quot;compiler.err.local.classes.cant.extend.sealed&quot;, s);
442     }
443 
444     public void testNoLocalSealedClasses() {
445         for (String s : List.of(
446                 &quot;&quot;&quot;
447                 sealed class C {
448                     void m() {
449                         sealed class D { }
450                     }
451                 }
452                 &quot;&quot;&quot;,
453                 &quot;&quot;&quot;
454                 sealed class C {
455                     void m() {
456                         non-sealed class D { }
457                     }
458                 }
459                 &quot;&quot;&quot;))
460             assertFail(&quot;compiler.err.sealed.or.non.sealed.local.classes.not.allowed&quot;, s);
461     }
462 
463     public void testLocalCantExtendSealed() {
464         for (String s : List.of(
465                 &quot;&quot;&quot;
466                 sealed class C {
467                     void m() {
468                         final class D extends C { }
469                     }
470                 }
471                 &quot;&quot;&quot;))
472             assertFail(&quot;compiler.err.local.classes.cant.extend.sealed&quot;, s);
473     }
474 
475     public void testSealedInterfaceAndAbstracClasses() {
476         for (String s : List.of(
477                 &quot;&quot;&quot;
478                 sealed interface I {}
479                 &quot;&quot;&quot;,
480                 &quot;&quot;&quot;
481                 sealed abstract class AC {}
482                 &quot;&quot;&quot;,
483                 &quot;&quot;&quot;
484                 sealed class C {}
485                 &quot;&quot;&quot;))
486             assertFail(&quot;compiler.err.sealed.class.must.have.subclasses&quot;, s);
487 
488         for (String s : List.of(
489                 &quot;&quot;&quot;
490                 sealed interface I {}
491 
492                 non-sealed interface I2 extends I {}
493                 &quot;&quot;&quot;,
494                 &quot;&quot;&quot;
495                 sealed interface I {}
496 
497                 sealed interface I2 extends I {}
498 
499                 non-sealed interface I3 extends I2 {}
500                 &quot;&quot;&quot;,
501                 &quot;&quot;&quot;
502                 sealed interface I permits I2 {}
503 
504                 non-sealed interface I2 extends I {}
505                 &quot;&quot;&quot;,
506                 &quot;&quot;&quot;
507                 sealed interface I permits I2 {}
508 
509                 sealed interface I2 extends I permits I3 {}
510 
511                 non-sealed interface I3 extends I2 {}
512                 &quot;&quot;&quot;
513                 ))
514             assertOK(s);
515     }
516 
517     public void testEnumsCantBeSealedOrNonSealed() {
518         for (String s : List.of(
519                 &quot;&quot;&quot;
520                 sealed interface I {}
521 
522                 sealed enum E implements I {E1}
523                 &quot;&quot;&quot;,
524                 &quot;&quot;&quot;
525                 sealed interface I {}
526 
527                 non-sealed enum E implements I {E1}
528                 &quot;&quot;&quot;))
529             assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, s);
530     }
531 
532     public void testEnumsCanImplementSealedInterfaces() {
533         for (String s : List.of(
534                 &quot;&quot;&quot;
535                 sealed interface I {}
536 
537                 enum E implements I {E1}
538                 &quot;&quot;&quot;))
539             assertOK(s);
540     }
541 
542     public void testClassesCanExtendNonSealed() {
543         for (String s : List.of(
544                 &quot;&quot;&quot;
545                 sealed class C {}
546 
547                 non-sealed class Sub extends C {}
548 
549                 class Sub2 extends Sub {}
550                 &quot;&quot;&quot;)) {
551             assertOK(s);
552         }
553     }
554 
555     public void testEmptyPermits() {
556         for (String s : List.of(
557             &quot;&quot;&quot;
558             sealed class C permits {}
559             non-sealed class Sub extends C {}
560             &quot;&quot;&quot;)) {
561             assertFail(&quot;compiler.err.expected&quot;, s);
562         }
563     }
564 
565     public void testTypeVarInPermits() {
566         for (String s : List.of(
567             &quot;&quot;&quot;
568             class Outer&lt;T&gt; {
569                 sealed class C permits T  {}
570             }
571             &quot;&quot;&quot;)) {
572             assertFail(&quot;compiler.err.invalid.permits.clause&quot;, s);
573         }
574     }
575 
576     public void testRepeatedTypeInPermits() {
577         for (String s : List.of(
578             &quot;&quot;&quot;
579             sealed class C permits Sub, Sub {}
580 
581             final class Sub extends C {}
582             &quot;&quot;&quot;)) {
583             assertFail(&quot;compiler.err.invalid.permits.clause&quot;, s);
584         }
585     }
586 
587     public void testSubtypeDoesntExtendSealed() {
588         for (String s : List.of(
589             &quot;&quot;&quot;
590             sealed class C permits Sub {}
591 
592             final class Sub {}
593             &quot;&quot;&quot;,
594             &quot;&quot;&quot;
595             sealed interface I permits Sub {}
596 
597             final class Sub {}
598             &quot;&quot;&quot;,
599             &quot;&quot;&quot;
600             sealed class C permits Sub1, Sub2 {}
601 
602             sealed class Sub1 extends C permits Sub2 {}
603 
604             final class Sub2 extends Sub1 {}
605             &quot;&quot;&quot;
606             )) {
607             assertFail(&quot;compiler.err.invalid.permits.clause&quot;, s);
608         }
609     }
610 
611     public void testAPIForPrimitiveAndArrayClasses() {
612         for (Class&lt;?&gt; c : new Class[]{byte.class, byte[].class, short.class, short[].class, int.class, int[].class, long.class, long[].class,
613             float.class, float[].class, double.class, double[].class, char.class, char[].class, boolean.class, boolean[].class, void.class,
614             String[].class}) {
615             Assert.check(!c.isSealed());
616             Assert.check(c.permittedSubclasses().length == 0);
617         }
618     }
619 
620     public void testPrinting() throws Exception {
621         Path base = Paths.get(&quot;testPrinting&quot;);
622         Path src = base.resolve(&quot;src&quot;);
623         Path test = src.resolve(&quot;Test&quot;);
624 
625         tb.writeJavaFiles(test,
626             &quot;&quot;&quot;
627             sealed class SealedClassNoPermits {}
628 
629             final class FinalSubClass extends SealedClassNoPermits {}
630 
631             non-sealed class NonSealedSubClass extends SealedClassNoPermits {}
632 
633             sealed interface SealedInterfaceNoPermits {}
634 
635             non-sealed interface NonSealedInterface extends SealedInterfaceNoPermits {}
636 
637             final class FinalSubClass2 implements SealedInterfaceNoPermits {}
638 
639 
640             sealed class SealedClassWithPermits permits SealedClassWithPermits, NonSealedSubClass2 {}
641 
642             final class FinalSubClass3 extends SealedClassWithPermits {}
643 
644             non-sealed class NonSealedSubClass2 extends SealedClassWithPermits {}
645 
646             sealed interface SealedInterfaceWithPermits permits NonSealedInterface2, FinalSubClass4 {}
647 
648             non-sealed interface NonSealedInterface2 extends SealedInterfaceWithPermits {}
649 
650             final class FinalSubClass4 implements SealedInterfaceWithPermits {}
651 
652 
653             enum SealedEnum {
654                 E {}
655             }
656 
657             enum Enum {
658                 E
659             }
660             &quot;&quot;&quot;
661         );
662 
663         Path out = base.resolve(&quot;out&quot;);
664 
665         Files.createDirectories(out);
666 
667         List&lt;String&gt; output = new JavacTask(tb)
668             .outdir(out)
669             .options(&quot;--enable-preview&quot;, &quot;-source&quot;, Integer.toString(Runtime.version().feature()), &quot;-Xprint&quot;)
670             .files(findJavaFiles(test))
671             .run()
672             .writeAll()
673             .getOutputLines(OutputKind.STDOUT);
674 
675         List&lt;String&gt; expected = List.of(
676             &quot;sealed class SealedClassNoPermits permits FinalSubClass, NonSealedSubClass {&quot;,
677             &quot;  SealedClassNoPermits();&quot;,
678             &quot;}&quot;,
679             &quot;final class FinalSubClass extends SealedClassNoPermits {&quot;,
680             &quot;  FinalSubClass();&quot;,
681             &quot;}&quot;,
682             &quot;non-sealed class NonSealedSubClass extends SealedClassNoPermits {&quot;,
683             &quot;  NonSealedSubClass();&quot;,
684             &quot;}&quot;,
685             &quot;sealed interface SealedInterfaceNoPermits permits NonSealedInterface, FinalSubClass2 {&quot;,
686             &quot;}&quot;,
687             &quot;non-sealed interface NonSealedInterface extends SealedInterfaceNoPermits {&quot;,
688             &quot;}&quot;,
689             &quot;final class FinalSubClass2 implements SealedInterfaceNoPermits {&quot;,
690             &quot;  FinalSubClass2();&quot;,
691             &quot;}&quot;,
692             &quot;sealed class SealedClassWithPermits permits SealedClassWithPermits, NonSealedSubClass2 {&quot;,
693             &quot;  SealedClassWithPermits();&quot;,
694             &quot;}&quot;,
695             &quot;final class FinalSubClass3 extends SealedClassWithPermits {&quot;,
696             &quot;  FinalSubClass3();&quot;,
697             &quot;}&quot;,
698             &quot;non-sealed class NonSealedSubClass2 extends SealedClassWithPermits {&quot;,
699             &quot;  NonSealedSubClass2();&quot;,
700             &quot;}&quot;,
701             &quot;sealed interface SealedInterfaceWithPermits permits NonSealedInterface2, FinalSubClass4 {&quot;,
702             &quot;}&quot;,
703             &quot;non-sealed interface NonSealedInterface2 extends SealedInterfaceWithPermits {&quot;,
704             &quot;}&quot;,
705             &quot;final class FinalSubClass4 implements SealedInterfaceWithPermits {&quot;,
706             &quot;  FinalSubClass4();&quot;,
707             &quot;}&quot;,
708             &quot;enum SealedEnum {&quot;,
709             &quot;  E;&quot;,
710             &quot;  public static SealedEnum[] values();&quot;,
711             &quot;  public static SealedEnum valueOf(java.lang.String name);&quot;,
712             &quot;  private SealedEnum();&quot;,
713             &quot;}&quot;,
714             &quot;enum Enum {&quot;,
715             &quot;  E;&quot;,
716             &quot;  public static Enum[] values();&quot;,
717             &quot;  public static Enum valueOf(java.lang.String name);&quot;,
718             &quot;  private Enum();&quot;,
719             &quot;}&quot;
720         );
721         // remove empty strings
722         String newLine = System.getProperty(&quot;line.separator&quot;);
723         output = output.stream().filter(s -&gt; !s.isEmpty()).map(s -&gt; s.replaceAll(newLine, &quot;\n&quot;).replaceAll(&quot;\n&quot;, &quot;&quot;)).collect(Collectors.toList());
724         if (!output.containsAll(expected)) {
725             for (int i = 0; i &lt; output.size(); i++) {
726                 if (!output.get(i).equals(expected.get(i))) {
727                     System.out.println(&quot;failing at index &quot; + i);
728                     System.out.println(&quot;expected:&quot; + expected.get(i));
729                     System.out.println(&quot;found:&quot; + output.get(i));
730                 }
731             }
732             throw new AssertionError(&quot;Expected output not found. Expected: &quot; + expected);
733         }
734     }
735 
736     public void testNonSealedErroneousSuper() {
737         assertFail(&quot;compiler.err.cant.resolve&quot;,
738                    d -&gt; {
739                        if (diags.keys().size() != 1) {
740                            fail(&quot;Unexpected errors: &quot; + diags.toString());
741                        }
742                    },
743                    &quot;&quot;&quot;
744                    non-sealed class C extends Undefined {}
745                    &quot;&quot;&quot;);
746     }
747 
748     public void testIllFormedNonSealed() {
749         for (String s : List.of(
750             &quot;&quot;&quot;
751             sealed class C permits Sub {}
752             non -sealed class Sub extends C {}
753             &quot;&quot;&quot;,
754             &quot;&quot;&quot;
755             sealed class C permits Sub {}
756             non sealed class Sub extends C {}
757             &quot;&quot;&quot;,
758             &quot;&quot;&quot;
759             sealed class C permits Sub {}
760             non - sealed class Sub extends C {}
761             &quot;&quot;&quot;,
762             &quot;&quot;&quot;
763             sealed class C permits Sub {}
764             non/**/sealed class Sub extends C {}
765             &quot;&quot;&quot;
766             )) {
767             assertFail(&quot;compiler.err.expected4&quot;, s);
768         }
769     }
770 
771     public void testParameterizedPermitted() {
772         for (String s : List.of(
773             &quot;&quot;&quot;
774             sealed class C&lt;T&gt; permits Sub&lt;T&gt; {}
775             final class Sub&lt;T&gt; extends C&lt;T&gt; {}
776             &quot;&quot;&quot;,
777             &quot;&quot;&quot;
778             sealed class C permits Sub&lt;String&gt; {}
779             final class Sub&lt;T&gt; extends C {}
780             &quot;&quot;&quot;
781             )) {
782             assertFail(&quot;compiler.err.expected&quot;, s);
783         }
784     }
785 
786     private Path[] findJavaFiles(Path... paths) throws IOException {
787         return tb.findJavaFiles(paths);
788     }
789 
790     public void testSealedNonSealedWithOtherModifiers() {
791         String template1 =
792             &quot;&quot;&quot;
793             @interface A {}
794 
795             class Outer {
796                 sealed class Sup { }
797                 # # class Sub extends Sup {}
798                 final class Sub2 extends Sub {}
799             }
800             &quot;&quot;&quot;;
801 
802         String template2 =
803             &quot;&quot;&quot;
804             @interface A {}
805 
806             class Outer {
807                 sealed interface Sup { }
808                 # # interface Sub extends Sup {}
809                 final class Sub2 implements Sub {}
810             }
811             &quot;&quot;&quot;;
812 
813         List&lt;String&gt; templateList = List.of(template1, template2);
814         List&lt;String&gt; otherModifiers = List.of(
815                 &quot;@A&quot;, &quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, &quot;abstract&quot;, &quot;static&quot;, &quot;strictfp&quot;, &quot;final&quot;, &quot;sealed&quot;, &quot;non-sealed&quot;
816         );
817 
818         for (String template : templateList) {
819             for (String sealed_non_sealed : List.of(&quot;sealed&quot;, &quot;non-sealed&quot;)) {
820                 for (String modifier : otherModifiers) {
821                     if (sealed_non_sealed.equals(modifier)) {
822                         assertFail(&quot;compiler.err.repeated.modifier&quot;, template, sealed_non_sealed, modifier);
823                     } else if (modifier.equals(&quot;final&quot;) || modifier.equals(&quot;sealed&quot;) || modifier.equals(&quot;non-sealed&quot;)) {
824                         assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, template, sealed_non_sealed, modifier);
825                     } else {
826                         assertOK(template, sealed_non_sealed, modifier);
827                     }
828                 }
829             }
830         }
831     }
832 
833     public void testSubClassBeforeSealedClassInSameCU() {
834         for (String s : List.of(
835             &quot;&quot;&quot;
836             final class Sub extends Sealed {}
837 
838             sealed class Sealed {}
839             &quot;&quot;&quot;,
840             &quot;&quot;&quot;
841             final class Sub extends Sealed {}
842 
843             sealed class Sealed permits Sub {}
844             &quot;&quot;&quot;,
845             &quot;&quot;&quot;
846             final class Sub extends Outer.Super {}
847 
848             class Outer {
849                 sealed static class Super {}
850             }
851             &quot;&quot;&quot;,
852             &quot;&quot;&quot;
853             final class Sub extends Outer.Super {}
854 
855             class Outer {
856                 sealed static class Super permits Sub {}
857             }
858             &quot;&quot;&quot;,
859             &quot;&quot;&quot;
860             class Outer {
861                 final class Sub extends Super {}
862             }
863 
864             sealed class Super {}
865             &quot;&quot;&quot;,
866             &quot;&quot;&quot;
867             class Outer {
868                 final class Sub extends Super {}
869             }
870 
871             sealed class Super permits Outer.Sub{}
872             &quot;&quot;&quot;,
873             &quot;&quot;&quot;
874             class Outer1 {
875                 final class Sub extends Outer2.Super {}
876             }
877 
878             class Outer2 {
879                 sealed static class Super {}
880             }
881             &quot;&quot;&quot;,
882             &quot;&quot;&quot;
883             class Outer1 {
884                 final class Sub extends Outer2.Super {}
885             }
886 
887             class Outer2 {
888                 sealed static class Super permits Outer1.Sub {}
889             }
890             &quot;&quot;&quot;,
891             &quot;&quot;&quot;
892             class Outer {
893                 final class Sub extends Outer.Inner.Super {}
894                 static class Inner {
895                     sealed static class Super {}
896                 }
897             }
898             &quot;&quot;&quot;,
899             &quot;&quot;&quot;
900             class Outer {
901                 final class Sub extends Outer.Inner.Super {}
902                 static class Inner {
903                     sealed static class Super permits Outer.Sub {}
904                 }
905             }
906             &quot;&quot;&quot;
907         )) {
908             assertOK(s);
909         }
910     }
911 }
    </pre>
  </body>
</html>
diff a/test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java b/test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java
--- a/test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java
+++ b/test/langtools/jdk/javadoc/lib/javadoc/tester/JavadocTester.java
@@ -60,11 +60,11 @@
  * Test framework for running javadoc and performing tests on the resulting output.
  *
  * <p>
  * Tests are typically written as subtypes of JavadocTester, with a main
  * method that creates an instance of the test class and calls the runTests()
- * method. The runTests() methods calls all the test methods declared in the class,
+ * method. The runTests() method calls all the test methods declared in the class,
  * and then calls a method to print a summary, and throw an exception if
  * any of the test methods reported a failure.
  *
  * <p>
  * Test methods are identified with a @Test annotation. They have no parameters.
@@ -109,25 +109,26 @@
  * </code></pre>
  *
  * <p>
  * If javadoc is run more than once in a test method, you can compare the
  * results that are generated with the diff method. Since files written by
- * javadoc typically contain a timestamp, you may want to use the -notimestamp
+ * javadoc typically contain a timestamp, you may want to use the {@code -notimestamp}
  * option if you are going to compare the results from two runs of javadoc.
  *
  * <p>
  * If you have many calls of checkOutput that are very similar, you can write
  * your own check... method to reduce the amount of duplication. For example,
  * if you want to check that many files contain the same string, you could
  * write a method that takes a varargs list of files and calls checkOutput
  * on each file in turn with the string to be checked.
  *
  * <p>
- * You can also write you own custom check methods, which can use
- * readFile to get the contents of a file generated by javadoc,
- * and then use pass(...) or fail(...) to report whether the check
- * succeeded or not.
+ * You can also write your own custom check methods. After any setup or
+ * argument checking, the method should call {@code checking(...)},
+ * and then eventually call either {@code passed(...)} or {@code failed(...)}
+ * to report whether the check succeeded or not.
+ * Use {@code readFile} to get the contents of a file generated by javadoc.
  *
  * <p>
  * You can have many separate test methods, each identified with a @Test
  * annotation. However, you should <b>not</b> assume they will be called
  * in the order declared in your source file.  If the order of a series
@@ -571,11 +572,12 @@
     /**
      * Shows the heading structure for each of the specified files.
      * The structure is is printed in plain text to the main output stream.
      * No errors are reported (unless there is a problem reading a file)
      * but missing headings are noted within the output.
-     * @params the files
+     *
+     * @param paths the files
      */
     public void showHeadings(String... paths) {
         ShowHeadings s = new ShowHeadings(out, this::readFile);
         for (String p : paths) {
             try {
@@ -811,30 +813,68 @@
         } catch (IOException e) {
             throw new Error("Error reading file: " + fileName + ": " + e);
         }
     }
 
+    /**
+     * Starts a check.
+     *
+     * <p>This method should be called before subsequently calling {@code pass(...)}
+     * or {@code fail(...)}.
+     *
+     * @param message a short description of the check
+     */
     protected void checking(String message) {
         numTestsRun++;
         javadocTestNum++;
         print("Starting subtest " + javadocRunNum + "." + javadocTestNum, message);
     }
 
+    /**
+     * Concludes a check for a file, reporting that the check succeeded.
+     *
+     * <p>This method should be called after previously calling {@code checking(...)}.
+     *
+     * @param file the file that was the focus of the check
+     * @param message a short description of the outcome
+     */
     protected void passed(File file, String message) {
         passed(file + ": " + message);
     }
 
+    /**
+     * Concludes a check, reporting that the check succeeded.
+     *
+     * <p>This method should be called after previously calling {@code checking(...)}.
+     *
+     * @param message a short description of the outcome
+     */
     protected void passed(String message) {
         numTestsPassed++;
         print("Passed", message);
         out.println();
     }
 
+    /**
+     * Concludes a check for a file, reporting that the check failed.
+     *
+     * <p>This method should be called after previously calling {@code checking(...)}.
+     *
+     * @param file the file that was the focus of the check
+     * @param message a short description of the outcome
+     */
     protected void failed(File file, String message) {
         failed(file + ": " + message);
     }
 
+    /**
+     * Concludes a check for a file, reporting that the check failed.
+     *
+     * <p>This method should be called after previously calling {@code checking(...)}.
+     *
+     * @param message a short description of the outcome
+     */
     protected void failed(String message) {
         print("FAILED", message);
         StackWalker.getInstance().walk(s -> {
             s.dropWhile(f -> f.getMethodName().equals("failed"))
                     .takeWhile(f -> !f.getMethodName().equals("runTests"))
@@ -899,12 +939,10 @@
      * Compares the two given files.
      *
      * @param baseDir1 the directory in which to locate the first file
      * @param baseDir2 the directory in which to locate the second file
      * @param file the file to compare in the two base directories
-     * an error if the files do not match.
-     * @return true if the files are the same and false otherwise.
      */
     private void diff(File baseDir1, File baseDir2, String file) {
         String file1Contents = readFile(baseDir1, file);
         String file2Contents = readFile(baseDir2, file);
         checking("diff " + new File(baseDir1, file) + ", " + new File(baseDir2, file));

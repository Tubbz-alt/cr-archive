<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jpackage/junit/jdk/incubator/jpackage/internal/OverridableResourceTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jpackage.internal;
 26 
 27 import java.io.IOException;
 28 import java.io.InputStream;
 29 import java.nio.charset.StandardCharsets;
 30 import java.nio.file.Files;
 31 import java.nio.file.Path;
 32 import java.util.HashMap;
 33 import java.util.Iterator;
 34 import java.util.List;
 35 import java.util.Map;
 36 import jdk.incubator.jpackage.internal.resources.ResourceLocator;
 37 import static org.hamcrest.CoreMatchers.is;
 38 import static org.hamcrest.CoreMatchers.not;
 39 import static org.junit.Assert.assertArrayEquals;
 40 import static org.junit.Assert.assertEquals;
 41 import static org.junit.Assert.assertFalse;
 42 import static org.junit.Assert.assertTrue;
 43 import static org.junit.Assert.assertThat;
 44 import org.junit.Rule;
 45 import org.junit.Test;
 46 import org.junit.rules.TemporaryFolder;
 47 
 48 public class OverridableResourceTest {
 49 
 50     @Rule
 51     public final TemporaryFolder tempFolder = new TemporaryFolder();
 52 
 53     @Test
 54     public void testDefault() throws IOException {
 55         byte[] actualBytes = saveToFile(new OverridableResource(DEFAULT_NAME));
 56 
 57         try (InputStream is = ResourceLocator.class.getResourceAsStream(
 58                 DEFAULT_NAME)) {
 59             assertArrayEquals(is.readAllBytes(), actualBytes);
 60         }
 61     }
 62 
 63     @Test
 64     public void testDefaultWithSubstitution() throws IOException {
 65         OverridableResource resource = new OverridableResource(DEFAULT_NAME);
 66 
 67         List&lt;String&gt; linesBeforeSubstitution = convertToStringList(saveToFile(
 68                 resource));
 69 
 70         if (SUBSTITUTION_DATA.size() != 1) {
 71             // Test setup issue
 72             throw new IllegalArgumentException(
 73                     &quot;Substitution map should contain only a single entry&quot;);
 74         }
 75 
 76         resource.setSubstitutionData(SUBSTITUTION_DATA);
 77         List&lt;String&gt; linesAfterSubstitution = convertToStringList(saveToFile(
 78                 resource));
 79 
 80         assertEquals(linesBeforeSubstitution.size(), linesAfterSubstitution.size());
 81 
 82         Iterator&lt;String&gt; beforeIt = linesBeforeSubstitution.iterator();
 83         Iterator&lt;String&gt; afterIt = linesAfterSubstitution.iterator();
 84 
 85         var substitutionEntry = SUBSTITUTION_DATA.entrySet().iterator().next();
 86 
 87         boolean linesMismatch = false;
 88         while (beforeIt.hasNext()) {
 89             String beforeStr = beforeIt.next();
 90             String afterStr = afterIt.next();
 91 
 92             if (beforeStr.equals(afterStr)) {
 93                 assertFalse(beforeStr.contains(substitutionEntry.getKey()));
 94             } else {
 95                 linesMismatch = true;
 96                 assertTrue(beforeStr.contains(substitutionEntry.getKey()));
 97                 assertTrue(afterStr.contains(substitutionEntry.getValue()));
 98                 assertFalse(afterStr.contains(substitutionEntry.getKey()));
 99             }
100         }
101 
102         assertTrue(linesMismatch);
103     }
104 
105     @Test
106     public void testCustom() throws IOException {
107         testCustom(DEFAULT_NAME);
108     }
109 
110     @Test
111     public void testCustomNoDefault() throws IOException {
112         testCustom(null);
113     }
114 
115     private void testCustom(String defaultName) throws IOException {
116         List&lt;String&gt; expectedResourceData = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
117 
118         Path customFile = createCustomFile(&quot;foo&quot;, expectedResourceData);
119 
120         List&lt;String&gt; actualResourceData = convertToStringList(saveToFile(
121                 new OverridableResource(defaultName)
122                         .setPublicName(customFile.getFileName())
123                         .setResourceDir(customFile.getParent())));
124 
125         assertArrayEquals(expectedResourceData.toArray(String[]::new),
126                 actualResourceData.toArray(String[]::new));
127     }
128 
129     @Test
130     public void testCustomtWithSubstitution() throws IOException {
131         testCustomtWithSubstitution(DEFAULT_NAME);
132     }
133 
134     @Test
135     public void testCustomtWithSubstitutionNoDefault() throws IOException {
136         testCustomtWithSubstitution(null);
137     }
138 
139     private void testCustomtWithSubstitution(String defaultName) throws IOException {
140         final List&lt;String&gt; resourceData = List.of(&quot;A&quot;, &quot;[BB]&quot;, &quot;C&quot;, &quot;Foo&quot;,
141                 &quot;GoodbyeHello&quot;);
142         final Path customFile = createCustomFile(&quot;foo&quot;, resourceData);
143 
144         final Map&lt;String, String&gt; substitutionData = new HashMap(Map.of(&quot;B&quot;,
145                 &quot;Bar&quot;, &quot;Foo&quot;, &quot;B&quot;));
146         substitutionData.put(&quot;Hello&quot;, null);
147 
148         final List&lt;String&gt; expectedResourceData = List.of(&quot;A&quot;, &quot;[BarBar]&quot;, &quot;C&quot;,
149                 &quot;B&quot;, &quot;Goodbye&quot;);
150 
151         final List&lt;String&gt; actualResourceData = convertToStringList(saveToFile(
152                 new OverridableResource(defaultName)
153                         .setPublicName(customFile.getFileName())
154                         .setSubstitutionData(substitutionData)
155                         .setResourceDir(customFile.getParent())));
156         assertArrayEquals(expectedResourceData.toArray(String[]::new),
157                 actualResourceData.toArray(String[]::new));
158 
159         // Don&#39;t call setPublicName()
160         final Path dstFile = tempFolder.newFolder().toPath().resolve(customFile.getFileName());
161         new OverridableResource(defaultName)
162                 .setSubstitutionData(substitutionData)
163                 .setResourceDir(customFile.getParent())
164                 .saveToFile(dstFile);
165         assertArrayEquals(expectedResourceData.toArray(String[]::new),
166                 convertToStringList(Files.readAllBytes(dstFile)).toArray(
167                         String[]::new));
168 
169         // Verify setSubstitutionData() stores a copy of passed in data
170         Map&lt;String, String&gt; substitutionData2 = new HashMap(substitutionData);
171         var resource = new OverridableResource(defaultName)
172                 .setResourceDir(customFile.getParent());
173 
174         resource.setSubstitutionData(substitutionData2);
175         substitutionData2.clear();
176         Files.delete(dstFile);
177         resource.saveToFile(dstFile);
178         assertArrayEquals(expectedResourceData.toArray(String[]::new),
179                 convertToStringList(Files.readAllBytes(dstFile)).toArray(
180                         String[]::new));
181     }
182 
183     @Test
184     public void testNoDefault() throws IOException {
185         Path dstFolder = tempFolder.newFolder().toPath();
186         Path dstFile = dstFolder.resolve(Path.of(&quot;foo&quot;, &quot;bar&quot;));
187 
188         new OverridableResource(null).saveToFile(dstFile);
189 
190         assertFalse(dstFile.toFile().exists());
191     }
192 
193     private final static String DEFAULT_NAME;
194     private final static Map&lt;String, String&gt; SUBSTITUTION_DATA;
195     static {
196         if (Platform.isWindows()) {
197             DEFAULT_NAME = &quot;WinLauncher.template&quot;;
198             SUBSTITUTION_DATA = Map.of(&quot;COMPANY_NAME&quot;, &quot;Foo9090345&quot;);
199         } else if (Platform.isLinux()) {
200             DEFAULT_NAME = &quot;template.control&quot;;
201             SUBSTITUTION_DATA = Map.of(&quot;APPLICATION_PACKAGE&quot;, &quot;Package1967&quot;);
202         } else if (Platform.isMac()) {
203             DEFAULT_NAME = &quot;Info-lite.plist.template&quot;;
204             SUBSTITUTION_DATA = Map.of(&quot;DEPLOY_BUNDLE_IDENTIFIER&quot;, &quot;12345&quot;);
205         } else {
206             throw Platform.throwUnknownPlatformError();
207         }
208     }
209 
210     private byte[] saveToFile(OverridableResource resource) throws IOException {
211         Path dstFile = tempFolder.newFile().toPath();
212         resource.saveToFile(dstFile);
213         assertThat(0, is(not(dstFile.toFile().length())));
214 
215         return Files.readAllBytes(dstFile);
216     }
217 
218     private Path createCustomFile(String publicName, List&lt;String&gt; data) throws
219             IOException {
220         Path resourceFolder = tempFolder.newFolder().toPath();
221         Path customFile = resourceFolder.resolve(publicName);
222 
223         Files.write(customFile, data);
224 
225         return customFile;
226     }
227 
228     private static List&lt;String&gt; convertToStringList(byte[] data) {
229         return List.of(new String(data, StandardCharsets.UTF_8).split(&quot;\\R&quot;));
230     }
231 }
    </pre>
  </body>
</html>
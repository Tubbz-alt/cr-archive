<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.incubator.jpackage/linux/classes/jdk/incubator/jpackage/internal/LinuxRpmBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.*;
 29 import java.nio.file.Path;
 30 import java.text.MessageFormat;
 31 import java.util.*;
 32 import java.util.regex.Matcher;
 33 import java.util.regex.Pattern;
 34 import java.util.stream.Collectors;
 35 
 36 import static jdk.incubator.jpackage.internal.StandardBundlerParam.*;
 37 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 38 
 39 /**
 40  * There are two command line options to configure license information for RPM
 41  * packaging: --linux-rpm-license-type and --license-file. Value of
 42  * --linux-rpm-license-type command line option configures &quot;License:&quot; section
 43  * of RPM spec. Value of --license-file command line option specifies a license
 44  * file to be added to the package. License file is a sort of documentation file
 45  * but it will be installed even if user selects an option to install the
 46  * package without documentation. --linux-rpm-license-type is the primary option
 47  * to set license information. --license-file makes little sense in case of RPM
 48  * packaging.
 49  */
 50 public class LinuxRpmBundler extends LinuxPackageBundler {
 51 
 52     // Fedora rules for package naming are used here
 53     // https://fedoraproject.org/wiki/Packaging:NamingGuidelines?rd=Packaging/NamingGuidelines
 54     //
 55     // all Fedora packages must be named using only the following ASCII
 56     // characters. These characters are displayed here:
 57     //
 58     // abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._+
 59     //
 60     private static final Pattern RPM_PACKAGE_NAME_PATTERN =
 61             Pattern.compile(&quot;[a-z\\d\\+\\-\\.\\_]+&quot;, Pattern.CASE_INSENSITIVE);
 62 
 63     public static final BundlerParamInfo&lt;String&gt; PACKAGE_NAME =
 64             new StandardBundlerParam&lt;&gt; (
 65             Arguments.CLIOptions.LINUX_BUNDLE_NAME.getId(),
 66             String.class,
 67             params -&gt; {
 68                 String nm = APP_NAME.fetchFrom(params);
 69                 if (nm == null) return null;
 70 
 71                 // make sure to lower case and spaces become dashes
 72                 nm = nm.toLowerCase().replaceAll(&quot;[ ]&quot;, &quot;-&quot;);
 73 
 74                 return nm;
 75             },
 76             (s, p) -&gt; {
 77                 if (!RPM_PACKAGE_NAME_PATTERN.matcher(s).matches()) {
 78                     String msgKey = &quot;error.invalid-value-for-package-name&quot;;
 79                     throw new IllegalArgumentException(
 80                             new ConfigException(MessageFormat.format(
 81                                     I18N.getString(msgKey), s),
 82                                     I18N.getString(msgKey + &quot;.advice&quot;)));
 83                 }
 84 
 85                 return s;
 86             }
 87         );
 88 
 89     public static final BundlerParamInfo&lt;String&gt; LICENSE_TYPE =
 90         new StandardBundlerParam&lt;&gt;(
 91                 Arguments.CLIOptions.LINUX_RPM_LICENSE_TYPE.getId(),
 92                 String.class,
 93                 params -&gt; I18N.getString(&quot;param.license-type.default&quot;),
 94                 (s, p) -&gt; s
 95         );
 96 
 97     public static final BundlerParamInfo&lt;String&gt; GROUP =
 98             new StandardBundlerParam&lt;&gt;(
 99             Arguments.CLIOptions.LINUX_CATEGORY.getId(),
100             String.class,
101             params -&gt; null,
102             (s, p) -&gt; s);
103 
104     private final static String DEFAULT_SPEC_TEMPLATE = &quot;template.spec&quot;;
105 
106     public final static String TOOL_RPM = &quot;rpm&quot;;
107     public final static String TOOL_RPMBUILD = &quot;rpmbuild&quot;;
108     public final static DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(
109             &quot;4.10&quot;);
110 
111     public LinuxRpmBundler() {
112         super(PACKAGE_NAME);
113     }
114 
115     @Override
116     public void doValidate(Map&lt;String, ? super Object&gt; params)
117             throws ConfigException {
118     }
119 
120     private static ToolValidator createRpmbuildToolValidator() {
121         Pattern pattern = Pattern.compile(&quot; (\\d+\\.\\d+)&quot;);
122         return new ToolValidator(TOOL_RPMBUILD).setMinimalVersion(
123                 TOOL_RPMBUILD_MIN_VERSION).setVersionParser(lines -&gt; {
124                     String versionString = lines.limit(1).collect(
125                             Collectors.toList()).get(0);
126                     Matcher matcher = pattern.matcher(versionString);
127                     if (matcher.find()) {
128                         return matcher.group(1);
129                     }
130                     return null;
131                 });
132     }
133 
134     @Override
135     protected List&lt;ToolValidator&gt; getToolValidators(
136             Map&lt;String, ? super Object&gt; params) {
137         return List.of(createRpmbuildToolValidator());
138     }
139 
140     @Override
141     protected File buildPackageBundle(
142             Map&lt;String, String&gt; replacementData,
143             Map&lt;String, ? super Object&gt; params, File outputParentDir) throws
144             PackagerException, IOException {
145 
146         Path specFile = specFile(params);
147 
148         // prepare spec file
149         createResource(DEFAULT_SPEC_TEMPLATE, params)
150                 .setCategory(I18N.getString(&quot;resource.rpm-spec-file&quot;))
151                 .setSubstitutionData(replacementData)
152                 .saveToFile(specFile);
153 
154         return buildRPM(params, outputParentDir.toPath()).toFile();
155     }
156 
157     @Override
158     protected Map&lt;String, String&gt; createReplacementData(
159             Map&lt;String, ? super Object&gt; params) throws IOException {
160         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
161 
162         final Path prefix = Path.of(LINUX_INSTALL_DIR.fetchFrom(params));
163 
164         Path appDirectory = prefix;
165         if (!isInstallDirInUsrTree(prefix.toString())) {
166             appDirectory = appDirectory.resolve(PACKAGE_NAME.fetchFrom(params));
167         }
168 
169         data.put(&quot;APPLICATION_PREFIX&quot;, prefix.toString());
170         data.put(&quot;APPLICATION_DIRECTORY&quot;, appDirectory.toString());
171         data.put(&quot;APPLICATION_SUMMARY&quot;, APP_NAME.fetchFrom(params));
172         data.put(&quot;APPLICATION_LICENSE_TYPE&quot;, LICENSE_TYPE.fetchFrom(params));
173 
174         String licenseFile = LICENSE_FILE.fetchFrom(params);
175         if (licenseFile != null) {
176             licenseFile = Path.of(licenseFile).toAbsolutePath().normalize().toString();
177         }
178         data.put(&quot;APPLICATION_LICENSE_FILE&quot;, licenseFile);
179         data.put(&quot;APPLICATION_GROUP&quot;, GROUP.fetchFrom(params));
180 
181         return data;
182     }
183 
184     @Override
185     protected void initLibProvidersLookup(
186             Map&lt;String, ? super Object&gt; params,
187             LibProvidersLookup libProvidersLookup) {
188         libProvidersLookup.setPackageLookup(file -&gt; {
189             return Executor.of(TOOL_RPM,
190                 &quot;-q&quot;, &quot;--queryformat&quot;, &quot;%{name}\\n&quot;,
191                 &quot;-q&quot;, &quot;--whatprovides&quot;, file.toString())
192                 .saveOutput(true).executeExpectSuccess().getOutput().stream();
193         });
194     }
195 
196     @Override
197     protected List&lt;ConfigException&gt; verifyOutputBundle(
198             Map&lt;String, ? super Object&gt; params, Path packageBundle) {
199         List&lt;ConfigException&gt; errors = new ArrayList&lt;&gt;();
200 
201         String specFileName = specFile(params).getFileName().toString();
202 
203         try {
204             List&lt;PackageProperty&gt; properties = List.of(
205                     new PackageProperty(&quot;Name&quot;, PACKAGE_NAME.fetchFrom(params),
206                             &quot;APPLICATION_PACKAGE&quot;, specFileName),
207                     new PackageProperty(&quot;Version&quot;, VERSION.fetchFrom(params),
208                             &quot;APPLICATION_VERSION&quot;, specFileName),
209                     new PackageProperty(&quot;Release&quot;, RELEASE.fetchFrom(params),
210                             &quot;APPLICATION_RELEASE&quot;, specFileName),
211                     new PackageProperty(&quot;Arch&quot;, rpmArch(), null, specFileName));
212 
213             List&lt;String&gt; actualValues = Executor.of(TOOL_RPM, &quot;-qp&quot;, &quot;--queryformat&quot;,
214                     properties.stream().map(entry -&gt; String.format(&quot;%%{%s}&quot;,
215                     entry.name)).collect(Collectors.joining(&quot;\\n&quot;)),
216                     packageBundle.toString()).saveOutput(true).executeExpectSuccess().getOutput();
217 
218             Iterator&lt;String&gt; actualValuesIt = actualValues.iterator();
219             properties.forEach(property -&gt; errors.add(property.verifyValue(
220                     actualValuesIt.next())));
221         } catch (IOException ex) {
222             // Ignore error as it is not critical. Just report it.
223             Log.verbose(ex);
224         }
225 
226         return errors;
227     }
228 
229     /**
230      * Various ways to get rpm arch. Needed to address JDK-8233143. rpmbuild is
231      * mandatory for rpm packaging, try it first. rpm is optional and may not be
232      * available, use as the last resort.
233      */
234     private enum RpmArchReader {
235         Rpmbuild(TOOL_RPMBUILD, &quot;--eval=%{_target_cpu}&quot;),
236         Rpm(TOOL_RPM, &quot;--eval=%{_target_cpu}&quot;);
237 
238         RpmArchReader(String... cmdline) {
239             this.cmdline = cmdline;
240         }
241 
242         String getRpmArch() throws IOException {
243             Executor exec = Executor.of(cmdline).saveOutput(true);
244             if (this == values()[values().length - 1]) {
245                 exec.executeExpectSuccess();
246             } else if (exec.execute() != 0) {
247                 return null;
248             }
249 
250             return exec.getOutput().get(0);
251         }
252 
253         private final String[] cmdline;
254     }
255 
256     private String rpmArch() throws IOException {
257         if (rpmArch == null) {
258             for (var rpmArchReader : RpmArchReader.values()) {
259                 rpmArch = rpmArchReader.getRpmArch();
260                 if (rpmArch != null) {
261                     break;
262                 }
263             }
264         }
265         return rpmArch;
266     }
267 
268     private Path specFile(Map&lt;String, ? super Object&gt; params) {
269         return TEMP_ROOT.fetchFrom(params).toPath().resolve(Path.of(&quot;SPECS&quot;,
270                 PACKAGE_NAME.fetchFrom(params) + &quot;.spec&quot;));
271     }
272 
273     private Path buildRPM(Map&lt;String, ? super Object&gt; params,
274             Path outdir) throws IOException {
275 
276         Path rpmFile = outdir.toAbsolutePath().resolve(String.format(
277                 &quot;%s-%s-%s.%s.rpm&quot;, PACKAGE_NAME.fetchFrom(params),
278                 VERSION.fetchFrom(params), RELEASE.fetchFrom(params), rpmArch()));
279 
280         Log.verbose(MessageFormat.format(I18N.getString(
281                 &quot;message.outputting-bundle-location&quot;),
282                 rpmFile.getParent()));
283 
284         PlatformPackage thePackage = createMetaPackage(params);
285 
286         //run rpmbuild
287         Executor.of(
288                 TOOL_RPMBUILD,
289                 &quot;-bb&quot;, specFile(params).toAbsolutePath().toString(),
290                 &quot;--define&quot;, String.format(&quot;%%_sourcedir %s&quot;,
291                         thePackage.sourceRoot()),
292                 // save result to output dir
293                 &quot;--define&quot;, String.format(&quot;%%_rpmdir %s&quot;, rpmFile.getParent()),
294                 // do not use other system directories to build as current user
295                 &quot;--define&quot;, String.format(&quot;%%_topdir %s&quot;,
296                         TEMP_ROOT.fetchFrom(params).toPath().toAbsolutePath()),
297                 &quot;--define&quot;, String.format(&quot;%%_rpmfilename %s&quot;, rpmFile.getFileName())
298         ).executeExpectSuccess();
299 
300         Log.verbose(MessageFormat.format(
301                 I18N.getString(&quot;message.output-bundle-location&quot;),
302                 rpmFile.getParent()));
303 
304         return rpmFile;
305     }
306 
307     @Override
308     public String getName() {
309         return I18N.getString(&quot;rpm.bundler.name&quot;);
310     }
311 
312     @Override
313     public String getID() {
314         return &quot;rpm&quot;;
315     }
316 
317     @Override
318     public boolean supported(boolean runtimeInstaller) {
319         return Platform.isLinux() &amp;&amp; (createRpmbuildToolValidator().validate() == null);
320     }
321 
322     @Override
323     public boolean isDefault() {
324         return !LinuxDebBundler.isDebian();
325     }
326 
327     private String rpmArch;
328 }
    </pre>
  </body>
</html>
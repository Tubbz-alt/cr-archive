<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/bsd/os_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aix/os_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_bsd.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/bsd/os_bsd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;os_bsd.inline.hpp&quot;
  41 #include &quot;os_posix.inline.hpp&quot;
  42 #include &quot;os_share_bsd.hpp&quot;
  43 #include &quot;prims/jniFastGetField.hpp&quot;
  44 #include &quot;prims/jvm_misc.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/atomic.hpp&quot;
<span class="line-removed">  47 #include &quot;runtime/extendedPC.hpp&quot;</span>
  48 #include &quot;runtime/globals.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/java.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/mutexLocker.hpp&quot;
  53 #include &quot;runtime/objectMonitor.hpp&quot;
  54 #include &quot;runtime/osThread.hpp&quot;
  55 #include &quot;runtime/perfMemory.hpp&quot;
  56 #include &quot;runtime/semaphore.hpp&quot;
  57 #include &quot;runtime/sharedRuntime.hpp&quot;
  58 #include &quot;runtime/statSampler.hpp&quot;
  59 #include &quot;runtime/stubRoutines.hpp&quot;
  60 #include &quot;runtime/thread.inline.hpp&quot;
  61 #include &quot;runtime/threadCritical.hpp&quot;
  62 #include &quot;runtime/timer.hpp&quot;
  63 #include &quot;services/attachListener.hpp&quot;
  64 #include &quot;services/memTracker.hpp&quot;
  65 #include &quot;services/runtimeService.hpp&quot;
  66 #include &quot;utilities/align.hpp&quot;
  67 #include &quot;utilities/decoder.hpp&quot;
</pre>
<hr />
<pre>
2313 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
2314 //
2315 //  The remaining code is greatly simplified from the more general suspension
2316 //  code that used to be used.
2317 //
2318 //  The protocol is quite simple:
2319 //  - suspend:
2320 //      - sends a signal to the target thread
2321 //      - polls the suspend state of the osthread using a yield loop
2322 //      - target thread signal handler (SR_handler) sets suspend state
2323 //        and blocks in sigsuspend until continued
2324 //  - resume:
2325 //      - sets target osthread state to continue
2326 //      - sends signal to end the sigsuspend loop in the SR_handler
2327 //
2328 //  Note that the SR_lock plays no role in this suspend/resume protocol,
2329 //  but is checked for NULL in SR_handler as a thread termination indicator.
2330 //  The SR_lock is, however, used by JavaThread::java_suspend()/java_resume() APIs.
2331 //
2332 //  Note that resume_clear_context() and suspend_save_context() are needed
<span class="line-modified">2333 //  by SR_handler(), so that fetch_frame_from_ucontext() works,</span>
2334 //  which in part is used by:
2335 //    - Forte Analyzer: AsyncGetCallTrace()
2336 //    - StackBanging: get_frame_at_stack_banging_point()
2337 
2338 static void resume_clear_context(OSThread *osthread) {
2339   osthread-&gt;set_ucontext(NULL);
2340   osthread-&gt;set_siginfo(NULL);
2341 }
2342 
2343 static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {
2344   osthread-&gt;set_ucontext(context);
2345   osthread-&gt;set_siginfo(siginfo);
2346 }
2347 
2348 // Handler function invoked when a thread&#39;s execution is suspended or
2349 // resumed. We have to be careful that only async-safe functions are
2350 // called here (Note: most pthread functions are not async safe and
2351 // should be avoided.)
2352 //
2353 // Note: sigwait() is a more natural fit than sigsuspend() from an
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;code/icBuffer.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/disassembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/filemap.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;os_bsd.inline.hpp&quot;
  41 #include &quot;os_posix.inline.hpp&quot;
  42 #include &quot;os_share_bsd.hpp&quot;
  43 #include &quot;prims/jniFastGetField.hpp&quot;
  44 #include &quot;prims/jvm_misc.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/atomic.hpp&quot;

  47 #include &quot;runtime/globals.hpp&quot;
  48 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  49 #include &quot;runtime/java.hpp&quot;
  50 #include &quot;runtime/javaCalls.hpp&quot;
  51 #include &quot;runtime/mutexLocker.hpp&quot;
  52 #include &quot;runtime/objectMonitor.hpp&quot;
  53 #include &quot;runtime/osThread.hpp&quot;
  54 #include &quot;runtime/perfMemory.hpp&quot;
  55 #include &quot;runtime/semaphore.hpp&quot;
  56 #include &quot;runtime/sharedRuntime.hpp&quot;
  57 #include &quot;runtime/statSampler.hpp&quot;
  58 #include &quot;runtime/stubRoutines.hpp&quot;
  59 #include &quot;runtime/thread.inline.hpp&quot;
  60 #include &quot;runtime/threadCritical.hpp&quot;
  61 #include &quot;runtime/timer.hpp&quot;
  62 #include &quot;services/attachListener.hpp&quot;
  63 #include &quot;services/memTracker.hpp&quot;
  64 #include &quot;services/runtimeService.hpp&quot;
  65 #include &quot;utilities/align.hpp&quot;
  66 #include &quot;utilities/decoder.hpp&quot;
</pre>
<hr />
<pre>
2312 //  within hotspot. Currently used by JFR&#39;s OSThreadSampler
2313 //
2314 //  The remaining code is greatly simplified from the more general suspension
2315 //  code that used to be used.
2316 //
2317 //  The protocol is quite simple:
2318 //  - suspend:
2319 //      - sends a signal to the target thread
2320 //      - polls the suspend state of the osthread using a yield loop
2321 //      - target thread signal handler (SR_handler) sets suspend state
2322 //        and blocks in sigsuspend until continued
2323 //  - resume:
2324 //      - sets target osthread state to continue
2325 //      - sends signal to end the sigsuspend loop in the SR_handler
2326 //
2327 //  Note that the SR_lock plays no role in this suspend/resume protocol,
2328 //  but is checked for NULL in SR_handler as a thread termination indicator.
2329 //  The SR_lock is, however, used by JavaThread::java_suspend()/java_resume() APIs.
2330 //
2331 //  Note that resume_clear_context() and suspend_save_context() are needed
<span class="line-modified">2332 //  by SR_handler(), so that fetch_frame_from_context() works,</span>
2333 //  which in part is used by:
2334 //    - Forte Analyzer: AsyncGetCallTrace()
2335 //    - StackBanging: get_frame_at_stack_banging_point()
2336 
2337 static void resume_clear_context(OSThread *osthread) {
2338   osthread-&gt;set_ucontext(NULL);
2339   osthread-&gt;set_siginfo(NULL);
2340 }
2341 
2342 static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {
2343   osthread-&gt;set_ucontext(context);
2344   osthread-&gt;set_siginfo(siginfo);
2345 }
2346 
2347 // Handler function invoked when a thread&#39;s execution is suspended or
2348 // resumed. We have to be careful that only async-safe functions are
2349 // called here (Note: most pthread functions are not async safe and
2350 // should be avoided.)
2351 //
2352 // Note: sigwait() is a more natural fit than sigsuspend() from an
</pre>
</td>
</tr>
</table>
<center><a href="../aix/os_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_bsd.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
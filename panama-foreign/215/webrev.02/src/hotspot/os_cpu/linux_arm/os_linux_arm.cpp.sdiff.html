<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux_aarch64/thread_linux_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;assembler_arm.inline.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/icBuffer.hpp&quot;
 32 #include &quot;code/vtableStubs.hpp&quot;
 33 #include &quot;interpreter/interpreter.hpp&quot;
 34 #include &quot;memory/allocation.inline.hpp&quot;
 35 #include &quot;nativeInst_arm.hpp&quot;
 36 #include &quot;os_share_linux.hpp&quot;
 37 #include &quot;prims/jniFastGetField.hpp&quot;
 38 #include &quot;prims/jvm_misc.hpp&quot;
 39 #include &quot;runtime/arguments.hpp&quot;
<span class="line-removed"> 40 #include &quot;runtime/extendedPC.hpp&quot;</span>
 41 #include &quot;runtime/frame.inline.hpp&quot;
 42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 43 #include &quot;runtime/java.hpp&quot;
 44 #include &quot;runtime/javaCalls.hpp&quot;
 45 #include &quot;runtime/mutexLocker.hpp&quot;
 46 #include &quot;runtime/osThread.hpp&quot;
 47 #include &quot;runtime/safepointMechanism.hpp&quot;
 48 #include &quot;runtime/sharedRuntime.hpp&quot;
 49 #include &quot;runtime/stubRoutines.hpp&quot;
 50 #include &quot;runtime/timer.hpp&quot;
 51 #include &quot;utilities/debug.hpp&quot;
 52 #include &quot;utilities/events.hpp&quot;
 53 #include &quot;utilities/vmError.hpp&quot;
 54 
 55 // put OS-includes here
 56 # include &lt;sys/types.h&gt;
 57 # include &lt;sys/mman.h&gt;
 58 # include &lt;pthread.h&gt;
 59 # include &lt;signal.h&gt;
 60 # include &lt;errno.h&gt;
</pre>
<hr />
<pre>
125 }
126 
127 bool is_safe_for_fp(address pc) {
128 #ifdef __thumb__
129   if (CodeCache::find_blob(pc) != NULL) {
130     return true;
131   }
132   // For thumb C frames, given an fp we have no idea how to access the frame contents.
133   return false;
134 #else
135   // Calling os::address_is_in_vm() here leads to a dladdr call. Calling any libc
136   // function during os::get_native_stack() can result in a deadlock if JFR is
137   // enabled. For now, be more lenient and allow all pc&#39;s. There are other
138   // frame sanity checks in shared code, and to date they have been sufficient
139   // for other platforms.
140   //return os::address_is_in_vm(pc);
141   return true;
142 #endif
143 }
144 
<span class="line-modified">145 // For Forte Analyzer AsyncGetCallTrace profiling support - thread</span>
<span class="line-removed">146 // is currently interrupted by SIGPROF.</span>
<span class="line-removed">147 // os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal</span>
<span class="line-removed">148 // frames. Currently we don&#39;t do that on Linux, so it&#39;s the same as</span>
<span class="line-removed">149 // os::fetch_frame_from_context().</span>
<span class="line-removed">150 ExtendedPC os::Linux::fetch_frame_from_ucontext(Thread* thread,</span>
<span class="line-removed">151   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {</span>
<span class="line-removed">152 </span>
<span class="line-removed">153   assert(thread != NULL, &quot;just checking&quot;);</span>
<span class="line-removed">154   assert(ret_sp != NULL, &quot;just checking&quot;);</span>
<span class="line-removed">155   assert(ret_fp != NULL, &quot;just checking&quot;);</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   return os::fetch_frame_from_context(uc, ret_sp, ret_fp);</span>
<span class="line-removed">158 }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,</span>
161                     intptr_t** ret_sp, intptr_t** ret_fp) {
162 
<span class="line-modified">163   ExtendedPC  epc;</span>
164   const ucontext_t* uc = (const ucontext_t*)ucVoid;
165 
166   if (uc != NULL) {
<span class="line-modified">167     epc = ExtendedPC(os::Linux::ucontext_get_pc(uc));</span>
168     if (ret_sp) *ret_sp = os::Linux::ucontext_get_sp(uc);
169     if (ret_fp) {
170       intptr_t* fp = os::Linux::ucontext_get_fp(uc);
171 #ifndef __thumb__
<span class="line-modified">172       if (CodeCache::find_blob(epc.pc()) == NULL) {</span>
173         // It&#39;s a C frame. We need to adjust the fp.
174         fp += os::C_frame_offset;
175       }
176 #endif
177       // Clear FP when stack walking is dangerous so that
178       // the frame created will not be walked.
179       // However, ensure FP is set correctly when reliable and
180       // potentially necessary.
<span class="line-modified">181       if (!is_safe_for_fp(epc.pc())) {</span>
182         // FP unreliable
183         fp = (intptr_t *)NULL;
184       }
185       *ret_fp = fp;
186     }
187   } else {
<span class="line-modified">188     // construct empty ExtendedPC for return value checking</span>
<span class="line-removed">189     epc = ExtendedPC(NULL);</span>
190     if (ret_sp) *ret_sp = (intptr_t *)NULL;
191     if (ret_fp) *ret_fp = (intptr_t *)NULL;
192   }
193 
194   return epc;
195 }
196 
197 frame os::fetch_frame_from_context(const void* ucVoid) {
198   intptr_t* sp;
199   intptr_t* fp;
<span class="line-modified">200   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);</span>
<span class="line-modified">201   return frame(sp, fp, epc.pc());</span>
202 }
203 
204 frame os::get_sender_for_C_frame(frame* fr) {
205 #ifdef __thumb__
206   // We can&#39;t reliably get anything from a thumb C frame.
207   return frame();
208 #else
209   address pc = fr-&gt;sender_pc();
210   if (! is_safe_for_fp(pc)) {
211     return frame(fr-&gt;sender_sp(), (intptr_t *)NULL, pc);
212   } else {
213     return frame(fr-&gt;sender_sp(), fr-&gt;link() + os::C_frame_offset, pc);
214   }
215 #endif
216 }
217 
218 //
219 // This actually returns two frames up. It does not return os::current_frame(),
220 // which is the actual current frame. Nor does it return os::get_native_stack(),
221 // which is the caller. It returns whoever called os::get_native_stack(). Not
</pre>
</td>
<td>
<hr />
<pre>
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;assembler_arm.inline.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/icBuffer.hpp&quot;
 32 #include &quot;code/vtableStubs.hpp&quot;
 33 #include &quot;interpreter/interpreter.hpp&quot;
 34 #include &quot;memory/allocation.inline.hpp&quot;
 35 #include &quot;nativeInst_arm.hpp&quot;
 36 #include &quot;os_share_linux.hpp&quot;
 37 #include &quot;prims/jniFastGetField.hpp&quot;
 38 #include &quot;prims/jvm_misc.hpp&quot;
 39 #include &quot;runtime/arguments.hpp&quot;

 40 #include &quot;runtime/frame.inline.hpp&quot;
 41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 42 #include &quot;runtime/java.hpp&quot;
 43 #include &quot;runtime/javaCalls.hpp&quot;
 44 #include &quot;runtime/mutexLocker.hpp&quot;
 45 #include &quot;runtime/osThread.hpp&quot;
 46 #include &quot;runtime/safepointMechanism.hpp&quot;
 47 #include &quot;runtime/sharedRuntime.hpp&quot;
 48 #include &quot;runtime/stubRoutines.hpp&quot;
 49 #include &quot;runtime/timer.hpp&quot;
 50 #include &quot;utilities/debug.hpp&quot;
 51 #include &quot;utilities/events.hpp&quot;
 52 #include &quot;utilities/vmError.hpp&quot;
 53 
 54 // put OS-includes here
 55 # include &lt;sys/types.h&gt;
 56 # include &lt;sys/mman.h&gt;
 57 # include &lt;pthread.h&gt;
 58 # include &lt;signal.h&gt;
 59 # include &lt;errno.h&gt;
</pre>
<hr />
<pre>
124 }
125 
126 bool is_safe_for_fp(address pc) {
127 #ifdef __thumb__
128   if (CodeCache::find_blob(pc) != NULL) {
129     return true;
130   }
131   // For thumb C frames, given an fp we have no idea how to access the frame contents.
132   return false;
133 #else
134   // Calling os::address_is_in_vm() here leads to a dladdr call. Calling any libc
135   // function during os::get_native_stack() can result in a deadlock if JFR is
136   // enabled. For now, be more lenient and allow all pc&#39;s. There are other
137   // frame sanity checks in shared code, and to date they have been sufficient
138   // for other platforms.
139   //return os::address_is_in_vm(pc);
140   return true;
141 #endif
142 }
143 
<span class="line-modified">144 address os::fetch_frame_from_context(const void* ucVoid,</span>















145                     intptr_t** ret_sp, intptr_t** ret_fp) {
146 
<span class="line-modified">147   address epc;</span>
148   const ucontext_t* uc = (const ucontext_t*)ucVoid;
149 
150   if (uc != NULL) {
<span class="line-modified">151     epc = os::Linux::ucontext_get_pc(uc);</span>
152     if (ret_sp) *ret_sp = os::Linux::ucontext_get_sp(uc);
153     if (ret_fp) {
154       intptr_t* fp = os::Linux::ucontext_get_fp(uc);
155 #ifndef __thumb__
<span class="line-modified">156       if (CodeCache::find_blob(epc) == NULL) {</span>
157         // It&#39;s a C frame. We need to adjust the fp.
158         fp += os::C_frame_offset;
159       }
160 #endif
161       // Clear FP when stack walking is dangerous so that
162       // the frame created will not be walked.
163       // However, ensure FP is set correctly when reliable and
164       // potentially necessary.
<span class="line-modified">165       if (!is_safe_for_fp(epc)) {</span>
166         // FP unreliable
167         fp = (intptr_t *)NULL;
168       }
169       *ret_fp = fp;
170     }
171   } else {
<span class="line-modified">172     epc = NULL;</span>

173     if (ret_sp) *ret_sp = (intptr_t *)NULL;
174     if (ret_fp) *ret_fp = (intptr_t *)NULL;
175   }
176 
177   return epc;
178 }
179 
180 frame os::fetch_frame_from_context(const void* ucVoid) {
181   intptr_t* sp;
182   intptr_t* fp;
<span class="line-modified">183   address epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);</span>
<span class="line-modified">184   return frame(sp, fp, epc);</span>
185 }
186 
187 frame os::get_sender_for_C_frame(frame* fr) {
188 #ifdef __thumb__
189   // We can&#39;t reliably get anything from a thumb C frame.
190   return frame();
191 #else
192   address pc = fr-&gt;sender_pc();
193   if (! is_safe_for_fp(pc)) {
194     return frame(fr-&gt;sender_sp(), (intptr_t *)NULL, pc);
195   } else {
196     return frame(fr-&gt;sender_sp(), fr-&gt;link() + os::C_frame_offset, pc);
197   }
198 #endif
199 }
200 
201 //
202 // This actually returns two frames up. It does not return os::current_frame(),
203 // which is the actual current frame. Nor does it return os::get_native_stack(),
204 // which is the caller. It returns whoever called os::get_native_stack(). Not
</pre>
</td>
</tr>
</table>
<center><a href="../linux_aarch64/thread_linux_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread_linux_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/utilities/stack.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stack.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectInputStream.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/utilities/stack.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,27 ***</span>
  
  template &lt;class E, MEMFLAGS F&gt;
  void Stack&lt;E, F&gt;::push(E item)
  {
    assert(!is_full(), &quot;pushing onto a full stack&quot;);
<span class="line-modified">!   if (this-&gt;_cur_seg_size == this-&gt;_seg_size) {</span>
      push_segment();
    }
<span class="line-modified">!   this-&gt;_cur_seg[this-&gt;_cur_seg_size] = item;</span>
<span class="line-modified">!   ++this-&gt;_cur_seg_size;</span>
  }
  
  template &lt;class E, MEMFLAGS F&gt;
  E Stack&lt;E, F&gt;::pop()
  {
    assert(!is_empty(), &quot;popping from an empty stack&quot;);
<span class="line-modified">!   if (this-&gt;_cur_seg_size == 1) {</span>
<span class="line-modified">!     E tmp = _cur_seg[--this-&gt;_cur_seg_size];</span>
<span class="line-modified">!     pop_segment();</span>
<span class="line-modified">!     return tmp;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   return this-&gt;_cur_seg[--this-&gt;_cur_seg_size];</span>
  }
  
  template &lt;class E, MEMFLAGS F&gt;
  void Stack&lt;E, F&gt;::clear(bool clear_cache)
  {
<span class="line-new-header">--- 59,31 ---</span>
  
  template &lt;class E, MEMFLAGS F&gt;
  void Stack&lt;E, F&gt;::push(E item)
  {
    assert(!is_full(), &quot;pushing onto a full stack&quot;);
<span class="line-modified">!   size_t index = this-&gt;_cur_seg_size;</span>
<span class="line-added">+   if (index == this-&gt;_seg_size) {</span>
      push_segment();
<span class="line-added">+     index = 0;                  // Instead of fetching known zero _cur_seg_size.</span>
    }
<span class="line-modified">!   this-&gt;_cur_seg[index] = item;</span>
<span class="line-modified">!   this-&gt;_cur_seg_size = index + 1;</span>
  }
  
  template &lt;class E, MEMFLAGS F&gt;
  E Stack&lt;E, F&gt;::pop()
  {
    assert(!is_empty(), &quot;popping from an empty stack&quot;);
<span class="line-modified">!   // _cur_seg_size is never 0 if not empty.  pop that empties a</span>
<span class="line-modified">!   // segment also pops the segment.  push that adds a segment always</span>
<span class="line-modified">!   // adds an entry to the new segment.</span>
<span class="line-modified">!   assert(this-&gt;_cur_seg_size != 0, &quot;invariant&quot;);</span>
<span class="line-modified">!   size_t index = --this-&gt;_cur_seg_size;</span>
<span class="line-modified">!   E result = _cur_seg[index];</span>
<span class="line-added">+   if (index == 0) pop_segment();</span>
<span class="line-added">+   return result;</span>
  }
  
  template &lt;class E, MEMFLAGS F&gt;
  void Stack&lt;E, F&gt;::clear(bool clear_cache)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,13 ***</span>
    FREE_C_HEAP_ARRAY(char, (char*) addr);
  }
  
  // Stack is used by the GC code and in some hot paths a lot of the Stack
  // code gets inlined. This is generally good, but when too much code has
<span class="line-modified">! // been inlined, no further inlining is allowed by GCC. Therefore we need</span>
<span class="line-modified">! // to prevent parts of the slow path in Stack to be inlined to allow other</span>
<span class="line-removed">- // code to be.</span>
  template &lt;class E, MEMFLAGS F&gt;
  NOINLINE void Stack&lt;E, F&gt;::push_segment()
  {
    assert(this-&gt;_cur_seg_size == this-&gt;_seg_size, &quot;current segment is not full&quot;);
    E* next;
<span class="line-new-header">--- 147,12 ---</span>
    FREE_C_HEAP_ARRAY(char, (char*) addr);
  }
  
  // Stack is used by the GC code and in some hot paths a lot of the Stack
  // code gets inlined. This is generally good, but when too much code has
<span class="line-modified">! // been inlined, further inlining in the caller might be inhibited. So</span>
<span class="line-modified">! // prevent infrequent slow path segment manipulation from being inlined.</span>
  template &lt;class E, MEMFLAGS F&gt;
  NOINLINE void Stack&lt;E, F&gt;::push_segment()
  {
    assert(this-&gt;_cur_seg_size == this-&gt;_seg_size, &quot;current segment is not full&quot;);
    E* next;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,11 ***</span>
    this-&gt;_full_seg_size += at_empty_transition ? 0 : this-&gt;_seg_size;
    DEBUG_ONLY(verify(at_empty_transition);)
  }
  
  template &lt;class E, MEMFLAGS F&gt;
<span class="line-modified">! void Stack&lt;E, F&gt;::pop_segment()</span>
  {
    assert(this-&gt;_cur_seg_size == 0, &quot;current segment is not empty&quot;);
    E* const prev = get_link(_cur_seg);
    if (this-&gt;_cache_size &lt; this-&gt;_max_cache_size) {
      // Add the current segment to the cache.
<span class="line-new-header">--- 171,11 ---</span>
    this-&gt;_full_seg_size += at_empty_transition ? 0 : this-&gt;_seg_size;
    DEBUG_ONLY(verify(at_empty_transition);)
  }
  
  template &lt;class E, MEMFLAGS F&gt;
<span class="line-modified">! NOINLINE void Stack&lt;E, F&gt;::pop_segment()</span>
  {
    assert(this-&gt;_cur_seg_size == 0, &quot;current segment is not empty&quot;);
    E* const prev = get_link(_cur_seg);
    if (this-&gt;_cache_size &lt; this-&gt;_max_cache_size) {
      // Add the current segment to the cache.
</pre>
<center><a href="stack.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/io/ObjectInputStream.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/utilities/growableArray.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_UTILITIES_GROWABLEARRAY_HPP
 26 #define SHARE_UTILITIES_GROWABLEARRAY_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 29 #include &quot;memory/iterator.hpp&quot;</span>
 30 #include &quot;utilities/debug.hpp&quot;
 31 #include &quot;utilities/globalDefinitions.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #include &quot;utilities/powerOfTwo.hpp&quot;
 34 
 35 // A growable array.
 36 
 37 /*************************************************************************/
 38 /*                                                                       */
 39 /*     WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING   */
 40 /*                                                                       */
 41 /* Should you use GrowableArrays to contain handles you must be certain  */
<a name="3" id="anc3"></a><span class="line-modified"> 42 /* that the GrowableArray does not outlive the HandleMark that contains  */</span>
 43 /* the handles. Since GrowableArrays are typically resource allocated    */
 44 /* the following is an example of INCORRECT CODE,                        */
 45 /*                                                                       */
 46 /* ResourceMark rm;                                                      */
 47 /* GrowableArray&lt;Handle&gt;* arr = new GrowableArray&lt;Handle&gt;(size);         */
 48 /* if (blah) {                                                           */
 49 /*    while (...) {                                                      */
 50 /*      HandleMark hm;                                                   */
 51 /*      ...                                                              */
 52 /*      Handle h(THREAD, some_oop);                                      */
 53 /*      arr-&gt;append(h);                                                  */
 54 /*    }                                                                  */
 55 /* }                                                                     */
 56 /* if (arr-&gt;length() != 0 ) {                                            */
 57 /*    oop bad_oop = arr-&gt;at(0)(); // Handle is BAD HERE.                 */
 58 /*    ...                                                                */
 59 /* }                                                                     */
 60 /*                                                                       */
 61 /* If the GrowableArrays you are creating is C_Heap allocated then it    */
<a name="4" id="anc4"></a><span class="line-modified"> 62 /* should not hold handles since the handles could trivially try and     */</span>
 63 /* outlive their HandleMark. In some situations you might need to do     */
 64 /* this and it would be legal but be very careful and see if you can do  */
 65 /* the code in some other manner.                                        */
 66 /*                                                                       */
 67 /*************************************************************************/
 68 
<a name="5" id="anc5"></a><span class="line-modified"> 69 // Non-template base class responsible for handling the length and max.</span>


 70 
<a name="6" id="anc6"></a>
 71 
<a name="7" id="anc7"></a><span class="line-modified"> 72 class GrowableArrayBase : public ResourceObj {</span>





 73   friend class VMStructs;
 74 
<a name="8" id="anc8"></a><span class="line-modified"> 75 protected:</span>
<span class="line-modified"> 76   // Current number of accessible elements</span>
<span class="line-modified"> 77   int _len;</span>
<span class="line-modified"> 78   // Current number of allocated elements</span>
<span class="line-modified"> 79   int _max;</span>

























 80 
<a name="9" id="anc9"></a><span class="line-added"> 81   GrowableArrayBase(int initial_max, int initial_len) :</span>
<span class="line-added"> 82       _len(initial_len),</span>
<span class="line-added"> 83       _max(initial_max) {</span>
 84     assert(_len &gt;= 0 &amp;&amp; _len &lt;= _max, &quot;initial_len too big&quot;);
<a name="10" id="anc10"></a>







 85   }
 86 
<a name="11" id="anc11"></a><span class="line-modified"> 87   ~GrowableArrayBase() {}</span>






































 88 
 89 public:
<a name="12" id="anc12"></a>






































 90   int   length() const          { return _len; }
 91   int   max_length() const      { return _max; }
<a name="13" id="anc13"></a><span class="line-modified"> 92 </span>
 93   bool  is_empty() const        { return _len == 0; }
 94   bool  is_nonempty() const     { return _len != 0; }
 95   bool  is_full() const         { return _len == _max; }
<a name="14" id="anc14"></a>


 96 
<a name="15" id="anc15"></a><span class="line-modified"> 97   void  clear()                 { _len = 0; }</span>
<span class="line-modified"> 98   void  trunc_to(int length)    {</span>
<span class="line-modified"> 99     assert(length &lt;= _len,&quot;cannot increase length&quot;);</span>
<span class="line-modified">100     _len = length;</span>


101   }
<a name="16" id="anc16"></a><span class="line-added">102 };</span>
103 
<a name="17" id="anc17"></a><span class="line-modified">104 template &lt;typename E&gt; class GrowableArrayIterator;</span>
<span class="line-modified">105 template &lt;typename E, typename UnaryPredicate&gt; class GrowableArrayFilterIterator;</span>
<span class="line-modified">106 </span>
<span class="line-modified">107 // Extends GrowableArrayBase with a typed data array.</span>
<span class="line-modified">108 //</span>
<span class="line-modified">109 // E: Element type</span>
<span class="line-added">110 //</span>
<span class="line-added">111 // The &quot;view&quot; adds function that don&#39;t grow or deallocate</span>
<span class="line-added">112 // the _data array, so there&#39;s no need for an allocator.</span>
<span class="line-added">113 //</span>
<span class="line-added">114 // The &quot;view&quot; can be used to type erase the allocator classes</span>
<span class="line-added">115 // of GrowableArrayWithAllocator.</span>
<span class="line-added">116 template &lt;typename E&gt;</span>
<span class="line-added">117 class GrowableArrayView : public GrowableArrayBase {</span>
<span class="line-added">118 protected:</span>
<span class="line-added">119   E* _data; // data array</span>
120 
<a name="18" id="anc18"></a><span class="line-added">121   GrowableArrayView&lt;E&gt;(E* data, int initial_max, int initial_len) :</span>
<span class="line-added">122       GrowableArrayBase(initial_max, initial_len), _data(data) {}</span>
<span class="line-added">123 </span>
<span class="line-added">124   ~GrowableArrayView() {}</span>
<span class="line-added">125 </span>
<span class="line-added">126 public:</span>
127   E&amp; at(int i) {
128     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
129     return _data[i];
130   }
131 
132   E const&amp; at(int i) const {
133     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
134     return _data[i];
135   }
136 
137   E* adr_at(int i) const {
138     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
139     return &amp;_data[i];
140   }
141 
142   E first() const {
143     assert(_len &gt; 0, &quot;empty list&quot;);
144     return _data[0];
145   }
146 
147   E top() const {
148     assert(_len &gt; 0, &quot;empty list&quot;);
149     return _data[_len-1];
150   }
151 
152   E last() const {
153     return top();
154   }
155 
156   GrowableArrayIterator&lt;E&gt; begin() const {
157     return GrowableArrayIterator&lt;E&gt;(this, 0);
158   }
159 
160   GrowableArrayIterator&lt;E&gt; end() const {
161     return GrowableArrayIterator&lt;E&gt;(this, length());
162   }
163 
<a name="19" id="anc19"></a>

164   E pop() {
165     assert(_len &gt; 0, &quot;empty list&quot;);
166     return _data[--_len];
167   }
168 
169   void at_put(int i, const E&amp; elem) {
170     assert(0 &lt;= i &amp;&amp; i &lt; _len, &quot;illegal index&quot;);
171     _data[i] = elem;
172   }
173 
<a name="20" id="anc20"></a>

















174   bool contains(const E&amp; elem) const {
175     for (int i = 0; i &lt; _len; i++) {
176       if (_data[i] == elem) return true;
177     }
178     return false;
179   }
180 
181   int  find(const E&amp; elem) const {
182     for (int i = 0; i &lt; _len; i++) {
183       if (_data[i] == elem) return i;
184     }
185     return -1;
186   }
187 
188   int  find_from_end(const E&amp; elem) const {
189     for (int i = _len-1; i &gt;= 0; i--) {
190       if (_data[i] == elem) return i;
191     }
192     return -1;
193   }
194 
195   int  find(void* token, bool f(void*, E)) const {
196     for (int i = 0; i &lt; _len; i++) {
197       if (f(token, _data[i])) return i;
198     }
199     return -1;
200   }
201 
202   int  find_from_end(void* token, bool f(void*, E)) const {
203     // start at the end of the array
204     for (int i = _len-1; i &gt;= 0; i--) {
205       if (f(token, _data[i])) return i;
206     }
207     return -1;
208   }
209 
210   void remove(const E&amp; elem) {
211     for (int i = 0; i &lt; _len; i++) {
212       if (_data[i] == elem) {
213         for (int j = i + 1; j &lt; _len; j++) _data[j-1] = _data[j];
214         _len--;
215         return;
216       }
217     }
218     ShouldNotReachHere();
219   }
220 
221   // The order is preserved.
222   void remove_at(int index) {
223     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
224     for (int j = index + 1; j &lt; _len; j++) _data[j-1] = _data[j];
225     _len--;
226   }
227 
228   // The order is changed.
229   void delete_at(int index) {
230     assert(0 &lt;= index &amp;&amp; index &lt; _len, &quot;illegal index&quot;);
231     if (index &lt; --_len) {
232       // Replace removed element with last one.
233       _data[index] = _data[_len];
234     }
235   }
236 
<a name="21" id="anc21"></a><span class="line-modified">237   void sort(int f(E*, E*)) {</span>




































238     qsort(_data, length(), sizeof(E), (_sort_Fn)f);
239   }
240   // sort by fixed-stride sub arrays:
<a name="22" id="anc22"></a><span class="line-modified">241   void sort(int f(E*, E*), int stride) {</span>
242     qsort(_data, length() / stride, sizeof(E) * stride, (_sort_Fn)f);
243   }
244 
<a name="23" id="anc23"></a>












245   template &lt;typename K, int compare(const K&amp;, const E&amp;)&gt; int find_sorted(const K&amp; key, bool&amp; found) {
246     found = false;
247     int min = 0;
248     int max = length() - 1;
249 
250     while (max &gt;= min) {
251       int mid = (int)(((uint)max + min) / 2);
252       E value = at(mid);
253       int diff = compare(key, value);
254       if (diff &gt; 0) {
255         min = mid + 1;
256       } else if (diff &lt; 0) {
257         max = mid - 1;
258       } else {
259         found = true;
260         return mid;
261       }
262     }
263     return min;
264   }
265 
<a name="24" id="anc24"></a><span class="line-modified">266   template &lt;typename K&gt;</span>









267   int find_sorted(CompareClosure&lt;E&gt;* cc, const K&amp; key, bool&amp; found) {
268     found = false;
269     int min = 0;
270     int max = length() - 1;
271 
272     while (max &gt;= min) {
273       int mid = (int)(((uint)max + min) / 2);
274       E value = at(mid);
275       int diff = cc-&gt;do_compare(key, value);
276       if (diff &gt; 0) {
277         min = mid + 1;
278       } else if (diff &lt; 0) {
279         max = mid - 1;
280       } else {
281         found = true;
282         return mid;
283       }
284     }
285     return min;
286   }
<a name="25" id="anc25"></a><span class="line-added">287 </span>
<span class="line-added">288   void print() {</span>
<span class="line-added">289     tty-&gt;print(&quot;Growable Array &quot; INTPTR_FORMAT, this);</span>
<span class="line-added">290     tty-&gt;print(&quot;: length %ld (_max %ld) { &quot;, _len, _max);</span>
<span class="line-added">291     for (int i = 0; i &lt; _len; i++) {</span>
<span class="line-added">292       tty-&gt;print(INTPTR_FORMAT &quot; &quot;, *(intptr_t*)&amp;(_data[i]));</span>
<span class="line-added">293     }</span>
<span class="line-added">294     tty-&gt;print(&quot;}\n&quot;);</span>
<span class="line-added">295   }</span>
296 };
297 
<a name="26" id="anc26"></a><span class="line-modified">298 // GrowableArrayWithAllocator extends the &quot;view&quot; with</span>
<span class="line-added">299 // the capability to grow and deallocate the data array.</span>
<span class="line-added">300 //</span>
<span class="line-added">301 // The allocator responsibility is delegated to the sub-class.</span>
<span class="line-added">302 //</span>
<span class="line-added">303 // Derived: The sub-class responsible for allocation / deallocation</span>
<span class="line-added">304 //  - E* Derived::allocate()       - member function responsible for allocation</span>
<span class="line-added">305 //  - void Derived::deallocate(E*) - member function responsible for deallocation</span>
<span class="line-added">306 template &lt;typename E, typename Derived&gt;</span>
<span class="line-added">307 class GrowableArrayWithAllocator : public GrowableArrayView&lt;E&gt; {</span>
<span class="line-added">308   friend class VMStructs;</span>
309 
<a name="27" id="anc27"></a><span class="line-modified">310   void grow(int j);</span>
<span class="line-modified">311 </span>
<span class="line-modified">312 protected:</span>
<span class="line-modified">313   GrowableArrayWithAllocator(E* data, int initial_max) :</span>
<span class="line-modified">314       GrowableArrayView&lt;E&gt;(data, initial_max, 0) {</span>
<span class="line-modified">315     for (int i = 0; i &lt; initial_max; i++) {</span>
<span class="line-added">316       ::new ((void*)&amp;data[i]) E();</span>
<span class="line-added">317     }</span>
<span class="line-added">318   }</span>
<span class="line-added">319 </span>
<span class="line-added">320   GrowableArrayWithAllocator(E* data, int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="line-added">321       GrowableArrayView&lt;E&gt;(data, initial_max, initial_len) {</span>
322     int i = 0;
<a name="28" id="anc28"></a><span class="line-modified">323     for (; i &lt; initial_len; i++) {</span>
<span class="line-modified">324       ::new ((void*)&amp;data[i]) E(filler);</span>







325     }
<a name="29" id="anc29"></a><span class="line-modified">326     for (; i &lt; initial_max; i++) {</span>
<span class="line-modified">327       ::new ((void*)&amp;data[i]) E();</span>
<span class="line-added">328     }</span>
<span class="line-added">329   }</span>
330 
<a name="30" id="anc30"></a><span class="line-modified">331   ~GrowableArrayWithAllocator() {}</span>
<span class="line-modified">332 </span>
<span class="line-modified">333 public:</span>
<span class="line-modified">334   int append(const E&amp; elem) {</span>
<span class="line-modified">335     if (this-&gt;_len == this-&gt;_max) grow(this-&gt;_len);</span>
<span class="line-modified">336     int idx = this-&gt;_len++;</span>
<span class="line-added">337     this-&gt;_data[idx] = elem;</span>
<span class="line-added">338     return idx;</span>
<span class="line-added">339   }</span>
<span class="line-added">340 </span>
<span class="line-added">341   bool append_if_missing(const E&amp; elem) {</span>
<span class="line-added">342     // Returns TRUE if elem is added.</span>
<span class="line-added">343     bool missed = !this-&gt;contains(elem);</span>
<span class="line-added">344     if (missed) append(elem);</span>
<span class="line-added">345     return missed;</span>
<span class="line-added">346   }</span>
<span class="line-added">347 </span>
<span class="line-added">348   void push(const E&amp; elem) { append(elem); }</span>
<span class="line-added">349 </span>
<span class="line-added">350   E at_grow(int i, const E&amp; fill = E()) {</span>
<span class="line-added">351     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="line-added">352     if (i &gt;= this-&gt;_len) {</span>
<span class="line-added">353       if (i &gt;= this-&gt;_max) grow(i);</span>
<span class="line-added">354       for (int j = this-&gt;_len; j &lt;= i; j++)</span>
<span class="line-added">355         this-&gt;_data[j] = fill;</span>
<span class="line-added">356       this-&gt;_len = i+1;</span>
357     }
<a name="31" id="anc31"></a><span class="line-modified">358     return this-&gt;_data[i];</span>
<span class="line-modified">359   }</span>
360 
<a name="32" id="anc32"></a><span class="line-modified">361   void at_put_grow(int i, const E&amp; elem, const E&amp; fill = E()) {</span>
<span class="line-modified">362     assert(0 &lt;= i, &quot;negative index&quot;);</span>
<span class="line-modified">363     if (i &gt;= this-&gt;_len) {</span>
<span class="line-modified">364       if (i &gt;= this-&gt;_max) grow(i);</span>
<span class="line-modified">365       for (int j = this-&gt;_len; j &lt; i; j++)</span>
<span class="line-modified">366         this-&gt;_data[j] = fill;</span>
<span class="line-modified">367       this-&gt;_len = i+1;</span>




368     }
<a name="33" id="anc33"></a><span class="line-added">369     this-&gt;_data[i] = elem;</span>
<span class="line-added">370   }</span>
<span class="line-added">371 </span>
<span class="line-added">372   // inserts the given element before the element at index i</span>
<span class="line-added">373   void insert_before(const int idx, const E&amp; elem) {</span>
<span class="line-added">374     assert(0 &lt;= idx &amp;&amp; idx &lt;= this-&gt;_len, &quot;illegal index&quot;);</span>
<span class="line-added">375     if (this-&gt;_len == this-&gt;_max) grow(this-&gt;_len);</span>
<span class="line-added">376     for (int j = this-&gt;_len - 1; j &gt;= idx; j--) {</span>
<span class="line-added">377       this-&gt;_data[j + 1] = this-&gt;_data[j];</span>
<span class="line-added">378     }</span>
<span class="line-added">379     this-&gt;_len++;</span>
<span class="line-added">380     this-&gt;_data[idx] = elem;</span>
<span class="line-added">381   }</span>
<span class="line-added">382 </span>
<span class="line-added">383   void insert_before(const int idx, const GrowableArrayView&lt;E&gt;* array) {</span>
<span class="line-added">384     assert(0 &lt;= idx &amp;&amp; idx &lt;= this-&gt;_len, &quot;illegal index&quot;);</span>
<span class="line-added">385     int array_len = array-&gt;length();</span>
<span class="line-added">386     int new_len = this-&gt;_len + array_len;</span>
<span class="line-added">387     if (new_len &gt;= this-&gt;_max) grow(new_len);</span>
<span class="line-added">388 </span>
<span class="line-added">389     for (int j = this-&gt;_len - 1; j &gt;= idx; j--) {</span>
<span class="line-added">390       this-&gt;_data[j + array_len] = this-&gt;_data[j];</span>
<span class="line-added">391     }</span>
<span class="line-added">392 </span>
<span class="line-added">393     for (int j = 0; j &lt; array_len; j++) {</span>
<span class="line-added">394       this-&gt;_data[idx + j] = array-&gt;at(j);</span>
<span class="line-added">395     }</span>
<span class="line-added">396 </span>
<span class="line-added">397     this-&gt;_len += array_len;</span>
<span class="line-added">398   }</span>
<span class="line-added">399 </span>
<span class="line-added">400   void appendAll(const GrowableArrayView&lt;E&gt;* l) {</span>
<span class="line-added">401     for (int i = 0; i &lt; l-&gt;length(); i++) {</span>
<span class="line-added">402       this-&gt;at_put_grow(this-&gt;_len, l-&gt;at(i), E());</span>
<span class="line-added">403     }</span>
<span class="line-added">404   }</span>
<span class="line-added">405 </span>
<span class="line-added">406   // Binary search and insertion utility.  Search array for element</span>
<span class="line-added">407   // matching key according to the static compare function.  Insert</span>
<span class="line-added">408   // that element is not already in the list.  Assumes the list is</span>
<span class="line-added">409   // already sorted according to compare function.</span>
<span class="line-added">410   template &lt;int compare(const E&amp;, const E&amp;)&gt; E insert_sorted(const E&amp; key) {</span>
<span class="line-added">411     bool found;</span>
<span class="line-added">412     int location = GrowableArrayView&lt;E&gt;::template find_sorted&lt;E, compare&gt;(key, found);</span>
<span class="line-added">413     if (!found) {</span>
<span class="line-added">414       insert_before(location, key);</span>
<span class="line-added">415     }</span>
<span class="line-added">416     return this-&gt;at(location);</span>
<span class="line-added">417   }</span>
<span class="line-added">418 </span>
<span class="line-added">419   E insert_sorted(CompareClosure&lt;E&gt;* cc, const E&amp; key) {</span>
<span class="line-added">420     bool found;</span>
<span class="line-added">421     int location = find_sorted(cc, key, found);</span>
<span class="line-added">422     if (!found) {</span>
<span class="line-added">423       insert_before(location, key);</span>
<span class="line-added">424     }</span>
<span class="line-added">425     return this-&gt;at(location);</span>
<span class="line-added">426   }</span>
<span class="line-added">427 </span>
<span class="line-added">428   void clear_and_deallocate();</span>
<span class="line-added">429 };</span>
<span class="line-added">430 </span>
<span class="line-added">431 template &lt;typename E, typename Derived&gt;</span>
<span class="line-added">432 void GrowableArrayWithAllocator&lt;E, Derived&gt;::grow(int j) {</span>
<span class="line-added">433   int old_max = this-&gt;_max;</span>
<span class="line-added">434   // grow the array by increasing _max to the first power of two larger than the size we need</span>
<span class="line-added">435   this-&gt;_max = next_power_of_2((uint32_t)j);</span>
<span class="line-added">436   // j &lt; _max</span>
<span class="line-added">437   E* newData = static_cast&lt;Derived*&gt;(this)-&gt;allocate();</span>
<span class="line-added">438   int i = 0;</span>
<span class="line-added">439   for (     ; i &lt; this-&gt;_len; i++) ::new ((void*)&amp;newData[i]) E(this-&gt;_data[i]);</span>
<span class="line-added">440   for (     ; i &lt; this-&gt;_max; i++) ::new ((void*)&amp;newData[i]) E();</span>
<span class="line-added">441   for (i = 0; i &lt; old_max; i++) this-&gt;_data[i].~E();</span>
<span class="line-added">442   if (this-&gt;_data != NULL) {</span>
<span class="line-added">443     static_cast&lt;Derived*&gt;(this)-&gt;deallocate(this-&gt;_data);</span>
<span class="line-added">444   }</span>
<span class="line-added">445   this-&gt;_data = newData;</span>
446 }
447 
<a name="34" id="anc34"></a><span class="line-modified">448 template &lt;typename E, typename Derived&gt;</span>
<span class="line-modified">449 void GrowableArrayWithAllocator&lt;E, Derived&gt;::clear_and_deallocate() {</span>
<span class="line-modified">450   if (this-&gt;_data != NULL) {</span>
<span class="line-modified">451     for (int i = 0; i &lt; this-&gt;_max; i++) {</span>
<span class="line-modified">452       this-&gt;_data[i].~E();</span>
<span class="line-added">453     }</span>
<span class="line-added">454     static_cast&lt;Derived*&gt;(this)-&gt;deallocate(this-&gt;_data);</span>
<span class="line-added">455     this-&gt;_data = NULL;</span>
<span class="line-added">456   }</span>
<span class="line-added">457   this-&gt;_len = 0;</span>
<span class="line-added">458   this-&gt;_max = 0;</span>
459 }
460 
<a name="35" id="anc35"></a><span class="line-added">461 class GrowableArrayResourceAllocator {</span>
<span class="line-added">462 public:</span>
<span class="line-added">463   static void* allocate(int max, int element_size);</span>
<span class="line-added">464 };</span>
<span class="line-added">465 </span>
<span class="line-added">466 // Arena allocator</span>
<span class="line-added">467 class GrowableArrayArenaAllocator {</span>
<span class="line-added">468 public:</span>
<span class="line-added">469   static void* allocate(int max, int element_size, Arena* arena);</span>
<span class="line-added">470 };</span>
<span class="line-added">471 </span>
<span class="line-added">472 // CHeap allocator</span>
<span class="line-added">473 class GrowableArrayCHeapAllocator {</span>
<span class="line-added">474 public:</span>
<span class="line-added">475   static void* allocate(int max, int element_size, MEMFLAGS memflags);</span>
<span class="line-added">476   static void deallocate(void* mem);</span>
<span class="line-added">477 };</span>
<span class="line-added">478 </span>
<span class="line-added">479 #ifdef ASSERT</span>
<span class="line-added">480 </span>
<span class="line-added">481 // Checks resource allocation nesting</span>
<span class="line-added">482 class GrowableArrayNestingCheck {</span>
<span class="line-added">483   // resource area nesting at creation</span>
<span class="line-added">484   int _nesting;</span>
<span class="line-added">485 </span>
<span class="line-added">486 public:</span>
<span class="line-added">487   GrowableArrayNestingCheck(bool on_stack);</span>
<span class="line-added">488 </span>
<span class="line-added">489   void on_stack_alloc() const;</span>
<span class="line-added">490 };</span>
<span class="line-added">491 </span>
<span class="line-added">492 #endif // ASSERT</span>
<span class="line-added">493 </span>
<span class="line-added">494 // Encodes where the backing array is allocated</span>
<span class="line-added">495 // and performs necessary checks.</span>
<span class="line-added">496 class GrowableArrayMetadata {</span>
<span class="line-added">497   uintptr_t _bits;</span>
<span class="line-added">498 </span>
<span class="line-added">499   // resource area nesting at creation</span>
<span class="line-added">500   debug_only(GrowableArrayNestingCheck _nesting_check;)</span>
<span class="line-added">501 </span>
<span class="line-added">502   uintptr_t bits(MEMFLAGS memflags) const {</span>
<span class="line-added">503     if (memflags == mtNone) {</span>
<span class="line-added">504       // Stack allocation</span>
<span class="line-added">505       return 0;</span>
<span class="line-added">506     }</span>
<span class="line-added">507 </span>
<span class="line-added">508     // CHeap allocation</span>
<span class="line-added">509     return (uintptr_t(memflags) &lt;&lt; 1) | 1;</span>
<span class="line-added">510   }</span>
<span class="line-added">511 </span>
<span class="line-added">512   uintptr_t bits(Arena* arena) const {</span>
<span class="line-added">513     return uintptr_t(arena);</span>
<span class="line-added">514   }</span>
<span class="line-added">515 </span>
<span class="line-added">516 public:</span>
<span class="line-added">517   GrowableArrayMetadata(Arena* arena) :</span>
<span class="line-added">518       _bits(bits(arena))</span>
<span class="line-added">519       debug_only(COMMA _nesting_check(on_stack())) {</span>
<span class="line-added">520   }</span>
<span class="line-added">521 </span>
<span class="line-added">522   GrowableArrayMetadata(MEMFLAGS memflags) :</span>
<span class="line-added">523       _bits(bits(memflags))</span>
<span class="line-added">524       debug_only(COMMA _nesting_check(on_stack())) {</span>
<span class="line-added">525   }</span>
<span class="line-added">526 </span>
<span class="line-added">527 #ifdef ASSERT</span>
<span class="line-added">528   GrowableArrayMetadata(const GrowableArrayMetadata&amp; other) :</span>
<span class="line-added">529       _bits(other._bits),</span>
<span class="line-added">530       _nesting_check(other._nesting_check) {</span>
<span class="line-added">531     assert(!on_C_heap(), &quot;Copying of CHeap arrays not supported&quot;);</span>
<span class="line-added">532     assert(!other.on_C_heap(), &quot;Copying of CHeap arrays not supported&quot;);</span>
<span class="line-added">533   }</span>
<span class="line-added">534 </span>
<span class="line-added">535   GrowableArrayMetadata&amp; operator=(const GrowableArrayMetadata&amp; other) {</span>
<span class="line-added">536     _bits = other._bits;</span>
<span class="line-added">537     _nesting_check = other._nesting_check;</span>
<span class="line-added">538     assert(!on_C_heap(), &quot;Assignment of CHeap arrays not supported&quot;);</span>
<span class="line-added">539     assert(!other.on_C_heap(), &quot;Assignment of CHeap arrays not supported&quot;);</span>
<span class="line-added">540     return *this;</span>
<span class="line-added">541   }</span>
<span class="line-added">542 </span>
<span class="line-added">543   void init_checks(const GrowableArrayBase* array) const;</span>
<span class="line-added">544   void on_stack_alloc_check() const;</span>
<span class="line-added">545 #endif // ASSERT</span>
<span class="line-added">546 </span>
<span class="line-added">547   bool on_C_heap() const { return (_bits &amp; 1) == 1; }</span>
<span class="line-added">548   bool on_stack () const { return _bits == 0;      }</span>
<span class="line-added">549   bool on_arena () const { return (_bits &amp; 1) == 0 &amp;&amp; _bits != 0; }</span>
<span class="line-added">550 </span>
<span class="line-added">551   Arena* arena() const      { return (Arena*)_bits; }</span>
<span class="line-added">552   MEMFLAGS memflags() const { return MEMFLAGS(_bits &gt;&gt; 1); }</span>
<span class="line-added">553 };</span>
<span class="line-added">554 </span>
<span class="line-added">555 // THE GrowableArray.</span>
<span class="line-added">556 //</span>
<span class="line-added">557 // Supports multiple allocation strategies:</span>
<span class="line-added">558 //  - Resource stack allocation: if memflags == mtNone</span>
<span class="line-added">559 //  - CHeap allocation: if memflags != mtNone</span>
<span class="line-added">560 //  - Arena allocation: if an arena is provided</span>
<span class="line-added">561 //</span>
<span class="line-added">562 // There are some drawbacks of using GrowableArray, that are removed in some</span>
<span class="line-added">563 // of the other implementations of GrowableArrayWithAllocator sub-classes:</span>
<span class="line-added">564 //</span>
<span class="line-added">565 // Memory overhead: The multiple allocation strategies uses extra metadata</span>
<span class="line-added">566 //  embedded in the instance.</span>
<span class="line-added">567 //</span>
<span class="line-added">568 // Strict allocation locations: There are rules about where the GrowableArray</span>
<span class="line-added">569 //  instance is allocated, that depends on where the data array is allocated.</span>
<span class="line-added">570 //  See: init_checks.</span>
<span class="line-added">571 </span>
<span class="line-added">572 template &lt;typename E&gt;</span>
<span class="line-added">573 class GrowableArray : public GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt; {</span>
<span class="line-added">574   friend class GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;;</span>
<span class="line-added">575   friend class GrowableArrayTest;</span>
<span class="line-added">576 </span>
<span class="line-added">577   static E* allocate(int max) {</span>
<span class="line-added">578     return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));</span>
<span class="line-added">579   }</span>
<span class="line-added">580 </span>
<span class="line-added">581   static E* allocate(int max, MEMFLAGS memflags) {</span>
<span class="line-added">582     if (memflags != mtNone) {</span>
<span class="line-added">583       return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);</span>
<span class="line-added">584     }</span>
<span class="line-added">585 </span>
<span class="line-added">586     return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));</span>
<span class="line-added">587   }</span>
<span class="line-added">588 </span>
<span class="line-added">589   static E* allocate(int max, Arena* arena) {</span>
<span class="line-added">590     return (E*)GrowableArrayArenaAllocator::allocate(max, sizeof(E), arena);</span>
<span class="line-added">591   }</span>
<span class="line-added">592 </span>
<span class="line-added">593   GrowableArrayMetadata _metadata;</span>
<span class="line-added">594 </span>
<span class="line-added">595   void init_checks() const { debug_only(_metadata.init_checks(this);) }</span>
<span class="line-added">596 </span>
<span class="line-added">597   // Where are we going to allocate memory?</span>
<span class="line-added">598   bool on_C_heap() const { return _metadata.on_C_heap(); }</span>
<span class="line-added">599   bool on_stack () const { return _metadata.on_stack(); }</span>
<span class="line-added">600   bool on_arena () const { return _metadata.on_arena(); }</span>
<span class="line-added">601 </span>
<span class="line-added">602   E* allocate() {</span>
<span class="line-added">603     if (on_stack()) {</span>
<span class="line-added">604       debug_only(_metadata.on_stack_alloc_check());</span>
<span class="line-added">605       return allocate(this-&gt;_max);</span>
<span class="line-added">606     }</span>
<span class="line-added">607 </span>
<span class="line-added">608     if (on_C_heap()) {</span>
<span class="line-added">609       return allocate(this-&gt;_max, _metadata.memflags());</span>
<span class="line-added">610     }</span>
<span class="line-added">611 </span>
<span class="line-added">612     assert(on_arena(), &quot;Sanity&quot;);</span>
<span class="line-added">613     return allocate(this-&gt;_max, _metadata.arena());</span>
<span class="line-added">614   }</span>
<span class="line-added">615 </span>
<span class="line-added">616   void deallocate(E* mem) {</span>
<span class="line-added">617     if (on_C_heap()) {</span>
<span class="line-added">618       GrowableArrayCHeapAllocator::deallocate(mem);</span>
<span class="line-added">619     }</span>
<span class="line-added">620   }</span>
<span class="line-added">621 </span>
<span class="line-added">622 public:</span>
<span class="line-added">623   GrowableArray(int initial_max = 2, MEMFLAGS memflags = mtNone) :</span>
<span class="line-added">624       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="line-added">625           allocate(initial_max, memflags),</span>
<span class="line-added">626           initial_max),</span>
<span class="line-added">627       _metadata(memflags) {</span>
<span class="line-added">628     init_checks();</span>
<span class="line-added">629   }</span>
<span class="line-added">630 </span>
<span class="line-added">631   GrowableArray(int initial_max, int initial_len, const E&amp; filler, MEMFLAGS memflags = mtNone) :</span>
<span class="line-added">632       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="line-added">633           allocate(initial_max, memflags),</span>
<span class="line-added">634           initial_max, initial_len, filler),</span>
<span class="line-added">635       _metadata(memflags) {</span>
<span class="line-added">636     init_checks();</span>
<span class="line-added">637   }</span>
<span class="line-added">638 </span>
<span class="line-added">639   GrowableArray(Arena* arena, int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="line-added">640       GrowableArrayWithAllocator&lt;E, GrowableArray&lt;E&gt; &gt;(</span>
<span class="line-added">641           allocate(initial_max, arena),</span>
<span class="line-added">642           initial_max, initial_len, filler),</span>
<span class="line-added">643       _metadata(arena) {</span>
<span class="line-added">644     init_checks();</span>
<span class="line-added">645   }</span>
<span class="line-added">646 </span>
<span class="line-added">647   ~GrowableArray() {</span>
<span class="line-added">648     if (on_C_heap()) {</span>
<span class="line-added">649       this-&gt;clear_and_deallocate();</span>
<span class="line-added">650     }</span>
<span class="line-added">651   }</span>
<span class="line-added">652 };</span>
<span class="line-added">653 </span>
<span class="line-added">654 // Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MEMFLAGS.</span>
<span class="line-added">655 template &lt;typename E, MEMFLAGS F&gt;</span>
<span class="line-added">656 class GrowableArrayCHeap : public GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt; {</span>
<span class="line-added">657   friend class GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;;</span>
<span class="line-added">658 </span>
<span class="line-added">659   STATIC_ASSERT(F != mtNone);</span>
<span class="line-added">660 </span>
<span class="line-added">661   static E* allocate(int max, MEMFLAGS flags) {</span>
<span class="line-added">662     if (max == 0) {</span>
<span class="line-added">663       return NULL;</span>
<span class="line-added">664     }</span>
<span class="line-added">665 </span>
<span class="line-added">666     return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), flags);</span>
<span class="line-added">667   }</span>
<span class="line-added">668 </span>
<span class="line-added">669   NONCOPYABLE(GrowableArrayCHeap);</span>
<span class="line-added">670 </span>
<span class="line-added">671   E* allocate() {</span>
<span class="line-added">672     return allocate(this-&gt;_max, F);</span>
<span class="line-added">673   }</span>
<span class="line-added">674 </span>
<span class="line-added">675   void deallocate(E* mem) {</span>
<span class="line-added">676     GrowableArrayCHeapAllocator::deallocate(mem);</span>
<span class="line-added">677   }</span>
<span class="line-added">678 </span>
<span class="line-added">679 public:</span>
<span class="line-added">680   GrowableArrayCHeap(int initial_max) :</span>
<span class="line-added">681       GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;(</span>
<span class="line-added">682           allocate(initial_max, F),</span>
<span class="line-added">683           initial_max) {}</span>
<span class="line-added">684 </span>
<span class="line-added">685   GrowableArrayCHeap(int initial_max, int initial_len, const E&amp; filler) :</span>
<span class="line-added">686       GrowableArrayWithAllocator&lt;E, GrowableArrayCHeap&lt;E, F&gt; &gt;(</span>
<span class="line-added">687           allocate(initial_max, F),</span>
<span class="line-added">688           initial_max, initial_len, filler) {}</span>
<span class="line-added">689 </span>
<span class="line-added">690   ~GrowableArrayCHeap() {</span>
<span class="line-added">691     this-&gt;clear_and_deallocate();</span>
<span class="line-added">692   }</span>
<span class="line-added">693 </span>
<span class="line-added">694   void* operator new(size_t size) throw() {</span>
<span class="line-added">695     return ResourceObj::operator new(size, ResourceObj::C_HEAP, F);</span>
<span class="line-added">696   }</span>
<span class="line-added">697 </span>
<span class="line-added">698   void* operator new(size_t size, const std::nothrow_t&amp;  nothrow_constant) throw() {</span>
<span class="line-added">699     return ResourceObj::operator new(size, nothrow_constant, ResourceObj::C_HEAP, F);</span>
<span class="line-added">700   }</span>
<span class="line-added">701 };</span>
<span class="line-added">702 </span>
703 // Custom STL-style iterator to iterate over GrowableArrays
704 // It is constructed by invoking GrowableArray::begin() and GrowableArray::end()
<a name="36" id="anc36"></a><span class="line-modified">705 template &lt;typename E&gt;</span>
<span class="line-modified">706 class GrowableArrayIterator : public StackObj {</span>
<span class="line-modified">707   friend class GrowableArrayView&lt;E&gt;;</span>
<span class="line-added">708   template &lt;typename F, typename UnaryPredicate&gt; friend class GrowableArrayFilterIterator;</span>
709 
710  private:
<a name="37" id="anc37"></a><span class="line-modified">711   const GrowableArrayView&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="line-modified">712   int _position;                      // The current position in the GrowableArray</span>
713 
714   // Private constructor used in GrowableArray::begin() and GrowableArray::end()
<a name="38" id="anc38"></a><span class="line-modified">715   GrowableArrayIterator(const GrowableArrayView&lt;E&gt;* array, int position) : _array(array), _position(position) {</span>
716     assert(0 &lt;= position &amp;&amp; position &lt;= _array-&gt;length(), &quot;illegal position&quot;);
717   }
718 
719  public:
720   GrowableArrayIterator() : _array(NULL), _position(0) { }
<a name="39" id="anc39"></a><span class="line-modified">721   GrowableArrayIterator&lt;E&gt;&amp; operator++() { ++_position; return *this; }</span>
<span class="line-modified">722   E operator*()                          { return _array-&gt;at(_position); }</span>
723 
724   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
725     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
726     return _position == rhs._position;
727   }
728 
729   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
730     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
731     return _position != rhs._position;
732   }
733 };
734 
735 // Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate
<a name="40" id="anc40"></a><span class="line-modified">736 template &lt;typename E, class UnaryPredicate&gt;</span>
<span class="line-modified">737 class GrowableArrayFilterIterator : public StackObj {</span>
<span class="line-added">738   friend class GrowableArrayView&lt;E&gt;;</span>
739 
740  private:
<a name="41" id="anc41"></a><span class="line-modified">741   const GrowableArrayView&lt;E&gt;* _array; // GrowableArray we iterate over</span>
<span class="line-modified">742   int _position;                      // Current position in the GrowableArray</span>
<span class="line-modified">743   UnaryPredicate _predicate;          // Unary predicate the elements of the GrowableArray should satisfy</span>
744 
745  public:
<a name="42" id="anc42"></a><span class="line-modified">746   GrowableArrayFilterIterator(const GrowableArrayIterator&lt;E&gt;&amp; begin, UnaryPredicate filter_predicate) :</span>
<span class="line-modified">747       _array(begin._array), _position(begin._position), _predicate(filter_predicate) {</span>
748     // Advance to first element satisfying the predicate
749     while(_position != _array-&gt;length() &amp;&amp; !_predicate(_array-&gt;at(_position))) {
750       ++_position;
751     }
752   }
753 
754   GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; operator++() {
755     do {
756       // Advance to next element satisfying the predicate
757       ++_position;
758     } while(_position != _array-&gt;length() &amp;&amp; !_predicate(_array-&gt;at(_position)));
759     return *this;
760   }
761 
<a name="43" id="anc43"></a><span class="line-modified">762   E operator*() { return _array-&gt;at(_position); }</span>
763 
764   bool operator==(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
765     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
766     return _position == rhs._position;
767   }
768 
769   bool operator!=(const GrowableArrayIterator&lt;E&gt;&amp; rhs)  {
770     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
771     return _position != rhs._position;
772   }
773 
774   bool operator==(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
775     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
776     return _position == rhs._position;
777   }
778 
779   bool operator!=(const GrowableArrayFilterIterator&lt;E, UnaryPredicate&gt;&amp; rhs)  {
780     assert(_array == rhs._array, &quot;iterator belongs to different array&quot;);
781     return _position != rhs._position;
782   }
783 };
784 
785 // Arrays for basic types
786 typedef GrowableArray&lt;int&gt; intArray;
787 typedef GrowableArray&lt;int&gt; intStack;
788 typedef GrowableArray&lt;bool&gt; boolArray;
789 
790 #endif // SHARE_UTILITIES_GROWABLEARRAY_HPP
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>
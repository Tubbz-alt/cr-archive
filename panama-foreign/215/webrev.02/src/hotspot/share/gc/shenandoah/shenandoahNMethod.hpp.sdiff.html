<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 56   void update();
 57 
 58   bool has_cset_oops(ShenandoahHeap* heap);
 59 
 60   inline int oop_count() const;
 61   inline bool has_oops() const;
 62 
 63   inline void mark_unregistered();
 64   inline bool is_unregistered() const;
 65 
 66   static ShenandoahNMethod* for_nmethod(nmethod* nm);
 67   static inline ShenandoahReentrantLock* lock_for_nmethod(nmethod* nm);
 68 
 69   static void heal_nmethod(nmethod* nm);
 70   static inline void heal_nmethod_metadata(ShenandoahNMethod* nmethod_data);
 71   static inline void disarm_nmethod(nmethod* nm);
 72 
 73   static inline ShenandoahNMethod* gc_data(nmethod* nm);
 74   static inline void attach_gc_data(nmethod* nm, ShenandoahNMethod* gc_data);
 75 
<span class="line-modified"> 76   void assert_alive_and_correct() NOT_DEBUG_RETURN;</span>
 77   void assert_same_oops(bool allow_dead = false) NOT_DEBUG_RETURN;
 78   static void assert_no_oops(nmethod* nm, bool allow_dea = false) NOT_DEBUG_RETURN;
 79 
 80 private:
 81   bool has_non_immed_oops() const { return _has_non_immed_oops; }
 82   static void detect_reloc_oops(nmethod* nm, GrowableArray&lt;oop*&gt;&amp; oops, bool&amp; _has_non_immed_oops);
 83 };
 84 
 85 class ShenandoahNMethodTable;
 86 
 87 // ShenandoahNMethodList holds registered nmethod data. The list is reference counted.
 88 class ShenandoahNMethodList : public CHeapObj&lt;mtGC&gt; {
 89 private:
 90   ShenandoahNMethod** _list;
 91   const int           _size;
 92   uint                _ref_count;
 93 
 94 private:
 95   ~ShenandoahNMethodList();
 96 
</pre>
<hr />
<pre>
143 
144   int                    _index;
145   ShenandoahLock         _lock;
146   int                    _itr_cnt;
147 
148 public:
149   ShenandoahNMethodTable();
150   ~ShenandoahNMethodTable();
151 
152   void register_nmethod(nmethod* nm);
153   void unregister_nmethod(nmethod* nm);
154   void flush_nmethod(nmethod* nm);
155 
156   bool contain(nmethod* nm) const;
157   int length() const { return _index; }
158 
159   // Table iteration support
160   ShenandoahNMethodTableSnapshot* snapshot_for_iteration();
161   void finish_iteration(ShenandoahNMethodTableSnapshot* snapshot);
162 
<span class="line-modified">163   void assert_nmethods_alive_and_correct() NOT_DEBUG_RETURN;</span>
164 private:
165   // Rebuild table and replace current one
166   void rebuild(int size);
167 
168   bool is_full() const {
169     assert(_index &lt;= _list-&gt;size(), &quot;Sanity&quot;);
170     return _index == _list-&gt;size();
171   }
172 
173   ShenandoahNMethod* at(int index) const;
174   int  index_of(nmethod* nm) const;
175   void remove(int index);
176   void append(ShenandoahNMethod* snm);
177 
178   inline bool iteration_in_progress() const;
179   void wait_until_concurrent_iteration_done();
180 
181   // Logging support
182   void log_register_nmethod(nmethod* nm);
183   void log_unregister_nmethod(nmethod* nm);
</pre>
</td>
<td>
<hr />
<pre>
 56   void update();
 57 
 58   bool has_cset_oops(ShenandoahHeap* heap);
 59 
 60   inline int oop_count() const;
 61   inline bool has_oops() const;
 62 
 63   inline void mark_unregistered();
 64   inline bool is_unregistered() const;
 65 
 66   static ShenandoahNMethod* for_nmethod(nmethod* nm);
 67   static inline ShenandoahReentrantLock* lock_for_nmethod(nmethod* nm);
 68 
 69   static void heal_nmethod(nmethod* nm);
 70   static inline void heal_nmethod_metadata(ShenandoahNMethod* nmethod_data);
 71   static inline void disarm_nmethod(nmethod* nm);
 72 
 73   static inline ShenandoahNMethod* gc_data(nmethod* nm);
 74   static inline void attach_gc_data(nmethod* nm, ShenandoahNMethod* gc_data);
 75 
<span class="line-modified"> 76   void assert_correct() NOT_DEBUG_RETURN;</span>
 77   void assert_same_oops(bool allow_dead = false) NOT_DEBUG_RETURN;
 78   static void assert_no_oops(nmethod* nm, bool allow_dea = false) NOT_DEBUG_RETURN;
 79 
 80 private:
 81   bool has_non_immed_oops() const { return _has_non_immed_oops; }
 82   static void detect_reloc_oops(nmethod* nm, GrowableArray&lt;oop*&gt;&amp; oops, bool&amp; _has_non_immed_oops);
 83 };
 84 
 85 class ShenandoahNMethodTable;
 86 
 87 // ShenandoahNMethodList holds registered nmethod data. The list is reference counted.
 88 class ShenandoahNMethodList : public CHeapObj&lt;mtGC&gt; {
 89 private:
 90   ShenandoahNMethod** _list;
 91   const int           _size;
 92   uint                _ref_count;
 93 
 94 private:
 95   ~ShenandoahNMethodList();
 96 
</pre>
<hr />
<pre>
143 
144   int                    _index;
145   ShenandoahLock         _lock;
146   int                    _itr_cnt;
147 
148 public:
149   ShenandoahNMethodTable();
150   ~ShenandoahNMethodTable();
151 
152   void register_nmethod(nmethod* nm);
153   void unregister_nmethod(nmethod* nm);
154   void flush_nmethod(nmethod* nm);
155 
156   bool contain(nmethod* nm) const;
157   int length() const { return _index; }
158 
159   // Table iteration support
160   ShenandoahNMethodTableSnapshot* snapshot_for_iteration();
161   void finish_iteration(ShenandoahNMethodTableSnapshot* snapshot);
162 
<span class="line-modified">163   void assert_nmethods_correct() NOT_DEBUG_RETURN;</span>
164 private:
165   // Rebuild table and replace current one
166   void rebuild(int size);
167 
168   bool is_full() const {
169     assert(_index &lt;= _list-&gt;size(), &quot;Sanity&quot;);
170     return _index == _list-&gt;size();
171   }
172 
173   ShenandoahNMethod* at(int index) const;
174   int  index_of(nmethod* nm) const;
175   void remove(int index);
176   void append(ShenandoahNMethod* snm);
177 
178   inline bool iteration_in_progress() const;
179   void wait_until_concurrent_iteration_done();
180 
181   // Logging support
182   void log_register_nmethod(nmethod* nm);
183   void log_unregister_nmethod(nmethod* nm);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahNMethod.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../shared/oopStorageSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 101 
 102     // a1. Cancel evacuation, if in progress
 103     if (heap-&gt;is_evacuation_in_progress()) {
 104       heap-&gt;set_evacuation_in_progress(false);
 105     }
 106     assert(!heap-&gt;is_evacuation_in_progress(), &quot;sanity&quot;);
 107 
 108     // a2. Cancel update-refs, if in progress
 109     if (heap-&gt;is_update_refs_in_progress()) {
 110       heap-&gt;set_update_refs_in_progress(false);
 111     }
 112     assert(!heap-&gt;is_update_refs_in_progress(), &quot;sanity&quot;);
 113 
 114     // b. Cancel concurrent mark, if in progress
 115     if (heap-&gt;is_concurrent_mark_in_progress()) {
 116       heap-&gt;concurrent_mark()-&gt;cancel();
 117       heap-&gt;set_concurrent_mark_in_progress(false);
 118     }
 119     assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
 120 
<span class="line-modified"> 121     // c. Reset the bitmaps for new marking</span>





 122     heap-&gt;reset_mark_bitmap();
 123     assert(heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;sanity&quot;);
 124     assert(!heap-&gt;marking_context()-&gt;is_complete(), &quot;sanity&quot;);
 125 
<span class="line-modified"> 126     // d. Abandon reference discovery and clear all discovered references.</span>
 127     ReferenceProcessor* rp = heap-&gt;ref_processor();
 128     rp-&gt;disable_discovery();
 129     rp-&gt;abandon_partial_discovery();
 130     rp-&gt;verify_no_references_recorded();
 131 
<span class="line-modified"> 132     // e. Set back forwarded objects bit back, in case some steps above dropped it.</span>
 133     heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
 134 
<span class="line-modified"> 135     // f. Sync pinned region status from the CP marks</span>
 136     heap-&gt;sync_pinned_region_status();
 137 
 138     // The rest of prologue:
 139     BiasedLocking::preserve_marks();
 140     _preserved_marks-&gt;init(heap-&gt;workers()-&gt;active_workers());
 141   }
 142 
 143   heap-&gt;make_parsable(true);
 144 
 145   OrderAccess::fence();
 146 
 147   phase1_mark_heap();
 148 
 149   // Once marking is done, which may have fixed up forwarded objects, we can drop it.
 150   // Coming out of Full GC, we would not have any forwarded objects.
 151   // This also prevents resolves with fwdptr from kicking in while adjusting pointers in phase3.
 152   heap-&gt;set_has_forwarded_objects(false);
 153 
 154   heap-&gt;set_full_gc_move_in_progress(true);
 155 
</pre>
<hr />
<pre>
 225 void ShenandoahMarkCompact::phase1_mark_heap() {
 226   GCTraceTime(Info, gc, phases) time(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
 227   ShenandoahGCPhase mark_phase(ShenandoahPhaseTimings::full_gc_mark);
 228 
 229   ShenandoahHeap* heap = ShenandoahHeap::heap();
 230 
 231   ShenandoahPrepareForMarkClosure cl;
 232   heap-&gt;heap_region_iterate(&amp;cl);
 233 
 234   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
 235 
 236   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
 237   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
 238 
 239   ReferenceProcessor* rp = heap-&gt;ref_processor();
 240   // enable (&quot;weak&quot;) refs discovery
 241   rp-&gt;enable_discovery(true /*verify_no_refs*/);
 242   rp-&gt;setup_policy(true); // forcefully purge all soft references
 243   rp-&gt;set_active_mt_degree(heap-&gt;workers()-&gt;active_workers());
 244 
<span class="line-removed"> 245   cm-&gt;update_roots(ShenandoahPhaseTimings::full_gc_update_roots);</span>
 246   cm-&gt;mark_roots(ShenandoahPhaseTimings::full_gc_scan_roots);
 247   cm-&gt;finish_mark_from_roots(/* full_gc = */ true);
 248   heap-&gt;mark_complete_marking_context();
 249   heap-&gt;parallel_cleaning(true /* full_gc */);
 250 }
 251 
 252 class ShenandoahPrepareForCompactionObjectClosure : public ObjectClosure {
 253 private:
 254   PreservedMarks*          const _preserved_marks;
 255   ShenandoahHeap*          const _heap;
 256   GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; _empty_regions;
 257   int _empty_regions_pos;
 258   ShenandoahHeapRegion*          _to_region;
 259   ShenandoahHeapRegion*          _from_region;
 260   HeapWord* _compact_point;
 261 
 262 public:
 263   ShenandoahPrepareForCompactionObjectClosure(PreservedMarks* preserved_marks,
 264                                               GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; empty_regions,
 265                                               ShenandoahHeapRegion* to_region) :
</pre>
</td>
<td>
<hr />
<pre>
 101 
 102     // a1. Cancel evacuation, if in progress
 103     if (heap-&gt;is_evacuation_in_progress()) {
 104       heap-&gt;set_evacuation_in_progress(false);
 105     }
 106     assert(!heap-&gt;is_evacuation_in_progress(), &quot;sanity&quot;);
 107 
 108     // a2. Cancel update-refs, if in progress
 109     if (heap-&gt;is_update_refs_in_progress()) {
 110       heap-&gt;set_update_refs_in_progress(false);
 111     }
 112     assert(!heap-&gt;is_update_refs_in_progress(), &quot;sanity&quot;);
 113 
 114     // b. Cancel concurrent mark, if in progress
 115     if (heap-&gt;is_concurrent_mark_in_progress()) {
 116       heap-&gt;concurrent_mark()-&gt;cancel();
 117       heap-&gt;set_concurrent_mark_in_progress(false);
 118     }
 119     assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
 120 
<span class="line-modified"> 121     // c. Update roots if this full GC is due to evac-oom, which may carry from-space pointers in roots.</span>
<span class="line-added"> 122     if (has_forwarded_objects) {</span>
<span class="line-added"> 123       heap-&gt;concurrent_mark()-&gt;update_roots(ShenandoahPhaseTimings::full_gc_update_roots);</span>
<span class="line-added"> 124     }</span>
<span class="line-added"> 125 </span>
<span class="line-added"> 126     // d. Reset the bitmaps for new marking</span>
 127     heap-&gt;reset_mark_bitmap();
 128     assert(heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;sanity&quot;);
 129     assert(!heap-&gt;marking_context()-&gt;is_complete(), &quot;sanity&quot;);
 130 
<span class="line-modified"> 131     // e. Abandon reference discovery and clear all discovered references.</span>
 132     ReferenceProcessor* rp = heap-&gt;ref_processor();
 133     rp-&gt;disable_discovery();
 134     rp-&gt;abandon_partial_discovery();
 135     rp-&gt;verify_no_references_recorded();
 136 
<span class="line-modified"> 137     // f. Set back forwarded objects bit back, in case some steps above dropped it.</span>
 138     heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
 139 
<span class="line-modified"> 140     // g. Sync pinned region status from the CP marks</span>
 141     heap-&gt;sync_pinned_region_status();
 142 
 143     // The rest of prologue:
 144     BiasedLocking::preserve_marks();
 145     _preserved_marks-&gt;init(heap-&gt;workers()-&gt;active_workers());
 146   }
 147 
 148   heap-&gt;make_parsable(true);
 149 
 150   OrderAccess::fence();
 151 
 152   phase1_mark_heap();
 153 
 154   // Once marking is done, which may have fixed up forwarded objects, we can drop it.
 155   // Coming out of Full GC, we would not have any forwarded objects.
 156   // This also prevents resolves with fwdptr from kicking in while adjusting pointers in phase3.
 157   heap-&gt;set_has_forwarded_objects(false);
 158 
 159   heap-&gt;set_full_gc_move_in_progress(true);
 160 
</pre>
<hr />
<pre>
 230 void ShenandoahMarkCompact::phase1_mark_heap() {
 231   GCTraceTime(Info, gc, phases) time(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
 232   ShenandoahGCPhase mark_phase(ShenandoahPhaseTimings::full_gc_mark);
 233 
 234   ShenandoahHeap* heap = ShenandoahHeap::heap();
 235 
 236   ShenandoahPrepareForMarkClosure cl;
 237   heap-&gt;heap_region_iterate(&amp;cl);
 238 
 239   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
 240 
 241   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
 242   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
 243 
 244   ReferenceProcessor* rp = heap-&gt;ref_processor();
 245   // enable (&quot;weak&quot;) refs discovery
 246   rp-&gt;enable_discovery(true /*verify_no_refs*/);
 247   rp-&gt;setup_policy(true); // forcefully purge all soft references
 248   rp-&gt;set_active_mt_degree(heap-&gt;workers()-&gt;active_workers());
 249 

 250   cm-&gt;mark_roots(ShenandoahPhaseTimings::full_gc_scan_roots);
 251   cm-&gt;finish_mark_from_roots(/* full_gc = */ true);
 252   heap-&gt;mark_complete_marking_context();
 253   heap-&gt;parallel_cleaning(true /* full_gc */);
 254 }
 255 
 256 class ShenandoahPrepareForCompactionObjectClosure : public ObjectClosure {
 257 private:
 258   PreservedMarks*          const _preserved_marks;
 259   ShenandoahHeap*          const _heap;
 260   GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; _empty_regions;
 261   int _empty_regions_pos;
 262   ShenandoahHeapRegion*          _to_region;
 263   ShenandoahHeapRegion*          _from_region;
 264   HeapWord* _compact_point;
 265 
 266 public:
 267   ShenandoahPrepareForCompactionObjectClosure(PreservedMarks* preserved_marks,
 268                                               GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; empty_regions,
 269                                               ShenandoahHeapRegion* to_region) :
</pre>
</td>
</tr>
</table>
<center><a href="../shared/oopStorageSet.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahNMethod.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
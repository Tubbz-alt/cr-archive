<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  29 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  35 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  36 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  37 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
  39 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  43 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  47 #include &quot;gc/shenandoah/heuristics/shenandoahHeuristics.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/compressedOops.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;runtime/biasedLocking.hpp&quot;
  53 #include &quot;runtime/orderAccess.hpp&quot;
  54 #include &quot;runtime/thread.hpp&quot;
  55 #include &quot;utilities/copy.hpp&quot;
  56 #include &quot;utilities/growableArray.hpp&quot;
  57 #include &quot;gc/shared/workgroup.hpp&quot;
  58 
  59 ShenandoahMarkCompact::ShenandoahMarkCompact() :
  60   _gc_timer(NULL),
  61   _preserved_marks(new PreservedMarksSet(true)) {}
  62 
  63 void ShenandoahMarkCompact::initialize(GCTimer* gc_timer) {
  64   _gc_timer = gc_timer;
  65 }
  66 
  67 void ShenandoahMarkCompact::do_it(GCCause::Cause gc_cause) {
  68   ShenandoahHeap* heap = ShenandoahHeap::heap();
  69 
  70   if (ShenandoahVerify) {
  71     heap-&gt;verifier()-&gt;verify_before_fullgc();
  72   }
  73 
  74   if (VerifyBeforeGC) {
  75     Universe::verify();
  76   }
  77 
  78   // Degenerated GC may carry concurrent root flags when upgrading to
  79   // full GC. We need to reset it before mutators resume.
  80   if (ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {
  81     heap-&gt;set_concurrent_strong_root_in_progress(false);
  82     heap-&gt;set_concurrent_weak_root_in_progress(false);
  83   }
  84 
  85   heap-&gt;set_full_gc_in_progress(true);
  86 
  87   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;must be at a safepoint&quot;);
  88   assert(Thread::current()-&gt;is_VM_thread(), &quot;Do full GC only while world is stopped&quot;);
  89 
  90   {
  91     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdump_pre);
  92     heap-&gt;pre_full_gc_dump(_gc_timer);
  93   }
  94 
  95   {
  96     ShenandoahGCPhase prepare_phase(ShenandoahPhaseTimings::full_gc_prepare);
  97     // Full GC is supposed to recover from any GC state:
  98 
  99     // a0. Remember if we have forwarded objects
 100     bool has_forwarded_objects = heap-&gt;has_forwarded_objects();
 101 
 102     // a1. Cancel evacuation, if in progress
 103     if (heap-&gt;is_evacuation_in_progress()) {
 104       heap-&gt;set_evacuation_in_progress(false);
 105     }
 106     assert(!heap-&gt;is_evacuation_in_progress(), &quot;sanity&quot;);
 107 
 108     // a2. Cancel update-refs, if in progress
 109     if (heap-&gt;is_update_refs_in_progress()) {
 110       heap-&gt;set_update_refs_in_progress(false);
 111     }
 112     assert(!heap-&gt;is_update_refs_in_progress(), &quot;sanity&quot;);
 113 
 114     // b. Cancel concurrent mark, if in progress
 115     if (heap-&gt;is_concurrent_mark_in_progress()) {
 116       heap-&gt;concurrent_mark()-&gt;cancel();
 117       heap-&gt;set_concurrent_mark_in_progress(false);
 118     }
 119     assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
 120 
<a name="1" id="anc1"></a><span class="line-modified"> 121     // c. Reset the bitmaps for new marking</span>





 122     heap-&gt;reset_mark_bitmap();
 123     assert(heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;sanity&quot;);
 124     assert(!heap-&gt;marking_context()-&gt;is_complete(), &quot;sanity&quot;);
 125 
<a name="2" id="anc2"></a><span class="line-modified"> 126     // d. Abandon reference discovery and clear all discovered references.</span>
 127     ReferenceProcessor* rp = heap-&gt;ref_processor();
 128     rp-&gt;disable_discovery();
 129     rp-&gt;abandon_partial_discovery();
 130     rp-&gt;verify_no_references_recorded();
 131 
<a name="3" id="anc3"></a><span class="line-modified"> 132     // e. Set back forwarded objects bit back, in case some steps above dropped it.</span>
 133     heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
 134 
<a name="4" id="anc4"></a><span class="line-modified"> 135     // f. Sync pinned region status from the CP marks</span>
 136     heap-&gt;sync_pinned_region_status();
 137 
 138     // The rest of prologue:
 139     BiasedLocking::preserve_marks();
 140     _preserved_marks-&gt;init(heap-&gt;workers()-&gt;active_workers());
 141   }
 142 
 143   heap-&gt;make_parsable(true);
 144 
 145   OrderAccess::fence();
 146 
 147   phase1_mark_heap();
 148 
 149   // Once marking is done, which may have fixed up forwarded objects, we can drop it.
 150   // Coming out of Full GC, we would not have any forwarded objects.
 151   // This also prevents resolves with fwdptr from kicking in while adjusting pointers in phase3.
 152   heap-&gt;set_has_forwarded_objects(false);
 153 
 154   heap-&gt;set_full_gc_move_in_progress(true);
 155 
 156   // Setup workers for the rest
 157   OrderAccess::fence();
 158 
 159   // Initialize worker slices
 160   ShenandoahHeapRegionSet** worker_slices = NEW_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, heap-&gt;max_workers(), mtGC);
 161   for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
 162     worker_slices[i] = new ShenandoahHeapRegionSet();
 163   }
 164 
 165   {
 166     // The rest of code performs region moves, where region status is undefined
 167     // until all phases run together.
 168     ShenandoahHeapLocker lock(heap-&gt;lock());
 169 
 170     phase2_calculate_target_addresses(worker_slices);
 171 
 172     OrderAccess::fence();
 173 
 174     phase3_update_references();
 175 
 176     phase4_compact_objects(worker_slices);
 177   }
 178 
 179   {
 180     // Epilogue
 181     _preserved_marks-&gt;restore(heap-&gt;workers());
 182     BiasedLocking::restore_marks();
 183     _preserved_marks-&gt;reclaim();
 184   }
 185 
 186   // Resize metaspace
 187   MetaspaceGC::compute_new_size();
 188 
 189   // Free worker slices
 190   for (uint i = 0; i &lt; heap-&gt;max_workers(); i++) {
 191     delete worker_slices[i];
 192   }
 193   FREE_C_HEAP_ARRAY(ShenandoahHeapRegionSet*, worker_slices);
 194 
 195   heap-&gt;set_full_gc_move_in_progress(false);
 196   heap-&gt;set_full_gc_in_progress(false);
 197 
 198   if (ShenandoahVerify) {
 199     heap-&gt;verifier()-&gt;verify_after_fullgc();
 200   }
 201 
 202   if (VerifyAfterGC) {
 203     Universe::verify();
 204   }
 205 
 206   {
 207     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdump_post);
 208     heap-&gt;post_full_gc_dump(_gc_timer);
 209   }
 210 }
 211 
 212 class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {
 213 private:
 214   ShenandoahMarkingContext* const _ctx;
 215 
 216 public:
 217   ShenandoahPrepareForMarkClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
 218 
 219   void heap_region_do(ShenandoahHeapRegion *r) {
 220     _ctx-&gt;capture_top_at_mark_start(r);
 221     r-&gt;clear_live_data();
 222   }
 223 };
 224 
 225 void ShenandoahMarkCompact::phase1_mark_heap() {
 226   GCTraceTime(Info, gc, phases) time(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
 227   ShenandoahGCPhase mark_phase(ShenandoahPhaseTimings::full_gc_mark);
 228 
 229   ShenandoahHeap* heap = ShenandoahHeap::heap();
 230 
 231   ShenandoahPrepareForMarkClosure cl;
 232   heap-&gt;heap_region_iterate(&amp;cl);
 233 
 234   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
 235 
 236   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
 237   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
 238 
 239   ReferenceProcessor* rp = heap-&gt;ref_processor();
 240   // enable (&quot;weak&quot;) refs discovery
 241   rp-&gt;enable_discovery(true /*verify_no_refs*/);
 242   rp-&gt;setup_policy(true); // forcefully purge all soft references
 243   rp-&gt;set_active_mt_degree(heap-&gt;workers()-&gt;active_workers());
 244 
<a name="5" id="anc5"></a><span class="line-removed"> 245   cm-&gt;update_roots(ShenandoahPhaseTimings::full_gc_update_roots);</span>
 246   cm-&gt;mark_roots(ShenandoahPhaseTimings::full_gc_scan_roots);
 247   cm-&gt;finish_mark_from_roots(/* full_gc = */ true);
 248   heap-&gt;mark_complete_marking_context();
 249   heap-&gt;parallel_cleaning(true /* full_gc */);
 250 }
 251 
 252 class ShenandoahPrepareForCompactionObjectClosure : public ObjectClosure {
 253 private:
 254   PreservedMarks*          const _preserved_marks;
 255   ShenandoahHeap*          const _heap;
 256   GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; _empty_regions;
 257   int _empty_regions_pos;
 258   ShenandoahHeapRegion*          _to_region;
 259   ShenandoahHeapRegion*          _from_region;
 260   HeapWord* _compact_point;
 261 
 262 public:
 263   ShenandoahPrepareForCompactionObjectClosure(PreservedMarks* preserved_marks,
 264                                               GrowableArray&lt;ShenandoahHeapRegion*&gt;&amp; empty_regions,
 265                                               ShenandoahHeapRegion* to_region) :
 266     _preserved_marks(preserved_marks),
 267     _heap(ShenandoahHeap::heap()),
 268     _empty_regions(empty_regions),
 269     _empty_regions_pos(0),
 270     _to_region(to_region),
 271     _from_region(NULL),
 272     _compact_point(to_region-&gt;bottom()) {}
 273 
 274   void set_from_region(ShenandoahHeapRegion* from_region) {
 275     _from_region = from_region;
 276   }
 277 
 278   void finish_region() {
 279     assert(_to_region != NULL, &quot;should not happen&quot;);
 280     _to_region-&gt;set_new_top(_compact_point);
 281   }
 282 
 283   bool is_compact_same_region() {
 284     return _from_region == _to_region;
 285   }
 286 
 287   int empty_regions_pos() {
 288     return _empty_regions_pos;
 289   }
 290 
 291   void do_object(oop p) {
 292     assert(_from_region != NULL, &quot;must set before work&quot;);
 293     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
 294     assert(!_heap-&gt;complete_marking_context()-&gt;allocated_after_mark_start(p), &quot;must be truly marked&quot;);
 295 
 296     size_t obj_size = p-&gt;size();
 297     if (_compact_point + obj_size &gt; _to_region-&gt;end()) {
 298       finish_region();
 299 
 300       // Object doesn&#39;t fit. Pick next empty region and start compacting there.
 301       ShenandoahHeapRegion* new_to_region;
 302       if (_empty_regions_pos &lt; _empty_regions.length()) {
 303         new_to_region = _empty_regions.at(_empty_regions_pos);
 304         _empty_regions_pos++;
 305       } else {
 306         // Out of empty region? Compact within the same region.
 307         new_to_region = _from_region;
 308       }
 309 
 310       assert(new_to_region != _to_region, &quot;must not reuse same to-region&quot;);
 311       assert(new_to_region != NULL, &quot;must not be NULL&quot;);
 312       _to_region = new_to_region;
 313       _compact_point = _to_region-&gt;bottom();
 314     }
 315 
 316     // Object fits into current region, record new location:
 317     assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
 318     shenandoah_assert_not_forwarded(NULL, p);
 319     _preserved_marks-&gt;push_if_necessary(p, p-&gt;mark_raw());
 320     p-&gt;forward_to(oop(_compact_point));
 321     _compact_point += obj_size;
 322   }
 323 };
 324 
 325 class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
 326 private:
 327   PreservedMarksSet*        const _preserved_marks;
 328   ShenandoahHeap*           const _heap;
 329   ShenandoahHeapRegionSet** const _worker_slices;
 330 
 331 public:
 332   ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :
 333     AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
 334     _preserved_marks(preserved_marks),
 335     _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
 336   }
 337 
 338   static bool is_candidate_region(ShenandoahHeapRegion* r) {
 339     // Empty region: get it into the slice to defragment the slice itself.
 340     // We could have skipped this without violating correctness, but we really
 341     // want to compact all live regions to the start of the heap, which sometimes
 342     // means moving them into the fully empty regions.
 343     if (r-&gt;is_empty()) return true;
 344 
 345     // Can move the region, and this is not the humongous region. Humongous
 346     // moves are special cased here, because their moves are handled separately.
 347     return r-&gt;is_stw_move_allowed() &amp;&amp; !r-&gt;is_humongous();
 348   }
 349 
 350   void work(uint worker_id) {
 351     ShenandoahParallelWorkerSession worker_session(worker_id);
 352     ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
 353     ShenandoahHeapRegionSetIterator it(slice);
 354     ShenandoahHeapRegion* from_region = it.next();
 355     // No work?
 356     if (from_region == NULL) {
 357        return;
 358     }
 359 
 360     // Sliding compaction. Walk all regions in the slice, and compact them.
 361     // Remember empty regions and reuse them as needed.
 362     ResourceMark rm;
 363 
 364     GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());
 365 
 366     ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks-&gt;get(worker_id), empty_regions, from_region);
 367 
 368     while (from_region != NULL) {
 369       assert(is_candidate_region(from_region), &quot;Sanity&quot;);
 370 
 371       cl.set_from_region(from_region);
 372       if (from_region-&gt;has_live()) {
 373         _heap-&gt;marked_object_iterate(from_region, &amp;cl);
 374       }
 375 
 376       // Compacted the region to somewhere else? From-region is empty then.
 377       if (!cl.is_compact_same_region()) {
 378         empty_regions.append(from_region);
 379       }
 380       from_region = it.next();
 381     }
 382     cl.finish_region();
 383 
 384     // Mark all remaining regions as empty
 385     for (int pos = cl.empty_regions_pos(); pos &lt; empty_regions.length(); ++pos) {
 386       ShenandoahHeapRegion* r = empty_regions.at(pos);
 387       r-&gt;set_new_top(r-&gt;bottom());
 388     }
 389   }
 390 };
 391 
 392 void ShenandoahMarkCompact::calculate_target_humongous_objects() {
 393   ShenandoahHeap* heap = ShenandoahHeap::heap();
 394 
 395   // Compute the new addresses for humongous objects. We need to do this after addresses
 396   // for regular objects are calculated, and we know what regions in heap suffix are
 397   // available for humongous moves.
 398   //
 399   // Scan the heap backwards, because we are compacting humongous regions towards the end.
 400   // Maintain the contiguous compaction window in [to_begin; to_end), so that we can slide
 401   // humongous start there.
 402   //
 403   // The complication is potential non-movable regions during the scan. If such region is
 404   // detected, then sliding restarts towards that non-movable region.
 405 
 406   size_t to_begin = heap-&gt;num_regions();
 407   size_t to_end = heap-&gt;num_regions();
 408 
 409   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {
 410     ShenandoahHeapRegion *r = heap-&gt;get_region(c - 1);
 411     if (r-&gt;is_humongous_continuation() || (r-&gt;new_top() == r-&gt;bottom())) {
 412       // To-region candidate: record this, and continue scan
 413       to_begin = r-&gt;index();
 414       continue;
 415     }
 416 
 417     if (r-&gt;is_humongous_start() &amp;&amp; r-&gt;is_stw_move_allowed()) {
 418       // From-region candidate: movable humongous region
 419       oop old_obj = oop(r-&gt;bottom());
 420       size_t words_size = old_obj-&gt;size();
 421       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
 422 
 423       size_t start = to_end - num_regions;
 424 
 425       if (start &gt;= to_begin &amp;&amp; start != r-&gt;index()) {
 426         // Fits into current window, and the move is non-trivial. Record the move then, and continue scan.
 427         _preserved_marks-&gt;get(0)-&gt;push_if_necessary(old_obj, old_obj-&gt;mark_raw());
 428         old_obj-&gt;forward_to(oop(heap-&gt;get_region(start)-&gt;bottom()));
 429         to_end = start;
 430         continue;
 431       }
 432     }
 433 
 434     // Failed to fit. Scan starting from current region.
 435     to_begin = r-&gt;index();
 436     to_end = r-&gt;index();
 437   }
 438 }
 439 
 440 class ShenandoahEnsureHeapActiveClosure: public ShenandoahHeapRegionClosure {
 441 private:
 442   ShenandoahHeap* const _heap;
 443 
 444 public:
 445   ShenandoahEnsureHeapActiveClosure() : _heap(ShenandoahHeap::heap()) {}
 446   void heap_region_do(ShenandoahHeapRegion* r) {
 447     if (r-&gt;is_trash()) {
 448       r-&gt;recycle();
 449     }
 450     if (r-&gt;is_cset()) {
 451       r-&gt;make_regular_bypass();
 452     }
 453     if (r-&gt;is_empty_uncommitted()) {
 454       r-&gt;make_committed_bypass();
 455     }
 456     assert (r-&gt;is_committed(), &quot;only committed regions in heap now, see region &quot; SIZE_FORMAT, r-&gt;index());
 457 
 458     // Record current region occupancy: this communicates empty regions are free
 459     // to the rest of Full GC code.
 460     r-&gt;set_new_top(r-&gt;top());
 461   }
 462 };
 463 
 464 class ShenandoahTrashImmediateGarbageClosure: public ShenandoahHeapRegionClosure {
 465 private:
 466   ShenandoahHeap* const _heap;
 467   ShenandoahMarkingContext* const _ctx;
 468 
 469 public:
 470   ShenandoahTrashImmediateGarbageClosure() :
 471     _heap(ShenandoahHeap::heap()),
 472     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
 473 
 474   void heap_region_do(ShenandoahHeapRegion* r) {
 475     if (r-&gt;is_humongous_start()) {
 476       oop humongous_obj = oop(r-&gt;bottom());
 477       if (!_ctx-&gt;is_marked(humongous_obj)) {
 478         assert(!r-&gt;has_live(),
 479                &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;index());
 480         _heap-&gt;trash_humongous_region_at(r);
 481       } else {
 482         assert(r-&gt;has_live(),
 483                &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;index());
 484       }
 485     } else if (r-&gt;is_humongous_continuation()) {
 486       // If we hit continuation, the non-live humongous starts should have been trashed already
 487       assert(r-&gt;humongous_start_region()-&gt;has_live(),
 488              &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;index());
 489     } else if (r-&gt;is_regular()) {
 490       if (!r-&gt;has_live()) {
 491         r-&gt;make_trash_immediate();
 492       }
 493     }
 494   }
 495 };
 496 
 497 void ShenandoahMarkCompact::distribute_slices(ShenandoahHeapRegionSet** worker_slices) {
 498   ShenandoahHeap* heap = ShenandoahHeap::heap();
 499 
 500   uint n_workers = heap-&gt;workers()-&gt;active_workers();
 501   size_t n_regions = heap-&gt;num_regions();
 502 
 503   // What we want to accomplish: have the dense prefix of data, while still balancing
 504   // out the parallel work.
 505   //
 506   // Assuming the amount of work is driven by the live data that needs moving, we can slice
 507   // the entire heap into equal-live-sized prefix slices, and compact into them. So, each
 508   // thread takes all regions in its prefix subset, and then it takes some regions from
 509   // the tail.
 510   //
 511   // Tail region selection becomes interesting.
 512   //
 513   // First, we want to distribute the regions fairly between the workers, and those regions
 514   // might have different amount of live data. So, until we sure no workers need live data,
 515   // we need to only take what the worker needs.
 516   //
 517   // Second, since we slide everything to the left in each slice, the most busy regions
 518   // would be the ones on the left. Which means we want to have all workers have their after-tail
 519   // regions as close to the left as possible.
 520   //
 521   // The easiest way to do this is to distribute after-tail regions in round-robin between
 522   // workers that still need live data.
 523   //
 524   // Consider parallel workers A, B, C, then the target slice layout would be:
 525   //
 526   //  AAAAAAAABBBBBBBBCCCCCCCC|ABCABCABCABCABCABCABCABABABABABABABABABABAAAAA
 527   //
 528   //  (.....dense-prefix.....) (.....................tail...................)
 529   //  [all regions fully live] [left-most regions are fuller that right-most]
 530   //
 531 
 532   // Compute how much live data is there. This would approximate the size of dense prefix
 533   // we target to create.
 534   size_t total_live = 0;
 535   for (size_t idx = 0; idx &lt; n_regions; idx++) {
 536     ShenandoahHeapRegion *r = heap-&gt;get_region(idx);
 537     if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {
 538       total_live += r-&gt;get_live_data_words();
 539     }
 540   }
 541 
 542   // Estimate the size for the dense prefix. Note that we specifically count only the
 543   // &quot;full&quot; regions, so there would be some non-full regions in the slice tail.
 544   size_t live_per_worker = total_live / n_workers;
 545   size_t prefix_regions_per_worker = live_per_worker / ShenandoahHeapRegion::region_size_words();
 546   size_t prefix_regions_total = prefix_regions_per_worker * n_workers;
 547   prefix_regions_total = MIN2(prefix_regions_total, n_regions);
 548   assert(prefix_regions_total &lt;= n_regions, &quot;Sanity&quot;);
 549 
 550   // There might be non-candidate regions in the prefix. To compute where the tail actually
 551   // ends up being, we need to account those as well.
 552   size_t prefix_end = prefix_regions_total;
 553   for (size_t idx = 0; idx &lt; prefix_regions_total; idx++) {
 554     ShenandoahHeapRegion *r = heap-&gt;get_region(idx);
 555     if (!ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {
 556       prefix_end++;
 557     }
 558   }
 559   prefix_end = MIN2(prefix_end, n_regions);
 560   assert(prefix_end &lt;= n_regions, &quot;Sanity&quot;);
 561 
 562   // Distribute prefix regions per worker: each thread definitely gets its own same-sized
 563   // subset of dense prefix.
 564   size_t prefix_idx = 0;
 565 
 566   size_t* live = NEW_C_HEAP_ARRAY(size_t, n_workers, mtGC);
 567 
 568   for (size_t wid = 0; wid &lt; n_workers; wid++) {
 569     ShenandoahHeapRegionSet* slice = worker_slices[wid];
 570 
 571     live[wid] = 0;
 572     size_t regs = 0;
 573 
 574     // Add all prefix regions for this worker
 575     while (prefix_idx &lt; prefix_end &amp;&amp; regs &lt; prefix_regions_per_worker) {
 576       ShenandoahHeapRegion *r = heap-&gt;get_region(prefix_idx);
 577       if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {
 578         slice-&gt;add_region(r);
 579         live[wid] += r-&gt;get_live_data_words();
 580         regs++;
 581       }
 582       prefix_idx++;
 583     }
 584   }
 585 
 586   // Distribute the tail among workers in round-robin fashion.
 587   size_t wid = n_workers - 1;
 588 
 589   for (size_t tail_idx = prefix_end; tail_idx &lt; n_regions; tail_idx++) {
 590     ShenandoahHeapRegion *r = heap-&gt;get_region(tail_idx);
 591     if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {
 592       assert(wid &lt; n_workers, &quot;Sanity&quot;);
 593 
 594       size_t live_region = r-&gt;get_live_data_words();
 595 
 596       // Select next worker that still needs live data.
 597       size_t old_wid = wid;
 598       do {
 599         wid++;
 600         if (wid == n_workers) wid = 0;
 601       } while (live[wid] + live_region &gt;= live_per_worker &amp;&amp; old_wid != wid);
 602 
 603       if (old_wid == wid) {
 604         // Circled back to the same worker? This means liveness data was
 605         // miscalculated. Bump the live_per_worker limit so that
 606         // everyone gets a piece of the leftover work.
 607         live_per_worker += ShenandoahHeapRegion::region_size_words();
 608       }
 609 
 610       worker_slices[wid]-&gt;add_region(r);
 611       live[wid] += live_region;
 612     }
 613   }
 614 
 615   FREE_C_HEAP_ARRAY(size_t, live);
 616 
 617 #ifdef ASSERT
 618   ResourceBitMap map(n_regions);
 619   for (size_t wid = 0; wid &lt; n_workers; wid++) {
 620     ShenandoahHeapRegionSetIterator it(worker_slices[wid]);
 621     ShenandoahHeapRegion* r = it.next();
 622     while (r != NULL) {
 623       size_t idx = r-&gt;index();
 624       assert(ShenandoahPrepareForCompactionTask::is_candidate_region(r), &quot;Sanity: &quot; SIZE_FORMAT, idx);
 625       assert(!map.at(idx), &quot;No region distributed twice: &quot; SIZE_FORMAT, idx);
 626       map.at_put(idx, true);
 627       r = it.next();
 628     }
 629   }
 630 
 631   for (size_t rid = 0; rid &lt; n_regions; rid++) {
 632     bool is_candidate = ShenandoahPrepareForCompactionTask::is_candidate_region(heap-&gt;get_region(rid));
 633     bool is_distributed = map.at(rid);
 634     assert(is_distributed || !is_candidate, &quot;All candidates are distributed: &quot; SIZE_FORMAT, rid);
 635   }
 636 #endif
 637 }
 638 
 639 void ShenandoahMarkCompact::phase2_calculate_target_addresses(ShenandoahHeapRegionSet** worker_slices) {
 640   GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
 641   ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
 642 
 643   ShenandoahHeap* heap = ShenandoahHeap::heap();
 644 
 645   // About to figure out which regions can be compacted, make sure pinning status
 646   // had been updated in GC prologue.
 647   heap-&gt;assert_pinned_region_status();
 648 
 649   {
 650     // Trash the immediately collectible regions before computing addresses
 651     ShenandoahTrashImmediateGarbageClosure tigcl;
 652     heap-&gt;heap_region_iterate(&amp;tigcl);
 653 
 654     // Make sure regions are in good state: committed, active, clean.
 655     // This is needed because we are potentially sliding the data through them.
 656     ShenandoahEnsureHeapActiveClosure ecl;
 657     heap-&gt;heap_region_iterate(&amp;ecl);
 658   }
 659 
 660   // Compute the new addresses for regular objects
 661   {
 662     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
 663 
 664     distribute_slices(worker_slices);
 665 
 666     ShenandoahPrepareForCompactionTask task(_preserved_marks, worker_slices);
 667     heap-&gt;workers()-&gt;run_task(&amp;task);
 668   }
 669 
 670   // Compute the new addresses for humongous objects
 671   {
 672     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_humong);
 673     calculate_target_humongous_objects();
 674   }
 675 }
 676 
 677 class ShenandoahAdjustPointersClosure : public MetadataVisitingOopIterateClosure {
 678 private:
 679   ShenandoahHeap* const _heap;
 680   ShenandoahMarkingContext* const _ctx;
 681 
 682   template &lt;class T&gt;
 683   inline void do_oop_work(T* p) {
 684     T o = RawAccess&lt;&gt;::oop_load(p);
 685     if (!CompressedOops::is_null(o)) {
 686       oop obj = CompressedOops::decode_not_null(o);
 687       assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
 688       if (obj-&gt;is_forwarded()) {
 689         oop forw = obj-&gt;forwardee();
 690         RawAccess&lt;IS_NOT_NULL&gt;::oop_store(p, forw);
 691       }
 692     }
 693   }
 694 
 695 public:
 696   ShenandoahAdjustPointersClosure() :
 697     _heap(ShenandoahHeap::heap()),
 698     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
 699 
 700   void do_oop(oop* p)       { do_oop_work(p); }
 701   void do_oop(narrowOop* p) { do_oop_work(p); }
 702 };
 703 
 704 class ShenandoahAdjustPointersObjectClosure : public ObjectClosure {
 705 private:
 706   ShenandoahHeap* const _heap;
 707   ShenandoahAdjustPointersClosure _cl;
 708 
 709 public:
 710   ShenandoahAdjustPointersObjectClosure() :
 711     _heap(ShenandoahHeap::heap()) {
 712   }
 713   void do_object(oop p) {
 714     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
 715     p-&gt;oop_iterate(&amp;_cl);
 716   }
 717 };
 718 
 719 class ShenandoahAdjustPointersTask : public AbstractGangTask {
 720 private:
 721   ShenandoahHeap*          const _heap;
 722   ShenandoahRegionIterator       _regions;
 723 
 724 public:
 725   ShenandoahAdjustPointersTask() :
 726     AbstractGangTask(&quot;Shenandoah Adjust Pointers Task&quot;),
 727     _heap(ShenandoahHeap::heap()) {
 728   }
 729 
 730   void work(uint worker_id) {
 731     ShenandoahParallelWorkerSession worker_session(worker_id);
 732     ShenandoahAdjustPointersObjectClosure obj_cl;
 733     ShenandoahHeapRegion* r = _regions.next();
 734     while (r != NULL) {
 735       if (!r-&gt;is_humongous_continuation() &amp;&amp; r-&gt;has_live()) {
 736         _heap-&gt;marked_object_iterate(r, &amp;obj_cl);
 737       }
 738       r = _regions.next();
 739     }
 740   }
 741 };
 742 
 743 class ShenandoahAdjustRootPointersTask : public AbstractGangTask {
 744 private:
 745   ShenandoahRootAdjuster* _rp;
 746   PreservedMarksSet* _preserved_marks;
 747 public:
 748   ShenandoahAdjustRootPointersTask(ShenandoahRootAdjuster* rp, PreservedMarksSet* preserved_marks) :
 749     AbstractGangTask(&quot;Shenandoah Adjust Root Pointers Task&quot;),
 750     _rp(rp),
 751     _preserved_marks(preserved_marks) {}
 752 
 753   void work(uint worker_id) {
 754     ShenandoahParallelWorkerSession worker_session(worker_id);
 755     ShenandoahAdjustPointersClosure cl;
 756     _rp-&gt;roots_do(worker_id, &amp;cl);
 757     _preserved_marks-&gt;get(worker_id)-&gt;adjust_during_full_gc();
 758   }
 759 };
 760 
 761 void ShenandoahMarkCompact::phase3_update_references() {
 762   GCTraceTime(Info, gc, phases) time(&quot;Phase 3: Adjust pointers&quot;, _gc_timer);
 763   ShenandoahGCPhase adjust_pointer_phase(ShenandoahPhaseTimings::full_gc_adjust_pointers);
 764 
 765   ShenandoahHeap* heap = ShenandoahHeap::heap();
 766 
 767   WorkGang* workers = heap-&gt;workers();
 768   uint nworkers = workers-&gt;active_workers();
 769   {
 770 #if COMPILER2_OR_JVMCI
 771     DerivedPointerTable::clear();
 772 #endif
 773     ShenandoahRootAdjuster rp(nworkers, ShenandoahPhaseTimings::full_gc_adjust_roots);
 774     ShenandoahAdjustRootPointersTask task(&amp;rp, _preserved_marks);
 775     workers-&gt;run_task(&amp;task);
 776 #if COMPILER2_OR_JVMCI
 777     DerivedPointerTable::update_pointers();
 778 #endif
 779   }
 780 
 781   ShenandoahAdjustPointersTask adjust_pointers_task;
 782   workers-&gt;run_task(&amp;adjust_pointers_task);
 783 }
 784 
 785 class ShenandoahCompactObjectsClosure : public ObjectClosure {
 786 private:
 787   ShenandoahHeap* const _heap;
 788   uint            const _worker_id;
 789 
 790 public:
 791   ShenandoahCompactObjectsClosure(uint worker_id) :
 792     _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}
 793 
 794   void do_object(oop p) {
 795     assert(_heap-&gt;complete_marking_context()-&gt;is_marked(p), &quot;must be marked&quot;);
 796     size_t size = (size_t)p-&gt;size();
 797     if (p-&gt;is_forwarded()) {
 798       HeapWord* compact_from = cast_from_oop&lt;HeapWord*&gt;(p);
 799       HeapWord* compact_to = cast_from_oop&lt;HeapWord*&gt;(p-&gt;forwardee());
 800       Copy::aligned_conjoint_words(compact_from, compact_to, size);
 801       oop new_obj = oop(compact_to);
 802       new_obj-&gt;init_mark_raw();
 803     }
 804   }
 805 };
 806 
 807 class ShenandoahCompactObjectsTask : public AbstractGangTask {
 808 private:
 809   ShenandoahHeap* const _heap;
 810   ShenandoahHeapRegionSet** const _worker_slices;
 811 
 812 public:
 813   ShenandoahCompactObjectsTask(ShenandoahHeapRegionSet** worker_slices) :
 814     AbstractGangTask(&quot;Shenandoah Compact Objects Task&quot;),
 815     _heap(ShenandoahHeap::heap()),
 816     _worker_slices(worker_slices) {
 817   }
 818 
 819   void work(uint worker_id) {
 820     ShenandoahParallelWorkerSession worker_session(worker_id);
 821     ShenandoahHeapRegionSetIterator slice(_worker_slices[worker_id]);
 822 
 823     ShenandoahCompactObjectsClosure cl(worker_id);
 824     ShenandoahHeapRegion* r = slice.next();
 825     while (r != NULL) {
 826       assert(!r-&gt;is_humongous(), &quot;must not get humongous regions here&quot;);
 827       if (r-&gt;has_live()) {
 828         _heap-&gt;marked_object_iterate(r, &amp;cl);
 829       }
 830       r-&gt;set_top(r-&gt;new_top());
 831       r = slice.next();
 832     }
 833   }
 834 };
 835 
 836 class ShenandoahPostCompactClosure : public ShenandoahHeapRegionClosure {
 837 private:
 838   ShenandoahHeap* const _heap;
 839   size_t _live;
 840 
 841 public:
 842   ShenandoahPostCompactClosure() : _heap(ShenandoahHeap::heap()), _live(0) {
 843     _heap-&gt;free_set()-&gt;clear();
 844   }
 845 
 846   void heap_region_do(ShenandoahHeapRegion* r) {
 847     assert (!r-&gt;is_cset(), &quot;cset regions should have been demoted already&quot;);
 848 
 849     // Need to reset the complete-top-at-mark-start pointer here because
 850     // the complete marking bitmap is no longer valid. This ensures
 851     // size-based iteration in marked_object_iterate().
 852     // NOTE: See blurb at ShenandoahMCResetCompleteBitmapTask on why we need to skip
 853     // pinned regions.
 854     if (!r-&gt;is_pinned()) {
 855       _heap-&gt;complete_marking_context()-&gt;reset_top_at_mark_start(r);
 856     }
 857 
 858     size_t live = r-&gt;used();
 859 
 860     // Make empty regions that have been allocated into regular
 861     if (r-&gt;is_empty() &amp;&amp; live &gt; 0) {
 862       r-&gt;make_regular_bypass();
 863     }
 864 
 865     // Reclaim regular regions that became empty
 866     if (r-&gt;is_regular() &amp;&amp; live == 0) {
 867       r-&gt;make_trash();
 868     }
 869 
 870     // Recycle all trash regions
 871     if (r-&gt;is_trash()) {
 872       live = 0;
 873       r-&gt;recycle();
 874     }
 875 
 876     r-&gt;set_live_data(live);
 877     r-&gt;reset_alloc_metadata();
 878     _live += live;
 879   }
 880 
 881   size_t get_live() {
 882     return _live;
 883   }
 884 };
 885 
 886 void ShenandoahMarkCompact::compact_humongous_objects() {
 887   // Compact humongous regions, based on their fwdptr objects.
 888   //
 889   // This code is serial, because doing the in-slice parallel sliding is tricky. In most cases,
 890   // humongous regions are already compacted, and do not require further moves, which alleviates
 891   // sliding costs. We may consider doing this in parallel in future.
 892 
 893   ShenandoahHeap* heap = ShenandoahHeap::heap();
 894 
 895   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {
 896     ShenandoahHeapRegion* r = heap-&gt;get_region(c - 1);
 897     if (r-&gt;is_humongous_start()) {
 898       oop old_obj = oop(r-&gt;bottom());
 899       if (!old_obj-&gt;is_forwarded()) {
 900         // No need to move the object, it stays at the same slot
 901         continue;
 902       }
 903       size_t words_size = old_obj-&gt;size();
 904       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
 905 
 906       size_t old_start = r-&gt;index();
 907       size_t old_end   = old_start + num_regions - 1;
 908       size_t new_start = heap-&gt;heap_region_index_containing(old_obj-&gt;forwardee());
 909       size_t new_end   = new_start + num_regions - 1;
 910       assert(old_start != new_start, &quot;must be real move&quot;);
 911       assert(r-&gt;is_stw_move_allowed(), &quot;Region &quot; SIZE_FORMAT &quot; should be movable&quot;, r-&gt;index());
 912 
 913       Copy::aligned_conjoint_words(heap-&gt;get_region(old_start)-&gt;bottom(),
 914                                    heap-&gt;get_region(new_start)-&gt;bottom(),
 915                                    ShenandoahHeapRegion::region_size_words()*num_regions);
 916 
 917       oop new_obj = oop(heap-&gt;get_region(new_start)-&gt;bottom());
 918       new_obj-&gt;init_mark_raw();
 919 
 920       {
 921         for (size_t c = old_start; c &lt;= old_end; c++) {
 922           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 923           r-&gt;make_regular_bypass();
 924           r-&gt;set_top(r-&gt;bottom());
 925         }
 926 
 927         for (size_t c = new_start; c &lt;= new_end; c++) {
 928           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 929           if (c == new_start) {
 930             r-&gt;make_humongous_start_bypass();
 931           } else {
 932             r-&gt;make_humongous_cont_bypass();
 933           }
 934 
 935           // Trailing region may be non-full, record the remainder there
 936           size_t remainder = words_size &amp; ShenandoahHeapRegion::region_size_words_mask();
 937           if ((c == new_end) &amp;&amp; (remainder != 0)) {
 938             r-&gt;set_top(r-&gt;bottom() + remainder);
 939           } else {
 940             r-&gt;set_top(r-&gt;end());
 941           }
 942 
 943           r-&gt;reset_alloc_metadata();
 944         }
 945       }
 946     }
 947   }
 948 }
 949 
 950 // This is slightly different to ShHeap::reset_next_mark_bitmap:
 951 // we need to remain able to walk pinned regions.
 952 // Since pinned region do not move and don&#39;t get compacted, we will get holes with
 953 // unreachable objects in them (which may have pointers to unloaded Klasses and thus
 954 // cannot be iterated over using oop-&gt;size(). The only way to safely iterate over those is using
 955 // a valid marking bitmap and valid TAMS pointer. This class only resets marking
 956 // bitmaps for un-pinned regions, and later we only reset TAMS for unpinned regions.
 957 class ShenandoahMCResetCompleteBitmapTask : public AbstractGangTask {
 958 private:
 959   ShenandoahRegionIterator _regions;
 960 
 961 public:
 962   ShenandoahMCResetCompleteBitmapTask() :
 963     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {
 964   }
 965 
 966   void work(uint worker_id) {
 967     ShenandoahParallelWorkerSession worker_session(worker_id);
 968     ShenandoahHeapRegion* region = _regions.next();
 969     ShenandoahHeap* heap = ShenandoahHeap::heap();
 970     ShenandoahMarkingContext* const ctx = heap-&gt;complete_marking_context();
 971     while (region != NULL) {
 972       if (heap-&gt;is_bitmap_slice_committed(region) &amp;&amp; !region-&gt;is_pinned() &amp;&amp; region-&gt;has_live()) {
 973         ctx-&gt;clear_bitmap(region);
 974       }
 975       region = _regions.next();
 976     }
 977   }
 978 };
 979 
 980 void ShenandoahMarkCompact::phase4_compact_objects(ShenandoahHeapRegionSet** worker_slices) {
 981   GCTraceTime(Info, gc, phases) time(&quot;Phase 4: Move objects&quot;, _gc_timer);
 982   ShenandoahGCPhase compaction_phase(ShenandoahPhaseTimings::full_gc_copy_objects);
 983 
 984   ShenandoahHeap* heap = ShenandoahHeap::heap();
 985 
 986   // Compact regular objects first
 987   {
 988     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_copy_objects_regular);
 989     ShenandoahCompactObjectsTask compact_task(worker_slices);
 990     heap-&gt;workers()-&gt;run_task(&amp;compact_task);
 991   }
 992 
 993   // Compact humongous objects after regular object moves
 994   {
 995     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_copy_objects_humong);
 996     compact_humongous_objects();
 997   }
 998 
 999   // Reset complete bitmap. We&#39;re about to reset the complete-top-at-mark-start pointer
1000   // and must ensure the bitmap is in sync.
1001   {
1002     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_copy_objects_reset_complete);
1003     ShenandoahMCResetCompleteBitmapTask task;
1004     heap-&gt;workers()-&gt;run_task(&amp;task);
1005   }
1006 
1007   // Bring regions in proper states after the collection, and set heap properties.
1008   {
1009     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_copy_objects_rebuild);
1010 
1011     ShenandoahPostCompactClosure post_compact;
1012     heap-&gt;heap_region_iterate(&amp;post_compact);
1013     heap-&gt;set_used(post_compact.get_live());
1014 
1015     heap-&gt;collection_set()-&gt;clear();
1016     heap-&gt;free_set()-&gt;rebuild();
1017   }
1018 
1019   heap-&gt;clear_cancelled_gc();
1020 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
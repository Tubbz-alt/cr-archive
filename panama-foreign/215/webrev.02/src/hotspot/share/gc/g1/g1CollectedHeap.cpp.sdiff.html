<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Analytics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2651   VirtualSpaceSummary heap_summary = create_heap_space_summary();
2652   return G1HeapSummary(heap_summary, heap_used, eden_used_bytes,
2653                        eden_capacity_bytes, survivor_used_bytes, num_regions());
2654 }
2655 
2656 G1EvacSummary G1CollectedHeap::create_g1_evac_summary(G1EvacStats* stats) {
2657   return G1EvacSummary(stats-&gt;allocated(), stats-&gt;wasted(), stats-&gt;undo_wasted(),
2658                        stats-&gt;unused(), stats-&gt;used(), stats-&gt;region_end_waste(),
2659                        stats-&gt;regions_filled(), stats-&gt;direct_allocated(),
2660                        stats-&gt;failure_used(), stats-&gt;failure_waste());
2661 }
2662 
2663 void G1CollectedHeap::trace_heap(GCWhen::Type when, const GCTracer* gc_tracer) {
2664   const G1HeapSummary&amp; heap_summary = create_g1_heap_summary();
2665   gc_tracer-&gt;report_gc_heap_summary(when, heap_summary);
2666 
2667   const MetaspaceSummary&amp; metaspace_summary = create_metaspace_summary();
2668   gc_tracer-&gt;report_metaspace_summary(when, metaspace_summary);
2669 }
2670 
<span class="line-removed">2671 G1CollectedHeap* G1CollectedHeap::heap() {</span>
<span class="line-removed">2672   CollectedHeap* heap = Universe::heap();</span>
<span class="line-removed">2673   assert(heap != NULL, &quot;Uninitialized access to G1CollectedHeap::heap()&quot;);</span>
<span class="line-removed">2674   assert(heap-&gt;kind() == CollectedHeap::G1, &quot;Invalid name&quot;);</span>
<span class="line-removed">2675   return (G1CollectedHeap*)heap;</span>
<span class="line-removed">2676 }</span>
<span class="line-removed">2677 </span>
2678 void G1CollectedHeap::gc_prologue(bool full) {
2679   assert(InlineCacheBuffer::is_empty(), &quot;should have cleaned up ICBuffer&quot;);
2680 
2681   // This summary needs to be printed before incrementing total collections.
2682   rem_set()-&gt;print_periodic_summary_info(&quot;Before GC RS summary&quot;, total_collections());
2683 
2684   // Update common counters.
2685   increment_total_collections(full /* full gc */);
2686   if (full || collector_state()-&gt;in_initial_mark_gc()) {
2687     increment_old_marking_cycles_started();
2688   }
2689 
2690   // Fill TLAB&#39;s and such
2691   {
2692     Ticks start = Ticks::now();
2693     ensure_parsability(true);
2694     Tickspan dt = Ticks::now() - start;
2695     phase_times()-&gt;record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);
2696   }
2697 
</pre>
</td>
<td>
<hr />
<pre>
2651   VirtualSpaceSummary heap_summary = create_heap_space_summary();
2652   return G1HeapSummary(heap_summary, heap_used, eden_used_bytes,
2653                        eden_capacity_bytes, survivor_used_bytes, num_regions());
2654 }
2655 
2656 G1EvacSummary G1CollectedHeap::create_g1_evac_summary(G1EvacStats* stats) {
2657   return G1EvacSummary(stats-&gt;allocated(), stats-&gt;wasted(), stats-&gt;undo_wasted(),
2658                        stats-&gt;unused(), stats-&gt;used(), stats-&gt;region_end_waste(),
2659                        stats-&gt;regions_filled(), stats-&gt;direct_allocated(),
2660                        stats-&gt;failure_used(), stats-&gt;failure_waste());
2661 }
2662 
2663 void G1CollectedHeap::trace_heap(GCWhen::Type when, const GCTracer* gc_tracer) {
2664   const G1HeapSummary&amp; heap_summary = create_g1_heap_summary();
2665   gc_tracer-&gt;report_gc_heap_summary(when, heap_summary);
2666 
2667   const MetaspaceSummary&amp; metaspace_summary = create_metaspace_summary();
2668   gc_tracer-&gt;report_metaspace_summary(when, metaspace_summary);
2669 }
2670 







2671 void G1CollectedHeap::gc_prologue(bool full) {
2672   assert(InlineCacheBuffer::is_empty(), &quot;should have cleaned up ICBuffer&quot;);
2673 
2674   // This summary needs to be printed before incrementing total collections.
2675   rem_set()-&gt;print_periodic_summary_info(&quot;Before GC RS summary&quot;, total_collections());
2676 
2677   // Update common counters.
2678   increment_total_collections(full /* full gc */);
2679   if (full || collector_state()-&gt;in_initial_mark_gc()) {
2680     increment_old_marking_cycles_started();
2681   }
2682 
2683   // Fill TLAB&#39;s and such
2684   {
2685     Ticks start = Ticks::now();
2686     ensure_parsability(true);
2687     Tickspan dt = Ticks::now() - start;
2688     phase_times()-&gt;record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);
2689   }
2690 
</pre>
</td>
</tr>
</table>
<center><a href="g1Analytics.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1CollectedHeap.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1CollectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1CollectedHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1CollectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1276   // Returns the humongous threshold for a specific region size
1277   static size_t humongous_threshold_for(size_t region_size) {
1278     return (region_size / 2);
1279   }
1280 
1281   // Returns the number of regions the humongous object of the given word size
1282   // requires.
1283   static size_t humongous_obj_size_in_regions(size_t word_size);
1284 
1285   // Print the maximum heap capacity.
1286   virtual size_t max_capacity() const;
1287 
1288   // Return the size of reserved memory. Returns different value than max_capacity() when AllocateOldGenAt is used.
1289   virtual size_t max_reserved_capacity() const;
1290 
1291   virtual jlong millis_since_last_gc();
1292 
1293 
1294   // Convenience function to be used in situations where the heap type can be
1295   // asserted to be this type.
<span class="line-modified">1296   static G1CollectedHeap* heap();</span>


1297 
1298   void set_region_short_lived_locked(HeapRegion* hr);
1299   // add appropriate methods for any other surv rate groups
1300 
1301   const G1SurvivorRegions* survivor() const { return &amp;_survivor; }
1302 
1303   uint eden_regions_count() const { return _eden.length(); }
1304   uint eden_regions_count(uint node_index) const { return _eden.regions_on_node(node_index); }
1305   uint survivor_regions_count() const { return _survivor.length(); }
1306   uint survivor_regions_count(uint node_index) const { return _survivor.regions_on_node(node_index); }
1307   size_t eden_regions_used_bytes() const { return _eden.used_bytes(); }
1308   size_t survivor_regions_used_bytes() const { return _survivor.used_bytes(); }
1309   uint young_regions_count() const { return _eden.length() + _survivor.length(); }
1310   uint old_regions_count() const { return _old_set.length(); }
1311   uint archive_regions_count() const { return _archive_set.length(); }
1312   uint humongous_regions_count() const { return _humongous_set.length(); }
1313 
1314 #ifdef ASSERT
1315   bool check_young_list_empty();
1316 #endif
</pre>
</td>
<td>
<hr />
<pre>
1276   // Returns the humongous threshold for a specific region size
1277   static size_t humongous_threshold_for(size_t region_size) {
1278     return (region_size / 2);
1279   }
1280 
1281   // Returns the number of regions the humongous object of the given word size
1282   // requires.
1283   static size_t humongous_obj_size_in_regions(size_t word_size);
1284 
1285   // Print the maximum heap capacity.
1286   virtual size_t max_capacity() const;
1287 
1288   // Return the size of reserved memory. Returns different value than max_capacity() when AllocateOldGenAt is used.
1289   virtual size_t max_reserved_capacity() const;
1290 
1291   virtual jlong millis_since_last_gc();
1292 
1293 
1294   // Convenience function to be used in situations where the heap type can be
1295   // asserted to be this type.
<span class="line-modified">1296   static G1CollectedHeap* heap() {</span>
<span class="line-added">1297     return named_heap&lt;G1CollectedHeap&gt;(CollectedHeap::G1);</span>
<span class="line-added">1298   }</span>
1299 
1300   void set_region_short_lived_locked(HeapRegion* hr);
1301   // add appropriate methods for any other surv rate groups
1302 
1303   const G1SurvivorRegions* survivor() const { return &amp;_survivor; }
1304 
1305   uint eden_regions_count() const { return _eden.length(); }
1306   uint eden_regions_count(uint node_index) const { return _eden.regions_on_node(node_index); }
1307   uint survivor_regions_count() const { return _survivor.length(); }
1308   uint survivor_regions_count(uint node_index) const { return _survivor.regions_on_node(node_index); }
1309   size_t eden_regions_used_bytes() const { return _eden.used_bytes(); }
1310   size_t survivor_regions_used_bytes() const { return _survivor.used_bytes(); }
1311   uint young_regions_count() const { return _eden.length() + _survivor.length(); }
1312   uint old_regions_count() const { return _old_set.length(); }
1313   uint archive_regions_count() const { return _archive_set.length(); }
1314   uint humongous_regions_count() const { return _humongous_set.length(); }
1315 
1316 #ifdef ASSERT
1317   bool check_young_list_empty();
1318 #endif
</pre>
</td>
</tr>
</table>
<center><a href="g1CollectedHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1Policy.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
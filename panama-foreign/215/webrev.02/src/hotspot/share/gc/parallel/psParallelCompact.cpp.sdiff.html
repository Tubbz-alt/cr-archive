<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psParallelCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parallelScavengeHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psRootType.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psParallelCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 #include &quot;gc/parallel/parallelArguments.hpp&quot;
  34 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  35 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
  36 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  37 #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
  38 #include &quot;gc/parallel/psOldGen.hpp&quot;
  39 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  40 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
  41 #include &quot;gc/parallel/psRootType.hpp&quot;
  42 #include &quot;gc/parallel/psScavenge.hpp&quot;
  43 #include &quot;gc/parallel/psYoungGen.hpp&quot;
  44 #include &quot;gc/shared/gcCause.hpp&quot;
  45 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  46 #include &quot;gc/shared/gcId.hpp&quot;
  47 #include &quot;gc/shared/gcLocker.hpp&quot;
  48 #include &quot;gc/shared/gcTimer.hpp&quot;
  49 #include &quot;gc/shared/gcTrace.hpp&quot;
  50 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  51 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  52 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-modified">  53 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>

  54 #include &quot;gc/shared/referencePolicy.hpp&quot;
  55 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  56 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  57 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
  58 #include &quot;gc/shared/taskTerminator.hpp&quot;
  59 #include &quot;gc/shared/weakProcessor.hpp&quot;
  60 #include &quot;gc/shared/workerPolicy.hpp&quot;
  61 #include &quot;gc/shared/workgroup.hpp&quot;
  62 #include &quot;logging/log.hpp&quot;
  63 #include &quot;memory/iterator.inline.hpp&quot;
  64 #include &quot;memory/resourceArea.hpp&quot;
  65 #include &quot;memory/universe.hpp&quot;
  66 #include &quot;oops/access.inline.hpp&quot;
  67 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
  68 #include &quot;oops/instanceKlass.inline.hpp&quot;
  69 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  70 #include &quot;oops/methodData.hpp&quot;
  71 #include &quot;oops/objArrayKlass.inline.hpp&quot;
  72 #include &quot;oops/oop.inline.hpp&quot;
  73 #include &quot;runtime/atomic.hpp&quot;
</pre>
<hr />
<pre>
1998 
1999     thread-&gt;oops_do(&amp;mark_and_push_closure, &amp;mark_and_push_in_blobs);
2000 
2001     // Do the real work
2002     cm-&gt;follow_marking_stacks();
2003   }
2004 };
2005 
2006 static void mark_from_roots_work(ParallelRootType::Value root_type, uint worker_id) {
2007   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
2008 
2009   ParCompactionManager* cm =
2010     ParCompactionManager::gc_thread_compaction_manager(worker_id);
2011   PCMarkAndPushClosure mark_and_push_closure(cm);
2012 
2013   switch (root_type) {
2014     case ParallelRootType::universe:
2015       Universe::oops_do(&amp;mark_and_push_closure);
2016       break;
2017 
<span class="line-removed">2018     case ParallelRootType::jni_handles:</span>
<span class="line-removed">2019       JNIHandles::oops_do(&amp;mark_and_push_closure);</span>
<span class="line-removed">2020       break;</span>
<span class="line-removed">2021 </span>
2022     case ParallelRootType::object_synchronizer:
2023       ObjectSynchronizer::oops_do(&amp;mark_and_push_closure);
2024       break;
2025 
2026     case ParallelRootType::management:
2027       Management::oops_do(&amp;mark_and_push_closure);
2028       break;
2029 
2030     case ParallelRootType::jvmti:
2031       JvmtiExport::oops_do(&amp;mark_and_push_closure);
2032       break;
2033 
<span class="line-removed">2034     case ParallelRootType::vm_global:</span>
<span class="line-removed">2035       OopStorageSet::vm_global()-&gt;oops_do(&amp;mark_and_push_closure);</span>
<span class="line-removed">2036       break;</span>
<span class="line-removed">2037 </span>
2038     case ParallelRootType::class_loader_data:
2039       {
2040         CLDToOopClosure cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
2041         ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);
2042       }
2043       break;
2044 
2045     case ParallelRootType::code_cache:
2046       // Do not treat nmethods as strong roots for mark/sweep, since we can unload them.
2047       //ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure(&amp;mark_and_push_closure));
2048       AOTLoader::oops_do(&amp;mark_and_push_closure);
2049       break;
2050 
2051     case ParallelRootType::sentinel:
2052     DEBUG_ONLY(default:) // DEBUG_ONLY hack will create compile error on release builds (-Wswitch) and runtime check on debug builds
2053       fatal(&quot;Bad enumeration value: %u&quot;, root_type);
2054       break;
2055   }
2056 
2057   // Do the real work
</pre>
<hr />
<pre>
2064   ParCompactionManager* cm =
2065     ParCompactionManager::gc_thread_compaction_manager(worker_id);
2066 
2067   oop obj = NULL;
2068   ObjArrayTask task;
2069   do {
2070     while (ParCompactionManager::steal_objarray(worker_id,  task)) {
2071       cm-&gt;follow_array((objArrayOop)task.obj(), task.index());
2072       cm-&gt;follow_marking_stacks();
2073     }
2074     while (ParCompactionManager::steal(worker_id, obj)) {
2075       cm-&gt;follow_contents(obj);
2076       cm-&gt;follow_marking_stacks();
2077     }
2078   } while (!terminator.offer_termination());
2079 }
2080 
2081 class MarkFromRootsTask : public AbstractGangTask {
2082   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
2083   StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do

2084   SequentialSubTasksDone _subtasks;
2085   TaskTerminator _terminator;
2086   uint _active_workers;
2087 
2088 public:
2089   MarkFromRootsTask(uint active_workers) :
2090       AbstractGangTask(&quot;MarkFromRootsTask&quot;),
2091       _strong_roots_scope(active_workers),
2092       _subtasks(),
2093       _terminator(active_workers, ParCompactionManager::oop_task_queues()),
2094       _active_workers(active_workers) {
2095     _subtasks.set_n_threads(active_workers);
2096     _subtasks.set_n_tasks(ParallelRootType::sentinel);
2097   }
2098 
2099   virtual void work(uint worker_id) {
2100     for (uint task = 0; _subtasks.try_claim_task(task); /*empty*/ ) {
2101       mark_from_roots_work(static_cast&lt;ParallelRootType::Value&gt;(task), worker_id);
2102     }
2103     _subtasks.all_tasks_completed();
2104 
2105     PCAddThreadRootsMarkingTaskClosure closure(worker_id);
2106     Threads::possibly_parallel_threads_do(true /*parallel */, &amp;closure);
2107 









2108     if (_active_workers &gt; 1) {
2109       steal_marking_work(_terminator, worker_id);
2110     }
2111   }
2112 };
2113 
2114 class PCRefProcTask : public AbstractGangTask {
2115   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
2116   ProcessTask&amp; _task;
2117   uint _ergo_workers;
2118   TaskTerminator _terminator;
2119 
2120 public:
2121   PCRefProcTask(ProcessTask&amp; task, uint ergo_workers) :
2122       AbstractGangTask(&quot;PCRefProcTask&quot;),
2123       _task(task),
2124       _ergo_workers(ergo_workers),
2125       _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {
2126   }
2127 
</pre>
<hr />
<pre>
2218     Klass::clean_weak_klass_links(purged_class);
2219 
2220     // Clean JVMCI metadata handles.
2221     JVMCI_ONLY(JVMCI::do_unloading(purged_class));
2222   }
2223 
2224   _gc_tracer.report_object_count_after_gc(is_alive_closure());
2225 }
2226 
2227 void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {
2228   // Adjust the pointers to reflect the new locations
2229   GCTraceTime(Info, gc, phases) tm(&quot;Adjust Roots&quot;, &amp;_gc_timer);
2230 
2231   // Need new claim bits when tracing through and adjusting pointers.
2232   ClassLoaderDataGraph::clear_claimed_marks();
2233 
2234   PCAdjustPointerClosure oop_closure(cm);
2235 
2236   // General strong roots.
2237   Universe::oops_do(&amp;oop_closure);
<span class="line-removed">2238   JNIHandles::oops_do(&amp;oop_closure);   // Global (strong) JNI handles</span>
2239   Threads::oops_do(&amp;oop_closure, NULL);
2240   ObjectSynchronizer::oops_do(&amp;oop_closure);
2241   Management::oops_do(&amp;oop_closure);
2242   JvmtiExport::oops_do(&amp;oop_closure);
<span class="line-modified">2243   OopStorageSet::vm_global()-&gt;oops_do(&amp;oop_closure);</span>
2244   CLDToOopClosure cld_closure(&amp;oop_closure, ClassLoaderData::_claim_strong);
2245   ClassLoaderDataGraph::cld_do(&amp;cld_closure);
2246 
2247   // Now adjust pointers in remaining weak roots.  (All of which should
2248   // have been cleared if they pointed to non-surviving objects.)
2249   WeakProcessor::oops_do(&amp;oop_closure);
2250 
2251   CodeBlobToOopClosure adjust_from_blobs(&amp;oop_closure, CodeBlobToOopClosure::FixRelocations);
2252   CodeCache::blobs_do(&amp;adjust_from_blobs);
2253   AOT_ONLY(AOTLoader::oops_do(&amp;oop_closure);)
2254 
2255   ref_processor()-&gt;weak_oops_do(&amp;oop_closure);
2256   // Roots were visited so references into the young gen in roots
2257   // may have been scanned.  Process them also.
2258   // Should the reference processor have a span that excludes
2259   // young gen objects?
2260   PSScavenge::reference_processor()-&gt;weak_oops_do(&amp;oop_closure);
2261 }
2262 
2263 // Helper class to print 8 region numbers per line and then print the total at the end.
</pre>
</td>
<td>
<hr />
<pre>
  33 #include &quot;gc/parallel/parallelArguments.hpp&quot;
  34 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  35 #include &quot;gc/parallel/parMarkBitMap.inline.hpp&quot;
  36 #include &quot;gc/parallel/psAdaptiveSizePolicy.hpp&quot;
  37 #include &quot;gc/parallel/psCompactionManager.inline.hpp&quot;
  38 #include &quot;gc/parallel/psOldGen.hpp&quot;
  39 #include &quot;gc/parallel/psParallelCompact.inline.hpp&quot;
  40 #include &quot;gc/parallel/psPromotionManager.inline.hpp&quot;
  41 #include &quot;gc/parallel/psRootType.hpp&quot;
  42 #include &quot;gc/parallel/psScavenge.hpp&quot;
  43 #include &quot;gc/parallel/psYoungGen.hpp&quot;
  44 #include &quot;gc/shared/gcCause.hpp&quot;
  45 #include &quot;gc/shared/gcHeapSummary.hpp&quot;
  46 #include &quot;gc/shared/gcId.hpp&quot;
  47 #include &quot;gc/shared/gcLocker.hpp&quot;
  48 #include &quot;gc/shared/gcTimer.hpp&quot;
  49 #include &quot;gc/shared/gcTrace.hpp&quot;
  50 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  51 #include &quot;gc/shared/isGCActiveMark.hpp&quot;
  52 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
<span class="line-modified">  53 #include &quot;gc/shared/oopStorageSet.inline.hpp&quot;</span>
<span class="line-added">  54 #include &quot;gc/shared/oopStorageSetParState.inline.hpp&quot;</span>
  55 #include &quot;gc/shared/referencePolicy.hpp&quot;
  56 #include &quot;gc/shared/referenceProcessor.hpp&quot;
  57 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
  58 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
  59 #include &quot;gc/shared/taskTerminator.hpp&quot;
  60 #include &quot;gc/shared/weakProcessor.hpp&quot;
  61 #include &quot;gc/shared/workerPolicy.hpp&quot;
  62 #include &quot;gc/shared/workgroup.hpp&quot;
  63 #include &quot;logging/log.hpp&quot;
  64 #include &quot;memory/iterator.inline.hpp&quot;
  65 #include &quot;memory/resourceArea.hpp&quot;
  66 #include &quot;memory/universe.hpp&quot;
  67 #include &quot;oops/access.inline.hpp&quot;
  68 #include &quot;oops/instanceClassLoaderKlass.inline.hpp&quot;
  69 #include &quot;oops/instanceKlass.inline.hpp&quot;
  70 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;
  71 #include &quot;oops/methodData.hpp&quot;
  72 #include &quot;oops/objArrayKlass.inline.hpp&quot;
  73 #include &quot;oops/oop.inline.hpp&quot;
  74 #include &quot;runtime/atomic.hpp&quot;
</pre>
<hr />
<pre>
1999 
2000     thread-&gt;oops_do(&amp;mark_and_push_closure, &amp;mark_and_push_in_blobs);
2001 
2002     // Do the real work
2003     cm-&gt;follow_marking_stacks();
2004   }
2005 };
2006 
2007 static void mark_from_roots_work(ParallelRootType::Value root_type, uint worker_id) {
2008   assert(ParallelScavengeHeap::heap()-&gt;is_gc_active(), &quot;called outside gc&quot;);
2009 
2010   ParCompactionManager* cm =
2011     ParCompactionManager::gc_thread_compaction_manager(worker_id);
2012   PCMarkAndPushClosure mark_and_push_closure(cm);
2013 
2014   switch (root_type) {
2015     case ParallelRootType::universe:
2016       Universe::oops_do(&amp;mark_and_push_closure);
2017       break;
2018 




2019     case ParallelRootType::object_synchronizer:
2020       ObjectSynchronizer::oops_do(&amp;mark_and_push_closure);
2021       break;
2022 
2023     case ParallelRootType::management:
2024       Management::oops_do(&amp;mark_and_push_closure);
2025       break;
2026 
2027     case ParallelRootType::jvmti:
2028       JvmtiExport::oops_do(&amp;mark_and_push_closure);
2029       break;
2030 




2031     case ParallelRootType::class_loader_data:
2032       {
2033         CLDToOopClosure cld_closure(&amp;mark_and_push_closure, ClassLoaderData::_claim_strong);
2034         ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);
2035       }
2036       break;
2037 
2038     case ParallelRootType::code_cache:
2039       // Do not treat nmethods as strong roots for mark/sweep, since we can unload them.
2040       //ScavengableNMethods::scavengable_nmethods_do(CodeBlobToOopClosure(&amp;mark_and_push_closure));
2041       AOTLoader::oops_do(&amp;mark_and_push_closure);
2042       break;
2043 
2044     case ParallelRootType::sentinel:
2045     DEBUG_ONLY(default:) // DEBUG_ONLY hack will create compile error on release builds (-Wswitch) and runtime check on debug builds
2046       fatal(&quot;Bad enumeration value: %u&quot;, root_type);
2047       break;
2048   }
2049 
2050   // Do the real work
</pre>
<hr />
<pre>
2057   ParCompactionManager* cm =
2058     ParCompactionManager::gc_thread_compaction_manager(worker_id);
2059 
2060   oop obj = NULL;
2061   ObjArrayTask task;
2062   do {
2063     while (ParCompactionManager::steal_objarray(worker_id,  task)) {
2064       cm-&gt;follow_array((objArrayOop)task.obj(), task.index());
2065       cm-&gt;follow_marking_stacks();
2066     }
2067     while (ParCompactionManager::steal(worker_id, obj)) {
2068       cm-&gt;follow_contents(obj);
2069       cm-&gt;follow_marking_stacks();
2070     }
2071   } while (!terminator.offer_termination());
2072 }
2073 
2074 class MarkFromRootsTask : public AbstractGangTask {
2075   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
2076   StrongRootsScope _strong_roots_scope; // needed for Threads::possibly_parallel_threads_do
<span class="line-added">2077   OopStorageSetStrongParState&lt;false /* concurrent */, false /* is_const */&gt; _oop_storage_set_par_state;</span>
2078   SequentialSubTasksDone _subtasks;
2079   TaskTerminator _terminator;
2080   uint _active_workers;
2081 
2082 public:
2083   MarkFromRootsTask(uint active_workers) :
2084       AbstractGangTask(&quot;MarkFromRootsTask&quot;),
2085       _strong_roots_scope(active_workers),
2086       _subtasks(),
2087       _terminator(active_workers, ParCompactionManager::oop_task_queues()),
2088       _active_workers(active_workers) {
2089     _subtasks.set_n_threads(active_workers);
2090     _subtasks.set_n_tasks(ParallelRootType::sentinel);
2091   }
2092 
2093   virtual void work(uint worker_id) {
2094     for (uint task = 0; _subtasks.try_claim_task(task); /*empty*/ ) {
2095       mark_from_roots_work(static_cast&lt;ParallelRootType::Value&gt;(task), worker_id);
2096     }
2097     _subtasks.all_tasks_completed();
2098 
2099     PCAddThreadRootsMarkingTaskClosure closure(worker_id);
2100     Threads::possibly_parallel_threads_do(true /*parallel */, &amp;closure);
2101 
<span class="line-added">2102     // Mark from OopStorages</span>
<span class="line-added">2103     {</span>
<span class="line-added">2104       ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);</span>
<span class="line-added">2105       PCMarkAndPushClosure closure(cm);</span>
<span class="line-added">2106       _oop_storage_set_par_state.oops_do(&amp;closure);</span>
<span class="line-added">2107       // Do the real work</span>
<span class="line-added">2108       cm-&gt;follow_marking_stacks();</span>
<span class="line-added">2109     }</span>
<span class="line-added">2110 </span>
2111     if (_active_workers &gt; 1) {
2112       steal_marking_work(_terminator, worker_id);
2113     }
2114   }
2115 };
2116 
2117 class PCRefProcTask : public AbstractGangTask {
2118   typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;
2119   ProcessTask&amp; _task;
2120   uint _ergo_workers;
2121   TaskTerminator _terminator;
2122 
2123 public:
2124   PCRefProcTask(ProcessTask&amp; task, uint ergo_workers) :
2125       AbstractGangTask(&quot;PCRefProcTask&quot;),
2126       _task(task),
2127       _ergo_workers(ergo_workers),
2128       _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {
2129   }
2130 
</pre>
<hr />
<pre>
2221     Klass::clean_weak_klass_links(purged_class);
2222 
2223     // Clean JVMCI metadata handles.
2224     JVMCI_ONLY(JVMCI::do_unloading(purged_class));
2225   }
2226 
2227   _gc_tracer.report_object_count_after_gc(is_alive_closure());
2228 }
2229 
2230 void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {
2231   // Adjust the pointers to reflect the new locations
2232   GCTraceTime(Info, gc, phases) tm(&quot;Adjust Roots&quot;, &amp;_gc_timer);
2233 
2234   // Need new claim bits when tracing through and adjusting pointers.
2235   ClassLoaderDataGraph::clear_claimed_marks();
2236 
2237   PCAdjustPointerClosure oop_closure(cm);
2238 
2239   // General strong roots.
2240   Universe::oops_do(&amp;oop_closure);

2241   Threads::oops_do(&amp;oop_closure, NULL);
2242   ObjectSynchronizer::oops_do(&amp;oop_closure);
2243   Management::oops_do(&amp;oop_closure);
2244   JvmtiExport::oops_do(&amp;oop_closure);
<span class="line-modified">2245   OopStorageSet::strong_oops_do(&amp;oop_closure);</span>
2246   CLDToOopClosure cld_closure(&amp;oop_closure, ClassLoaderData::_claim_strong);
2247   ClassLoaderDataGraph::cld_do(&amp;cld_closure);
2248 
2249   // Now adjust pointers in remaining weak roots.  (All of which should
2250   // have been cleared if they pointed to non-surviving objects.)
2251   WeakProcessor::oops_do(&amp;oop_closure);
2252 
2253   CodeBlobToOopClosure adjust_from_blobs(&amp;oop_closure, CodeBlobToOopClosure::FixRelocations);
2254   CodeCache::blobs_do(&amp;adjust_from_blobs);
2255   AOT_ONLY(AOTLoader::oops_do(&amp;oop_closure);)
2256 
2257   ref_processor()-&gt;weak_oops_do(&amp;oop_closure);
2258   // Roots were visited so references into the young gen in roots
2259   // may have been scanned.  Process them also.
2260   // Should the reference processor have a span that excludes
2261   // young gen objects?
2262   PSScavenge::reference_processor()-&gt;weak_oops_do(&amp;oop_closure);
2263 }
2264 
2265 // Helper class to print 8 region numbers per line and then print the total at the end.
</pre>
</td>
</tr>
</table>
<center><a href="parallelScavengeHeap.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psRootType.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
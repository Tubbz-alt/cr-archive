<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/methodHandles.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 109     // If the entry is not set, it will throw AbstractMethodError.
 110   }
 111 }
 112 
 113 void MethodHandles::set_enabled(bool z) {
 114   if (_enabled != z) {
 115     guarantee(z, &quot;can only enable once&quot;);
 116     _enabled = z;
 117   }
 118 }
 119 
 120 // MemberName support
 121 
 122 // import java_lang_invoke_MemberName.*
 123 enum {
 124   IS_METHOD            = java_lang_invoke_MemberName::MN_IS_METHOD,
 125   IS_CONSTRUCTOR       = java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR,
 126   IS_FIELD             = java_lang_invoke_MemberName::MN_IS_FIELD,
 127   IS_TYPE              = java_lang_invoke_MemberName::MN_IS_TYPE,
 128   CALLER_SENSITIVE     = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,

 129   REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,
 130   REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,
 131   SEARCH_SUPERCLASSES  = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,
 132   SEARCH_INTERFACES    = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,
 133   ALL_KINDS      = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE
 134 };
 135 
 136 int MethodHandles::ref_kind_to_flags(int ref_kind) {
 137   assert(ref_kind_is_valid(ref_kind), &quot;%d&quot;, ref_kind);
 138   int flags = (ref_kind &lt;&lt; REFERENCE_KIND_SHIFT);
 139   if (ref_kind_is_field(ref_kind)) {
 140     flags |= IS_FIELD;
 141   } else if (ref_kind_is_method(ref_kind)) {
 142     flags |= IS_METHOD;
 143   } else if (ref_kind == JVM_REF_newInvokeSpecial) {
 144     flags |= IS_CONSTRUCTOR;
 145   }
 146   return flags;
 147 }
 148 
</pre>
<hr />
<pre>
 322   }
 323 
 324   Handle resolved_method = info.resolved_method_name();
 325   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),
 326          &quot;Should not change after link resolution&quot;);
 327 
 328   oop mname_oop = mname();
 329   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 330   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 331   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 332   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 333   // Note:  name and type can be lazily computed by resolve_MemberName,
 334   // if Java code needs them as resolved String and MethodType objects.
 335   // If relevant, the vtable or itable value is stored as vmindex.
 336   // This is done eagerly, since it is readily available without
 337   // constructing any new objects.
 338   return mname();
 339 }
 340 
 341 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {

 342   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 343   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);

 344   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 345   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
 346 
 347   oop mname_oop = mname();
 348   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 349   java_lang_invoke_MemberName::set_method (mname_oop, NULL);
 350   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);
<span class="line-modified"> 351   java_lang_invoke_MemberName::set_clazz  (mname_oop, fd.field_holder()-&gt;java_mirror());</span>
 352 
 353   oop type = field_signature_type_or_null(fd.signature());
 354   oop name = field_name_or_null(fd.name());
 355   if (name != NULL)
 356     java_lang_invoke_MemberName::set_name(mname_oop,   name);
 357   if (type != NULL)
 358     java_lang_invoke_MemberName::set_type(mname_oop,   type);
 359   // Note:  name and type can be lazily computed by resolve_MemberName,
 360   // if Java code needs them as resolved String and Class objects.
 361   // Note that the incoming type oop might be pre-resolved (non-null).
 362   // The base clazz and field offset (vmindex) must be eagerly stored,
 363   // because they unambiguously identify the field.
 364   // Although the fieldDescriptor::_index would also identify the field,
 365   // we do not use it, because it is harder to decode.
 366   // TO DO: maybe intern mname_oop
 367   return mname();
 368 }
 369 
 370 // JVM 2.9 Special Methods:
 371 // A method is signature polymorphic if and only if all of the following conditions hold :
</pre>
<hr />
<pre>
1090     // during runtime.
1091   }
1092 }
1093 
1094 //
1095 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1096 // They are the private interface between this JVM and the HotSpot-specific
1097 // Java code that implements JSR 292 method handles.
1098 //
1099 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1100 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1101 //
1102 
1103 #ifndef PRODUCT
1104 #define EACH_NAMED_CON(template, requirement) \
1105     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
1106     template(java_lang_invoke_MemberName,MN_IS_CONSTRUCTOR) \
1107     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1108     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1109     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \

1110     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1111     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1112     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1113     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
1114     template(java_lang_invoke_MemberName,MN_NESTMATE_CLASS) \
1115     template(java_lang_invoke_MemberName,MN_HIDDEN_CLASS) \
1116     template(java_lang_invoke_MemberName,MN_STRONG_LOADER_LINK) \
1117     template(java_lang_invoke_MemberName,MN_ACCESS_VM_ANNOTATIONS) \
1118     /*end*/
1119 
1120 #define IGNORE_REQ(req_expr) /* req_expr */
1121 #define ONE_PLUS(scope,value) 1+
1122 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1123 #define VALUE_COMMA(scope,value) scope::value,
1124 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1125 #define STRING_NULL(scope,value) #value &quot;\0&quot;
1126 static const char con_names[] = { EACH_NAMED_CON(STRING_NULL, IGNORE_REQ) };
1127 
1128 static bool advertise_con_value(int which) {
1129   if (which &lt; 0)  return false;
</pre>
</td>
<td>
<hr />
<pre>
 109     // If the entry is not set, it will throw AbstractMethodError.
 110   }
 111 }
 112 
 113 void MethodHandles::set_enabled(bool z) {
 114   if (_enabled != z) {
 115     guarantee(z, &quot;can only enable once&quot;);
 116     _enabled = z;
 117   }
 118 }
 119 
 120 // MemberName support
 121 
 122 // import java_lang_invoke_MemberName.*
 123 enum {
 124   IS_METHOD            = java_lang_invoke_MemberName::MN_IS_METHOD,
 125   IS_CONSTRUCTOR       = java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR,
 126   IS_FIELD             = java_lang_invoke_MemberName::MN_IS_FIELD,
 127   IS_TYPE              = java_lang_invoke_MemberName::MN_IS_TYPE,
 128   CALLER_SENSITIVE     = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,
<span class="line-added"> 129   TRUSTED_FINAL        = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,</span>
 130   REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,
 131   REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,
 132   SEARCH_SUPERCLASSES  = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,
 133   SEARCH_INTERFACES    = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,
 134   ALL_KINDS      = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE
 135 };
 136 
 137 int MethodHandles::ref_kind_to_flags(int ref_kind) {
 138   assert(ref_kind_is_valid(ref_kind), &quot;%d&quot;, ref_kind);
 139   int flags = (ref_kind &lt;&lt; REFERENCE_KIND_SHIFT);
 140   if (ref_kind_is_field(ref_kind)) {
 141     flags |= IS_FIELD;
 142   } else if (ref_kind_is_method(ref_kind)) {
 143     flags |= IS_METHOD;
 144   } else if (ref_kind == JVM_REF_newInvokeSpecial) {
 145     flags |= IS_CONSTRUCTOR;
 146   }
 147   return flags;
 148 }
 149 
</pre>
<hr />
<pre>
 323   }
 324 
 325   Handle resolved_method = info.resolved_method_name();
 326   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),
 327          &quot;Should not change after link resolution&quot;);
 328 
 329   oop mname_oop = mname();
 330   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 331   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 332   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 333   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 334   // Note:  name and type can be lazily computed by resolve_MemberName,
 335   // if Java code needs them as resolved String and MethodType objects.
 336   // If relevant, the vtable or itable value is stored as vmindex.
 337   // This is done eagerly, since it is readily available without
 338   // constructing any new objects.
 339   return mname();
 340 }
 341 
 342 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {
<span class="line-added"> 343   InstanceKlass* ik = fd.field_holder();</span>
 344   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 345   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-added"> 346   if (fd.is_trusted_final()) flags |= TRUSTED_FINAL;</span>
 347   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 348   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
 349 
 350   oop mname_oop = mname();
 351   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 352   java_lang_invoke_MemberName::set_method (mname_oop, NULL);
 353   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);
<span class="line-modified"> 354   java_lang_invoke_MemberName::set_clazz  (mname_oop, ik-&gt;java_mirror());</span>
 355 
 356   oop type = field_signature_type_or_null(fd.signature());
 357   oop name = field_name_or_null(fd.name());
 358   if (name != NULL)
 359     java_lang_invoke_MemberName::set_name(mname_oop,   name);
 360   if (type != NULL)
 361     java_lang_invoke_MemberName::set_type(mname_oop,   type);
 362   // Note:  name and type can be lazily computed by resolve_MemberName,
 363   // if Java code needs them as resolved String and Class objects.
 364   // Note that the incoming type oop might be pre-resolved (non-null).
 365   // The base clazz and field offset (vmindex) must be eagerly stored,
 366   // because they unambiguously identify the field.
 367   // Although the fieldDescriptor::_index would also identify the field,
 368   // we do not use it, because it is harder to decode.
 369   // TO DO: maybe intern mname_oop
 370   return mname();
 371 }
 372 
 373 // JVM 2.9 Special Methods:
 374 // A method is signature polymorphic if and only if all of the following conditions hold :
</pre>
<hr />
<pre>
1093     // during runtime.
1094   }
1095 }
1096 
1097 //
1098 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1099 // They are the private interface between this JVM and the HotSpot-specific
1100 // Java code that implements JSR 292 method handles.
1101 //
1102 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1103 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1104 //
1105 
1106 #ifndef PRODUCT
1107 #define EACH_NAMED_CON(template, requirement) \
1108     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
1109     template(java_lang_invoke_MemberName,MN_IS_CONSTRUCTOR) \
1110     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1111     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1112     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
<span class="line-added">1113     template(java_lang_invoke_MemberName,MN_TRUSTED_FINAL) \</span>
1114     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1115     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1116     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1117     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
1118     template(java_lang_invoke_MemberName,MN_NESTMATE_CLASS) \
1119     template(java_lang_invoke_MemberName,MN_HIDDEN_CLASS) \
1120     template(java_lang_invoke_MemberName,MN_STRONG_LOADER_LINK) \
1121     template(java_lang_invoke_MemberName,MN_ACCESS_VM_ANNOTATIONS) \
1122     /*end*/
1123 
1124 #define IGNORE_REQ(req_expr) /* req_expr */
1125 #define ONE_PLUS(scope,value) 1+
1126 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1127 #define VALUE_COMMA(scope,value) scope::value,
1128 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1129 #define STRING_NULL(scope,value) #value &quot;\0&quot;
1130 static const char con_names[] = { EACH_NAMED_CON(STRING_NULL, IGNORE_REQ) };
1131 
1132 static bool advertise_con_value(int which) {
1133   if (which &lt; 0)  return false;
</pre>
</td>
</tr>
</table>
<center><a href="jvm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
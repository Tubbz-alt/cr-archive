<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/interpreter/zero/bytecodeInterpreter.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_INTERPRETER_BYTECODEINTERPRETER_HPP
 26 #define SHARE_INTERPRETER_BYTECODEINTERPRETER_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/methodData.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;runtime/basicLock.hpp&quot;
 32 #include &quot;runtime/frame.hpp&quot;
 33 #include &quot;runtime/globals.hpp&quot;
 34 #include &quot;utilities/globalDefinitions.hpp&quot;
 35 #include &quot;utilities/macros.hpp&quot;
 36 
 37 // JavaStack Implementation
 38 #define MORE_STACK(count)  \
 39     (topOfStack -= ((count) * Interpreter::stackElementWords))
 40 
 41 // CVM definitions find hotspot equivalents...
 42 
 43 class InterpreterMacroAssembler;
 44 
 45 union VMJavaVal64 {
 46     jlong   l;
 47     jdouble d;
 48     uint32_t      v[2];
 49 };
 50 
 51 
 52 typedef class BytecodeInterpreter* interpreterState;
 53 
 54 struct call_message {
 55   class Method* _callee;           // method to call during call_method request
 56   address _callee_entry_point;     // address to jump to for call_method request
 57   int _bcp_advance;                // size of the invoke bytecode operation
 58 };
 59 
 60 struct osr_message {
 61   address _osr_buf;                 // the osr buffer
 62   address _osr_entry;               // the entry to the osr method
 63 };
 64 
 65 struct osr_result {
 66   nmethod* nm;                      // osr nmethod
 67   address return_addr;              // osr blob return address
 68 };
 69 
 70 // Result returned to frame manager
 71 union frame_manager_message {
 72   call_message _to_call;            // describes callee
 73   osr_message _osr;                 // describes the osr
 74   osr_result _osr_result;           // result of OSR request
 75 };
 76 
 77 class BytecodeInterpreter : StackObj {
 78 friend class SharedRuntime;
 79 friend class AbstractInterpreterGenerator;
 80 friend class ZeroInterpreterGenerator;
 81 friend class InterpreterMacroAssembler;
 82 friend class frame;
 83 friend class VMStructs;
 84 
 85 public:
 86     enum messages {
 87          no_request = 0,            // unused
 88          initialize,                // Perform one time interpreter initializations (assumes all switches set)
 89          // status message to C++ interpreter
 90          method_entry,              // initial method entry to interpreter
 91          method_resume,             // frame manager response to return_from_method request (assuming a frame to resume)
 92          deopt_resume,              // returning from a native call into a deopted frame
 93          deopt_resume2,             // deopt resume as a result of a PopFrame
 94          got_monitors,              // frame manager response to more_monitors request
 95          rethrow_exception,         // unwinding and throwing exception
 96          // requests to frame manager from C++ interpreter
 97          call_method,               // request for new frame from interpreter, manager responds with method_entry
 98          return_from_method,        // request from interpreter to unwind, manager responds with method_continue
 99          more_monitors,             // need a new monitor
100          throwing_exception,        // unwind stack and rethrow
101          popping_frame,             // unwind call and retry call
102          do_osr,                    // request this invocation be OSR&#39;s
103          early_return               // early return as commanded by jvmti
104     };
105 
106 private:
107     JavaThread*           _thread;        // the vm&#39;s java thread pointer
108     address               _bcp;           // instruction pointer
109     intptr_t*             _locals;        // local variable pointer
110     ConstantPoolCache*    _constants;     // constant pool cache
111     Method*               _method;        // method being executed
112     oop                   _mirror;        // mirror to klass containing method
113     DataLayout*           _mdx;           // compiler profiling data for current bytecode
114     intptr_t*             _stack;         // expression stack
115     messages              _msg;           // frame manager &lt;-&gt; interpreter message
116     frame_manager_message _result;        // result to frame manager
117     interpreterState      _prev_link;     // previous interpreter state
118     oop                   _oop_temp;      // mirror for interpreted native, null otherwise
119     intptr_t*             _stack_base;    // base of expression stack
120     intptr_t*             _stack_limit;   // limit of expression stack
121     BasicObjectLock*      _monitor_base;  // base of monitors on the native stack
122 
123 
124 public:
125   // Constructor is only used by the initialization step. All other instances are created
126   // by the frame manager.
127   BytecodeInterpreter(messages msg);
128 
129 //
130 // Deoptimization support
131 //
132 static void layout_interpreterState(interpreterState to_fill,
133                                     frame* caller,
134                                     frame* interpreter_frame,
135                                     Method* method,
136                                     intptr_t* locals,
137                                     intptr_t* stack,
138                                     intptr_t* stack_base,
139                                     intptr_t* monitor_base,
140                                     intptr_t* frame_bottom,
141                                     bool top_frame);
142 
143 /*
144  * Generic 32-bit wide &quot;Java slot&quot; definition. This type occurs
145  * in operand stacks, Java locals, object fields, constant pools.
146  */
147 union VMJavaVal32 {
148     jint     i;
149     jfloat   f;
150     class oopDesc*   r;
151     uint32_t raw;
152 };
153 
154 /*
155  * Generic 64-bit Java value definition
156  */
157 union VMJavaVal64 {
158     jlong   l;
159     jdouble d;
160     uint32_t      v[2];
161 };
162 
163 /*
164  * Generic 32-bit wide &quot;Java slot&quot; definition. This type occurs
165  * in Java locals, object fields, constant pools, and
166  * operand stacks (as a CVMStackVal32).
167  */
168 typedef union VMSlotVal32 {
169     VMJavaVal32    j;     /* For &quot;Java&quot; values */
170     address        a;     /* a return created by jsr or jsr_w */
171 } VMSlotVal32;
172 
173 
174 /*
175  * Generic 32-bit wide stack slot definition.
176  */
177 union VMStackVal32 {
178     VMJavaVal32    j;     /* For &quot;Java&quot; values */
179     VMSlotVal32    s;     /* any value from a &quot;slot&quot; or locals[] */
180 };
181 
182 inline JavaThread* thread() { return _thread; }
183 
184 inline address bcp() { return _bcp; }
185 inline void set_bcp(address new_bcp) { _bcp = new_bcp; }
186 
187 inline intptr_t* locals() { return _locals; }
188 
189 inline ConstantPoolCache* constants() { return _constants; }
190 inline Method* method() { return _method; }
191 inline DataLayout* mdx() { return _mdx; }
192 inline void set_mdx(DataLayout *new_mdx) { _mdx = new_mdx; }
193 
194 inline messages msg() { return _msg; }
195 inline void set_msg(messages new_msg) { _msg = new_msg; }
196 
197 inline Method* callee() { return _result._to_call._callee; }
198 inline void set_callee(Method* new_callee) { _result._to_call._callee = new_callee; }
199 inline void set_callee_entry_point(address entry) { _result._to_call._callee_entry_point = entry; }
200 inline void set_osr_buf(address buf) { _result._osr._osr_buf = buf; }
201 inline void set_osr_entry(address entry) { _result._osr._osr_entry = entry; }
202 inline int bcp_advance() { return _result._to_call._bcp_advance; }
203 inline void set_bcp_advance(int count) { _result._to_call._bcp_advance = count; }
204 
205 inline interpreterState prev() { return _prev_link; }
206 
207 inline intptr_t* stack() { return _stack; }
208 inline void set_stack(intptr_t* new_stack) { _stack = new_stack; }
209 
210 
211 inline intptr_t* stack_base() { return _stack_base; }
212 inline intptr_t* stack_limit() { return _stack_limit; }
213 
214 inline BasicObjectLock* monitor_base() { return _monitor_base; }
215 
216 /*
217  * 64-bit Arithmetic:
218  *
219  * The functions below follow the semantics of the
220  * ladd, land, ldiv, lmul, lor, lxor, and lrem bytecodes,
221  * respectively.
222  */
223 
224 static jlong VMlongAdd(jlong op1, jlong op2);
225 static jlong VMlongAnd(jlong op1, jlong op2);
226 static jlong VMlongDiv(jlong op1, jlong op2);
227 static jlong VMlongMul(jlong op1, jlong op2);
228 static jlong VMlongOr (jlong op1, jlong op2);
229 static jlong VMlongSub(jlong op1, jlong op2);
230 static jlong VMlongXor(jlong op1, jlong op2);
231 static jlong VMlongRem(jlong op1, jlong op2);
232 
233 /*
234  * Shift:
235  *
236  * The functions below follow the semantics of the
237  * lushr, lshl, and lshr bytecodes, respectively.
238  */
239 
240 static jlong VMlongUshr(jlong op1, jint op2);
241 static jlong VMlongShl (jlong op1, jint op2);
242 static jlong VMlongShr (jlong op1, jint op2);
243 
244 /*
245  * Unary:
246  *
247  * Return the negation of &quot;op&quot; (-op), according to
248  * the semantics of the lneg bytecode.
249  */
250 
251 static jlong VMlongNeg(jlong op);
252 
253 /*
254  * Return the complement of &quot;op&quot; (~op)
255  */
256 
257 static jlong VMlongNot(jlong op);
258 
259 
260 /*
261  * Comparisons to 0:
262  */
263 
264 static int32_t VMlongLtz(jlong op);     /* op &lt;= 0 */
265 static int32_t VMlongGez(jlong op);     /* op &gt;= 0 */
266 static int32_t VMlongEqz(jlong op);     /* op == 0 */
267 
268 /*
269  * Between operands:
270  */
271 
272 static int32_t VMlongEq(jlong op1, jlong op2);    /* op1 == op2 */
273 static int32_t VMlongNe(jlong op1, jlong op2);    /* op1 != op2 */
274 static int32_t VMlongGe(jlong op1, jlong op2);    /* op1 &gt;= op2 */
275 static int32_t VMlongLe(jlong op1, jlong op2);    /* op1 &lt;= op2 */
276 static int32_t VMlongLt(jlong op1, jlong op2);    /* op1 &lt;  op2 */
277 static int32_t VMlongGt(jlong op1, jlong op2);    /* op1 &gt;  op2 */
278 
279 /*
280  * Comparisons (returning an jint value: 0, 1, or -1)
281  *
282  * Between operands:
283  *
284  * Compare &quot;op1&quot; and &quot;op2&quot; according to the semantics of the
285  * &quot;lcmp&quot; bytecode.
286  */
287 
288 static int32_t VMlongCompare(jlong op1, jlong op2);
289 
290 /*
291  * Convert int to long, according to &quot;i2l&quot; bytecode semantics
292  */
293 static jlong VMint2Long(jint val);
294 
295 /*
296  * Convert long to int, according to &quot;l2i&quot; bytecode semantics
297  */
298 static jint VMlong2Int(jlong val);
299 
300 /*
301  * Convert long to float, according to &quot;l2f&quot; bytecode semantics
302  */
303 static jfloat VMlong2Float(jlong val);
304 
305 /*
306  * Convert long to double, according to &quot;l2d&quot; bytecode semantics
307  */
308 static jdouble VMlong2Double(jlong val);
309 
310 /*
311  * Java floating-point float value manipulation.
312  *
313  * The result argument is, once again, an lvalue.
314  *
315  * Arithmetic:
316  *
317  * The functions below follow the semantics of the
318  * fadd, fsub, fmul, fdiv, and frem bytecodes,
319  * respectively.
320  */
321 
322 static jfloat VMfloatAdd(jfloat op1, jfloat op2);
323 static jfloat VMfloatSub(jfloat op1, jfloat op2);
324 static jfloat VMfloatMul(jfloat op1, jfloat op2);
325 static jfloat VMfloatDiv(jfloat op1, jfloat op2);
326 static jfloat VMfloatRem(jfloat op1, jfloat op2);
327 
328 /*
329  * Unary:
330  *
331  * Return the negation of &quot;op&quot; (-op), according to
332  * the semantics of the fneg bytecode.
333  */
334 
335 static jfloat VMfloatNeg(jfloat op);
336 
337 /*
338  * Comparisons (returning an int value: 0, 1, or -1)
339  *
340  * Between operands:
341  *
342  * Compare &quot;op1&quot; and &quot;op2&quot; according to the semantics of the
343  * &quot;fcmpl&quot; (direction is -1) or &quot;fcmpg&quot; (direction is 1) bytecodes.
344  */
345 
346 static int32_t VMfloatCompare(jfloat op1, jfloat op2,
347                               int32_t direction);
348 /*
349  * Conversion:
350  */
351 
352 /*
353  * Convert float to double, according to &quot;f2d&quot; bytecode semantics
354  */
355 
356 static jdouble VMfloat2Double(jfloat op);
357 
358 /*
359  ******************************************
360  * Java double floating-point manipulation.
361  ******************************************
362  *
363  * The result argument is, once again, an lvalue.
364  *
365  * Conversions:
366  */
367 
368 /*
369  * Convert double to int, according to &quot;d2i&quot; bytecode semantics
370  */
371 
372 static jint VMdouble2Int(jdouble val);
373 
374 /*
375  * Convert double to float, according to &quot;d2f&quot; bytecode semantics
376  */
377 
378 static jfloat VMdouble2Float(jdouble val);
379 
380 /*
381  * Convert int to double, according to &quot;i2d&quot; bytecode semantics
382  */
383 
384 static jdouble VMint2Double(jint val);
385 
386 /*
387  * Arithmetic:
388  *
389  * The functions below follow the semantics of the
390  * dadd, dsub, ddiv, dmul, and drem bytecodes, respectively.
391  */
392 
393 static jdouble VMdoubleAdd(jdouble op1, jdouble op2);
394 static jdouble VMdoubleSub(jdouble op1, jdouble op2);
395 static jdouble VMdoubleDiv(jdouble op1, jdouble op2);
396 static jdouble VMdoubleMul(jdouble op1, jdouble op2);
397 static jdouble VMdoubleRem(jdouble op1, jdouble op2);
398 
399 /*
400  * Unary:
401  *
402  * Return the negation of &quot;op&quot; (-op), according to
403  * the semantics of the dneg bytecode.
404  */
405 
406 static jdouble VMdoubleNeg(jdouble op);
407 
408 /*
409  * Comparisons (returning an int32_t value: 0, 1, or -1)
410  *
411  * Between operands:
412  *
413  * Compare &quot;op1&quot; and &quot;op2&quot; according to the semantics of the
414  * &quot;dcmpl&quot; (direction is -1) or &quot;dcmpg&quot; (direction is 1) bytecodes.
415  */
416 
417 static int32_t VMdoubleCompare(jdouble op1, jdouble op2, int32_t direction);
418 
419 /*
420  * Copy two typeless 32-bit words from one location to another.
421  * This is semantically equivalent to:
422  *
423  * to[0] = from[0];
424  * to[1] = from[1];
425  *
426  * but this interface is provided for those platforms that could
427  * optimize this into a single 64-bit transfer.
428  */
429 
430 static void VMmemCopy64(uint32_t to[2], const uint32_t from[2]);
431 
432 
433 // Arithmetic operations
434 
435 /*
436  * Java arithmetic methods.
437  * The functions below follow the semantics of the
438  * iadd, isub, imul, idiv, irem, iand, ior, ixor,
439  * and ineg bytecodes, respectively.
440  */
441 
442 static jint VMintAdd(jint op1, jint op2);
443 static jint VMintSub(jint op1, jint op2);
444 static jint VMintMul(jint op1, jint op2);
445 static jint VMintDiv(jint op1, jint op2);
446 static jint VMintRem(jint op1, jint op2);
447 static jint VMintAnd(jint op1, jint op2);
448 static jint VMintOr (jint op1, jint op2);
449 static jint VMintXor(jint op1, jint op2);
450 
451 /*
452  * Shift Operation:
453  * The functions below follow the semantics of the
454  * iushr, ishl, and ishr bytecodes, respectively.
455  */
456 
457 static juint VMintUshr(jint op, jint num);
458 static jint VMintShl (jint op, jint num);
459 static jint VMintShr (jint op, jint num);
460 
461 /*
462  * Unary Operation:
463  *
464  * Return the negation of &quot;op&quot; (-op), according to
465  * the semantics of the ineg bytecode.
466  */
467 
468 static jint VMintNeg(jint op);
469 
470 /*
471  * Int Conversions:
472  */
473 
474 /*
475  * Convert int to float, according to &quot;i2f&quot; bytecode semantics
476  */
477 
478 static jfloat VMint2Float(jint val);
479 
480 /*
481  * Convert int to byte, according to &quot;i2b&quot; bytecode semantics
482  */
483 
484 static jbyte VMint2Byte(jint val);
485 
486 /*
487  * Convert int to char, according to &quot;i2c&quot; bytecode semantics
488  */
489 
490 static jchar VMint2Char(jint val);
491 
492 /*
493  * Convert int to short, according to &quot;i2s&quot; bytecode semantics
494  */
495 
496 static jshort VMint2Short(jint val);
497 
498 /*=========================================================================
499  * Bytecode interpreter operations
500  *=======================================================================*/
501 
502 static void dup(intptr_t *tos);
503 static void dup2(intptr_t *tos);
504 static void dup_x1(intptr_t *tos);    /* insert top word two down */
505 static void dup_x2(intptr_t *tos);    /* insert top word three down  */
506 static void dup2_x1(intptr_t *tos);   /* insert top 2 slots three down */
507 static void dup2_x2(intptr_t *tos);   /* insert top 2 slots four down */
508 static void swap(intptr_t *tos);      /* swap top two elements */
509 
510 // umm don&#39;t like this method modifies its object
511 
512 // The Interpreter used when
513 static void run(interpreterState istate);
514 // The interpreter used if JVMTI needs interpreter events
515 static void runWithChecks(interpreterState istate);
516 static void End_Of_Interpreter(void);
517 
518 // Inline static functions for Java Stack and Local manipulation
519 
520 static address stack_slot(intptr_t *tos, int offset);
521 static jint stack_int(intptr_t *tos, int offset);
522 static jfloat stack_float(intptr_t *tos, int offset);
523 static oop stack_object(intptr_t *tos, int offset);
524 static jdouble stack_double(intptr_t *tos, int offset);
525 static jlong stack_long(intptr_t *tos, int offset);
526 
527 // only used for value types
528 static void set_stack_slot(intptr_t *tos, address value, int offset);
529 static void set_stack_int(intptr_t *tos, int value, int offset);
530 static void set_stack_float(intptr_t *tos, jfloat value, int offset);
531 static void set_stack_object(intptr_t *tos, oop value, int offset);
532 
533 // needs to be platform dep for the 32 bit platforms.
534 static void set_stack_double(intptr_t *tos, jdouble value, int offset);
535 static void set_stack_long(intptr_t *tos, jlong value, int offset);
536 
537 static void set_stack_double_from_addr(intptr_t *tos, address addr, int offset);
538 static void set_stack_long_from_addr(intptr_t *tos, address addr, int offset);
539 
540 // Locals
541 
542 static address locals_slot(intptr_t* locals, int offset);
543 static jint locals_int(intptr_t* locals, int offset);
544 static jfloat locals_float(intptr_t* locals, int offset);
545 static oop locals_object(intptr_t* locals, int offset);
546 static jdouble locals_double(intptr_t* locals, int offset);
547 static jlong locals_long(intptr_t* locals, int offset);
548 
549 static address locals_long_at(intptr_t* locals, int offset);
550 static address locals_double_at(intptr_t* locals, int offset);
551 
552 static void set_locals_slot(intptr_t *locals, address value, int offset);
553 static void set_locals_int(intptr_t *locals, jint value, int offset);
554 static void set_locals_float(intptr_t *locals, jfloat value, int offset);
555 static void set_locals_object(intptr_t *locals, oop value, int offset);
556 static void set_locals_double(intptr_t *locals, jdouble value, int offset);
557 static void set_locals_long(intptr_t *locals, jlong value, int offset);
558 static void set_locals_double_from_addr(intptr_t *locals,
559                                    address addr, int offset);
560 static void set_locals_long_from_addr(intptr_t *locals,
561                                    address addr, int offset);
562 
563 static void astore(intptr_t* topOfStack, int stack_offset,
564                    intptr_t* locals,     int locals_offset);
565 
566 // Support for dup and swap
567 static void copy_stack_slot(intptr_t *tos, int from_offset, int to_offset);
568 
569 #ifndef PRODUCT
570 static const char* C_msg(BytecodeInterpreter::messages msg);
571 void print();
572 #endif // PRODUCT
573 
574 # include &quot;bytecodeInterpreter_zero.hpp&quot;
575 
576 }; // BytecodeInterpreter
577 
578 #endif // SHARE_INTERPRETER_BYTECODEINTERPRETER_HPP
    </pre>
  </body>
</html>
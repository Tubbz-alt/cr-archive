<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/rewriter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="invocationCounter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/rewriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
387     // call to calculate the length.
388     bc_length = Bytecodes::length_for(c);
389     if (bc_length == 0) {
390       bc_length = Bytecodes::length_at(method, bcp);
391 
392       // length_at will put us at the bytecode after the one modified
393       // by &#39;wide&#39;. We don&#39;t currently examine any of the bytecodes
394       // modified by wide, but in case we do in the future...
395       if (c == Bytecodes::_wide) {
396         prefix_length = 1;
397         c = (Bytecodes::Code)bcp[1];
398       }
399     }
400 
401     // Continuing with an invalid bytecode will fail in the loop below.
402     // So guarantee here.
403     guarantee(bc_length &gt; 0, &quot;Verifier should have caught this invalid bytecode&quot;);
404 
405     switch (c) {
406       case Bytecodes::_lookupswitch   : {
<span class="line-modified">407 #ifndef CC_INTERP</span>
408         Bytecode_lookupswitch bc(method, bcp);
409         (*bcp) = (
410           bc.number_of_pairs() &lt; BinarySwitchThreshold
411           ? Bytecodes::_fast_linearswitch
412           : Bytecodes::_fast_binaryswitch
413         );
414 #endif
415         break;
416       }
417       case Bytecodes::_fast_linearswitch:
418       case Bytecodes::_fast_binaryswitch: {
<span class="line-modified">419 #ifndef CC_INTERP</span>
420         (*bcp) = Bytecodes::_lookupswitch;
421 #endif
422         break;
423       }
424 
425       case Bytecodes::_invokespecial  : {
426         rewrite_invokespecial(bcp, prefix_length+1, reverse, invokespecial_error);
427         break;
428       }
429 
430       case Bytecodes::_putstatic      :
431       case Bytecodes::_putfield       : {
432         if (!reverse) {
433           // Check if any final field of the class given as parameter is modified
434           // outside of initializer methods of the class. Fields that are modified
435           // are marked with a flag. For marked fields, the compilers do not perform
436           // constant folding (as the field can be changed after initialization).
437           //
438           // The check is performed after verification and only if verification has
439           // succeeded. Therefore, the class is guaranteed to be well-formed.
</pre>
</td>
<td>
<hr />
<pre>
387     // call to calculate the length.
388     bc_length = Bytecodes::length_for(c);
389     if (bc_length == 0) {
390       bc_length = Bytecodes::length_at(method, bcp);
391 
392       // length_at will put us at the bytecode after the one modified
393       // by &#39;wide&#39;. We don&#39;t currently examine any of the bytecodes
394       // modified by wide, but in case we do in the future...
395       if (c == Bytecodes::_wide) {
396         prefix_length = 1;
397         c = (Bytecodes::Code)bcp[1];
398       }
399     }
400 
401     // Continuing with an invalid bytecode will fail in the loop below.
402     // So guarantee here.
403     guarantee(bc_length &gt; 0, &quot;Verifier should have caught this invalid bytecode&quot;);
404 
405     switch (c) {
406       case Bytecodes::_lookupswitch   : {
<span class="line-modified">407 #ifndef ZERO</span>
408         Bytecode_lookupswitch bc(method, bcp);
409         (*bcp) = (
410           bc.number_of_pairs() &lt; BinarySwitchThreshold
411           ? Bytecodes::_fast_linearswitch
412           : Bytecodes::_fast_binaryswitch
413         );
414 #endif
415         break;
416       }
417       case Bytecodes::_fast_linearswitch:
418       case Bytecodes::_fast_binaryswitch: {
<span class="line-modified">419 #ifndef ZERO</span>
420         (*bcp) = Bytecodes::_lookupswitch;
421 #endif
422         break;
423       }
424 
425       case Bytecodes::_invokespecial  : {
426         rewrite_invokespecial(bcp, prefix_length+1, reverse, invokespecial_error);
427         break;
428       }
429 
430       case Bytecodes::_putstatic      :
431       case Bytecodes::_putfield       : {
432         if (!reverse) {
433           // Check if any final field of the class given as parameter is modified
434           // outside of initializer methods of the class. Fields that are modified
435           // are marked with a flag. For marked fields, the compilers do not perform
436           // constant folding (as the field can be changed after initialization).
437           //
438           // The check is performed after verification and only if verification has
439           // succeeded. Therefore, the class is guaranteed to be well-formed.
</pre>
</td>
</tr>
</table>
<center><a href="invocationCounter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateInterpreter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
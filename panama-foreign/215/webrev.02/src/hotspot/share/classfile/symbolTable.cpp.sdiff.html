<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/symbolTable.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stringTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/symbolTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
496     sym = allocate_symbol(name, len, heap);
497     if (_local_table-&gt;insert(THREAD, lookup, sym, &amp;rehash_warning, &amp;clean_hint)) {
498       break;
499     }
500     // In case another thread did a concurrent add, return value already in the table.
501     // This could fail if the symbol got deleted concurrently, so loop back until success.
502     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {
503       sym = stg.get_res_sym();
504       break;
505     }
506   } while(true);
507 
508   update_needs_rehash(rehash_warning);
509 
510   if (clean_hint) {
511     mark_has_items_to_clean();
512     check_concurrent_work();
513   }
514 
515   assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;found dead symbol&quot;);







516   return sym;
517 }
518 
519 Symbol* SymbolTable::new_permanent_symbol(const char* name) {
520   unsigned int hash = 0;
521   int len = (int)strlen(name);
522   Symbol* sym = SymbolTable::lookup_only(name, len, hash);
523   if (sym == NULL) {
524     sym = do_add_if_needed(name, len, hash, false);
525   }
526   if (!sym-&gt;is_permanent()) {
527     sym-&gt;make_permanent();
528     log_trace_symboltable_helper(sym, &quot;Asked for a permanent symbol, but got a regular one&quot;);
529   }
530   return sym;
531 }
532 
533 struct SizeFunc : StackObj {
534   size_t operator()(Symbol** value) {
535     assert(value != NULL, &quot;expected valid value&quot;);
</pre>
</td>
<td>
<hr />
<pre>
496     sym = allocate_symbol(name, len, heap);
497     if (_local_table-&gt;insert(THREAD, lookup, sym, &amp;rehash_warning, &amp;clean_hint)) {
498       break;
499     }
500     // In case another thread did a concurrent add, return value already in the table.
501     // This could fail if the symbol got deleted concurrently, so loop back until success.
502     if (_local_table-&gt;get(THREAD, lookup, stg, &amp;rehash_warning)) {
503       sym = stg.get_res_sym();
504       break;
505     }
506   } while(true);
507 
508   update_needs_rehash(rehash_warning);
509 
510   if (clean_hint) {
511     mark_has_items_to_clean();
512     check_concurrent_work();
513   }
514 
515   assert((sym == NULL) || sym-&gt;refcount() != 0, &quot;found dead symbol&quot;);
<span class="line-added">516 #if INCLUDE_CDS</span>
<span class="line-added">517   if (DumpSharedSpaces) {</span>
<span class="line-added">518     if (sym != NULL) {</span>
<span class="line-added">519       MetaspaceShared::add_symbol(sym);</span>
<span class="line-added">520     }</span>
<span class="line-added">521   }</span>
<span class="line-added">522 #endif</span>
523   return sym;
524 }
525 
526 Symbol* SymbolTable::new_permanent_symbol(const char* name) {
527   unsigned int hash = 0;
528   int len = (int)strlen(name);
529   Symbol* sym = SymbolTable::lookup_only(name, len, hash);
530   if (sym == NULL) {
531     sym = do_add_if_needed(name, len, hash, false);
532   }
533   if (!sym-&gt;is_permanent()) {
534     sym-&gt;make_permanent();
535     log_trace_symboltable_helper(sym, &quot;Asked for a permanent symbol, but got a regular one&quot;);
536   }
537   return sym;
538 }
539 
540 struct SizeFunc : StackObj {
541   size_t operator()(Symbol** value) {
542     assert(value != NULL, &quot;expected valid value&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="stringTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
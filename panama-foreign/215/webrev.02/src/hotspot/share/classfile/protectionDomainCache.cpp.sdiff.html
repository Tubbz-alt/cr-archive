<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/protectionDomainCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="moduleEntry.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="protectionDomainCache.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/protectionDomainCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;classfile/dictionary.hpp&quot;
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;

 30 #include &quot;logging/log.hpp&quot;
 31 #include &quot;logging/logStream.hpp&quot;
 32 #include &quot;memory/iterator.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/weakHandle.inline.hpp&quot;
 36 #include &quot;utilities/hashtable.inline.hpp&quot;
 37 
 38 unsigned int ProtectionDomainCacheTable::compute_hash(Handle protection_domain) {
 39   // Identity hash can safepoint, so keep protection domain in a Handle.
 40   return (unsigned int)(protection_domain-&gt;identity_hash());
 41 }
 42 
 43 int ProtectionDomainCacheTable::index_for(Handle protection_domain) {
 44   return hash_to_index(compute_hash(protection_domain));
 45 }
 46 
 47 ProtectionDomainCacheTable::ProtectionDomainCacheTable(int table_size)
<span class="line-modified"> 48   : Hashtable&lt;WeakHandle&lt;vm_weak_data&gt;, mtClass&gt;(table_size, sizeof(ProtectionDomainCacheEntry))</span>
 49 {   _dead_entries = false;
 50     _total_oops_removed = 0;
 51 }
 52 
 53 void ProtectionDomainCacheTable::trigger_cleanup() {
 54   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);
 55   _dead_entries = true;
 56   Service_lock-&gt;notify_all();
 57 }
 58 
 59 class CleanProtectionDomainEntries : public CLDClosure {
 60   void do_cld(ClassLoaderData* data) {
 61     Dictionary* dictionary = data-&gt;dictionary();
 62     if (dictionary != NULL) {
 63       dictionary-&gt;clean_cached_protection_domains();
 64     }
 65   }
 66 };
 67 
 68 void ProtectionDomainCacheTable::unlink() {
</pre>
<hr />
<pre>
 76     CleanProtectionDomainEntries clean;
 77     ClassLoaderDataGraph::loaded_cld_do(&amp;clean);
 78   }
 79 
 80   MutexLocker ml(SystemDictionary_lock);
 81   int oops_removed = 0;
 82   for (int i = 0; i &lt; table_size(); ++i) {
 83     ProtectionDomainCacheEntry** p = bucket_addr(i);
 84     ProtectionDomainCacheEntry* entry = bucket(i);
 85     while (entry != NULL) {
 86       oop pd = entry-&gt;object_no_keepalive();
 87       if (pd != NULL) {
 88         p = entry-&gt;next_addr();
 89       } else {
 90         oops_removed++;
 91         LogTarget(Debug, protectiondomain, table) lt;
 92         if (lt.is_enabled()) {
 93           LogStream ls(lt);
 94           ls.print_cr(&quot;protection domain unlinked at %d&quot;, i);
 95         }
<span class="line-modified"> 96         entry-&gt;literal().release();</span>
 97         *p = entry-&gt;next();
 98         free_entry(entry);
 99       }
100       entry = *p;
101     }
102   }
103   _total_oops_removed += oops_removed;
104   _dead_entries = false;
105 }
106 
107 void ProtectionDomainCacheTable::print_on(outputStream* st) const {
108   assert_locked_or_safepoint(SystemDictionary_lock);
109   st-&gt;print_cr(&quot;Protection domain cache table (table_size=%d, classes=%d)&quot;,
110                table_size(), number_of_entries());
111   for (int index = 0; index &lt; table_size(); index++) {
112     for (ProtectionDomainCacheEntry* probe = bucket(index);
113                                      probe != NULL;
114                                      probe = probe-&gt;next()) {
115       st-&gt;print_cr(&quot;%4d: protection_domain: &quot; PTR_FORMAT, index, p2i(probe-&gt;object_no_keepalive()));
116     }
</pre>
<hr />
<pre>
163     if (e-&gt;object_no_keepalive() == protection_domain()) {
164       return e;
165     }
166   }
167 
168   return NULL;
169 }
170 
171 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::add_entry(int index, unsigned int hash, Handle protection_domain) {
172   assert_locked_or_safepoint(SystemDictionary_lock);
173   assert(index == index_for(protection_domain), &quot;incorrect index?&quot;);
174   assert(find_entry(index, protection_domain) == NULL, &quot;no double entry&quot;);
175 
176   LogTarget(Debug, protectiondomain, table) lt;
177   if (lt.is_enabled()) {
178     LogStream ls(lt);
179     ls.print(&quot;protection domain added &quot;);
180     protection_domain-&gt;print_value_on(&amp;ls);
181     ls.cr();
182   }
<span class="line-modified">183   WeakHandle&lt;vm_weak_data&gt; w = WeakHandle&lt;vm_weak_data&gt;::create(protection_domain);</span>
184   ProtectionDomainCacheEntry* p = new_entry(hash, w);
<span class="line-modified">185   Hashtable&lt;WeakHandle&lt;vm_weak_data&gt;, mtClass&gt;::add_entry(index, p);</span>
186   return p;
187 }
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 27 #include &quot;classfile/dictionary.hpp&quot;
 28 #include &quot;classfile/protectionDomainCache.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;logging/logStream.hpp&quot;
 33 #include &quot;memory/iterator.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;oops/weakHandle.inline.hpp&quot;
 37 #include &quot;utilities/hashtable.inline.hpp&quot;
 38 
 39 unsigned int ProtectionDomainCacheTable::compute_hash(Handle protection_domain) {
 40   // Identity hash can safepoint, so keep protection domain in a Handle.
 41   return (unsigned int)(protection_domain-&gt;identity_hash());
 42 }
 43 
 44 int ProtectionDomainCacheTable::index_for(Handle protection_domain) {
 45   return hash_to_index(compute_hash(protection_domain));
 46 }
 47 
 48 ProtectionDomainCacheTable::ProtectionDomainCacheTable(int table_size)
<span class="line-modified"> 49   : Hashtable&lt;WeakHandle, mtClass&gt;(table_size, sizeof(ProtectionDomainCacheEntry))</span>
 50 {   _dead_entries = false;
 51     _total_oops_removed = 0;
 52 }
 53 
 54 void ProtectionDomainCacheTable::trigger_cleanup() {
 55   MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);
 56   _dead_entries = true;
 57   Service_lock-&gt;notify_all();
 58 }
 59 
 60 class CleanProtectionDomainEntries : public CLDClosure {
 61   void do_cld(ClassLoaderData* data) {
 62     Dictionary* dictionary = data-&gt;dictionary();
 63     if (dictionary != NULL) {
 64       dictionary-&gt;clean_cached_protection_domains();
 65     }
 66   }
 67 };
 68 
 69 void ProtectionDomainCacheTable::unlink() {
</pre>
<hr />
<pre>
 77     CleanProtectionDomainEntries clean;
 78     ClassLoaderDataGraph::loaded_cld_do(&amp;clean);
 79   }
 80 
 81   MutexLocker ml(SystemDictionary_lock);
 82   int oops_removed = 0;
 83   for (int i = 0; i &lt; table_size(); ++i) {
 84     ProtectionDomainCacheEntry** p = bucket_addr(i);
 85     ProtectionDomainCacheEntry* entry = bucket(i);
 86     while (entry != NULL) {
 87       oop pd = entry-&gt;object_no_keepalive();
 88       if (pd != NULL) {
 89         p = entry-&gt;next_addr();
 90       } else {
 91         oops_removed++;
 92         LogTarget(Debug, protectiondomain, table) lt;
 93         if (lt.is_enabled()) {
 94           LogStream ls(lt);
 95           ls.print_cr(&quot;protection domain unlinked at %d&quot;, i);
 96         }
<span class="line-modified"> 97         entry-&gt;literal().release(OopStorageSet::vm_weak());</span>
 98         *p = entry-&gt;next();
 99         free_entry(entry);
100       }
101       entry = *p;
102     }
103   }
104   _total_oops_removed += oops_removed;
105   _dead_entries = false;
106 }
107 
108 void ProtectionDomainCacheTable::print_on(outputStream* st) const {
109   assert_locked_or_safepoint(SystemDictionary_lock);
110   st-&gt;print_cr(&quot;Protection domain cache table (table_size=%d, classes=%d)&quot;,
111                table_size(), number_of_entries());
112   for (int index = 0; index &lt; table_size(); index++) {
113     for (ProtectionDomainCacheEntry* probe = bucket(index);
114                                      probe != NULL;
115                                      probe = probe-&gt;next()) {
116       st-&gt;print_cr(&quot;%4d: protection_domain: &quot; PTR_FORMAT, index, p2i(probe-&gt;object_no_keepalive()));
117     }
</pre>
<hr />
<pre>
164     if (e-&gt;object_no_keepalive() == protection_domain()) {
165       return e;
166     }
167   }
168 
169   return NULL;
170 }
171 
172 ProtectionDomainCacheEntry* ProtectionDomainCacheTable::add_entry(int index, unsigned int hash, Handle protection_domain) {
173   assert_locked_or_safepoint(SystemDictionary_lock);
174   assert(index == index_for(protection_domain), &quot;incorrect index?&quot;);
175   assert(find_entry(index, protection_domain) == NULL, &quot;no double entry&quot;);
176 
177   LogTarget(Debug, protectiondomain, table) lt;
178   if (lt.is_enabled()) {
179     LogStream ls(lt);
180     ls.print(&quot;protection domain added &quot;);
181     protection_domain-&gt;print_value_on(&amp;ls);
182     ls.cr();
183   }
<span class="line-modified">184   WeakHandle w(OopStorageSet::vm_weak(), protection_domain);</span>
185   ProtectionDomainCacheEntry* p = new_entry(hash, w);
<span class="line-modified">186   Hashtable&lt;WeakHandle, mtClass&gt;::add_entry(index, p);</span>
187   return p;
188 }
</pre>
</td>
</tr>
</table>
<center><a href="moduleEntry.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="protectionDomainCache.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
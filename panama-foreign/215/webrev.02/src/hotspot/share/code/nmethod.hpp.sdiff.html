<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/nmethod.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledIC.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compilerDirectives.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
243   // whether to restart collecting RTM locking abort statistic again.
244   RTMState _rtm_state;
245 #endif
246 
247   // Nmethod Flushing lock. If non-zero, then the nmethod is not removed
248   // and is not made into a zombie. However, once the nmethod is made into
249   // a zombie, it will be locked one final time if CompiledMethodUnload
250   // event processing needs to be done.
251   volatile jint _lock_count;
252 
253   // not_entrant method removal. Each mark_sweep pass will update
254   // this mark to current sweep invocation count if it is seen on the
255   // stack.  An not_entrant method can be removed when there are no
256   // more activations, i.e., when the _stack_traversal_mark is less than
257   // current sweep traversal index.
258   volatile long _stack_traversal_mark;
259 
260   // The _hotness_counter indicates the hotness of a method. The higher
261   // the value the hotter the method. The hotness counter of a nmethod is
262   // set to [(ReservedCodeCacheSize / (1024 * 1024)) * 2] each time the method
<span class="line-modified">263   // is active while stack scanning (mark_active_nmethods()). The hotness</span>
264   // counter is decreased (by 1) while sweeping.
265   int _hotness_counter;
266 
267   // Local state used to keep track of whether unloading is happening or not
268   volatile uint8_t _is_unloading_state;
269 
270   // These are used for compiled synchronized native methods to
271   // locate the owner and stack slot for the BasicLock so that we can
272   // properly revoke the bias of the owner if necessary. They are
273   // needed because there is no debug information for compiled native
274   // wrappers and the oop maps are insufficient to allow
275   // frame::retrieve_receiver() to work. Currently they are expected
276   // to be byte offsets from the Java stack pointer for maximum code
277   // sharing between platforms. Note that currently biased locking
278   // will never cause Class instances to be biased but this code
279   // handles the static synchronized case as well.
280   // JVMTI&#39;s GetLocalInstance() also uses these offsets to find the receiver
281   // for non-static native wrapper frames.
282   ByteSize _native_receiver_sp_offset;
283   ByteSize _native_basic_lock_sp_offset;
</pre>
</td>
<td>
<hr />
<pre>
243   // whether to restart collecting RTM locking abort statistic again.
244   RTMState _rtm_state;
245 #endif
246 
247   // Nmethod Flushing lock. If non-zero, then the nmethod is not removed
248   // and is not made into a zombie. However, once the nmethod is made into
249   // a zombie, it will be locked one final time if CompiledMethodUnload
250   // event processing needs to be done.
251   volatile jint _lock_count;
252 
253   // not_entrant method removal. Each mark_sweep pass will update
254   // this mark to current sweep invocation count if it is seen on the
255   // stack.  An not_entrant method can be removed when there are no
256   // more activations, i.e., when the _stack_traversal_mark is less than
257   // current sweep traversal index.
258   volatile long _stack_traversal_mark;
259 
260   // The _hotness_counter indicates the hotness of a method. The higher
261   // the value the hotter the method. The hotness counter of a nmethod is
262   // set to [(ReservedCodeCacheSize / (1024 * 1024)) * 2] each time the method
<span class="line-modified">263   // is active while stack scanning (do_stack_scanning()). The hotness</span>
264   // counter is decreased (by 1) while sweeping.
265   int _hotness_counter;
266 
267   // Local state used to keep track of whether unloading is happening or not
268   volatile uint8_t _is_unloading_state;
269 
270   // These are used for compiled synchronized native methods to
271   // locate the owner and stack slot for the BasicLock so that we can
272   // properly revoke the bias of the owner if necessary. They are
273   // needed because there is no debug information for compiled native
274   // wrappers and the oop maps are insufficient to allow
275   // frame::retrieve_receiver() to work. Currently they are expected
276   // to be byte offsets from the Java stack pointer for maximum code
277   // sharing between platforms. Note that currently biased locking
278   // will never cause Class instances to be biased but this code
279   // handles the static synchronized case as well.
280   // JVMTI&#39;s GetLocalInstance() also uses these offsets to find the receiver
281   // for non-static native wrapper frames.
282   ByteSize _native_receiver_sp_offset;
283   ByteSize _native_basic_lock_sp_offset;
</pre>
</td>
</tr>
</table>
<center><a href="compiledIC.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compilerDirectives.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
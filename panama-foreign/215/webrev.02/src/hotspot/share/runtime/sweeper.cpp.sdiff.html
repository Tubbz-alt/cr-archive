<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sweeper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sweeper.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sweeper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
124 size_t NMethodSweeper::_total_flushed_size              = 0;   // Total number of bytes flushed from the code cache
125 Tickspan NMethodSweeper::_total_time_sweeping;                 // Accumulated time sweeping
126 Tickspan NMethodSweeper::_total_time_this_sweep;               // Total time this sweep
127 Tickspan NMethodSweeper::_peak_sweep_time;                     // Peak time for a full sweep
128 Tickspan NMethodSweeper::_peak_sweep_fraction_time;            // Peak time sweeping one fraction
129 
130 class MarkActivationClosure: public CodeBlobClosure {
131 public:
132   virtual void do_code_blob(CodeBlob* cb) {
133     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
134     nmethod* nm = (nmethod*)cb;
135     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
136     // If we see an activation belonging to a non_entrant nmethod, we mark it.
137     if (nm-&gt;is_not_entrant()) {
138       nm-&gt;mark_as_seen_on_stack();
139     }
140   }
141 };
142 static MarkActivationClosure mark_activation_closure;
143 
<span class="line-removed">144 class SetHotnessClosure: public CodeBlobClosure {</span>
<span class="line-removed">145 public:</span>
<span class="line-removed">146   virtual void do_code_blob(CodeBlob* cb) {</span>
<span class="line-removed">147     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);</span>
<span class="line-removed">148     nmethod* nm = (nmethod*)cb;</span>
<span class="line-removed">149     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());</span>
<span class="line-removed">150   }</span>
<span class="line-removed">151 };</span>
<span class="line-removed">152 static SetHotnessClosure set_hotness_closure;</span>
<span class="line-removed">153 </span>
<span class="line-removed">154 </span>
155 int NMethodSweeper::hotness_counter_reset_val() {
156   if (_hotness_counter_reset_val == 0) {
157     _hotness_counter_reset_val = (ReservedCodeCacheSize &lt; M) ? 1 : (ReservedCodeCacheSize / M) * 2;
158   }
159   return _hotness_counter_reset_val;
160 }
161 bool NMethodSweeper::wait_for_stack_scanning() {
162   return _current.end();
163 }
164 
165 class NMethodMarkingClosure : public HandshakeClosure {
166 private:
167   CodeBlobClosure* _cl;
168 public:
169   NMethodMarkingClosure(CodeBlobClosure* cl) : HandshakeClosure(&quot;NMethodMarking&quot;), _cl(cl) {}
170   void do_thread(Thread* thread) {
171     if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
172       JavaThread* jt = (JavaThread*) thread;
173       jt-&gt;nmethods_do(_cl);
174     }
</pre>
<hr />
<pre>
185   // to scan stacks
186   if (!MethodFlushing) {
187     return NULL;
188   }
189 
190   // Check for restart
191   assert(_current.method() == NULL, &quot;should only happen between sweeper cycles&quot;);
192   assert(wait_for_stack_scanning(), &quot;should only happen between sweeper cycles&quot;);
193 
194   _seen = 0;
195   _current = CompiledMethodIterator(CompiledMethodIterator::all_blobs);
196   // Initialize to first nmethod
197   _current.next();
198   _traversals += 1;
199   _total_time_this_sweep = Tickspan();
200 
201   if (PrintMethodFlushing) {
202     tty-&gt;print_cr(&quot;### Sweep: stack traversal %ld&quot;, _traversals);
203   }
204   return &amp;mark_activation_closure;
<span class="line-removed">205 }</span>
<span class="line-removed">206 </span>
<span class="line-removed">207 CodeBlobClosure* NMethodSweeper::prepare_reset_hotness_counters() {</span>
<span class="line-removed">208   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be executed at a safepoint&quot;);</span>
<span class="line-removed">209 </span>
<span class="line-removed">210   // If we do not want to reclaim not-entrant or zombie methods there is no need</span>
<span class="line-removed">211   // to scan stacks</span>
<span class="line-removed">212   if (!MethodFlushing) {</span>
<span class="line-removed">213     return NULL;</span>
<span class="line-removed">214   }</span>
<span class="line-removed">215 </span>
<span class="line-removed">216   // Check for restart</span>
<span class="line-removed">217   if (_current.method() != NULL) {</span>
<span class="line-removed">218     if (_current.method()-&gt;is_nmethod()) {</span>
<span class="line-removed">219       assert(CodeCache::find_blob_unsafe(_current.method()) == _current.method(), &quot;Sweeper nmethod cached state invalid&quot;);</span>
<span class="line-removed">220     } else if (_current.method()-&gt;is_aot()) {</span>
<span class="line-removed">221       assert(CodeCache::find_blob_unsafe(_current.method()-&gt;code_begin()) == _current.method(), &quot;Sweeper AOT method cached state invalid&quot;);</span>
<span class="line-removed">222     } else {</span>
<span class="line-removed">223       ShouldNotReachHere();</span>
<span class="line-removed">224     }</span>
<span class="line-removed">225   }</span>
<span class="line-removed">226 </span>
<span class="line-removed">227   return &amp;set_hotness_closure;</span>
228 }
229 
230 /**
231   * This function triggers a VM operation that does stack scanning of active
232   * methods. Stack scanning is mandatory for the sweeper to make progress.
233   */
234 void NMethodSweeper::do_stack_scanning() {
235   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
236   if (wait_for_stack_scanning()) {
237     CodeBlobClosure* code_cl;
238     {
239       MutexLocker ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);
240       code_cl = prepare_mark_active_nmethods();
241     }
242     if (code_cl != NULL) {
243       NMethodMarkingClosure nm_cl(code_cl);
244       Handshake::execute(&amp;nm_cl);
245     }
246   }
247 }
</pre>
</td>
<td>
<hr />
<pre>
124 size_t NMethodSweeper::_total_flushed_size              = 0;   // Total number of bytes flushed from the code cache
125 Tickspan NMethodSweeper::_total_time_sweeping;                 // Accumulated time sweeping
126 Tickspan NMethodSweeper::_total_time_this_sweep;               // Total time this sweep
127 Tickspan NMethodSweeper::_peak_sweep_time;                     // Peak time for a full sweep
128 Tickspan NMethodSweeper::_peak_sweep_fraction_time;            // Peak time sweeping one fraction
129 
130 class MarkActivationClosure: public CodeBlobClosure {
131 public:
132   virtual void do_code_blob(CodeBlob* cb) {
133     assert(cb-&gt;is_nmethod(), &quot;CodeBlob should be nmethod&quot;);
134     nmethod* nm = (nmethod*)cb;
135     nm-&gt;set_hotness_counter(NMethodSweeper::hotness_counter_reset_val());
136     // If we see an activation belonging to a non_entrant nmethod, we mark it.
137     if (nm-&gt;is_not_entrant()) {
138       nm-&gt;mark_as_seen_on_stack();
139     }
140   }
141 };
142 static MarkActivationClosure mark_activation_closure;
143 











144 int NMethodSweeper::hotness_counter_reset_val() {
145   if (_hotness_counter_reset_val == 0) {
146     _hotness_counter_reset_val = (ReservedCodeCacheSize &lt; M) ? 1 : (ReservedCodeCacheSize / M) * 2;
147   }
148   return _hotness_counter_reset_val;
149 }
150 bool NMethodSweeper::wait_for_stack_scanning() {
151   return _current.end();
152 }
153 
154 class NMethodMarkingClosure : public HandshakeClosure {
155 private:
156   CodeBlobClosure* _cl;
157 public:
158   NMethodMarkingClosure(CodeBlobClosure* cl) : HandshakeClosure(&quot;NMethodMarking&quot;), _cl(cl) {}
159   void do_thread(Thread* thread) {
160     if (thread-&gt;is_Java_thread() &amp;&amp; ! thread-&gt;is_Code_cache_sweeper_thread()) {
161       JavaThread* jt = (JavaThread*) thread;
162       jt-&gt;nmethods_do(_cl);
163     }
</pre>
<hr />
<pre>
174   // to scan stacks
175   if (!MethodFlushing) {
176     return NULL;
177   }
178 
179   // Check for restart
180   assert(_current.method() == NULL, &quot;should only happen between sweeper cycles&quot;);
181   assert(wait_for_stack_scanning(), &quot;should only happen between sweeper cycles&quot;);
182 
183   _seen = 0;
184   _current = CompiledMethodIterator(CompiledMethodIterator::all_blobs);
185   // Initialize to first nmethod
186   _current.next();
187   _traversals += 1;
188   _total_time_this_sweep = Tickspan();
189 
190   if (PrintMethodFlushing) {
191     tty-&gt;print_cr(&quot;### Sweep: stack traversal %ld&quot;, _traversals);
192   }
193   return &amp;mark_activation_closure;























194 }
195 
196 /**
197   * This function triggers a VM operation that does stack scanning of active
198   * methods. Stack scanning is mandatory for the sweeper to make progress.
199   */
200 void NMethodSweeper::do_stack_scanning() {
201   assert(!CodeCache_lock-&gt;owned_by_self(), &quot;just checking&quot;);
202   if (wait_for_stack_scanning()) {
203     CodeBlobClosure* code_cl;
204     {
205       MutexLocker ccl(CodeCache_lock, Mutex::_no_safepoint_check_flag);
206       code_cl = prepare_mark_active_nmethods();
207     }
208     if (code_cl != NULL) {
209       NMethodMarkingClosure nm_cl(code_cl);
210       Handshake::execute(&amp;nm_cl);
211     }
212   }
213 }
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sweeper.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
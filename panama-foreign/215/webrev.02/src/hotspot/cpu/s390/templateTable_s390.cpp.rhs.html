<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/templateTable_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (c) 2016, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  34 #include &quot;oops/methodData.hpp&quot;</span>
  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubRoutines.hpp&quot;
  42 #include &quot;runtime/synchronizer.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #ifdef PRODUCT
  46 #define __ _masm-&gt;
  47 #define BLOCK_COMMENT(str)
  48 #define BIND(label)        __ bind(label);
  49 #else
  50 #define __ (PRODUCT_ONLY(false&amp;&amp;)Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
  51 #define BLOCK_COMMENT(str) __ block_comment(str)
  52 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  53 #endif
  54 
  55 // The assumed minimum size of a BranchTableBlock.
  56 // The actual size of each block heavily depends on the CPU capabilities and,
  57 // of course, on the logic implemented in each block.
  58 #ifdef ASSERT
  59   #define BTB_MINSIZE 256
  60 #else
  61   #define BTB_MINSIZE  64
  62 #endif
  63 
  64 #ifdef ASSERT
  65 // Macro to open a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  66 #define BTB_BEGIN(lbl, alignment, name)                                        \
  67   __ align_address(alignment);                                                 \
  68   __ bind(lbl);                                                                \
  69   { unsigned int b_off = __ offset();                                          \
  70     uintptr_t   b_addr = (uintptr_t)__ pc();                                   \
  71     __ z_larl(Z_R0, (int64_t)0);     /* Check current address alignment. */    \
  72     __ z_slgr(Z_R0, br_tab);         /* Current Address must be equal    */    \
  73     __ z_slgr(Z_R0, flags);          /* to calculated branch target.     */    \
  74     __ z_brc(Assembler::bcondLogZero, 3); /* skip trap if ok. */               \
  75     __ z_illtrap(0x55);                                                        \
  76     guarantee(b_addr%alignment == 0, &quot;bad alignment at begin of block&quot; name);
  77 
  78 // Macro to close a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  79 #define BTB_END(lbl, alignment, name)                                          \
  80     uintptr_t   e_addr = (uintptr_t)__ pc();                                   \
  81     unsigned int e_off = __ offset();                                          \
  82     unsigned int len   = e_off-b_off;                                          \
  83     if (len &gt; alignment) {                                                     \
  84       tty-&gt;print_cr(&quot;%4d of %4d @ &quot; INTPTR_FORMAT &quot;: Block len for %s&quot;,        \
  85                     len, alignment, e_addr-len, name);                         \
  86       guarantee(len &lt;= alignment, &quot;block too large&quot;);                          \
  87     }                                                                          \
  88     guarantee(len == e_addr-b_addr, &quot;block len mismatch&quot;);                     \
  89   }
  90 #else
  91 // Macro to open a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  92 #define BTB_BEGIN(lbl, alignment, name)                                        \
  93   __ align_address(alignment);                                                 \
  94   __ bind(lbl);                                                                \
  95   { unsigned int b_off = __ offset();                                          \
  96     uintptr_t   b_addr = (uintptr_t)__ pc();                                   \
  97     guarantee(b_addr%alignment == 0, &quot;bad alignment at begin of block&quot; name);
  98 
  99 // Macro to close a BranchTableBlock (a piece of code that is branched to by a calculated branch).
 100 #define BTB_END(lbl, alignment, name)                                          \
 101     uintptr_t   e_addr = (uintptr_t)__ pc();                                   \
 102     unsigned int e_off = __ offset();                                          \
 103     unsigned int len   = e_off-b_off;                                          \
 104     if (len &gt; alignment) {                                                     \
 105       tty-&gt;print_cr(&quot;%4d of %4d @ &quot; INTPTR_FORMAT &quot;: Block len for %s&quot;,        \
 106                     len, alignment, e_addr-len, name);                         \
 107       guarantee(len &lt;= alignment, &quot;block too large&quot;);                          \
 108     }                                                                          \
 109     guarantee(len == e_addr-b_addr, &quot;block len mismatch&quot;);                     \
 110   }
 111 #endif // ASSERT
 112 
 113 // Platform-dependent initialization.
 114 
 115 void TemplateTable::pd_initialize() {
 116   // No specific initialization.
 117 }
 118 
 119 // Address computation: local variables
 120 
 121 static inline Address iaddress(int n) {
 122   return Address(Z_locals, Interpreter::local_offset_in_bytes(n));
 123 }
 124 
 125 static inline Address laddress(int n) {
 126   return iaddress(n + 1);
 127 }
 128 
 129 static inline Address faddress(int n) {
 130   return iaddress(n);
 131 }
 132 
 133 static inline Address daddress(int n) {
 134   return laddress(n);
 135 }
 136 
 137 static inline Address aaddress(int n) {
 138   return iaddress(n);
 139 }
 140 
 141 // Pass NULL, if no shift instruction should be emitted.
 142 static inline Address iaddress(InterpreterMacroAssembler *masm, Register r) {
 143   if (masm) {
 144     masm-&gt;z_sllg(r, r, LogBytesPerWord);  // index2bytes
 145   }
 146   return Address(Z_locals, r, Interpreter::local_offset_in_bytes(0));
 147 }
 148 
 149 // Pass NULL, if no shift instruction should be emitted.
 150 static inline Address laddress(InterpreterMacroAssembler *masm, Register r) {
 151   if (masm) {
 152     masm-&gt;z_sllg(r, r, LogBytesPerWord);  // index2bytes
 153   }
 154   return Address(Z_locals, r, Interpreter::local_offset_in_bytes(1) );
 155 }
 156 
 157 static inline Address faddress(InterpreterMacroAssembler *masm, Register r) {
 158   return iaddress(masm, r);
 159 }
 160 
 161 static inline Address daddress(InterpreterMacroAssembler *masm, Register r) {
 162   return laddress(masm, r);
 163 }
 164 
 165 static inline Address aaddress(InterpreterMacroAssembler *masm, Register r) {
 166   return iaddress(masm, r);
 167 }
 168 
 169 // At top of Java expression stack which may be different than esp(). It
 170 // isn&#39;t for category 1 objects.
 171 static inline Address at_tos(int slot = 0) {
 172   return Address(Z_esp, Interpreter::expr_offset_in_bytes(slot));
 173 }
 174 
 175 // Condition conversion
 176 static Assembler::branch_condition j_not(TemplateTable::Condition cc) {
 177   switch (cc) {
 178     case TemplateTable::equal :
 179       return Assembler::bcondNotEqual;
 180     case TemplateTable::not_equal :
 181       return Assembler::bcondEqual;
 182     case TemplateTable::less :
 183       return Assembler::bcondNotLow;
 184     case TemplateTable::less_equal :
 185       return Assembler::bcondHigh;
 186     case TemplateTable::greater :
 187       return Assembler::bcondNotHigh;
 188     case TemplateTable::greater_equal:
 189       return Assembler::bcondLow;
 190   }
 191   ShouldNotReachHere();
 192   return Assembler::bcondZero;
 193 }
 194 
 195 // Do an oop store like *(base + offset) = val
 196 // offset can be a register or a constant.
 197 static void do_oop_store(InterpreterMacroAssembler* _masm,
 198                          const Address&amp;     addr,
 199                          Register           val,         // Noreg means always null.
 200                          Register           tmp1,
 201                          Register           tmp2,
 202                          Register           tmp3,
 203                          DecoratorSet       decorators) {
 204   assert_different_registers(tmp1, tmp2, tmp3, val, addr.base());
 205   __ store_heap_oop(val, addr, tmp1, tmp2, tmp3, decorators);
 206 }
 207 
 208 static void do_oop_load(InterpreterMacroAssembler* _masm,
 209                         const Address&amp; addr,
 210                         Register dst,
 211                         Register tmp1,
 212                         Register tmp2,
 213                         DecoratorSet decorators) {
 214   assert_different_registers(addr.base(), tmp1, tmp2);
 215   assert_different_registers(dst, tmp1, tmp2);
 216   __ load_heap_oop(dst, addr, tmp1, tmp2, decorators);
 217 }
 218 
 219 Address TemplateTable::at_bcp(int offset) {
 220   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 221   return Address(Z_bcp, offset);
 222 }
 223 
 224 void TemplateTable::patch_bytecode(Bytecodes::Code bc,
 225                                    Register        bc_reg,
 226                                    Register        temp_reg,
 227                                    bool            load_bc_into_bc_reg, // = true
 228                                    int             byte_no) {
 229   if (!RewriteBytecodes) { return; }
 230 
 231   NearLabel L_patch_done;
 232   BLOCK_COMMENT(&quot;patch_bytecode {&quot;);
 233 
 234   switch (bc) {
 235     case Bytecodes::_fast_aputfield:
 236     case Bytecodes::_fast_bputfield:
 237     case Bytecodes::_fast_zputfield:
 238     case Bytecodes::_fast_cputfield:
 239     case Bytecodes::_fast_dputfield:
 240     case Bytecodes::_fast_fputfield:
 241     case Bytecodes::_fast_iputfield:
 242     case Bytecodes::_fast_lputfield:
 243     case Bytecodes::_fast_sputfield:
 244       {
 245         // We skip bytecode quickening for putfield instructions when
 246         // the put_code written to the constant pool cache is zero.
 247         // This is required so that every execution of this instruction
 248         // calls out to InterpreterRuntime::resolve_get_put to do
 249         // additional, required work.
 250         assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 251         assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 252         __ get_cache_and_index_and_bytecode_at_bcp(Z_R1_scratch, bc_reg,
 253                                                    temp_reg, byte_no, 1);
 254         __ load_const_optimized(bc_reg, bc);
 255         __ compareU32_and_branch(temp_reg, (intptr_t)0,
 256                                  Assembler::bcondZero, L_patch_done);
 257       }
 258       break;
 259     default:
 260       assert(byte_no == -1, &quot;sanity&quot;);
 261       // The pair bytecodes have already done the load.
 262       if (load_bc_into_bc_reg) {
 263         __ load_const_optimized(bc_reg, bc);
 264       }
 265       break;
 266   }
 267 
 268   if (JvmtiExport::can_post_breakpoint()) {
 269 
 270     Label   L_fast_patch;
 271 
 272     // If a breakpoint is present we can&#39;t rewrite the stream directly.
 273     __ z_cli(at_bcp(0), Bytecodes::_breakpoint);
 274     __ z_brne(L_fast_patch);
 275     __ get_method(temp_reg);
 276     // Let breakpoint table handling rewrite to quicker bytecode.
 277     __ call_VM_static(noreg,
 278                       CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at),
 279                       temp_reg, Z_R13, bc_reg);
 280     __ z_bru(L_patch_done);
 281 
 282     __ bind(L_fast_patch);
 283   }
 284 
 285 #ifdef ASSERT
 286   NearLabel   L_okay;
 287 
 288   // We load into 64 bits, since this works on any CPU.
 289   __ z_llgc(temp_reg, at_bcp(0));
 290   __ compareU32_and_branch(temp_reg, Bytecodes::java_code(bc),
 291                             Assembler::bcondEqual, L_okay        );
 292   __ compareU32_and_branch(temp_reg, bc_reg, Assembler::bcondEqual, L_okay);
 293   __ stop_static(&quot;patching the wrong bytecode&quot;);
 294   __ bind(L_okay);
 295 #endif
 296 
 297   // Patch bytecode.
 298   __ z_stc(bc_reg, at_bcp(0));
 299 
 300   __ bind(L_patch_done);
 301   BLOCK_COMMENT(&quot;} patch_bytecode&quot;);
 302 }
 303 
 304 // Individual instructions
 305 
 306 void TemplateTable::nop() {
 307   transition(vtos, vtos);
 308 }
 309 
 310 void TemplateTable::shouldnotreachhere() {
 311   transition(vtos, vtos);
 312   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 313 }
 314 
 315 void TemplateTable::aconst_null() {
 316   transition(vtos, atos);
 317   __ clear_reg(Z_tos, true, false);
 318 }
 319 
 320 void TemplateTable::iconst(int value) {
 321   transition(vtos, itos);
 322   // Zero extension of the iconst makes zero extension at runtime obsolete.
 323   __ load_const_optimized(Z_tos, ((unsigned long)(unsigned int)value));
 324 }
 325 
 326 void TemplateTable::lconst(int value) {
 327   transition(vtos, ltos);
 328   __ load_const_optimized(Z_tos, value);
 329 }
 330 
 331 // No pc-relative load/store for floats.
 332 void TemplateTable::fconst(int value) {
 333   transition(vtos, ftos);
 334   static float   one = 1.0f, two = 2.0f;
 335 
 336   switch (value) {
 337     case 0:
 338       __ z_lzer(Z_ftos);
 339       return;
 340     case 1:
 341       __ load_absolute_address(Z_R1_scratch, (address) &amp;one);
 342       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch), false);
 343       return;
 344     case 2:
 345       __ load_absolute_address(Z_R1_scratch, (address) &amp;two);
 346       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch), false);
 347       return;
 348     default:
 349       ShouldNotReachHere();
 350       return;
 351   }
 352 }
 353 
 354 void TemplateTable::dconst(int value) {
 355   transition(vtos, dtos);
 356   static double one = 1.0;
 357 
 358   switch (value) {
 359     case 0:
 360       __ z_lzdr(Z_ftos);
 361       return;
 362     case 1:
 363       __ load_absolute_address(Z_R1_scratch, (address) &amp;one);
 364       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch));
 365       return;
 366     default:
 367       ShouldNotReachHere();
 368       return;
 369   }
 370 }
 371 
 372 void TemplateTable::bipush() {
 373   transition(vtos, itos);
 374   __ z_lb(Z_tos, at_bcp(1));
 375 }
 376 
 377 void TemplateTable::sipush() {
 378   transition(vtos, itos);
 379   __ get_2_byte_integer_at_bcp(Z_tos, 1, InterpreterMacroAssembler::Signed);
 380 }
 381 
 382 
 383 void TemplateTable::ldc(bool wide) {
 384   transition(vtos, vtos);
 385   Label call_ldc, notFloat, notClass, notInt, Done;
 386   const Register RcpIndex = Z_tmp_1;
 387   const Register Rtags = Z_ARG2;
 388 
 389   if (wide) {
 390     __ get_2_byte_integer_at_bcp(RcpIndex, 1, InterpreterMacroAssembler::Unsigned);
 391   } else {
 392     __ z_llgc(RcpIndex, at_bcp(1));
 393   }
 394 
 395   __ get_cpool_and_tags(Z_tmp_2, Rtags);
 396 
 397   const int      base_offset = ConstantPool::header_size() * wordSize;
 398   const int      tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 399   const Register Raddr_type = Rtags;
 400 
 401   // Get address of type.
 402   __ add2reg_with_index(Raddr_type, tags_offset, RcpIndex, Rtags);
 403 
 404   __ z_cli(0, Raddr_type, JVM_CONSTANT_UnresolvedClass);
 405   __ z_bre(call_ldc);    // Unresolved class - get the resolved class.
 406 
 407   __ z_cli(0, Raddr_type, JVM_CONSTANT_UnresolvedClassInError);
 408   __ z_bre(call_ldc);    // Unresolved class in error state - call into runtime
 409                          // to throw the error from the first resolution attempt.
 410 
 411   __ z_cli(0, Raddr_type, JVM_CONSTANT_Class);
 412   __ z_brne(notClass);   // Resolved class - need to call vm to get java
 413                          // mirror of the class.
 414 
 415   // We deal with a class. Call vm to do the appropriate.
 416   __ bind(call_ldc);
 417   __ load_const_optimized(Z_ARG2, wide);
 418   call_VM(Z_RET, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), Z_ARG2);
 419   __ push_ptr(Z_RET);
 420   __ z_bru(Done);
 421 
 422   // Not a class.
 423   __ bind(notClass);
 424   Register RcpOffset = RcpIndex;
 425   __ z_sllg(RcpOffset, RcpIndex, LogBytesPerWord); // Convert index to offset.
 426   __ z_cli(0, Raddr_type, JVM_CONSTANT_Float);
 427   __ z_brne(notFloat);
 428 
 429   // ftos
 430   __ mem2freg_opt(Z_ftos, Address(Z_tmp_2, RcpOffset, base_offset), false);
 431   __ push_f();
 432   __ z_bru(Done);
 433 
 434   __ bind(notFloat);
 435   __ z_cli(0, Raddr_type, JVM_CONSTANT_Integer);
 436   __ z_brne(notInt);
 437 
 438   // itos
 439   __ mem2reg_opt(Z_tos, Address(Z_tmp_2, RcpOffset, base_offset), false);
 440   __ push_i(Z_tos);
 441   __ z_bru(Done);
 442 
 443   // assume the tag is for condy; if not, the VM runtime will tell us
 444   __ bind(notInt);
 445   condy_helper(Done);
 446 
 447   __ bind(Done);
 448 }
 449 
 450 // Fast path for caching oop constants.
 451 // %%% We should use this to handle Class and String constants also.
 452 // %%% It will simplify the ldc/primitive path considerably.
 453 void TemplateTable::fast_aldc(bool wide) {
 454   transition(vtos, atos);
 455 
 456   const Register index = Z_tmp_2;
 457   int            index_size = wide ? sizeof(u2) : sizeof(u1);
 458   Label          L_do_resolve, L_resolved;
 459 
 460   // We are resolved if the resolved reference cache entry contains a
 461   // non-null object (CallSite, etc.).
 462   __ get_cache_index_at_bcp(index, 1, index_size);  // Load index.
 463   __ load_resolved_reference_at_index(Z_tos, index);
 464   __ z_ltgr(Z_tos, Z_tos);
 465   __ z_bre(L_do_resolve);
 466 
 467   // Convert null sentinel to NULL.
 468   __ load_const_optimized(Z_R1_scratch, (intptr_t)Universe::the_null_sentinel_addr());
 469   __ z_cg(Z_tos, Address(Z_R1_scratch));
 470   __ z_brne(L_resolved);
 471   __ clear_reg(Z_tos);
 472   __ z_bru(L_resolved);
 473 
 474   __ bind(L_do_resolve);
 475   // First time invocation - must resolve first.
 476   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 477   __ load_const_optimized(Z_ARG1, (int)bytecode());
 478   __ call_VM(Z_tos, entry, Z_ARG1);
 479 
 480   __ bind(L_resolved);
 481   __ verify_oop(Z_tos);
 482 }
 483 
 484 void TemplateTable::ldc2_w() {
 485   transition(vtos, vtos);
 486   Label notDouble, notLong, Done;
 487 
 488   // Z_tmp_1 = index of cp entry
 489   __ get_2_byte_integer_at_bcp(Z_tmp_1, 1, InterpreterMacroAssembler::Unsigned);
 490 
 491   __ get_cpool_and_tags(Z_tmp_2, Z_tos);
 492 
 493   const int base_offset = ConstantPool::header_size() * wordSize;
 494   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 495 
 496   // Get address of type.
 497   __ add2reg_with_index(Z_tos, tags_offset, Z_tos, Z_tmp_1);
 498 
 499   // Index needed in both branches, so calculate here.
 500   __ z_sllg(Z_tmp_1, Z_tmp_1, LogBytesPerWord);  // index2bytes
 501 
 502   // Check type.
 503   __ z_cli(0, Z_tos, JVM_CONSTANT_Double);
 504   __ z_brne(notDouble);
 505   // dtos
 506   __ mem2freg_opt(Z_ftos, Address(Z_tmp_2, Z_tmp_1, base_offset));
 507   __ push_d();
 508   __ z_bru(Done);
 509 
 510   __ bind(notDouble);
 511   __ z_cli(0, Z_tos, JVM_CONSTANT_Long);
 512   __ z_brne(notLong);
 513   // ltos
 514   __ mem2reg_opt(Z_tos, Address(Z_tmp_2, Z_tmp_1, base_offset));
 515   __ push_l();
 516   __ z_bru(Done);
 517 
 518   __ bind(notLong);
 519   condy_helper(Done);
 520 
 521   __ bind(Done);
 522 }
 523 
 524 void TemplateTable::condy_helper(Label&amp; Done) {
 525   const Register obj   = Z_tmp_1;
 526   const Register off   = Z_tmp_2;
 527   const Register flags = Z_ARG1;
 528   const Register rarg  = Z_ARG2;
 529   __ load_const_optimized(rarg, (int)bytecode());
 530   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc), rarg);
 531   __ get_vm_result_2(flags);
 532 
 533   // VMr = obj = base address to find primitive value to push
 534   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 535   assert(ConstantPoolCacheEntry::field_index_mask == 0xffff, &quot;or use other instructions&quot;);
 536   __ z_llghr(off, flags);
 537   const Address field(obj, off);
 538 
 539   // What sort of thing are we loading?
 540   __ z_srl(flags, ConstantPoolCacheEntry::tos_state_shift);
 541   // Make sure we don&#39;t need to mask flags for tos_state after the above shift.
 542   ConstantPoolCacheEntry::verify_tos_state_shift();
 543 
 544   switch (bytecode()) {
 545   case Bytecodes::_ldc:
 546   case Bytecodes::_ldc_w:
 547     {
 548       // tos in (itos, ftos, stos, btos, ctos, ztos)
 549       Label notInt, notFloat, notShort, notByte, notChar, notBool;
 550       __ z_cghi(flags, itos);
 551       __ z_brne(notInt);
 552       // itos
 553       __ z_l(Z_tos, field);
 554       __ push(itos);
 555       __ z_bru(Done);
 556 
 557       __ bind(notInt);
 558       __ z_cghi(flags, ftos);
 559       __ z_brne(notFloat);
 560       // ftos
 561       __ z_le(Z_ftos, field);
 562       __ push(ftos);
 563       __ z_bru(Done);
 564 
 565       __ bind(notFloat);
 566       __ z_cghi(flags, stos);
 567       __ z_brne(notShort);
 568       // stos
 569       __ z_lh(Z_tos, field);
 570       __ push(stos);
 571       __ z_bru(Done);
 572 
 573       __ bind(notShort);
 574       __ z_cghi(flags, btos);
 575       __ z_brne(notByte);
 576       // btos
 577       __ z_lb(Z_tos, field);
 578       __ push(btos);
 579       __ z_bru(Done);
 580 
 581       __ bind(notByte);
 582       __ z_cghi(flags, ctos);
 583       __ z_brne(notChar);
 584       // ctos
 585       __ z_llh(Z_tos, field);
 586       __ push(ctos);
 587       __ z_bru(Done);
 588 
 589       __ bind(notChar);
 590       __ z_cghi(flags, ztos);
 591       __ z_brne(notBool);
 592       // ztos
 593       __ z_lb(Z_tos, field);
 594       __ push(ztos);
 595       __ z_bru(Done);
 596 
 597       __ bind(notBool);
 598       break;
 599     }
 600 
 601   case Bytecodes::_ldc2_w:
 602     {
 603       Label notLong, notDouble;
 604       __ z_cghi(flags, ltos);
 605       __ z_brne(notLong);
 606       // ltos
 607       __ z_lg(Z_tos, field);
 608       __ push(ltos);
 609       __ z_bru(Done);
 610 
 611       __ bind(notLong);
 612       __ z_cghi(flags, dtos);
 613       __ z_brne(notDouble);
 614       // dtos
 615       __ z_ld(Z_ftos, field);
 616       __ push(dtos);
 617       __ z_bru(Done);
 618 
 619       __ bind(notDouble);
 620       break;
 621     }
 622 
 623   default:
 624     ShouldNotReachHere();
 625   }
 626 
 627   __ stop(&quot;bad ldc/condy&quot;);
 628 }
 629 
 630 void TemplateTable::locals_index(Register reg, int offset) {
 631   __ z_llgc(reg, at_bcp(offset));
 632   __ z_lcgr(reg);
 633 }
 634 
 635 void TemplateTable::iload() {
 636   iload_internal();
 637 }
 638 
 639 void TemplateTable::nofast_iload() {
 640   iload_internal(may_not_rewrite);
 641 }
 642 
 643 void TemplateTable::iload_internal(RewriteControl rc) {
 644   transition(vtos, itos);
 645 
 646   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 647     NearLabel rewrite, done;
 648     const Register bc = Z_ARG4;
 649 
 650     assert(Z_R1_scratch != bc, &quot;register damaged&quot;);
 651 
 652     // Get next byte.
 653     __ z_llgc(Z_R1_scratch, at_bcp(Bytecodes::length_for (Bytecodes::_iload)));
 654 
 655     // If _iload, wait to rewrite to iload2. We only want to rewrite the
 656     // last two iloads in a pair. Comparing against fast_iload means that
 657     // the next bytecode is neither an iload or a caload, and therefore
 658     // an iload pair.
 659     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_iload,
 660                              Assembler::bcondEqual, done);
 661 
 662     __ load_const_optimized(bc, Bytecodes::_fast_iload2);
 663     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_iload,
 664                              Assembler::bcondEqual, rewrite);
 665 
 666     // If _caload, rewrite to fast_icaload.
 667     __ load_const_optimized(bc, Bytecodes::_fast_icaload);
 668     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_caload,
 669                              Assembler::bcondEqual, rewrite);
 670 
 671     // Rewrite so iload doesn&#39;t check again.
 672     __ load_const_optimized(bc, Bytecodes::_fast_iload);
 673 
 674     // rewrite
 675     // bc: fast bytecode
 676     __ bind(rewrite);
 677     patch_bytecode(Bytecodes::_iload, bc, Z_R1_scratch, false);
 678 
 679     __ bind(done);
 680 
 681   }
 682 
 683   // Get the local value into tos.
 684   locals_index(Z_R1_scratch);
 685   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 686 }
 687 
 688 void TemplateTable::fast_iload2() {
 689   transition(vtos, itos);
 690 
 691   locals_index(Z_R1_scratch);
 692   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 693   __ push_i(Z_tos);
 694   locals_index(Z_R1_scratch, 3);
 695   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 696 }
 697 
 698 void TemplateTable::fast_iload() {
 699   transition(vtos, itos);
 700 
 701   locals_index(Z_R1_scratch);
 702   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 703 }
 704 
 705 void TemplateTable::lload() {
 706   transition(vtos, ltos);
 707 
 708   locals_index(Z_R1_scratch);
 709   __ mem2reg_opt(Z_tos, laddress(_masm, Z_R1_scratch));
 710 }
 711 
 712 void TemplateTable::fload() {
 713   transition(vtos, ftos);
 714 
 715   locals_index(Z_R1_scratch);
 716   __ mem2freg_opt(Z_ftos, faddress(_masm, Z_R1_scratch), false);
 717 }
 718 
 719 void TemplateTable::dload() {
 720   transition(vtos, dtos);
 721 
 722   locals_index(Z_R1_scratch);
 723   __ mem2freg_opt(Z_ftos, daddress(_masm, Z_R1_scratch));
 724 }
 725 
 726 void TemplateTable::aload() {
 727   transition(vtos, atos);
 728 
 729   locals_index(Z_R1_scratch);
 730   __ mem2reg_opt(Z_tos, aaddress(_masm, Z_R1_scratch));
 731 }
 732 
 733 void TemplateTable::locals_index_wide(Register reg) {
 734   __ get_2_byte_integer_at_bcp(reg, 2, InterpreterMacroAssembler::Unsigned);
 735   __ z_lcgr(reg);
 736 }
 737 
 738 void TemplateTable::wide_iload() {
 739   transition(vtos, itos);
 740 
 741   locals_index_wide(Z_tmp_1);
 742   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_tmp_1), false);
 743 }
 744 
 745 void TemplateTable::wide_lload() {
 746   transition(vtos, ltos);
 747 
 748   locals_index_wide(Z_tmp_1);
 749   __ mem2reg_opt(Z_tos, laddress(_masm, Z_tmp_1));
 750 }
 751 
 752 void TemplateTable::wide_fload() {
 753   transition(vtos, ftos);
 754 
 755   locals_index_wide(Z_tmp_1);
 756   __ mem2freg_opt(Z_ftos, faddress(_masm, Z_tmp_1), false);
 757 }
 758 
 759 void TemplateTable::wide_dload() {
 760   transition(vtos, dtos);
 761 
 762   locals_index_wide(Z_tmp_1);
 763   __ mem2freg_opt(Z_ftos, daddress(_masm, Z_tmp_1));
 764 }
 765 
 766 void TemplateTable::wide_aload() {
 767   transition(vtos, atos);
 768 
 769   locals_index_wide(Z_tmp_1);
 770   __ mem2reg_opt(Z_tos, aaddress(_masm, Z_tmp_1));
 771 }
 772 
 773 void TemplateTable::index_check(Register array, Register index, unsigned int shift) {
 774   assert_different_registers(Z_R1_scratch, array, index);
 775 
 776   // Check array.
 777   __ null_check(array, Z_R0_scratch, arrayOopDesc::length_offset_in_bytes());
 778 
 779   // Sign extend index for use by indexed load.
 780   __ z_lgfr(index, index);
 781 
 782   // Check index.
 783   Label index_ok;
 784   __ z_cl(index, Address(array, arrayOopDesc::length_offset_in_bytes()));
 785   __ z_brl(index_ok);
 786   __ lgr_if_needed(Z_ARG3, index); // See generate_ArrayIndexOutOfBounds_handler().
 787   // Pass the array to create more detailed exceptions.
 788   __ lgr_if_needed(Z_ARG2, array); // See generate_ArrayIndexOutOfBounds_handler().
 789   __ load_absolute_address(Z_R1_scratch,
 790                            Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 791   __ z_bcr(Assembler::bcondAlways, Z_R1_scratch);
 792   __ bind(index_ok);
 793 
 794   if (shift &gt; 0)
 795     __ z_sllg(index, index, shift);
 796 }
 797 
 798 void TemplateTable::iaload() {
 799   transition(itos, itos);
 800 
 801   __ pop_ptr(Z_tmp_1);  // array
 802   // Index is in Z_tos.
 803   Register index = Z_tos;
 804   index_check(Z_tmp_1, index, LogBytesPerInt); // Kills Z_ARG3.
 805   // Load the value.
 806   __ mem2reg_opt(Z_tos,
 807                  Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_INT)),
 808                  false);
 809 }
 810 
 811 void TemplateTable::laload() {
 812   transition(itos, ltos);
 813 
 814   __ pop_ptr(Z_tmp_2);
 815   // Z_tos   : index
 816   // Z_tmp_2 : array
 817   Register index = Z_tos;
 818   index_check(Z_tmp_2, index, LogBytesPerLong);
 819   __ mem2reg_opt(Z_tos,
 820                  Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_LONG)));
 821 }
 822 
 823 void TemplateTable::faload() {
 824   transition(itos, ftos);
 825 
 826   __ pop_ptr(Z_tmp_2);
 827   // Z_tos   : index
 828   // Z_tmp_2 : array
 829   Register index = Z_tos;
 830   index_check(Z_tmp_2, index, LogBytesPerInt);
 831   __ mem2freg_opt(Z_ftos,
 832                   Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 833                   false);
 834 }
 835 
 836 void TemplateTable::daload() {
 837   transition(itos, dtos);
 838 
 839   __ pop_ptr(Z_tmp_2);
 840   // Z_tos   : index
 841   // Z_tmp_2 : array
 842   Register index = Z_tos;
 843   index_check(Z_tmp_2, index, LogBytesPerLong);
 844   __ mem2freg_opt(Z_ftos,
 845                   Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_DOUBLE)));
 846 }
 847 
 848 void TemplateTable::aaload() {
 849   transition(itos, atos);
 850 
 851   unsigned const int shift = LogBytesPerHeapOop;
 852   __ pop_ptr(Z_tmp_1);  // array
 853   // Index is in Z_tos.
 854   Register index = Z_tos;
 855   index_check(Z_tmp_1, index, shift);
 856   // Now load array element.
 857   do_oop_load(_masm, Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_OBJECT)), Z_tos,
 858               Z_tmp_2, Z_tmp_3, IS_ARRAY);
 859   __ verify_oop(Z_tos);
 860 }
 861 
 862 void TemplateTable::baload() {
 863   transition(itos, itos);
 864 
 865   __ pop_ptr(Z_tmp_1);
 866   // Z_tos   : index
 867   // Z_tmp_1 : array
 868   Register index = Z_tos;
 869   index_check(Z_tmp_1, index, 0);
 870   __ z_lb(Z_tos,
 871           Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_BYTE)));
 872 }
 873 
 874 void TemplateTable::caload() {
 875   transition(itos, itos);
 876 
 877   __ pop_ptr(Z_tmp_2);
 878   // Z_tos   : index
 879   // Z_tmp_2 : array
 880   Register index = Z_tos;
 881   index_check(Z_tmp_2, index, LogBytesPerShort);
 882   // Load into 64 bits, works on all CPUs.
 883   __ z_llgh(Z_tos,
 884             Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
 885 }
 886 
 887 // Iload followed by caload frequent pair.
 888 void TemplateTable::fast_icaload() {
 889   transition(vtos, itos);
 890 
 891   // Load index out of locals.
 892   locals_index(Z_R1_scratch);
 893   __ mem2reg_opt(Z_ARG3, iaddress(_masm, Z_R1_scratch), false);
 894   // Z_ARG3  : index
 895   // Z_tmp_2 : array
 896   __ pop_ptr(Z_tmp_2);
 897   index_check(Z_tmp_2, Z_ARG3, LogBytesPerShort);
 898   // Load into 64 bits, works on all CPUs.
 899   __ z_llgh(Z_tos,
 900             Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
 901 }
 902 
 903 void TemplateTable::saload() {
 904   transition(itos, itos);
 905 
 906   __ pop_ptr(Z_tmp_2);
 907   // Z_tos   : index
 908   // Z_tmp_2 : array
 909   Register index = Z_tos;
 910   index_check(Z_tmp_2, index, LogBytesPerShort);
 911   __ z_lh(Z_tos,
 912           Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_SHORT)));
 913 }
 914 
 915 void TemplateTable::iload(int n) {
 916   transition(vtos, itos);
 917   __ z_ly(Z_tos, iaddress(n));
 918 }
 919 
 920 void TemplateTable::lload(int n) {
 921   transition(vtos, ltos);
 922   __ z_lg(Z_tos, laddress(n));
 923 }
 924 
 925 void TemplateTable::fload(int n) {
 926   transition(vtos, ftos);
 927   __ mem2freg_opt(Z_ftos, faddress(n), false);
 928 }
 929 
 930 void TemplateTable::dload(int n) {
 931   transition(vtos, dtos);
 932   __ mem2freg_opt(Z_ftos, daddress(n));
 933 }
 934 
 935 void TemplateTable::aload(int n) {
 936   transition(vtos, atos);
 937   __ mem2reg_opt(Z_tos, aaddress(n));
 938 }
 939 
 940 void TemplateTable::aload_0() {
 941   aload_0_internal();
 942 }
 943 
 944 void TemplateTable::nofast_aload_0() {
 945   aload_0_internal(may_not_rewrite);
 946 }
 947 
 948 void TemplateTable::aload_0_internal(RewriteControl rc) {
 949   transition(vtos, atos);
 950 
 951   // According to bytecode histograms, the pairs:
 952   //
 953   // _aload_0, _fast_igetfield
 954   // _aload_0, _fast_agetfield
 955   // _aload_0, _fast_fgetfield
 956   //
 957   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 958   // _aload_0 bytecode checks if the next bytecode is either
 959   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 960   // rewrites the current bytecode into a pair bytecode; otherwise it
 961   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 962   // the pair check anymore.
 963   //
 964   // Note: If the next bytecode is _getfield, the rewrite must be
 965   //       delayed, otherwise we may miss an opportunity for a pair.
 966   //
 967   // Also rewrite frequent pairs
 968   //   aload_0, aload_1
 969   //   aload_0, iload_1
 970   // These bytecodes with a small amount of code are most profitable
 971   // to rewrite.
 972   if (!(RewriteFrequentPairs &amp;&amp; (rc == may_rewrite))) {
 973     aload(0);
 974     return;
 975   }
 976 
 977   NearLabel rewrite, done;
 978   const Register bc = Z_ARG4;
 979 
 980   assert(Z_R1_scratch != bc, &quot;register damaged&quot;);
 981   // Get next byte.
 982   __ z_llgc(Z_R1_scratch, at_bcp(Bytecodes::length_for (Bytecodes::_aload_0)));
 983 
 984   // Do actual aload_0.
 985   aload(0);
 986 
 987   // If _getfield then wait with rewrite.
 988   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_getfield,
 989                            Assembler::bcondEqual, done);
 990 
 991   // If _igetfield then rewrite to _fast_iaccess_0.
 992   assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0)
 993             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 994 
 995   __ load_const_optimized(bc, Bytecodes::_fast_iaccess_0);
 996   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_igetfield,
 997                            Assembler::bcondEqual, rewrite);
 998 
 999   // If _agetfield then rewrite to _fast_aaccess_0.
1000   assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0)
1001             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1002 
1003   __ load_const_optimized(bc, Bytecodes::_fast_aaccess_0);
1004   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_agetfield,
1005                            Assembler::bcondEqual, rewrite);
1006 
1007   // If _fgetfield then rewrite to _fast_faccess_0.
1008   assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0)
1009             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1010 
1011   __ load_const_optimized(bc, Bytecodes::_fast_faccess_0);
1012   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_fgetfield,
1013                            Assembler::bcondEqual, rewrite);
1014 
1015   // Else rewrite to _fast_aload0.
1016   assert(Bytecodes::java_code(Bytecodes::_fast_aload_0)
1017             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1018   __ load_const_optimized(bc, Bytecodes::_fast_aload_0);
1019 
1020   // rewrite
1021   // bc: fast bytecode
1022   __ bind(rewrite);
1023 
1024   patch_bytecode(Bytecodes::_aload_0, bc, Z_R1_scratch, false);
1025   // Reload local 0 because of VM call inside patch_bytecode().
1026   // this may trigger GC and thus change the oop.
1027   aload(0);
1028 
1029   __ bind(done);
1030 }
1031 
1032 void TemplateTable::istore() {
1033   transition(itos, vtos);
1034   locals_index(Z_R1_scratch);
1035   __ reg2mem_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
1036 }
1037 
1038 void TemplateTable::lstore() {
1039   transition(ltos, vtos);
1040   locals_index(Z_R1_scratch);
1041   __ reg2mem_opt(Z_tos, laddress(_masm, Z_R1_scratch));
1042 }
1043 
1044 void TemplateTable::fstore() {
1045   transition(ftos, vtos);
1046   locals_index(Z_R1_scratch);
1047   __ freg2mem_opt(Z_ftos, faddress(_masm, Z_R1_scratch));
1048 }
1049 
1050 void TemplateTable::dstore() {
1051   transition(dtos, vtos);
1052   locals_index(Z_R1_scratch);
1053   __ freg2mem_opt(Z_ftos, daddress(_masm, Z_R1_scratch));
1054 }
1055 
1056 void TemplateTable::astore() {
1057   transition(vtos, vtos);
1058   __ pop_ptr(Z_tos);
1059   locals_index(Z_R1_scratch);
1060   __ reg2mem_opt(Z_tos, aaddress(_masm, Z_R1_scratch));
1061 }
1062 
1063 void TemplateTable::wide_istore() {
1064   transition(vtos, vtos);
1065   __ pop_i(Z_tos);
1066   locals_index_wide(Z_tmp_1);
1067   __ reg2mem_opt(Z_tos, iaddress(_masm, Z_tmp_1), false);
1068 }
1069 
1070 void TemplateTable::wide_lstore() {
1071   transition(vtos, vtos);
1072   __ pop_l(Z_tos);
1073   locals_index_wide(Z_tmp_1);
1074   __ reg2mem_opt(Z_tos, laddress(_masm, Z_tmp_1));
1075 }
1076 
1077 void TemplateTable::wide_fstore() {
1078   transition(vtos, vtos);
1079   __ pop_f(Z_ftos);
1080   locals_index_wide(Z_tmp_1);
1081   __ freg2mem_opt(Z_ftos, faddress(_masm, Z_tmp_1), false);
1082 }
1083 
1084 void TemplateTable::wide_dstore() {
1085   transition(vtos, vtos);
1086   __ pop_d(Z_ftos);
1087   locals_index_wide(Z_tmp_1);
1088   __ freg2mem_opt(Z_ftos, daddress(_masm, Z_tmp_1));
1089 }
1090 
1091 void TemplateTable::wide_astore() {
1092   transition(vtos, vtos);
1093   __ pop_ptr(Z_tos);
1094   locals_index_wide(Z_tmp_1);
1095   __ reg2mem_opt(Z_tos, aaddress(_masm, Z_tmp_1));
1096 }
1097 
1098 void TemplateTable::iastore() {
1099   transition(itos, vtos);
1100 
1101   Register index = Z_ARG3; // Index_check expects index in Z_ARG3.
1102   // Value is in Z_tos ...
1103   __ pop_i(index);        // index
1104   __ pop_ptr(Z_tmp_1);    // array
1105   index_check(Z_tmp_1, index, LogBytesPerInt);
1106   // ... and then move the value.
1107   __ reg2mem_opt(Z_tos,
1108                  Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_INT)),
1109                  false);
1110 }
1111 
1112 void TemplateTable::lastore() {
1113   transition(ltos, vtos);
1114 
1115   __ pop_i(Z_ARG3);
1116   __ pop_ptr(Z_tmp_2);
1117   // Z_tos   : value
1118   // Z_ARG3  : index
1119   // Z_tmp_2 : array
1120  index_check(Z_tmp_2, Z_ARG3, LogBytesPerLong); // Prefer index in Z_ARG3.
1121   __ reg2mem_opt(Z_tos,
1122                  Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_LONG)));
1123 }
1124 
1125 void TemplateTable::fastore() {
1126   transition(ftos, vtos);
1127 
1128   __ pop_i(Z_ARG3);
1129   __ pop_ptr(Z_tmp_2);
1130   // Z_ftos  : value
1131   // Z_ARG3  : index
1132   // Z_tmp_2 : array
1133   index_check(Z_tmp_2, Z_ARG3, LogBytesPerInt); // Prefer index in Z_ARG3.
1134   __ freg2mem_opt(Z_ftos,
1135                   Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1136                   false);
1137 }
1138 
1139 void TemplateTable::dastore() {
1140   transition(dtos, vtos);
1141 
1142   __ pop_i(Z_ARG3);
1143   __ pop_ptr(Z_tmp_2);
1144   // Z_ftos  : value
1145   // Z_ARG3  : index
1146   // Z_tmp_2 : array
1147   index_check(Z_tmp_2, Z_ARG3, LogBytesPerLong); // Prefer index in Z_ARG3.
1148   __ freg2mem_opt(Z_ftos,
1149                   Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_DOUBLE)));
1150 }
1151 
1152 void TemplateTable::aastore() {
1153   NearLabel is_null, ok_is_subtype, done;
1154   transition(vtos, vtos);
1155 
1156   // stack: ..., array, index, value
1157 
1158   Register Rvalue = Z_tos;
1159   Register Rarray = Z_ARG2;
1160   Register Rindex = Z_ARG3; // Convention for index_check().
1161 
1162   __ load_ptr(0, Rvalue);
1163   __ z_l(Rindex, Address(Z_esp, Interpreter::expr_offset_in_bytes(1)));
1164   __ load_ptr(2, Rarray);
1165 
1166   unsigned const int shift = LogBytesPerHeapOop;
1167   index_check(Rarray, Rindex, shift); // side effect: Rindex = Rindex &lt;&lt; shift
1168   Register Rstore_addr  = Rindex;
1169   // Address where the store goes to, i.e. &amp;(Rarry[index])
1170   __ load_address(Rstore_addr, Address(Rarray, Rindex, arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
1171 
1172   // do array store check - check for NULL value first.
1173   __ compareU64_and_branch(Rvalue, (intptr_t)0, Assembler::bcondEqual, is_null);
1174 
1175   Register Rsub_klass   = Z_ARG4;
1176   Register Rsuper_klass = Z_ARG5;
1177   __ load_klass(Rsub_klass, Rvalue);
1178   // Load superklass.
1179   __ load_klass(Rsuper_klass, Rarray);
1180   __ z_lg(Rsuper_klass, Address(Rsuper_klass, ObjArrayKlass::element_klass_offset()));
1181 
1182   // Generate a fast subtype check.  Branch to ok_is_subtype if no failure.
1183   // Throw if failure.
1184   Register tmp1 = Z_tmp_1;
1185   Register tmp2 = Z_tmp_2;
1186   __ gen_subtype_check(Rsub_klass, Rsuper_klass, tmp1, tmp2, ok_is_subtype);
1187 
1188   // Fall through on failure.
1189   // Object is in Rvalue == Z_tos.
1190   assert(Rvalue == Z_tos, &quot;that&#39;s the expected location&quot;);
1191   __ load_absolute_address(tmp1, Interpreter::_throw_ArrayStoreException_entry);
1192   __ z_br(tmp1);
1193 
1194   Register tmp3 = Rsub_klass;
1195 
1196   // Have a NULL in Rvalue.
1197   __ bind(is_null);
1198   __ profile_null_seen(tmp1);
1199 
1200   // Store a NULL.
1201   do_oop_store(_masm, Address(Rstore_addr, (intptr_t)0), noreg,
1202                tmp3, tmp2, tmp1, IS_ARRAY);
1203   __ z_bru(done);
1204 
1205   // Come here on success.
1206   __ bind(ok_is_subtype);
1207 
1208   // Now store using the appropriate barrier.
1209   do_oop_store(_masm, Address(Rstore_addr, (intptr_t)0), Rvalue,
1210                tmp3, tmp2, tmp1, IS_ARRAY | IS_NOT_NULL);
1211 
1212   // Pop stack arguments.
1213   __ bind(done);
1214   __ add2reg(Z_esp, 3 * Interpreter::stackElementSize);
1215 }
1216 
1217 
1218 void TemplateTable::bastore() {
1219   transition(itos, vtos);
1220 
1221   __ pop_i(Z_ARG3);
1222   __ pop_ptr(Z_tmp_2);
1223   // Z_tos   : value
1224   // Z_ARG3  : index
1225   // Z_tmp_2 : array
1226 
1227   // Need to check whether array is boolean or byte
1228   // since both types share the bastore bytecode.
1229   __ load_klass(Z_tmp_1, Z_tmp_2);
1230   __ z_llgf(Z_tmp_1, Address(Z_tmp_1, Klass::layout_helper_offset()));
1231   __ z_tmll(Z_tmp_1, Klass::layout_helper_boolean_diffbit());
1232   Label L_skip;
1233   __ z_bfalse(L_skip);
1234   // if it is a T_BOOLEAN array, mask the stored value to 0/1
1235   __ z_nilf(Z_tos, 0x1);
1236   __ bind(L_skip);
1237 
1238   // No index shift necessary - pass 0.
1239   index_check(Z_tmp_2, Z_ARG3, 0); // Prefer index in Z_ARG3.
1240   __ z_stc(Z_tos,
1241            Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_BYTE)));
1242 }
1243 
1244 void TemplateTable::castore() {
1245   transition(itos, vtos);
1246 
1247   __ pop_i(Z_ARG3);
1248   __ pop_ptr(Z_tmp_2);
1249   // Z_tos   : value
1250   // Z_ARG3  : index
1251   // Z_tmp_2 : array
1252   Register index = Z_ARG3; // prefer index in Z_ARG3
1253   index_check(Z_tmp_2, index, LogBytesPerShort);
1254   __ z_sth(Z_tos,
1255            Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
1256 }
1257 
1258 void TemplateTable::sastore() {
1259   castore();
1260 }
1261 
1262 void TemplateTable::istore(int n) {
1263   transition(itos, vtos);
1264   __ reg2mem_opt(Z_tos, iaddress(n), false);
1265 }
1266 
1267 void TemplateTable::lstore(int n) {
1268   transition(ltos, vtos);
1269   __ reg2mem_opt(Z_tos, laddress(n));
1270 }
1271 
1272 void TemplateTable::fstore(int n) {
1273   transition(ftos, vtos);
1274   __ freg2mem_opt(Z_ftos, faddress(n), false);
1275 }
1276 
1277 void TemplateTable::dstore(int n) {
1278   transition(dtos, vtos);
1279   __ freg2mem_opt(Z_ftos, daddress(n));
1280 }
1281 
1282 void TemplateTable::astore(int n) {
1283   transition(vtos, vtos);
1284   __ pop_ptr(Z_tos);
1285   __ reg2mem_opt(Z_tos, aaddress(n));
1286 }
1287 
1288 void TemplateTable::pop() {
1289   transition(vtos, vtos);
1290   __ add2reg(Z_esp, Interpreter::stackElementSize);
1291 }
1292 
1293 void TemplateTable::pop2() {
1294   transition(vtos, vtos);
1295   __ add2reg(Z_esp, 2 * Interpreter::stackElementSize);
1296 }
1297 
1298 void TemplateTable::dup() {
1299   transition(vtos, vtos);
1300   __ load_ptr(0, Z_tos);
1301   __ push_ptr(Z_tos);
1302   // stack: ..., a, a
1303 }
1304 
1305 void TemplateTable::dup_x1() {
1306   transition(vtos, vtos);
1307 
1308   // stack: ..., a, b
1309   __ load_ptr(0, Z_tos);          // load b
1310   __ load_ptr(1, Z_R0_scratch);   // load a
1311   __ store_ptr(1, Z_tos);         // store b
1312   __ store_ptr(0, Z_R0_scratch);  // store a
1313   __ push_ptr(Z_tos);             // push b
1314   // stack: ..., b, a, b
1315 }
1316 
1317 void TemplateTable::dup_x2() {
1318   transition(vtos, vtos);
1319 
1320   // stack: ..., a, b, c
1321   __ load_ptr(0, Z_R0_scratch);   // load c
1322   __ load_ptr(2, Z_R1_scratch);   // load a
1323   __ store_ptr(2, Z_R0_scratch);  // store c in a
1324   __ push_ptr(Z_R0_scratch);      // push c
1325   // stack: ..., c, b, c, c
1326   __ load_ptr(2, Z_R0_scratch);   // load b
1327   __ store_ptr(2, Z_R1_scratch);  // store a in b
1328   // stack: ..., c, a, c, c
1329   __ store_ptr(1, Z_R0_scratch);  // store b in c
1330   // stack: ..., c, a, b, c
1331 }
1332 
1333 void TemplateTable::dup2() {
1334   transition(vtos, vtos);
1335 
1336   // stack: ..., a, b
1337   __ load_ptr(1, Z_R0_scratch);  // load a
1338   __ push_ptr(Z_R0_scratch);     // push a
1339   __ load_ptr(1, Z_R0_scratch);  // load b
1340   __ push_ptr(Z_R0_scratch);     // push b
1341   // stack: ..., a, b, a, b
1342 }
1343 
1344 void TemplateTable::dup2_x1() {
1345   transition(vtos, vtos);
1346 
1347   // stack: ..., a, b, c
1348   __ load_ptr(0, Z_R0_scratch);  // load c
1349   __ load_ptr(1, Z_R1_scratch);  // load b
1350   __ push_ptr(Z_R1_scratch);     // push b
1351   __ push_ptr(Z_R0_scratch);     // push c
1352   // stack: ..., a, b, c, b, c
1353   __ store_ptr(3, Z_R0_scratch); // store c in b
1354   // stack: ..., a, c, c, b, c
1355   __ load_ptr( 4, Z_R0_scratch); // load a
1356   __ store_ptr(2, Z_R0_scratch); // store a in 2nd c
1357   // stack: ..., a, c, a, b, c
1358   __ store_ptr(4, Z_R1_scratch); // store b in a
1359   // stack: ..., b, c, a, b, c
1360 }
1361 
1362 void TemplateTable::dup2_x2() {
1363   transition(vtos, vtos);
1364 
1365   // stack: ..., a, b, c, d
1366   __ load_ptr(0, Z_R0_scratch);   // load d
1367   __ load_ptr(1, Z_R1_scratch);   // load c
1368   __ push_ptr(Z_R1_scratch);      // push c
1369   __ push_ptr(Z_R0_scratch);      // push d
1370   // stack: ..., a, b, c, d, c, d
1371   __ load_ptr(4, Z_R1_scratch);   // load b
1372   __ store_ptr(2, Z_R1_scratch);  // store b in d
1373   __ store_ptr(4, Z_R0_scratch);  // store d in b
1374   // stack: ..., a, d, c, b, c, d
1375   __ load_ptr(5, Z_R0_scratch);   // load a
1376   __ load_ptr(3, Z_R1_scratch);   // load c
1377   __ store_ptr(3, Z_R0_scratch);  // store a in c
1378   __ store_ptr(5, Z_R1_scratch);  // store c in a
1379   // stack: ..., c, d, a, b, c, d
1380 }
1381 
1382 void TemplateTable::swap() {
1383   transition(vtos, vtos);
1384 
1385   // stack: ..., a, b
1386   __ load_ptr(1, Z_R0_scratch);  // load a
1387   __ load_ptr(0, Z_R1_scratch);  // load b
1388   __ store_ptr(0, Z_R0_scratch);  // store a in b
1389   __ store_ptr(1, Z_R1_scratch);  // store b in a
1390   // stack: ..., b, a
1391 }
1392 
1393 void TemplateTable::iop2(Operation op) {
1394   transition(itos, itos);
1395   switch (op) {
1396     case add  :                           __ z_ay(Z_tos,  __ stackTop()); __ pop_i(); break;
1397     case sub  :                           __ z_sy(Z_tos,  __ stackTop()); __ pop_i(); __ z_lcr(Z_tos, Z_tos); break;
1398     case mul  :                           __ z_msy(Z_tos, __ stackTop()); __ pop_i(); break;
1399     case _and :                           __ z_ny(Z_tos,  __ stackTop()); __ pop_i(); break;
1400     case _or  :                           __ z_oy(Z_tos,  __ stackTop()); __ pop_i(); break;
1401     case _xor :                           __ z_xy(Z_tos,  __ stackTop()); __ pop_i(); break;
1402     case shl  : __ z_lr(Z_tmp_1, Z_tos);
1403                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1404                                           __ pop_i(Z_tos);   __ z_sll(Z_tos, 0,  Z_tmp_1); break;
1405     case shr  : __ z_lr(Z_tmp_1, Z_tos);
1406                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1407                                           __ pop_i(Z_tos);   __ z_sra(Z_tos, 0,  Z_tmp_1); break;
1408     case ushr : __ z_lr(Z_tmp_1, Z_tos);
1409                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1410                                           __ pop_i(Z_tos);   __ z_srl(Z_tos, 0,  Z_tmp_1); break;
1411     default   : ShouldNotReachHere(); break;
1412   }
1413   return;
1414 }
1415 
1416 void TemplateTable::lop2(Operation op) {
1417   transition(ltos, ltos);
1418 
1419   switch (op) {
1420     case add  :  __ z_ag(Z_tos,  __ stackTop()); __ pop_l(); break;
1421     case sub  :  __ z_sg(Z_tos,  __ stackTop()); __ pop_l(); __ z_lcgr(Z_tos, Z_tos); break;
1422     case mul  :  __ z_msg(Z_tos, __ stackTop()); __ pop_l(); break;
1423     case _and :  __ z_ng(Z_tos,  __ stackTop()); __ pop_l(); break;
1424     case _or  :  __ z_og(Z_tos,  __ stackTop()); __ pop_l(); break;
1425     case _xor :  __ z_xg(Z_tos,  __ stackTop()); __ pop_l(); break;
1426     default   : ShouldNotReachHere(); break;
1427   }
1428   return;
1429 }
1430 
1431 // Common part of idiv/irem.
1432 static void idiv_helper(InterpreterMacroAssembler * _masm, address exception) {
1433   NearLabel not_null;
1434 
1435   // Use register pair Z_tmp_1, Z_tmp_2 for DIVIDE SINGLE.
1436   assert(Z_tmp_1-&gt;successor() == Z_tmp_2, &quot; need even/odd register pair for idiv/irem&quot;);
1437 
1438   // Get dividend.
1439   __ pop_i(Z_tmp_2);
1440 
1441   // If divisor == 0 throw exception.
1442   __ compare32_and_branch(Z_tos, (intptr_t) 0,
1443                           Assembler::bcondNotEqual, not_null   );
1444   __ load_absolute_address(Z_R1_scratch, exception);
1445   __ z_br(Z_R1_scratch);
1446 
1447   __ bind(not_null);
1448 
1449   __ z_lgfr(Z_tmp_2, Z_tmp_2);   // Sign extend dividend.
1450   __ z_dsgfr(Z_tmp_1, Z_tos);    // Do it.
1451 }
1452 
1453 void TemplateTable::idiv() {
1454   transition(itos, itos);
1455 
1456   idiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry);
1457   __ z_llgfr(Z_tos, Z_tmp_2);     // Result is in Z_tmp_2.
1458 }
1459 
1460 void TemplateTable::irem() {
1461   transition(itos, itos);
1462 
1463   idiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry);
1464   __ z_llgfr(Z_tos, Z_tmp_1);     // Result is in Z_tmp_1.
1465 }
1466 
1467 void TemplateTable::lmul() {
1468   transition(ltos, ltos);
1469 
1470   // Multiply with memory operand.
1471   __ z_msg(Z_tos, __ stackTop());
1472   __ pop_l();  // Pop operand.
1473 }
1474 
1475 // Common part of ldiv/lrem.
1476 //
1477 // Input:
1478 //     Z_tos := the divisor (dividend still on stack)
1479 //
1480 // Updated registers:
1481 //     Z_tmp_1 := pop_l() % Z_tos     ; if is_ldiv == false
1482 //     Z_tmp_2 := pop_l() / Z_tos     ; if is_ldiv == true
1483 //
1484 static void ldiv_helper(InterpreterMacroAssembler * _masm, address exception, bool is_ldiv) {
1485   NearLabel not_null, done;
1486 
1487   // Use register pair Z_tmp_1, Z_tmp_2 for DIVIDE SINGLE.
1488   assert(Z_tmp_1-&gt;successor() == Z_tmp_2,
1489          &quot; need even/odd register pair for idiv/irem&quot;);
1490 
1491   // Get dividend.
1492   __ pop_l(Z_tmp_2);
1493 
1494   // If divisor == 0 throw exception.
1495   __ compare64_and_branch(Z_tos, (intptr_t)0, Assembler::bcondNotEqual, not_null);
1496   __ load_absolute_address(Z_R1_scratch, exception);
1497   __ z_br(Z_R1_scratch);
1498 
1499   __ bind(not_null);
1500   // Special case for dividend == 0x8000 and divisor == -1.
1501   if (is_ldiv) {
1502     // result := Z_tmp_2 := - dividend
1503     __ z_lcgr(Z_tmp_2, Z_tmp_2);
1504   } else {
1505     // result remainder := Z_tmp_1 := 0
1506     __ clear_reg(Z_tmp_1, true, false);  // Don&#39;t set CC.
1507   }
1508 
1509   // if divisor == -1 goto done
1510   __ compare64_and_branch(Z_tos, -1, Assembler::bcondEqual, done);
1511   if (is_ldiv)
1512     // Restore sign, because divisor != -1.
1513     __ z_lcgr(Z_tmp_2, Z_tmp_2);
1514   __ z_dsgr(Z_tmp_1, Z_tos);    // Do it.
1515   __ bind(done);
1516 }
1517 
1518 void TemplateTable::ldiv() {
1519   transition(ltos, ltos);
1520 
1521   ldiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry, true /*is_ldiv*/);
1522   __ z_lgr(Z_tos, Z_tmp_2);     // Result is in Z_tmp_2.
1523 }
1524 
1525 void TemplateTable::lrem() {
1526   transition(ltos, ltos);
1527 
1528   ldiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry, false /*is_ldiv*/);
1529   __ z_lgr(Z_tos, Z_tmp_1);     // Result is in Z_tmp_1.
1530 }
1531 
1532 void TemplateTable::lshl() {
1533   transition(itos, ltos);
1534 
1535   // Z_tos: shift amount
1536   __ pop_l(Z_tmp_1);              // Get shift value.
1537   __ z_sllg(Z_tos, Z_tmp_1, 0, Z_tos);
1538 }
1539 
1540 void TemplateTable::lshr() {
1541   transition(itos, ltos);
1542 
1543   // Z_tos: shift amount
1544   __ pop_l(Z_tmp_1);              // Get shift value.
1545   __ z_srag(Z_tos, Z_tmp_1, 0, Z_tos);
1546 }
1547 
1548 void TemplateTable::lushr() {
1549   transition(itos, ltos);
1550 
1551   // Z_tos: shift amount
1552   __ pop_l(Z_tmp_1);              // Get shift value.
1553   __ z_srlg(Z_tos, Z_tmp_1, 0, Z_tos);
1554 }
1555 
1556 void TemplateTable::fop2(Operation op) {
1557   transition(ftos, ftos);
1558 
1559   switch (op) {
1560     case add:
1561       // Add memory operand.
1562       __ z_aeb(Z_ftos, __ stackTop()); __ pop_f(); return;
1563     case sub:
1564       // Sub memory operand.
1565       __ z_ler(Z_F1, Z_ftos);    // first operand
1566       __ pop_f(Z_ftos);          // second operand from stack
1567       __ z_sebr(Z_ftos, Z_F1);
1568       return;
1569     case mul:
1570       // Multiply with memory operand.
1571       __ z_meeb(Z_ftos, __ stackTop()); __ pop_f(); return;
1572     case div:
1573       __ z_ler(Z_F1, Z_ftos);    // first operand
1574       __ pop_f(Z_ftos);          // second operand from stack
1575       __ z_debr(Z_ftos, Z_F1);
1576       return;
1577     case rem:
1578       // Do runtime call.
1579       __ z_ler(Z_FARG2, Z_ftos);  // divisor
1580       __ pop_f(Z_FARG1);          // dividend
1581       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1582       // Result should be in the right place (Z_ftos == Z_FRET).
1583       return;
1584     default:
1585       ShouldNotReachHere();
1586       return;
1587   }
1588 }
1589 
1590 void TemplateTable::dop2(Operation op) {
1591   transition(dtos, dtos);
1592 
1593   switch (op) {
1594     case add:
1595       // Add memory operand.
1596       __ z_adb(Z_ftos, __ stackTop()); __ pop_d(); return;
1597     case sub:
1598       // Sub memory operand.
1599       __ z_ldr(Z_F1, Z_ftos);    // first operand
1600       __ pop_d(Z_ftos);          // second operand from stack
1601       __ z_sdbr(Z_ftos, Z_F1);
1602       return;
1603     case mul:
1604       // Multiply with memory operand.
1605       __ z_mdb(Z_ftos, __ stackTop()); __ pop_d(); return;
1606     case div:
1607       __ z_ldr(Z_F1, Z_ftos);    // first operand
1608       __ pop_d(Z_ftos);          // second operand from stack
1609       __ z_ddbr(Z_ftos, Z_F1);
1610       return;
1611     case rem:
1612       // Do runtime call.
1613       __ z_ldr(Z_FARG2, Z_ftos);  // divisor
1614       __ pop_d(Z_FARG1);          // dividend
1615       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1616       // Result should be in the right place (Z_ftos == Z_FRET).
1617       return;
1618     default:
1619       ShouldNotReachHere();
1620       return;
1621   }
1622 }
1623 
1624 void TemplateTable::ineg() {
1625   transition(itos, itos);
1626   __ z_lcr(Z_tos);
1627 }
1628 
1629 void TemplateTable::lneg() {
1630   transition(ltos, ltos);
1631   __ z_lcgr(Z_tos);
1632 }
1633 
1634 void TemplateTable::fneg() {
1635   transition(ftos, ftos);
1636   __ z_lcebr(Z_ftos, Z_ftos);
1637 }
1638 
1639 void TemplateTable::dneg() {
1640   transition(dtos, dtos);
1641   __ z_lcdbr(Z_ftos, Z_ftos);
1642 }
1643 
1644 void TemplateTable::iinc() {
1645   transition(vtos, vtos);
1646 
1647   Address local;
1648   __ z_lb(Z_R0_scratch, at_bcp(2)); // Get constant.
1649   locals_index(Z_R1_scratch);
1650   local = iaddress(_masm, Z_R1_scratch);
1651   __ z_a(Z_R0_scratch, local);
1652   __ reg2mem_opt(Z_R0_scratch, local, false);
1653 }
1654 
1655 void TemplateTable::wide_iinc() {
1656   transition(vtos, vtos);
1657 
1658   // Z_tmp_1 := increment
1659   __ get_2_byte_integer_at_bcp(Z_tmp_1, 4, InterpreterMacroAssembler::Signed);
1660   // Z_R1_scratch := index of local to increment
1661   locals_index_wide(Z_tmp_2);
1662   // Load, increment, and store.
1663   __ access_local_int(Z_tmp_2, Z_tos);
1664   __ z_agr(Z_tos,  Z_tmp_1);
1665   // Shifted index is still in Z_tmp_2.
1666   __ reg2mem_opt(Z_tos, Address(Z_locals, Z_tmp_2), false);
1667 }
1668 
1669 
1670 void TemplateTable::convert() {
1671   // Checking
1672 #ifdef ASSERT
1673   TosState   tos_in  = ilgl;
1674   TosState   tos_out = ilgl;
1675 
1676   switch (bytecode()) {
1677     case Bytecodes::_i2l:
1678     case Bytecodes::_i2f:
1679     case Bytecodes::_i2d:
1680     case Bytecodes::_i2b:
1681     case Bytecodes::_i2c:
1682     case Bytecodes::_i2s:
1683       tos_in = itos;
1684       break;
1685     case Bytecodes::_l2i:
1686     case Bytecodes::_l2f:
1687     case Bytecodes::_l2d:
1688       tos_in = ltos;
1689       break;
1690     case Bytecodes::_f2i:
1691     case Bytecodes::_f2l:
1692     case Bytecodes::_f2d:
1693       tos_in = ftos;
1694       break;
1695     case Bytecodes::_d2i:
1696     case Bytecodes::_d2l:
1697     case Bytecodes::_d2f:
1698       tos_in = dtos;
1699       break;
1700     default :
1701       ShouldNotReachHere();
1702   }
1703   switch (bytecode()) {
1704     case Bytecodes::_l2i:
1705     case Bytecodes::_f2i:
1706     case Bytecodes::_d2i:
1707     case Bytecodes::_i2b:
1708     case Bytecodes::_i2c:
1709     case Bytecodes::_i2s:
1710       tos_out = itos;
1711       break;
1712     case Bytecodes::_i2l:
1713     case Bytecodes::_f2l:
1714     case Bytecodes::_d2l:
1715       tos_out = ltos;
1716       break;
1717     case Bytecodes::_i2f:
1718     case Bytecodes::_l2f:
1719     case Bytecodes::_d2f:
1720       tos_out = ftos;
1721       break;
1722     case Bytecodes::_i2d:
1723     case Bytecodes::_l2d:
1724     case Bytecodes::_f2d:
1725       tos_out = dtos;
1726       break;
1727     default :
1728       ShouldNotReachHere();
1729   }
1730 
1731   transition(tos_in, tos_out);
1732 #endif // ASSERT
1733 
1734   // Conversion
1735   Label done;
1736   switch (bytecode()) {
1737     case Bytecodes::_i2l:
1738       __ z_lgfr(Z_tos, Z_tos);
1739       return;
1740     case Bytecodes::_i2f:
1741       __ z_cefbr(Z_ftos, Z_tos);
1742       return;
1743     case Bytecodes::_i2d:
1744       __ z_cdfbr(Z_ftos, Z_tos);
1745       return;
1746     case Bytecodes::_i2b:
1747       // Sign extend least significant byte.
1748       __ move_reg_if_needed(Z_tos, T_BYTE, Z_tos, T_INT);
1749       return;
1750     case Bytecodes::_i2c:
1751       // Zero extend 2 least significant bytes.
1752       __ move_reg_if_needed(Z_tos, T_CHAR, Z_tos, T_INT);
1753       return;
1754     case Bytecodes::_i2s:
1755       // Sign extend 2 least significant bytes.
1756       __ move_reg_if_needed(Z_tos, T_SHORT, Z_tos, T_INT);
1757       return;
1758     case Bytecodes::_l2i:
1759       // Sign-extend not needed here, upper 4 bytes of int value in register are ignored.
1760       return;
1761     case Bytecodes::_l2f:
1762       __ z_cegbr(Z_ftos, Z_tos);
1763       return;
1764     case Bytecodes::_l2d:
1765       __ z_cdgbr(Z_ftos, Z_tos);
1766       return;
1767     case Bytecodes::_f2i:
1768     case Bytecodes::_f2l:
1769       __ clear_reg(Z_tos, true, false);  // Don&#39;t set CC.
1770       __ z_cebr(Z_ftos, Z_ftos);
1771       __ z_brno(done); // NaN -&gt; 0
1772       if (bytecode() == Bytecodes::_f2i)
1773         __ z_cfebr(Z_tos, Z_ftos, Assembler::to_zero);
1774       else // bytecode() == Bytecodes::_f2l
1775         __ z_cgebr(Z_tos, Z_ftos, Assembler::to_zero);
1776       break;
1777     case Bytecodes::_f2d:
1778       __ move_freg_if_needed(Z_ftos, T_DOUBLE, Z_ftos, T_FLOAT);
1779       return;
1780     case Bytecodes::_d2i:
1781     case Bytecodes::_d2l:
1782       __ clear_reg(Z_tos, true, false);  // Ddon&#39;t set CC.
1783       __ z_cdbr(Z_ftos, Z_ftos);
1784       __ z_brno(done); // NaN -&gt; 0
1785       if (bytecode() == Bytecodes::_d2i)
1786         __ z_cfdbr(Z_tos, Z_ftos, Assembler::to_zero);
1787       else // Bytecodes::_d2l
1788         __ z_cgdbr(Z_tos, Z_ftos, Assembler::to_zero);
1789       break;
1790     case Bytecodes::_d2f:
1791       __ move_freg_if_needed(Z_ftos, T_FLOAT, Z_ftos, T_DOUBLE);
1792       return;
1793     default:
1794       ShouldNotReachHere();
1795   }
1796   __ bind(done);
1797 }
1798 
1799 void TemplateTable::lcmp() {
1800   transition(ltos, itos);
1801 
1802   Label   done;
1803   Register val1 = Z_R0_scratch;
1804   Register val2 = Z_R1_scratch;
1805 
1806   if (VM_Version::has_LoadStoreConditional()) {
1807     __ pop_l(val1);           // pop value 1.
1808     __ z_lghi(val2,  -1);     // lt value
1809     __ z_cgr(val1, Z_tos);    // Compare with Z_tos (value 2). Protect CC under all circumstances.
1810     __ z_lghi(val1,   1);     // gt value
1811     __ z_lghi(Z_tos,  0);     // eq value
1812 
1813     __ z_locgr(Z_tos, val1, Assembler::bcondHigh);
1814     __ z_locgr(Z_tos, val2, Assembler::bcondLow);
1815   } else {
1816     __ pop_l(val1);           // Pop value 1.
1817     __ z_cgr(val1, Z_tos);    // Compare with Z_tos (value 2). Protect CC under all circumstances.
1818 
1819     __ z_lghi(Z_tos,  0);     // eq value
1820     __ z_bre(done);
1821 
1822     __ z_lghi(Z_tos,  1);     // gt value
1823     __ z_brh(done);
1824 
1825     __ z_lghi(Z_tos, -1);     // lt value
1826   }
1827 
1828   __ bind(done);
1829 }
1830 
1831 
1832 void TemplateTable::float_cmp(bool is_float, int unordered_result) {
1833   Label done;
1834 
1835   if (is_float) {
1836     __ pop_f(Z_FARG2);
1837     __ z_cebr(Z_FARG2, Z_ftos);
1838   } else {
1839     __ pop_d(Z_FARG2);
1840     __ z_cdbr(Z_FARG2, Z_ftos);
1841   }
1842 
1843   if (VM_Version::has_LoadStoreConditional()) {
1844     Register one       = Z_R0_scratch;
1845     Register minus_one = Z_R1_scratch;
1846     __ z_lghi(minus_one,  -1);
1847     __ z_lghi(one,  1);
1848     __ z_lghi(Z_tos, 0);
1849     __ z_locgr(Z_tos, one,       unordered_result == 1 ? Assembler::bcondHighOrNotOrdered : Assembler::bcondHigh);
1850     __ z_locgr(Z_tos, minus_one, unordered_result == 1 ? Assembler::bcondLow              : Assembler::bcondLowOrNotOrdered);
1851   } else {
1852     // Z_FARG2 == Z_ftos
1853     __ clear_reg(Z_tos, false, false);
1854     __ z_bre(done);
1855 
1856     // F_ARG2 &gt; Z_Ftos, or unordered
1857     __ z_lhi(Z_tos, 1);
1858     __ z_brc(unordered_result == 1 ? Assembler::bcondHighOrNotOrdered : Assembler::bcondHigh, done);
1859 
1860     // F_ARG2 &lt; Z_FTOS, or unordered
1861     __ z_lhi(Z_tos, -1);
1862 
1863     __ bind(done);
1864   }
1865 }
1866 
1867 void TemplateTable::branch(bool is_jsr, bool is_wide) {
1868   const Register   bumped_count = Z_tmp_1;
1869   const Register   method       = Z_tmp_2;
1870   const Register   m_counters   = Z_R1_scratch;
1871   const Register   mdo          = Z_tos;
1872 
1873   BLOCK_COMMENT(&quot;TemplateTable::branch {&quot;);
1874   __ get_method(method);
1875   __ profile_taken_branch(mdo, bumped_count);
1876 
1877   const ByteSize ctr_offset = InvocationCounter::counter_offset();
1878   const ByteSize be_offset  = MethodCounters::backedge_counter_offset()   + ctr_offset;
1879   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() + ctr_offset;
1880 
1881   // Get (wide) offset to disp.
1882   const Register disp = Z_ARG5;
1883   if (is_wide) {
1884     __ get_4_byte_integer_at_bcp(disp, 1);
1885   } else {
1886     __ get_2_byte_integer_at_bcp(disp, 1, InterpreterMacroAssembler::Signed);
1887   }
1888 
1889   // Handle all the JSR stuff here, then exit.
1890   // It&#39;s much shorter and cleaner than intermingling with the
1891   // non-JSR normal-branch stuff occurring below.
1892   if (is_jsr) {
1893     // Compute return address as bci in Z_tos.
1894     __ z_lgr(Z_R1_scratch, Z_bcp);
1895     __ z_sg(Z_R1_scratch, Address(method, Method::const_offset()));
1896     __ add2reg(Z_tos, (is_wide ? 5 : 3) - in_bytes(ConstMethod::codes_offset()), Z_R1_scratch);
1897 
1898     // Bump bcp to target of JSR.
1899     __ z_agr(Z_bcp, disp);
1900     // Push return address for &quot;ret&quot; on stack.
1901     __ push_ptr(Z_tos);
1902     // And away we go!
1903     __ dispatch_next(vtos, 0 , true);
1904     return;
1905   }
1906 
1907   // Normal (non-jsr) branch handling.
1908 
1909   // Bump bytecode pointer by displacement (take the branch).
1910   __ z_agr(Z_bcp, disp);
1911 
1912   assert(UseLoopCounter || !UseOnStackReplacement,
1913          &quot;on-stack-replacement requires loop counters&quot;);
1914 
1915   NearLabel backedge_counter_overflow;
1916   NearLabel profile_method;
1917   NearLabel dispatch;
1918   int       increment = InvocationCounter::count_increment;
1919 
1920   if (UseLoopCounter) {
1921     // Increment backedge counter for backward branches.
1922     // disp: target offset
1923     // Z_bcp: target bcp
1924     // Z_locals: locals pointer
1925     //
1926     // Count only if backward branch.
1927     __ compare32_and_branch(disp, (intptr_t)0, Assembler::bcondHigh, dispatch);
1928 
1929     if (TieredCompilation) {
1930       Label noCounters;
1931 
1932       if (ProfileInterpreter) {
1933         NearLabel   no_mdo;
1934 
1935         // Are we profiling?
1936         __ load_and_test_long(mdo, Address(method, Method::method_data_offset()));
1937         __ branch_optimized(Assembler::bcondZero, no_mdo);
1938 
1939         // Increment the MDO backedge counter.
1940         const Address mdo_backedge_counter(mdo, MethodData::backedge_counter_offset() + InvocationCounter::counter_offset());
1941 
1942         const Address mask(mdo, MethodData::backedge_mask_offset());
1943         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1944                                    Z_ARG2, false, Assembler::bcondZero,
1945                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
1946         __ z_bru(dispatch);
1947         __ bind(no_mdo);
1948       }
1949 
1950       // Increment backedge counter in MethodCounters*.
1951       __ get_method_counters(method, m_counters, noCounters);
1952       const Address mask(m_counters, MethodCounters::backedge_mask_offset());
1953       __ increment_mask_and_jump(Address(m_counters, be_offset),
1954                                  increment, mask,
1955                                  Z_ARG2, false, Assembler::bcondZero,
1956                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
1957       __ bind(noCounters);
1958     } else {
1959       Register counter = Z_tos;
1960       Label    noCounters;
1961       // Get address of MethodCounters object.
1962       __ get_method_counters(method, m_counters, noCounters);
1963       // Increment backedge counter.
1964       __ increment_backedge_counter(m_counters, counter);
1965 
1966       if (ProfileInterpreter) {
1967         // Test to see if we should create a method data obj.
1968         __ z_cl(counter, Address(m_counters, MethodCounters::interpreter_profile_limit_offset()));
1969         __ z_brl(dispatch);
1970 
1971         // If no method data exists, go to profile method.
1972         __ test_method_data_pointer(Z_ARG4/*result unused*/, profile_method);
1973 
1974         if (UseOnStackReplacement) {
1975           // Check for overflow against &#39;bumped_count&#39; which is the MDO taken count.
1976           __ z_cl(bumped_count, Address(m_counters, MethodCounters::interpreter_backward_branch_limit_offset()));
1977           __ z_brl(dispatch);
1978 
1979           // When ProfileInterpreter is on, the backedge_count comes
1980           // from the methodDataOop, which value does not get reset on
1981           // the call to frequency_counter_overflow(). To avoid
1982           // excessive calls to the overflow routine while the method is
1983           // being compiled, add a second test to make sure the overflow
1984           // function is called only once every overflow_frequency.
1985           const int overflow_frequency = 1024;
1986           __ and_imm(bumped_count, overflow_frequency - 1);
1987           __ z_brz(backedge_counter_overflow);
1988 
1989         }
1990       } else {
1991         if (UseOnStackReplacement) {
1992           // Check for overflow against &#39;counter&#39;, which is the sum of the
1993           // counters.
1994           __ z_cl(counter, Address(m_counters, MethodCounters::interpreter_backward_branch_limit_offset()));
1995           __ z_brh(backedge_counter_overflow);
1996         }
1997       }
1998       __ bind(noCounters);
1999     }
2000 
2001     __ bind(dispatch);
2002   }
2003 
2004   // Pre-load the next target bytecode into rbx.
2005   __ z_llgc(Z_bytecode, Address(Z_bcp, (intptr_t) 0));
2006 
2007   // Continue with the bytecode @ target.
2008   // Z_tos: Return bci for jsr&#39;s, unused otherwise.
2009   // Z_bytecode: target bytecode
2010   // Z_bcp: target bcp
2011   __ dispatch_only(vtos, true);
2012 
2013   // Out-of-line code runtime calls.
2014   if (UseLoopCounter) {
2015     if (ProfileInterpreter) {
2016       // Out-of-line code to allocate method data oop.
2017       __ bind(profile_method);
2018 
2019       __ call_VM(noreg,
2020                  CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2021       __ z_llgc(Z_bytecode, Address(Z_bcp, (intptr_t) 0));  // Restore target bytecode.
2022       __ set_method_data_pointer_for_bcp();
2023       __ z_bru(dispatch);
2024     }
2025 
2026     if (UseOnStackReplacement) {
2027 
2028       // invocation counter overflow
2029       __ bind(backedge_counter_overflow);
2030 
2031       __ z_lcgr(Z_ARG2, disp); // Z_ARG2 := -disp
2032       __ z_agr(Z_ARG2, Z_bcp); // Z_ARG2 := branch target bcp - disp == branch bcp
2033       __ call_VM(noreg,
2034                  CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow),
2035                  Z_ARG2);
2036 
2037       // Z_RET: osr nmethod (osr ok) or NULL (osr not possible).
2038       __ compare64_and_branch(Z_RET, (intptr_t) 0, Assembler::bcondEqual, dispatch);
2039 
2040       // Nmethod may have been invalidated (VM may block upon call_VM return).
2041       __ z_cliy(nmethod::state_offset(), Z_RET, nmethod::in_use);
2042       __ z_brne(dispatch);
2043 
2044       // Migrate the interpreter frame off of the stack.
2045 
2046       __ z_lgr(Z_tmp_1, Z_RET); // Save the nmethod.
2047 
2048       call_VM(noreg,
2049               CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2050 
2051       // Z_RET is OSR buffer, move it to expected parameter location.
2052       __ lgr_if_needed(Z_ARG1, Z_RET);
2053 
2054       // Pop the interpreter frame ...
2055       __ pop_interpreter_frame(Z_R14, Z_ARG2/*tmp1*/, Z_ARG3/*tmp2*/);
2056 
2057       // ... and begin the OSR nmethod.
2058       __ z_lg(Z_R1_scratch, Address(Z_tmp_1, nmethod::osr_entry_point_offset()));
2059       __ z_br(Z_R1_scratch);
2060     }
2061   }
2062   BLOCK_COMMENT(&quot;} TemplateTable::branch&quot;);
2063 }
2064 
2065 void TemplateTable::if_0cmp(Condition cc) {
2066   transition(itos, vtos);
2067 
2068   // Assume branch is more often taken than not (loops use backward branches).
2069   NearLabel not_taken;
2070   __ compare32_and_branch(Z_tos, (intptr_t) 0, j_not(cc), not_taken);
2071   branch(false, false);
2072   __ bind(not_taken);
2073   __ profile_not_taken_branch(Z_tos);
2074 }
2075 
2076 void TemplateTable::if_icmp(Condition cc) {
2077   transition(itos, vtos);
2078 
2079   // Assume branch is more often taken than not (loops use backward branches).
2080   NearLabel not_taken;
2081   __ pop_i(Z_R0_scratch);
2082   __ compare32_and_branch(Z_R0_scratch, Z_tos, j_not(cc), not_taken);
2083   branch(false, false);
2084   __ bind(not_taken);
2085   __ profile_not_taken_branch(Z_tos);
2086 }
2087 
2088 void TemplateTable::if_nullcmp(Condition cc) {
2089   transition(atos, vtos);
2090 
2091   // Assume branch is more often taken than not (loops use backward branches) .
2092   NearLabel not_taken;
2093   __ compare64_and_branch(Z_tos, (intptr_t) 0, j_not(cc), not_taken);
2094   branch(false, false);
2095   __ bind(not_taken);
2096   __ profile_not_taken_branch(Z_tos);
2097 }
2098 
2099 void TemplateTable::if_acmp(Condition cc) {
2100   transition(atos, vtos);
2101   // Assume branch is more often taken than not (loops use backward branches).
2102   NearLabel not_taken;
2103   __ pop_ptr(Z_ARG2);
2104   __ verify_oop(Z_ARG2);
2105   __ verify_oop(Z_tos);
2106   __ compareU64_and_branch(Z_tos, Z_ARG2, j_not(cc), not_taken);
2107   branch(false, false);
2108   __ bind(not_taken);
2109   __ profile_not_taken_branch(Z_ARG3);
2110 }
2111 
2112 void TemplateTable::ret() {
2113   transition(vtos, vtos);
2114 
2115   locals_index(Z_tmp_1);
2116   // Get return bci, compute return bcp. Must load 64 bits.
2117   __ mem2reg_opt(Z_tmp_1, iaddress(_masm, Z_tmp_1));
2118   __ profile_ret(Z_tmp_1, Z_tmp_2);
2119   __ get_method(Z_tos);
2120   __ mem2reg_opt(Z_R1_scratch, Address(Z_tos, Method::const_offset()));
2121   __ load_address(Z_bcp, Address(Z_R1_scratch, Z_tmp_1, ConstMethod::codes_offset()));
2122   __ dispatch_next(vtos, 0 , true);
2123 }
2124 
2125 void TemplateTable::wide_ret() {
2126   transition(vtos, vtos);
2127 
2128   locals_index_wide(Z_tmp_1);
2129   // Get return bci, compute return bcp.
2130   __ mem2reg_opt(Z_tmp_1, aaddress(_masm, Z_tmp_1));
2131   __ profile_ret(Z_tmp_1, Z_tmp_2);
2132   __ get_method(Z_tos);
2133   __ mem2reg_opt(Z_R1_scratch, Address(Z_tos, Method::const_offset()));
2134   __ load_address(Z_bcp, Address(Z_R1_scratch, Z_tmp_1, ConstMethod::codes_offset()));
2135   __ dispatch_next(vtos, 0, true);
2136 }
2137 
2138 void TemplateTable::tableswitch () {
2139   transition(itos, vtos);
2140 
2141   NearLabel default_case, continue_execution;
2142   Register  bcp = Z_ARG5;
2143   // Align bcp.
2144   __ load_address(bcp, at_bcp(BytesPerInt));
2145   __ z_nill(bcp, (-BytesPerInt) &amp; 0xffff);
2146 
2147   // Load lo &amp; hi.
2148   Register low  = Z_tmp_1;
2149   Register high = Z_tmp_2;
2150 
2151   // Load low into 64 bits, since used for address calculation.
2152   __ mem2reg_signed_opt(low, Address(bcp, BytesPerInt));
2153   __ mem2reg_opt(high, Address(bcp, 2 * BytesPerInt), false);
2154   // Sign extend &quot;label&quot; value for address calculation.
2155   __ z_lgfr(Z_tos, Z_tos);
2156 
2157   // Check against lo &amp; hi.
2158   __ compare32_and_branch(Z_tos, low, Assembler::bcondLow, default_case);
2159   __ compare32_and_branch(Z_tos, high, Assembler::bcondHigh, default_case);
2160 
2161   // Lookup dispatch offset.
2162   __ z_sgr(Z_tos, low);
2163   Register jump_table_offset = Z_ARG3;
2164   // Index2offset; index in Z_tos is killed by profile_switch_case.
2165   __ z_sllg(jump_table_offset, Z_tos, LogBytesPerInt);
2166   __ profile_switch_case(Z_tos, Z_ARG4 /*tmp for mdp*/, low/*tmp*/, Z_bytecode/*tmp*/);
2167 
2168   Register index = Z_tmp_2;
2169 
2170   // Load index sign extended for addressing.
2171   __ mem2reg_signed_opt(index, Address(bcp, jump_table_offset, 3 * BytesPerInt));
2172 
2173   // Continue execution.
2174   __ bind(continue_execution);
2175 
2176   // Load next bytecode.
2177   __ z_llgc(Z_bytecode, Address(Z_bcp, index));
2178   __ z_agr(Z_bcp, index); // Advance bcp.
2179   __ dispatch_only(vtos, true);
2180 
2181   // Handle default.
2182   __ bind(default_case);
2183 
2184   __ profile_switch_default(Z_tos);
2185   __ mem2reg_signed_opt(index, Address(bcp));
2186   __ z_bru(continue_execution);
2187 }
2188 
2189 void TemplateTable::lookupswitch () {
2190   transition(itos, itos);
2191   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2192 }
2193 
2194 void TemplateTable::fast_linearswitch () {
2195   transition(itos, vtos);
2196 
2197   Label    loop_entry, loop, found, continue_execution;
2198   Register bcp = Z_ARG5;
2199 
2200   // Align bcp.
2201   __ load_address(bcp, at_bcp(BytesPerInt));
2202   __ z_nill(bcp, (-BytesPerInt) &amp; 0xffff);
2203 
2204   // Start search with last case.
2205   Register current_case_offset = Z_tmp_1;
2206 
2207   __ mem2reg_signed_opt(current_case_offset, Address(bcp, BytesPerInt));
2208   __ z_sllg(current_case_offset, current_case_offset, LogBytesPerWord);   // index2bytes
2209   __ z_bru(loop_entry);
2210 
2211   // table search
2212   __ bind(loop);
2213 
2214   __ z_c(Z_tos, Address(bcp, current_case_offset, 2 * BytesPerInt));
2215   __ z_bre(found);
2216 
2217   __ bind(loop_entry);
2218   __ z_aghi(current_case_offset, -2 * BytesPerInt);  // Decrement.
2219   __ z_brnl(loop);
2220 
2221   // default case
2222   Register   offset = Z_tmp_2;
2223 
2224   __ profile_switch_default(Z_tos);
2225   // Load offset sign extended for addressing.
2226   __ mem2reg_signed_opt(offset, Address(bcp));
2227   __ z_bru(continue_execution);
2228 
2229   // Entry found -&gt; get offset.
2230   __ bind(found);
2231   __ mem2reg_signed_opt(offset, Address(bcp, current_case_offset, 3 * BytesPerInt));
2232   // Profile that this case was taken.
2233   Register current_case_idx = Z_ARG4;
2234   __ z_srlg(current_case_idx, current_case_offset, LogBytesPerWord); // bytes2index
2235   __ profile_switch_case(current_case_idx, Z_tos, bcp, Z_bytecode);
2236 
2237   // Continue execution.
2238   __ bind(continue_execution);
2239 
2240   // Load next bytecode.
2241   __ z_llgc(Z_bytecode, Address(Z_bcp, offset, 0));
2242   __ z_agr(Z_bcp, offset); // Advance bcp.
2243   __ dispatch_only(vtos, true);
2244 }
2245 
2246 
2247 void TemplateTable::fast_binaryswitch() {
2248 
2249   transition(itos, vtos);
2250 
2251   // Implementation using the following core algorithm:
2252   //
2253   // int binary_search(int key, LookupswitchPair* array, int n) {
2254   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2255   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2256   //   int i = 0;
2257   //   int j = n;
2258   //   while (i+1 &lt; j) {
2259   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2260   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2261   //     // where a stands for the array and assuming that the (inexisting)
2262   //     // element a[n] is infinitely big.
2263   //     int h = (i + j) &gt;&gt; 1;
2264   //     // i &lt; h &lt; j
2265   //     if (key &lt; array[h].fast_match()) {
2266   //       j = h;
2267   //     } else {
2268   //       i = h;
2269   //     }
2270   //   }
2271   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2272   //   // (i.e., if key is within array, i is the correct index)
2273   //   return i;
2274   // }
2275 
2276   // Register allocation
2277   // Note: Since we use the indices in address operands, we do all the
2278   // computation in 64 bits.
2279   const Register key   = Z_tos; // Already set (tosca).
2280   const Register array = Z_tmp_1;
2281   const Register i     = Z_tmp_2;
2282   const Register j     = Z_ARG5;
2283   const Register h     = Z_ARG4;
2284   const Register temp  = Z_R1_scratch;
2285 
2286   // Find array start.
2287   __ load_address(array, at_bcp(3 * BytesPerInt));
2288   __ z_nill(array, (-BytesPerInt) &amp; 0xffff);   // align
2289 
2290   // Initialize i &amp; j.
2291   __ clear_reg(i, true, false);  // i = 0;  Don&#39;t set CC.
2292   __ mem2reg_signed_opt(j, Address(array, -BytesPerInt)); // j = length(array);
2293 
2294   // And start.
2295   Label entry;
2296   __ z_bru(entry);
2297 
2298   // binary search loop
2299   {
2300     NearLabel   loop;
2301 
2302     __ bind(loop);
2303 
2304     // int h = (i + j) &gt;&gt; 1;
2305     __ add2reg_with_index(h, 0, i, j); // h = i + j;
2306     __ z_srag(h, h, 1);                // h = (i + j) &gt;&gt; 1;
2307 
2308     // if (key &lt; array[h].fast_match()) {
2309     //   j = h;
2310     // } else {
2311     //   i = h;
2312     // }
2313 
2314     // Convert array[h].match to native byte-ordering before compare.
2315     __ z_sllg(temp, h, LogBytesPerWord);   // index2bytes
2316     __ mem2reg_opt(temp, Address(array, temp), false);
2317 
2318     NearLabel  else_;
2319 
2320     __ compare32_and_branch(key, temp, Assembler::bcondNotLow, else_);
2321     // j = h if (key &lt;  array[h].fast_match())
2322     __ z_lgr(j, h);
2323     __ z_bru(entry); // continue
2324 
2325     __ bind(else_);
2326 
2327     // i = h if (key &gt;= array[h].fast_match())
2328     __ z_lgr(i, h);  // and fallthrough
2329 
2330     // while (i+1 &lt; j)
2331     __ bind(entry);
2332 
2333     // if (i + 1 &lt; j) continue search
2334     __ add2reg(h, 1, i);
2335     __ compare64_and_branch(h, j, Assembler::bcondLow, loop);
2336   }
2337 
2338   // End of binary search, result index is i (must check again!).
2339   NearLabel default_case;
2340 
2341   // h is no longer needed, so use it to hold the byte offset.
2342   __ z_sllg(h, i, LogBytesPerWord);   // index2bytes
2343   __ mem2reg_opt(temp, Address(array, h), false);
2344   __ compare32_and_branch(key, temp, Assembler::bcondNotEqual, default_case);
2345 
2346   // entry found -&gt; j = offset
2347   __ mem2reg_signed_opt(j, Address(array, h, BytesPerInt));
2348   __ profile_switch_case(i, key, array, Z_bytecode);
2349   // Load next bytecode.
2350   __ z_llgc(Z_bytecode, Address(Z_bcp, j));
2351   __ z_agr(Z_bcp, j);       // Advance bcp.
2352   __ dispatch_only(vtos, true);
2353 
2354   // default case -&gt; j = default offset
2355   __ bind(default_case);
2356 
2357   __ profile_switch_default(i);
2358   __ mem2reg_signed_opt(j, Address(array, -2 * BytesPerInt));
2359   // Load next bytecode.
2360   __ z_llgc(Z_bytecode, Address(Z_bcp, j));
2361   __ z_agr(Z_bcp, j);       // Advance bcp.
2362   __ dispatch_only(vtos, true);
2363 }
2364 
2365 void TemplateTable::_return(TosState state) {
2366   transition(state, state);
2367   assert(_desc-&gt;calls_vm(),
2368          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2369 
2370   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2371     Register Rthis  = Z_ARG2;
2372     Register Rklass = Z_ARG5;
2373     Label skip_register_finalizer;
2374     assert(state == vtos, &quot;only valid state&quot;);
2375     __ z_lg(Rthis, aaddress(0));
2376     __ load_klass(Rklass, Rthis);
2377     __ testbit(Address(Rklass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));
2378     __ z_bfalse(skip_register_finalizer);
2379     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), Rthis);
2380     __ bind(skip_register_finalizer);
2381   }
2382 
2383   if (_desc-&gt;bytecode() != Bytecodes::_return_register_finalizer) {
2384     Label no_safepoint;
2385     const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);
2386     __ z_tm(poll_byte_addr, SafepointMechanism::poll_bit());
2387     __ z_braz(no_safepoint);
2388     __ push(state);
2389     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint));
2390     __ pop(state);
2391     __ bind(no_safepoint);
2392   }
2393 
2394   if (state == itos) {
2395     // Narrow result if state is itos but result type is smaller.
2396     // Need to narrow in the return bytecode rather than in generate_return_entry
2397     // since compiled code callers expect the result to already be narrowed.
2398     __ narrow(Z_tos, Z_tmp_1); /* fall through */
2399   }
2400 
2401   __ remove_activation(state, Z_R14);
2402   __ z_br(Z_R14);
2403 }
2404 
2405 // ----------------------------------------------------------------------------
2406 // NOTE: Cpe_offset is already computed as byte offset, so we must not
2407 // shift it afterwards!
2408 void TemplateTable::resolve_cache_and_index(int byte_no,
2409                                             Register cache,
2410                                             Register cpe_offset,
2411                                             size_t index_size) {
2412   BLOCK_COMMENT(&quot;resolve_cache_and_index {&quot;);
2413   NearLabel      resolved, clinit_barrier_slow;
2414   const Register bytecode_in_cpcache = Z_R1_scratch;
2415   const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());
2416   assert_different_registers(cache, cpe_offset, bytecode_in_cpcache);
2417 
2418   Bytecodes::Code code = bytecode();
2419   switch (code) {
2420     case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2421     case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2422     default:
2423       break;
2424   }
2425 
2426   {
2427     assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2428     __ get_cache_and_index_and_bytecode_at_bcp(cache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);
2429     // Have we resolved this bytecode?
2430     __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);
2431   }
2432 
2433   // Resolve first time through.
2434   // Class initialization barrier slow path lands here as well.
2435   __ bind(clinit_barrier_slow);
2436   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2437   __ load_const_optimized(Z_ARG2, (int) code);
2438   __ call_VM(noreg, entry, Z_ARG2);
2439 
2440   // Update registers with resolved info.
2441   __ get_cache_and_index_at_bcp(cache, cpe_offset, 1, index_size);
2442   __ bind(resolved);
2443 
2444   // Class initialization barrier for static methods
2445   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2446     const Register method = Z_R1_scratch;
2447     const Register klass  = Z_R1_scratch;
2448 
2449     __ load_resolved_method_at_index(byte_no, cache, cpe_offset, method);
2450     __ load_method_holder(klass, method);
2451     __ clinit_barrier(klass, Z_thread, NULL /*L_fast_path*/, &amp;clinit_barrier_slow);
2452   }
2453 
2454   BLOCK_COMMENT(&quot;} resolve_cache_and_index&quot;);
2455 }
2456 
2457 // The Rcache and index registers must be set before call.
2458 // Index is already a byte offset, don&#39;t shift!
2459 void TemplateTable::load_field_cp_cache_entry(Register obj,
2460                                               Register cache,
2461                                               Register index,
2462                                               Register off,
2463                                               Register flags,
2464                                               bool is_static = false) {
2465   assert_different_registers(cache, index, flags, off);
2466   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2467 
2468   // Field offset
2469   __ mem2reg_opt(off, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f2_offset()));
2470   // Flags. Must load 64 bits.
2471   __ mem2reg_opt(flags, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::flags_offset()));
2472 
2473   // klass overwrite register
2474   if (is_static) {
2475     __ mem2reg_opt(obj, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f1_offset()));
2476     __ mem2reg_opt(obj, Address(obj, Klass::java_mirror_offset()));
2477     __ resolve_oop_handle(obj);
2478   }
2479 }
2480 
2481 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2482                                                Register method,
2483                                                Register itable_index,
2484                                                Register flags,
2485                                                bool is_invokevirtual,
2486                                                bool is_invokevfinal, // unused
2487                                                bool is_invokedynamic) {
2488   BLOCK_COMMENT(&quot;load_invoke_cp_cache_entry {&quot;);
2489   // Setup registers.
2490   const Register cache     = Z_ARG1;
2491   const Register cpe_offset= flags;
2492   const ByteSize base_off  = ConstantPoolCache::base_offset();
2493   const ByteSize f1_off    = ConstantPoolCacheEntry::f1_offset();
2494   const ByteSize f2_off    = ConstantPoolCacheEntry::f2_offset();
2495   const ByteSize flags_off = ConstantPoolCacheEntry::flags_offset();
2496   const int method_offset  = in_bytes(base_off + ((byte_no == f2_byte) ? f2_off : f1_off));
2497   const int flags_offset   = in_bytes(base_off + flags_off);
2498   // Access constant pool cache fields.
2499   const int index_offset   = in_bytes(base_off + f2_off);
2500 
2501   assert_different_registers(method, itable_index, flags, cache);
2502   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2503 
2504   if (is_invokevfinal) {
2505     // Already resolved.
2506      assert(itable_index == noreg, &quot;register not used&quot;);
2507      __ get_cache_and_index_at_bcp(cache, cpe_offset, 1);
2508   } else {
2509     // Need to resolve.
2510     resolve_cache_and_index(byte_no, cache, cpe_offset, is_invokedynamic ? sizeof(u4) : sizeof(u2));
2511   }
2512   __ z_lg(method, Address(cache, cpe_offset, method_offset));
2513 
2514   if (itable_index != noreg) {
2515     __ z_lg(itable_index, Address(cache, cpe_offset, index_offset));
2516   }
2517 
2518   // Only load the lower 4 bytes and fill high bytes of flags with zeros.
2519   // Callers depend on this zero-extension!!!
2520   // Attention: overwrites cpe_offset == flags
2521   __ z_llgf(flags, Address(cache, cpe_offset, flags_offset + (BytesPerLong-BytesPerInt)));
2522 
2523   BLOCK_COMMENT(&quot;} load_invoke_cp_cache_entry&quot;);
2524 }
2525 
2526 // The registers cache and index expected to be set before call.
2527 // Correct values of the cache and index registers are preserved.
2528 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2529                                             bool is_static, bool has_tos) {
2530 
2531   // Do the JVMTI work here to avoid disturbing the register state below.
2532   // We use c_rarg registers here because we want to use the register used in
2533   // the call to the VM
2534   if (!JvmtiExport::can_post_field_access()) {
2535     return;
2536   }
2537 
2538   // Check to see if a field access watch has been set before we
2539   // take the time to call into the VM.
2540   Label exit;
2541   assert_different_registers(cache, index, Z_tos);
2542   __ load_absolute_address(Z_tos, (address)JvmtiExport::get_field_access_count_addr());
2543   __ load_and_test_int(Z_R0, Address(Z_tos));
2544   __ z_brz(exit);
2545 
2546   // Index is returned as byte offset, do not shift!
2547   __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);
2548 
2549   // cache entry pointer
2550   __ add2reg_with_index(Z_ARG3,
2551                         in_bytes(ConstantPoolCache::base_offset()),
2552                         Z_ARG3, Z_R1_scratch);
2553 
2554   if (is_static) {
2555     __ clear_reg(Z_ARG2, true, false); // NULL object reference. Don&#39;t set CC.
2556   } else {
2557     __ mem2reg_opt(Z_ARG2, at_tos());  // Get object pointer without popping it.
2558     __ verify_oop(Z_ARG2);
2559   }
2560   // Z_ARG2: object pointer or NULL
2561   // Z_ARG3: cache entry pointer
2562   __ call_VM(noreg,
2563              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
2564              Z_ARG2, Z_ARG3);
2565   __ get_cache_and_index_at_bcp(cache, index, 1);
2566 
2567   __ bind(exit);
2568 }
2569 
2570 void TemplateTable::pop_and_check_object(Register r) {
2571   __ pop_ptr(r);
2572   __ null_check(r);  // for field access must check obj.
2573   __ verify_oop(r);
2574 }
2575 
2576 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2577   transition(vtos, vtos);
2578 
2579   const Register cache = Z_tmp_1;
2580   const Register index = Z_tmp_2;
2581   const Register obj   = Z_tmp_1;
2582   const Register off   = Z_ARG2;
2583   const Register flags = Z_ARG1;
2584   const Register bc    = Z_tmp_1;  // Uses same reg as obj, so don&#39;t mix them.
2585 
2586   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2587   jvmti_post_field_access(cache, index, is_static, false);
2588   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2589 
2590   if (!is_static) {
2591     // Obj is on the stack.
2592     pop_and_check_object(obj);
2593   }
2594 
2595   // Displacement is 0, so any store instruction will be fine on any CPU.
2596   const Address field(obj, off);
2597 
2598   Label    is_Byte, is_Bool, is_Int, is_Short, is_Char,
2599            is_Long, is_Float, is_Object, is_Double;
2600   Label    is_badState8, is_badState9, is_badStateA, is_badStateB,
2601            is_badStateC, is_badStateD, is_badStateE, is_badStateF,
2602            is_badState;
2603   Label    branchTable, atosHandler,  Done;
2604   Register br_tab       = Z_R1_scratch;
2605   bool     do_rewrite   = !is_static &amp;&amp; (rc == may_rewrite);
2606   bool     dont_rewrite = (is_static || (rc == may_not_rewrite));
2607 
2608   assert(do_rewrite == !dont_rewrite, &quot;Oops, code is not fit for that&quot;);
2609   assert(btos == 0, &quot;change code, btos != 0&quot;);
2610 
2611   // Calculate branch table size. Generated code size depends on ASSERT and on bytecode rewriting.
2612 #ifdef ASSERT
2613   const unsigned int bsize = dont_rewrite ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2614 #else
2615   const unsigned int bsize = dont_rewrite ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2616 #endif
2617 
2618   // Calculate address of branch table entry and branch there.
2619   {
2620     const int bit_shift = exact_log2(bsize); // Size of each branch table entry.
2621     const int r_bitpos  = 63 - bit_shift;
2622     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
2623     const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);
2624     __ z_larl(br_tab, branchTable);
2625     __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);
2626   }
2627   __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);
2628 
2629   __ align_address(bsize);
2630   BIND(branchTable);
2631 
2632   // btos
2633   BTB_BEGIN(is_Byte, bsize, &quot;getfield_or_static:is_Byte&quot;);
2634   __ z_lb(Z_tos, field);
2635   __ push(btos);
2636   // Rewrite bytecode to be faster.
2637   if (do_rewrite) {
2638     patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);
2639   }
2640   __ z_bru(Done);
2641   BTB_END(is_Byte, bsize, &quot;getfield_or_static:is_Byte&quot;);
2642 
2643   // ztos
2644   BTB_BEGIN(is_Bool, bsize, &quot;getfield_or_static:is_Bool&quot;);
2645   __ z_lb(Z_tos, field);
2646   __ push(ztos);
2647   // Rewrite bytecode to be faster.
2648   if (do_rewrite) {
2649     // Use btos rewriting, no truncating to t/f bit is needed for getfield.
2650     patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);
2651   }
2652   __ z_bru(Done);
2653   BTB_END(is_Bool, bsize, &quot;getfield_or_static:is_Bool&quot;);
2654 
2655   // ctos
2656   BTB_BEGIN(is_Char, bsize, &quot;getfield_or_static:is_Char&quot;);
2657   // Load into 64 bits, works on all CPUs.
2658   __ z_llgh(Z_tos, field);
2659   __ push(ctos);
2660   // Rewrite bytecode to be faster.
2661   if (do_rewrite) {
2662     patch_bytecode(Bytecodes::_fast_cgetfield, bc, Z_ARG5);
2663   }
2664   __ z_bru(Done);
2665   BTB_END(is_Char, bsize, &quot;getfield_or_static:is_Char&quot;);
2666 
2667   // stos
2668   BTB_BEGIN(is_Short, bsize, &quot;getfield_or_static:is_Short&quot;);
2669   __ z_lh(Z_tos, field);
2670   __ push(stos);
2671   // Rewrite bytecode to be faster.
2672   if (do_rewrite) {
2673     patch_bytecode(Bytecodes::_fast_sgetfield, bc, Z_ARG5);
2674   }
2675   __ z_bru(Done);
2676   BTB_END(is_Short, bsize, &quot;getfield_or_static:is_Short&quot;);
2677 
2678   // itos
2679   BTB_BEGIN(is_Int, bsize, &quot;getfield_or_static:is_Int&quot;);
2680   __ mem2reg_opt(Z_tos, field, false);
2681   __ push(itos);
2682   // Rewrite bytecode to be faster.
2683   if (do_rewrite) {
2684     patch_bytecode(Bytecodes::_fast_igetfield, bc, Z_ARG5);
2685   }
2686   __ z_bru(Done);
2687   BTB_END(is_Int, bsize, &quot;getfield_or_static:is_Int&quot;);
2688 
2689   // ltos
2690   BTB_BEGIN(is_Long, bsize, &quot;getfield_or_static:is_Long&quot;);
2691   __ mem2reg_opt(Z_tos, field);
2692   __ push(ltos);
2693   // Rewrite bytecode to be faster.
2694   if (do_rewrite) {
2695     patch_bytecode(Bytecodes::_fast_lgetfield, bc, Z_ARG5);
2696   }
2697   __ z_bru(Done);
2698   BTB_END(is_Long, bsize, &quot;getfield_or_static:is_Long&quot;);
2699 
2700   // ftos
2701   BTB_BEGIN(is_Float, bsize, &quot;getfield_or_static:is_Float&quot;);
2702   __ mem2freg_opt(Z_ftos, field, false);
2703   __ push(ftos);
2704   // Rewrite bytecode to be faster.
2705   if (do_rewrite) {
2706     patch_bytecode(Bytecodes::_fast_fgetfield, bc, Z_ARG5);
2707   }
2708   __ z_bru(Done);
2709   BTB_END(is_Float, bsize, &quot;getfield_or_static:is_Float&quot;);
2710 
2711   // dtos
2712   BTB_BEGIN(is_Double, bsize, &quot;getfield_or_static:is_Double&quot;);
2713   __ mem2freg_opt(Z_ftos, field);
2714   __ push(dtos);
2715   // Rewrite bytecode to be faster.
2716   if (do_rewrite) {
2717     patch_bytecode(Bytecodes::_fast_dgetfield, bc, Z_ARG5);
2718   }
2719   __ z_bru(Done);
2720   BTB_END(is_Double, bsize, &quot;getfield_or_static:is_Double&quot;);
2721 
2722   // atos
2723   BTB_BEGIN(is_Object, bsize, &quot;getfield_or_static:is_Object&quot;);
2724   __ z_bru(atosHandler);
2725   BTB_END(is_Object, bsize, &quot;getfield_or_static:is_Object&quot;);
2726 
2727   // Bad state detection comes at no extra runtime cost.
2728   BTB_BEGIN(is_badState8, bsize, &quot;getfield_or_static:is_badState8&quot;);
2729   __ z_illtrap();
2730   __ z_bru(is_badState);
2731   BTB_END( is_badState8, bsize, &quot;getfield_or_static:is_badState8&quot;);
2732   BTB_BEGIN(is_badState9, bsize, &quot;getfield_or_static:is_badState9&quot;);
2733   __ z_illtrap();
2734   __ z_bru(is_badState);
2735   BTB_END( is_badState9, bsize, &quot;getfield_or_static:is_badState9&quot;);
2736   BTB_BEGIN(is_badStateA, bsize, &quot;getfield_or_static:is_badStateA&quot;);
2737   __ z_illtrap();
2738   __ z_bru(is_badState);
2739   BTB_END( is_badStateA, bsize, &quot;getfield_or_static:is_badStateA&quot;);
2740   BTB_BEGIN(is_badStateB, bsize, &quot;getfield_or_static:is_badStateB&quot;);
2741   __ z_illtrap();
2742   __ z_bru(is_badState);
2743   BTB_END( is_badStateB, bsize, &quot;getfield_or_static:is_badStateB&quot;);
2744   BTB_BEGIN(is_badStateC, bsize, &quot;getfield_or_static:is_badStateC&quot;);
2745   __ z_illtrap();
2746   __ z_bru(is_badState);
2747   BTB_END( is_badStateC, bsize, &quot;getfield_or_static:is_badStateC&quot;);
2748   BTB_BEGIN(is_badStateD, bsize, &quot;getfield_or_static:is_badStateD&quot;);
2749   __ z_illtrap();
2750   __ z_bru(is_badState);
2751   BTB_END( is_badStateD, bsize, &quot;getfield_or_static:is_badStateD&quot;);
2752   BTB_BEGIN(is_badStateE, bsize, &quot;getfield_or_static:is_badStateE&quot;);
2753   __ z_illtrap();
2754   __ z_bru(is_badState);
2755   BTB_END( is_badStateE, bsize, &quot;getfield_or_static:is_badStateE&quot;);
2756   BTB_BEGIN(is_badStateF, bsize, &quot;getfield_or_static:is_badStateF&quot;);
2757   __ z_illtrap();
2758   __ z_bru(is_badState);
2759   BTB_END( is_badStateF, bsize, &quot;getfield_or_static:is_badStateF&quot;);
2760 
2761   __ align_address(64);
2762   BIND(is_badState);  // Do this outside branch table. Needs a lot of space.
2763   {
2764     unsigned int b_off = __ offset();
2765     if (is_static) {
2766       __ stop_static(&quot;Bad state in getstatic&quot;);
2767     } else {
2768       __ stop_static(&quot;Bad state in getfield&quot;);
2769     }
2770     unsigned int e_off = __ offset();
2771   }
2772 
2773   __ align_address(64);
2774   BIND(atosHandler);  // Oops are really complicated to handle.
2775                       // There is a lot of code generated.
2776                       // Therefore: generate the handler outside of branch table.
2777                       // There is no performance penalty. The additional branch
2778                       // to here is compensated for by the fallthru to &quot;Done&quot;.
2779   {
2780     unsigned int b_off = __ offset();
2781     do_oop_load(_masm, field, Z_tos, Z_tmp_2, Z_tmp_3, IN_HEAP);
2782     __ verify_oop(Z_tos);
2783     __ push(atos);
2784     if (do_rewrite) {
2785       patch_bytecode(Bytecodes::_fast_agetfield, bc, Z_ARG5);
2786     }
2787     unsigned int e_off = __ offset();
2788   }
2789 
2790   BIND(Done);
2791 }
2792 
2793 void TemplateTable::getfield(int byte_no) {
2794   BLOCK_COMMENT(&quot;getfield  {&quot;);
2795   getfield_or_static(byte_no, false);
2796   BLOCK_COMMENT(&quot;} getfield&quot;);
2797 }
2798 
2799 void TemplateTable::nofast_getfield(int byte_no) {
2800   getfield_or_static(byte_no, false, may_not_rewrite);
2801 }
2802 
2803 void TemplateTable::getstatic(int byte_no) {
2804   BLOCK_COMMENT(&quot;getstatic {&quot;);
2805   getfield_or_static(byte_no, true);
2806   BLOCK_COMMENT(&quot;} getstatic&quot;);
2807 }
2808 
2809 // The registers cache and index expected to be set before call.  The
2810 // function may destroy various registers, just not the cache and
2811 // index registers.
2812 void TemplateTable::jvmti_post_field_mod(Register cache,
2813                                          Register index, bool is_static) {
2814   transition(vtos, vtos);
2815 
2816   if (!JvmtiExport::can_post_field_modification()) {
2817     return;
2818   }
2819 
2820   BLOCK_COMMENT(&quot;jvmti_post_field_mod {&quot;);
2821 
2822   // Check to see if a field modification watch has been set before
2823   // we take the time to call into the VM.
2824   Label    L1;
2825   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2826   assert_different_registers(cache, index, Z_tos);
2827 
2828   __ load_absolute_address(Z_tos, (address)JvmtiExport::get_field_modification_count_addr());
2829   __ load_and_test_int(Z_R0, Address(Z_tos));
2830   __ z_brz(L1);
2831 
2832   // Index is returned as byte offset, do not shift!
2833   __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);
2834 
2835   if (is_static) {
2836     // Life is simple. Null out the object pointer.
2837     __ clear_reg(Z_ARG2, true, false);   // Don&#39;t set CC.
2838   } else {
2839     // Life is harder. The stack holds the value on top, followed by
2840     // the object. We don&#39;t know the size of the value, though. It
2841     // could be one or two words depending on its type. As a result,
2842     // we must find the type to determine where the object is.
2843     __ mem2reg_opt(Z_ARG4,
2844                    Address(Z_ARG3, Z_R1_scratch,
2845                            in_bytes(cp_base_offset + ConstantPoolCacheEntry::flags_offset()) +
2846                            (BytesPerLong - BytesPerInt)),
2847                    false);
2848     __ z_srl(Z_ARG4, ConstantPoolCacheEntry::tos_state_shift);
2849     // Make sure we don&#39;t need to mask Z_ARG4 for tos_state after the above shift.
2850     ConstantPoolCacheEntry::verify_tos_state_shift();
2851     __ mem2reg_opt(Z_ARG2, at_tos(1));  // Initially assume a one word jvalue.
2852 
2853     NearLabel   load_dtos, cont;
2854 
2855     __ compareU32_and_branch(Z_ARG4, (intptr_t) ltos,
2856                               Assembler::bcondNotEqual, load_dtos);
2857     __ mem2reg_opt(Z_ARG2, at_tos(2)); // ltos (two word jvalue)
2858     __ z_bru(cont);
2859 
2860     __ bind(load_dtos);
2861     __ compareU32_and_branch(Z_ARG4, (intptr_t)dtos, Assembler::bcondNotEqual, cont);
2862     __ mem2reg_opt(Z_ARG2, at_tos(2)); // dtos (two word jvalue)
2863 
2864     __ bind(cont);
2865   }
2866   // cache entry pointer
2867 
2868   __ add2reg_with_index(Z_ARG3, in_bytes(cp_base_offset), Z_ARG3, Z_R1_scratch);
2869 
2870   // object(tos)
2871   __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));
2872   // Z_ARG2: object pointer set up above (NULL if static)
2873   // Z_ARG3: cache entry pointer
2874   // Z_ARG4: jvalue object on the stack
2875   __ call_VM(noreg,
2876              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification),
2877              Z_ARG2, Z_ARG3, Z_ARG4);
2878   __ get_cache_and_index_at_bcp(cache, index, 1);
2879 
2880   __ bind(L1);
2881   BLOCK_COMMENT(&quot;} jvmti_post_field_mod&quot;);
2882 }
2883 
2884 
2885 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2886   transition(vtos, vtos);
2887 
2888   const Register cache         = Z_tmp_1;
2889   const Register index         = Z_ARG5;
2890   const Register obj           = Z_tmp_1;
2891   const Register off           = Z_tmp_2;
2892   const Register flags         = Z_R1_scratch;
2893   const Register br_tab        = Z_ARG5;
2894   const Register bc            = Z_tmp_1;
2895   const Register oopStore_tmp1 = Z_R1_scratch;
2896   const Register oopStore_tmp2 = Z_ARG5;
2897   const Register oopStore_tmp3 = Z_R0_scratch;
2898 
2899   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2900   jvmti_post_field_mod(cache, index, is_static);
2901   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2902   // begin of life for:
2903   //   obj, off   long life range
2904   //   flags      short life range, up to branch into branch table
2905   // end of life for:
2906   //   cache, index
2907 
2908   const Address field(obj, off);
2909   Label is_Byte, is_Bool, is_Int, is_Short, is_Char,
2910         is_Long, is_Float, is_Object, is_Double;
2911   Label is_badState8, is_badState9, is_badStateA, is_badStateB,
2912         is_badStateC, is_badStateD, is_badStateE, is_badStateF,
2913         is_badState;
2914   Label branchTable, atosHandler, Done;
2915   bool  do_rewrite   = !is_static &amp;&amp; (rc == may_rewrite);
2916   bool  dont_rewrite = (is_static || (rc == may_not_rewrite));
2917 
2918   assert(do_rewrite == !dont_rewrite, &quot;Oops, code is not fit for that&quot;);
2919 
2920   assert(btos == 0, &quot;change code, btos != 0&quot;);
2921 
2922 #ifdef ASSERT
2923   const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2924 #else
2925   const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*8;
2926 #endif
2927 
2928   // Calculate address of branch table entry and branch there.
2929   {
2930     const int bit_shift = exact_log2(bsize); // Size of each branch table entry.
2931     const int r_bitpos  = 63 - bit_shift;
2932     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
2933     const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);
2934     __ z_larl(br_tab, branchTable);
2935     __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);
2936     __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);
2937   }
2938   // end of life for:
2939   //   flags, br_tab
2940 
2941   __ align_address(bsize);
2942   BIND(branchTable);
2943 
2944   // btos
2945   BTB_BEGIN(is_Byte, bsize, &quot;putfield_or_static:is_Byte&quot;);
2946   __ pop(btos);
2947   if (!is_static) {
2948     pop_and_check_object(obj);
2949   }
2950   __ z_stc(Z_tos, field);
2951   if (do_rewrite) {
2952     patch_bytecode(Bytecodes::_fast_bputfield, bc, Z_ARG5, true, byte_no);
2953   }
2954   __ z_bru(Done);
2955   BTB_END( is_Byte, bsize, &quot;putfield_or_static:is_Byte&quot;);
2956 
2957   // ztos
2958   BTB_BEGIN(is_Bool, bsize, &quot;putfield_or_static:is_Bool&quot;);
2959   __ pop(ztos);
2960   if (!is_static) {
2961     pop_and_check_object(obj);
2962   }
2963   __ z_nilf(Z_tos, 0x1);
2964   __ z_stc(Z_tos, field);
2965   if (do_rewrite) {
2966     patch_bytecode(Bytecodes::_fast_zputfield, bc, Z_ARG5, true, byte_no);
2967   }
2968   __ z_bru(Done);
2969   BTB_END(is_Bool, bsize, &quot;putfield_or_static:is_Bool&quot;);
2970 
2971   // ctos
2972   BTB_BEGIN(is_Char, bsize, &quot;putfield_or_static:is_Char&quot;);
2973   __ pop(ctos);
2974   if (!is_static) {
2975     pop_and_check_object(obj);
2976   }
2977   __ z_sth(Z_tos, field);
2978   if (do_rewrite) {
2979     patch_bytecode(Bytecodes::_fast_cputfield, bc, Z_ARG5, true, byte_no);
2980   }
2981   __ z_bru(Done);
2982   BTB_END( is_Char, bsize, &quot;putfield_or_static:is_Char&quot;);
2983 
2984   // stos
2985   BTB_BEGIN(is_Short, bsize, &quot;putfield_or_static:is_Short&quot;);
2986   __ pop(stos);
2987   if (!is_static) {
2988     pop_and_check_object(obj);
2989   }
2990   __ z_sth(Z_tos, field);
2991   if (do_rewrite) {
2992     patch_bytecode(Bytecodes::_fast_sputfield, bc, Z_ARG5, true, byte_no);
2993   }
2994   __ z_bru(Done);
2995   BTB_END( is_Short, bsize, &quot;putfield_or_static:is_Short&quot;);
2996 
2997   // itos
2998   BTB_BEGIN(is_Int, bsize, &quot;putfield_or_static:is_Int&quot;);
2999   __ pop(itos);
3000   if (!is_static) {
3001     pop_and_check_object(obj);
3002   }
3003   __ reg2mem_opt(Z_tos, field, false);
3004   if (do_rewrite) {
3005     patch_bytecode(Bytecodes::_fast_iputfield, bc, Z_ARG5, true, byte_no);
3006   }
3007   __ z_bru(Done);
3008   BTB_END( is_Int, bsize, &quot;putfield_or_static:is_Int&quot;);
3009 
3010   // ltos
3011   BTB_BEGIN(is_Long, bsize, &quot;putfield_or_static:is_Long&quot;);
3012   __ pop(ltos);
3013   if (!is_static) {
3014     pop_and_check_object(obj);
3015   }
3016   __ reg2mem_opt(Z_tos, field);
3017   if (do_rewrite) {
3018     patch_bytecode(Bytecodes::_fast_lputfield, bc, Z_ARG5, true, byte_no);
3019   }
3020   __ z_bru(Done);
3021   BTB_END( is_Long, bsize, &quot;putfield_or_static:is_Long&quot;);
3022 
3023   // ftos
3024   BTB_BEGIN(is_Float, bsize, &quot;putfield_or_static:is_Float&quot;);
3025   __ pop(ftos);
3026   if (!is_static) {
3027     pop_and_check_object(obj);
3028   }
3029   __ freg2mem_opt(Z_ftos, field, false);
3030   if (do_rewrite) {
3031     patch_bytecode(Bytecodes::_fast_fputfield, bc, Z_ARG5, true, byte_no);
3032   }
3033   __ z_bru(Done);
3034   BTB_END( is_Float, bsize, &quot;putfield_or_static:is_Float&quot;);
3035 
3036   // dtos
3037   BTB_BEGIN(is_Double, bsize, &quot;putfield_or_static:is_Double&quot;);
3038   __ pop(dtos);
3039   if (!is_static) {
3040     pop_and_check_object(obj);
3041   }
3042   __ freg2mem_opt(Z_ftos, field);
3043   if (do_rewrite) {
3044     patch_bytecode(Bytecodes::_fast_dputfield, bc, Z_ARG5, true, byte_no);
3045   }
3046   __ z_bru(Done);
3047   BTB_END( is_Double, bsize, &quot;putfield_or_static:is_Double&quot;);
3048 
3049   // atos
3050   BTB_BEGIN(is_Object, bsize, &quot;putfield_or_static:is_Object&quot;);
3051   __ z_bru(atosHandler);
3052   BTB_END( is_Object, bsize, &quot;putfield_or_static:is_Object&quot;);
3053 
3054   // Bad state detection comes at no extra runtime cost.
3055   BTB_BEGIN(is_badState8, bsize, &quot;putfield_or_static:is_badState8&quot;);
3056   __ z_illtrap();
3057   __ z_bru(is_badState);
3058   BTB_END( is_badState8, bsize, &quot;putfield_or_static:is_badState8&quot;);
3059   BTB_BEGIN(is_badState9, bsize, &quot;putfield_or_static:is_badState9&quot;);
3060   __ z_illtrap();
3061   __ z_bru(is_badState);
3062   BTB_END( is_badState9, bsize, &quot;putfield_or_static:is_badState9&quot;);
3063   BTB_BEGIN(is_badStateA, bsize, &quot;putfield_or_static:is_badStateA&quot;);
3064   __ z_illtrap();
3065   __ z_bru(is_badState);
3066   BTB_END( is_badStateA, bsize, &quot;putfield_or_static:is_badStateA&quot;);
3067   BTB_BEGIN(is_badStateB, bsize, &quot;putfield_or_static:is_badStateB&quot;);
3068   __ z_illtrap();
3069   __ z_bru(is_badState);
3070   BTB_END( is_badStateB, bsize, &quot;putfield_or_static:is_badStateB&quot;);
3071   BTB_BEGIN(is_badStateC, bsize, &quot;putfield_or_static:is_badStateC&quot;);
3072   __ z_illtrap();
3073   __ z_bru(is_badState);
3074   BTB_END( is_badStateC, bsize, &quot;putfield_or_static:is_badStateC&quot;);
3075   BTB_BEGIN(is_badStateD, bsize, &quot;putfield_or_static:is_badStateD&quot;);
3076   __ z_illtrap();
3077   __ z_bru(is_badState);
3078   BTB_END( is_badStateD, bsize, &quot;putfield_or_static:is_badStateD&quot;);
3079   BTB_BEGIN(is_badStateE, bsize, &quot;putfield_or_static:is_badStateE&quot;);
3080   __ z_illtrap();
3081   __ z_bru(is_badState);
3082   BTB_END( is_badStateE, bsize, &quot;putfield_or_static:is_badStateE&quot;);
3083   BTB_BEGIN(is_badStateF, bsize, &quot;putfield_or_static:is_badStateF&quot;);
3084   __ z_illtrap();
3085   __ z_bru(is_badState);
3086   BTB_END( is_badStateF, bsize, &quot;putfield_or_static:is_badStateF&quot;);
3087 
3088   __ align_address(64);
3089   BIND(is_badState);  // Do this outside branch table. Needs a lot of space.
3090   {
3091     unsigned int b_off = __ offset();
3092     if (is_static) __ stop_static(&quot;Bad state in putstatic&quot;);
3093     else            __ stop_static(&quot;Bad state in putfield&quot;);
3094     unsigned int e_off = __ offset();
3095   }
3096 
3097   __ align_address(64);
3098   BIND(atosHandler);  // Oops are really complicated to handle.
3099                       // There is a lot of code generated.
3100                       // Therefore: generate the handler outside of branch table.
3101                       // There is no performance penalty. The additional branch
3102                       // to here is compensated for by the fallthru to &quot;Done&quot;.
3103   {
3104     unsigned int b_off = __ offset();
3105     __ pop(atos);
3106     if (!is_static) {
3107       pop_and_check_object(obj);
3108     }
3109     // Store into the field
3110     do_oop_store(_masm, Address(obj, off), Z_tos,
3111                  oopStore_tmp1, oopStore_tmp2, oopStore_tmp3, IN_HEAP);
3112     if (do_rewrite) {
3113       patch_bytecode(Bytecodes::_fast_aputfield, bc, Z_ARG5, true, byte_no);
3114     }
3115     // __ z_bru(Done); // fallthru
3116     unsigned int e_off = __ offset();
3117   }
3118 
3119   BIND(Done);
3120 
3121   // Check for volatile store.
3122   Label notVolatile;
3123 
3124   __ testbit(Z_ARG4, ConstantPoolCacheEntry::is_volatile_shift);
3125   __ z_brz(notVolatile);
3126   __ z_fence();
3127 
3128   BIND(notVolatile);
3129 }
3130 
3131 void TemplateTable::putfield(int byte_no) {
3132   BLOCK_COMMENT(&quot;putfield  {&quot;);
3133   putfield_or_static(byte_no, false);
3134   BLOCK_COMMENT(&quot;} putfield&quot;);
3135 }
3136 
3137 void TemplateTable::nofast_putfield(int byte_no) {
3138   putfield_or_static(byte_no, false, may_not_rewrite);
3139 }
3140 
3141 void TemplateTable::putstatic(int byte_no) {
3142   BLOCK_COMMENT(&quot;putstatic {&quot;);
3143   putfield_or_static(byte_no, true);
3144   BLOCK_COMMENT(&quot;} putstatic&quot;);
3145 }
3146 
3147 // Push the tos value back to the stack.
3148 // gc will find oops there and update.
3149 void TemplateTable::jvmti_post_fast_field_mod() {
3150 
3151   if (!JvmtiExport::can_post_field_modification()) {
3152     return;
3153   }
3154 
3155   // Check to see if a field modification watch has been set before
3156   // we take the time to call into the VM.
3157   Label   exit;
3158 
3159   BLOCK_COMMENT(&quot;jvmti_post_fast_field_mod {&quot;);
3160 
3161   __ load_absolute_address(Z_R1_scratch,
3162                            (address) JvmtiExport::get_field_modification_count_addr());
3163   __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));
3164   __ z_brz(exit);
3165 
3166   Register obj = Z_tmp_1;
3167 
3168   __ pop_ptr(obj);                  // Copy the object pointer from tos.
3169   __ verify_oop(obj);
3170   __ push_ptr(obj);                 // Put the object pointer back on tos.
3171 
3172   // Save tos values before call_VM() clobbers them. Since we have
3173   // to do it for every data type, we use the saved values as the
3174   // jvalue object.
3175   switch (bytecode()) {          // Load values into the jvalue object.
3176     case Bytecodes::_fast_aputfield:
3177       __ push_ptr(Z_tos);
3178       break;
3179     case Bytecodes::_fast_bputfield:
3180     case Bytecodes::_fast_zputfield:
3181     case Bytecodes::_fast_sputfield:
3182     case Bytecodes::_fast_cputfield:
3183     case Bytecodes::_fast_iputfield:
3184       __ push_i(Z_tos);
3185       break;
3186     case Bytecodes::_fast_dputfield:
3187       __ push_d();
3188       break;
3189     case Bytecodes::_fast_fputfield:
3190       __ push_f();
3191       break;
3192     case Bytecodes::_fast_lputfield:
3193       __ push_l(Z_tos);
3194       break;
3195 
3196     default:
3197       ShouldNotReachHere();
3198   }
3199 
3200   // jvalue on the stack
3201   __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));
3202   // Access constant pool cache entry.
3203   __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tos, 1);
3204   __ verify_oop(obj);
3205 
3206   // obj   : object pointer copied above
3207   // Z_ARG3: cache entry pointer
3208   // Z_ARG4: jvalue object on the stack
3209   __ call_VM(noreg,
3210              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification),
3211              obj, Z_ARG3, Z_ARG4);
3212 
3213   switch (bytecode()) {             // Restore tos values.
3214     case Bytecodes::_fast_aputfield:
3215       __ pop_ptr(Z_tos);
3216       break;
3217     case Bytecodes::_fast_bputfield:
3218     case Bytecodes::_fast_zputfield:
3219     case Bytecodes::_fast_sputfield:
3220     case Bytecodes::_fast_cputfield:
3221     case Bytecodes::_fast_iputfield:
3222       __ pop_i(Z_tos);
3223       break;
3224     case Bytecodes::_fast_dputfield:
3225       __ pop_d(Z_ftos);
3226       break;
3227     case Bytecodes::_fast_fputfield:
3228       __ pop_f(Z_ftos);
3229       break;
3230     case Bytecodes::_fast_lputfield:
3231       __ pop_l(Z_tos);
3232       break;
3233     default:
3234       break;
3235   }
3236 
3237   __ bind(exit);
3238   BLOCK_COMMENT(&quot;} jvmti_post_fast_field_mod&quot;);
3239 }
3240 
3241 void TemplateTable::fast_storefield(TosState state) {
3242   transition(state, vtos);
3243 
3244   ByteSize base = ConstantPoolCache::base_offset();
3245   jvmti_post_fast_field_mod();
3246 
3247   // Access constant pool cache.
3248   Register cache = Z_tmp_1;
3249   Register index = Z_tmp_2;
3250   Register flags = Z_ARG5;
3251 
3252   // Index comes in bytes, don&#39;t shift afterwards!
3253   __ get_cache_and_index_at_bcp(cache, index, 1);
3254 
3255   // Test for volatile.
3256   assert(!flags-&gt;is_volatile(), &quot;do_oop_store could perform leaf RT call&quot;);
3257   __ z_lg(flags, Address(cache, index, base + ConstantPoolCacheEntry::flags_offset()));
3258 
3259   // Replace index with field offset from cache entry.
3260   Register field_offset = index;
3261   __ z_lg(field_offset, Address(cache, index, base + ConstantPoolCacheEntry::f2_offset()));
3262 
3263   // Get object from stack.
3264   Register   obj = cache;
3265 
3266   pop_and_check_object(obj);
3267 
3268   // field address
3269   const Address   field(obj, field_offset);
3270 
3271   // access field
3272   switch (bytecode()) {
3273     case Bytecodes::_fast_aputfield:
3274       do_oop_store(_masm, Address(obj, field_offset), Z_tos,
3275                    Z_ARG2, Z_ARG3, Z_ARG4, IN_HEAP);
3276       break;
3277     case Bytecodes::_fast_lputfield:
3278       __ reg2mem_opt(Z_tos, field);
3279       break;
3280     case Bytecodes::_fast_iputfield:
3281       __ reg2mem_opt(Z_tos, field, false);
3282       break;
3283     case Bytecodes::_fast_zputfield:
3284       __ z_nilf(Z_tos, 0x1);
3285       // fall through to bputfield
3286     case Bytecodes::_fast_bputfield:
3287       __ z_stc(Z_tos, field);
3288       break;
3289     case Bytecodes::_fast_sputfield:
3290       // fall through
3291     case Bytecodes::_fast_cputfield:
3292       __ z_sth(Z_tos, field);
3293       break;
3294     case Bytecodes::_fast_fputfield:
3295       __ freg2mem_opt(Z_ftos, field, false);
3296       break;
3297     case Bytecodes::_fast_dputfield:
3298       __ freg2mem_opt(Z_ftos, field);
3299       break;
3300     default:
3301       ShouldNotReachHere();
3302   }
3303 
3304   //  Check for volatile store.
3305   Label notVolatile;
3306 
3307   __ testbit(flags, ConstantPoolCacheEntry::is_volatile_shift);
3308   __ z_brz(notVolatile);
3309   __ z_fence();
3310 
3311   __ bind(notVolatile);
3312 }
3313 
3314 void TemplateTable::fast_accessfield(TosState state) {
3315   transition(atos, state);
3316 
3317   Register obj = Z_tos;
3318 
3319   // Do the JVMTI work here to avoid disturbing the register state below
3320   if (JvmtiExport::can_post_field_access()) {
3321     // Check to see if a field access watch has been set before we
3322     // take the time to call into the VM.
3323     Label cont;
3324 
3325     __ load_absolute_address(Z_R1_scratch,
3326                              (address)JvmtiExport::get_field_access_count_addr());
3327     __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));
3328     __ z_brz(cont);
3329 
3330     // Access constant pool cache entry.
3331 
3332     __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tmp_1, 1);
3333     __ verify_oop(obj);
3334     __ push_ptr(obj);  // Save object pointer before call_VM() clobbers it.
3335     __ z_lgr(Z_ARG2, obj);
3336 
3337     // Z_ARG2: object pointer copied above
3338     // Z_ARG3: cache entry pointer
3339     __ call_VM(noreg,
3340                CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
3341                Z_ARG2, Z_ARG3);
3342     __ pop_ptr(obj); // Restore object pointer.
3343 
3344     __ bind(cont);
3345   }
3346 
3347   // Access constant pool cache.
3348   Register   cache = Z_tmp_1;
3349   Register   index = Z_tmp_2;
3350 
3351   // Index comes in bytes, don&#39;t shift afterwards!
3352   __ get_cache_and_index_at_bcp(cache, index, 1);
3353   // Replace index with field offset from cache entry.
3354   __ mem2reg_opt(index,
3355                  Address(cache, index,
3356                          ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));
3357 
3358   __ verify_oop(obj);
3359   __ null_check(obj);
3360 
3361   Address field(obj, index);
3362 
3363   // access field
3364   switch (bytecode()) {
3365     case Bytecodes::_fast_agetfield:
3366       do_oop_load(_masm, field, Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);
3367       __ verify_oop(Z_tos);
3368       return;
3369     case Bytecodes::_fast_lgetfield:
3370       __ mem2reg_opt(Z_tos, field);
3371       return;
3372     case Bytecodes::_fast_igetfield:
3373       __ mem2reg_opt(Z_tos, field, false);
3374       return;
3375     case Bytecodes::_fast_bgetfield:
3376       __ z_lb(Z_tos, field);
3377       return;
3378     case Bytecodes::_fast_sgetfield:
3379       __ z_lh(Z_tos, field);
3380       return;
3381     case Bytecodes::_fast_cgetfield:
3382       __ z_llgh(Z_tos, field);   // Load into 64 bits, works on all CPUs.
3383       return;
3384     case Bytecodes::_fast_fgetfield:
3385       __ mem2freg_opt(Z_ftos, field, false);
3386       return;
3387     case Bytecodes::_fast_dgetfield:
3388       __ mem2freg_opt(Z_ftos, field);
3389       return;
3390     default:
3391       ShouldNotReachHere();
3392   }
3393 }
3394 
3395 void TemplateTable::fast_xaccess(TosState state) {
3396   transition(vtos, state);
3397 
3398   Register receiver = Z_tos;
3399   // Get receiver.
3400   __ mem2reg_opt(Z_tos, aaddress(0));
3401 
3402   // Access constant pool cache.
3403   Register cache = Z_tmp_1;
3404   Register index = Z_tmp_2;
3405 
3406   // Index comes in bytes, don&#39;t shift afterwards!
3407   __ get_cache_and_index_at_bcp(cache, index, 2);
3408   // Replace index with field offset from cache entry.
3409   __ mem2reg_opt(index,
3410                  Address(cache, index,
3411                          ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));
3412 
3413   // Make sure exception is reported in correct bcp range (getfield is
3414   // next instruction).
3415   __ add2reg(Z_bcp, 1);
3416   __ null_check(receiver);
3417   switch (state) {
3418     case itos:
3419       __ mem2reg_opt(Z_tos, Address(receiver, index), false);
3420       break;
3421     case atos:
3422       do_oop_load(_masm, Address(receiver, index), Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);
3423       __ verify_oop(Z_tos);
3424       break;
3425     case ftos:
3426       __ mem2freg_opt(Z_ftos, Address(receiver, index));
3427       break;
3428     default:
3429       ShouldNotReachHere();
3430   }
3431 
3432   // Reset bcp to original position.
3433   __ add2reg(Z_bcp, -1);
3434 }
3435 
3436 //-----------------------------------------------------------------------------
3437 // Calls
3438 
3439 void TemplateTable::prepare_invoke(int byte_no,
3440                                    Register method,  // linked method (or i-klass)
3441                                    Register index,   // itable index, MethodType, etc.
3442                                    Register recv,    // If caller wants to see it.
3443                                    Register flags) { // If caller wants to test it.
3444   // Determine flags.
3445   const Bytecodes::Code code = bytecode();
3446   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3447   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3448   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3449   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3450   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3451   const bool load_receiver       = (recv != noreg);
3452   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3453 
3454   // Setup registers &amp; access constant pool cache.
3455   if (recv  == noreg) { recv  = Z_ARG1; }
3456   if (flags == noreg) { flags = Z_ARG2; }
3457   assert_different_registers(method, Z_R14, index, recv, flags);
3458 
3459   BLOCK_COMMENT(&quot;prepare_invoke {&quot;);
3460 
3461   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3462 
3463   // Maybe push appendix to arguments.
3464   if (is_invokedynamic || is_invokehandle) {
3465     Label L_no_push;
3466     Register resolved_reference = Z_R1_scratch;
3467     __ testbit(flags, ConstantPoolCacheEntry::has_appendix_shift);
3468     __ z_bfalse(L_no_push);
3469     // Push the appendix as a trailing parameter.
3470     // This must be done before we get the receiver,
3471     // since the parameter_size includes it.
3472     __ load_resolved_reference_at_index(resolved_reference, index);
3473     __ verify_oop(resolved_reference);
3474     __ push_ptr(resolved_reference);  // Push appendix (MethodType, CallSite, etc.).
3475     __ bind(L_no_push);
3476   }
3477 
3478   // Load receiver if needed (after appendix is pushed so parameter size is correct).
3479   if (load_receiver) {
3480     assert(!is_invokedynamic, &quot;&quot;);
3481     // recv := int2long(flags &amp; ConstantPoolCacheEntry::parameter_size_mask) &lt;&lt; 3
3482     // Flags is zero-extended int2long when loaded during load_invoke_cp_cache_entry().
3483     // Only the least significant byte (psize) of flags is used.
3484     {
3485       const unsigned int logSES = Interpreter::logStackElementSize;
3486       const int bit_shift = logSES;
3487       const int r_bitpos  = 63 - bit_shift;
3488       const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::parameter_size_bits + 1;
3489       const int n_rotate  = bit_shift;
3490       assert(ConstantPoolCacheEntry::parameter_size_mask == 255, &quot;adapt bitpositions&quot;);
3491       __ rotate_then_insert(recv, flags, l_bitpos, r_bitpos, n_rotate, true);
3492     }
3493     // Recv now contains #arguments * StackElementSize.
3494 
3495     Address recv_addr(Z_esp, recv);
3496     __ z_lg(recv, recv_addr);
3497     __ verify_oop(recv);
3498   }
3499 
3500   // Compute return type.
3501   // ret_type is used by callers (invokespecial, invokestatic) at least.
3502   Register ret_type = Z_R1_scratch;
3503   assert_different_registers(ret_type, method);
3504 
3505   const address table_addr = (address)Interpreter::invoke_return_entry_table_for(code);
3506   __ load_absolute_address(Z_R14, table_addr);
3507 
3508   {
3509     const int bit_shift = LogBytesPerWord;           // Size of each table entry.
3510     const int r_bitpos  = 63 - bit_shift;
3511     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
3512     const int n_rotate  = bit_shift-ConstantPoolCacheEntry::tos_state_shift;
3513     __ rotate_then_insert(ret_type, flags, l_bitpos, r_bitpos, n_rotate, true);
3514     // Make sure we don&#39;t need to mask flags for tos_state after the above shift.
3515     ConstantPoolCacheEntry::verify_tos_state_shift();
3516   }
3517 
3518     __ z_lg(Z_R14, Address(Z_R14, ret_type)); // Load return address.
3519   BLOCK_COMMENT(&quot;} prepare_invoke&quot;);
3520 }
3521 
3522 
3523 void TemplateTable::invokevirtual_helper(Register index,
3524                                          Register recv,
3525                                          Register flags) {
3526   // Uses temporary registers Z_tmp_2, Z_ARG4.
3527   assert_different_registers(index, recv, Z_tmp_2, Z_ARG4);
3528 
3529   // Test for an invoke of a final method.
3530   Label notFinal;
3531 
3532   BLOCK_COMMENT(&quot;invokevirtual_helper {&quot;);
3533 
3534   __ testbit(flags, ConstantPoolCacheEntry::is_vfinal_shift);
3535   __ z_brz(notFinal);
3536 
3537   const Register method = index;  // Method must be Z_ARG3.
3538   assert(method == Z_ARG3, &quot;method must be second argument for interpreter calling convention&quot;);
3539 
3540   // Do the call - the index is actually the method to call.
3541   // That is, f2 is a vtable index if !is_vfinal, else f2 is a method.
3542 
3543   // It&#39;s final, need a null check here!
3544   __ null_check(recv);
3545 
3546   // Profile this call.
3547   __ profile_final_call(Z_tmp_2);
3548   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true); // Argument type profiling.
3549   __ jump_from_interpreted(method, Z_tmp_2);
3550 
3551   __ bind(notFinal);
3552 
3553   // Get receiver klass.
3554   __ null_check(recv, Z_R0_scratch, oopDesc::klass_offset_in_bytes());
3555   __ load_klass(Z_tmp_2, recv);
3556 
3557   // Profile this call.
3558   __ profile_virtual_call(Z_tmp_2, Z_ARG4, Z_ARG5);
3559 
3560   // Get target method &amp; entry point.
3561   __ z_sllg(index, index, exact_log2(vtableEntry::size_in_bytes()));
3562   __ mem2reg_opt(method,
3563                  Address(Z_tmp_2, index,
3564                          Klass::vtable_start_offset() + in_ByteSize(vtableEntry::method_offset_in_bytes())));
3565   __ profile_arguments_type(Z_ARG4, method, Z_ARG5, true);
3566   __ jump_from_interpreted(method, Z_ARG4);
3567   BLOCK_COMMENT(&quot;} invokevirtual_helper&quot;);
3568 }
3569 
3570 void TemplateTable::invokevirtual(int byte_no) {
3571   transition(vtos, vtos);
3572 
3573   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3574   prepare_invoke(byte_no,
3575                  Z_ARG3,  // method or vtable index
3576                  noreg,   // unused itable index
3577                  Z_ARG1,  // recv
3578                  Z_ARG2); // flags
3579 
3580   // Z_ARG3 : index
3581   // Z_ARG1 : receiver
3582   // Z_ARG2 : flags
3583   invokevirtual_helper(Z_ARG3, Z_ARG1, Z_ARG2);
3584 }
3585 
3586 void TemplateTable::invokespecial(int byte_no) {
3587   transition(vtos, vtos);
3588 
3589   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3590   Register Rmethod = Z_tmp_2;
3591   prepare_invoke(byte_no, Rmethod, noreg, // Get f1 method.
3592                  Z_ARG3);   // Get receiver also for null check.
3593   __ verify_oop(Z_ARG3);
3594   __ null_check(Z_ARG3);
3595   // Do the call.
3596   __ profile_call(Z_ARG2);
3597   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3598   __ jump_from_interpreted(Rmethod, Z_R1_scratch);
3599 }
3600 
3601 void TemplateTable::invokestatic(int byte_no) {
3602   transition(vtos, vtos);
3603 
3604   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3605   Register Rmethod = Z_tmp_2;
3606   prepare_invoke(byte_no, Rmethod);   // Get f1 method.
3607   // Do the call.
3608   __ profile_call(Z_ARG2);
3609   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3610   __ jump_from_interpreted(Rmethod, Z_R1_scratch);
3611 }
3612 
3613 // Outdated feature, and we don&#39;t support it.
3614 void TemplateTable::fast_invokevfinal(int byte_no) {
3615   transition(vtos, vtos);
3616   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3617   __ stop(&quot;fast_invokevfinal not used on linuxs390x&quot;);
3618 }
3619 
3620 void TemplateTable::invokeinterface(int byte_no) {
3621   transition(vtos, vtos);
3622 
3623   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3624   Register klass     = Z_ARG2,
3625            method    = Z_ARG3,
3626            interface = Z_ARG4,
3627            flags     = Z_ARG5,
3628            receiver  = Z_tmp_1;
3629 
3630   BLOCK_COMMENT(&quot;invokeinterface {&quot;);
3631 
3632   prepare_invoke(byte_no, interface, method,  // Get f1 klassOop, f2 Method*.
3633                  receiver, flags);
3634 
3635   // Z_R14 (== Z_bytecode) : return entry
3636 
3637   // First check for Object case, then private interface method,
3638   // then regular interface method.
3639 
3640   // Special case of invokeinterface called for virtual method of
3641   // java.lang.Object. See cpCache.cpp for details.
3642   NearLabel notObjectMethod, no_such_method;
3643   __ testbit(flags, ConstantPoolCacheEntry::is_forced_virtual_shift);
3644   __ z_brz(notObjectMethod);
3645   invokevirtual_helper(method, receiver, flags);
3646   __ bind(notObjectMethod);
3647 
3648   // Check for private method invocation - indicated by vfinal
3649   NearLabel notVFinal;
3650   __ testbit(flags, ConstantPoolCacheEntry::is_vfinal_shift);
3651   __ z_brz(notVFinal);
3652 
3653   // Get receiver klass into klass - also a null check.
3654   __ load_klass(klass, receiver);
3655 
3656   NearLabel subtype, no_such_interface;
3657 
3658   __ check_klass_subtype(klass, interface, Z_tmp_2, flags/*scratch*/, subtype);
3659   // If we get here the typecheck failed
3660   __ z_bru(no_such_interface);
3661   __ bind(subtype);
3662 
3663   // do the call
3664   __ profile_final_call(Z_tmp_2);
3665   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true);
3666   __ jump_from_interpreted(method, Z_tmp_2);
3667 
3668   __ bind(notVFinal);
3669 
3670   // Get receiver klass into klass - also a null check.
3671   __ load_klass(klass, receiver);
3672 
3673   __ lookup_interface_method(klass, interface, noreg, noreg, /*temp*/Z_ARG1,
3674                              no_such_interface, /*return_method=*/false);
3675 
3676   // Profile this call.
3677   __ profile_virtual_call(klass, Z_ARG1/*mdp*/, flags/*scratch*/);
3678 
3679   // Find entry point to call.
3680 
3681   // Get declaring interface class from method
3682   __ load_method_holder(interface, method);
3683 
3684   // Get itable index from method
3685   Register index   = receiver,
3686            method2 = flags;
3687   __ z_lgf(index, Address(method, Method::itable_index_offset()));
3688   __ z_aghi(index, -Method::itable_index_max);
3689   __ z_lcgr(index, index);
3690 
3691   __ lookup_interface_method(klass, interface, index, method2, Z_tmp_2,
3692                              no_such_interface);
3693 
3694   // Check for abstract method error.
3695   // Note: This should be done more efficiently via a throw_abstract_method_error
3696   // interpreter entry point and a conditional jump to it in case of a null
3697   // method.
3698   __ compareU64_and_branch(method2, (intptr_t) 0,
3699                            Assembler::bcondZero, no_such_method);
3700 
3701   __ profile_arguments_type(Z_tmp_1, method2, Z_tmp_2, true);
3702 
3703   // Do the call.
3704   __ jump_from_interpreted(method2, Z_tmp_2);
3705   __ should_not_reach_here();
3706 
3707   // exception handling code follows...
3708   // Note: Must restore interpreter registers to canonical
3709   // state for exception handling to work correctly!
3710 
3711   __ bind(no_such_method);
3712 
3713   // Throw exception.
3714   // Pass arguments for generating a verbose error message.
3715   __ z_lgr(Z_tmp_1, method); // Prevent register clash.
3716   __ call_VM(noreg,
3717              CAST_FROM_FN_PTR(address,
3718                               InterpreterRuntime::throw_AbstractMethodErrorVerbose),
3719                               klass, Z_tmp_1);
3720   // The call_VM checks for exception, so we should never return here.
3721   __ should_not_reach_here();
3722 
3723   __ bind(no_such_interface);
3724 
3725   // Throw exception.
3726   // Pass arguments for generating a verbose error message.
3727   __ call_VM(noreg,
3728              CAST_FROM_FN_PTR(address,
3729                               InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose),
3730                               klass, interface);
3731   // The call_VM checks for exception, so we should never return here.
3732   __ should_not_reach_here();
3733 
3734   BLOCK_COMMENT(&quot;} invokeinterface&quot;);
3735   return;
3736 }
3737 
3738 void TemplateTable::invokehandle(int byte_no) {
3739   transition(vtos, vtos);
3740 
3741   const Register method = Z_tmp_2;
3742   const Register recv   = Z_ARG5;
3743   const Register mtype  = Z_tmp_1;
3744   prepare_invoke(byte_no,
3745                  method, mtype,   // Get f2 method, f1 MethodType.
3746                  recv);
3747   __ verify_method_ptr(method);
3748   __ verify_oop(recv);
3749   __ null_check(recv);
3750 
3751   // Note: Mtype is already pushed (if necessary) by prepare_invoke.
3752 
3753   // FIXME: profile the LambdaForm also.
3754   __ profile_final_call(Z_ARG2);
3755   __ profile_arguments_type(Z_ARG3, method, Z_ARG5, true);
3756 
3757   __ jump_from_interpreted(method, Z_ARG3);
3758 }
3759 
3760 void TemplateTable::invokedynamic(int byte_no) {
3761   transition(vtos, vtos);
3762 
3763   const Register Rmethod   = Z_tmp_2;
3764   const Register Rcallsite = Z_tmp_1;
3765 
3766   prepare_invoke(byte_no, Rmethod, Rcallsite);
3767 
3768   // Rmethod: CallSite object (from f1)
3769   // Rcallsite: MH.linkToCallSite method (from f2)
3770 
3771   // Note: Callsite is already pushed by prepare_invoke.
3772 
3773   // TODO: should make a type profile for any invokedynamic that takes a ref argument.
3774   // Profile this call.
3775   __ profile_call(Z_ARG2);
3776   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3777   __ jump_from_interpreted(Rmethod, Z_ARG2);
3778 }
3779 
3780 //-----------------------------------------------------------------------------
3781 // Allocation
3782 
3783 // Original comment on &quot;allow_shared_alloc&quot;:
3784 // Always go the slow path.
3785 //  + Eliminated optimization within the template-based interpreter:
3786 //    If an allocation is done within the interpreter without using
3787 //    tlabs, the interpreter tries to do the allocation directly
3788 //    on the heap.
3789 //  + That means the profiling hooks are not considered and allocations
3790 //    get lost for the profiling framework.
3791 //  + However, we do not think that this optimization is really needed,
3792 //    so we always go now the slow path through the VM in this case --
3793 //    spec jbb2005 shows no measurable performance degradation.
3794 void TemplateTable::_new() {
3795   transition(vtos, atos);
3796   address prev_instr_address = NULL;
3797   Register tags  = Z_tmp_1;
3798   Register RallocatedObject   = Z_tos;
3799   Register cpool = Z_ARG2;
3800   Register tmp = Z_ARG3; // RobjectFields==tmp and Rsize==offset must be a register pair.
3801   Register offset = Z_ARG4;
3802   Label slow_case;
3803   Label done;
3804   Label initialize_header;
3805 
3806   BLOCK_COMMENT(&quot;TemplateTable::_new {&quot;);
3807   __ get_2_byte_integer_at_bcp(offset/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3808   __ get_cpool_and_tags(cpool, tags);
3809   // Make sure the class we&#39;re about to instantiate has been resolved.
3810   // This is done before loading InstanceKlass to be consistent with the order
3811   // how Constant Pool is updated (see ConstantPool::klass_at_put).
3812   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3813   __ load_address(tmp, Address(tags, offset, tags_offset));
3814   __ z_cli(0, tmp, JVM_CONSTANT_Class);
3815   __ z_brne(slow_case);
3816 
3817   __ z_sllg(offset, offset, LogBytesPerWord); // Convert to to offset.
3818   // Get InstanceKlass.
3819   Register iklass = cpool;
3820   __ load_resolved_klass_at_offset(cpool, offset, iklass);
3821 
3822   // Make sure klass is initialized &amp; doesn&#39;t have finalizer.
3823   // Make sure klass is fully initialized.
3824   const int state_offset = in_bytes(InstanceKlass::init_state_offset());
3825   if (Immediate::is_uimm12(state_offset)) {
3826     __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);
3827   } else {
3828     __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);
3829   }
3830   __ z_brne(slow_case);
3831 
3832   // Get instance_size in InstanceKlass (scaled to a count of bytes).
3833   Register Rsize = offset;
3834   const int mask = 1 &lt;&lt; Klass::_lh_instance_slow_path_bit;
3835   __ z_llgf(Rsize, Address(iklass, Klass::layout_helper_offset()));
3836   __ z_tmll(Rsize, mask);
3837   __ z_btrue(slow_case);
3838 
3839   // Allocate the instance
3840   // 1) Try to allocate in the TLAB.
3841   // 2) If the above fails (or is not applicable), go to a slow case
3842   // (creates a new TLAB, etc.).
3843   // Note: compared to other architectures, s390&#39;s implementation always goes
3844   // to the slow path if TLAB is used and fails.
3845   if (UseTLAB) {
3846     Register RoldTopValue = RallocatedObject;
3847     Register RnewTopValue = tmp;
3848     __ z_lg(RoldTopValue, Address(Z_thread, JavaThread::tlab_top_offset()));
3849     __ load_address(RnewTopValue, Address(RoldTopValue, Rsize));
3850     __ z_cg(RnewTopValue, Address(Z_thread, JavaThread::tlab_end_offset()));
3851     __ z_brh(slow_case);
3852     __ z_stg(RnewTopValue, Address(Z_thread, JavaThread::tlab_top_offset()));
3853 
3854     Register RobjectFields = tmp;
3855     Register Rzero = Z_R1_scratch;
3856     __ clear_reg(Rzero, true /*whole reg*/, false); // Load 0L into Rzero. Don&#39;t set CC.
3857 
3858     if (!ZeroTLAB) {
3859       // The object is initialized before the header. If the object size is
3860       // zero, go directly to the header initialization.
3861       __ z_aghi(Rsize, (int)-sizeof(oopDesc)); // Subtract header size, set CC.
3862       __ z_bre(initialize_header);             // Jump if size of fields is zero.
3863 
3864       // Initialize object fields.
3865       // See documentation for MVCLE instruction!!!
3866       assert(RobjectFields-&gt;encoding() % 2 == 0, &quot;RobjectFields must be an even register&quot;);
3867       assert(Rsize-&gt;encoding() == (RobjectFields-&gt;encoding()+1),
3868              &quot;RobjectFields and Rsize must be a register pair&quot;);
3869       assert(Rzero-&gt;encoding() % 2 == 1, &quot;Rzero must be an odd register&quot;);
3870 
3871       // Set Rzero to 0 and use it as src length, then mvcle will copy nothing
3872       // and fill the object with the padding value 0.
3873       __ add2reg(RobjectFields, sizeof(oopDesc), RallocatedObject);
3874       __ move_long_ext(RobjectFields, as_Register(Rzero-&gt;encoding() - 1), 0);
3875     }
3876 
3877     // Initialize object header only.
3878     __ bind(initialize_header);
3879     if (UseBiasedLocking) {
3880       Register prototype = RobjectFields;
3881       __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));
3882       __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));
3883     } else {
3884       __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),
3885                      (long)markWord::prototype().value());
3886     }
3887 
3888     __ store_klass_gap(Rzero, RallocatedObject);  // Zero klass gap for compressed oops.
3889     __ store_klass(iklass, RallocatedObject);     // Store klass last.
3890 
3891     {
3892       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false, Z_ARG5 /*scratch*/);
3893       // Trigger dtrace event for fastpath.
3894       __ push(atos); // Save the return value.
3895       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), RallocatedObject);
3896       __ pop(atos); // Restore the return value.
3897     }
3898     __ z_bru(done);
3899   }
3900 
3901   // slow case
3902   __ bind(slow_case);
3903   __ get_constant_pool(Z_ARG2);
3904   __ get_2_byte_integer_at_bcp(Z_ARG3/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3905   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), Z_ARG2, Z_ARG3);
3906   __ verify_oop(Z_tos);
3907 
3908   // continue
3909   __ bind(done);
3910 
3911   BLOCK_COMMENT(&quot;} TemplateTable::_new&quot;);
3912 }
3913 
3914 void TemplateTable::newarray() {
3915   transition(itos, atos);
3916 
3917   // Call runtime.
3918   __ z_llgc(Z_ARG2, at_bcp(1));   // type
3919   __ z_lgfr(Z_ARG3, Z_tos);       // size
3920   call_VM(Z_RET,
3921           CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3922           Z_ARG2, Z_ARG3);
3923 }
3924 
3925 void TemplateTable::anewarray() {
3926   transition(itos, atos);
3927   __ get_2_byte_integer_at_bcp(Z_ARG3, 1, InterpreterMacroAssembler::Unsigned);
3928   __ get_constant_pool(Z_ARG2);
3929   __ z_lgfr(Z_ARG4, Z_tos);
3930   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3931           Z_ARG2, Z_ARG3, Z_ARG4);
3932 }
3933 
3934 void TemplateTable::arraylength() {
3935   transition(atos, itos);
3936 
3937   int offset = arrayOopDesc::length_offset_in_bytes();
3938 
3939   __ null_check(Z_tos, Z_R0_scratch, offset);
3940   __ mem2reg_opt(Z_tos, Address(Z_tos, offset), false);
3941 }
3942 
3943 void TemplateTable::checkcast() {
3944   transition(atos, atos);
3945 
3946   NearLabel done, is_null, ok_is_subtype, quicked, resolved;
3947 
3948   BLOCK_COMMENT(&quot;checkcast {&quot;);
3949   // If object is NULL, we are almost done.
3950   __ compareU64_and_branch(Z_tos, (intptr_t) 0, Assembler::bcondZero, is_null);
3951 
3952   // Get cpool &amp; tags index.
3953   Register cpool = Z_tmp_1;
3954   Register tags = Z_tmp_2;
3955   Register index = Z_ARG5;
3956 
3957   __ get_cpool_and_tags(cpool, tags);
3958   __ get_2_byte_integer_at_bcp(index, 1, InterpreterMacroAssembler::Unsigned);
3959   // See if bytecode has already been quicked.
3960   // Note: For CLI, we would have to add the index to the tags pointer first,
3961   // thus load and compare in a &quot;classic&quot; manner.
3962   __ z_llgc(Z_R0_scratch,
3963             Address(tags, index, Array&lt;u1&gt;::base_offset_in_bytes()));
3964   __ compareU64_and_branch(Z_R0_scratch, JVM_CONSTANT_Class,
3965                            Assembler::bcondEqual, quicked);
3966 
3967   __ push(atos); // Save receiver for result, and for GC.
3968   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3969   __ get_vm_result_2(Z_tos);
3970 
3971   Register   receiver = Z_ARG4;
3972   Register   klass = Z_tos;
3973   Register   subklass = Z_ARG5;
3974 
3975   __ pop_ptr(receiver); // restore receiver
3976   __ z_bru(resolved);
3977 
3978   // Get superklass in klass and subklass in subklass.
3979   __ bind(quicked);
3980 
3981   __ z_lgr(Z_ARG4, Z_tos);  // Save receiver.
3982   __ z_sllg(index, index, LogBytesPerWord);  // index2bytes for addressing
3983   __ load_resolved_klass_at_offset(cpool, index, klass);
3984 
3985   __ bind(resolved);
3986 
3987   __ load_klass(subklass, receiver);
3988 
3989   // Generate subtype check. Object in receiver.
3990   // Superklass in klass. Subklass in subklass.
3991   __ gen_subtype_check(subklass, klass, Z_ARG3, Z_tmp_1, ok_is_subtype);
3992 
3993   // Come here on failure.
3994   __ push_ptr(receiver);
3995   // Object is at TOS, target klass oop expected in rax by convention.
3996   __ z_brul((address) Interpreter::_throw_ClassCastException_entry);
3997 
3998   // Come here on success.
3999   __ bind(ok_is_subtype);
4000 
4001   __ z_lgr(Z_tos, receiver); // Restore object.
4002 
4003   // Collect counts on whether this test sees NULLs a lot or not.
4004   if (ProfileInterpreter) {
4005     __ z_bru(done);
4006     __ bind(is_null);
4007     __ profile_null_seen(Z_tmp_1);
4008   } else {
4009     __ bind(is_null);   // Same as &#39;done&#39;.
4010   }
4011 
4012   __ bind(done);
4013   BLOCK_COMMENT(&quot;} checkcast&quot;);
4014 }
4015 
4016 void TemplateTable::instanceof() {
4017   transition(atos, itos);
4018 
4019   NearLabel done, is_null, ok_is_subtype, quicked, resolved;
4020 
4021   BLOCK_COMMENT(&quot;instanceof {&quot;);
4022   // If object is NULL, we are almost done.
4023   __ compareU64_and_branch(Z_tos, (intptr_t) 0, Assembler::bcondZero, is_null);
4024 
4025   // Get cpool &amp; tags index.
4026   Register cpool = Z_tmp_1;
4027   Register tags = Z_tmp_2;
4028   Register index = Z_ARG5;
4029 
4030   __ get_cpool_and_tags(cpool, tags);
4031   __ get_2_byte_integer_at_bcp(index, 1, InterpreterMacroAssembler::Unsigned);
4032   // See if bytecode has already been quicked.
4033   // Note: For CLI, we would have to add the index to the tags pointer first,
4034   // thus load and compare in a &quot;classic&quot; manner.
4035   __ z_llgc(Z_R0_scratch,
4036             Address(tags, index, Array&lt;u1&gt;::base_offset_in_bytes()));
4037   __ compareU64_and_branch(Z_R0_scratch, JVM_CONSTANT_Class, Assembler::bcondEqual, quicked);
4038 
4039   __ push(atos); // Save receiver for result, and for GC.
4040   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4041   __ get_vm_result_2(Z_tos);
4042 
4043   Register receiver = Z_tmp_2;
4044   Register klass = Z_tos;
4045   Register subklass = Z_tmp_2;
4046 
4047   __ pop_ptr(receiver); // Restore receiver.
4048   __ verify_oop(receiver);
4049   __ load_klass(subklass, subklass);
4050   __ z_bru(resolved);
4051 
4052   // Get superklass in klass and subklass in subklass.
4053   __ bind(quicked);
4054 
4055   __ load_klass(subklass, Z_tos);
4056   __ z_sllg(index, index, LogBytesPerWord);  // index2bytes for addressing
4057   __ load_resolved_klass_at_offset(cpool, index, klass);
4058 
4059   __ bind(resolved);
4060 
4061   // Generate subtype check.
4062   // Superklass in klass. Subklass in subklass.
4063   __ gen_subtype_check(subklass, klass, Z_ARG4, Z_ARG5, ok_is_subtype);
4064 
4065   // Come here on failure.
4066   __ clear_reg(Z_tos, true, false);
4067   __ z_bru(done);
4068 
4069   // Come here on success.
4070   __ bind(ok_is_subtype);
4071   __ load_const_optimized(Z_tos, 1);
4072 
4073   // Collect counts on whether this test sees NULLs a lot or not.
4074   if (ProfileInterpreter) {
4075     __ z_bru(done);
4076     __ bind(is_null);
4077     __ profile_null_seen(Z_tmp_1);
4078   } else {
4079     __ bind(is_null);   // same as &#39;done&#39;
4080   }
4081 
4082   __ bind(done);
4083   // tos = 0: obj == NULL or  obj is not an instanceof the specified klass
4084   // tos = 1: obj != NULL and obj is     an instanceof the specified klass
4085   BLOCK_COMMENT(&quot;} instanceof&quot;);
4086 }
4087 
4088 //-----------------------------------------------------------------------------
4089 // Breakpoints
4090 void TemplateTable::_breakpoint() {
4091 
4092   // Note: We get here even if we are single stepping.
4093   // Jbug insists on setting breakpoints at every bytecode
4094   // even if we are in single step mode.
4095 
4096   transition(vtos, vtos);
4097 
4098   // Get the unpatched byte code.
4099   __ get_method(Z_ARG2);
4100   __ call_VM(noreg,
4101              CAST_FROM_FN_PTR(address, InterpreterRuntime::get_original_bytecode_at),
4102              Z_ARG2, Z_bcp);
4103   // Save the result to a register that is preserved over C-function calls.
4104   __ z_lgr(Z_tmp_1, Z_RET);
4105 
4106   // Post the breakpoint event.
4107   __ get_method(Z_ARG2);
4108   __ call_VM(noreg,
4109              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
4110              Z_ARG2, Z_bcp);
4111 
4112   // Must restore the bytecode, because call_VM destroys Z_bytecode.
4113   __ z_lgr(Z_bytecode, Z_tmp_1);
4114 
4115   // Complete the execution of original bytecode.
4116   __ dispatch_only_normal(vtos);
4117 }
4118 
4119 
4120 // Exceptions
4121 
4122 void TemplateTable::athrow() {
4123   transition(atos, vtos);
4124   __ null_check(Z_tos);
4125   __ load_absolute_address(Z_ARG2, Interpreter::throw_exception_entry());
4126   __ z_br(Z_ARG2);
4127 }
4128 
4129 // Synchronization
4130 //
4131 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
4132 //       in the assembly code structure as well
4133 //
4134 // Stack layout:
4135 //
4136 //               callers_sp        &lt;- Z_SP (callers_sp == Z_fp (own fp))
4137 //               return_pc
4138 //               [rest of ABI_160]
4139 //              /slot o:   free
4140 //             / ...       free
4141 //       oper. | slot n+1: free    &lt;- Z_esp points to first free slot
4142 //       stack | slot n:   val                      caches IJAVA_STATE.esp
4143 //             | ...
4144 //              \slot 0:   val
4145 //              /slot m            &lt;- IJAVA_STATE.monitors = monitor block top
4146 //             | ...
4147 //     monitors| slot 2
4148 //             | slot 1
4149 //              \slot 0
4150 //              /slot l            &lt;- monitor block bot
4151 // ijava_state | ...
4152 //             | slot 2
4153 //              \slot 0
4154 //                                 &lt;- Z_fp
4155 void TemplateTable::monitorenter() {
4156   transition(atos, vtos);
4157 
4158   BLOCK_COMMENT(&quot;monitorenter {&quot;);
4159 
4160   // Check for NULL object.
4161   __ null_check(Z_tos);
4162   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4163   NearLabel allocated;
4164   // Initialize entry pointer.
4165   const Register Rfree_slot = Z_tmp_1;
4166   __ clear_reg(Rfree_slot, true, false); // Points to free slot or NULL. Don&#39;t set CC.
4167 
4168   // Find a free slot in the monitor block from top to bot (result in Rfree_slot).
4169   {
4170     const Register Rcurr_monitor = Z_ARG2;
4171     const Register Rbot = Z_ARG3; // Points to word under bottom of monitor block.
4172     const Register Rlocked_obj = Z_ARG4;
4173     NearLabel loop, exit, not_free;
4174     // Starting with top-most entry.
4175     __ get_monitors(Rcurr_monitor); // Rcur_monitor = IJAVA_STATE.monitors
4176     __ add2reg(Rbot, -frame::z_ijava_state_size, Z_fp);
4177 
4178 #ifdef ASSERT
4179     address reentry = NULL;
4180     { NearLabel ok;
4181       __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotHigh, ok);
4182       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors points below monitor block bottom&quot;);
4183       __ bind(ok);
4184     }
4185     { NearLabel ok;
4186       __ compareU64_and_branch(Rcurr_monitor, Z_esp, Assembler::bcondHigh, ok);
4187       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors above Z_esp&quot;);
4188       __ bind(ok);
4189     }
4190 #endif
4191 
4192     // Check if bottom reached, i.e. if there is at least one monitor.
4193     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondEqual, exit);
4194 
4195     __ bind(loop);
4196     // Check if current entry is used.
4197     __ load_and_test_long(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));
4198     __ z_brne(not_free);
4199     // If not used then remember entry in Rfree_slot.
4200     __ z_lgr(Rfree_slot, Rcurr_monitor);
4201     __ bind(not_free);
4202     // Exit if current entry is for same object; this guarantees, that new monitor
4203     // used for recursive lock is above the older one.
4204     __ compareU64_and_branch(Rlocked_obj, Z_tos, Assembler::bcondEqual, exit);
4205     // otherwise advance to next entry
4206     __ add2reg(Rcurr_monitor, entry_size);
4207     // Check if bottom reached, if not at bottom then check this entry.
4208     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotEqual, loop);
4209     __ bind(exit);
4210   }
4211 
4212   // Rfree_slot != NULL -&gt; found one
4213   __ compareU64_and_branch(Rfree_slot, (intptr_t)0L, Assembler::bcondNotEqual, allocated);
4214 
4215   // Allocate one if there&#39;s no free slot.
4216   __ add_monitor_to_stack(false, Z_ARG3, Z_ARG4, Z_ARG5);
4217   __ get_monitors(Rfree_slot);
4218 
4219   // Rfree_slot: points to monitor entry.
4220   __ bind(allocated);
4221 
4222   // Increment bcp to point to the next bytecode, so exception
4223   // handling for async. exceptions work correctly.
4224   // The object has already been poped from the stack, so the
4225   // expression stack looks correct.
4226   __ add2reg(Z_bcp, 1, Z_bcp);
4227 
4228   // Store object.
4229   __ z_stg(Z_tos, BasicObjectLock::obj_offset_in_bytes(), Rfree_slot);
4230   __ lock_object(Rfree_slot, Z_tos);
4231 
4232   // Check to make sure this monitor doesn&#39;t cause stack overflow after locking.
4233   __ save_bcp();  // in case of exception
4234   __ generate_stack_overflow_check(0);
4235 
4236   // The bcp has already been incremented. Just need to dispatch to
4237   // next instruction.
4238   __ dispatch_next(vtos);
4239 
4240   BLOCK_COMMENT(&quot;} monitorenter&quot;);
4241 }
4242 
4243 
4244 void TemplateTable::monitorexit() {
4245   transition(atos, vtos);
4246 
4247   BLOCK_COMMENT(&quot;monitorexit {&quot;);
4248 
4249   // Check for NULL object.
4250   __ null_check(Z_tos);
4251 
4252   NearLabel found, not_found;
4253   const Register Rcurr_monitor = Z_ARG2;
4254 
4255   // Find matching slot.
4256   {
4257     const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4258     NearLabel entry, loop;
4259 
4260     const Register Rbot = Z_ARG3; // Points to word under bottom of monitor block.
4261     const Register Rlocked_obj = Z_ARG4;
4262     // Starting with top-most entry.
4263     __ get_monitors(Rcurr_monitor); // Rcur_monitor = IJAVA_STATE.monitors
4264     __ add2reg(Rbot, -frame::z_ijava_state_size, Z_fp);
4265 
4266 #ifdef ASSERT
4267     address reentry = NULL;
4268     { NearLabel ok;
4269       __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotHigh, ok);
4270       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors points below monitor block bottom&quot;);
4271       __ bind(ok);
4272     }
4273     { NearLabel ok;
4274       __ compareU64_and_branch(Rcurr_monitor, Z_esp, Assembler::bcondHigh, ok);
4275       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors above Z_esp&quot;);
4276       __ bind(ok);
4277     }
4278 #endif
4279 
4280     // Check if bottom reached, i.e. if there is at least one monitor.
4281     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondEqual, not_found);
4282 
4283     __ bind(loop);
4284     // Check if current entry is for same object.
4285     __ z_lg(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));
4286     // If same object then stop searching.
4287     __ compareU64_and_branch(Rlocked_obj, Z_tos, Assembler::bcondEqual, found);
4288     // Otherwise advance to next entry.
4289     __ add2reg(Rcurr_monitor, entry_size);
4290     // Check if bottom reached, if not at bottom then check this entry.
4291     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotEqual, loop);
4292   }
4293 
4294   __ bind(not_found);
4295   // Error handling. Unlocking was not block-structured.
4296   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4297                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4298   __ should_not_reach_here();
4299 
4300   __ bind(found);
4301   __ push_ptr(Z_tos); // Make sure object is on stack (contract with oopMaps).
4302   __ unlock_object(Rcurr_monitor, Z_tos);
4303   __ pop_ptr(Z_tos); // Discard object.
4304   BLOCK_COMMENT(&quot;} monitorexit&quot;);
4305 }
4306 
4307 // Wide instructions
4308 void TemplateTable::wide() {
4309   transition(vtos, vtos);
4310 
4311   __ z_llgc(Z_R1_scratch, at_bcp(1));
4312   __ z_sllg(Z_R1_scratch, Z_R1_scratch, LogBytesPerWord);
4313   __ load_absolute_address(Z_tmp_1, (address) Interpreter::_wentry_point);
4314   __ mem2reg_opt(Z_tmp_1, Address(Z_tmp_1, Z_R1_scratch));
4315   __ z_br(Z_tmp_1);
4316   // Note: the bcp increment step is part of the individual wide
4317   // bytecode implementations.
4318 }
4319 
4320 // Multi arrays
4321 void TemplateTable::multianewarray() {
4322   transition(vtos, atos);
4323 
4324   __ z_llgc(Z_tmp_1, at_bcp(3)); // Get number of dimensions.
4325   // Slot count to byte offset.
4326   __ z_sllg(Z_tmp_1, Z_tmp_1, Interpreter::logStackElementSize);
4327   // Z_esp points past last_dim, so set to Z_ARG2 to first_dim address.
4328   __ load_address(Z_ARG2, Address(Z_esp, Z_tmp_1));
4329   call_VM(Z_RET,
4330           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4331           Z_ARG2);
4332   // Pop dimensions from expression stack.
4333   __ z_agr(Z_esp, Z_tmp_1);
4334 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
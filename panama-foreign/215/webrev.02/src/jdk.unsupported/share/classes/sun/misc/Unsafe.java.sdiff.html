<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../jdk.sctp/share/classes/com/sun/nio/sctp/NotificationHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.zipfs/share/classes/module-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 619 
 620     /**
 621      * Reports the location of a given field in the storage allocation of its
 622      * class.  Do not expect to perform any sort of arithmetic on this offset;
 623      * it is just a cookie which is passed to the unsafe heap memory accessors.
 624      *
 625      * &lt;p&gt;Any given field will always have the same offset and base, and no
 626      * two distinct fields of the same class will ever have the same offset
 627      * and base.
 628      *
 629      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 630      * although the Sun JVM does not use the most significant 32 bits.
 631      * However, JVM implementations which store static fields at absolute
 632      * addresses can use long offsets and null base pointers to express
 633      * the field locations in a form usable by {@link #getInt(Object,long)}.
 634      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 635      * must preserve all bits of static field offsets.
 636      * @see #getInt(Object, long)
 637      */
 638     @ForceInline

 639     public long objectFieldOffset(Field f) {
 640         if (f == null) {
 641             throw new NullPointerException();
 642         }
<span class="line-modified"> 643         if (f.getDeclaringClass().isHidden()) {</span>

 644             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);
 645         }



 646         return theInternalUnsafe.objectFieldOffset(f);
 647     }
 648 
 649     /**
 650      * Reports the location of a given static field, in conjunction with {@link
 651      * #staticFieldBase}.
 652      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 653      * it is just a cookie which is passed to the unsafe heap memory accessors.
 654      *
 655      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 656      * fields of the same class will ever have the same offset.
 657      *
 658      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 659      * although the Sun JVM does not use the most significant 32 bits.
 660      * It is hard to imagine a JVM technology which needs more than
 661      * a few bits to encode an offset within a non-array object,
 662      * However, for consistency with other methods in this class,
 663      * this method reports its result as a long value.
 664      * @see #getInt(Object, long)
 665      */
 666     @ForceInline

 667     public long staticFieldOffset(Field f) {
 668         if (f == null) {
 669             throw new NullPointerException();
 670         }
<span class="line-modified"> 671         if (f.getDeclaringClass().isHidden()) {</span>

 672             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);
 673         }



 674         return theInternalUnsafe.staticFieldOffset(f);
 675     }
 676 
 677     /**
 678      * Reports the location of a given static field, in conjunction with {@link
 679      * #staticFieldOffset}.
 680      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
 681      * given class can be accessed via methods like {@link #getInt(Object,
 682      * long)}.  This value may be null.  This value may refer to an object
 683      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
 684      * not be used in any way except as argument to the get and put routines in
 685      * this class.
 686      */
 687     @ForceInline

 688     public Object staticFieldBase(Field f) {
 689         if (f == null) {
 690             throw new NullPointerException();
 691         }
<span class="line-modified"> 692         if (f.getDeclaringClass().isHidden()) {</span>

 693             throw new UnsupportedOperationException(&quot;can&#39;t get base address on a hidden class: &quot; + f);
 694         }



 695         return theInternalUnsafe.staticFieldBase(f);
 696     }
 697 
 698     /**
 699      * Detects if the given class may need to be initialized. This is often
 700      * needed in conjunction with obtaining the static field base of a
 701      * class.
 702      *
 703      * @deprecated No replacement API for this method.  As multiple threads
 704      * may be trying to initialize the same class or interface at the same time.
 705      * The only reliable result returned by this method is {@code false}
 706      * indicating that the given class has been initialized.  Instead, simply
 707      * call {@link java.lang.invoke.MethodHandles.Lookup#ensureInitialized(Class)}
 708      * that does nothing if the given class has already been initialized.
 709      * This method is subject to removal in a future version of JDK.
 710      *
 711      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 712      *
 713      */
 714     @Deprecated(since = &quot;15&quot;, forRemoval = true)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 619 
 620     /**
 621      * Reports the location of a given field in the storage allocation of its
 622      * class.  Do not expect to perform any sort of arithmetic on this offset;
 623      * it is just a cookie which is passed to the unsafe heap memory accessors.
 624      *
 625      * &lt;p&gt;Any given field will always have the same offset and base, and no
 626      * two distinct fields of the same class will ever have the same offset
 627      * and base.
 628      *
 629      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 630      * although the Sun JVM does not use the most significant 32 bits.
 631      * However, JVM implementations which store static fields at absolute
 632      * addresses can use long offsets and null base pointers to express
 633      * the field locations in a form usable by {@link #getInt(Object,long)}.
 634      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 635      * must preserve all bits of static field offsets.
 636      * @see #getInt(Object, long)
 637      */
 638     @ForceInline
<span class="line-added"> 639     @SuppressWarnings(&quot;preview&quot;)</span>
 640     public long objectFieldOffset(Field f) {
 641         if (f == null) {
 642             throw new NullPointerException();
 643         }
<span class="line-modified"> 644         Class&lt;?&gt; declaringClass = f.getDeclaringClass();</span>
<span class="line-added"> 645         if (declaringClass.isHidden()) {</span>
 646             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);
 647         }
<span class="line-added"> 648         if (declaringClass.isRecord()) {</span>
<span class="line-added"> 649             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a record (preview): &quot; + f);</span>
<span class="line-added"> 650         }</span>
 651         return theInternalUnsafe.objectFieldOffset(f);
 652     }
 653 
 654     /**
 655      * Reports the location of a given static field, in conjunction with {@link
 656      * #staticFieldBase}.
 657      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 658      * it is just a cookie which is passed to the unsafe heap memory accessors.
 659      *
 660      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 661      * fields of the same class will ever have the same offset.
 662      *
 663      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 664      * although the Sun JVM does not use the most significant 32 bits.
 665      * It is hard to imagine a JVM technology which needs more than
 666      * a few bits to encode an offset within a non-array object,
 667      * However, for consistency with other methods in this class,
 668      * this method reports its result as a long value.
 669      * @see #getInt(Object, long)
 670      */
 671     @ForceInline
<span class="line-added"> 672     @SuppressWarnings(&quot;preview&quot;)</span>
 673     public long staticFieldOffset(Field f) {
 674         if (f == null) {
 675             throw new NullPointerException();
 676         }
<span class="line-modified"> 677         Class&lt;?&gt; declaringClass = f.getDeclaringClass();</span>
<span class="line-added"> 678         if (declaringClass.isHidden()) {</span>
 679             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);
 680         }
<span class="line-added"> 681         if (declaringClass.isRecord()) {</span>
<span class="line-added"> 682             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a record (preview): &quot; + f);</span>
<span class="line-added"> 683         }</span>
 684         return theInternalUnsafe.staticFieldOffset(f);
 685     }
 686 
 687     /**
 688      * Reports the location of a given static field, in conjunction with {@link
 689      * #staticFieldOffset}.
 690      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
 691      * given class can be accessed via methods like {@link #getInt(Object,
 692      * long)}.  This value may be null.  This value may refer to an object
 693      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
 694      * not be used in any way except as argument to the get and put routines in
 695      * this class.
 696      */
 697     @ForceInline
<span class="line-added"> 698     @SuppressWarnings(&quot;preview&quot;)</span>
 699     public Object staticFieldBase(Field f) {
 700         if (f == null) {
 701             throw new NullPointerException();
 702         }
<span class="line-modified"> 703         Class&lt;?&gt; declaringClass = f.getDeclaringClass();</span>
<span class="line-added"> 704         if (declaringClass.isHidden()) {</span>
 705             throw new UnsupportedOperationException(&quot;can&#39;t get base address on a hidden class: &quot; + f);
 706         }
<span class="line-added"> 707         if (declaringClass.isRecord()) {</span>
<span class="line-added"> 708             throw new UnsupportedOperationException(&quot;can&#39;t get base address on a record (preview): &quot; + f);</span>
<span class="line-added"> 709         }</span>
 710         return theInternalUnsafe.staticFieldBase(f);
 711     }
 712 
 713     /**
 714      * Detects if the given class may need to be initialized. This is often
 715      * needed in conjunction with obtaining the static field base of a
 716      * class.
 717      *
 718      * @deprecated No replacement API for this method.  As multiple threads
 719      * may be trying to initialize the same class or interface at the same time.
 720      * The only reliable result returned by this method is {@code false}
 721      * indicating that the given class has been initialized.  Instead, simply
 722      * call {@link java.lang.invoke.MethodHandles.Lookup#ensureInitialized(Class)}
 723      * that does nothing if the given class has already been initialized.
 724      * This method is subject to removal in a future version of JDK.
 725      *
 726      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 727      *
 728      */
 729     @Deprecated(since = &quot;15&quot;, forRemoval = true)
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../jdk.sctp/share/classes/com/sun/nio/sctp/NotificationHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.zipfs/share/classes/module-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
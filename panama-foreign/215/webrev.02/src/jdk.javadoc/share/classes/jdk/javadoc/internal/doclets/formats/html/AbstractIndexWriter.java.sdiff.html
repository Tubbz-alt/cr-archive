<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../../jdk.internal.vm.ci/share/classes/jdk.vm.ci.meta/src/jdk/vm/ci/meta/ResolvedJavaType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DeprecatedListWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 
 28 import java.io.IOException;
 29 import java.io.Writer;

 30 import java.util.Iterator;
 31 import java.util.List;
 32 import java.util.Map;
 33 import java.util.stream.Collectors;
 34 import java.util.stream.Stream;
 35 
 36 import javax.lang.model.element.Element;
 37 import javax.lang.model.element.ElementKind;
 38 import javax.lang.model.element.ExecutableElement;
 39 import javax.lang.model.element.ModuleElement;
 40 import javax.lang.model.element.PackageElement;
 41 import javax.lang.model.element.TypeElement;
 42 
 43 import com.sun.source.doctree.DocTree;
 44 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;
 45 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
 48 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 49 import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
</pre>
<hr />
<pre>
 88      * @param path       Path to the file which is getting generated.
 89      * @param indexBuilder Unicode based Index from {@link IndexBuilder}
 90      */
 91     protected AbstractIndexWriter(HtmlConfiguration configuration,
 92                                   DocPath path,
 93                                   IndexBuilder indexBuilder) {
 94         super(configuration, path);
 95         this.indexBuilder = indexBuilder;
 96         this.navBar = new Navigation(null, configuration, PageMode.INDEX, path);
 97         Stream&lt;SearchIndexItem&gt; items =
 98                 searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY)
 99                         .sorted(comparators.makeGenericSearchIndexComparator());
100         this.tagSearchIndexMap = buildSearchTagIndex(items);
101     }
102 
103     protected void addContents(Character uc, List&lt;IndexItem&gt; memberlist,
104             Content contentTree) {
105         addHeading(uc, contentTree);
106 
107         HtmlTree dl = HtmlTree.DL(HtmlStyle.index);



108         for (IndexItem indexItem : memberlist) {
<span class="line-modified">109             addDescription(indexItem, dl);</span>

110         }
111         contentTree.add(dl);
112     }
113 
114     protected void addHeading(Character uc, Content contentTree) {
115         String unicode = uc.toString();
116         Content headContent = new StringContent(unicode);
117         HtmlTree heading = HtmlTree.HEADING(Headings.CONTENT_HEADING,
118                 HtmlStyle.title, headContent);
119         heading.setId(getNameForIndex(unicode));
120         contentTree.add(heading);
121     }
122 
<span class="line-modified">123     protected void addDescription(IndexItem indexItem, Content dl) {</span>
124         SearchIndexItem si = indexItem.getSearchTag();
125         if (si != null) {
126             addDescription(si, dl);
127         } else {
128             si = new SearchIndexItem();
129             si.setLabel(indexItem.getLabel());
<span class="line-modified">130             addElementDescription(indexItem, dl, si);</span>
131             searchItems.add(si);
132         }
133     }
134 
135     /**
136      * Add one line summary comment for the element.
137      *
138      * @param indexItem the element to be documented
139      * @param dlTree the content tree to which the description will be added
140      * @param si the search index item

141      */
<span class="line-modified">142     protected void addElementDescription(IndexItem indexItem, Content dlTree, SearchIndexItem si) {</span>

143         Content dt;
144         Element element = indexItem.getElement();
145         String label = indexItem.getLabel();
146         switch (element.getKind()) {
147             case MODULE:
148                 dt = HtmlTree.DT(getModuleLink((ModuleElement)element, new StringContent(label)));
149                 si.setCategory(Category.MODULES);
150                 dt.add(&quot; - &quot;).add(contents.module_).add(&quot; &quot; + label);
151                 break;
152             case PACKAGE:
153                 dt = HtmlTree.DT(getPackageLink((PackageElement)element, new StringContent(label)));
154                 if (configuration.showModules) {
155                     si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));
156                 }
157                 si.setCategory(Category.PACKAGES);
158                 dt.add(&quot; - &quot;).add(contents.package_).add(&quot; &quot; + label);
159                 break;
160             case CLASS:
161             case ENUM:
162             case RECORD:
163             case ANNOTATION_TYPE:
164             case INTERFACE:
165                 dt = HtmlTree.DT(getLink(new LinkInfoImpl(configuration,
166                         LinkInfoImpl.Kind.INDEX, (TypeElement)element).strong(true)));
167                 si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));



168                 si.setCategory(Category.TYPES);
169                 dt.add(&quot; - &quot;);
170                 addClassInfo((TypeElement)element, dt);
171                 break;
172             default:
173                 TypeElement containingType = indexItem.getTypeElement();
174                 dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.memberNameLink,
175                         getDocLink(LinkInfoImpl.Kind.INDEX, containingType, element, new StringContent(label))));
176                 si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));
177                 si.setContainingClass(utils.getSimpleName(containingType));



178                 if (utils.isExecutableElement(element)) {
179                     String url = HtmlTree.encodeURL(links.getName(getAnchor((ExecutableElement)element)));
180                     if (!label.equals(url)) {
181                         si.setUrl(url);
182                     }
183                 }
184                 si.setCategory(Category.MEMBERS);
185                 dt.add(&quot; - &quot;);
186                 addMemberDesc(element, containingType, dt);
187                 break;
188         }
189         dlTree.add(dt);
190         Content dd = new HtmlTree(TagName.DD);
191         if (element.getKind() == ElementKind.MODULE || element.getKind() == ElementKind.PACKAGE) {
192             addSummaryComment(element, dd);
193         } else {
194             addComment(element, dd);
195         }
196         dlTree.add(dd);
197     }
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 
 28 import java.io.IOException;
 29 import java.io.Writer;
<span class="line-added"> 30 import java.util.HashMap;</span>
 31 import java.util.Iterator;
 32 import java.util.List;
 33 import java.util.Map;
 34 import java.util.stream.Collectors;
 35 import java.util.stream.Stream;
 36 
 37 import javax.lang.model.element.Element;
 38 import javax.lang.model.element.ElementKind;
 39 import javax.lang.model.element.ExecutableElement;
 40 import javax.lang.model.element.ModuleElement;
 41 import javax.lang.model.element.PackageElement;
 42 import javax.lang.model.element.TypeElement;
 43 
 44 import com.sun.source.doctree.DocTree;
 45 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 48 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 50 import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
</pre>
<hr />
<pre>
 89      * @param path       Path to the file which is getting generated.
 90      * @param indexBuilder Unicode based Index from {@link IndexBuilder}
 91      */
 92     protected AbstractIndexWriter(HtmlConfiguration configuration,
 93                                   DocPath path,
 94                                   IndexBuilder indexBuilder) {
 95         super(configuration, path);
 96         this.indexBuilder = indexBuilder;
 97         this.navBar = new Navigation(null, configuration, PageMode.INDEX, path);
 98         Stream&lt;SearchIndexItem&gt; items =
 99                 searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY)
100                         .sorted(comparators.makeGenericSearchIndexComparator());
101         this.tagSearchIndexMap = buildSearchTagIndex(items);
102     }
103 
104     protected void addContents(Character uc, List&lt;IndexItem&gt; memberlist,
105             Content contentTree) {
106         addHeading(uc, contentTree);
107 
108         HtmlTree dl = HtmlTree.DL(HtmlStyle.index);
<span class="line-added">109         Map&lt;String,Integer&gt; duplicateLabelCheck = new HashMap&lt;&gt;();</span>
<span class="line-added">110         memberlist.forEach(e -&gt; duplicateLabelCheck.compute(e.getFullyQualifiedLabel(utils),</span>
<span class="line-added">111                 (k, v) -&gt; v == null ? 1 : v + 1));</span>
112         for (IndexItem indexItem : memberlist) {
<span class="line-modified">113             addDescription(indexItem, dl,</span>
<span class="line-added">114                     duplicateLabelCheck.get(indexItem.getFullyQualifiedLabel(utils)) &gt; 1);</span>
115         }
116         contentTree.add(dl);
117     }
118 
119     protected void addHeading(Character uc, Content contentTree) {
120         String unicode = uc.toString();
121         Content headContent = new StringContent(unicode);
122         HtmlTree heading = HtmlTree.HEADING(Headings.CONTENT_HEADING,
123                 HtmlStyle.title, headContent);
124         heading.setId(getNameForIndex(unicode));
125         contentTree.add(heading);
126     }
127 
<span class="line-modified">128     protected void addDescription(IndexItem indexItem, Content dl, boolean addModuleInfo) {</span>
129         SearchIndexItem si = indexItem.getSearchTag();
130         if (si != null) {
131             addDescription(si, dl);
132         } else {
133             si = new SearchIndexItem();
134             si.setLabel(indexItem.getLabel());
<span class="line-modified">135             addElementDescription(indexItem, dl, si, addModuleInfo);</span>
136             searchItems.add(si);
137         }
138     }
139 
140     /**
141      * Add one line summary comment for the element.
142      *
143      * @param indexItem the element to be documented
144      * @param dlTree the content tree to which the description will be added
145      * @param si the search index item
<span class="line-added">146      * @param addModuleInfo whether to include module information</span>
147      */
<span class="line-modified">148     protected void addElementDescription(IndexItem indexItem, Content dlTree, SearchIndexItem si,</span>
<span class="line-added">149                                          boolean addModuleInfo) {</span>
150         Content dt;
151         Element element = indexItem.getElement();
152         String label = indexItem.getLabel();
153         switch (element.getKind()) {
154             case MODULE:
155                 dt = HtmlTree.DT(getModuleLink((ModuleElement)element, new StringContent(label)));
156                 si.setCategory(Category.MODULES);
157                 dt.add(&quot; - &quot;).add(contents.module_).add(&quot; &quot; + label);
158                 break;
159             case PACKAGE:
160                 dt = HtmlTree.DT(getPackageLink((PackageElement)element, new StringContent(label)));
161                 if (configuration.showModules) {
162                     si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));
163                 }
164                 si.setCategory(Category.PACKAGES);
165                 dt.add(&quot; - &quot;).add(contents.package_).add(&quot; &quot; + label);
166                 break;
167             case CLASS:
168             case ENUM:
169             case RECORD:
170             case ANNOTATION_TYPE:
171             case INTERFACE:
172                 dt = HtmlTree.DT(getLink(new LinkInfoImpl(configuration,
173                         LinkInfoImpl.Kind.INDEX, (TypeElement)element).strong(true)));
174                 si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));
<span class="line-added">175                 if (configuration.showModules &amp;&amp; addModuleInfo) {</span>
<span class="line-added">176                     si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));</span>
<span class="line-added">177                 }</span>
178                 si.setCategory(Category.TYPES);
179                 dt.add(&quot; - &quot;);
180                 addClassInfo((TypeElement)element, dt);
181                 break;
182             default:
183                 TypeElement containingType = indexItem.getTypeElement();
184                 dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.memberNameLink,
185                         getDocLink(LinkInfoImpl.Kind.INDEX, containingType, element, new StringContent(label))));
186                 si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));
187                 si.setContainingClass(utils.getSimpleName(containingType));
<span class="line-added">188                 if (configuration.showModules &amp;&amp; addModuleInfo) {</span>
<span class="line-added">189                     si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));</span>
<span class="line-added">190                 }</span>
191                 if (utils.isExecutableElement(element)) {
192                     String url = HtmlTree.encodeURL(links.getName(getAnchor((ExecutableElement)element)));
193                     if (!label.equals(url)) {
194                         si.setUrl(url);
195                     }
196                 }
197                 si.setCategory(Category.MEMBERS);
198                 dt.add(&quot; - &quot;);
199                 addMemberDesc(element, containingType, dt);
200                 break;
201         }
202         dlTree.add(dt);
203         Content dd = new HtmlTree(TagName.DD);
204         if (element.getKind() == ElementKind.MODULE || element.getKind() == ElementKind.PACKAGE) {
205             addSummaryComment(element, dd);
206         } else {
207             addComment(element, dd);
208         }
209         dlTree.add(dd);
210     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../../jdk.internal.vm.ci/share/classes/jdk.vm.ci.meta/src/jdk/vm/ci/meta/ResolvedJavaType.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DeprecatedListWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/BaseConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit;
 27 
 28 import java.io.*;
 29 import java.util.*;
 30 
 31 import javax.lang.model.element.Element;
 32 import javax.lang.model.element.ModuleElement;
 33 import javax.lang.model.element.PackageElement;
 34 import javax.lang.model.element.TypeElement;
 35 import javax.lang.model.util.SimpleElementVisitor14;
 36 import javax.tools.JavaFileManager;
 37 import javax.tools.JavaFileObject;
 38 
 39 import com.sun.source.util.DocTreePath;
 40 import com.sun.tools.javac.util.DefinedBy;
 41 import com.sun.tools.javac.util.DefinedBy.Api;
 42 import jdk.javadoc.doclet.Doclet;
 43 import jdk.javadoc.doclet.DocletEnvironment;
 44 import jdk.javadoc.doclet.Reporter;
 45 import jdk.javadoc.doclet.StandardDoclet;
 46 import jdk.javadoc.doclet.Taglet;
 47 import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;
 48 import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;
 49 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;
 50 import jdk.javadoc.internal.doclets.toolkit.util.Comparators;
 51 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 52 import jdk.javadoc.internal.doclets.toolkit.util.DocFileFactory;
 53 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 54 import jdk.javadoc.internal.doclets.toolkit.util.Extern;
 55 import jdk.javadoc.internal.doclets.toolkit.util.Group;
 56 import jdk.javadoc.internal.doclets.toolkit.util.MetaKeywords;
 57 import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;
 58 import jdk.javadoc.internal.doclets.toolkit.util.TypeElementCatalog;
 59 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 60 import jdk.javadoc.internal.doclets.toolkit.util.Utils.Pair;
 61 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberCache;
 62 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 63 
 64 /**
 65  * Configure the output based on the options. Doclets should sub-class
 66  * BaseConfiguration, to configure and add their own options. This class contains
 67  * all user options which are supported by the standard doclet.
 68  * &lt;p&gt;
 69  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 70  * If you write code that depends on this, you do so at your own risk.
 71  * This code and its internal interfaces are subject to change or
 72  * deletion without notice.&lt;/b&gt;
 73  */
 74 public abstract class BaseConfiguration {
 75     /**
 76      * The doclet that created this configuration.
 77      */
 78     public final Doclet doclet;
 79 
 80     /**
 81      * The factory for builders.
 82      */
 83     protected BuilderFactory builderFactory;
 84 
 85     /**
 86      * The taglet manager.
 87      */
 88     public TagletManager tagletManager;
 89 
 90     /**
 91      * The path to the builder XML input file.
 92      */
 93     public String builderXMLPath;
 94 
 95     /**
 96      * The default path to the builder XML.
 97      */
 98     public static final String DEFAULT_BUILDER_XML = &quot;resources/doclet.xml&quot;;
 99 
100     /**
101      * The meta tag keywords instance.
102      */
103     public MetaKeywords metakeywords;
104 
105     /**
106      * The doclet environment.
107      */
108     public DocletEnvironment docEnv;
109 
110     /**
111      * An utility class for commonly used helpers
112      */
113     public Utils utils;
114 
115     /**
116      * All the temporary accessors to javac internals.
117      */
118     public WorkArounds workArounds;
119 
120     /**
121      * Sourcepath from where to read the source files. Default is classpath.
122      */
123     public String sourcepath = &quot;&quot;;
124 
125     /**
126      * Generate modules documentation if more than one module is present.
127      */
128     public boolean showModules = false;
129 
130     /**
131      * The catalog of classes specified on the command-line
132      */
133     public TypeElementCatalog typeElementCatalog;
134 
135     /**
136      * The package grouping instance.
137      */
138     public final Group group = new Group(this);
139 
140     /**
141      * The tracker of external package links.
142      */
143     public Extern extern;
144 
145     public final Reporter reporter;
146 
147     public final Locale locale;
148 
149     public abstract Messages getMessages();
150 
151     public abstract Resources getDocResources();
152 
153     /**
154      * Returns the version of the {@link #doclet doclet}.
155      *
156      * @return the version
157      */
158     public abstract Runtime.Version getDocletVersion();
159 
160     /**
161      * Returns a short string representation of the version returned by
162      * {@linkplain #getDocletVersion()}.
163      *
164      * @return a short string representation of the version
165      */
166     public abstract String getDocletVersionString();
167 
168     /**
169      * This method should be defined in all those doclets (configurations),
170      * which want to derive themselves from this BaseConfiguration. This method
171      * can be used to finish up the options setup.
172      *
173      * @return true if successful and false otherwise
174      */
175 
176     public abstract boolean finishOptionSettings();
177 
178     public CommentUtils cmtUtils;
179 
180     /**
181      * A sorted set of included packages.
182      */
183     public SortedSet&lt;PackageElement&gt; packages = null;
184 
185     public OverviewElement overviewElement;
186 
187     public DocFileFactory docFileFactory;
188 
189     /**
190      * A sorted map, giving the (specified|included|other) packages for each module.
191      */
192     public SortedMap&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackages;
193 
194     /**
195      * The list of known modules, that should be documented.
196      */
197     public SortedSet&lt;ModuleElement&gt; modules;
198 
199     protected static final String sharedResourceBundleName =
200             &quot;jdk.javadoc.internal.doclets.toolkit.resources.doclets&quot;;
201 
202     VisibleMemberCache visibleMemberCache = null;
203 
204     public PropertyUtils propertyUtils = null;
205 
206     /**
207      * Constructs the format-independent configuration needed by the doclet.
208      *
209      * @apiNote The {@code doclet} parameter is used when
210      * {@link Taglet#init(DocletEnvironment, Doclet) initializing tags}.
211      * Some doclets (such as the {@link StandardDoclet}), may delegate to another
212      * (such as the {@link HtmlDoclet}).  In such cases, the primary doclet (i.e
213      * {@code StandardDoclet}) should be provided here, and not any internal
214      * class like {@code HtmlDoclet}.
215      *
216      * @param doclet   the doclet for this run of javadoc
217      * @param locale   the locale for the generated documentation
218      * @param reporter the reporter to use for console messages
219      */
220     public BaseConfiguration(Doclet doclet, Locale locale, Reporter reporter) {
221         this.doclet = doclet;
222         this.locale = locale;
223         this.reporter = reporter;
224     }
225 
226     public abstract BaseOptions getOptions();
227 
228     private boolean initialized = false;
229 
230     protected void initConfiguration(DocletEnvironment docEnv) {
231         if (initialized) {
232             throw new IllegalStateException(&quot;configuration previously initialized&quot;);
233         }
234         initialized = true;
235         this.docEnv = docEnv;
236         // Utils needs docEnv, safe to init now.
237         utils = new Utils(this);
238 
239         BaseOptions options = getOptions();
240         if (!options.javafx()) {
241             options.setJavaFX(isJavaFXMode());
242         }
243 
244         // Once docEnv and Utils have been initialized, others should be safe.
245         metakeywords = new MetaKeywords(this);
246         cmtUtils = new CommentUtils(this);
247         workArounds = new WorkArounds(this);
248         visibleMemberCache = new VisibleMemberCache(this);
249         propertyUtils = new PropertyUtils(this);
250 
251         Splitter specifiedSplitter = new Splitter(docEnv, false);
252         specifiedModuleElements = Collections.unmodifiableSet(specifiedSplitter.mset);
253         specifiedPackageElements = Collections.unmodifiableSet(specifiedSplitter.pset);
254         specifiedTypeElements = Collections.unmodifiableSet(specifiedSplitter.tset);
255 
256         Splitter includedSplitter = new Splitter(docEnv, true);
257         includedModuleElements = Collections.unmodifiableSet(includedSplitter.mset);
258         includedPackageElements = Collections.unmodifiableSet(includedSplitter.pset);
259         includedTypeElements = Collections.unmodifiableSet(includedSplitter.tset);
260     }
261 
262     /**
263      * Return the builder factory for this doclet.
264      *
265      * @return the builder factory for this doclet.
266      */
267     public BuilderFactory getBuilderFactory() {
268         if (builderFactory == null) {
269             builderFactory = new BuilderFactory(this);
270         }
271         return builderFactory;
272     }
273 
274     public Reporter getReporter() {
275         return this.reporter;
276     }
277 
278     private Set&lt;ModuleElement&gt; specifiedModuleElements;
279 
280     public Set&lt;ModuleElement&gt; getSpecifiedModuleElements() {
281         return specifiedModuleElements;
282     }
283 
284     private Set&lt;PackageElement&gt; specifiedPackageElements;
285 
286     public Set&lt;PackageElement&gt; getSpecifiedPackageElements() {
287         return specifiedPackageElements;
288     }
289 
290     private Set&lt;TypeElement&gt; specifiedTypeElements;
291 
292     public Set&lt;TypeElement&gt; getSpecifiedTypeElements() {
293         return specifiedTypeElements;
294     }
295 
296     private Set&lt;ModuleElement&gt; includedModuleElements;
297 
298     public Set&lt;ModuleElement&gt; getIncludedModuleElements() {
299         return includedModuleElements;
300     }
301 
302     private Set&lt;PackageElement&gt; includedPackageElements;
303 
304     public Set&lt;PackageElement&gt; getIncludedPackageElements() {
305         return includedPackageElements;
306     }
307 
308     private Set&lt;TypeElement&gt; includedTypeElements;
309 
310     public Set&lt;TypeElement&gt; getIncludedTypeElements() {
311         return includedTypeElements;
312     }
313 
314     private void initModules() {
315         Comparators comparators = utils.comparators;
316         // Build the modules structure used by the doclet
317         modules = new TreeSet&lt;&gt;(comparators.makeModuleComparator());
318         modules.addAll(getSpecifiedModuleElements());
319 
320         modulePackages = new TreeMap&lt;&gt;(comparators.makeModuleComparator());
321         for (PackageElement p : packages) {
322             ModuleElement mdle = docEnv.getElementUtils().getModuleOf(p);
323             if (mdle != null &amp;&amp; !mdle.isUnnamed()) {
324                 Set&lt;PackageElement&gt; s = modulePackages
325                         .computeIfAbsent(mdle, m -&gt; new TreeSet&lt;&gt;(comparators.makePackageComparator()));
326                 s.add(p);
327             }
328         }
329 
330         for (PackageElement p : getIncludedPackageElements()) {
331             ModuleElement mdle = docEnv.getElementUtils().getModuleOf(p);
332             if (mdle != null &amp;&amp; !mdle.isUnnamed()) {
333                 Set&lt;PackageElement&gt; s = modulePackages
334                         .computeIfAbsent(mdle, m -&gt; new TreeSet&lt;&gt;(comparators.makePackageComparator()));
335                 s.add(p);
336             }
337         }
338 
339         // add entries for modules which may not have exported packages
340         modules.forEach(mdle -&gt; modulePackages.computeIfAbsent(mdle, m -&gt; Collections.emptySet()));
341 
342         modules.addAll(modulePackages.keySet());
343         showModules = !modules.isEmpty();
344         for (Set&lt;PackageElement&gt; pkgs : modulePackages.values()) {
345             packages.addAll(pkgs);
346         }
347     }
348 
349     private void initPackages() {
350         packages = new TreeSet&lt;&gt;(utils.comparators.makePackageComparator());
351         // add all the included packages
352         packages.addAll(includedPackageElements);
353     }
354 
355     /*
356      * when this is called all the option have been set, this method,
357      * initializes certain components before anything else is started.
358      */
359     protected boolean finishOptionSettings0() throws DocletException {
360         BaseOptions options = getOptions();
361         extern = new Extern(this);
362         initDestDirectory();
363         for (String link : options.linkList()) {
364             extern.link(link, reporter);
365         }
366         for (Pair&lt;String, String&gt; linkOfflinePair : options.linkOfflineList()) {
367             extern.link(linkOfflinePair.first, linkOfflinePair.second, reporter);
368         }
369         typeElementCatalog = new TypeElementCatalog(includedTypeElements, this);
370         initTagletManager(options.customTagStrs());
371         options.groupPairs().forEach(grp -&gt; {
372             if (showModules) {
373                 group.checkModuleGroups(grp.first, grp.second);
374             } else {
375                 group.checkPackageGroups(grp.first, grp.second);
376             }
377         });
378         overviewElement = new OverviewElement(workArounds.getUnnamedPackage(), getOverviewPath());
379         return true;
380     }
381 
382     /**
383      * Set the command-line options supported by this configuration.
384      *
385      * @return true if the options are set successfully
386      * @throws DocletException if there is a problem while setting the options
387      */
388     public boolean setOptions() throws DocletException {
389         initPackages();
390         initModules();
391         if (!finishOptionSettings0() || !finishOptionSettings())
392             return false;
393 
394         return true;
395     }
396 
397     private void initDestDirectory() throws DocletException {
398         String destDirName = getOptions().destDirName();
399         if (!destDirName.isEmpty()) {
400             Messages messages = getMessages();
401             DocFile destDir = DocFile.createFileForDirectory(this, destDirName);
402             if (!destDir.exists()) {
403                 //Create the output directory (in case it doesn&#39;t exist yet)
404                 messages.notice(&quot;doclet.dest_dir_create&quot;, destDirName);
405                 destDir.mkdirs();
406             } else if (!destDir.isDirectory()) {
407                 throw new SimpleDocletException(messages.getResources().getText(
408                         &quot;doclet.destination_directory_not_directory_0&quot;,
409                         destDir.getPath()));
410             } else if (!destDir.canWrite()) {
411                 throw new SimpleDocletException(messages.getResources().getText(
412                         &quot;doclet.destination_directory_not_writable_0&quot;,
413                         destDir.getPath()));
414             }
415         }
416         DocFileFactory.getFactory(this).setDestDir(destDirName);
417     }
418 
419     /**
420      * Initialize the taglet manager.  The strings to initialize the simple custom tags should
421      * be in the following format:  &quot;[tag name]:[location str]:[heading]&quot;.
422      *
423      * @param customTagStrs the set two dimensional arrays of strings.  These arrays contain
424      *                      either -tag or -taglet arguments.
425      */
426     private void initTagletManager(Set&lt;List&lt;String&gt;&gt; customTagStrs) {
427         tagletManager = tagletManager != null ? tagletManager : new TagletManager(this);
428         JavaFileManager fileManager = getFileManager();
429         Messages messages = getMessages();
430         try {
431             tagletManager.initTagletPath(fileManager);
432             tagletManager.loadTaglets(fileManager);
433 
434             for (List&lt;String&gt; args : customTagStrs) {
435                 if (args.get(0).equals(&quot;-taglet&quot;)) {
436                     tagletManager.addCustomTag(args.get(1), fileManager);
437                     continue;
438                 }
439                 List&lt;String&gt; tokens = tokenize(args.get(1), TagletManager.SIMPLE_TAGLET_OPT_SEPARATOR, 3);
440                 switch (tokens.size()) {
441                     case 1:
442                         String tagName = args.get(1);
443                         if (tagletManager.isKnownCustomTag(tagName)) {
444                             //reorder a standard tag
445                             tagletManager.addNewSimpleCustomTag(tagName, null, &quot;&quot;);
446                         } else {
447                             //Create a simple tag with the heading that has the same name as the tag.
448                             StringBuilder heading = new StringBuilder(tagName + &quot;:&quot;);
449                             heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));
450                             tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), &quot;a&quot;);
451                         }
452                         break;
453 
454                     case 2:
455                         //Add simple taglet without heading, probably to excluding it in the output.
456                         tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), &quot;&quot;);
457                         break;
458 
459                     case 3:
460                         tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));
461                         break;
462 
463                     default:
464                         messages.error(&quot;doclet.Error_invalid_custom_tag_argument&quot;, args.get(1));
465                 }
466             }
467         } catch (IOException e) {
468             messages.error(&quot;doclet.taglet_could_not_set_location&quot;, e.toString());
469         }
470     }
471 
472     /**
473      * Given a string, return an array of tokens.  The separator can be escaped
474      * with the &#39;\&#39; character.  The &#39;\&#39; character may also be escaped by the
475      * &#39;\&#39; character.
476      *
477      * @param s         the string to tokenize.
478      * @param separator the separator char.
479      * @param maxTokens the maximum number of tokens returned.  If the
480      *                  max is reached, the remaining part of s is appended
481      *                  to the end of the last token.
482      * @return an array of tokens.
483      */
484     private List&lt;String&gt; tokenize(String s, char separator, int maxTokens) {
485         List&lt;String&gt; tokens = new ArrayList&lt;&gt;();
486         StringBuilder token = new StringBuilder();
487         boolean prevIsEscapeChar = false;
488         for (int i = 0; i &lt; s.length(); i += Character.charCount(i)) {
489             int currentChar = s.codePointAt(i);
490             if (prevIsEscapeChar) {
491                 // Case 1:  escaped character
492                 token.appendCodePoint(currentChar);
493                 prevIsEscapeChar = false;
494             } else if (currentChar == separator &amp;&amp; tokens.size() &lt; maxTokens - 1) {
495                 // Case 2:  separator
496                 tokens.add(token.toString());
497                 token = new StringBuilder();
498             } else if (currentChar == &#39;\\&#39;) {
499                 // Case 3:  escape character
500                 prevIsEscapeChar = true;
501             } else {
502                 // Case 4:  regular character
503                 token.appendCodePoint(currentChar);
504             }
505         }
506         if (token.length() &gt; 0) {
507             tokens.add(token.toString());
508         }
509         return tokens;
510     }
511 
512     /**
513      * Return true if the given doc-file subdirectory should be excluded and
514      * false otherwise.
515      *
516      * @param docfilesubdir the doc-files subdirectory to check.
517      * @return true if the directory is excluded.
518      */
519     public boolean shouldExcludeDocFileDir(String docfilesubdir) {
520         Set&lt;String&gt; excludedDocFileDirs = getOptions().excludedDocFileDirs();
521         return excludedDocFileDirs.contains(docfilesubdir);
522     }
523 
524     /**
525      * Return true if the given qualifier should be excluded and false otherwise.
526      *
527      * @param qualifier the qualifier to check.
528      * @return true if the qualifier should be excluded
529      */
530     public boolean shouldExcludeQualifier(String qualifier) {
531         Set&lt;String&gt; excludedQualifiers = getOptions().excludedQualifiers();
532         if (excludedQualifiers.contains(&quot;all&quot;) ||
533                 excludedQualifiers.contains(qualifier) ||
534                 excludedQualifiers.contains(qualifier + &quot;.*&quot;)) {
535             return true;
536         } else {
537             int index = -1;
538             while ((index = qualifier.indexOf(&quot;.&quot;, index + 1)) != -1) {
539                 if (excludedQualifiers.contains(qualifier.substring(0, index + 1) + &quot;*&quot;)) {
540                     return true;
541                 }
542             }
543             return false;
544         }
545     }
546 
547     /**
548      * Return the qualified name of the Element if its qualifier is not excluded.
549      * Otherwise return the unqualified Element name.
550      *
551      * @param te the TypeElement to check.
552      * @return the class name
553      */
554     public String getClassName(TypeElement te) {
555         PackageElement pkg = utils.containingPackage(te);
556         return shouldExcludeQualifier(utils.getPackageName(pkg))
557                 ? utils.getSimpleName(te)
558                 : utils.getFullyQualifiedName(te);
559     }
560 
561     /**
562      * Return true if the TypeElement element is getting documented, depending upon
563      * -nodeprecated option and the deprecation information. Return true if
564      * -nodeprecated is not used. Return false if -nodeprecated is used and if
565      * either TypeElement element is deprecated or the containing package is deprecated.
566      *
567      * @param te the TypeElement for which the page generation is checked
568      * @return true if it is a generated doc.
569      */
570     public boolean isGeneratedDoc(TypeElement te) {
571         boolean nodeprecated = getOptions().noDeprecated();
572         if (!nodeprecated) {
573             return true;
574         }
575         return !(utils.isDeprecated(te) || utils.isDeprecated(utils.containingPackage(te)));
576     }
577 
578     /**
579      * Return the doclet specific instance of a writer factory.
580      *
581      * @return the {@link WriterFactory} for the doclet.
582      */
583     public abstract WriterFactory getWriterFactory();
584 
585     /**
586      * Return the input stream to the builder XML.
587      *
588      * @return the input steam to the builder XML.
589      * @throws DocFileIOException when the given XML file cannot be found or opened.
590      */
591     public InputStream getBuilderXML() throws DocFileIOException {
592         return builderXMLPath == null ?
593                 BaseConfiguration.class.getResourceAsStream(DEFAULT_BUILDER_XML) :
594                 DocFile.createFileForInput(this, builderXMLPath).openInputStream();
595     }
596 
597     /**
598      * Return the Locale for this document.
599      *
600      * @return the current locale
601      */
602     public abstract Locale getLocale();
603 
604     /**
605      * Return the path of the overview file and null if it does not exist.
606      *
607      * @return the path of the overview file.
608      */
609     public abstract JavaFileObject getOverviewPath();
610 
611     /**
612      * Return the current file manager.
613      *
614      * @return JavaFileManager
615      */
616     public abstract JavaFileManager getFileManager();
617 
618     public abstract boolean showMessage(DocTreePath path, String key);
619 
620     public abstract boolean showMessage(Element e, String key);
621 
622     /*
623      * Splits the elements in a collection to its individual
624      * collection.
625      */
626     @SuppressWarnings(&quot;preview&quot;)
627     private static class Splitter {
628 
629         final Set&lt;ModuleElement&gt; mset = new LinkedHashSet&lt;&gt;();
630         final Set&lt;PackageElement&gt; pset = new LinkedHashSet&lt;&gt;();
631         final Set&lt;TypeElement&gt; tset = new LinkedHashSet&lt;&gt;();
632 
633         Splitter(DocletEnvironment docEnv, boolean included) {
634 
635             Set&lt;? extends Element&gt; inset = included
636                     ? docEnv.getIncludedElements()
637                     : docEnv.getSpecifiedElements();
638 
639             for (Element e : inset) {
640                 new SimpleElementVisitor14&lt;Void, Void&gt;() {
641                     @Override
642                     @DefinedBy(Api.LANGUAGE_MODEL)
643                     public Void visitModule(ModuleElement e, Void p) {
644                         mset.add(e);
645                         return null;
646                     }
647 
648                     @Override
649                     @DefinedBy(Api.LANGUAGE_MODEL)
650                     public Void visitPackage(PackageElement e, Void p) {
651                         pset.add(e);
652                         return null;
653                     }
654 
655                     @Override
656                     @DefinedBy(Api.LANGUAGE_MODEL)
657                     public Void visitType(TypeElement e, Void p) {
658                         tset.add(e);
659                         return null;
660                     }
661 
662                     @Override
663                     @DefinedBy(Api.LANGUAGE_MODEL)
664                     protected Void defaultAction(Element e, Void p) {
665                         throw new AssertionError(&quot;unexpected element: &quot; + e);
666                     }
667 
668                 }.visit(e);
669             }
670         }
671     }
672 
673     /**
674      * Returns whether or not to allow JavaScript in comments.
675      * Default is off; can be set true from a command-line option.
676      *
677      * @return the allowScriptInComments
678      */
679     public boolean isAllowScriptInComments() {
680         return getOptions().allowScriptInComments();
681     }
682 
683     public synchronized VisibleMemberTable getVisibleMemberTable(TypeElement te) {
684         return visibleMemberCache.getVisibleMemberTable(te);
685     }
686 
687     /**
688      * Determines if JavaFX is available in the compilation environment.
689      * @return true if JavaFX is available
690      */
691     public boolean isJavaFXMode() {
692         TypeElement observable = utils.elementUtils.getTypeElement(&quot;javafx.beans.Observable&quot;);
693         if (observable == null) {
694             return false;
695         }
696         ModuleElement javafxModule = utils.elementUtils.getModuleOf(observable);
697         return javafxModule == null
698                 || javafxModule.isUnnamed()
699                 || javafxModule.getQualifiedName().contentEquals(&quot;javafx.base&quot;);
700     }
701 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.tool;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.PrintWriter;
 31 import java.text.BreakIterator;
 32 import java.text.Collator;
 33 import java.util.ArrayList;
<a name="1" id="anc1"></a>
 34 import java.util.Collections;
 35 import java.util.Comparator;
 36 import java.util.IllformedLocaleException;
 37 import java.util.List;
 38 import java.util.Locale;
<a name="2" id="anc2"></a>
 39 import java.util.Objects;
<a name="3" id="anc3"></a>
 40 import java.util.Set;
<a name="4" id="anc4"></a><span class="line-added"> 41 import java.util.function.Supplier;</span>
 42 import java.util.stream.Collectors;
 43 
 44 import javax.tools.JavaFileManager;
 45 import javax.tools.JavaFileObject;
 46 import javax.tools.StandardJavaFileManager;
 47 
 48 import com.sun.tools.javac.api.JavacTrees;
 49 import com.sun.tools.javac.file.BaseFileManager;
 50 import com.sun.tools.javac.file.JavacFileManager;
 51 import com.sun.tools.javac.jvm.Target;
 52 import com.sun.tools.javac.main.Arguments;
 53 import com.sun.tools.javac.main.CommandLine;
 54 import com.sun.tools.javac.util.ClientCodeException;
 55 import com.sun.tools.javac.util.Context;
 56 import com.sun.tools.javac.util.Log;
 57 import com.sun.tools.javac.util.StringUtils;
 58 
 59 import jdk.javadoc.doclet.Doclet;
 60 import jdk.javadoc.doclet.Doclet.Option;
 61 import jdk.javadoc.doclet.DocletEnvironment;
 62 import jdk.javadoc.doclet.StandardDoclet;
<a name="5" id="anc5"></a><span class="line-added"> 63 import jdk.javadoc.internal.Versions;</span>
 64 import jdk.javadoc.internal.tool.Main.Result;
 65 import jdk.javadoc.internal.tool.ToolOptions.ToolOption;
 66 
 67 import static javax.tools.DocumentationTool.Location.*;
 68 
 69 import static jdk.javadoc.internal.tool.Main.Result.*;
 70 
 71 /**
 72  * Main program of Javadoc.
 73  * Previously named &quot;Main&quot;.
 74  *
 75  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 76  *  If you write code that depends on this, you do so at your own risk.
 77  *  This code and its internal interfaces are subject to change or
 78  *  deletion without notice.&lt;/b&gt;
 79  */
 80 public class Start {
 81 
 82     /** Context for this invocation. */
 83     private final Context context;
 84 
 85     private static final String ProgramName = &quot;javadoc&quot;;
 86 
 87     private Messager messager;
 88 
 89     private final String docletName;
 90 
 91     private final ClassLoader classLoader;
 92 
 93     private Class&lt;?&gt; docletClass;
 94 
 95     private Doclet doclet;
 96 
 97     // used to determine the locale for the messager
 98     private Locale locale;
 99 
100     /**
101      * In API mode, exceptions thrown while calling the doclet are
102      * propagated using ClientCodeException.
103      */
104     private boolean apiMode;
105 
106     private JavaFileManager fileManager;
107 
108     private final ToolOptions options;
109 
110     Start() {
111         this(null, null, null, null, null, null);
112     }
113 
114     Start(PrintWriter outWriter, PrintWriter errWriter) {
115         this(null, null, outWriter, errWriter, null, null);
116     }
117 
118     Start(Context context, String programName,
119             PrintWriter outWriter, PrintWriter errWriter,
120             String docletName, ClassLoader classLoader) {
121         this.context = context == null ? new Context() : context;
122         String pname = programName == null ? ProgramName : programName;
123         this.messager = (outWriter == null &amp;&amp; errWriter == null)
124                 ? new Messager(this.context, pname)
125                 : new Messager(this.context, pname, outWriter, errWriter);
126         this.docletName = docletName;
127         this.classLoader = classLoader;
128         this.docletClass = null;
129         this.locale = Locale.getDefault();
130 
131         options = getToolOptions();
132     }
133 
134     public Start(Context context) {
135         this.docletClass = null;
136         this.context = Objects.requireNonNull(context);
137         this.apiMode = true;
138         this.docletName = null;
139         this.classLoader = null;
140         this.locale = Locale.getDefault();
141 
142         Log log = context.get(Log.logKey);
143         if (log instanceof Messager) {
144             messager = (Messager) log;
145         } else {
146             PrintWriter out = context.get(Log.errKey);
147             messager = (out == null)
148                     ? new Messager(context, ProgramName)
149                     : new Messager(context, ProgramName, out, out);
150         }
151 
152         options = getToolOptions();
153     }
154 
155     private ToolOptions getToolOptions() {
156         ToolOptions.ShowHelper helper =  new ToolOptions.ShowHelper() {
157             @Override
158             public void usage() {
159                 showUsage(&quot;main.usage&quot;, ToolOption.Kind.STANDARD, &quot;main.usage.foot&quot;);
160             }
161 
162             @Override
163             public void Xusage() {
164                 showUsage(&quot;main.Xusage&quot;, ToolOption.Kind.EXTENDED, &quot;main.Xusage.foot&quot;);
165             }
166 
167             @Override
168             public void version() {
<a name="6" id="anc6"></a><span class="line-modified">169                 showVersion(&quot;javadoc.version&quot;, orDefault(() -&gt; Versions.shortVersionStringOf(toolVersion())));</span>
170             }
171 
172             @Override
173             public void fullVersion() {
<a name="7" id="anc7"></a><span class="line-modified">174                 showVersion(&quot;javadoc.fullversion&quot;, orDefault(() -&gt; Versions.fullVersionStringOf(toolVersion())));</span>
<span class="line-added">175             }</span>
<span class="line-added">176 </span>
<span class="line-added">177             private String orDefault(Supplier&lt;String&gt; s) {</span>
<span class="line-added">178                 try {</span>
<span class="line-added">179                     return s.get();</span>
<span class="line-added">180                 } catch (RuntimeException e) {</span>
<span class="line-added">181                     assert false : e;</span>
<span class="line-added">182                     return Log.getLocalizedString(&quot;version.not.available&quot;);</span>
<span class="line-added">183                 }</span>
184             }
185         };
186         return new ToolOptions(context, messager, helper);
187     }
188 
<a name="8" id="anc8"></a><span class="line-added">189     private Runtime.Version toolVersion() {</span>
<span class="line-added">190         return Versions.javadocVersion();</span>
<span class="line-added">191     }</span>
<span class="line-added">192 </span>
193     private void showUsage() {
194         showUsage(&quot;main.usage&quot;, ToolOption.Kind.STANDARD, &quot;main.usage.foot&quot;);
195     }
196 
197     private void showUsage(String headerKey, ToolOption.Kind kind, String footerKey) {
198         messager.notice(headerKey);
199         showToolOptions(kind);
200 
201         // let doclet print usage information
202         if (docletClass != null) {
203             showDocletOptions(kind == ToolOption.Kind.EXTENDED
204                     ? Option.Kind.EXTENDED
205                     : Option.Kind.STANDARD);
206         }
207         if (footerKey != null)
208             messager.notice(footerKey);
209     }
210 
<a name="9" id="anc9"></a><span class="line-modified">211     private void showVersion(String labelKey, String value) {</span>
<span class="line-modified">212         messager.notice(labelKey, messager.programName, value);</span>


















213     }
214 
215     private void showToolOptions(ToolOption.Kind kind) {
216         Comparator&lt;ToolOption&gt; comp = new Comparator&lt;ToolOption&gt;() {
217             final Collator collator = Collator.getInstance(Locale.US);
218             { collator.setStrength(Collator.PRIMARY); }
219 
220             @Override
221             public int compare(ToolOption o1, ToolOption o2) {
222                 return collator.compare(o1.primaryName, o2.primaryName);
223             }
224         };
225 
226         options.getSupportedOptions().stream()
227                     .filter(opt -&gt; opt.kind == kind)
228                     .sorted(comp)
229                     .forEach(this::showToolOption);
230     }
231 
232     private void showToolOption(ToolOption option) {
233         List&lt;String&gt; names = option.getNames();
234         String primaryName = option.primaryName;
235         String parameters;
236         if (option.hasArg || primaryName.endsWith(&quot;:&quot;)) {
237             String sep = primaryName.endsWith(&quot;:&quot;)
238                     || primaryName.equals(ToolOptions.AT)
239                     || primaryName.equals(ToolOptions.J)
240                     ? &quot;&quot; : &quot; &quot;;
241             parameters = sep + option.getParameters(messager);
242         } else {
243             parameters = &quot;&quot;;
244         }
245         String description = option.getDescription(messager);
246         showOption(names, parameters, description);
247     }
248 
249     private void showDocletOptions(Option.Kind kind) {
250         String name = doclet.getName();
251         Set&lt;? extends Option&gt; options = getSupportedOptionsOf(doclet);
252         if (options.isEmpty()) {
253             return;
254         }
255         messager.notice(&quot;main.doclet.usage.header&quot;, name);
256 
257         Comparator&lt;Doclet.Option&gt; comp = new Comparator&lt;Doclet.Option&gt;() {
258             final Collator collator = Collator.getInstance(Locale.US);
259             { collator.setStrength(Collator.PRIMARY); }
260 
261             @Override
262             public int compare(Doclet.Option o1, Doclet.Option o2) {
263                 return collator.compare(o1.getNames().get(0), o2.getNames().get(0));
264             }
265         };
266 
267         options.stream()
268                 .filter(opt -&gt; opt.getKind() == kind)
269                 .sorted(comp)
270                 .forEach(this::showDocletOption);
271     }
272 
273     private void showDocletOption(Doclet.Option option) {
274         List&lt;String&gt; names = option.getNames();
275         String parameters;
276         String primaryName = names.get(0);
277         if (option.getArgumentCount() &gt; 0 || primaryName.endsWith(&quot;:&quot;)) {
278             String sep = primaryName.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;
279             parameters = sep + option.getParameters();
280         } else {
281             parameters = &quot;&quot;;
282         }
283         String description = option.getDescription();
284         showOption(names, parameters, description);
285     }
286 
287     // The following constants are intended to format the output to
288     // be similar to that of the java launcher: i.e. &quot;java -help&quot;.
289 
290     /** The indent for the option synopsis. */
291     private static final String SMALL_INDENT = &quot; &quot;.repeat(4);
292     /** The automatic indent for the description. */
293     private static final String LARGE_INDENT = &quot; &quot;.repeat(18);
294     /** The space allowed for the synopsis, if the description is to be shown on the same line. */
295     private static final int DEFAULT_SYNOPSIS_WIDTH = 13;
296     /** The nominal maximum line length, when seeing if text will fit on a line. */
297     private static final int DEFAULT_MAX_LINE_LENGTH = 80;
298     /** The format for a single-line help entry. */
299     private static final String COMPACT_FORMAT = SMALL_INDENT + &quot;%-&quot; + DEFAULT_SYNOPSIS_WIDTH + &quot;s %s&quot;;
300 
301     void showOption(List&lt;String&gt; names, String parameters, String description) {
302         String synopses = names.stream()
303                 .map(s -&gt; s + parameters)
304                 .collect(Collectors.joining(&quot;, &quot;));
305         // If option synopses and description fit on a single line of reasonable length,
306         // display using COMPACT_FORMAT
307         if (synopses.length() &lt; DEFAULT_SYNOPSIS_WIDTH
308                 &amp;&amp; !description.contains(&quot;\n&quot;)
309                 &amp;&amp; (SMALL_INDENT.length() + DEFAULT_SYNOPSIS_WIDTH + 1 + description.length() &lt;= DEFAULT_MAX_LINE_LENGTH)) {
310             messager.printNotice(String.format(COMPACT_FORMAT, synopses, description));
311             return;
312         }
313 
314         // If option synopses fit on a single line of reasonable length, show that;
315         // otherwise, show 1 per line
316         if (synopses.length() &lt;= DEFAULT_MAX_LINE_LENGTH) {
317             messager.printNotice(SMALL_INDENT + synopses);
318         } else {
319             for (String name: names) {
320                 messager.printNotice(SMALL_INDENT + name + parameters);
321             }
322         }
323 
324         // Finally, show the description
325         messager.printNotice(LARGE_INDENT + description.replace(&quot;\n&quot;, &quot;\n&quot; + LARGE_INDENT));
326     }
327 
328 
329     /**
330      * Main program - external wrapper. In order to maintain backward
331      * CLI compatibility, the execution is dispatched to the appropriate
332      * Start mechanism, depending on the doclet variant.
333      *
334      * The doclet tests are performed in the begin method, further on,
335      * this is to minimize argument processing and most importantly the impact
336      * of class loader creation, needed to detect the doclet class variants.
337      */
338     @SuppressWarnings(&quot;deprecation&quot;)
339     Result begin(String... argv) {
340         // Preprocess @file arguments
341         List&lt;String&gt; allArgs;
342         try {
343             allArgs = CommandLine.parse(List.of(argv));
344         } catch (IOException e) {
345             error(&quot;main.cant.read&quot;, e.getMessage());
346             return ERROR;
347         }
348         return begin(allArgs, Collections.emptySet());
349     }
350 
351     // Called by the JSR 199 API
352     public boolean begin(Class&lt;?&gt; docletClass,
353                          Iterable&lt;String&gt; options,
354                          Iterable&lt;? extends JavaFileObject&gt; fileObjects)
355     {
356         this.docletClass = docletClass;
357         List&lt;String&gt; opts = new ArrayList&lt;&gt;();
358         for (String opt: options)
359             opts.add(opt);
360 
361         return begin(opts, fileObjects).isOK();
362     }
363 
364     private Result begin(List&lt;String&gt; options, Iterable&lt;? extends JavaFileObject&gt; fileObjects) {
365         fileManager = context.get(JavaFileManager.class);
366         if (fileManager == null) {
367             JavacFileManager.preRegister(context);
368             fileManager = context.get(JavaFileManager.class);
369             if (fileManager instanceof BaseFileManager) {
370                 ((BaseFileManager) fileManager).autoClose = true;
371             }
372         }
373 
374         // Perform an initial scan of the options to determine the doclet to be used (if any),
375         // so that it may participate in the main round of option processing.
376         try {
377             doclet = preprocess(options);
378         } catch (ToolException te) {
379             if (!te.result.isOK()) {
380                 if (te.message != null) {
381                     messager.printError(te.message);
382                 }
383                 Throwable t = te.getCause();
384                 dumpStack(t == null ? te : t);
385             }
386             return te.result;
387         } catch (OptionException oe) {
388             if (oe.message != null) {
389                 messager.printError(oe.message);
390             }
391             oe.m.run();
392             Throwable t = oe.getCause();
393             dumpStack(t == null ? oe : t);
394             return oe.result;
395         }
396 
397         Result result = OK;
398         try {
399             result = parseAndExecute(options, fileObjects);
400         } catch (com.sun.tools.javac.main.Option.InvalidValueException e) {
401             messager.printError(e.getMessage());
402             Throwable t = e.getCause();
403             dumpStack(t == null ? e : t);
404             return ERROR;
405         } catch (OptionException oe) {
406             if (oe.message != null)
407                 messager.printError(oe.message);
408 
409             oe.m.run();
410             Throwable t = oe.getCause();
411             dumpStack(t == null ? oe : t);
412             return oe.result;
413         } catch (ToolException exc) {
414             if (exc.message != null) {
415                 messager.printError(exc.message);
416             }
417             Throwable t = exc.getCause();
418             if (result == ABNORMAL) {
419                 reportInternalError(t == null ? exc : t);
420             } else {
421                 dumpStack(t == null ? exc : t);
422             }
423             return exc.result;
424         } catch (OutOfMemoryError ee) {
425             error(&quot;main.out.of.memory&quot;);
426             result = SYSERR;
427             dumpStack(ee);
428         } catch (ClientCodeException e) {
429             // simply rethrow these exceptions, to be caught and handled by JavadocTaskImpl
430             throw e;
431         } catch (Error | Exception ee) {
432             error(&quot;main.fatal.error&quot;, ee);
433             reportInternalError(ee);
434             result = ABNORMAL;
435         } finally {
436             if (fileManager != null
437                     &amp;&amp; fileManager instanceof BaseFileManager
438                     &amp;&amp; ((BaseFileManager) fileManager).autoClose) {
439                 try {
440                     fileManager.close();
441                 } catch (IOException ignore) {}
442             }
443             if (this.options.rejectWarnings() &amp;&amp; messager.hasWarnings()) {
444                 error(&quot;main.warnings.Werror&quot;);
445             }
446             boolean haveErrors = messager.hasErrors();
447             if (!result.isOK() &amp;&amp; !haveErrors) {
448                 // the doclet failed, but nothing reported, flag it!.
449                 error(&quot;main.unknown.error&quot;);
450             }
451             if (haveErrors &amp;&amp; result.isOK()) {
452                 result = ERROR;
453             }
454             messager.printErrorWarningCounts();
455             messager.flush();
456         }
457         return result;
458     }
459 
460     private void reportInternalError(Throwable t) {
461         messager.printErrorUsingKey(&quot;doclet.internal.report.bug&quot;);
462         dumpStack(true, t);
463     }
464 
465     private void dumpStack(Throwable t) {
466         dumpStack(false, t);
467     }
468 
469     private void dumpStack(boolean enabled, Throwable t) {
470         if (t != null &amp;&amp; (enabled || options.dumpOnError())) {
471             t.printStackTrace(System.err);
472         }
473     }
474 
475     /**
476      * Main program - internal
477      */
478     private Result parseAndExecute(List&lt;String&gt; argList, Iterable&lt;? extends JavaFileObject&gt; fileObjects)
479             throws ToolException, OptionException, com.sun.tools.javac.main.Option.InvalidValueException
480     {
481         final long startNanos = System.nanoTime();
482 
483         List&lt;String&gt; javaNames = new ArrayList&lt;&gt;();
484 
485         // Make sure no obsolete source/target messages are reported
486         try {
487             options.processCompilerOption(com.sun.tools.javac.main.Option.XLINT_CUSTOM, &quot;-Xlint:-options&quot;);
488         } catch (com.sun.tools.javac.main.Option.InvalidValueException ignore) {
489         }
490 
491         Arguments arguments = Arguments.instance(context);
492         arguments.init(ProgramName);
493         arguments.allowEmpty();
494 
495         doclet.init(locale, messager);
496         int beforeCount = messager.nerrors;
497         boolean success = parseArgs(argList, javaNames);
498         int afterCount = messager.nerrors;
499         if (!success &amp;&amp; beforeCount == afterCount) { // if there were failures but they have not been reported
500             return CMDERR;
501         }
502 
503         if (!arguments.handleReleaseOptions(extra -&gt; true)) {
504             // Arguments does not always increase the error count in the
505             // case of errors, so increment the error count only if it has
506             // not been updated previously, preventing complaints by callers
507             if (!messager.hasErrors() &amp;&amp; !messager.hasWarnings())
508                 messager.nerrors++;
509             return CMDERR;
510         }
511 
512         if (!arguments.validate()) {
513             // Arguments does not always increase the error count in the
514             // case of errors, so increment the error count only if it has
515             // not been updated previously, preventing complaints by callers
516             if (!messager.hasErrors() &amp;&amp; !messager.hasWarnings())
517                 messager.nerrors++;
518             return CMDERR;
519         }
520 
521         if (fileManager instanceof BaseFileManager) {
522             ((BaseFileManager) fileManager).handleOptions(options.fileManagerOptions());
523         }
524 
525         String mr = com.sun.tools.javac.main.Option.MULTIRELEASE.primaryName;
526         if (fileManager.isSupportedOption(mr) == 1) {
527             Target target = Target.instance(context);
528             List&lt;String&gt; list = List.of(target.multiReleaseValue());
529             fileManager.handleOption(mr, list.iterator());
530         }
531         options.compilerOptions().notifyListeners();
532 
533         if (options.modules().isEmpty()) {
534             if (options.subpackages().isEmpty()) {
535                 if (javaNames.isEmpty() &amp;&amp; isEmpty(fileObjects)) {
536                     String text = messager.getText(&quot;main.No_modules_packages_or_classes_specified&quot;);
537                     throw new ToolException(CMDERR, text);
538                 }
539             }
540         }
541 
542         JavadocTool comp = JavadocTool.make0(context);
543         if (comp == null) return ABNORMAL;
544 
545         DocletEnvironment docEnv = comp.getEnvironment(options, javaNames, fileObjects);
546 
547         // release resources
548         comp = null;
549 
550         if (options.breakIterator() || !locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) {
551             JavacTrees trees = JavacTrees.instance(context);
552             trees.setBreakIterator(BreakIterator.getSentenceInstance(locale));
553         }
554         // pass off control to the doclet
555         Result returnStatus = docEnv != null &amp;&amp; doclet.run(docEnv)
556                 ? OK
557                 : ERROR;
558 
559         // We&#39;re done.
560         if (options.verbose()) {
561             long elapsedMillis = (System.nanoTime() - startNanos) / 1_000_000;
562             messager.notice(&quot;main.done_in&quot;, Long.toString(elapsedMillis));
563         }
564 
565         return returnStatus;
566     }
567 
568     boolean matches(List&lt;String&gt; names, String arg) {
569         for (String name : names) {
570             if (StringUtils.toLowerCase(name).equals(StringUtils.toLowerCase(arg)))
571                 return true;
572         }
573         return false;
574     }
575 
576     boolean matches(Doclet.Option option, String arg) {
577         if (matches(option.getNames(), arg))
578              return true;
579         int sep = arg.indexOf(&#39;:&#39;);
580         String targ = arg.substring(0, sep + 1);
581         return matches(option.getNames(), targ);
582     }
583 
584     private Set&lt;? extends Doclet.Option&gt; docletOptions = null;
585 
586     /*
587      * Consumes an option along with its arguments. Returns an advanced index
588      * modulo the sign. If the value is negative, it means there was a failure
589      * processing one or more options.
590      */
591     int consumeDocletOption(int idx, List&lt;String&gt; args, boolean isToolOption) throws OptionException {
592         if (docletOptions == null) {
593             docletOptions = getSupportedOptionsOf(doclet);
594         }
595         String arg = args.get(idx);
596         String argBase, argVal;
597         if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
598             int sep = arg.indexOf(&quot;=&quot;);
599             argBase = arg.substring(0, sep);
600             argVal = arg.substring(sep + 1);
601         } else {
602             argBase = arg;
603             argVal = null;
604         }
605         int m = 1;
606         String text = null;
607         for (Doclet.Option opt : docletOptions) {
608             if (matches(opt, argBase)) {
609                 if (argVal != null) {
610                     switch (opt.getArgumentCount()) {
611                         case 0:
612                             text = messager.getText(&quot;main.unnecessary_arg_provided&quot;, argBase);
613                             throw new OptionException(ERROR, this::showUsage, text);
614                         case 1:
615                             if (!opt.process(arg, Collections.singletonList(argVal))) {
616                                 m = -1;
617                             }
618                             break;
619                         default:
620                             text = messager.getText(&quot;main.only_one_argument_with_equals&quot;, argBase);
621                             throw new OptionException(ERROR, this::showUsage, text);
622                     }
623                 } else {
624                     if (args.size() - idx - 1 &lt; opt.getArgumentCount()) {
625                         text = messager.getText(&quot;main.requires_argument&quot;, arg);
626                         throw new OptionException(ERROR, this::showUsage, text);
627                     }
628                     if (!opt.process(arg, args.subList(idx + 1, idx + 1 + opt.getArgumentCount()))) {
629                         m = -1;
630                     }
631                     idx += opt.getArgumentCount();
632                 }
633                 return m * idx;
634             }
635         }
636         // check if arg is accepted by the tool before emitting error
637         if (!isToolOption) {
638             text = messager.getText(&quot;main.invalid_flag&quot;, arg);
639             throw new OptionException(ERROR, this::showUsage, text);
640         }
641         return m * idx;
642     }
643 
644     private static Set&lt;? extends Option&gt; getSupportedOptionsOf(Doclet doclet) {
645         Set&lt;? extends Option&gt; options = doclet.getSupportedOptions();
646         return options == null ? Set.of() : options;
647     }
648 
649     /**
650      * Performs an initial pass over the options, primarily to determine
651      * the doclet to be used (if any), so that it may participate in the
652      * main round of option decoding. This avoids having to specify that
653      * the options to specify the doclet should appear before any options
654      * that are handled by the doclet.
655      *
656      * The downside of this initial phase is that we have to skip over
657      * unknown options, and assume that we can reliably detect the options
658      * we need to handle.
659      *
660      * @param argv the arguments to be processed
661      * @return the doclet
662      * @throws ToolException if an error occurs initializing the doclet
663      * @throws OptionException if an error occurs while processing an option
664      */
665     private Doclet preprocess(List&lt;String&gt; argv) throws ToolException, OptionException {
666         // doclet specifying arguments
667         String userDocletPath = null;
668         String userDocletName = null;
669 
670         // Step 1: loop through the args, set locale early on, if found.
671         for (int i = 0; i &lt; argv.size(); i++) {
672             String arg = argv.get(i);
673             if (arg.equals(ToolOptions.DUMP_ON_ERROR)) {
674                 // although this option is not needed in order to initialize the doclet,
675                 // it is helpful if it is set before trying to initialize the doclet
676                 options.setDumpOnError(true);
677             } else if (arg.equals(ToolOptions.LOCALE)) {
678                 checkOneArg(argv, i++);
679                 String lname = argv.get(i);
680                 locale = getLocale(lname);
681             } else if (arg.equals(ToolOptions.DOCLET)) {
682                 checkOneArg(argv, i++);
683                 if (userDocletName != null) {
684                     if (apiMode) {
685                         throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
686                                 userDocletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
687                     }
688                     String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
689                             userDocletName, argv.get(i));
690                     throw new ToolException(CMDERR, text);
691                 }
692                 if (docletName != null) {
693                     if (apiMode) {
694                         throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
695                                 docletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
696                     }
697                     String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
698                             docletName, argv.get(i));
699                     throw new ToolException(CMDERR, text);
700                 }
701                 userDocletName = argv.get(i);
702             } else if (arg.equals(ToolOptions.DOCLET_PATH)) {
703                 checkOneArg(argv, i++);
704                 if (userDocletPath == null) {
705                     userDocletPath = argv.get(i);
706                 } else {
707                     userDocletPath += File.pathSeparator + argv.get(i);
708                 }
709             }
710         }
711 
712         // Step 3: doclet name specified ? if so find a ClassLoader,
713         // and load it.
714         if (docletClass == null) {
715             if (userDocletName != null) {
716                 ClassLoader cl = classLoader;
717                 if (cl == null) {
718                     if (!fileManager.hasLocation(DOCLET_PATH)) {
719                         List&lt;File&gt; paths = new ArrayList&lt;&gt;();
720                         if (userDocletPath != null) {
721                             for (String pathname : userDocletPath.split(File.pathSeparator)) {
722                                 paths.add(new File(pathname));
723                             }
724                         }
725                         try {
726                             ((StandardJavaFileManager)fileManager).setLocation(DOCLET_PATH, paths);
727                         } catch (IOException ioe) {
728                             if (apiMode) {
729                                 throw new IllegalArgumentException(&quot;Could not set location for &quot; +
730                                         userDocletPath, ioe);
731                             }
732                             String text = messager.getText(&quot;main.doclet_could_not_set_location&quot;,
733                                     userDocletPath);
734                             throw new ToolException(CMDERR, text, ioe);
735                         }
736                     }
737                     cl = fileManager.getClassLoader(DOCLET_PATH);
738                     if (cl == null) {
739                         // despite doclet specified on cmdline no classloader found!
740                         if (apiMode) {
741                             throw new IllegalArgumentException(&quot;Could not obtain classloader to load &quot;
742 
743                                     + userDocletPath);
744                         }
745                         String text = messager.getText(&quot;main.doclet_no_classloader_found&quot;,
746                                 userDocletName);
747                         throw new ToolException(CMDERR, text);
748                     }
749                 }
750                 docletClass = loadDocletClass(userDocletName, cl);
751             } else if (docletName != null){
752                 docletClass = loadDocletClass(docletName, getClass().getClassLoader());
753             } else {
754                 docletClass = StandardDoclet.class;
755             }
756         }
757 
758         if (Doclet.class.isAssignableFrom(docletClass)) {
759             messager.setLocale(Locale.getDefault());  // use default locale for console messages
760             try {
761                 Object o = docletClass.getConstructor().newInstance();
762                 doclet = (Doclet) o;
763             } catch (ReflectiveOperationException exc) {
764                 if (apiMode) {
765                     throw new ClientCodeException(exc);
766                 }
767                 String text = messager.getText(&quot;main.could_not_instantiate_class&quot;, docletClass.getName());
768                 throw new ToolException(ERROR, text);
769             }
770         } else {
771             String text = messager.getText(&quot;main.not_a_doclet&quot;, docletClass.getName());
772             throw new ToolException(ERROR, text);
773         }
774         return doclet;
775     }
776 
777     private Class&lt;?&gt; loadDocletClass(String docletName, ClassLoader classLoader) throws ToolException {
778         try {
779             return classLoader == null ? Class.forName(docletName) : classLoader.loadClass(docletName);
780         } catch (ClassNotFoundException cnfe) {
781             if (apiMode) {
782                 throw new IllegalArgumentException(&quot;Cannot find doclet class &quot; + docletName);
783             }
784             String text = messager.getText(&quot;main.doclet_class_not_found&quot;, docletName);
785             throw new ToolException(CMDERR, text, cnfe);
786         }
787     }
788 
789     private boolean parseArgs(List&lt;String&gt; args, List&lt;String&gt; javaNames)
790             throws OptionException, com.sun.tools.javac.main.Option.InvalidValueException
791     {
792         boolean success = true;
793         for (int i = 0; i &lt; args.size(); i++) {
794             String arg = args.get(i);
795             ToolOption o = options.getOption(arg);
796             if (o != null) {
797                 // handle a doclet argument that may be needed however
798                 // don&#39;t increment the index, and allow the tool to consume args
799                 if (consumeDocletOption(i, args, true) &lt; 0) {
800                     success = false;
801                 }
802                 if (o.hasArg) {
803                     if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
804                         o.process(arg.substring(arg.indexOf(&#39;=&#39;) + 1));
805                     } else {
806                         checkOneArg(args, i++);
807                         o.process(args.get(i));
808                     }
809                 } else if (o.hasSuffix) {
810                     o.process(arg);
811                 } else {
812                     o.process();
813                 }
814             } else if (arg.startsWith(&quot;-XD&quot;)) {
815                 // hidden javac options
816                 String s = arg.substring(&quot;-XD&quot;.length());
817                 int eq = s.indexOf(&#39;=&#39;);
818                 String key = (eq &lt; 0) ? s : s.substring(0, eq);
819                 String value = (eq &lt; 0) ? s : s.substring(eq + 1);
820                 options.compilerOptions().put(key, value);
821             } else if (arg.startsWith(&quot;-&quot;)) {
822                 i = consumeDocletOption(i, args, false);
823                 if (i &lt; 0) {
824                     i = -i;
825                     success = false;
826                 }
827             } else {
828                 javaNames.add(arg);
829             }
830         }
831         return success;
832     }
833 
834     private &lt;T&gt; boolean isEmpty(Iterable&lt;T&gt; iter) {
835         return !iter.iterator().hasNext();
836     }
837 
838     /**
839      * Check the one arg option.
840      * Error and exit if one argument is not provided.
841      */
842     private void checkOneArg(List&lt;String&gt; args, int index) throws OptionException {
843         if ((index + 1) &gt;= args.size() || args.get(index + 1).startsWith(&quot;-d&quot;)) {
844             String text = messager.getText(&quot;main.requires_argument&quot;, args.get(index));
845             throw new OptionException(CMDERR, this::showUsage, text);
846         }
847     }
848 
849     void error(String key, Object... args) {
850         messager.printErrorUsingKey(key, args);
851     }
852 
853     /**
854      * Get the locale if specified on the command line
855      * else return null and if locale option is not used
856      * then return default locale.
857      */
858     private Locale getLocale(String localeName) throws ToolException {
859         try {
860             // Tolerate, at least for a while, the older syntax accepted by javadoc,
861             // using _ as the separator
862             localeName = localeName.replace(&quot;_&quot;, &quot;-&quot;);
863             Locale l =  new Locale.Builder().setLanguageTag(localeName).build();
864             // Ensure that a non-empty language is available for the &lt;HTML lang=...&gt; element
865             return (l.getLanguage().isEmpty()) ? Locale.ENGLISH : l;
866         } catch (IllformedLocaleException e) {
867             String text = messager.getText(&quot;main.malformed_locale_name&quot;, localeName);
868             throw new ToolException(CMDERR, text);
869         }
870     }
871 
872 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
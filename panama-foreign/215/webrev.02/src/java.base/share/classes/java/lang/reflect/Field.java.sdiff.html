<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibleObject.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Field.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55  * @see java.lang.Class
  56  * @see java.lang.Class#getFields()
  57  * @see java.lang.Class#getField(String)
  58  * @see java.lang.Class#getDeclaredFields()
  59  * @see java.lang.Class#getDeclaredField(String)
  60  *
  61  * @author Kenneth Russell
  62  * @author Nakul Saraiya
  63  * @since 1.1
  64  */
  65 public final
  66 class Field extends AccessibleObject implements Member {
  67 
  68     private Class&lt;?&gt;            clazz;
  69     private int                 slot;
  70     // This is guaranteed to be interned by the VM in the 1.4
  71     // reflection implementation
  72     private String              name;
  73     private Class&lt;?&gt;            type;
  74     private int                 modifiers;

  75     // Generics and annotations support
  76     private transient String    signature;
  77     // generic info repository; lazily initialized
  78     private transient FieldRepository genericInfo;
  79     private byte[]              annotations;
  80     // Cached field accessor created without override
  81     private FieldAccessor fieldAccessor;
  82     // Cached field accessor created with override
  83     private FieldAccessor overrideFieldAccessor;
  84     // For sharing of FieldAccessors. This branching structure is
  85     // currently only two levels deep (i.e., one root Field and
  86     // potentially many Field objects pointing to it.)
  87     //
  88     // If this branching structure would ever contain cycles, deadlocks can
  89     // occur in annotation code.
  90     private Field               root;
  91 
  92     // Generics infrastructure
  93 
  94     private String getGenericSignature() {return signature;}
</pre>
<hr />
<pre>
 102 
 103     // Accessor for generic info repository
 104     private FieldRepository getGenericInfo() {
 105         // lazily initialize repository if necessary
 106         if (genericInfo == null) {
 107             // create and cache generic info repository
 108             genericInfo = FieldRepository.make(getGenericSignature(),
 109                                                getFactory());
 110         }
 111         return genericInfo; //return cached repository
 112     }
 113 
 114 
 115     /**
 116      * Package-private constructor
 117      */
 118     Field(Class&lt;?&gt; declaringClass,
 119           String name,
 120           Class&lt;?&gt; type,
 121           int modifiers,

 122           int slot,
 123           String signature,
 124           byte[] annotations)
 125     {
 126         this.clazz = declaringClass;
 127         this.name = name;
 128         this.type = type;
 129         this.modifiers = modifiers;

 130         this.slot = slot;
 131         this.signature = signature;
 132         this.annotations = annotations;
 133     }
 134 
 135     /**
 136      * Package-private routine (exposed to java.lang.Class via
 137      * ReflectAccess) which returns a copy of this Field. The copy&#39;s
 138      * &quot;root&quot; field points to this Field.
 139      */
 140     Field copy() {
 141         // This routine enables sharing of FieldAccessor objects
 142         // among Field objects which refer to the same underlying
 143         // method in the VM. (All of this contortion is only necessary
 144         // because of the &quot;accessibility&quot; bit in AccessibleObject,
 145         // which implicitly requires that new java.lang.reflect
 146         // objects be fabricated for each reflective call on Class
 147         // objects.)
 148         if (this.root != null)
 149             throw new IllegalArgumentException(&quot;Can not copy a non-root Field&quot;);
 150 
<span class="line-modified"> 151         Field res = new Field(clazz, name, type, modifiers, slot, signature, annotations);</span>
 152         res.root = this;
 153         // Might as well eagerly propagate this if already present
 154         res.fieldAccessor = fieldAccessor;
 155         res.overrideFieldAccessor = overrideFieldAccessor;
 156 
 157         return res;
 158     }
 159 
 160     /**
 161      * @throws InaccessibleObjectException {@inheritDoc}
 162      * @throws SecurityException {@inheritDoc}
 163      */
 164     @Override
 165     @CallerSensitive
 166     public void setAccessible(boolean flag) {
 167         AccessibleObject.checkPermission();
 168         if (flag) checkCanSetAccessible(Reflection.getCallerClass());
 169         setAccessible0(flag);
 170     }
 171 
</pre>
<hr />
<pre>
 711      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 712      * ignored; it may be null.
 713      *
 714      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 715      * specified object argument is null, the method throws a
 716      * {@code NullPointerException}.  If the specified object argument is not
 717      * an instance of the class or interface declaring the underlying
 718      * field, the method throws an {@code IllegalArgumentException}.
 719      *
 720      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 721      * the underlying field is inaccessible, the method throws an
 722      * {@code IllegalAccessException}.
 723      *
 724      * &lt;p&gt;If the underlying field is final, this {@code Field} object has
 725      * &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:
 726      * &lt;ul&gt;
 727      * &lt;li&gt;{@link #setAccessible(boolean) setAccessible(true)} has succeeded for
 728      *     this {@code Field} object;&lt;/li&gt;
 729      * &lt;li&gt;the field is non-static; and&lt;/li&gt;
 730      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isHidden()
<span class="line-modified"> 731      *     hidden class}.&lt;/li&gt;</span>


 732      * &lt;/ul&gt;
 733      * If any of the above checks is not met, this method throws an
 734      * {@code IllegalAccessException}.
 735      *
 736      * &lt;p&gt; Setting a final field in this way
 737      * is meaningful only during deserialization or reconstruction of
 738      * instances of classes with blank final fields, before they are
 739      * made available for access by other parts of a program. Use in
 740      * any other context may have unpredictable effects, including cases
 741      * in which other parts of a program continue to use the original
 742      * value of this field.
 743      *
 744      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 745      * conversion is attempted to convert the new value to a value of
 746      * a primitive type.  If this attempt fails, the method throws an
 747      * {@code IllegalArgumentException}.
 748      *
 749      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 750      * converted to the type of the underlying field by an identity or
 751      * widening conversion, the method throws an
</pre>
<hr />
<pre>
1128     // Returns FieldAccessor for this Field object, not looking up
1129     // the chain to the root
1130     private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {
1131         return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;
1132     }
1133 
1134     // Sets the FieldAccessor for this Field object and
1135     // (recursively) its root
1136     private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {
1137         if (overrideFinalCheck)
1138             overrideFieldAccessor = accessor;
1139         else
1140             fieldAccessor = accessor;
1141         // Propagate up
1142         if (root != null) {
1143             root.setFieldAccessor(accessor, overrideFinalCheck);
1144         }
1145     }
1146 
1147     @Override
<span class="line-modified">1148     Field getRoot() {</span>
1149         return root;
1150     }
1151 




1152     /**
1153      * {@inheritDoc}
1154      *
1155      * @throws NullPointerException {@inheritDoc}
1156      * @since 1.5
1157      */
1158     @Override
1159     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
1160         Objects.requireNonNull(annotationClass);
1161         return annotationClass.cast(declaredAnnotations().get(annotationClass));
1162     }
1163 
1164     /**
1165      * {@inheritDoc}
1166      *
1167      * @throws NullPointerException {@inheritDoc}
1168      * @since 1.8
1169      */
1170     @Override
1171     public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
</pre>
</td>
<td>
<hr />
<pre>
  55  * @see java.lang.Class
  56  * @see java.lang.Class#getFields()
  57  * @see java.lang.Class#getField(String)
  58  * @see java.lang.Class#getDeclaredFields()
  59  * @see java.lang.Class#getDeclaredField(String)
  60  *
  61  * @author Kenneth Russell
  62  * @author Nakul Saraiya
  63  * @since 1.1
  64  */
  65 public final
  66 class Field extends AccessibleObject implements Member {
  67 
  68     private Class&lt;?&gt;            clazz;
  69     private int                 slot;
  70     // This is guaranteed to be interned by the VM in the 1.4
  71     // reflection implementation
  72     private String              name;
  73     private Class&lt;?&gt;            type;
  74     private int                 modifiers;
<span class="line-added">  75     private boolean             trustedFinal;</span>
  76     // Generics and annotations support
  77     private transient String    signature;
  78     // generic info repository; lazily initialized
  79     private transient FieldRepository genericInfo;
  80     private byte[]              annotations;
  81     // Cached field accessor created without override
  82     private FieldAccessor fieldAccessor;
  83     // Cached field accessor created with override
  84     private FieldAccessor overrideFieldAccessor;
  85     // For sharing of FieldAccessors. This branching structure is
  86     // currently only two levels deep (i.e., one root Field and
  87     // potentially many Field objects pointing to it.)
  88     //
  89     // If this branching structure would ever contain cycles, deadlocks can
  90     // occur in annotation code.
  91     private Field               root;
  92 
  93     // Generics infrastructure
  94 
  95     private String getGenericSignature() {return signature;}
</pre>
<hr />
<pre>
 103 
 104     // Accessor for generic info repository
 105     private FieldRepository getGenericInfo() {
 106         // lazily initialize repository if necessary
 107         if (genericInfo == null) {
 108             // create and cache generic info repository
 109             genericInfo = FieldRepository.make(getGenericSignature(),
 110                                                getFactory());
 111         }
 112         return genericInfo; //return cached repository
 113     }
 114 
 115 
 116     /**
 117      * Package-private constructor
 118      */
 119     Field(Class&lt;?&gt; declaringClass,
 120           String name,
 121           Class&lt;?&gt; type,
 122           int modifiers,
<span class="line-added"> 123           boolean trustedFinal,</span>
 124           int slot,
 125           String signature,
 126           byte[] annotations)
 127     {
 128         this.clazz = declaringClass;
 129         this.name = name;
 130         this.type = type;
 131         this.modifiers = modifiers;
<span class="line-added"> 132         this.trustedFinal = trustedFinal;</span>
 133         this.slot = slot;
 134         this.signature = signature;
 135         this.annotations = annotations;
 136     }
 137 
 138     /**
 139      * Package-private routine (exposed to java.lang.Class via
 140      * ReflectAccess) which returns a copy of this Field. The copy&#39;s
 141      * &quot;root&quot; field points to this Field.
 142      */
 143     Field copy() {
 144         // This routine enables sharing of FieldAccessor objects
 145         // among Field objects which refer to the same underlying
 146         // method in the VM. (All of this contortion is only necessary
 147         // because of the &quot;accessibility&quot; bit in AccessibleObject,
 148         // which implicitly requires that new java.lang.reflect
 149         // objects be fabricated for each reflective call on Class
 150         // objects.)
 151         if (this.root != null)
 152             throw new IllegalArgumentException(&quot;Can not copy a non-root Field&quot;);
 153 
<span class="line-modified"> 154         Field res = new Field(clazz, name, type, modifiers, trustedFinal, slot, signature, annotations);</span>
 155         res.root = this;
 156         // Might as well eagerly propagate this if already present
 157         res.fieldAccessor = fieldAccessor;
 158         res.overrideFieldAccessor = overrideFieldAccessor;
 159 
 160         return res;
 161     }
 162 
 163     /**
 164      * @throws InaccessibleObjectException {@inheritDoc}
 165      * @throws SecurityException {@inheritDoc}
 166      */
 167     @Override
 168     @CallerSensitive
 169     public void setAccessible(boolean flag) {
 170         AccessibleObject.checkPermission();
 171         if (flag) checkCanSetAccessible(Reflection.getCallerClass());
 172         setAccessible0(flag);
 173     }
 174 
</pre>
<hr />
<pre>
 714      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 715      * ignored; it may be null.
 716      *
 717      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 718      * specified object argument is null, the method throws a
 719      * {@code NullPointerException}.  If the specified object argument is not
 720      * an instance of the class or interface declaring the underlying
 721      * field, the method throws an {@code IllegalArgumentException}.
 722      *
 723      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 724      * the underlying field is inaccessible, the method throws an
 725      * {@code IllegalAccessException}.
 726      *
 727      * &lt;p&gt;If the underlying field is final, this {@code Field} object has
 728      * &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:
 729      * &lt;ul&gt;
 730      * &lt;li&gt;{@link #setAccessible(boolean) setAccessible(true)} has succeeded for
 731      *     this {@code Field} object;&lt;/li&gt;
 732      * &lt;li&gt;the field is non-static; and&lt;/li&gt;
 733      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isHidden()
<span class="line-modified"> 734      *     hidden class}; and&lt;/li&gt;</span>
<span class="line-added"> 735      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isRecord()</span>
<span class="line-added"> 736      *     record class}.&lt;/li&gt;</span>
 737      * &lt;/ul&gt;
 738      * If any of the above checks is not met, this method throws an
 739      * {@code IllegalAccessException}.
 740      *
 741      * &lt;p&gt; Setting a final field in this way
 742      * is meaningful only during deserialization or reconstruction of
 743      * instances of classes with blank final fields, before they are
 744      * made available for access by other parts of a program. Use in
 745      * any other context may have unpredictable effects, including cases
 746      * in which other parts of a program continue to use the original
 747      * value of this field.
 748      *
 749      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 750      * conversion is attempted to convert the new value to a value of
 751      * a primitive type.  If this attempt fails, the method throws an
 752      * {@code IllegalArgumentException}.
 753      *
 754      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 755      * converted to the type of the underlying field by an identity or
 756      * widening conversion, the method throws an
</pre>
<hr />
<pre>
1133     // Returns FieldAccessor for this Field object, not looking up
1134     // the chain to the root
1135     private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {
1136         return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;
1137     }
1138 
1139     // Sets the FieldAccessor for this Field object and
1140     // (recursively) its root
1141     private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {
1142         if (overrideFinalCheck)
1143             overrideFieldAccessor = accessor;
1144         else
1145             fieldAccessor = accessor;
1146         // Propagate up
1147         if (root != null) {
1148             root.setFieldAccessor(accessor, overrideFinalCheck);
1149         }
1150     }
1151 
1152     @Override
<span class="line-modified">1153     /* package-private */ Field getRoot() {</span>
1154         return root;
1155     }
1156 
<span class="line-added">1157     /* package-private */ boolean isTrustedFinal() {</span>
<span class="line-added">1158         return trustedFinal;</span>
<span class="line-added">1159     }</span>
<span class="line-added">1160 </span>
1161     /**
1162      * {@inheritDoc}
1163      *
1164      * @throws NullPointerException {@inheritDoc}
1165      * @since 1.5
1166      */
1167     @Override
1168     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
1169         Objects.requireNonNull(annotationClass);
1170         return annotationClass.cast(declaredAnnotations().get(annotationClass));
1171     }
1172 
1173     /**
1174      * {@inheritDoc}
1175      *
1176      * @throws NullPointerException {@inheritDoc}
1177      * @since 1.8
1178      */
1179     @Override
1180     public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
</pre>
</td>
</tr>
</table>
<center><a href="AccessibleObject.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ReflectAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
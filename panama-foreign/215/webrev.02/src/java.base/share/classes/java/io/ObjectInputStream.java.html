<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/io/ObjectInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.io;
  27 
  28 import java.io.ObjectStreamClass.WeakClassKey;
  29 import java.io.ObjectStreamClass.RecordSupport;
  30 import java.lang.System.Logger;
  31 import java.lang.invoke.MethodHandle;
  32 import java.lang.ref.ReferenceQueue;
  33 import java.lang.reflect.Array;
  34 import java.lang.reflect.Modifier;
  35 import java.lang.reflect.Proxy;
  36 import java.security.AccessControlContext;
  37 import java.security.AccessController;
  38 import java.security.PrivilegedAction;
  39 import java.security.PrivilegedActionException;
  40 import java.security.PrivilegedExceptionAction;
  41 import java.util.Arrays;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 import java.util.concurrent.ConcurrentMap;
  46 
  47 import static java.io.ObjectStreamClass.processQueue;
  48 
  49 import jdk.internal.access.SharedSecrets;
  50 import jdk.internal.misc.Unsafe;
  51 import sun.reflect.misc.ReflectUtil;
  52 
  53 /**
  54  * An ObjectInputStream deserializes primitive data and objects previously
  55  * written using an ObjectOutputStream.
  56  *
  57  * &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
  58  * and should be avoided. Untrusted data should be carefully validated according to the
  59  * &quot;Serialization and Deserialization&quot; section of the
  60  * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
  61  * {@extLink serialization_filter_guide Serialization Filtering} describes best
  62  * practices for defensive use of serial filters.
  63  * &lt;/strong&gt;&lt;/p&gt;
  64  *
  65  * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
  66  * persistent storage for graphs of objects when used with a FileOutputStream
  67  * and FileInputStream respectively.  ObjectInputStream is used to recover
  68  * those objects previously serialized. Other uses include passing objects
  69  * between hosts using a socket stream or for marshaling and unmarshaling
  70  * arguments and parameters in a remote communication system.
  71  *
  72  * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
  73  * created from the stream match the classes present in the Java Virtual
  74  * Machine.  Classes are loaded as required using the standard mechanisms.
  75  *
  76  * &lt;p&gt;Only objects that support the java.io.Serializable or
  77  * java.io.Externalizable interface can be read from streams.
  78  *
  79  * &lt;p&gt;The method {@code readObject} is used to read an object from the
  80  * stream.  Java&#39;s safe casting should be used to get the desired type.  In
  81  * Java, strings and arrays are objects and are treated as objects during
  82  * serialization. When read they need to be cast to the expected type.
  83  *
  84  * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
  85  * method on DataInput.
  86  *
  87  * &lt;p&gt;The default deserialization mechanism for objects restores the contents
  88  * of each field to the value and type it had when it was written.  Fields
  89  * declared as transient or static are ignored by the deserialization process.
  90  * References to other objects cause those objects to be read from the stream
  91  * as necessary.  Graphs of objects are restored correctly using a reference
  92  * sharing mechanism.  New objects are always allocated when deserializing,
  93  * which prevents existing objects from being overwritten.
  94  *
  95  * &lt;p&gt;Reading an object is analogous to running the constructors of a new
  96  * object.  Memory is allocated for the object and initialized to zero (NULL).
  97  * No-arg constructors are invoked for the non-serializable classes and then
  98  * the fields of the serializable classes are restored from the stream starting
  99  * with the serializable class closest to java.lang.object and finishing with
 100  * the object&#39;s most specific class.
 101  *
 102  * &lt;p&gt;For example to read from a stream as written by the example in
 103  * ObjectOutputStream:
 104  * &lt;br&gt;
 105  * &lt;pre&gt;
 106  *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
 107  *      ObjectInputStream ois = new ObjectInputStream(fis);
 108  *
 109  *      int i = ois.readInt();
 110  *      String today = (String) ois.readObject();
 111  *      Date date = (Date) ois.readObject();
 112  *
 113  *      ois.close();
 114  * &lt;/pre&gt;
 115  *
 116  * &lt;p&gt;Classes control how they are serialized by implementing either the
 117  * java.io.Serializable or java.io.Externalizable interfaces.
 118  *
 119  * &lt;p&gt;Implementing the Serializable interface allows object serialization to
 120  * save and restore the entire state of the object and it allows classes to
 121  * evolve between the time the stream is written and the time it is read.  It
 122  * automatically traverses references between objects, saving and restoring
 123  * entire graphs.
 124  *
 125  * &lt;p&gt;Serializable classes that require special handling during the
 126  * serialization and deserialization process should implement the following
 127  * methods:
 128  *
 129  * &lt;pre&gt;
 130  * private void writeObject(java.io.ObjectOutputStream stream)
 131  *     throws IOException;
 132  * private void readObject(java.io.ObjectInputStream stream)
 133  *     throws IOException, ClassNotFoundException;
 134  * private void readObjectNoData()
 135  *     throws ObjectStreamException;
 136  * &lt;/pre&gt;
 137  *
 138  * &lt;p&gt;The readObject method is responsible for reading and restoring the state
 139  * of the object for its particular class using data written to the stream by
 140  * the corresponding writeObject method.  The method does not need to concern
 141  * itself with the state belonging to its superclasses or subclasses.  State is
 142  * restored by reading data from the ObjectInputStream for the individual
 143  * fields and making assignments to the appropriate fields of the object.
 144  * Reading primitive data types is supported by DataInput.
 145  *
 146  * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
 147  * custom data written by the corresponding writeObject method will cause an
 148  * OptionalDataException to be thrown with an eof field value of true.
 149  * Non-object reads which exceed the end of the allotted data will reflect the
 150  * end of data in the same way that they would indicate the end of the stream:
 151  * bytewise reads will return -1 as the byte read or number of bytes read, and
 152  * primitive reads will throw EOFExceptions.  If there is no corresponding
 153  * writeObject method, then the end of default serialized data marks the end of
 154  * the allotted data.
 155  *
 156  * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
 157  * behave in the same manner--if the stream is already positioned at the end of
 158  * data written by the corresponding writeExternal method, object reads will
 159  * throw OptionalDataExceptions with eof set to true, bytewise reads will
 160  * return -1, and primitive reads will throw EOFExceptions.  Note that this
 161  * behavior does not hold for streams written with the old
 162  * {@code ObjectStreamConstants.PROTOCOL_VERSION_1} protocol, in which the
 163  * end of data written by writeExternal methods is not demarcated, and hence
 164  * cannot be detected.
 165  *
 166  * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
 167  * the object for its particular class in the event that the serialization
 168  * stream does not list the given class as a superclass of the object being
 169  * deserialized.  This may occur in cases where the receiving party uses a
 170  * different version of the deserialized instance&#39;s class than the sending
 171  * party, and the receiver&#39;s version extends classes that are not extended by
 172  * the sender&#39;s version.  This may also occur if the serialization stream has
 173  * been tampered; hence, readObjectNoData is useful for initializing
 174  * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
 175  * stream.
 176  *
 177  * &lt;p&gt;Serialization does not read or assign values to the fields of any object
 178  * that does not implement the java.io.Serializable interface.  Subclasses of
 179  * Objects that are not serializable can be serializable. In this case the
 180  * non-serializable class must have a no-arg constructor to allow its fields to
 181  * be initialized.  In this case it is the responsibility of the subclass to
 182  * save and restore the state of the non-serializable class. It is frequently
 183  * the case that the fields of that class are accessible (public, package, or
 184  * protected) or that there are get and set methods that can be used to restore
 185  * the state.
 186  *
 187  * &lt;p&gt;The contents of the stream can be filtered during deserialization.
 188  * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}
 189  * on an ObjectInputStream, the {@link ObjectInputFilter} can check that
 190  * the classes, array lengths, number of references in the stream, depth, and
 191  * number of bytes consumed from the input stream are allowed and
 192  * if not, can terminate deserialization.
 193  * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) system-wide filter}
 194  * can be configured that is applied to each {@code ObjectInputStream} unless replaced
 195  * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
 196  *
 197  * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
 198  * the ObjectInputStream and abort the reading process.
 199  *
 200  * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
 201  * complete control over the contents and format of the object&#39;s serialized
 202  * form.  The methods of the Externalizable interface, writeExternal and
 203  * readExternal, are called to save and restore the objects state.  When
 204  * implemented by a class they can write and read their own state using all of
 205  * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
 206  * the objects to handle any versioning that occurs.
 207  *
 208  * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
 209  * externalizable objects.  The serialized form of an enum constant consists
 210  * solely of its name; field values of the constant are not transmitted.  To
 211  * deserialize an enum constant, ObjectInputStream reads the constant name from
 212  * the stream; the deserialized constant is then obtained by calling the static
 213  * method {@code Enum.valueOf(Class, String)} with the enum constant&#39;s
 214  * base type and the received constant name as arguments.  Like other
 215  * serializable or externalizable objects, enum constants can function as the
 216  * targets of back references appearing subsequently in the serialization
 217  * stream.  The process by which enum constants are deserialized cannot be
 218  * customized: any class-specific readObject, readObjectNoData, and readResolve
 219  * methods defined by enum types are ignored during deserialization.
 220  * Similarly, any serialPersistentFields or serialVersionUID field declarations
 221  * are also ignored--all enum types have a fixed serialVersionUID of 0L.
 222  *
 223  * @implSpec
 224  * &lt;a id=&quot;record-serialization&quot;&gt;&lt;/a&gt;
 225  * Records are serialized differently than ordinary serializable or externalizable
 226  * objects. The serialized form of a record object is a sequence of values derived
 227  * from the record components. The stream format of a record object is the same as
 228  * that of an ordinary object in the stream. During deserialization, if the local
 229  * class equivalent of the specified stream class descriptor is a record class,
 230  * then first the stream fields are read and reconstructed to serve as the record&#39;s
 231  * component values; and second, a record object is created by invoking the
 232  * record&#39;s &lt;i&gt;canonical&lt;/i&gt; constructor with the component values as arguments (or the
 233  * default value for component&#39;s type if a component value is absent from the
 234  * stream).
 235  * Like other serializable or externalizable objects, record objects can function
 236  * as the target of back references appearing subsequently in the serialization
 237  * stream. However, a cycle in the graph where the record object is referred to,
 238  * either directly or transitively, by one of its components, is not preserved.
 239  * The record components are deserialized prior to the invocation of the record
 240  * constructor, hence this limitation (see
 241  * &lt;a href=&quot;{@docRoot}/../specs/serialization/serial-arch.html#cyclic-references&quot;&gt;
 242  * [Section 1.14, &quot;Circular References&quot;&lt;/a&gt; for additional information).
 243  * The process by which record objects are serialized or externalized cannot be
 244  * customized; any class-specific writeObject, readObject, readObjectNoData,
 245  * writeExternal, and readExternal methods defined by record classes are
 246  * ignored during serialization and deserialization. However, a substitute object
 247  * to be serialized or a designate replacement may be specified, by the
 248  * writeReplace and readResolve methods, respectively.  Any
 249  * serialPersistentFields field declaration is ignored. Documenting serializable
 250  * fields and data for record classes is unnecessary, since there is no variation
 251  * in the serial form, other than whether a substitute or replacement object is
 252  * used. The serialVersionUID of a record class is 0L unless explicitly
 253  * declared. The requirement for matching serialVersionUID values is waived for
 254  * record classes.
 255  *
 256  * @author      Mike Warres
 257  * @author      Roger Riggs
 258  * @see java.io.DataInput
 259  * @see java.io.ObjectOutputStream
 260  * @see java.io.Serializable
 261  * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/input.html&quot;&gt;
 262  *     Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;
 263  * @since   1.1
 264  */
 265 public class ObjectInputStream
 266     extends InputStream implements ObjectInput, ObjectStreamConstants
 267 {
 268     /** handle value representing null */
 269     private static final int NULL_HANDLE = -1;
 270 
 271     /** marker for unshared objects in internal handle table */
 272     private static final Object unsharedMarker = new Object();
 273 
 274     /**
 275      * immutable table mapping primitive type names to corresponding
 276      * class objects
 277      */
 278     private static final Map&lt;String, Class&lt;?&gt;&gt; primClasses =
 279         Map.of(&quot;boolean&quot;, boolean.class,
 280                &quot;byte&quot;, byte.class,
 281                &quot;char&quot;, char.class,
 282                &quot;short&quot;, short.class,
 283                &quot;int&quot;, int.class,
 284                &quot;long&quot;, long.class,
 285                &quot;float&quot;, float.class,
 286                &quot;double&quot;, double.class,
 287                &quot;void&quot;, void.class);
 288 
 289     private static class Caches {
 290         /** cache of subclass security audit results */
 291         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
 292             new ConcurrentHashMap&lt;&gt;();
 293 
 294         /** queue for WeakReferences to audited subclasses */
 295         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
 296             new ReferenceQueue&lt;&gt;();
 297     }
 298 
 299     /*
 300      * Separate class to defer initialization of logging until needed.
 301      */
 302     private static class Logging {
 303         /*
 304          * Logger for ObjectInputFilter results.
 305          * Setup the filter logger if it is set to DEBUG or TRACE.
 306          * (Assuming it will not change).
 307          */
 308         static final System.Logger filterLogger;
 309 
 310         static {
 311             Logger filterLog = System.getLogger(&quot;java.io.serialization&quot;);
 312             filterLogger = (filterLog.isLoggable(Logger.Level.DEBUG)
 313                     || filterLog.isLoggable(Logger.Level.TRACE)) ? filterLog : null;
 314         }
 315     }
 316 
 317     /** filter stream for handling block data conversion */
 318     private final BlockDataInputStream bin;
 319     /** validation callback list */
 320     private final ValidationList vlist;
 321     /** recursion depth */
 322     private long depth;
 323     /** Total number of references to any type of object, class, enum, proxy, etc. */
 324     private long totalObjectRefs;
 325     /** whether stream is closed */
 326     private boolean closed;
 327 
 328     /** wire handle -&gt; obj/exception map */
 329     private final HandleTable handles;
 330     /** scratch field for passing handle values up/down call stack */
 331     private int passHandle = NULL_HANDLE;
 332     /** flag set when at end of field value block with no TC_ENDBLOCKDATA */
 333     private boolean defaultDataEnd = false;
 334 
 335     /** if true, invoke readObjectOverride() instead of readObject() */
 336     private final boolean enableOverride;
 337     /** if true, invoke resolveObject() */
 338     private boolean enableResolve;
 339 
 340     /**
 341      * Context during upcalls to class-defined readObject methods; holds
 342      * object currently being deserialized and descriptor for current class.
 343      * Null when not during readObject upcall.
 344      */
 345     private SerialCallbackContext curContext;
 346 
 347     /**
 348      * Filter of class descriptors and classes read from the stream;
 349      * may be null.
 350      */
 351     private ObjectInputFilter serialFilter;
 352 
 353     /**
 354      * Creates an ObjectInputStream that reads from the specified InputStream.
 355      * A serialization stream header is read from the stream and verified.
 356      * This constructor will block until the corresponding ObjectOutputStream
 357      * has written and flushed the header.
 358      *
 359      * &lt;p&gt;The serialization filter is initialized to the value of
 360      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 361      *
 362      * &lt;p&gt;If a security manager is installed, this constructor will check for
 363      * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
 364      * directly or indirectly by the constructor of a subclass which overrides
 365      * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
 366      * methods.
 367      *
 368      * @param   in input stream to read from
 369      * @throws  StreamCorruptedException if the stream header is incorrect
 370      * @throws  IOException if an I/O error occurs while reading stream header
 371      * @throws  SecurityException if untrusted subclass illegally overrides
 372      *          security-sensitive methods
 373      * @throws  NullPointerException if {@code in} is {@code null}
 374      * @see     ObjectInputStream#ObjectInputStream()
 375      * @see     ObjectInputStream#readFields()
 376      * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
 377      */
 378     public ObjectInputStream(InputStream in) throws IOException {
 379         verifySubclass();
 380         bin = new BlockDataInputStream(in);
 381         handles = new HandleTable(10);
 382         vlist = new ValidationList();
 383         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 384         enableOverride = false;
 385         readStreamHeader();
 386         bin.setBlockDataMode(true);
 387     }
 388 
 389     /**
 390      * Provide a way for subclasses that are completely reimplementing
 391      * ObjectInputStream to not have to allocate private data just used by this
 392      * implementation of ObjectInputStream.
 393      *
 394      * &lt;p&gt;The serialization filter is initialized to the value of
 395      * {@linkplain ObjectInputFilter.Config#getSerialFilter() the system-wide filter}.
 396      *
 397      * &lt;p&gt;If there is a security manager installed, this method first calls the
 398      * security manager&#39;s {@code checkPermission} method with the
 399      * {@code SerializablePermission(&quot;enableSubclassImplementation&quot;)}
 400      * permission to ensure it&#39;s ok to enable subclassing.
 401      *
 402      * @throws  SecurityException if a security manager exists and its
 403      *          {@code checkPermission} method denies enabling
 404      *          subclassing.
 405      * @throws  IOException if an I/O error occurs while creating this stream
 406      * @see SecurityManager#checkPermission
 407      * @see java.io.SerializablePermission
 408      */
 409     protected ObjectInputStream() throws IOException, SecurityException {
 410         SecurityManager sm = System.getSecurityManager();
 411         if (sm != null) {
 412             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 413         }
 414         bin = null;
 415         handles = null;
 416         vlist = null;
 417         serialFilter = ObjectInputFilter.Config.getSerialFilter();
 418         enableOverride = true;
 419     }
 420 
 421     /**
 422      * Read an object from the ObjectInputStream.  The class of the object, the
 423      * signature of the class, and the values of the non-transient and
 424      * non-static fields of the class and all of its supertypes are read.
 425      * Default deserializing for a class can be overridden using the writeObject
 426      * and readObject methods.  Objects referenced by this object are read
 427      * transitively so that a complete equivalent graph of objects is
 428      * reconstructed by readObject.
 429      *
 430      * &lt;p&gt;The root object is completely restored when all of its fields and the
 431      * objects it references are completely restored.  At this point the object
 432      * validation callbacks are executed in order based on their registered
 433      * priorities. The callbacks are registered by objects (in the readObject
 434      * special methods) as they are individually restored.
 435      *
 436      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 437      * each object (regular or class) read to reconstruct the root object.
 438      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 439      *
 440      * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
 441      * classes that should not be deserialized.  All exceptions are fatal to
 442      * the InputStream and leave it in an indeterminate state; it is up to the
 443      * caller to ignore or recover the stream state.
 444      *
 445      * @throws  ClassNotFoundException Class of a serialized object cannot be
 446      *          found.
 447      * @throws  InvalidClassException Something is wrong with a class used by
 448      *          serialization.
 449      * @throws  StreamCorruptedException Control information in the
 450      *          stream is inconsistent.
 451      * @throws  OptionalDataException Primitive data was found in the
 452      *          stream instead of objects.
 453      * @throws  IOException Any of the usual Input/Output related exceptions.
 454      */
 455     public final Object readObject()
 456         throws IOException, ClassNotFoundException {
 457         return readObject(Object.class);
 458     }
 459 
 460     /**
 461      * Reads a String and only a string.
 462      *
 463      * @return  the String read
 464      * @throws  EOFException If end of file is reached.
 465      * @throws  IOException If other I/O error has occurred.
 466      */
 467     private String readString() throws IOException {
 468         try {
 469             return (String) readObject(String.class);
 470         } catch (ClassNotFoundException cnf) {
 471             throw new IllegalStateException(cnf);
 472         }
 473     }
 474 
 475     /**
 476      * Internal method to read an object from the ObjectInputStream of the expected type.
 477      * Called only from {@code readObject()} and {@code readString()}.
 478      * Only {@code Object.class} and {@code String.class} are supported.
 479      *
 480      * @param type the type expected; either Object.class or String.class
 481      * @return an object of the type
 482      * @throws  IOException Any of the usual Input/Output related exceptions.
 483      * @throws  ClassNotFoundException Class of a serialized object cannot be
 484      *          found.
 485      */
 486     private final Object readObject(Class&lt;?&gt; type)
 487         throws IOException, ClassNotFoundException
 488     {
 489         if (enableOverride) {
 490             return readObjectOverride();
 491         }
 492 
 493         if (! (type == Object.class || type == String.class))
 494             throw new AssertionError(&quot;internal error&quot;);
 495 
 496         // if nested read, passHandle contains handle of enclosing object
 497         int outerHandle = passHandle;
 498         try {
 499             Object obj = readObject0(type, false);
 500             handles.markDependency(outerHandle, passHandle);
 501             ClassNotFoundException ex = handles.lookupException(passHandle);
 502             if (ex != null) {
 503                 throw ex;
 504             }
 505             if (depth == 0) {
 506                 vlist.doCallbacks();
 507                 freeze();
 508             }
 509             return obj;
 510         } finally {
 511             passHandle = outerHandle;
 512             if (closed &amp;&amp; depth == 0) {
 513                 clear();
 514             }
 515         }
 516     }
 517 
 518     /**
 519      * This method is called by trusted subclasses of ObjectInputStream that
 520      * constructed ObjectInputStream using the protected no-arg constructor.
 521      * The subclass is expected to provide an override method with the modifier
 522      * &quot;final&quot;.
 523      *
 524      * @return  the Object read from the stream.
 525      * @throws  ClassNotFoundException Class definition of a serialized object
 526      *          cannot be found.
 527      * @throws  OptionalDataException Primitive data was found in the stream
 528      *          instead of objects.
 529      * @throws  IOException if I/O errors occurred while reading from the
 530      *          underlying stream
 531      * @see #ObjectInputStream()
 532      * @see #readObject()
 533      * @since 1.2
 534      */
 535     protected Object readObjectOverride()
 536         throws IOException, ClassNotFoundException
 537     {
 538         return null;
 539     }
 540 
 541     /**
 542      * Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
 543      * identical to readObject, except that it prevents subsequent calls to
 544      * readObject and readUnshared from returning additional references to the
 545      * deserialized instance obtained via this call.  Specifically:
 546      * &lt;ul&gt;
 547      *   &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
 548      *       stream representation of an object which has been written
 549      *       previously to the stream), an ObjectStreamException will be
 550      *       thrown.
 551      *
 552      *   &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
 553      *       to deserialize back-references to the stream handle deserialized
 554      *       by readUnshared will cause an ObjectStreamException to be thrown.
 555      * &lt;/ul&gt;
 556      * Deserializing an object via readUnshared invalidates the stream handle
 557      * associated with the returned object.  Note that this in itself does not
 558      * always guarantee that the reference returned by readUnshared is unique;
 559      * the deserialized object may define a readResolve method which returns an
 560      * object visible to other parties, or readUnshared may return a Class
 561      * object or enum constant obtainable elsewhere in the stream or through
 562      * external means. If the deserialized object defines a readResolve method
 563      * and the invocation of that method returns an array, then readUnshared
 564      * returns a shallow clone of that array; this guarantees that the returned
 565      * array object is unique and cannot be obtained a second time from an
 566      * invocation of readObject or readUnshared on the ObjectInputStream,
 567      * even if the underlying data stream has been manipulated.
 568      *
 569      * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
 570      * each object (regular or class) read to reconstruct the root object.
 571      * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
 572      *
 573      * &lt;p&gt;ObjectInputStream subclasses which override this method can only be
 574      * constructed in security contexts possessing the
 575      * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
 576      * instantiate such a subclass without this permission will cause a
 577      * SecurityException to be thrown.
 578      *
 579      * @return  reference to deserialized object
 580      * @throws  ClassNotFoundException if class of an object to deserialize
 581      *          cannot be found
 582      * @throws  StreamCorruptedException if control information in the stream
 583      *          is inconsistent
 584      * @throws  ObjectStreamException if object to deserialize has already
 585      *          appeared in stream
 586      * @throws  OptionalDataException if primitive data is next in stream
 587      * @throws  IOException if an I/O error occurs during deserialization
 588      * @since   1.4
 589      */
 590     public Object readUnshared() throws IOException, ClassNotFoundException {
 591         // if nested read, passHandle contains handle of enclosing object
 592         int outerHandle = passHandle;
 593         try {
 594             Object obj = readObject0(Object.class, true);
 595             handles.markDependency(outerHandle, passHandle);
 596             ClassNotFoundException ex = handles.lookupException(passHandle);
 597             if (ex != null) {
 598                 throw ex;
 599             }
 600             if (depth == 0) {
 601                 vlist.doCallbacks();
 602                 freeze();
 603             }
 604             return obj;
 605         } finally {
 606             passHandle = outerHandle;
 607             if (closed &amp;&amp; depth == 0) {
 608                 clear();
 609             }
 610         }
 611     }
 612 
 613     /**
 614      * Read the non-static and non-transient fields of the current class from
 615      * this stream.  This may only be called from the readObject method of the
 616      * class being deserialized. It will throw the NotActiveException if it is
 617      * called otherwise.
 618      *
 619      * @throws  ClassNotFoundException if the class of a serialized object
 620      *          could not be found.
 621      * @throws  IOException if an I/O error occurs.
 622      * @throws  NotActiveException if the stream is not currently reading
 623      *          objects.
 624      */
 625     public void defaultReadObject()
 626         throws IOException, ClassNotFoundException
 627     {
 628         SerialCallbackContext ctx = curContext;
 629         if (ctx == null) {
 630             throw new NotActiveException(&quot;not in call to readObject&quot;);
 631         }
 632         Object curObj = ctx.getObj();
 633         ObjectStreamClass curDesc = ctx.getDesc();
 634         bin.setBlockDataMode(false);
 635         FieldValues vals = defaultReadFields(curObj, curDesc);
 636         if (curObj != null) {
 637             defaultCheckFieldValues(curObj, curDesc, vals);
 638             defaultSetFieldValues(curObj, curDesc, vals);
 639         }
 640         bin.setBlockDataMode(true);
 641         if (!curDesc.hasWriteObjectData()) {
 642             /*
 643              * Fix for 4360508: since stream does not contain terminating
 644              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 645              * knows to simulate end-of-custom-data behavior.
 646              */
 647             defaultDataEnd = true;
 648         }
 649         ClassNotFoundException ex = handles.lookupException(passHandle);
 650         if (ex != null) {
 651             throw ex;
 652         }
 653     }
 654 
 655     /**
 656      * Reads the persistent fields from the stream and makes them available by
 657      * name.
 658      *
 659      * @return  the {@code GetField} object representing the persistent
 660      *          fields of the object being deserialized
 661      * @throws  ClassNotFoundException if the class of a serialized object
 662      *          could not be found.
 663      * @throws  IOException if an I/O error occurs.
 664      * @throws  NotActiveException if the stream is not currently reading
 665      *          objects.
 666      * @since 1.2
 667      */
 668     public ObjectInputStream.GetField readFields()
 669         throws IOException, ClassNotFoundException
 670     {
 671         SerialCallbackContext ctx = curContext;
 672         if (ctx == null) {
 673             throw new NotActiveException(&quot;not in call to readObject&quot;);
 674         }
 675         ctx.checkAndSetUsed();
 676         ObjectStreamClass curDesc = ctx.getDesc();
 677         bin.setBlockDataMode(false);
 678         GetFieldImpl getField = new GetFieldImpl(curDesc);
 679         getField.readFields();
 680         bin.setBlockDataMode(true);
 681         if (!curDesc.hasWriteObjectData()) {
 682             /*
 683              * Fix for 4360508: since stream does not contain terminating
 684              * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
 685              * knows to simulate end-of-custom-data behavior.
 686              */
 687             defaultDataEnd = true;
 688         }
 689 
 690         return getField;
 691     }
 692 
 693     /**
 694      * Register an object to be validated before the graph is returned.  While
 695      * similar to resolveObject these validations are called after the entire
 696      * graph has been reconstituted.  Typically, a readObject method will
 697      * register the object with the stream so that when all of the objects are
 698      * restored a final set of validations can be performed.
 699      *
 700      * @param   obj the object to receive the validation callback.
 701      * @param   prio controls the order of callbacks;zero is a good default.
 702      *          Use higher numbers to be called back earlier, lower numbers for
 703      *          later callbacks. Within a priority, callbacks are processed in
 704      *          no particular order.
 705      * @throws  NotActiveException The stream is not currently reading objects
 706      *          so it is invalid to register a callback.
 707      * @throws  InvalidObjectException The validation object is null.
 708      */
 709     public void registerValidation(ObjectInputValidation obj, int prio)
 710         throws NotActiveException, InvalidObjectException
 711     {
 712         if (depth == 0) {
 713             throw new NotActiveException(&quot;stream inactive&quot;);
 714         }
 715         vlist.register(obj, prio);
 716     }
 717 
 718     /**
 719      * Load the local class equivalent of the specified stream class
 720      * description.  Subclasses may implement this method to allow classes to
 721      * be fetched from an alternate source.
 722      *
 723      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 724      * {@code annotateClass}.  This method will be invoked only once for
 725      * each unique class in the stream.  This method can be implemented by
 726      * subclasses to use an alternate loading mechanism but must return a
 727      * {@code Class} object. Once returned, if the class is not an array
 728      * class, its serialVersionUID is compared to the serialVersionUID of the
 729      * serialized class, and if there is a mismatch, the deserialization fails
 730      * and an {@link InvalidClassException} is thrown.
 731      *
 732      * &lt;p&gt;The default implementation of this method in
 733      * {@code ObjectInputStream} returns the result of calling
 734      * &lt;pre&gt;
 735      *     Class.forName(desc.getName(), false, loader)
 736      * &lt;/pre&gt;
 737      * where {@code loader} is the first class loader on the current
 738      * thread&#39;s stack (starting from the currently executing method) that is
 739      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 740      * class loader} nor its ancestor; otherwise, {@code loader} is the
 741      * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
 742      * {@code ClassNotFoundException} and the name of the passed
 743      * {@code ObjectStreamClass} instance is the Java language keyword
 744      * for a primitive type or void, then the {@code Class} object
 745      * representing that primitive type or void will be returned
 746      * (e.g., an {@code ObjectStreamClass} with the name
 747      * {@code &quot;int&quot;} will be resolved to {@code Integer.TYPE}).
 748      * Otherwise, the {@code ClassNotFoundException} will be thrown to
 749      * the caller of this method.
 750      *
 751      * @param   desc an instance of class {@code ObjectStreamClass}
 752      * @return  a {@code Class} object corresponding to {@code desc}
 753      * @throws  IOException any of the usual Input/Output exceptions.
 754      * @throws  ClassNotFoundException if class of a serialized object cannot
 755      *          be found.
 756      */
 757     protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
 758         throws IOException, ClassNotFoundException
 759     {
 760         String name = desc.getName();
 761         try {
 762             return Class.forName(name, false, latestUserDefinedLoader());
 763         } catch (ClassNotFoundException ex) {
 764             Class&lt;?&gt; cl = primClasses.get(name);
 765             if (cl != null) {
 766                 return cl;
 767             } else {
 768                 throw ex;
 769             }
 770         }
 771     }
 772 
 773     /**
 774      * Returns a proxy class that implements the interfaces named in a proxy
 775      * class descriptor; subclasses may implement this method to read custom
 776      * data from the stream along with the descriptors for dynamic proxy
 777      * classes, allowing them to use an alternate loading mechanism for the
 778      * interfaces and the proxy class.
 779      *
 780      * &lt;p&gt;This method is called exactly once for each unique proxy class
 781      * descriptor in the stream.
 782      *
 783      * &lt;p&gt;The corresponding method in {@code ObjectOutputStream} is
 784      * {@code annotateProxyClass}.  For a given subclass of
 785      * {@code ObjectInputStream} that overrides this method, the
 786      * {@code annotateProxyClass} method in the corresponding subclass of
 787      * {@code ObjectOutputStream} must write any data or objects read by
 788      * this method.
 789      *
 790      * &lt;p&gt;The default implementation of this method in
 791      * {@code ObjectInputStream} returns the result of calling
 792      * {@code Proxy.getProxyClass} with the list of {@code Class}
 793      * objects for the interfaces that are named in the {@code interfaces}
 794      * parameter.  The {@code Class} object for each interface name
 795      * {@code i} is the value returned by calling
 796      * &lt;pre&gt;
 797      *     Class.forName(i, false, loader)
 798      * &lt;/pre&gt;
 799      * where {@code loader} is the first class loader on the current
 800      * thread&#39;s stack (starting from the currently executing method) that is
 801      * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
 802      * class loader} nor its ancestor; otherwise, {@code loader} is the
 803      * &lt;em&gt;platform class loader&lt;/em&gt;.
 804      * Unless any of the resolved interfaces are non-public, this same value
 805      * of {@code loader} is also the class loader passed to
 806      * {@code Proxy.getProxyClass}; if non-public interfaces are present,
 807      * their class loader is passed instead (if more than one non-public
 808      * interface class loader is encountered, an
 809      * {@code IllegalAccessError} is thrown).
 810      * If {@code Proxy.getProxyClass} throws an
 811      * {@code IllegalArgumentException}, {@code resolveProxyClass}
 812      * will throw a {@code ClassNotFoundException} containing the
 813      * {@code IllegalArgumentException}.
 814      *
 815      * @param interfaces the list of interface names that were
 816      *                deserialized in the proxy class descriptor
 817      * @return  a proxy class for the specified interfaces
 818      * @throws        IOException any exception thrown by the underlying
 819      *                {@code InputStream}
 820      * @throws        ClassNotFoundException if the proxy class or any of the
 821      *                named interfaces could not be found
 822      * @see ObjectOutputStream#annotateProxyClass(Class)
 823      * @since 1.3
 824      */
 825     protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
 826         throws IOException, ClassNotFoundException
 827     {
 828         ClassLoader latestLoader = latestUserDefinedLoader();
 829         ClassLoader nonPublicLoader = null;
 830         boolean hasNonPublicInterface = false;
 831 
 832         // define proxy in class loader of non-public interface(s), if any
 833         Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];
 834         for (int i = 0; i &lt; interfaces.length; i++) {
 835             Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);
 836             if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {
 837                 if (hasNonPublicInterface) {
 838                     if (nonPublicLoader != cl.getClassLoader()) {
 839                         throw new IllegalAccessError(
 840                             &quot;conflicting non-public interface class loaders&quot;);
 841                     }
 842                 } else {
 843                     nonPublicLoader = cl.getClassLoader();
 844                     hasNonPublicInterface = true;
 845                 }
 846             }
 847             classObjs[i] = cl;
 848         }
 849         try {
 850             @SuppressWarnings(&quot;deprecation&quot;)
 851             Class&lt;?&gt; proxyClass = Proxy.getProxyClass(
 852                 hasNonPublicInterface ? nonPublicLoader : latestLoader,
 853                 classObjs);
 854             return proxyClass;
 855         } catch (IllegalArgumentException e) {
 856             throw new ClassNotFoundException(null, e);
 857         }
 858     }
 859 
 860     /**
 861      * This method will allow trusted subclasses of ObjectInputStream to
 862      * substitute one object for another during deserialization. Replacing
 863      * objects is disabled until enableResolveObject is called. The
 864      * enableResolveObject method checks that the stream requesting to resolve
 865      * object can be trusted. Every reference to serializable objects is passed
 866      * to resolveObject.  To insure that the private state of objects is not
 867      * unintentionally exposed only trusted streams may use resolveObject.
 868      *
 869      * &lt;p&gt;This method is called after an object has been read but before it is
 870      * returned from readObject.  The default resolveObject method just returns
 871      * the same object.
 872      *
 873      * &lt;p&gt;When a subclass is replacing objects it must insure that the
 874      * substituted object is compatible with every field where the reference
 875      * will be stored.  Objects whose type is not a subclass of the type of the
 876      * field or array element abort the serialization by raising an exception
 877      * and the object is not be stored.
 878      *
 879      * &lt;p&gt;This method is called only once when each object is first
 880      * encountered.  All subsequent references to the object will be redirected
 881      * to the new object.
 882      *
 883      * @param   obj object to be substituted
 884      * @return  the substituted object
 885      * @throws  IOException Any of the usual Input/Output exceptions.
 886      */
 887     protected Object resolveObject(Object obj) throws IOException {
 888         return obj;
 889     }
 890 
 891     /**
 892      * Enables the stream to do replacement of objects read from the stream. When
 893      * enabled, the {@link #resolveObject} method is called for every object being
 894      * deserialized.
 895      *
 896      * &lt;p&gt;If object replacement is currently not enabled, and
 897      * {@code enable} is true, and there is a security manager installed,
 898      * this method first calls the security manager&#39;s
 899      * {@code checkPermission} method with the
 900      * {@code SerializablePermission(&quot;enableSubstitution&quot;)} permission to
 901      * ensure that the caller is permitted to enable the stream to do replacement
 902      * of objects read from the stream.
 903      *
 904      * @param   enable true for enabling use of {@code resolveObject} for
 905      *          every object being deserialized
 906      * @return  the previous setting before this method was invoked
 907      * @throws  SecurityException if a security manager exists and its
 908      *          {@code checkPermission} method denies enabling the stream
 909      *          to do replacement of objects read from the stream.
 910      * @see SecurityManager#checkPermission
 911      * @see java.io.SerializablePermission
 912      */
 913     protected boolean enableResolveObject(boolean enable)
 914         throws SecurityException
 915     {
 916         if (enable == enableResolve) {
 917             return enable;
 918         }
 919         if (enable) {
 920             SecurityManager sm = System.getSecurityManager();
 921             if (sm != null) {
 922                 sm.checkPermission(SUBSTITUTION_PERMISSION);
 923             }
 924         }
 925         enableResolve = enable;
 926         return !enableResolve;
 927     }
 928 
 929     /**
 930      * The readStreamHeader method is provided to allow subclasses to read and
 931      * verify their own stream headers. It reads and verifies the magic number
 932      * and version number.
 933      *
 934      * @throws  IOException if there are I/O errors while reading from the
 935      *          underlying {@code InputStream}
 936      * @throws  StreamCorruptedException if control information in the stream
 937      *          is inconsistent
 938      */
 939     protected void readStreamHeader()
 940         throws IOException, StreamCorruptedException
 941     {
 942         short s0 = bin.readShort();
 943         short s1 = bin.readShort();
 944         if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
 945             throw new StreamCorruptedException(
 946                 String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));
 947         }
 948     }
 949 
 950     /**
 951      * Read a class descriptor from the serialization stream.  This method is
 952      * called when the ObjectInputStream expects a class descriptor as the next
 953      * item in the serialization stream.  Subclasses of ObjectInputStream may
 954      * override this method to read in class descriptors that have been written
 955      * in non-standard formats (by subclasses of ObjectOutputStream which have
 956      * overridden the {@code writeClassDescriptor} method).  By default,
 957      * this method reads class descriptors according to the format defined in
 958      * the Object Serialization specification.
 959      *
 960      * @return  the class descriptor read
 961      * @throws  IOException If an I/O error has occurred.
 962      * @throws  ClassNotFoundException If the Class of a serialized object used
 963      *          in the class descriptor representation cannot be found
 964      * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 965      * @since 1.3
 966      */
 967     protected ObjectStreamClass readClassDescriptor()
 968         throws IOException, ClassNotFoundException
 969     {
 970         ObjectStreamClass desc = new ObjectStreamClass();
 971         desc.readNonProxy(this);
 972         return desc;
 973     }
 974 
 975     /**
 976      * Reads a byte of data. This method will block if no input is available.
 977      *
 978      * @return  the byte read, or -1 if the end of the stream is reached.
 979      * @throws  IOException If an I/O error has occurred.
 980      */
 981     public int read() throws IOException {
 982         return bin.read();
 983     }
 984 
 985     /**
 986      * Reads into an array of bytes.  This method will block until some input
 987      * is available. Consider using java.io.DataInputStream.readFully to read
 988      * exactly &#39;length&#39; bytes.
 989      *
 990      * @param   buf the buffer into which the data is read
 991      * @param   off the start offset in the destination array {@code buf}
 992      * @param   len the maximum number of bytes read
 993      * @return  the actual number of bytes read, -1 is returned when the end of
 994      *          the stream is reached.
 995      * @throws  NullPointerException if {@code buf} is {@code null}.
 996      * @throws  IndexOutOfBoundsException if {@code off} is negative,
 997      *          {@code len} is negative, or {@code len} is greater than
 998      *          {@code buf.length - off}.
 999      * @throws  IOException If an I/O error has occurred.
1000      * @see java.io.DataInputStream#readFully(byte[],int,int)
1001      */
1002     public int read(byte[] buf, int off, int len) throws IOException {
1003         if (buf == null) {
1004             throw new NullPointerException();
1005         }
1006         int endoff = off + len;
1007         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1008             throw new IndexOutOfBoundsException();
1009         }
1010         return bin.read(buf, off, len, false);
1011     }
1012 
1013     /**
1014      * Returns the number of bytes that can be read without blocking.
1015      *
1016      * @return  the number of available bytes.
1017      * @throws  IOException if there are I/O errors while reading from the
1018      *          underlying {@code InputStream}
1019      */
1020     public int available() throws IOException {
1021         return bin.available();
1022     }
1023 
1024     /**
1025      * Closes the input stream. Must be called to release any resources
1026      * associated with the stream.
1027      *
1028      * @throws  IOException If an I/O error has occurred.
1029      */
1030     public void close() throws IOException {
1031         /*
1032          * Even if stream already closed, propagate redundant close to
1033          * underlying stream to stay consistent with previous implementations.
1034          */
1035         closed = true;
1036         if (depth == 0) {
1037             clear();
1038         }
1039         bin.close();
1040     }
1041 
1042     /**
1043      * Reads in a boolean.
1044      *
1045      * @return  the boolean read.
1046      * @throws  EOFException If end of file is reached.
1047      * @throws  IOException If other I/O error has occurred.
1048      */
1049     public boolean readBoolean() throws IOException {
1050         return bin.readBoolean();
1051     }
1052 
1053     /**
1054      * Reads an 8 bit byte.
1055      *
1056      * @return  the 8 bit byte read.
1057      * @throws  EOFException If end of file is reached.
1058      * @throws  IOException If other I/O error has occurred.
1059      */
1060     public byte readByte() throws IOException  {
1061         return bin.readByte();
1062     }
1063 
1064     /**
1065      * Reads an unsigned 8 bit byte.
1066      *
1067      * @return  the 8 bit byte read.
1068      * @throws  EOFException If end of file is reached.
1069      * @throws  IOException If other I/O error has occurred.
1070      */
1071     public int readUnsignedByte()  throws IOException {
1072         return bin.readUnsignedByte();
1073     }
1074 
1075     /**
1076      * Reads a 16 bit char.
1077      *
1078      * @return  the 16 bit char read.
1079      * @throws  EOFException If end of file is reached.
1080      * @throws  IOException If other I/O error has occurred.
1081      */
1082     public char readChar()  throws IOException {
1083         return bin.readChar();
1084     }
1085 
1086     /**
1087      * Reads a 16 bit short.
1088      *
1089      * @return  the 16 bit short read.
1090      * @throws  EOFException If end of file is reached.
1091      * @throws  IOException If other I/O error has occurred.
1092      */
1093     public short readShort()  throws IOException {
1094         return bin.readShort();
1095     }
1096 
1097     /**
1098      * Reads an unsigned 16 bit short.
1099      *
1100      * @return  the 16 bit short read.
1101      * @throws  EOFException If end of file is reached.
1102      * @throws  IOException If other I/O error has occurred.
1103      */
1104     public int readUnsignedShort() throws IOException {
1105         return bin.readUnsignedShort();
1106     }
1107 
1108     /**
1109      * Reads a 32 bit int.
1110      *
1111      * @return  the 32 bit integer read.
1112      * @throws  EOFException If end of file is reached.
1113      * @throws  IOException If other I/O error has occurred.
1114      */
1115     public int readInt()  throws IOException {
1116         return bin.readInt();
1117     }
1118 
1119     /**
1120      * Reads a 64 bit long.
1121      *
1122      * @return  the read 64 bit long.
1123      * @throws  EOFException If end of file is reached.
1124      * @throws  IOException If other I/O error has occurred.
1125      */
1126     public long readLong()  throws IOException {
1127         return bin.readLong();
1128     }
1129 
1130     /**
1131      * Reads a 32 bit float.
1132      *
1133      * @return  the 32 bit float read.
1134      * @throws  EOFException If end of file is reached.
1135      * @throws  IOException If other I/O error has occurred.
1136      */
1137     public float readFloat() throws IOException {
1138         return bin.readFloat();
1139     }
1140 
1141     /**
1142      * Reads a 64 bit double.
1143      *
1144      * @return  the 64 bit double read.
1145      * @throws  EOFException If end of file is reached.
1146      * @throws  IOException If other I/O error has occurred.
1147      */
1148     public double readDouble() throws IOException {
1149         return bin.readDouble();
1150     }
1151 
1152     /**
1153      * Reads bytes, blocking until all bytes are read.
1154      *
1155      * @param   buf the buffer into which the data is read
1156      * @throws  NullPointerException If {@code buf} is {@code null}.
1157      * @throws  EOFException If end of file is reached.
1158      * @throws  IOException If other I/O error has occurred.
1159      */
1160     public void readFully(byte[] buf) throws IOException {
1161         bin.readFully(buf, 0, buf.length, false);
1162     }
1163 
1164     /**
1165      * Reads bytes, blocking until all bytes are read.
1166      *
1167      * @param   buf the buffer into which the data is read
1168      * @param   off the start offset into the data array {@code buf}
1169      * @param   len the maximum number of bytes to read
1170      * @throws  NullPointerException If {@code buf} is {@code null}.
1171      * @throws  IndexOutOfBoundsException If {@code off} is negative,
1172      *          {@code len} is negative, or {@code len} is greater than
1173      *          {@code buf.length - off}.
1174      * @throws  EOFException If end of file is reached.
1175      * @throws  IOException If other I/O error has occurred.
1176      */
1177     public void readFully(byte[] buf, int off, int len) throws IOException {
1178         int endoff = off + len;
1179         if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
1180             throw new IndexOutOfBoundsException();
1181         }
1182         bin.readFully(buf, off, len, false);
1183     }
1184 
1185     /**
1186      * Skips bytes.
1187      *
1188      * @param   len the number of bytes to be skipped
1189      * @return  the actual number of bytes skipped.
1190      * @throws  IOException If an I/O error has occurred.
1191      */
1192     public int skipBytes(int len) throws IOException {
1193         return bin.skipBytes(len);
1194     }
1195 
1196     /**
1197      * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
1198      *
1199      * @return  a String copy of the line.
1200      * @throws  IOException if there are I/O errors while reading from the
1201      *          underlying {@code InputStream}
1202      * @deprecated This method does not properly convert bytes to characters.
1203      *          see DataInputStream for the details and alternatives.
1204      */
1205     @Deprecated
1206     public String readLine() throws IOException {
1207         return bin.readLine();
1208     }
1209 
1210     /**
1211      * Reads a String in
1212      * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
1213      * format.
1214      *
1215      * @return  the String.
1216      * @throws  IOException if there are I/O errors while reading from the
1217      *          underlying {@code InputStream}
1218      * @throws  UTFDataFormatException if read bytes do not represent a valid
1219      *          modified UTF-8 encoding of a string
1220      */
1221     public String readUTF() throws IOException {
1222         return bin.readUTF();
1223     }
1224 
1225     /**
1226      * Returns the serialization filter for this stream.
1227      * The serialization filter is the most recent filter set in
1228      * {@link #setObjectInputFilter setObjectInputFilter} or
1229      * the initial system-wide filter from
1230      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.
1231      *
1232      * @return the serialization filter for the stream; may be null
1233      * @since 9
1234      */
1235     public final ObjectInputFilter getObjectInputFilter() {
1236         return serialFilter;
1237     }
1238 
1239     /**
1240      * Set the serialization filter for the stream.
1241      * The filter&#39;s {@link ObjectInputFilter#checkInput checkInput} method is called
1242      * for each class and reference in the stream.
1243      * The filter can check any or all of the class, the array length, the number
1244      * of references, the depth of the graph, and the size of the input stream.
1245      * The depth is the number of nested {@linkplain #readObject readObject}
1246      * calls starting with the reading of the root of the graph being deserialized
1247      * and the current object being deserialized.
1248      * The number of references is the cumulative number of objects and references
1249      * to objects already read from the stream including the current object being read.
1250      * The filter is invoked only when reading objects from the stream and for
1251      * not primitives.
1252      * &lt;p&gt;
1253      * If the filter returns {@link ObjectInputFilter.Status#REJECTED Status.REJECTED},
1254      * {@code null} or throws a {@link RuntimeException},
1255      * the active {@code readObject} or {@code readUnshared}
1256      * throws {@link InvalidClassException}, otherwise deserialization
1257      * continues uninterrupted.
1258      * &lt;p&gt;
1259      * The serialization filter is initialized to the value of
1260      * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}
1261      * when the {@code  ObjectInputStream} is constructed and can be set
1262      * to a custom filter only once.
1263      *
1264      * @implSpec
1265      * The filter, when not {@code null}, is invoked during {@link #readObject readObject}
1266      * and {@link #readUnshared readUnshared} for each object (regular or class) in the stream.
1267      * Strings are treated as primitives and do not invoke the filter.
1268      * The filter is called for:
1269      * &lt;ul&gt;
1270      *     &lt;li&gt;each object reference previously deserialized from the stream
1271      *     (class is {@code null}, arrayLength is -1),
1272      *     &lt;li&gt;each regular class (class is not {@code null}, arrayLength is -1),
1273      *     &lt;li&gt;each interface of a dynamic proxy and the dynamic proxy class itself
1274      *     (class is not {@code null}, arrayLength is -1),
1275      *     &lt;li&gt;each array is filtered using the array type and length of the array
1276      *     (class is the array type, arrayLength is the requested length),
1277      *     &lt;li&gt;each object replaced by its class&#39; {@code readResolve} method
1278      *         is filtered using the replacement object&#39;s class, if not {@code null},
1279      *         and if it is an array, the arrayLength, otherwise -1,
1280      *     &lt;li&gt;and each object replaced by {@link #resolveObject resolveObject}
1281      *         is filtered using the replacement object&#39;s class, if not {@code null},
1282      *         and if it is an array, the arrayLength, otherwise -1.
1283      * &lt;/ul&gt;
1284      *
1285      * When the {@link ObjectInputFilter#checkInput checkInput} method is invoked
1286      * it is given access to the current class, the array length,
1287      * the current number of references already read from the stream,
1288      * the depth of nested calls to {@link #readObject readObject} or
1289      * {@link #readUnshared readUnshared},
1290      * and the implementation dependent number of bytes consumed from the input stream.
1291      * &lt;p&gt;
1292      * Each call to {@link #readObject readObject} or
1293      * {@link #readUnshared readUnshared} increases the depth by 1
1294      * before reading an object and decreases by 1 before returning
1295      * normally or exceptionally.
1296      * The depth starts at {@code 1} and increases for each nested object and
1297      * decrements when each nested call returns.
1298      * The count of references in the stream starts at {@code 1} and
1299      * is increased before reading an object.
1300      *
1301      * @param filter the filter, may be null
1302      * @throws SecurityException if there is security manager and the
1303      *       {@code SerializablePermission(&quot;serialFilter&quot;)} is not granted
1304      * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}
1305      *       is not {@code null} and is not the system-wide filter
1306      * @since 9
1307      */
1308     public final void setObjectInputFilter(ObjectInputFilter filter) {
1309         SecurityManager sm = System.getSecurityManager();
1310         if (sm != null) {
1311             sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);
1312         }
1313         // Allow replacement of the system-wide filter if not already set
1314         if (serialFilter != null &amp;&amp;
1315                 serialFilter != ObjectInputFilter.Config.getSerialFilter()) {
1316             throw new IllegalStateException(&quot;filter can not be set more than once&quot;);
1317         }
1318         this.serialFilter = filter;
1319     }
1320 
1321     /**
1322      * Invoke the serialization filter if non-null.
1323      * If the filter rejects or an exception is thrown, throws InvalidClassException.
1324      *
1325      * @param clazz the class; may be null
1326      * @param arrayLength the array length requested; use {@code -1} if not creating an array
1327      * @throws InvalidClassException if it rejected by the filter or
1328      *        a {@link RuntimeException} is thrown
1329      */
1330     private void filterCheck(Class&lt;?&gt; clazz, int arrayLength)
1331             throws InvalidClassException {
1332         if (serialFilter != null) {
1333             RuntimeException ex = null;
1334             ObjectInputFilter.Status status;
1335             // Info about the stream is not available if overridden by subclass, return 0
1336             long bytesRead = (bin == null) ? 0 : bin.getBytesRead();
1337             try {
1338                 status = serialFilter.checkInput(new FilterValues(clazz, arrayLength,
1339                         totalObjectRefs, depth, bytesRead));
1340             } catch (RuntimeException e) {
1341                 // Preventive interception of an exception to log
1342                 status = ObjectInputFilter.Status.REJECTED;
1343                 ex = e;
1344             }
1345             if (Logging.filterLogger != null) {
1346                 // Debug logging of filter checks that fail; Tracing for those that succeed
1347                 Logging.filterLogger.log(status == null || status == ObjectInputFilter.Status.REJECTED
1348                                 ? Logger.Level.DEBUG
1349                                 : Logger.Level.TRACE,
1350                         &quot;ObjectInputFilter {0}: {1}, array length: {2}, nRefs: {3}, depth: {4}, bytes: {5}, ex: {6}&quot;,
1351                         status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,
1352                         Objects.toString(ex, &quot;n/a&quot;));
1353             }
1354             if (status == null ||
1355                     status == ObjectInputFilter.Status.REJECTED) {
1356                 InvalidClassException ice = new InvalidClassException(&quot;filter status: &quot; + status);
1357                 ice.initCause(ex);
1358                 throw ice;
1359             }
1360         }
1361     }
1362 
1363     /**
1364      * Checks the given array type and length to ensure that creation of such
1365      * an array is permitted by this ObjectInputStream. The arrayType argument
1366      * must represent an actual array type.
1367      *
1368      * This private method is called via SharedSecrets.
1369      *
1370      * @param arrayType the array type
1371      * @param arrayLength the array length
1372      * @throws NullPointerException if arrayType is null
1373      * @throws IllegalArgumentException if arrayType isn&#39;t actually an array type
1374      * @throws NegativeArraySizeException if arrayLength is negative
1375      * @throws InvalidClassException if the filter rejects creation
1376      */
1377     private void checkArray(Class&lt;?&gt; arrayType, int arrayLength) throws InvalidClassException {
1378         if (! arrayType.isArray()) {
1379             throw new IllegalArgumentException(&quot;not an array type&quot;);
1380         }
1381 
1382         if (arrayLength &lt; 0) {
1383             throw new NegativeArraySizeException();
1384         }
1385 
1386         filterCheck(arrayType, arrayLength);
1387     }
1388 
1389     /**
1390      * Provide access to the persistent fields read from the input stream.
1391      */
1392     public abstract static class GetField {
1393         /**
1394          * Constructor for subclasses to call.
1395          */
1396         public GetField() {}
1397 
1398         /**
1399          * Get the ObjectStreamClass that describes the fields in the stream.
1400          *
1401          * @return  the descriptor class that describes the serializable fields
1402          */
1403         public abstract ObjectStreamClass getObjectStreamClass();
1404 
1405         /**
1406          * Return true if the named field is defaulted and has no value in this
1407          * stream.
1408          *
1409          * @param  name the name of the field
1410          * @return true, if and only if the named field is defaulted
1411          * @throws IOException if there are I/O errors while reading from
1412          *         the underlying {@code InputStream}
1413          * @throws IllegalArgumentException if {@code name} does not
1414          *         correspond to a serializable field
1415          */
1416         public abstract boolean defaulted(String name) throws IOException;
1417 
1418         /**
1419          * Get the value of the named boolean field from the persistent field.
1420          *
1421          * @param  name the name of the field
1422          * @param  val the default value to use if {@code name} does not
1423          *         have a value
1424          * @return the value of the named {@code boolean} field
1425          * @throws IOException if there are I/O errors while reading from the
1426          *         underlying {@code InputStream}
1427          * @throws IllegalArgumentException if type of {@code name} is
1428          *         not serializable or if the field type is incorrect
1429          */
1430         public abstract boolean get(String name, boolean val)
1431             throws IOException;
1432 
1433         /**
1434          * Get the value of the named byte field from the persistent field.
1435          *
1436          * @param  name the name of the field
1437          * @param  val the default value to use if {@code name} does not
1438          *         have a value
1439          * @return the value of the named {@code byte} field
1440          * @throws IOException if there are I/O errors while reading from the
1441          *         underlying {@code InputStream}
1442          * @throws IllegalArgumentException if type of {@code name} is
1443          *         not serializable or if the field type is incorrect
1444          */
1445         public abstract byte get(String name, byte val) throws IOException;
1446 
1447         /**
1448          * Get the value of the named char field from the persistent field.
1449          *
1450          * @param  name the name of the field
1451          * @param  val the default value to use if {@code name} does not
1452          *         have a value
1453          * @return the value of the named {@code char} field
1454          * @throws IOException if there are I/O errors while reading from the
1455          *         underlying {@code InputStream}
1456          * @throws IllegalArgumentException if type of {@code name} is
1457          *         not serializable or if the field type is incorrect
1458          */
1459         public abstract char get(String name, char val) throws IOException;
1460 
1461         /**
1462          * Get the value of the named short field from the persistent field.
1463          *
1464          * @param  name the name of the field
1465          * @param  val the default value to use if {@code name} does not
1466          *         have a value
1467          * @return the value of the named {@code short} field
1468          * @throws IOException if there are I/O errors while reading from the
1469          *         underlying {@code InputStream}
1470          * @throws IllegalArgumentException if type of {@code name} is
1471          *         not serializable or if the field type is incorrect
1472          */
1473         public abstract short get(String name, short val) throws IOException;
1474 
1475         /**
1476          * Get the value of the named int field from the persistent field.
1477          *
1478          * @param  name the name of the field
1479          * @param  val the default value to use if {@code name} does not
1480          *         have a value
1481          * @return the value of the named {@code int} field
1482          * @throws IOException if there are I/O errors while reading from the
1483          *         underlying {@code InputStream}
1484          * @throws IllegalArgumentException if type of {@code name} is
1485          *         not serializable or if the field type is incorrect
1486          */
1487         public abstract int get(String name, int val) throws IOException;
1488 
1489         /**
1490          * Get the value of the named long field from the persistent field.
1491          *
1492          * @param  name the name of the field
1493          * @param  val the default value to use if {@code name} does not
1494          *         have a value
1495          * @return the value of the named {@code long} field
1496          * @throws IOException if there are I/O errors while reading from the
1497          *         underlying {@code InputStream}
1498          * @throws IllegalArgumentException if type of {@code name} is
1499          *         not serializable or if the field type is incorrect
1500          */
1501         public abstract long get(String name, long val) throws IOException;
1502 
1503         /**
1504          * Get the value of the named float field from the persistent field.
1505          *
1506          * @param  name the name of the field
1507          * @param  val the default value to use if {@code name} does not
1508          *         have a value
1509          * @return the value of the named {@code float} field
1510          * @throws IOException if there are I/O errors while reading from the
1511          *         underlying {@code InputStream}
1512          * @throws IllegalArgumentException if type of {@code name} is
1513          *         not serializable or if the field type is incorrect
1514          */
1515         public abstract float get(String name, float val) throws IOException;
1516 
1517         /**
1518          * Get the value of the named double field from the persistent field.
1519          *
1520          * @param  name the name of the field
1521          * @param  val the default value to use if {@code name} does not
1522          *         have a value
1523          * @return the value of the named {@code double} field
1524          * @throws IOException if there are I/O errors while reading from the
1525          *         underlying {@code InputStream}
1526          * @throws IllegalArgumentException if type of {@code name} is
1527          *         not serializable or if the field type is incorrect
1528          */
1529         public abstract double get(String name, double val) throws IOException;
1530 
1531         /**
1532          * Get the value of the named Object field from the persistent field.
1533          *
1534          * @param  name the name of the field
1535          * @param  val the default value to use if {@code name} does not
1536          *         have a value
1537          * @return the value of the named {@code Object} field
1538          * @throws IOException if there are I/O errors while reading from the
1539          *         underlying {@code InputStream}
1540          * @throws IllegalArgumentException if type of {@code name} is
1541          *         not serializable or if the field type is incorrect
1542          */
1543         public abstract Object get(String name, Object val) throws IOException;
1544     }
1545 
1546     /**
1547      * Verifies that this (possibly subclass) instance can be constructed
1548      * without violating security constraints: the subclass must not override
1549      * security-sensitive non-final methods, or else the
1550      * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.
1551      */
1552     private void verifySubclass() {
1553         Class&lt;?&gt; cl = getClass();
1554         if (cl == ObjectInputStream.class) {
1555             return;
1556         }
1557         SecurityManager sm = System.getSecurityManager();
1558         if (sm == null) {
1559             return;
1560         }
1561         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
1562         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
1563         Boolean result = Caches.subclassAudits.get(key);
1564         if (result == null) {
1565             result = auditSubclass(cl);
1566             Caches.subclassAudits.putIfAbsent(key, result);
1567         }
1568         if (!result) {
1569             sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
1570         }
1571     }
1572 
1573     /**
1574      * Performs reflective checks on given subclass to verify that it doesn&#39;t
1575      * override security-sensitive non-final methods.  Returns TRUE if subclass
1576      * is &quot;safe&quot;, FALSE otherwise.
1577      */
1578     private static Boolean auditSubclass(Class&lt;?&gt; subcl) {
1579         return AccessController.doPrivileged(
1580             new PrivilegedAction&lt;Boolean&gt;() {
1581                 public Boolean run() {
1582                     for (Class&lt;?&gt; cl = subcl;
1583                          cl != ObjectInputStream.class;
1584                          cl = cl.getSuperclass())
1585                     {
1586                         try {
1587                             cl.getDeclaredMethod(
1588                                 &quot;readUnshared&quot;, (Class[]) null);
1589                             return Boolean.FALSE;
1590                         } catch (NoSuchMethodException ex) {
1591                         }
1592                         try {
1593                             cl.getDeclaredMethod(&quot;readFields&quot;, (Class[]) null);
1594                             return Boolean.FALSE;
1595                         } catch (NoSuchMethodException ex) {
1596                         }
1597                     }
1598                     return Boolean.TRUE;
1599                 }
1600             }
1601         );
1602     }
1603 
1604     /**
1605      * Clears internal data structures.
1606      */
1607     private void clear() {
1608         handles.clear();
1609         vlist.clear();
1610     }
1611 
1612     /**
1613      * Underlying readObject implementation.
1614      * @param type a type expected to be deserialized; non-null
1615      * @param unshared true if the object can not be a reference to a shared object, otherwise false
1616      */
1617     private Object readObject0(Class&lt;?&gt; type, boolean unshared) throws IOException {
1618         boolean oldMode = bin.getBlockDataMode();
1619         if (oldMode) {
1620             int remain = bin.currentBlockRemaining();
1621             if (remain &gt; 0) {
1622                 throw new OptionalDataException(remain);
1623             } else if (defaultDataEnd) {
1624                 /*
1625                  * Fix for 4360508: stream is currently at the end of a field
1626                  * value block written via default serialization; since there
1627                  * is no terminating TC_ENDBLOCKDATA tag, simulate
1628                  * end-of-custom-data behavior explicitly.
1629                  */
1630                 throw new OptionalDataException(true);
1631             }
1632             bin.setBlockDataMode(false);
1633         }
1634 
1635         byte tc;
1636         while ((tc = bin.peekByte()) == TC_RESET) {
1637             bin.readByte();
1638             handleReset();
1639         }
1640 
1641         depth++;
1642         totalObjectRefs++;
1643         try {
1644             switch (tc) {
1645                 case TC_NULL:
1646                     return readNull();
1647 
1648                 case TC_REFERENCE:
1649                     // check the type of the existing object
1650                     return type.cast(readHandle(unshared));
1651 
1652                 case TC_CLASS:
1653                     if (type == String.class) {
1654                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1655                     }
1656                     return readClass(unshared);
1657 
1658                 case TC_CLASSDESC:
1659                 case TC_PROXYCLASSDESC:
1660                     if (type == String.class) {
1661                         throw new ClassCastException(&quot;Cannot cast a class to java.lang.String&quot;);
1662                     }
1663                     return readClassDesc(unshared);
1664 
1665                 case TC_STRING:
1666                 case TC_LONGSTRING:
1667                     return checkResolve(readString(unshared));
1668 
1669                 case TC_ARRAY:
1670                     if (type == String.class) {
1671                         throw new ClassCastException(&quot;Cannot cast an array to java.lang.String&quot;);
1672                     }
1673                     return checkResolve(readArray(unshared));
1674 
1675                 case TC_ENUM:
1676                     if (type == String.class) {
1677                         throw new ClassCastException(&quot;Cannot cast an enum to java.lang.String&quot;);
1678                     }
1679                     return checkResolve(readEnum(unshared));
1680 
1681                 case TC_OBJECT:
1682                     if (type == String.class) {
1683                         throw new ClassCastException(&quot;Cannot cast an object to java.lang.String&quot;);
1684                     }
1685                     return checkResolve(readOrdinaryObject(unshared));
1686 
1687                 case TC_EXCEPTION:
1688                     if (type == String.class) {
1689                         throw new ClassCastException(&quot;Cannot cast an exception to java.lang.String&quot;);
1690                     }
1691                     IOException ex = readFatalException();
1692                     throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
1693 
1694                 case TC_BLOCKDATA:
1695                 case TC_BLOCKDATALONG:
1696                     if (oldMode) {
1697                         bin.setBlockDataMode(true);
1698                         bin.peek();             // force header read
1699                         throw new OptionalDataException(
1700                             bin.currentBlockRemaining());
1701                     } else {
1702                         throw new StreamCorruptedException(
1703                             &quot;unexpected block data&quot;);
1704                     }
1705 
1706                 case TC_ENDBLOCKDATA:
1707                     if (oldMode) {
1708                         throw new OptionalDataException(true);
1709                     } else {
1710                         throw new StreamCorruptedException(
1711                             &quot;unexpected end of block data&quot;);
1712                     }
1713 
1714                 default:
1715                     throw new StreamCorruptedException(
1716                         String.format(&quot;invalid type code: %02X&quot;, tc));
1717             }
1718         } finally {
1719             depth--;
1720             bin.setBlockDataMode(oldMode);
1721         }
1722     }
1723 
1724     /**
1725      * If resolveObject has been enabled and given object does not have an
1726      * exception associated with it, calls resolveObject to determine
1727      * replacement for object, and updates handle table accordingly.  Returns
1728      * replacement object, or echoes provided object if no replacement
1729      * occurred.  Expects that passHandle is set to given object&#39;s handle prior
1730      * to calling this method.
1731      */
1732     private Object checkResolve(Object obj) throws IOException {
1733         if (!enableResolve || handles.lookupException(passHandle) != null) {
1734             return obj;
1735         }
1736         Object rep = resolveObject(obj);
1737         if (rep != obj) {
1738             // The type of the original object has been filtered but resolveObject
1739             // may have replaced it;  filter the replacement&#39;s type
1740             if (rep != null) {
1741                 if (rep.getClass().isArray()) {
1742                     filterCheck(rep.getClass(), Array.getLength(rep));
1743                 } else {
1744                     filterCheck(rep.getClass(), -1);
1745                 }
1746             }
1747             handles.setObject(passHandle, rep);
1748         }
1749         return rep;
1750     }
1751 
1752     /**
1753      * Reads string without allowing it to be replaced in stream.  Called from
1754      * within ObjectStreamClass.read().
1755      */
1756     String readTypeString() throws IOException {
1757         int oldHandle = passHandle;
1758         try {
1759             byte tc = bin.peekByte();
1760             switch (tc) {
1761                 case TC_NULL:
1762                     return (String) readNull();
1763 
1764                 case TC_REFERENCE:
1765                     return (String) readHandle(false);
1766 
1767                 case TC_STRING:
1768                 case TC_LONGSTRING:
1769                     return readString(false);
1770 
1771                 default:
1772                     throw new StreamCorruptedException(
1773                         String.format(&quot;invalid type code: %02X&quot;, tc));
1774             }
1775         } finally {
1776             passHandle = oldHandle;
1777         }
1778     }
1779 
1780     /**
1781      * Reads in null code, sets passHandle to NULL_HANDLE and returns null.
1782      */
1783     private Object readNull() throws IOException {
1784         if (bin.readByte() != TC_NULL) {
1785             throw new InternalError();
1786         }
1787         passHandle = NULL_HANDLE;
1788         return null;
1789     }
1790 
1791     /**
1792      * Reads in object handle, sets passHandle to the read handle, and returns
1793      * object associated with the handle.
1794      */
1795     private Object readHandle(boolean unshared) throws IOException {
1796         if (bin.readByte() != TC_REFERENCE) {
1797             throw new InternalError();
1798         }
1799         passHandle = bin.readInt() - baseWireHandle;
1800         if (passHandle &lt; 0 || passHandle &gt;= handles.size()) {
1801             throw new StreamCorruptedException(
1802                 String.format(&quot;invalid handle value: %08X&quot;, passHandle +
1803                 baseWireHandle));
1804         }
1805         if (unshared) {
1806             // REMIND: what type of exception to throw here?
1807             throw new InvalidObjectException(
1808                 &quot;cannot read back reference as unshared&quot;);
1809         }
1810 
1811         Object obj = handles.lookupObject(passHandle);
1812         if (obj == unsharedMarker) {
1813             // REMIND: what type of exception to throw here?
1814             throw new InvalidObjectException(
1815                 &quot;cannot read back reference to unshared object&quot;);
1816         }
1817         filterCheck(null, -1);       // just a check for number of references, depth, no class
1818         return obj;
1819     }
1820 
1821     /**
1822      * Reads in and returns class object.  Sets passHandle to class object&#39;s
1823      * assigned handle.  Returns null if class is unresolvable (in which case a
1824      * ClassNotFoundException will be associated with the class&#39; handle in the
1825      * handle table).
1826      */
1827     private Class&lt;?&gt; readClass(boolean unshared) throws IOException {
1828         if (bin.readByte() != TC_CLASS) {
1829             throw new InternalError();
1830         }
1831         ObjectStreamClass desc = readClassDesc(false);
1832         Class&lt;?&gt; cl = desc.forClass();
1833         passHandle = handles.assign(unshared ? unsharedMarker : cl);
1834 
1835         ClassNotFoundException resolveEx = desc.getResolveException();
1836         if (resolveEx != null) {
1837             handles.markException(passHandle, resolveEx);
1838         }
1839 
1840         handles.finish(passHandle);
1841         return cl;
1842     }
1843 
1844     /**
1845      * Reads in and returns (possibly null) class descriptor.  Sets passHandle
1846      * to class descriptor&#39;s assigned handle.  If class descriptor cannot be
1847      * resolved to a class in the local VM, a ClassNotFoundException is
1848      * associated with the class descriptor&#39;s handle.
1849      */
1850     private ObjectStreamClass readClassDesc(boolean unshared)
1851         throws IOException
1852     {
1853         byte tc = bin.peekByte();
1854         ObjectStreamClass descriptor;
1855         switch (tc) {
1856             case TC_NULL:
1857                 descriptor = (ObjectStreamClass) readNull();
1858                 break;
1859             case TC_REFERENCE:
1860                 descriptor = (ObjectStreamClass) readHandle(unshared);
1861                 // Should only reference initialized class descriptors
1862                 descriptor.checkInitialized();
1863                 break;
1864             case TC_PROXYCLASSDESC:
1865                 descriptor = readProxyDesc(unshared);
1866                 break;
1867             case TC_CLASSDESC:
1868                 descriptor = readNonProxyDesc(unshared);
1869                 break;
1870             default:
1871                 throw new StreamCorruptedException(
1872                     String.format(&quot;invalid type code: %02X&quot;, tc));
1873         }
1874         return descriptor;
1875     }
1876 
1877     private boolean isCustomSubclass() {
1878         // Return true if this class is a custom subclass of ObjectInputStream
1879         return getClass().getClassLoader()
1880                     != ObjectInputStream.class.getClassLoader();
1881     }
1882 
1883     /**
1884      * Reads in and returns class descriptor for a dynamic proxy class.  Sets
1885      * passHandle to proxy class descriptor&#39;s assigned handle.  If proxy class
1886      * descriptor cannot be resolved to a class in the local VM, a
1887      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1888      */
1889     private ObjectStreamClass readProxyDesc(boolean unshared)
1890         throws IOException
1891     {
1892         if (bin.readByte() != TC_PROXYCLASSDESC) {
1893             throw new InternalError();
1894         }
1895 
1896         ObjectStreamClass desc = new ObjectStreamClass();
1897         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1898         passHandle = NULL_HANDLE;
1899 
1900         int numIfaces = bin.readInt();
1901         if (numIfaces &gt; 65535) {
1902             throw new InvalidObjectException(&quot;interface limit exceeded: &quot;
1903                     + numIfaces);
1904         }
1905         String[] ifaces = new String[numIfaces];
1906         for (int i = 0; i &lt; numIfaces; i++) {
1907             ifaces[i] = bin.readUTF();
1908         }
1909 
1910         Class&lt;?&gt; cl = null;
1911         ClassNotFoundException resolveEx = null;
1912         bin.setBlockDataMode(true);
1913         try {
1914             if ((cl = resolveProxyClass(ifaces)) == null) {
1915                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1916             } else if (!Proxy.isProxyClass(cl)) {
1917                 throw new InvalidClassException(&quot;Not a proxy&quot;);
1918             } else {
1919                 // ReflectUtil.checkProxyPackageAccess makes a test
1920                 // equivalent to isCustomSubclass so there&#39;s no need
1921                 // to condition this call to isCustomSubclass == true here.
1922                 ReflectUtil.checkProxyPackageAccess(
1923                         getClass().getClassLoader(),
1924                         cl.getInterfaces());
1925                 // Filter the interfaces
1926                 for (Class&lt;?&gt; clazz : cl.getInterfaces()) {
1927                     filterCheck(clazz, -1);
1928                 }
1929             }
1930         } catch (ClassNotFoundException ex) {
1931             resolveEx = ex;
1932         }
1933 
1934         // Call filterCheck on the class before reading anything else
1935         filterCheck(cl, -1);
1936 
1937         skipCustomData();
1938 
1939         try {
1940             totalObjectRefs++;
1941             depth++;
1942             desc.initProxy(cl, resolveEx, readClassDesc(false));
1943         } finally {
1944             depth--;
1945         }
1946 
1947         handles.finish(descHandle);
1948         passHandle = descHandle;
1949         return desc;
1950     }
1951 
1952     /**
1953      * Reads in and returns class descriptor for a class that is not a dynamic
1954      * proxy class.  Sets passHandle to class descriptor&#39;s assigned handle.  If
1955      * class descriptor cannot be resolved to a class in the local VM, a
1956      * ClassNotFoundException is associated with the descriptor&#39;s handle.
1957      */
1958     private ObjectStreamClass readNonProxyDesc(boolean unshared)
1959         throws IOException
1960     {
1961         if (bin.readByte() != TC_CLASSDESC) {
1962             throw new InternalError();
1963         }
1964 
1965         ObjectStreamClass desc = new ObjectStreamClass();
1966         int descHandle = handles.assign(unshared ? unsharedMarker : desc);
1967         passHandle = NULL_HANDLE;
1968 
1969         ObjectStreamClass readDesc;
1970         try {
1971             readDesc = readClassDescriptor();
1972         } catch (ClassNotFoundException ex) {
1973             throw (IOException) new InvalidClassException(
1974                 &quot;failed to read class descriptor&quot;).initCause(ex);
1975         }
1976 
1977         Class&lt;?&gt; cl = null;
1978         ClassNotFoundException resolveEx = null;
1979         bin.setBlockDataMode(true);
1980         final boolean checksRequired = isCustomSubclass();
1981         try {
1982             if ((cl = resolveClass(readDesc)) == null) {
1983                 resolveEx = new ClassNotFoundException(&quot;null class&quot;);
1984             } else if (checksRequired) {
1985                 ReflectUtil.checkPackageAccess(cl);
1986             }
1987         } catch (ClassNotFoundException ex) {
1988             resolveEx = ex;
1989         }
1990 
1991         // Call filterCheck on the class before reading anything else
1992         filterCheck(cl, -1);
1993 
1994         skipCustomData();
1995 
1996         try {
1997             totalObjectRefs++;
1998             depth++;
1999             desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));
2000         } finally {
2001             depth--;
2002         }
2003 
2004         handles.finish(descHandle);
2005         passHandle = descHandle;
2006 
2007         return desc;
2008     }
2009 
2010     /**
2011      * Reads in and returns new string.  Sets passHandle to new string&#39;s
2012      * assigned handle.
2013      */
2014     private String readString(boolean unshared) throws IOException {
2015         String str;
2016         byte tc = bin.readByte();
2017         switch (tc) {
2018             case TC_STRING:
2019                 str = bin.readUTF();
2020                 break;
2021 
2022             case TC_LONGSTRING:
2023                 str = bin.readLongUTF();
2024                 break;
2025 
2026             default:
2027                 throw new StreamCorruptedException(
2028                     String.format(&quot;invalid type code: %02X&quot;, tc));
2029         }
2030         passHandle = handles.assign(unshared ? unsharedMarker : str);
2031         handles.finish(passHandle);
2032         return str;
2033     }
2034 
2035     /**
2036      * Reads in and returns array object, or null if array class is
2037      * unresolvable.  Sets passHandle to array&#39;s assigned handle.
2038      */
2039     private Object readArray(boolean unshared) throws IOException {
2040         if (bin.readByte() != TC_ARRAY) {
2041             throw new InternalError();
2042         }
2043 
2044         ObjectStreamClass desc = readClassDesc(false);
2045         int len = bin.readInt();
2046 
2047         filterCheck(desc.forClass(), len);
2048 
2049         Object array = null;
2050         Class&lt;?&gt; cl, ccl = null;
2051         if ((cl = desc.forClass()) != null) {
2052             ccl = cl.getComponentType();
2053             array = Array.newInstance(ccl, len);
2054         }
2055 
2056         int arrayHandle = handles.assign(unshared ? unsharedMarker : array);
2057         ClassNotFoundException resolveEx = desc.getResolveException();
2058         if (resolveEx != null) {
2059             handles.markException(arrayHandle, resolveEx);
2060         }
2061 
2062         if (ccl == null) {
2063             for (int i = 0; i &lt; len; i++) {
2064                 readObject0(Object.class, false);
2065             }
2066         } else if (ccl.isPrimitive()) {
2067             if (ccl == Integer.TYPE) {
2068                 bin.readInts((int[]) array, 0, len);
2069             } else if (ccl == Byte.TYPE) {
2070                 bin.readFully((byte[]) array, 0, len, true);
2071             } else if (ccl == Long.TYPE) {
2072                 bin.readLongs((long[]) array, 0, len);
2073             } else if (ccl == Float.TYPE) {
2074                 bin.readFloats((float[]) array, 0, len);
2075             } else if (ccl == Double.TYPE) {
2076                 bin.readDoubles((double[]) array, 0, len);
2077             } else if (ccl == Short.TYPE) {
2078                 bin.readShorts((short[]) array, 0, len);
2079             } else if (ccl == Character.TYPE) {
2080                 bin.readChars((char[]) array, 0, len);
2081             } else if (ccl == Boolean.TYPE) {
2082                 bin.readBooleans((boolean[]) array, 0, len);
2083             } else {
2084                 throw new InternalError();
2085             }
2086         } else {
2087             Object[] oa = (Object[]) array;
2088             for (int i = 0; i &lt; len; i++) {
2089                 oa[i] = readObject0(Object.class, false);
2090                 handles.markDependency(arrayHandle, passHandle);
2091             }
2092         }
2093 
2094         handles.finish(arrayHandle);
2095         passHandle = arrayHandle;
2096         return array;
2097     }
2098 
2099     /**
2100      * Reads in and returns enum constant, or null if enum type is
2101      * unresolvable.  Sets passHandle to enum constant&#39;s assigned handle.
2102      */
2103     private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {
2104         if (bin.readByte() != TC_ENUM) {
2105             throw new InternalError();
2106         }
2107 
2108         ObjectStreamClass desc = readClassDesc(false);
2109         if (!desc.isEnum()) {
2110             throw new InvalidClassException(&quot;non-enum class: &quot; + desc);
2111         }
2112 
2113         int enumHandle = handles.assign(unshared ? unsharedMarker : null);
2114         ClassNotFoundException resolveEx = desc.getResolveException();
2115         if (resolveEx != null) {
2116             handles.markException(enumHandle, resolveEx);
2117         }
2118 
2119         String name = readString(false);
2120         Enum&lt;?&gt; result = null;
2121         Class&lt;?&gt; cl = desc.forClass();
2122         if (cl != null) {
2123             try {
2124                 @SuppressWarnings(&quot;unchecked&quot;)
2125                 Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);
2126                 result = en;
2127             } catch (IllegalArgumentException ex) {
2128                 throw (IOException) new InvalidObjectException(
2129                     &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
2130                     cl).initCause(ex);
2131             }
2132             if (!unshared) {
2133                 handles.setObject(enumHandle, result);
2134             }
2135         }
2136 
2137         handles.finish(enumHandle);
2138         passHandle = enumHandle;
2139         return result;
2140     }
2141 
2142     /**
2143      * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
2144      * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
2145      * class is unresolvable (in which case a ClassNotFoundException will be
2146      * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
2147      * handle.
2148      */
2149     private Object readOrdinaryObject(boolean unshared)
2150         throws IOException
2151     {
2152         if (bin.readByte() != TC_OBJECT) {
2153             throw new InternalError();
2154         }
2155 
2156         ObjectStreamClass desc = readClassDesc(false);
2157         desc.checkDeserialize();
2158 
2159         Class&lt;?&gt; cl = desc.forClass();
2160         if (cl == String.class || cl == Class.class
2161                 || cl == ObjectStreamClass.class) {
2162             throw new InvalidClassException(&quot;invalid class descriptor&quot;);
2163         }
2164 
2165         Object obj;
2166         try {
2167             obj = desc.isInstantiable() ? desc.newInstance() : null;
2168         } catch (Exception ex) {
2169             throw (IOException) new InvalidClassException(
2170                 desc.forClass().getName(),
2171                 &quot;unable to create instance&quot;).initCause(ex);
2172         }
2173 
2174         passHandle = handles.assign(unshared ? unsharedMarker : obj);
2175         ClassNotFoundException resolveEx = desc.getResolveException();
2176         if (resolveEx != null) {
2177             handles.markException(passHandle, resolveEx);
2178         }
2179 
2180         final boolean isRecord = desc.isRecord();
2181         if (isRecord) {
2182             assert obj == null;
2183             obj = readRecord(desc);
2184             if (!unshared)
2185                 handles.setObject(passHandle, obj);
2186         } else if (desc.isExternalizable()) {
2187             readExternalData((Externalizable) obj, desc);
2188         } else {
2189             readSerialData(obj, desc);
2190         }
2191 
2192         handles.finish(passHandle);
2193 
2194         if (obj != null &amp;&amp;
2195             handles.lookupException(passHandle) == null &amp;&amp;
2196             desc.hasReadResolveMethod())
2197         {
2198             Object rep = desc.invokeReadResolve(obj);
2199             if (unshared &amp;&amp; rep.getClass().isArray()) {
2200                 rep = cloneArray(rep);
2201             }
2202             if (rep != obj) {
2203                 // Filter the replacement object
2204                 if (rep != null) {
2205                     if (rep.getClass().isArray()) {
2206                         filterCheck(rep.getClass(), Array.getLength(rep));
2207                     } else {
2208                         filterCheck(rep.getClass(), -1);
2209                     }
2210                 }
2211                 handles.setObject(passHandle, obj = rep);
2212             }
2213         }
2214 
2215         return obj;
2216     }
2217 
2218     /**
2219      * If obj is non-null, reads externalizable data by invoking readExternal()
2220      * method of obj; otherwise, attempts to skip over externalizable data.
2221      * Expects that passHandle is set to obj&#39;s handle before this method is
2222      * called.
2223      */
2224     private void readExternalData(Externalizable obj, ObjectStreamClass desc)
2225         throws IOException
2226     {
2227         SerialCallbackContext oldContext = curContext;
2228         if (oldContext != null)
2229             oldContext.check();
2230         curContext = null;
2231         try {
2232             boolean blocked = desc.hasBlockExternalData();
2233             if (blocked) {
2234                 bin.setBlockDataMode(true);
2235             }
2236             if (obj != null) {
2237                 try {
2238                     obj.readExternal(this);
2239                 } catch (ClassNotFoundException ex) {
2240                     /*
2241                      * In most cases, the handle table has already propagated
2242                      * a CNFException to passHandle at this point; this mark
2243                      * call is included to address cases where the readExternal
2244                      * method has cons&#39;ed and thrown a new CNFException of its
2245                      * own.
2246                      */
2247                      handles.markException(passHandle, ex);
2248                 }
2249             }
2250             if (blocked) {
2251                 skipCustomData();
2252             }
2253         } finally {
2254             if (oldContext != null)
2255                 oldContext.check();
2256             curContext = oldContext;
2257         }
2258         /*
2259          * At this point, if the externalizable data was not written in
2260          * block-data form and either the externalizable class doesn&#39;t exist
2261          * locally (i.e., obj == null) or readExternal() just threw a
2262          * CNFException, then the stream is probably in an inconsistent state,
2263          * since some (or all) of the externalizable data may not have been
2264          * consumed.  Since there&#39;s no &quot;correct&quot; action to take in this case,
2265          * we mimic the behavior of past serialization implementations and
2266          * blindly hope that the stream is in sync; if it isn&#39;t and additional
2267          * externalizable data remains in the stream, a subsequent read will
2268          * most likely throw a StreamCorruptedException.
2269          */
2270     }
2271 
2272     /** Reads a record. */
2273     private Object readRecord(ObjectStreamClass desc) throws IOException {
2274         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2275         if (slots.length != 1) {
2276             // skip any superclass stream field values
2277             for (int i = 0; i &lt; slots.length-1; i++) {
2278                 ObjectStreamClass slotDesc = slots[i].desc;
2279                 if (slots[i].hasData) {
2280                     defaultReadFields(null, slotDesc);
2281                 }
2282             }
2283         }
2284 
2285         FieldValues fieldValues = defaultReadFields(null, desc);
2286 
2287         // get canonical record constructor adapted to take two arguments:
2288         // - byte[] primValues
2289         // - Object[] objValues
2290         // and return Object
2291         MethodHandle ctrMH = RecordSupport.deserializationCtr(desc);
2292 
2293         try {
2294             return (Object) ctrMH.invokeExact(fieldValues.primValues, fieldValues.objValues);
2295         } catch (Exception e) {
2296             InvalidObjectException ioe = new InvalidObjectException(e.getMessage());
2297             ioe.initCause(e);
2298             throw ioe;
2299         } catch (Error e) {
2300             throw e;
2301         } catch (Throwable t) {
2302             ObjectStreamException ose = new InvalidObjectException(
2303                     &quot;ReflectiveOperationException during deserialization&quot;);
2304             ose.initCause(t);
2305             throw ose;
2306         }
2307     }
2308 
2309     /**
2310      * Reads (or attempts to skip, if obj is null or is tagged with a
2311      * ClassNotFoundException) instance data for each serializable class of
2312      * object in stream, from superclass to subclass.  Expects that passHandle
2313      * is set to obj&#39;s handle before this method is called.
2314      */
2315     private void readSerialData(Object obj, ObjectStreamClass desc)
2316         throws IOException
2317     {
2318         ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
2319         // Best effort Failure Atomicity; slotValues will be non-null if field
2320         // values can be set after reading all field data in the hierarchy.
2321         // Field values can only be set after reading all data if there are no
2322         // user observable methods in the hierarchy, readObject(NoData). The
2323         // top most Serializable class in the hierarchy can be skipped.
2324         FieldValues[] slotValues = null;
2325 
2326         boolean hasSpecialReadMethod = false;
2327         for (int i = 1; i &lt; slots.length; i++) {
2328             ObjectStreamClass slotDesc = slots[i].desc;
2329             if (slotDesc.hasReadObjectMethod()
2330                   || slotDesc.hasReadObjectNoDataMethod()) {
2331                 hasSpecialReadMethod = true;
2332                 break;
2333             }
2334         }
2335         // No special read methods, can store values and defer setting.
2336         if (!hasSpecialReadMethod)
2337             slotValues = new FieldValues[slots.length];
2338 
2339         for (int i = 0; i &lt; slots.length; i++) {
2340             ObjectStreamClass slotDesc = slots[i].desc;
2341 
2342             if (slots[i].hasData) {
2343                 if (obj == null || handles.lookupException(passHandle) != null) {
2344                     defaultReadFields(null, slotDesc); // skip field values
2345                 } else if (slotDesc.hasReadObjectMethod()) {
2346                     ThreadDeath t = null;
2347                     boolean reset = false;
2348                     SerialCallbackContext oldContext = curContext;
2349                     if (oldContext != null)
2350                         oldContext.check();
2351                     try {
2352                         curContext = new SerialCallbackContext(obj, slotDesc);
2353 
2354                         bin.setBlockDataMode(true);
2355                         slotDesc.invokeReadObject(obj, this);
2356                     } catch (ClassNotFoundException ex) {
2357                         /*
2358                          * In most cases, the handle table has already
2359                          * propagated a CNFException to passHandle at this
2360                          * point; this mark call is included to address cases
2361                          * where the custom readObject method has cons&#39;ed and
2362                          * thrown a new CNFException of its own.
2363                          */
2364                         handles.markException(passHandle, ex);
2365                     } finally {
2366                         do {
2367                             try {
2368                                 curContext.setUsed();
2369                                 if (oldContext!= null)
2370                                     oldContext.check();
2371                                 curContext = oldContext;
2372                                 reset = true;
2373                             } catch (ThreadDeath x) {
2374                                 t = x;  // defer until reset is true
2375                             }
2376                         } while (!reset);
2377                         if (t != null)
2378                             throw t;
2379                     }
2380 
2381                     /*
2382                      * defaultDataEnd may have been set indirectly by custom
2383                      * readObject() method when calling defaultReadObject() or
2384                      * readFields(); clear it to restore normal read behavior.
2385                      */
2386                     defaultDataEnd = false;
2387                 } else {
2388                     FieldValues vals = defaultReadFields(obj, slotDesc);
2389                     if (slotValues != null) {
2390                         slotValues[i] = vals;
2391                     } else if (obj != null) {
2392                         defaultCheckFieldValues(obj, slotDesc, vals);
2393                         defaultSetFieldValues(obj, slotDesc, vals);
2394                     }
2395                 }
2396 
2397                 if (slotDesc.hasWriteObjectData()) {
2398                     skipCustomData();
2399                 } else {
2400                     bin.setBlockDataMode(false);
2401                 }
2402             } else {
2403                 if (obj != null &amp;&amp;
2404                     slotDesc.hasReadObjectNoDataMethod() &amp;&amp;
2405                     handles.lookupException(passHandle) == null)
2406                 {
2407                     slotDesc.invokeReadObjectNoData(obj);
2408                 }
2409             }
2410         }
2411 
2412         if (obj != null &amp;&amp; slotValues != null) {
2413             // Check that the non-primitive types are assignable for all slots
2414             // before assigning.
2415             for (int i = 0; i &lt; slots.length; i++) {
2416                 if (slotValues[i] != null)
2417                     defaultCheckFieldValues(obj, slots[i].desc, slotValues[i]);
2418             }
2419             for (int i = 0; i &lt; slots.length; i++) {
2420                 if (slotValues[i] != null)
2421                     defaultSetFieldValues(obj, slots[i].desc, slotValues[i]);
2422             }
2423         }
2424     }
2425 
2426     /**
2427      * Skips over all block data and objects until TC_ENDBLOCKDATA is
2428      * encountered.
2429      */
2430     private void skipCustomData() throws IOException {
2431         int oldHandle = passHandle;
2432         for (;;) {
2433             if (bin.getBlockDataMode()) {
2434                 bin.skipBlockData();
2435                 bin.setBlockDataMode(false);
2436             }
2437             switch (bin.peekByte()) {
2438                 case TC_BLOCKDATA:
2439                 case TC_BLOCKDATALONG:
2440                     bin.setBlockDataMode(true);
2441                     break;
2442 
2443                 case TC_ENDBLOCKDATA:
2444                     bin.readByte();
2445                     passHandle = oldHandle;
2446                     return;
2447 
2448                 default:
2449                     readObject0(Object.class, false);
2450                     break;
2451             }
2452         }
2453     }
2454 
2455     /*package-private*/ class FieldValues {
2456         final byte[] primValues;
2457         final Object[] objValues;
2458 
2459         FieldValues(byte[] primValues, Object[] objValues) {
2460             this.primValues = primValues;
2461             this.objValues = objValues;
2462         }
2463     }
2464 
2465     /**
2466      * Reads in values of serializable fields declared by given class
2467      * descriptor. Expects that passHandle is set to obj&#39;s handle before this
2468      * method is called.
2469      */
2470     private FieldValues defaultReadFields(Object obj, ObjectStreamClass desc)
2471         throws IOException
2472     {
2473         Class&lt;?&gt; cl = desc.forClass();
2474         if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
2475             throw new ClassCastException();
2476         }
2477 
2478         byte[] primVals = null;
2479         int primDataSize = desc.getPrimDataSize();
2480         if (primDataSize &gt; 0) {
2481             primVals = new byte[primDataSize];
2482             bin.readFully(primVals, 0, primDataSize, false);
2483         }
2484 
2485         Object[] objVals = null;
2486         int numObjFields = desc.getNumObjFields();
2487         if (numObjFields &gt; 0) {
2488             int objHandle = passHandle;
2489             ObjectStreamField[] fields = desc.getFields(false);
2490             objVals = new Object[numObjFields];
2491             int numPrimFields = fields.length - objVals.length;
2492             for (int i = 0; i &lt; objVals.length; i++) {
2493                 ObjectStreamField f = fields[numPrimFields + i];
2494                 objVals[i] = readObject0(Object.class, f.isUnshared());
2495                 if (f.getField() != null) {
2496                     handles.markDependency(objHandle, passHandle);
2497                 }
2498             }
2499             passHandle = objHandle;
2500         }
2501 
2502         return new FieldValues(primVals, objVals);
2503     }
2504 
2505     /** Throws ClassCastException if any value is not assignable. */
2506     private void defaultCheckFieldValues(Object obj, ObjectStreamClass desc,
2507                                          FieldValues values) {
2508         Object[] objectValues = values.objValues;
2509         if (objectValues != null)
2510             desc.checkObjFieldValueTypes(obj, objectValues);
2511     }
2512 
2513     /** Sets field values in obj. */
2514     private void defaultSetFieldValues(Object obj, ObjectStreamClass desc,
2515                                        FieldValues values) {
2516         byte[] primValues = values.primValues;
2517         Object[] objectValues = values.objValues;
2518 
2519         if (primValues != null)
2520             desc.setPrimFieldValues(obj, primValues);
2521         if (objectValues != null)
2522             desc.setObjFieldValues(obj, objectValues);
2523     }
2524 
2525     /**
2526      * Reads in and returns IOException that caused serialization to abort.
2527      * All stream state is discarded prior to reading in fatal exception.  Sets
2528      * passHandle to fatal exception&#39;s handle.
2529      */
2530     private IOException readFatalException() throws IOException {
2531         if (bin.readByte() != TC_EXCEPTION) {
2532             throw new InternalError();
2533         }
2534         clear();
2535         return (IOException) readObject0(Object.class, false);
2536     }
2537 
2538     /**
2539      * If recursion depth is 0, clears internal data structures; otherwise,
2540      * throws a StreamCorruptedException.  This method is called when a
2541      * TC_RESET typecode is encountered.
2542      */
2543     private void handleReset() throws StreamCorruptedException {
2544         if (depth &gt; 0) {
2545             throw new StreamCorruptedException(
2546                 &quot;unexpected reset; recursion depth: &quot; + depth);
2547         }
2548         clear();
2549     }
2550 
2551     /**
2552      * Returns the first non-null and non-platform class loader (not counting
2553      * class loaders of generated reflection implementation classes) up the
2554      * execution stack, or the platform class loader if only code from the
2555      * bootstrap and platform class loader is on the stack.
2556      */
2557     private static ClassLoader latestUserDefinedLoader() {
2558         return jdk.internal.misc.VM.latestUserDefinedLoader();
2559     }
2560 
2561     /**
2562      * Default GetField implementation.
2563      */
2564     private class GetFieldImpl extends GetField {
2565 
2566         /** class descriptor describing serializable fields */
2567         private final ObjectStreamClass desc;
2568         /** primitive field values */
2569         private final byte[] primVals;
2570         /** object field values */
2571         private final Object[] objVals;
2572         /** object field value handles */
2573         private final int[] objHandles;
2574 
2575         /**
2576          * Creates GetFieldImpl object for reading fields defined in given
2577          * class descriptor.
2578          */
2579         GetFieldImpl(ObjectStreamClass desc) {
2580             this.desc = desc;
2581             primVals = new byte[desc.getPrimDataSize()];
2582             objVals = new Object[desc.getNumObjFields()];
2583             objHandles = new int[objVals.length];
2584         }
2585 
2586         public ObjectStreamClass getObjectStreamClass() {
2587             return desc;
2588         }
2589 
2590         public boolean defaulted(String name) throws IOException {
2591             return (getFieldOffset(name, null) &lt; 0);
2592         }
2593 
2594         public boolean get(String name, boolean val) throws IOException {
2595             int off = getFieldOffset(name, Boolean.TYPE);
2596             return (off &gt;= 0) ? Bits.getBoolean(primVals, off) : val;
2597         }
2598 
2599         public byte get(String name, byte val) throws IOException {
2600             int off = getFieldOffset(name, Byte.TYPE);
2601             return (off &gt;= 0) ? primVals[off] : val;
2602         }
2603 
2604         public char get(String name, char val) throws IOException {
2605             int off = getFieldOffset(name, Character.TYPE);
2606             return (off &gt;= 0) ? Bits.getChar(primVals, off) : val;
2607         }
2608 
2609         public short get(String name, short val) throws IOException {
2610             int off = getFieldOffset(name, Short.TYPE);
2611             return (off &gt;= 0) ? Bits.getShort(primVals, off) : val;
2612         }
2613 
2614         public int get(String name, int val) throws IOException {
2615             int off = getFieldOffset(name, Integer.TYPE);
2616             return (off &gt;= 0) ? Bits.getInt(primVals, off) : val;
2617         }
2618 
2619         public float get(String name, float val) throws IOException {
2620             int off = getFieldOffset(name, Float.TYPE);
2621             return (off &gt;= 0) ? Bits.getFloat(primVals, off) : val;
2622         }
2623 
2624         public long get(String name, long val) throws IOException {
2625             int off = getFieldOffset(name, Long.TYPE);
2626             return (off &gt;= 0) ? Bits.getLong(primVals, off) : val;
2627         }
2628 
2629         public double get(String name, double val) throws IOException {
2630             int off = getFieldOffset(name, Double.TYPE);
2631             return (off &gt;= 0) ? Bits.getDouble(primVals, off) : val;
2632         }
2633 
2634         public Object get(String name, Object val) throws IOException {
2635             int off = getFieldOffset(name, Object.class);
2636             if (off &gt;= 0) {
2637                 int objHandle = objHandles[off];
2638                 handles.markDependency(passHandle, objHandle);
2639                 return (handles.lookupException(objHandle) == null) ?
2640                     objVals[off] : null;
2641             } else {
2642                 return val;
2643             }
2644         }
2645 
2646         /**
2647          * Reads primitive and object field values from stream.
2648          */
2649         void readFields() throws IOException {
2650             bin.readFully(primVals, 0, primVals.length, false);
2651 
2652             int oldHandle = passHandle;
2653             ObjectStreamField[] fields = desc.getFields(false);
2654             int numPrimFields = fields.length - objVals.length;
2655             for (int i = 0; i &lt; objVals.length; i++) {
2656                 objVals[i] =
2657                     readObject0(Object.class, fields[numPrimFields + i].isUnshared());
2658                 objHandles[i] = passHandle;
2659             }
2660             passHandle = oldHandle;
2661         }
2662 
2663         /**
2664          * Returns offset of field with given name and type.  A specified type
2665          * of null matches all types, Object.class matches all non-primitive
2666          * types, and any other non-null type matches assignable types only.
2667          * If no matching field is found in the (incoming) class
2668          * descriptor but a matching field is present in the associated local
2669          * class descriptor, returns -1.  Throws IllegalArgumentException if
2670          * neither incoming nor local class descriptor contains a match.
2671          */
2672         private int getFieldOffset(String name, Class&lt;?&gt; type) {
2673             ObjectStreamField field = desc.getField(name, type);
2674             if (field != null) {
2675                 return field.getOffset();
2676             } else if (desc.getLocalDesc().getField(name, type) != null) {
2677                 return -1;
2678             } else {
2679                 throw new IllegalArgumentException(&quot;no such field &quot; + name +
2680                                                    &quot; with type &quot; + type);
2681             }
2682         }
2683     }
2684 
2685     /**
2686      * Prioritized list of callbacks to be performed once object graph has been
2687      * completely deserialized.
2688      */
2689     private static class ValidationList {
2690 
2691         private static class Callback {
2692             final ObjectInputValidation obj;
2693             final int priority;
2694             Callback next;
2695             final AccessControlContext acc;
2696 
2697             Callback(ObjectInputValidation obj, int priority, Callback next,
2698                 AccessControlContext acc)
2699             {
2700                 this.obj = obj;
2701                 this.priority = priority;
2702                 this.next = next;
2703                 this.acc = acc;
2704             }
2705         }
2706 
2707         /** linked list of callbacks */
2708         private Callback list;
2709 
2710         /**
2711          * Creates new (empty) ValidationList.
2712          */
2713         ValidationList() {
2714         }
2715 
2716         /**
2717          * Registers callback.  Throws InvalidObjectException if callback
2718          * object is null.
2719          */
2720         void register(ObjectInputValidation obj, int priority)
2721             throws InvalidObjectException
2722         {
2723             if (obj == null) {
2724                 throw new InvalidObjectException(&quot;null callback&quot;);
2725             }
2726 
2727             Callback prev = null, cur = list;
2728             while (cur != null &amp;&amp; priority &lt; cur.priority) {
2729                 prev = cur;
2730                 cur = cur.next;
2731             }
2732             AccessControlContext acc = AccessController.getContext();
2733             if (prev != null) {
2734                 prev.next = new Callback(obj, priority, cur, acc);
2735             } else {
2736                 list = new Callback(obj, priority, list, acc);
2737             }
2738         }
2739 
2740         /**
2741          * Invokes all registered callbacks and clears the callback list.
2742          * Callbacks with higher priorities are called first; those with equal
2743          * priorities may be called in any order.  If any of the callbacks
2744          * throws an InvalidObjectException, the callback process is terminated
2745          * and the exception propagated upwards.
2746          */
2747         void doCallbacks() throws InvalidObjectException {
2748             try {
2749                 while (list != null) {
2750                     AccessController.doPrivileged(
2751                         new PrivilegedExceptionAction&lt;Void&gt;()
2752                     {
2753                         public Void run() throws InvalidObjectException {
2754                             list.obj.validateObject();
2755                             return null;
2756                         }
2757                     }, list.acc);
2758                     list = list.next;
2759                 }
2760             } catch (PrivilegedActionException ex) {
2761                 list = null;
2762                 throw (InvalidObjectException) ex.getException();
2763             }
2764         }
2765 
2766         /**
2767          * Resets the callback list to its initial (empty) state.
2768          */
2769         public void clear() {
2770             list = null;
2771         }
2772     }
2773 
2774     /**
2775      * Hold a snapshot of values to be passed to an ObjectInputFilter.
2776      */
2777     static class FilterValues implements ObjectInputFilter.FilterInfo {
2778         final Class&lt;?&gt; clazz;
2779         final long arrayLength;
2780         final long totalObjectRefs;
2781         final long depth;
2782         final long streamBytes;
2783 
2784         public FilterValues(Class&lt;?&gt; clazz, long arrayLength, long totalObjectRefs,
2785                             long depth, long streamBytes) {
2786             this.clazz = clazz;
2787             this.arrayLength = arrayLength;
2788             this.totalObjectRefs = totalObjectRefs;
2789             this.depth = depth;
2790             this.streamBytes = streamBytes;
2791         }
2792 
2793         @Override
2794         public Class&lt;?&gt; serialClass() {
2795             return clazz;
2796         }
2797 
2798         @Override
2799         public long arrayLength() {
2800             return arrayLength;
2801         }
2802 
2803         @Override
2804         public long references() {
2805             return totalObjectRefs;
2806         }
2807 
2808         @Override
2809         public long depth() {
2810             return depth;
2811         }
2812 
2813         @Override
2814         public long streamBytes() {
2815             return streamBytes;
2816         }
2817     }
2818 
2819     /**
2820      * Input stream supporting single-byte peek operations.
2821      */
2822     private static class PeekInputStream extends InputStream {
2823 
2824         /** underlying stream */
2825         private final InputStream in;
2826         /** peeked byte */
2827         private int peekb = -1;
2828         /** total bytes read from the stream */
2829         private long totalBytesRead = 0;
2830 
2831         /**
2832          * Creates new PeekInputStream on top of given underlying stream.
2833          */
2834         PeekInputStream(InputStream in) {
2835             this.in = in;
2836         }
2837 
2838         /**
2839          * Peeks at next byte value in stream.  Similar to read(), except
2840          * that it does not consume the read value.
2841          */
2842         int peek() throws IOException {
2843             if (peekb &gt;= 0) {
2844                 return peekb;
2845             }
2846             peekb = in.read();
2847             totalBytesRead += peekb &gt;= 0 ? 1 : 0;
2848             return peekb;
2849         }
2850 
2851         public int read() throws IOException {
2852             if (peekb &gt;= 0) {
2853                 int v = peekb;
2854                 peekb = -1;
2855                 return v;
2856             } else {
2857                 int nbytes = in.read();
2858                 totalBytesRead += nbytes &gt;= 0 ? 1 : 0;
2859                 return nbytes;
2860             }
2861         }
2862 
2863         public int read(byte[] b, int off, int len) throws IOException {
2864             int nbytes;
2865             if (len == 0) {
2866                 return 0;
2867             } else if (peekb &lt; 0) {
2868                 nbytes = in.read(b, off, len);
2869                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2870                 return nbytes;
2871             } else {
2872                 b[off++] = (byte) peekb;
2873                 len--;
2874                 peekb = -1;
2875                 nbytes = in.read(b, off, len);
2876                 totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
2877                 return (nbytes &gt;= 0) ? (nbytes + 1) : 1;
2878             }
2879         }
2880 
2881         void readFully(byte[] b, int off, int len) throws IOException {
2882             int n = 0;
2883             while (n &lt; len) {
2884                 int count = read(b, off + n, len - n);
2885                 if (count &lt; 0) {
2886                     throw new EOFException();
2887                 }
2888                 n += count;
2889             }
2890         }
2891 
2892         public long skip(long n) throws IOException {
2893             if (n &lt;= 0) {
2894                 return 0;
2895             }
2896             int skipped = 0;
2897             if (peekb &gt;= 0) {
2898                 peekb = -1;
2899                 skipped++;
2900                 n--;
2901             }
2902             n = skipped + in.skip(n);
2903             totalBytesRead += n;
2904             return n;
2905         }
2906 
2907         public int available() throws IOException {
2908             return in.available() + ((peekb &gt;= 0) ? 1 : 0);
2909         }
2910 
2911         public void close() throws IOException {
2912             in.close();
2913         }
2914 
2915         public long getBytesRead() {
2916             return totalBytesRead;
2917         }
2918     }
2919 
2920     private static final Unsafe UNSAFE = Unsafe.getUnsafe();
2921 
2922     /**
2923      * Performs a &quot;freeze&quot; action, required to adhere to final field semantics.
2924      *
2925      * &lt;p&gt; This method can be called unconditionally before returning the graph,
2926      * from the topmost readObject call, since it is expected that the
2927      * additional cost of the freeze action is negligible compared to
2928      * reconstituting even the most simple graph.
2929      *
2930      * &lt;p&gt; Nested calls to readObject do not issue freeze actions because the
2931      * sub-graph returned from a nested call is not guaranteed to be fully
2932      * initialized yet (possible cycles).
2933      */
2934     private void freeze() {
2935         // Issue a StoreStore|StoreLoad fence, which is at least sufficient
2936         // to provide final-freeze semantics.
2937         UNSAFE.storeFence();
2938     }
2939 
2940     /**
2941      * Input stream with two modes: in default mode, inputs data written in the
2942      * same format as DataOutputStream; in &quot;block data&quot; mode, inputs data
2943      * bracketed by block data markers (see object serialization specification
2944      * for details).  Buffering depends on block data mode: when in default
2945      * mode, no data is buffered in advance; when in block data mode, all data
2946      * for the current data block is read in at once (and buffered).
2947      */
2948     private class BlockDataInputStream
2949         extends InputStream implements DataInput
2950     {
2951         /** maximum data block length */
2952         private static final int MAX_BLOCK_SIZE = 1024;
2953         /** maximum data block header length */
2954         private static final int MAX_HEADER_SIZE = 5;
2955         /** (tunable) length of char buffer (for reading strings) */
2956         private static final int CHAR_BUF_SIZE = 256;
2957         /** readBlockHeader() return value indicating header read may block */
2958         private static final int HEADER_BLOCKED = -2;
2959 
2960         /** buffer for reading general/block data */
2961         private final byte[] buf = new byte[MAX_BLOCK_SIZE];
2962         /** buffer for reading block data headers */
2963         private final byte[] hbuf = new byte[MAX_HEADER_SIZE];
2964         /** char buffer for fast string reads */
2965         private final char[] cbuf = new char[CHAR_BUF_SIZE];
2966 
2967         /** block data mode */
2968         private boolean blkmode = false;
2969 
2970         // block data state fields; values meaningful only when blkmode true
2971         /** current offset into buf */
2972         private int pos = 0;
2973         /** end offset of valid data in buf, or -1 if no more block data */
2974         private int end = -1;
2975         /** number of bytes in current block yet to be read from stream */
2976         private int unread = 0;
2977 
2978         /** underlying stream (wrapped in peekable filter stream) */
2979         private final PeekInputStream in;
2980         /** loopback stream (for data reads that span data blocks) */
2981         private final DataInputStream din;
2982 
2983         /**
2984          * Creates new BlockDataInputStream on top of given underlying stream.
2985          * Block data mode is turned off by default.
2986          */
2987         BlockDataInputStream(InputStream in) {
2988             this.in = new PeekInputStream(in);
2989             din = new DataInputStream(this);
2990         }
2991 
2992         /**
2993          * Sets block data mode to the given mode (true == on, false == off)
2994          * and returns the previous mode value.  If the new mode is the same as
2995          * the old mode, no action is taken.  Throws IllegalStateException if
2996          * block data mode is being switched from on to off while unconsumed
2997          * block data is still present in the stream.
2998          */
2999         boolean setBlockDataMode(boolean newmode) throws IOException {
3000             if (blkmode == newmode) {
3001                 return blkmode;
3002             }
3003             if (newmode) {
3004                 pos = 0;
3005                 end = 0;
3006                 unread = 0;
3007             } else if (pos &lt; end) {
3008                 throw new IllegalStateException(&quot;unread block data&quot;);
3009             }
3010             blkmode = newmode;
3011             return !blkmode;
3012         }
3013 
3014         /**
3015          * Returns true if the stream is currently in block data mode, false
3016          * otherwise.
3017          */
3018         boolean getBlockDataMode() {
3019             return blkmode;
3020         }
3021 
3022         /**
3023          * If in block data mode, skips to the end of the current group of data
3024          * blocks (but does not unset block data mode).  If not in block data
3025          * mode, throws an IllegalStateException.
3026          */
3027         void skipBlockData() throws IOException {
3028             if (!blkmode) {
3029                 throw new IllegalStateException(&quot;not in block data mode&quot;);
3030             }
3031             while (end &gt;= 0) {
3032                 refill();
3033             }
3034         }
3035 
3036         /**
3037          * Attempts to read in the next block data header (if any).  If
3038          * canBlock is false and a full header cannot be read without possibly
3039          * blocking, returns HEADER_BLOCKED, else if the next element in the
3040          * stream is a block data header, returns the block data length
3041          * specified by the header, else returns -1.
3042          */
3043         private int readBlockHeader(boolean canBlock) throws IOException {
3044             if (defaultDataEnd) {
3045                 /*
3046                  * Fix for 4360508: stream is currently at the end of a field
3047                  * value block written via default serialization; since there
3048                  * is no terminating TC_ENDBLOCKDATA tag, simulate
3049                  * end-of-custom-data behavior explicitly.
3050                  */
3051                 return -1;
3052             }
3053             try {
3054                 for (;;) {
3055                     int avail = canBlock ? Integer.MAX_VALUE : in.available();
3056                     if (avail == 0) {
3057                         return HEADER_BLOCKED;
3058                     }
3059 
3060                     int tc = in.peek();
3061                     switch (tc) {
3062                         case TC_BLOCKDATA:
3063                             if (avail &lt; 2) {
3064                                 return HEADER_BLOCKED;
3065                             }
3066                             in.readFully(hbuf, 0, 2);
3067                             return hbuf[1] &amp; 0xFF;
3068 
3069                         case TC_BLOCKDATALONG:
3070                             if (avail &lt; 5) {
3071                                 return HEADER_BLOCKED;
3072                             }
3073                             in.readFully(hbuf, 0, 5);
3074                             int len = Bits.getInt(hbuf, 1);
3075                             if (len &lt; 0) {
3076                                 throw new StreamCorruptedException(
3077                                     &quot;illegal block data header length: &quot; +
3078                                     len);
3079                             }
3080                             return len;
3081 
3082                         /*
3083                          * TC_RESETs may occur in between data blocks.
3084                          * Unfortunately, this case must be parsed at a lower
3085                          * level than other typecodes, since primitive data
3086                          * reads may span data blocks separated by a TC_RESET.
3087                          */
3088                         case TC_RESET:
3089                             in.read();
3090                             handleReset();
3091                             break;
3092 
3093                         default:
3094                             if (tc &gt;= 0 &amp;&amp; (tc &lt; TC_BASE || tc &gt; TC_MAX)) {
3095                                 throw new StreamCorruptedException(
3096                                     String.format(&quot;invalid type code: %02X&quot;,
3097                                     tc));
3098                             }
3099                             return -1;
3100                     }
3101                 }
3102             } catch (EOFException ex) {
3103                 throw new StreamCorruptedException(
3104                     &quot;unexpected EOF while reading block data header&quot;);
3105             }
3106         }
3107 
3108         /**
3109          * Refills internal buffer buf with block data.  Any data in buf at the
3110          * time of the call is considered consumed.  Sets the pos, end, and
3111          * unread fields to reflect the new amount of available block data; if
3112          * the next element in the stream is not a data block, sets pos and
3113          * unread to 0 and end to -1.
3114          */
3115         private void refill() throws IOException {
3116             try {
3117                 do {
3118                     pos = 0;
3119                     if (unread &gt; 0) {
3120                         int n =
3121                             in.read(buf, 0, Math.min(unread, MAX_BLOCK_SIZE));
3122                         if (n &gt;= 0) {
3123                             end = n;
3124                             unread -= n;
3125                         } else {
3126                             throw new StreamCorruptedException(
3127                                 &quot;unexpected EOF in middle of data block&quot;);
3128                         }
3129                     } else {
3130                         int n = readBlockHeader(true);
3131                         if (n &gt;= 0) {
3132                             end = 0;
3133                             unread = n;
3134                         } else {
3135                             end = -1;
3136                             unread = 0;
3137                         }
3138                     }
3139                 } while (pos == end);
3140             } catch (IOException ex) {
3141                 pos = 0;
3142                 end = -1;
3143                 unread = 0;
3144                 throw ex;
3145             }
3146         }
3147 
3148         /**
3149          * If in block data mode, returns the number of unconsumed bytes
3150          * remaining in the current data block.  If not in block data mode,
3151          * throws an IllegalStateException.
3152          */
3153         int currentBlockRemaining() {
3154             if (blkmode) {
3155                 return (end &gt;= 0) ? (end - pos) + unread : 0;
3156             } else {
3157                 throw new IllegalStateException();
3158             }
3159         }
3160 
3161         /**
3162          * Peeks at (but does not consume) and returns the next byte value in
3163          * the stream, or -1 if the end of the stream/block data (if in block
3164          * data mode) has been reached.
3165          */
3166         int peek() throws IOException {
3167             if (blkmode) {
3168                 if (pos == end) {
3169                     refill();
3170                 }
3171                 return (end &gt;= 0) ? (buf[pos] &amp; 0xFF) : -1;
3172             } else {
3173                 return in.peek();
3174             }
3175         }
3176 
3177         /**
3178          * Peeks at (but does not consume) and returns the next byte value in
3179          * the stream, or throws EOFException if end of stream/block data has
3180          * been reached.
3181          */
3182         byte peekByte() throws IOException {
3183             int val = peek();
3184             if (val &lt; 0) {
3185                 throw new EOFException();
3186             }
3187             return (byte) val;
3188         }
3189 
3190 
3191         /* ----------------- generic input stream methods ------------------ */
3192         /*
3193          * The following methods are equivalent to their counterparts in
3194          * InputStream, except that they interpret data block boundaries and
3195          * read the requested data from within data blocks when in block data
3196          * mode.
3197          */
3198 
3199         public int read() throws IOException {
3200             if (blkmode) {
3201                 if (pos == end) {
3202                     refill();
3203                 }
3204                 return (end &gt;= 0) ? (buf[pos++] &amp; 0xFF) : -1;
3205             } else {
3206                 return in.read();
3207             }
3208         }
3209 
3210         public int read(byte[] b, int off, int len) throws IOException {
3211             return read(b, off, len, false);
3212         }
3213 
3214         public long skip(long len) throws IOException {
3215             long remain = len;
3216             while (remain &gt; 0) {
3217                 if (blkmode) {
3218                     if (pos == end) {
3219                         refill();
3220                     }
3221                     if (end &lt; 0) {
3222                         break;
3223                     }
3224                     int nread = (int) Math.min(remain, end - pos);
3225                     remain -= nread;
3226                     pos += nread;
3227                 } else {
3228                     int nread = (int) Math.min(remain, MAX_BLOCK_SIZE);
3229                     if ((nread = in.read(buf, 0, nread)) &lt; 0) {
3230                         break;
3231                     }
3232                     remain -= nread;
3233                 }
3234             }
3235             return len - remain;
3236         }
3237 
3238         public int available() throws IOException {
3239             if (blkmode) {
3240                 if ((pos == end) &amp;&amp; (unread == 0)) {
3241                     int n;
3242                     while ((n = readBlockHeader(false)) == 0) ;
3243                     switch (n) {
3244                         case HEADER_BLOCKED:
3245                             break;
3246 
3247                         case -1:
3248                             pos = 0;
3249                             end = -1;
3250                             break;
3251 
3252                         default:
3253                             pos = 0;
3254                             end = 0;
3255                             unread = n;
3256                             break;
3257                     }
3258                 }
3259                 // avoid unnecessary call to in.available() if possible
3260                 int unreadAvail = (unread &gt; 0) ?
3261                     Math.min(in.available(), unread) : 0;
3262                 return (end &gt;= 0) ? (end - pos) + unreadAvail : 0;
3263             } else {
3264                 return in.available();
3265             }
3266         }
3267 
3268         public void close() throws IOException {
3269             if (blkmode) {
3270                 pos = 0;
3271                 end = -1;
3272                 unread = 0;
3273             }
3274             in.close();
3275         }
3276 
3277         /**
3278          * Attempts to read len bytes into byte array b at offset off.  Returns
3279          * the number of bytes read, or -1 if the end of stream/block data has
3280          * been reached.  If copy is true, reads values into an intermediate
3281          * buffer before copying them to b (to avoid exposing a reference to
3282          * b).
3283          */
3284         int read(byte[] b, int off, int len, boolean copy) throws IOException {
3285             if (len == 0) {
3286                 return 0;
3287             } else if (blkmode) {
3288                 if (pos == end) {
3289                     refill();
3290                 }
3291                 if (end &lt; 0) {
3292                     return -1;
3293                 }
3294                 int nread = Math.min(len, end - pos);
3295                 System.arraycopy(buf, pos, b, off, nread);
3296                 pos += nread;
3297                 return nread;
3298             } else if (copy) {
3299                 int nread = in.read(buf, 0, Math.min(len, MAX_BLOCK_SIZE));
3300                 if (nread &gt; 0) {
3301                     System.arraycopy(buf, 0, b, off, nread);
3302                 }
3303                 return nread;
3304             } else {
3305                 return in.read(b, off, len);
3306             }
3307         }
3308 
3309         /* ----------------- primitive data input methods ------------------ */
3310         /*
3311          * The following methods are equivalent to their counterparts in
3312          * DataInputStream, except that they interpret data block boundaries
3313          * and read the requested data from within data blocks when in block
3314          * data mode.
3315          */
3316 
3317         public void readFully(byte[] b) throws IOException {
3318             readFully(b, 0, b.length, false);
3319         }
3320 
3321         public void readFully(byte[] b, int off, int len) throws IOException {
3322             readFully(b, off, len, false);
3323         }
3324 
3325         public void readFully(byte[] b, int off, int len, boolean copy)
3326             throws IOException
3327         {
3328             while (len &gt; 0) {
3329                 int n = read(b, off, len, copy);
3330                 if (n &lt; 0) {
3331                     throw new EOFException();
3332                 }
3333                 off += n;
3334                 len -= n;
3335             }
3336         }
3337 
3338         public int skipBytes(int n) throws IOException {
3339             return din.skipBytes(n);
3340         }
3341 
3342         public boolean readBoolean() throws IOException {
3343             int v = read();
3344             if (v &lt; 0) {
3345                 throw new EOFException();
3346             }
3347             return (v != 0);
3348         }
3349 
3350         public byte readByte() throws IOException {
3351             int v = read();
3352             if (v &lt; 0) {
3353                 throw new EOFException();
3354             }
3355             return (byte) v;
3356         }
3357 
3358         public int readUnsignedByte() throws IOException {
3359             int v = read();
3360             if (v &lt; 0) {
3361                 throw new EOFException();
3362             }
3363             return v;
3364         }
3365 
3366         public char readChar() throws IOException {
3367             if (!blkmode) {
3368                 pos = 0;
3369                 in.readFully(buf, 0, 2);
3370             } else if (end - pos &lt; 2) {
3371                 return din.readChar();
3372             }
3373             char v = Bits.getChar(buf, pos);
3374             pos += 2;
3375             return v;
3376         }
3377 
3378         public short readShort() throws IOException {
3379             if (!blkmode) {
3380                 pos = 0;
3381                 in.readFully(buf, 0, 2);
3382             } else if (end - pos &lt; 2) {
3383                 return din.readShort();
3384             }
3385             short v = Bits.getShort(buf, pos);
3386             pos += 2;
3387             return v;
3388         }
3389 
3390         public int readUnsignedShort() throws IOException {
3391             if (!blkmode) {
3392                 pos = 0;
3393                 in.readFully(buf, 0, 2);
3394             } else if (end - pos &lt; 2) {
3395                 return din.readUnsignedShort();
3396             }
3397             int v = Bits.getShort(buf, pos) &amp; 0xFFFF;
3398             pos += 2;
3399             return v;
3400         }
3401 
3402         public int readInt() throws IOException {
3403             if (!blkmode) {
3404                 pos = 0;
3405                 in.readFully(buf, 0, 4);
3406             } else if (end - pos &lt; 4) {
3407                 return din.readInt();
3408             }
3409             int v = Bits.getInt(buf, pos);
3410             pos += 4;
3411             return v;
3412         }
3413 
3414         public float readFloat() throws IOException {
3415             if (!blkmode) {
3416                 pos = 0;
3417                 in.readFully(buf, 0, 4);
3418             } else if (end - pos &lt; 4) {
3419                 return din.readFloat();
3420             }
3421             float v = Bits.getFloat(buf, pos);
3422             pos += 4;
3423             return v;
3424         }
3425 
3426         public long readLong() throws IOException {
3427             if (!blkmode) {
3428                 pos = 0;
3429                 in.readFully(buf, 0, 8);
3430             } else if (end - pos &lt; 8) {
3431                 return din.readLong();
3432             }
3433             long v = Bits.getLong(buf, pos);
3434             pos += 8;
3435             return v;
3436         }
3437 
3438         public double readDouble() throws IOException {
3439             if (!blkmode) {
3440                 pos = 0;
3441                 in.readFully(buf, 0, 8);
3442             } else if (end - pos &lt; 8) {
3443                 return din.readDouble();
3444             }
3445             double v = Bits.getDouble(buf, pos);
3446             pos += 8;
3447             return v;
3448         }
3449 
3450         public String readUTF() throws IOException {
3451             return readUTFBody(readUnsignedShort());
3452         }
3453 
3454         @SuppressWarnings(&quot;deprecation&quot;)
3455         public String readLine() throws IOException {
3456             return din.readLine();      // deprecated, not worth optimizing
3457         }
3458 
3459         /* -------------- primitive data array input methods --------------- */
3460         /*
3461          * The following methods read in spans of primitive data values.
3462          * Though equivalent to calling the corresponding primitive read
3463          * methods repeatedly, these methods are optimized for reading groups
3464          * of primitive data values more efficiently.
3465          */
3466 
3467         void readBooleans(boolean[] v, int off, int len) throws IOException {
3468             int stop, endoff = off + len;
3469             while (off &lt; endoff) {
3470                 if (!blkmode) {
3471                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE);
3472                     in.readFully(buf, 0, span);
3473                     stop = off + span;
3474                     pos = 0;
3475                 } else if (end - pos &lt; 1) {
3476                     v[off++] = din.readBoolean();
3477                     continue;
3478                 } else {
3479                     stop = Math.min(endoff, off + end - pos);
3480                 }
3481 
3482                 while (off &lt; stop) {
3483                     v[off++] = Bits.getBoolean(buf, pos++);
3484                 }
3485             }
3486         }
3487 
3488         void readChars(char[] v, int off, int len) throws IOException {
3489             int stop, endoff = off + len;
3490             while (off &lt; endoff) {
3491                 if (!blkmode) {
3492                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3493                     in.readFully(buf, 0, span &lt;&lt; 1);
3494                     stop = off + span;
3495                     pos = 0;
3496                 } else if (end - pos &lt; 2) {
3497                     v[off++] = din.readChar();
3498                     continue;
3499                 } else {
3500                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3501                 }
3502 
3503                 while (off &lt; stop) {
3504                     v[off++] = Bits.getChar(buf, pos);
3505                     pos += 2;
3506                 }
3507             }
3508         }
3509 
3510         void readShorts(short[] v, int off, int len) throws IOException {
3511             int stop, endoff = off + len;
3512             while (off &lt; endoff) {
3513                 if (!blkmode) {
3514                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);
3515                     in.readFully(buf, 0, span &lt;&lt; 1);
3516                     stop = off + span;
3517                     pos = 0;
3518                 } else if (end - pos &lt; 2) {
3519                     v[off++] = din.readShort();
3520                     continue;
3521                 } else {
3522                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
3523                 }
3524 
3525                 while (off &lt; stop) {
3526                     v[off++] = Bits.getShort(buf, pos);
3527                     pos += 2;
3528                 }
3529             }
3530         }
3531 
3532         void readInts(int[] v, int off, int len) throws IOException {
3533             int stop, endoff = off + len;
3534             while (off &lt; endoff) {
3535                 if (!blkmode) {
3536                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3537                     in.readFully(buf, 0, span &lt;&lt; 2);
3538                     stop = off + span;
3539                     pos = 0;
3540                 } else if (end - pos &lt; 4) {
3541                     v[off++] = din.readInt();
3542                     continue;
3543                 } else {
3544                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));
3545                 }
3546 
3547                 while (off &lt; stop) {
3548                     v[off++] = Bits.getInt(buf, pos);
3549                     pos += 4;
3550                 }
3551             }
3552         }
3553 
3554         void readFloats(float[] v, int off, int len) throws IOException {
3555             int stop, endoff = off + len;
3556             while (off &lt; endoff) {
3557                 if (!blkmode) {
3558                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);
3559                     in.readFully(buf, 0, span &lt;&lt; 2);
3560                     stop = off + span;
3561                     pos = 0;
3562                 } else if (end - pos &lt; 4) {
3563                     v[off++] = din.readFloat();
3564                     continue;
3565                 } else {
3566                     stop = Math.min(endoff, ((end - pos) &gt;&gt; 2));
3567                 }
3568 
3569                 while (off &lt; stop) {
3570                     v[off++] = Bits.getFloat(buf, pos);
3571                     pos += 4;
3572                 }
3573             }
3574         }
3575 
3576         void readLongs(long[] v, int off, int len) throws IOException {
3577             int stop, endoff = off + len;
3578             while (off &lt; endoff) {
3579                 if (!blkmode) {
3580                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3581                     in.readFully(buf, 0, span &lt;&lt; 3);
3582                     stop = off + span;
3583                     pos = 0;
3584                 } else if (end - pos &lt; 8) {
3585                     v[off++] = din.readLong();
3586                     continue;
3587                 } else {
3588                     stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));
3589                 }
3590 
3591                 while (off &lt; stop) {
3592                     v[off++] = Bits.getLong(buf, pos);
3593                     pos += 8;
3594                 }
3595             }
3596         }
3597 
3598         void readDoubles(double[] v, int off, int len) throws IOException {
3599             int stop, endoff = off + len;
3600             while (off &lt; endoff) {
3601                 if (!blkmode) {
3602                     int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
3603                     in.readFully(buf, 0, span &lt;&lt; 3);
3604                     stop = off + span;
3605                     pos = 0;
3606                 } else if (end - pos &lt; 8) {
3607                     v[off++] = din.readDouble();
3608                     continue;
3609                 } else {
3610                     stop = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));
3611                 }
3612 
3613                 while (off &lt; stop) {
3614                     v[off++] = Bits.getDouble(buf, pos);
3615                     pos += 8;
3616                 }
3617             }
3618         }
3619 
3620         /**
3621          * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
3622          * identical to standard UTF, except that it uses an 8 byte header
3623          * (instead of the standard 2 bytes) to convey the UTF encoding length.
3624          */
3625         String readLongUTF() throws IOException {
3626             return readUTFBody(readLong());
3627         }
3628 
3629         /**
3630          * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
3631          * or 8-byte length header) of a UTF encoding, which occupies the next
3632          * utflen bytes.
3633          */
3634         private String readUTFBody(long utflen) throws IOException {
3635             StringBuilder sbuf;
3636             if (utflen &gt; 0 &amp;&amp; utflen &lt; Integer.MAX_VALUE) {
3637                 // a reasonable initial capacity based on the UTF length
3638                 int initialCapacity = Math.min((int)utflen, 0xFFFF);
3639                 sbuf = new StringBuilder(initialCapacity);
3640             } else {
3641                 sbuf = new StringBuilder();
3642             }
3643 
3644             if (!blkmode) {
3645                 end = pos = 0;
3646             }
3647 
3648             while (utflen &gt; 0) {
3649                 int avail = end - pos;
3650                 if (avail &gt;= 3 || (long) avail == utflen) {
3651                     utflen -= readUTFSpan(sbuf, utflen);
3652                 } else {
3653                     if (blkmode) {
3654                         // near block boundary, read one byte at a time
3655                         utflen -= readUTFChar(sbuf, utflen);
3656                     } else {
3657                         // shift and refill buffer manually
3658                         if (avail &gt; 0) {
3659                             System.arraycopy(buf, pos, buf, 0, avail);
3660                         }
3661                         pos = 0;
3662                         end = (int) Math.min(MAX_BLOCK_SIZE, utflen);
3663                         in.readFully(buf, avail, end - avail);
3664                     }
3665                 }
3666             }
3667 
3668             return sbuf.toString();
3669         }
3670 
3671         /**
3672          * Reads span of UTF-encoded characters out of internal buffer
3673          * (starting at offset pos and ending at or before offset end),
3674          * consuming no more than utflen bytes.  Appends read characters to
3675          * sbuf.  Returns the number of bytes consumed.
3676          */
3677         private long readUTFSpan(StringBuilder sbuf, long utflen)
3678             throws IOException
3679         {
3680             int cpos = 0;
3681             int start = pos;
3682             int avail = Math.min(end - pos, CHAR_BUF_SIZE);
3683             // stop short of last char unless all of utf bytes in buffer
3684             int stop = pos + ((utflen &gt; avail) ? avail - 2 : (int) utflen);
3685             boolean outOfBounds = false;
3686 
3687             try {
3688                 while (pos &lt; stop) {
3689                     int b1, b2, b3;
3690                     b1 = buf[pos++] &amp; 0xFF;
3691                     switch (b1 &gt;&gt; 4) {
3692                         case 0:
3693                         case 1:
3694                         case 2:
3695                         case 3:
3696                         case 4:
3697                         case 5:
3698                         case 6:
3699                         case 7:   // 1 byte format: 0xxxxxxx
3700                             cbuf[cpos++] = (char) b1;
3701                             break;
3702 
3703                         case 12:
3704                         case 13:  // 2 byte format: 110xxxxx 10xxxxxx
3705                             b2 = buf[pos++];
3706                             if ((b2 &amp; 0xC0) != 0x80) {
3707                                 throw new UTFDataFormatException();
3708                             }
3709                             cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3710                                                    ((b2 &amp; 0x3F) &lt;&lt; 0));
3711                             break;
3712 
3713                         case 14:  // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3714                             b3 = buf[pos + 1];
3715                             b2 = buf[pos + 0];
3716                             pos += 2;
3717                             if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3718                                 throw new UTFDataFormatException();
3719                             }
3720                             cbuf[cpos++] = (char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3721                                                    ((b2 &amp; 0x3F) &lt;&lt; 6) |
3722                                                    ((b3 &amp; 0x3F) &lt;&lt; 0));
3723                             break;
3724 
3725                         default:  // 10xx xxxx, 1111 xxxx
3726                             throw new UTFDataFormatException();
3727                     }
3728                 }
3729             } catch (ArrayIndexOutOfBoundsException ex) {
3730                 outOfBounds = true;
3731             } finally {
3732                 if (outOfBounds || (pos - start) &gt; utflen) {
3733                     /*
3734                      * Fix for 4450867: if a malformed utf char causes the
3735                      * conversion loop to scan past the expected end of the utf
3736                      * string, only consume the expected number of utf bytes.
3737                      */
3738                     pos = start + (int) utflen;
3739                     throw new UTFDataFormatException();
3740                 }
3741             }
3742 
3743             sbuf.append(cbuf, 0, cpos);
3744             return pos - start;
3745         }
3746 
3747         /**
3748          * Reads in single UTF-encoded character one byte at a time, appends
3749          * the character to sbuf, and returns the number of bytes consumed.
3750          * This method is used when reading in UTF strings written in block
3751          * data mode to handle UTF-encoded characters which (potentially)
3752          * straddle block-data boundaries.
3753          */
3754         private int readUTFChar(StringBuilder sbuf, long utflen)
3755             throws IOException
3756         {
3757             int b1, b2, b3;
3758             b1 = readByte() &amp; 0xFF;
3759             switch (b1 &gt;&gt; 4) {
3760                 case 0:
3761                 case 1:
3762                 case 2:
3763                 case 3:
3764                 case 4:
3765                 case 5:
3766                 case 6:
3767                 case 7:     // 1 byte format: 0xxxxxxx
3768                     sbuf.append((char) b1);
3769                     return 1;
3770 
3771                 case 12:
3772                 case 13:    // 2 byte format: 110xxxxx 10xxxxxx
3773                     if (utflen &lt; 2) {
3774                         throw new UTFDataFormatException();
3775                     }
3776                     b2 = readByte();
3777                     if ((b2 &amp; 0xC0) != 0x80) {
3778                         throw new UTFDataFormatException();
3779                     }
3780                     sbuf.append((char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
3781                                         ((b2 &amp; 0x3F) &lt;&lt; 0)));
3782                     return 2;
3783 
3784                 case 14:    // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
3785                     if (utflen &lt; 3) {
3786                         if (utflen == 2) {
3787                             readByte();         // consume remaining byte
3788                         }
3789                         throw new UTFDataFormatException();
3790                     }
3791                     b2 = readByte();
3792                     b3 = readByte();
3793                     if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
3794                         throw new UTFDataFormatException();
3795                     }
3796                     sbuf.append((char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
3797                                         ((b2 &amp; 0x3F) &lt;&lt; 6) |
3798                                         ((b3 &amp; 0x3F) &lt;&lt; 0)));
3799                     return 3;
3800 
3801                 default:   // 10xx xxxx, 1111 xxxx
3802                     throw new UTFDataFormatException();
3803             }
3804         }
3805 
3806         /**
3807          * Returns the number of bytes read from the input stream.
3808          * @return the number of bytes read from the input stream
3809          */
3810         long getBytesRead() {
3811             return in.getBytesRead();
3812         }
3813     }
3814 
3815     /**
3816      * Unsynchronized table which tracks wire handle to object mappings, as
3817      * well as ClassNotFoundExceptions associated with deserialized objects.
3818      * This class implements an exception-propagation algorithm for
3819      * determining which objects should have ClassNotFoundExceptions associated
3820      * with them, taking into account cycles and discontinuities (e.g., skipped
3821      * fields) in the object graph.
3822      *
3823      * &lt;p&gt;General use of the table is as follows: during deserialization, a
3824      * given object is first assigned a handle by calling the assign method.
3825      * This method leaves the assigned handle in an &quot;open&quot; state, wherein
3826      * dependencies on the exception status of other handles can be registered
3827      * by calling the markDependency method, or an exception can be directly
3828      * associated with the handle by calling markException.  When a handle is
3829      * tagged with an exception, the HandleTable assumes responsibility for
3830      * propagating the exception to any other objects which depend
3831      * (transitively) on the exception-tagged object.
3832      *
3833      * &lt;p&gt;Once all exception information/dependencies for the handle have been
3834      * registered, the handle should be &quot;closed&quot; by calling the finish method
3835      * on it.  The act of finishing a handle allows the exception propagation
3836      * algorithm to aggressively prune dependency links, lessening the
3837      * performance/memory impact of exception tracking.
3838      *
3839      * &lt;p&gt;Note that the exception propagation algorithm used depends on handles
3840      * being assigned/finished in LIFO order; however, for simplicity as well
3841      * as memory conservation, it does not enforce this constraint.
3842      */
3843     // REMIND: add full description of exception propagation algorithm?
3844     private static class HandleTable {
3845 
3846         /* status codes indicating whether object has associated exception */
3847         private static final byte STATUS_OK = 1;
3848         private static final byte STATUS_UNKNOWN = 2;
3849         private static final byte STATUS_EXCEPTION = 3;
3850 
3851         /** array mapping handle -&gt; object status */
3852         byte[] status;
3853         /** array mapping handle -&gt; object/exception (depending on status) */
3854         Object[] entries;
3855         /** array mapping handle -&gt; list of dependent handles (if any) */
3856         HandleList[] deps;
3857         /** lowest unresolved dependency */
3858         int lowDep = -1;
3859         /** number of handles in table */
3860         int size = 0;
3861 
3862         /**
3863          * Creates handle table with the given initial capacity.
3864          */
3865         HandleTable(int initialCapacity) {
3866             status = new byte[initialCapacity];
3867             entries = new Object[initialCapacity];
3868             deps = new HandleList[initialCapacity];
3869         }
3870 
3871         /**
3872          * Assigns next available handle to given object, and returns assigned
3873          * handle.  Once object has been completely deserialized (and all
3874          * dependencies on other objects identified), the handle should be
3875          * &quot;closed&quot; by passing it to finish().
3876          */
3877         int assign(Object obj) {
3878             if (size &gt;= entries.length) {
3879                 grow();
3880             }
3881             status[size] = STATUS_UNKNOWN;
3882             entries[size] = obj;
3883             return size++;
3884         }
3885 
3886         /**
3887          * Registers a dependency (in exception status) of one handle on
3888          * another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but
3889          * not finished yet).  No action is taken if either dependent or target
3890          * handle is NULL_HANDLE. Additionally, no action is taken if the
3891          * dependent and target are the same.
3892          */
3893         void markDependency(int dependent, int target) {
3894             if (dependent == target || dependent == NULL_HANDLE || target == NULL_HANDLE) {
3895                 return;
3896             }
3897             switch (status[dependent]) {
3898 
3899                 case STATUS_UNKNOWN:
3900                     switch (status[target]) {
3901                         case STATUS_OK:
3902                             // ignore dependencies on objs with no exception
3903                             break;
3904 
3905                         case STATUS_EXCEPTION:
3906                             // eagerly propagate exception
3907                             markException(dependent,
3908                                 (ClassNotFoundException) entries[target]);
3909                             break;
3910 
3911                         case STATUS_UNKNOWN:
3912                             // add to dependency list of target
3913                             if (deps[target] == null) {
3914                                 deps[target] = new HandleList();
3915                             }
3916                             deps[target].add(dependent);
3917 
3918                             // remember lowest unresolved target seen
3919                             if (lowDep &lt; 0 || lowDep &gt; target) {
3920                                 lowDep = target;
3921                             }
3922                             break;
3923 
3924                         default:
3925                             throw new InternalError();
3926                     }
3927                     break;
3928 
3929                 case STATUS_EXCEPTION:
3930                     break;
3931 
3932                 default:
3933                     throw new InternalError();
3934             }
3935         }
3936 
3937         /**
3938          * Associates a ClassNotFoundException (if one not already associated)
3939          * with the currently active handle and propagates it to other
3940          * referencing objects as appropriate.  The specified handle must be
3941          * &quot;open&quot; (i.e., assigned, but not finished yet).
3942          */
3943         void markException(int handle, ClassNotFoundException ex) {
3944             switch (status[handle]) {
3945                 case STATUS_UNKNOWN:
3946                     status[handle] = STATUS_EXCEPTION;
3947                     entries[handle] = ex;
3948 
3949                     // propagate exception to dependents
3950                     HandleList dlist = deps[handle];
3951                     if (dlist != null) {
3952                         int ndeps = dlist.size();
3953                         for (int i = 0; i &lt; ndeps; i++) {
3954                             markException(dlist.get(i), ex);
3955                         }
3956                         deps[handle] = null;
3957                     }
3958                     break;
3959 
3960                 case STATUS_EXCEPTION:
3961                     break;
3962 
3963                 default:
3964                     throw new InternalError();
3965             }
3966         }
3967 
3968         /**
3969          * Marks given handle as finished, meaning that no new dependencies
3970          * will be marked for handle.  Calls to the assign and finish methods
3971          * must occur in LIFO order.
3972          */
3973         void finish(int handle) {
3974             int end;
3975             if (lowDep &lt; 0) {
3976                 // no pending unknowns, only resolve current handle
3977                 end = handle + 1;
3978             } else if (lowDep &gt;= handle) {
3979                 // pending unknowns now clearable, resolve all upward handles
3980                 end = size;
3981                 lowDep = -1;
3982             } else {
3983                 // unresolved backrefs present, can&#39;t resolve anything yet
3984                 return;
3985             }
3986 
3987             // change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles
3988             for (int i = handle; i &lt; end; i++) {
3989                 switch (status[i]) {
3990                     case STATUS_UNKNOWN:
3991                         status[i] = STATUS_OK;
3992                         deps[i] = null;
3993                         break;
3994 
3995                     case STATUS_OK:
3996                     case STATUS_EXCEPTION:
3997                         break;
3998 
3999                     default:
4000                         throw new InternalError();
4001                 }
4002             }
4003         }
4004 
4005         /**
4006          * Assigns a new object to the given handle.  The object previously
4007          * associated with the handle is forgotten.  This method has no effect
4008          * if the given handle already has an exception associated with it.
4009          * This method may be called at any time after the handle is assigned.
4010          */
4011         void setObject(int handle, Object obj) {
4012             switch (status[handle]) {
4013                 case STATUS_UNKNOWN:
4014                 case STATUS_OK:
4015                     entries[handle] = obj;
4016                     break;
4017 
4018                 case STATUS_EXCEPTION:
4019                     break;
4020 
4021                 default:
4022                     throw new InternalError();
4023             }
4024         }
4025 
4026         /**
4027          * Looks up and returns object associated with the given handle.
4028          * Returns null if the given handle is NULL_HANDLE, or if it has an
4029          * associated ClassNotFoundException.
4030          */
4031         Object lookupObject(int handle) {
4032             return (handle != NULL_HANDLE &amp;&amp;
4033                     status[handle] != STATUS_EXCEPTION) ?
4034                 entries[handle] : null;
4035         }
4036 
4037         /**
4038          * Looks up and returns ClassNotFoundException associated with the
4039          * given handle.  Returns null if the given handle is NULL_HANDLE, or
4040          * if there is no ClassNotFoundException associated with the handle.
4041          */
4042         ClassNotFoundException lookupException(int handle) {
4043             return (handle != NULL_HANDLE &amp;&amp;
4044                     status[handle] == STATUS_EXCEPTION) ?
4045                 (ClassNotFoundException) entries[handle] : null;
4046         }
4047 
4048         /**
4049          * Resets table to its initial state.
4050          */
4051         void clear() {
4052             Arrays.fill(status, 0, size, (byte) 0);
4053             Arrays.fill(entries, 0, size, null);
4054             Arrays.fill(deps, 0, size, null);
4055             lowDep = -1;
4056             size = 0;
4057         }
4058 
4059         /**
4060          * Returns number of handles registered in table.
4061          */
4062         int size() {
4063             return size;
4064         }
4065 
4066         /**
4067          * Expands capacity of internal arrays.
4068          */
4069         private void grow() {
4070             int newCapacity = (entries.length &lt;&lt; 1) + 1;
4071 
4072             byte[] newStatus = new byte[newCapacity];
4073             Object[] newEntries = new Object[newCapacity];
4074             HandleList[] newDeps = new HandleList[newCapacity];
4075 
4076             System.arraycopy(status, 0, newStatus, 0, size);
4077             System.arraycopy(entries, 0, newEntries, 0, size);
4078             System.arraycopy(deps, 0, newDeps, 0, size);
4079 
4080             status = newStatus;
4081             entries = newEntries;
4082             deps = newDeps;
4083         }
4084 
4085         /**
4086          * Simple growable list of (integer) handles.
4087          */
4088         private static class HandleList {
4089             private int[] list = new int[4];
4090             private int size = 0;
4091 
4092             public HandleList() {
4093             }
4094 
4095             public void add(int handle) {
4096                 if (size &gt;= list.length) {
4097                     int[] newList = new int[list.length &lt;&lt; 1];
4098                     System.arraycopy(list, 0, newList, 0, list.length);
4099                     list = newList;
4100                 }
4101                 list[size++] = handle;
4102             }
4103 
4104             public int get(int index) {
4105                 if (index &gt;= size) {
4106                     throw new ArrayIndexOutOfBoundsException();
4107                 }
4108                 return list[index];
4109             }
4110 
4111             public int size() {
4112                 return size;
4113             }
4114         }
4115     }
4116 
4117     /**
4118      * Method for cloning arrays in case of using unsharing reading
4119      */
4120     private static Object cloneArray(Object array) {
4121         if (array instanceof Object[]) {
4122             return ((Object[]) array).clone();
4123         } else if (array instanceof boolean[]) {
4124             return ((boolean[]) array).clone();
4125         } else if (array instanceof byte[]) {
4126             return ((byte[]) array).clone();
4127         } else if (array instanceof char[]) {
4128             return ((char[]) array).clone();
4129         } else if (array instanceof double[]) {
4130             return ((double[]) array).clone();
4131         } else if (array instanceof float[]) {
4132             return ((float[]) array).clone();
4133         } else if (array instanceof int[]) {
4134             return ((int[]) array).clone();
4135         } else if (array instanceof long[]) {
4136             return ((long[]) array).clone();
4137         } else if (array instanceof short[]) {
4138             return ((short[]) array).clone();
4139         } else {
4140             throw new AssertionError();
4141         }
4142     }
4143 
4144     static {
4145         SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
4146         SharedSecrets.setJavaObjectInputStreamReadString(ObjectInputStream::readString);
4147     }
4148 
4149 }
    </pre>
  </body>
</html>
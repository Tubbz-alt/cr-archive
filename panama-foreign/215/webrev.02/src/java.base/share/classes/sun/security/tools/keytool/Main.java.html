<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/tools/keytool/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.keytool;
  27 
  28 import java.io.*;
  29 import java.nio.file.Files;
  30 import java.nio.file.Path;
  31 import java.security.AlgorithmParameters;
  32 import java.security.CodeSigner;
  33 import java.security.CryptoPrimitive;
  34 import java.security.KeyStore;
  35 import java.security.KeyStoreException;
  36 import java.security.MessageDigest;
  37 import java.security.Key;
  38 import java.security.PublicKey;
  39 import java.security.PrivateKey;
  40 import java.security.SecureRandom;
  41 import java.security.Signature;
  42 import java.security.Timestamp;
  43 import java.security.UnrecoverableEntryException;
  44 import java.security.UnrecoverableKeyException;
  45 import java.security.Principal;
  46 import java.security.cert.Certificate;
  47 import java.security.cert.CertificateFactory;
  48 import java.security.cert.CertStoreException;
  49 import java.security.cert.CRL;
  50 import java.security.cert.X509Certificate;
  51 import java.security.cert.CertificateException;
  52 import java.security.cert.URICertStoreParameters;
  53 
  54 
  55 import java.security.interfaces.ECKey;
  56 import java.security.spec.AlgorithmParameterSpec;
  57 import java.security.spec.ECParameterSpec;
  58 import java.text.Collator;
  59 import java.text.MessageFormat;
  60 import java.util.*;
  61 import java.util.function.BiFunction;
  62 import java.util.jar.JarEntry;
  63 import java.util.jar.JarFile;
  64 import java.math.BigInteger;
  65 import java.net.URI;
  66 import java.net.URL;
  67 import java.net.URLClassLoader;
  68 import java.security.cert.CertStore;
  69 
  70 import java.security.cert.X509CRL;
  71 import java.security.cert.X509CRLEntry;
  72 import java.security.cert.X509CRLSelector;
  73 import javax.security.auth.x500.X500Principal;
  74 import java.util.Base64;
  75 
  76 import sun.security.pkcs12.PKCS12KeyStore;
  77 import sun.security.util.ECKeySizeParameterSpec;
  78 import sun.security.util.KeyUtil;
  79 import sun.security.util.NamedCurve;
  80 import sun.security.util.ObjectIdentifier;
  81 import sun.security.pkcs10.PKCS10;
  82 import sun.security.pkcs10.PKCS10Attribute;
  83 import sun.security.provider.X509Factory;
  84 import sun.security.provider.certpath.ssl.SSLServerCertStore;
  85 import sun.security.util.KnownOIDs;
  86 import sun.security.util.Password;
  87 import sun.security.util.SecurityProperties;
  88 import sun.security.util.SecurityProviderConstants;
  89 import sun.security.util.SignatureUtil;
  90 import javax.crypto.KeyGenerator;
  91 import javax.crypto.SecretKey;
  92 import javax.crypto.SecretKeyFactory;
  93 import javax.crypto.spec.PBEKeySpec;
  94 
  95 import sun.security.pkcs.PKCS9Attribute;
  96 import sun.security.tools.KeyStoreUtil;
  97 import sun.security.tools.PathList;
  98 import sun.security.util.DerValue;
  99 import sun.security.util.Pem;
 100 import sun.security.x509.*;
 101 
 102 import static java.security.KeyStore.*;
 103 import java.security.Security;
 104 import static sun.security.tools.keytool.Main.Command.*;
 105 import static sun.security.tools.keytool.Main.Option.*;
 106 import sun.security.util.DisabledAlgorithmConstraints;
 107 
 108 /**
 109  * This tool manages keystores.
 110  *
 111  * @author Jan Luehe
 112  *
 113  *
 114  * @see java.security.KeyStore
 115  * @see sun.security.provider.KeyProtector
 116  * @see sun.security.provider.JavaKeyStore
 117  *
 118  * @since 1.2
 119  */
 120 public final class Main {
 121 
 122     private static final byte[] CRLF = new byte[] {&#39;\r&#39;, &#39;\n&#39;};
 123 
 124     private boolean debug = false;
 125     private Command command = null;
 126     private String sigAlgName = null;
 127     private String keyAlgName = null;
 128     private boolean verbose = false;
 129     private int keysize = -1;
 130     private String groupName = null;
 131     private boolean rfc = false;
 132     private long validity = (long)90;
 133     private String alias = null;
 134     private String dname = null;
 135     private String dest = null;
 136     private String filename = null;
 137     private String infilename = null;
 138     private String outfilename = null;
 139     private String srcksfname = null;
 140 
 141     // User-specified providers are added before any command is called.
 142     // However, they are not removed before the end of the main() method.
 143     // If you&#39;re calling KeyTool.main() directly in your own Java program,
 144     // please programtically add any providers you need and do not specify
 145     // them through the command line.
 146 
 147     private Set&lt;Pair &lt;String, String&gt;&gt; providers = null;
 148     private Set&lt;Pair &lt;String, String&gt;&gt; providerClasses = null;
 149     private String storetype = null;
 150     private String srcProviderName = null;
 151     private String providerName = null;
 152     private String pathlist = null;
 153     private char[] storePass = null;
 154     private char[] storePassNew = null;
 155     private char[] keyPass = null;
 156     private char[] keyPassNew = null;
 157     private char[] newPass = null;
 158     private char[] destKeyPass = null;
 159     private char[] srckeyPass = null;
 160     private String ksfname = null;
 161     private File ksfile = null;
 162     private InputStream ksStream = null; // keystore stream
 163     private String sslserver = null;
 164     private String jarfile = null;
 165     private KeyStore keyStore = null;
 166     private boolean token = false;
 167     private boolean nullStream = false;
 168     private boolean kssave = false;
 169     private boolean noprompt = false;
 170     private boolean trustcacerts = false;
 171     private boolean protectedPath = false;
 172     private boolean srcprotectedPath = false;
 173     private boolean cacerts = false;
 174     private boolean nowarn = false;
 175     private KeyStore caks = null; // &quot;cacerts&quot; keystore
 176     private char[] srcstorePass = null;
 177     private String srcstoretype = null;
 178     private Set&lt;char[]&gt; passwords = new HashSet&lt;&gt;();
 179     private String startDate = null;
 180 
 181     private boolean tlsInfo = false;
 182 
 183     private List&lt;String&gt; ids = new ArrayList&lt;&gt;();   // used in GENCRL
 184     private List&lt;String&gt; v3ext = new ArrayList&lt;&gt;();
 185 
 186     // In-place importkeystore is special.
 187     // A backup is needed, and no need to prompt for deststorepass.
 188     private boolean inplaceImport = false;
 189     private String inplaceBackupName = null;
 190 
 191     // Warnings on weak algorithms etc
 192     private List&lt;String&gt; weakWarnings = new ArrayList&lt;&gt;();
 193 
 194     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
 195             new DisabledAlgorithmConstraints(
 196                     DisabledAlgorithmConstraints.PROPERTY_CERTPATH_DISABLED_ALGS);
 197 
 198     private static final DisabledAlgorithmConstraints LEGACY_CHECK =
 199             new DisabledAlgorithmConstraints(
 200                     DisabledAlgorithmConstraints.PROPERTY_SECURITY_LEGACY_ALGS);
 201 
 202     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 203             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 204     private boolean isPasswordlessKeyStore = false;
 205 
 206     enum Command {
 207         CERTREQ(&quot;Generates.a.certificate.request&quot;,
 208             ALIAS, SIGALG, FILEOUT, KEYPASS, KEYSTORE, DNAME,
 209             EXT, STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 210             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 211         CHANGEALIAS(&quot;Changes.an.entry.s.alias&quot;,
 212             ALIAS, DESTALIAS, KEYPASS, KEYSTORE, CACERTS, STOREPASS,
 213             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 214             PROVIDERPATH, V, PROTECTED),
 215         DELETE(&quot;Deletes.an.entry&quot;,
 216             ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 217             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 218             PROVIDERPATH, V, PROTECTED),
 219         EXPORTCERT(&quot;Exports.certificate&quot;,
 220             RFC, ALIAS, FILEOUT, KEYSTORE, CACERTS, STOREPASS,
 221             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 222             PROVIDERPATH, V, PROTECTED),
 223         GENKEYPAIR(&quot;Generates.a.key.pair&quot;,
 224             ALIAS, KEYALG, KEYSIZE, CURVENAME, SIGALG, DNAME,
 225             STARTDATE, EXT, VALIDITY, KEYPASS, KEYSTORE,
 226             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 227             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 228         GENSECKEY(&quot;Generates.a.secret.key&quot;,
 229             ALIAS, KEYPASS, KEYALG, KEYSIZE, KEYSTORE,
 230             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 231             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 232         GENCERT(&quot;Generates.certificate.from.a.certificate.request&quot;,
 233             RFC, INFILE, OUTFILE, ALIAS, SIGALG, DNAME,
 234             STARTDATE, EXT, VALIDITY, KEYPASS, KEYSTORE,
 235             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 236             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 237         IMPORTCERT(&quot;Imports.a.certificate.or.a.certificate.chain&quot;,
 238             NOPROMPT, TRUSTCACERTS, PROTECTED, ALIAS, FILEIN,
 239             KEYPASS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 240             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 241             PROVIDERPATH, V),
 242         IMPORTPASS(&quot;Imports.a.password&quot;,
 243             ALIAS, KEYPASS, KEYALG, KEYSIZE, KEYSTORE,
 244             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 245             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 246         IMPORTKEYSTORE(&quot;Imports.one.or.all.entries.from.another.keystore&quot;,
 247             SRCKEYSTORE, DESTKEYSTORE, SRCSTORETYPE,
 248             DESTSTORETYPE, SRCSTOREPASS, DESTSTOREPASS,
 249             SRCPROTECTED, DESTPROTECTED, SRCPROVIDERNAME, DESTPROVIDERNAME,
 250             SRCALIAS, DESTALIAS, SRCKEYPASS, DESTKEYPASS,
 251             NOPROMPT, ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH,
 252             V),
 253         KEYPASSWD(&quot;Changes.the.key.password.of.an.entry&quot;,
 254             ALIAS, KEYPASS, NEW, KEYSTORE, STOREPASS,
 255             STORETYPE, PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 256             PROVIDERPATH, V),
 257         LIST(&quot;Lists.entries.in.a.keystore&quot;,
 258             RFC, ALIAS, KEYSTORE, CACERTS, STOREPASS, STORETYPE,
 259             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 260             PROVIDERPATH, V, PROTECTED),
 261         PRINTCERT(&quot;Prints.the.content.of.a.certificate&quot;,
 262             RFC, FILEIN, SSLSERVER, JARFILE,
 263             KEYSTORE, STOREPASS, STORETYPE, TRUSTCACERTS,
 264             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS,
 265             PROVIDERPATH, V, PROTECTED),
 266         PRINTCERTREQ(&quot;Prints.the.content.of.a.certificate.request&quot;,
 267             FILEIN, V),
 268         PRINTCRL(&quot;Prints.the.content.of.a.CRL.file&quot;,
 269             FILEIN, KEYSTORE, STOREPASS, STORETYPE, TRUSTCACERTS,
 270             PROVIDERNAME, ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH,
 271             V, PROTECTED),
 272         STOREPASSWD(&quot;Changes.the.store.password.of.a.keystore&quot;,
 273             NEW, KEYSTORE, CACERTS, STOREPASS, STORETYPE, PROVIDERNAME,
 274             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 275         SHOWINFO(&quot;showinfo.command.help&quot;,
 276             TLS, V),
 277 
 278         // Undocumented start here, KEYCLONE is used a marker in -help;
 279 
 280         KEYCLONE(&quot;Clones.a.key.entry&quot;,
 281             ALIAS, DESTALIAS, KEYPASS, NEW, STORETYPE,
 282             KEYSTORE, STOREPASS, PROVIDERNAME, ADDPROVIDER,
 283             PROVIDERCLASS, PROVIDERPATH, V),
 284         SELFCERT(&quot;Generates.a.self.signed.certificate&quot;,
 285             ALIAS, SIGALG, DNAME, STARTDATE, EXT, VALIDITY, KEYPASS,
 286             STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 287             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V),
 288         GENCRL(&quot;Generates.CRL&quot;,
 289             RFC, FILEOUT, ID,
 290             ALIAS, SIGALG, KEYPASS, KEYSTORE,
 291             STOREPASS, STORETYPE, PROVIDERNAME, ADDPROVIDER,
 292             PROVIDERCLASS, PROVIDERPATH, V, PROTECTED),
 293         IDENTITYDB(&quot;Imports.entries.from.a.JDK.1.1.x.style.identity.database&quot;,
 294             FILEIN, STORETYPE, KEYSTORE, STOREPASS, PROVIDERNAME,
 295             ADDPROVIDER, PROVIDERCLASS, PROVIDERPATH, V);
 296 
 297         final String description;
 298         final Option[] options;
 299         final String name;
 300 
 301         String altName;     // &quot;genkey&quot; is altName for &quot;genkeypair&quot;
 302 
 303         Command(String d, Option... o) {
 304             description = d;
 305             options = o;
 306             name = &quot;-&quot; + name().toLowerCase(Locale.ENGLISH);
 307         }
 308         @Override
 309         public String toString() {
 310             return name;
 311         }
 312         public String getAltName() {
 313             return altName;
 314         }
 315         public void setAltName(String altName) {
 316             this.altName = altName;
 317         }
 318         public static Command getCommand(String cmd) {
 319             for (Command c: Command.values()) {
 320                 if (collator.compare(cmd, c.name) == 0
 321                         || (c.altName != null
 322                             &amp;&amp; collator.compare(cmd, c.altName) == 0)) {
 323                     return c;
 324                 }
 325             }
 326             return null;
 327         }
 328     };
 329 
 330     static {
 331         Command.GENKEYPAIR.setAltName(&quot;-genkey&quot;);
 332         Command.IMPORTCERT.setAltName(&quot;-import&quot;);
 333         Command.EXPORTCERT.setAltName(&quot;-export&quot;);
 334         Command.IMPORTPASS.setAltName(&quot;-importpassword&quot;);
 335     }
 336 
 337     // If an option is allowed multiple times, remember to record it
 338     // in the optionsSet.contains() block in parseArgs().
 339     enum Option {
 340         ALIAS(&quot;alias&quot;, &quot;&lt;alias&gt;&quot;, &quot;alias.name.of.the.entry.to.process&quot;),
 341         CURVENAME(&quot;groupname&quot;, &quot;&lt;name&gt;&quot;, &quot;groupname.option.help&quot;),
 342         DESTALIAS(&quot;destalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;destination.alias&quot;),
 343         DESTKEYPASS(&quot;destkeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;destination.key.password&quot;),
 344         DESTKEYSTORE(&quot;destkeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;destination.keystore.name&quot;),
 345         DESTPROTECTED(&quot;destprotected&quot;, null, &quot;destination.keystore.password.protected&quot;),
 346         DESTPROVIDERNAME(&quot;destprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;destination.keystore.provider.name&quot;),
 347         DESTSTOREPASS(&quot;deststorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;destination.keystore.password&quot;),
 348         DESTSTORETYPE(&quot;deststoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;destination.keystore.type&quot;),
 349         DNAME(&quot;dname&quot;, &quot;&lt;name&gt;&quot;, &quot;distinguished.name&quot;),
 350         EXT(&quot;ext&quot;, &quot;&lt;value&gt;&quot;, &quot;X.509.extension&quot;),
 351         FILEOUT(&quot;file&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 352         FILEIN(&quot;file&quot;, &quot;&lt;file&gt;&quot;, &quot;input.file.name&quot;),
 353         ID(&quot;id&quot;, &quot;&lt;id:reason&gt;&quot;, &quot;Serial.ID.of.cert.to.revoke&quot;),
 354         INFILE(&quot;infile&quot;, &quot;&lt;file&gt;&quot;, &quot;input.file.name&quot;),
 355         KEYALG(&quot;keyalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;key.algorithm.name&quot;),
 356         KEYPASS(&quot;keypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;key.password&quot;),
 357         KEYSIZE(&quot;keysize&quot;, &quot;&lt;size&gt;&quot;, &quot;key.bit.size&quot;),
 358         KEYSTORE(&quot;keystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;keystore.name&quot;),
 359         CACERTS(&quot;cacerts&quot;, null, &quot;access.the.cacerts.keystore&quot;),
 360         NEW(&quot;new&quot;, &quot;&lt;arg&gt;&quot;, &quot;new.password&quot;),
 361         NOPROMPT(&quot;noprompt&quot;, null, &quot;do.not.prompt&quot;),
 362         OUTFILE(&quot;outfile&quot;, &quot;&lt;file&gt;&quot;, &quot;output.file.name&quot;),
 363         PROTECTED(&quot;protected&quot;, null, &quot;password.through.protected.mechanism&quot;),
 364         PROVIDERCLASS(&quot;providerclass&quot;, &quot;&lt;class&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;provider.class.option&quot;),
 365         ADDPROVIDER(&quot;addprovider&quot;, &quot;&lt;name&gt;\n[-providerarg &lt;arg&gt;]&quot;, &quot;addprovider.option&quot;),
 366         PROVIDERNAME(&quot;providername&quot;, &quot;&lt;name&gt;&quot;, &quot;provider.name&quot;),
 367         PROVIDERPATH(&quot;providerpath&quot;, &quot;&lt;list&gt;&quot;, &quot;provider.classpath&quot;),
 368         RFC(&quot;rfc&quot;, null, &quot;output.in.RFC.style&quot;),
 369         SIGALG(&quot;sigalg&quot;, &quot;&lt;alg&gt;&quot;, &quot;signature.algorithm.name&quot;),
 370         SRCALIAS(&quot;srcalias&quot;, &quot;&lt;alias&gt;&quot;, &quot;source.alias&quot;),
 371         SRCKEYPASS(&quot;srckeypass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.key.password&quot;),
 372         SRCKEYSTORE(&quot;srckeystore&quot;, &quot;&lt;keystore&gt;&quot;, &quot;source.keystore.name&quot;),
 373         SRCPROTECTED(&quot;srcprotected&quot;, null, &quot;source.keystore.password.protected&quot;),
 374         SRCPROVIDERNAME(&quot;srcprovidername&quot;, &quot;&lt;name&gt;&quot;, &quot;source.keystore.provider.name&quot;),
 375         SRCSTOREPASS(&quot;srcstorepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;source.keystore.password&quot;),
 376         SRCSTORETYPE(&quot;srcstoretype&quot;, &quot;&lt;type&gt;&quot;, &quot;source.keystore.type&quot;),
 377         SSLSERVER(&quot;sslserver&quot;, &quot;&lt;server[:port]&gt;&quot;, &quot;SSL.server.host.and.port&quot;),
 378         JARFILE(&quot;jarfile&quot;, &quot;&lt;file&gt;&quot;, &quot;signed.jar.file&quot;),
 379         STARTDATE(&quot;startdate&quot;, &quot;&lt;date&gt;&quot;, &quot;certificate.validity.start.date.time&quot;),
 380         STOREPASS(&quot;storepass&quot;, &quot;&lt;arg&gt;&quot;, &quot;keystore.password&quot;),
 381         STORETYPE(&quot;storetype&quot;, &quot;&lt;type&gt;&quot;, &quot;keystore.type&quot;),
 382         TLS(&quot;tls&quot;, null, &quot;tls.option.help&quot;),
 383         TRUSTCACERTS(&quot;trustcacerts&quot;, null, &quot;trust.certificates.from.cacerts&quot;),
 384         V(&quot;v&quot;, null, &quot;verbose.output&quot;),
 385         VALIDITY(&quot;validity&quot;, &quot;&lt;days&gt;&quot;, &quot;validity.number.of.days&quot;);
 386 
 387         final String name, arg, description;
 388         Option(String name, String arg, String description) {
 389             this.name = name;
 390             this.arg = arg;
 391             this.description = description;
 392         }
 393         @Override
 394         public String toString() {
 395             return &quot;-&quot; + name;
 396         }
 397     };
 398 
 399     private static final String NONE = &quot;NONE&quot;;
 400     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
 401     private static final String P12KEYSTORE = &quot;PKCS12&quot;;
 402     private static final String keyAlias = &quot;mykey&quot;;
 403 
 404     // for i18n
 405     private static final java.util.ResourceBundle rb =
 406         java.util.ResourceBundle.getBundle(
 407             &quot;sun.security.tools.keytool.Resources&quot;);
 408     private static final Collator collator = Collator.getInstance();
 409     static {
 410         // this is for case insensitive string comparisons
 411         collator.setStrength(Collator.PRIMARY);
 412     };
 413 
 414     private Main() { }
 415 
 416     public static void main(String[] args) throws Exception {
 417         Main kt = new Main();
 418         kt.run(args, System.out);
 419     }
 420 
 421     private void run(String[] args, PrintStream out) throws Exception {
 422         try {
 423             args = parseArgs(args);
 424             if (command != null) {
 425                 doCommands(out);
 426             }
 427         } catch (Exception e) {
 428             System.out.println(rb.getString(&quot;keytool.error.&quot;) + e);
 429             if (verbose) {
 430                 e.printStackTrace(System.out);
 431             }
 432             if (!debug) {
 433                 System.exit(1);
 434             } else {
 435                 throw e;
 436             }
 437         } finally {
 438             printWeakWarnings(false);
 439             for (char[] pass : passwords) {
 440                 if (pass != null) {
 441                     Arrays.fill(pass, &#39; &#39;);
 442                     pass = null;
 443                 }
 444             }
 445 
 446             if (ksStream != null) {
 447                 ksStream.close();
 448             }
 449         }
 450     }
 451 
 452     /**
 453      * Parse command line arguments.
 454      */
 455     String[] parseArgs(String[] args) throws Exception {
 456 
 457         int i=0;
 458         boolean help = args.length == 0;
 459 
 460         String confFile = null;
 461 
 462         // Records all commands and options set. Used to check dups.
 463         Set&lt;String&gt; optionsSet = new HashSet&lt;&gt;();
 464 
 465         for (i=0; i &lt; args.length; i++) {
 466             String flags = args[i];
 467             if (flags.startsWith(&quot;-&quot;)) {
 468                 String lowerFlags = flags.toLowerCase(Locale.ROOT);
 469                 if (optionsSet.contains(lowerFlags)) {
 470                     switch (lowerFlags) {
 471                         case &quot;-ext&quot;:
 472                         case &quot;-id&quot;:
 473                         case &quot;-provider&quot;:
 474                         case &quot;-addprovider&quot;:
 475                         case &quot;-providerclass&quot;:
 476                         case &quot;-providerarg&quot;:
 477                             // These options are allowed multiple times
 478                             break;
 479                         default:
 480                             weakWarnings.add(String.format(
 481                                     rb.getString(&quot;option.1.set.twice&quot;),
 482                                     lowerFlags));
 483                     }
 484                 } else {
 485                     optionsSet.add(lowerFlags);
 486                 }
 487                 if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 488                     if (i == args.length - 1) {
 489                         errorNeedArgument(flags);
 490                     }
 491                     confFile = args[++i];
 492                 } else {
 493                     Command c = Command.getCommand(flags);
 494                     if (c != null) {
 495                         if (command == null) {
 496                             command = c;
 497                         } else {
 498                             throw new Exception(String.format(
 499                                     rb.getString(&quot;multiple.commands.1.2&quot;),
 500                                     command.name, c.name));
 501                         }
 502                     }
 503                 }
 504             }
 505         }
 506 
 507         if (confFile != null &amp;&amp; command != null) {
 508             args = KeyStoreUtil.expandArgs(&quot;keytool&quot;, confFile,
 509                     command.toString(),
 510                     command.getAltName(), args);
 511         }
 512 
 513         debug = Arrays.stream(args).anyMatch(
 514                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 515 
 516         if (debug) {
 517             // No need to localize debug output
 518             System.out.println(&quot;Command line args: &quot; +
 519                     Arrays.toString(args));
 520         }
 521 
 522         for (i=0; (i &lt; args.length) &amp;&amp; args[i].startsWith(&quot;-&quot;); i++) {
 523 
 524             String flags = args[i];
 525 
 526             // Check if the last option needs an arg
 527             if (i == args.length - 1) {
 528                 for (Option option: Option.values()) {
 529                     // Only options with an arg need to be checked
 530                     if (collator.compare(flags, option.toString()) == 0) {
 531                         if (option.arg != null) errorNeedArgument(flags);
 532                         break;
 533                     }
 534                 }
 535             }
 536 
 537             /*
 538              * Check modifiers
 539              */
 540             String modifier = null;
 541             int pos = flags.indexOf(&#39;:&#39;);
 542             if (pos &gt; 0) {
 543                 modifier = flags.substring(pos+1);
 544                 flags = flags.substring(0, pos);
 545             }
 546 
 547             /*
 548              * command modes
 549              */
 550             Command c = Command.getCommand(flags);
 551 
 552             if (c != null) {
 553                 command = c;
 554             } else if (collator.compare(flags, &quot;--help&quot;) == 0 ||
 555                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 556                        collator.compare(flags, &quot;-?&quot;) == 0 ||
 557                        // -help: legacy.
 558                        collator.compare(flags, &quot;-help&quot;) == 0) {
 559                 help = true;
 560             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 561                 i++;
 562             } else if (collator.compare(flags, &quot;-nowarn&quot;) == 0) {
 563                 nowarn = true;
 564             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 565                 ksfname = args[++i];
 566                 if (new File(ksfname).getCanonicalPath().equals(
 567                         new File(KeyStoreUtil.getCacerts()).getCanonicalPath())) {
 568                     System.err.println(rb.getString(&quot;warning.cacerts.option&quot;));
 569                 }
 570             } else if (collator.compare(flags, &quot;-destkeystore&quot;) == 0) {
 571                 ksfname = args[++i];
 572             } else if (collator.compare(flags, &quot;-cacerts&quot;) == 0) {
 573                 cacerts = true;
 574             } else if (collator.compare(flags, &quot;-storepass&quot;) == 0 ||
 575                     collator.compare(flags, &quot;-deststorepass&quot;) == 0) {
 576                 storePass = getPass(modifier, args[++i]);
 577                 passwords.add(storePass);
 578             } else if (collator.compare(flags, &quot;-storetype&quot;) == 0 ||
 579                     collator.compare(flags, &quot;-deststoretype&quot;) == 0) {
 580                 storetype = KeyStoreUtil.niceStoreTypeName(args[++i]);
 581             } else if (collator.compare(flags, &quot;-srcstorepass&quot;) == 0) {
 582                 srcstorePass = getPass(modifier, args[++i]);
 583                 passwords.add(srcstorePass);
 584             } else if (collator.compare(flags, &quot;-srcstoretype&quot;) == 0) {
 585                 srcstoretype = KeyStoreUtil.niceStoreTypeName(args[++i]);
 586             } else if (collator.compare(flags, &quot;-srckeypass&quot;) == 0) {
 587                 srckeyPass = getPass(modifier, args[++i]);
 588                 passwords.add(srckeyPass);
 589             } else if (collator.compare(flags, &quot;-srcprovidername&quot;) == 0) {
 590                 srcProviderName = args[++i];
 591             } else if (collator.compare(flags, &quot;-providername&quot;) == 0 ||
 592                     collator.compare(flags, &quot;-destprovidername&quot;) == 0) {
 593                 providerName = args[++i];
 594             } else if (collator.compare(flags, &quot;-providerpath&quot;) == 0) {
 595                 pathlist = args[++i];
 596             } else if (collator.compare(flags, &quot;-keypass&quot;) == 0) {
 597                 keyPass = getPass(modifier, args[++i]);
 598                 passwords.add(keyPass);
 599             } else if (collator.compare(flags, &quot;-new&quot;) == 0) {
 600                 newPass = getPass(modifier, args[++i]);
 601                 passwords.add(newPass);
 602             } else if (collator.compare(flags, &quot;-destkeypass&quot;) == 0) {
 603                 destKeyPass = getPass(modifier, args[++i]);
 604                 passwords.add(destKeyPass);
 605             } else if (collator.compare(flags, &quot;-alias&quot;) == 0 ||
 606                     collator.compare(flags, &quot;-srcalias&quot;) == 0) {
 607                 alias = args[++i];
 608             } else if (collator.compare(flags, &quot;-dest&quot;) == 0 ||
 609                     collator.compare(flags, &quot;-destalias&quot;) == 0) {
 610                 dest = args[++i];
 611             } else if (collator.compare(flags, &quot;-dname&quot;) == 0) {
 612                 dname = args[++i];
 613             } else if (collator.compare(flags, &quot;-keysize&quot;) == 0) {
 614                 keysize = Integer.parseInt(args[++i]);
 615             } else if (collator.compare(flags, &quot;-groupname&quot;) == 0) {
 616                 groupName = args[++i];
 617             } else if (collator.compare(flags, &quot;-keyalg&quot;) == 0) {
 618                 keyAlgName = args[++i];
 619             } else if (collator.compare(flags, &quot;-sigalg&quot;) == 0) {
 620                 sigAlgName = args[++i];
 621             } else if (collator.compare(flags, &quot;-startdate&quot;) == 0) {
 622                 startDate = args[++i];
 623             } else if (collator.compare(flags, &quot;-validity&quot;) == 0) {
 624                 validity = Long.parseLong(args[++i]);
 625             } else if (collator.compare(flags, &quot;-ext&quot;) == 0) {
 626                 v3ext.add(args[++i]);
 627             } else if (collator.compare(flags, &quot;-id&quot;) == 0) {
 628                 ids.add(args[++i]);
 629             } else if (collator.compare(flags, &quot;-file&quot;) == 0) {
 630                 filename = args[++i];
 631             } else if (collator.compare(flags, &quot;-infile&quot;) == 0) {
 632                 infilename = args[++i];
 633             } else if (collator.compare(flags, &quot;-outfile&quot;) == 0) {
 634                 outfilename = args[++i];
 635             } else if (collator.compare(flags, &quot;-sslserver&quot;) == 0) {
 636                 sslserver = args[++i];
 637             } else if (collator.compare(flags, &quot;-jarfile&quot;) == 0) {
 638                 jarfile = args[++i];
 639             } else if (collator.compare(flags, &quot;-srckeystore&quot;) == 0) {
 640                 srcksfname = args[++i];
 641             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 642                         collator.compare(flags, &quot;-providerclass&quot;) == 0) {
 643                 if (providerClasses == null) {
 644                     providerClasses = new HashSet&lt;Pair &lt;String, String&gt;&gt; (3);
 645                 }
 646                 String providerClass = args[++i];
 647                 String providerArg = null;
 648 
 649                 if (args.length &gt; (i+1)) {
 650                     flags = args[i+1];
 651                     if (collator.compare(flags, &quot;-providerarg&quot;) == 0) {
 652                         if (args.length == (i+2)) errorNeedArgument(flags);
 653                         providerArg = args[i+2];
 654                         i += 2;
 655                     }
 656                 }
 657                 providerClasses.add(
 658                         Pair.of(providerClass, providerArg));
 659             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 660                 if (providers == null) {
 661                     providers = new HashSet&lt;Pair &lt;String, String&gt;&gt; (3);
 662                 }
 663                 String provider = args[++i];
 664                 String providerArg = null;
 665 
 666                 if (args.length &gt; (i+1)) {
 667                     flags = args[i+1];
 668                     if (collator.compare(flags, &quot;-providerarg&quot;) == 0) {
 669                         if (args.length == (i+2)) errorNeedArgument(flags);
 670                         providerArg = args[i+2];
 671                         i += 2;
 672                     }
 673                 }
 674                 providers.add(
 675                         Pair.of(provider, providerArg));
 676             }
 677 
 678             /*
 679              * options
 680              */
 681             else if (collator.compare(flags, &quot;-v&quot;) == 0) {
 682                 verbose = true;
 683             } else if (collator.compare(flags, &quot;-debug&quot;) == 0) {
 684                 // Already processed
 685             } else if (collator.compare(flags, &quot;-rfc&quot;) == 0) {
 686                 rfc = true;
 687             } else if (collator.compare(flags, &quot;-noprompt&quot;) == 0) {
 688                 noprompt = true;
 689             } else if (collator.compare(flags, &quot;-trustcacerts&quot;) == 0) {
 690                 trustcacerts = true;
 691             } else if (collator.compare(flags, &quot;-protected&quot;) == 0 ||
 692                     collator.compare(flags, &quot;-destprotected&quot;) == 0) {
 693                 protectedPath = true;
 694             } else if (collator.compare(flags, &quot;-srcprotected&quot;) == 0) {
 695                 srcprotectedPath = true;
 696             } else if (collator.compare(flags, &quot;-tls&quot;) == 0) {
 697                 tlsInfo = true;
 698             } else  {
 699                 System.err.println(rb.getString(&quot;Illegal.option.&quot;) + flags);
 700                 tinyHelp();
 701             }
 702         }
 703 
 704         if (i&lt;args.length) {
 705             System.err.println(rb.getString(&quot;Illegal.option.&quot;) + args[i]);
 706             tinyHelp();
 707         }
 708 
 709         if (command == null) {
 710             if (help) {
 711                 usage();
 712             } else {
 713                 System.err.println(rb.getString(&quot;Usage.error.no.command.provided&quot;));
 714                 tinyHelp();
 715             }
 716         } else if (help) {
 717             usage();
 718             command = null;
 719         }
 720 
 721         return args;
 722     }
 723 
 724     boolean isKeyStoreRelated(Command cmd) {
 725         return cmd != PRINTCERTREQ &amp;&amp; cmd != SHOWINFO;
 726     }
 727 
 728     /**
 729      * Execute the commands.
 730      */
 731     void doCommands(PrintStream out) throws Exception {
 732 
 733         if (cacerts) {
 734             if (ksfname != null || storetype != null) {
 735                 throw new IllegalArgumentException(rb.getString
 736                         (&quot;the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option&quot;));
 737             }
 738             ksfname = KeyStoreUtil.getCacerts();
 739         }
 740 
 741         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 742                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 743             token = true;
 744             if (ksfname == null) {
 745                 ksfname = NONE;
 746             }
 747         }
 748         if (NONE.equals(ksfname)) {
 749             nullStream = true;
 750         }
 751 
 752         if (token &amp;&amp; !nullStream) {
 753             System.err.println(MessageFormat.format(rb.getString
 754                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 755             System.err.println();
 756             tinyHelp();
 757         }
 758 
 759         if (token &amp;&amp;
 760             (command == KEYPASSWD || command == STOREPASSWD)) {
 761             throw new UnsupportedOperationException(MessageFormat.format(rb.getString
 762                         (&quot;.storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}&quot;), storetype));
 763         }
 764 
 765         if (token &amp;&amp; (keyPass != null || newPass != null || destKeyPass != null)) {
 766             throw new IllegalArgumentException(MessageFormat.format(rb.getString
 767                 (&quot;.keypass.and.new.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 768         }
 769 
 770         if (protectedPath) {
 771             if (storePass != null || keyPass != null ||
 772                     newPass != null || destKeyPass != null) {
 773                 throw new IllegalArgumentException(rb.getString
 774                         (&quot;if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified&quot;));
 775             }
 776         }
 777 
 778         if (srcprotectedPath) {
 779             if (srcstorePass != null || srckeyPass != null) {
 780                 throw new IllegalArgumentException(rb.getString
 781                         (&quot;if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;));
 782             }
 783         }
 784 
 785         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 786             if (storePass != null || keyPass != null ||
 787                     newPass != null || destKeyPass != null) {
 788                 throw new IllegalArgumentException(rb.getString
 789                         (&quot;if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified&quot;));
 790             }
 791         }
 792 
 793         if (KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
 794             if (srcstorePass != null || srckeyPass != null) {
 795                 throw new IllegalArgumentException(rb.getString
 796                         (&quot;if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified&quot;));
 797             }
 798         }
 799 
 800         if (validity &lt;= (long)0) {
 801             throw new Exception
 802                 (rb.getString(&quot;Validity.must.be.greater.than.zero&quot;));
 803         }
 804 
 805         // Try to load and install specified provider
 806         if (providers != null) {
 807             for (Pair&lt;String, String&gt; provider : providers) {
 808                 try {
 809                     KeyStoreUtil.loadProviderByName(
 810                             provider.fst, provider.snd);
 811                     if (debug) {
 812                         System.out.println(&quot;loadProviderByName: &quot; + provider.fst);
 813                     }
 814                 } catch (IllegalArgumentException e) {
 815                     throw new Exception(String.format(rb.getString(
 816                             &quot;provider.name.not.found&quot;), provider.fst));
 817                 }
 818             }
 819         }
 820         if (providerClasses != null) {
 821             ClassLoader cl = null;
 822             if (pathlist != null) {
 823                 String path = null;
 824                 path = PathList.appendPath(
 825                         path, System.getProperty(&quot;java.class.path&quot;));
 826                 path = PathList.appendPath(
 827                         path, System.getProperty(&quot;env.class.path&quot;));
 828                 path = PathList.appendPath(path, pathlist);
 829 
 830                 URL[] urls = PathList.pathToURLs(path);
 831                 cl = new URLClassLoader(urls);
 832             } else {
 833                 cl = ClassLoader.getSystemClassLoader();
 834             }
 835             for (Pair&lt;String, String&gt; provider : providerClasses) {
 836                 try {
 837                     KeyStoreUtil.loadProviderByClass(
 838                             provider.fst, provider.snd, cl);
 839                     if (debug) {
 840                         System.out.println(&quot;loadProviderByClass: &quot; + provider.fst);
 841                     }
 842                 } catch (ClassCastException cce) {
 843                     throw new Exception(String.format(rb.getString(
 844                             &quot;provclass.not.a.provider&quot;), provider.fst));
 845                 } catch (IllegalArgumentException e) {
 846                     throw new Exception(String.format(rb.getString(
 847                             &quot;provider.class.not.found&quot;), provider.fst), e.getCause());
 848                 }
 849             }
 850         }
 851 
 852         if (command == LIST &amp;&amp; verbose &amp;&amp; rfc) {
 853             System.err.println(rb.getString
 854                 (&quot;Must.not.specify.both.v.and.rfc.with.list.command&quot;));
 855             tinyHelp();
 856         }
 857 
 858         // Make sure provided passwords are at least 6 characters long
 859         if (command == GENKEYPAIR &amp;&amp; keyPass!=null &amp;&amp; keyPass.length &lt; 6) {
 860             throw new Exception(rb.getString
 861                 (&quot;Key.password.must.be.at.least.6.characters&quot;));
 862         }
 863         if (newPass != null &amp;&amp; newPass.length &lt; 6) {
 864             throw new Exception(rb.getString
 865                 (&quot;New.password.must.be.at.least.6.characters&quot;));
 866         }
 867         if (destKeyPass != null &amp;&amp; destKeyPass.length &lt; 6) {
 868             throw new Exception(rb.getString
 869                 (&quot;New.password.must.be.at.least.6.characters&quot;));
 870         }
 871 
 872         // Set this before inplaceImport check so we can compare name.
 873         if (ksfname == null) {
 874             ksfname = System.getProperty(&quot;user.home&quot;) + File.separator
 875                     + &quot;.keystore&quot;;
 876         }
 877 
 878         KeyStore srcKeyStore = null;
 879         if (command == IMPORTKEYSTORE) {
 880             inplaceImport = inplaceImportCheck();
 881             if (inplaceImport) {
 882                 // We load srckeystore first so we have srcstorePass that
 883                 // can be assigned to storePass
 884                 srcKeyStore = loadSourceKeyStore();
 885                 if (storePass == null) {
 886                     storePass = srcstorePass;
 887                 }
 888             }
 889         }
 890 
 891         // Check if keystore exists.
 892         // If no keystore has been specified at the command line, try to use
 893         // the default, which is located in $HOME/.keystore.
 894         // No need to check if isKeyStoreRelated(command) is false.
 895 
 896         // DO NOT open the existing keystore if this is an in-place import.
 897         // The keystore should be created as brand new.
 898         if (isKeyStoreRelated(command) &amp;&amp; !nullStream &amp;&amp; !inplaceImport) {
 899             try {
 900                 ksfile = new File(ksfname);
 901                 // Check if keystore file is empty
 902                 if (ksfile.exists() &amp;&amp; ksfile.length() == 0) {
 903                     throw new Exception(rb.getString
 904                             (&quot;Keystore.file.exists.but.is.empty.&quot;) + ksfname);
 905                 }
 906                 ksStream = new FileInputStream(ksfile);
 907             } catch (FileNotFoundException e) {
 908                 // These commands do not need the keystore to be existing.
 909                 // Either it will create a new one or the keystore is
 910                 // optional (i.e. PRINTCRL and PRINTCERT).
 911                 if (command != GENKEYPAIR &amp;&amp;
 912                         command != GENSECKEY &amp;&amp;
 913                         command != IDENTITYDB &amp;&amp;
 914                         command != IMPORTCERT &amp;&amp;
 915                         command != IMPORTPASS &amp;&amp;
 916                         command != IMPORTKEYSTORE &amp;&amp;
 917                         command != PRINTCRL &amp;&amp;
 918                         command != PRINTCERT) {
 919                     throw new Exception(rb.getString
 920                             (&quot;Keystore.file.does.not.exist.&quot;) + ksfname);
 921                 }
 922             }
 923         }
 924 
 925         if ((command == KEYCLONE || command == CHANGEALIAS)
 926                 &amp;&amp; dest == null) {
 927             dest = getAlias(&quot;destination&quot;);
 928             if (&quot;&quot;.equals(dest)) {
 929                 throw new Exception(rb.getString
 930                         (&quot;Must.specify.destination.alias&quot;));
 931             }
 932         }
 933 
 934         if (command == DELETE &amp;&amp; alias == null) {
 935             alias = getAlias(null);
 936             if (&quot;&quot;.equals(alias)) {
 937                 throw new Exception(rb.getString(&quot;Must.specify.alias&quot;));
 938             }
 939         }
 940 
 941         // Create new keystore
 942         // Probe for keystore type when filename is available
 943         if (ksfile != null &amp;&amp; ksStream != null &amp;&amp; providerName == null &amp;&amp;
 944                 storetype == null &amp;&amp; !inplaceImport) {
 945             keyStore = KeyStore.getInstance(ksfile, storePass);
 946             storetype = keyStore.getType();
 947             if (storetype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
 948                 isPasswordlessKeyStore = PKCS12KeyStore.isPasswordless(ksfile);
 949             }
 950         } else {
 951             if (storetype == null) {
 952                 storetype = KeyStore.getDefaultType();
 953             }
 954             if (providerName == null) {
 955                 keyStore = KeyStore.getInstance(storetype);
 956             } else {
 957                 keyStore = KeyStore.getInstance(storetype, providerName);
 958             }
 959             // When creating a new pkcs12 file, Do not prompt for storepass
 960             // if certProtectionAlgorithm and macAlgorithm are both NONE.
 961             if (storetype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
 962                 isPasswordlessKeyStore =
 963                         &quot;NONE&quot;.equals(SecurityProperties.privilegedGetOverridable(
 964                                 &quot;keystore.pkcs12.certProtectionAlgorithm&quot;))
 965                         &amp;&amp; &quot;NONE&quot;.equals(SecurityProperties.privilegedGetOverridable(
 966                                 &quot;keystore.pkcs12.macAlgorithm&quot;));
 967             }
 968 
 969             /*
 970              * Load the keystore data.
 971              *
 972              * At this point, it&#39;s OK if no keystore password has been provided.
 973              * We want to make sure that we can load the keystore data, i.e.,
 974              * the keystore data has the right format. If we cannot load the
 975              * keystore, why bother asking the user for his or her password?
 976              * Only if we were able to load the keystore, and no keystore
 977              * password has been provided, will we prompt the user for the
 978              * keystore password to verify the keystore integrity.
 979              * This means that the keystore is loaded twice: first load operation
 980              * checks the keystore format, second load operation verifies the
 981              * keystore integrity.
 982              *
 983              * If the keystore password has already been provided (at the
 984              * command line), however, the keystore is loaded only once, and the
 985              * keystore format and integrity are checked &quot;at the same time&quot;.
 986              *
 987              * Null stream keystores are loaded later.
 988              */
 989             if (!nullStream) {
 990                 if (inplaceImport) {
 991                     keyStore.load(null, storePass);
 992                 } else {
 993                     keyStore.load(ksStream, storePass);
 994                 }
 995                 if (ksStream != null) {
 996                     ksStream.close();
 997                 }
 998             }
 999         }
1000 
1001         if (P12KEYSTORE.equalsIgnoreCase(storetype) &amp;&amp; command == KEYPASSWD) {
1002             throw new UnsupportedOperationException(rb.getString
1003                     (&quot;.keypasswd.commands.not.supported.if.storetype.is.PKCS12&quot;));
1004         }
1005 
1006         // All commands that create or modify the keystore require a keystore
1007         // password.
1008 
1009         if (nullStream &amp;&amp; storePass != null) {
1010             keyStore.load(null, storePass);
1011         } else if (!nullStream &amp;&amp; storePass != null) {
1012             // If we are creating a new non nullStream-based keystore,
1013             // insist that the password be at least 6 characters
1014             if (ksStream == null &amp;&amp; storePass.length &lt; 6) {
1015                 throw new Exception(rb.getString
1016                         (&quot;Keystore.password.must.be.at.least.6.characters&quot;));
1017             }
1018         } else if (storePass == null) {
1019             if (!protectedPath &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1020                     &amp;&amp; isKeyStoreRelated(command)
1021                     &amp;&amp; !isPasswordlessKeyStore) {
1022                 if (command == CERTREQ ||
1023                         command == DELETE ||
1024                         command == GENKEYPAIR ||
1025                         command == GENSECKEY ||
1026                         command == IMPORTCERT ||
1027                         command == IMPORTPASS ||
1028                         command == IMPORTKEYSTORE ||
1029                         command == KEYCLONE ||
1030                         command == CHANGEALIAS ||
1031                         command == SELFCERT ||
1032                         command == STOREPASSWD ||
1033                         command == KEYPASSWD ||
1034                         command == IDENTITYDB) {
1035                     int count = 0;
1036                     do {
1037                         if (command == IMPORTKEYSTORE) {
1038                             System.err.print
1039                                     (rb.getString(&quot;Enter.destination.keystore.password.&quot;));
1040                         } else {
1041                             System.err.print
1042                                     (rb.getString(&quot;Enter.keystore.password.&quot;));
1043                         }
1044                         System.err.flush();
1045                         storePass = Password.readPassword(System.in);
1046                         passwords.add(storePass);
1047 
1048                         // If we are creating a new non nullStream-based keystore,
1049                         // insist that the password be at least 6 characters
1050                         if (!nullStream &amp;&amp; (storePass == null || storePass.length &lt; 6)) {
1051                             System.err.println(rb.getString
1052                                     (&quot;Keystore.password.is.too.short.must.be.at.least.6.characters&quot;));
1053                             storePass = null;
1054                         }
1055 
1056                         // If the keystore file does not exist and needs to be
1057                         // created, the storepass should be prompted twice.
1058                         if (storePass != null &amp;&amp; !nullStream &amp;&amp; ksStream == null) {
1059                             System.err.print(rb.getString(&quot;Re.enter.new.password.&quot;));
1060                             char[] storePassAgain = Password.readPassword(System.in);
1061                             passwords.add(storePassAgain);
1062                             if (!Arrays.equals(storePass, storePassAgain)) {
1063                                 System.err.println
1064                                         (rb.getString(&quot;They.don.t.match.Try.again&quot;));
1065                                 storePass = null;
1066                             }
1067                         }
1068 
1069                         count++;
1070                     } while ((storePass == null) &amp;&amp; count &lt; 3);
1071 
1072 
1073                     if (storePass == null) {
1074                         System.err.println
1075                                 (rb.getString(&quot;Too.many.failures.try.later&quot;));
1076                         return;
1077                     }
1078                 } else {
1079                     // here we have EXPORTCERT and LIST (info valid until STOREPASSWD)
1080                     if (command != PRINTCRL &amp;&amp; command != PRINTCERT) {
1081                         System.err.print(rb.getString(&quot;Enter.keystore.password.&quot;));
1082                         System.err.flush();
1083                         storePass = Password.readPassword(System.in);
1084                         passwords.add(storePass);
1085                     }
1086                 }
1087             }
1088 
1089             // Now load a nullStream-based keystore,
1090             // or verify the integrity of an input stream-based keystore
1091             if (nullStream) {
1092                 keyStore.load(null, storePass);
1093             } else if (ksStream != null) {
1094                 ksStream = new FileInputStream(ksfile);
1095                 keyStore.load(ksStream, storePass);
1096                 ksStream.close();
1097             }
1098         }
1099 
1100         if (storePass != null &amp;&amp; P12KEYSTORE.equalsIgnoreCase(storetype)) {
1101             MessageFormat form = new MessageFormat(rb.getString(
1102                 &quot;Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.&quot;));
1103             if (keyPass != null &amp;&amp; !Arrays.equals(storePass, keyPass)) {
1104                 Object[] source = {&quot;-keypass&quot;};
1105                 System.err.println(form.format(source));
1106                 keyPass = storePass;
1107             }
1108             if (destKeyPass != null &amp;&amp; !Arrays.equals(storePass, destKeyPass)) {
1109                 Object[] source = {&quot;-destkeypass&quot;};
1110                 System.err.println(form.format(source));
1111                 destKeyPass = storePass;
1112             }
1113         }
1114 
1115         // -trustcacerts can be specified on -importcert, -printcert or -printcrl.
1116         // Reset it so that warnings on CA cert will remain for other command.
1117         if (command != IMPORTCERT &amp;&amp; command != PRINTCERT
1118                 &amp;&amp; command != PRINTCRL) {
1119             trustcacerts = false;
1120         }
1121 
1122         if (trustcacerts) {
1123             caks = KeyStoreUtil.getCacertsKeyStore();
1124         }
1125 
1126         // Perform the specified command
1127         if (command == CERTREQ) {
1128             if (filename != null) {
1129                 try (PrintStream ps = new PrintStream(new FileOutputStream
1130                                                       (filename))) {
1131                     doCertReq(alias, sigAlgName, ps);
1132                 }
1133             } else {
1134                 doCertReq(alias, sigAlgName, out);
1135             }
1136             if (verbose &amp;&amp; filename != null) {
1137                 MessageFormat form = new MessageFormat(rb.getString
1138                         (&quot;Certification.request.stored.in.file.filename.&quot;));
1139                 Object[] source = {filename};
1140                 System.err.println(form.format(source));
1141                 System.err.println(rb.getString(&quot;Submit.this.to.your.CA&quot;));
1142             }
1143         } else if (command == DELETE) {
1144             doDeleteEntry(alias);
1145             kssave = true;
1146         } else if (command == EXPORTCERT) {
1147             if (filename != null) {
1148                 try (PrintStream ps = new PrintStream(new FileOutputStream
1149                                                    (filename))) {
1150                     doExportCert(alias, ps);
1151                 }
1152             } else {
1153                 doExportCert(alias, out);
1154             }
1155             if (filename != null) {
1156                 MessageFormat form = new MessageFormat(rb.getString
1157                         (&quot;Certificate.stored.in.file.filename.&quot;));
1158                 Object[] source = {filename};
1159                 System.err.println(form.format(source));
1160             }
1161         } else if (command == GENKEYPAIR) {
1162             if (keyAlgName == null) {
1163                 throw new Exception(rb.getString(
1164                         &quot;keyalg.option.missing.error&quot;));
1165             }
1166             doGenKeyPair(alias, dname, keyAlgName, keysize, groupName, sigAlgName);
1167             kssave = true;
1168         } else if (command == GENSECKEY) {
1169             if (keyAlgName == null) {
1170                 throw new Exception(rb.getString(
1171                         &quot;keyalg.option.missing.error&quot;));
1172             }
1173             doGenSecretKey(alias, keyAlgName, keysize);
1174             kssave = true;
1175         } else if (command == IMPORTPASS) {
1176             if (keyAlgName == null) {
1177                 keyAlgName = &quot;PBE&quot;;
1178             }
1179             // password is stored as a secret key
1180             doGenSecretKey(alias, keyAlgName, keysize);
1181             kssave = true;
1182         } else if (command == IDENTITYDB) {
1183             if (filename != null) {
1184                 try (InputStream inStream = new FileInputStream(filename)) {
1185                     doImportIdentityDatabase(inStream);
1186                 }
1187             } else {
1188                 doImportIdentityDatabase(System.in);
1189             }
1190         } else if (command == IMPORTCERT) {
1191             InputStream inStream = System.in;
1192             if (filename != null) {
1193                 inStream = new FileInputStream(filename);
1194             }
1195             String importAlias = (alias!=null)?alias:keyAlias;
1196             try {
1197                 if (keyStore.entryInstanceOf(
1198                         importAlias, KeyStore.PrivateKeyEntry.class)) {
1199                     kssave = installReply(importAlias, inStream);
1200                     if (kssave) {
1201                         System.err.println(rb.getString
1202                             (&quot;Certificate.reply.was.installed.in.keystore&quot;));
1203                     } else {
1204                         System.err.println(rb.getString
1205                             (&quot;Certificate.reply.was.not.installed.in.keystore&quot;));
1206                     }
1207                 } else if (!keyStore.containsAlias(importAlias) ||
1208                         keyStore.entryInstanceOf(importAlias,
1209                             KeyStore.TrustedCertificateEntry.class)) {
1210                     kssave = addTrustedCert(importAlias, inStream);
1211                     if (kssave) {
1212                         System.err.println(rb.getString
1213                             (&quot;Certificate.was.added.to.keystore&quot;));
1214                     } else {
1215                         System.err.println(rb.getString
1216                             (&quot;Certificate.was.not.added.to.keystore&quot;));
1217                     }
1218                 }
1219             } finally {
1220                 if (inStream != System.in) {
1221                     inStream.close();
1222                 }
1223             }
1224         } else if (command == IMPORTKEYSTORE) {
1225             // When not in-place import, srcKeyStore is not loaded yet.
1226             if (srcKeyStore == null) {
1227                 srcKeyStore = loadSourceKeyStore();
1228             }
1229             doImportKeyStore(srcKeyStore);
1230             kssave = true;
1231         } else if (command == KEYCLONE) {
1232             keyPassNew = newPass;
1233 
1234             // added to make sure only key can go thru
1235             if (alias == null) {
1236                 alias = keyAlias;
1237             }
1238             if (keyStore.containsAlias(alias) == false) {
1239                 MessageFormat form = new MessageFormat
1240                     (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1241                 Object[] source = {alias};
1242                 throw new Exception(form.format(source));
1243             }
1244             if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) {
1245                 MessageFormat form = new MessageFormat(rb.getString(
1246                         &quot;Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key&quot;));
1247                 Object[] source = {alias};
1248                 throw new Exception(form.format(source));
1249             }
1250 
1251             doCloneEntry(alias, dest, true);  // Now everything can be cloned
1252             kssave = true;
1253         } else if (command == CHANGEALIAS) {
1254             if (alias == null) {
1255                 alias = keyAlias;
1256             }
1257             doCloneEntry(alias, dest, false);
1258             // in PKCS11, clone a PrivateKeyEntry will delete the old one
1259             if (keyStore.containsAlias(alias)) {
1260                 doDeleteEntry(alias);
1261             }
1262             kssave = true;
1263         } else if (command == KEYPASSWD) {
1264             keyPassNew = newPass;
1265             doChangeKeyPasswd(alias);
1266             kssave = true;
1267         } else if (command == LIST) {
1268             if (storePass == null
1269                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1270                     &amp;&amp; !isPasswordlessKeyStore) {
1271                 printNoIntegrityWarning();
1272             }
1273 
1274             if (alias != null) {
1275                 doPrintEntry(rb.getString(&quot;the.certificate&quot;), alias, out);
1276             } else {
1277                 doPrintEntries(out);
1278             }
1279         } else if (command == PRINTCERT) {
1280             doPrintCert(out);
1281         } else if (command == SELFCERT) {
1282             doSelfCert(alias, dname, sigAlgName);
1283             kssave = true;
1284         } else if (command == STOREPASSWD) {
1285             doChangeStorePasswd();
1286             kssave = true;
1287         } else if (command == GENCERT) {
1288             if (alias == null) {
1289                 alias = keyAlias;
1290             }
1291             InputStream inStream = System.in;
1292             if (infilename != null) {
1293                 inStream = new FileInputStream(infilename);
1294             }
1295             PrintStream ps = null;
1296             if (outfilename != null) {
1297                 ps = new PrintStream(new FileOutputStream(outfilename));
1298                 out = ps;
1299             }
1300             try {
1301                 doGenCert(alias, sigAlgName, inStream, out);
1302             } finally {
1303                 if (inStream != System.in) {
1304                     inStream.close();
1305                 }
1306                 if (ps != null) {
1307                     ps.close();
1308                 }
1309             }
1310         } else if (command == GENCRL) {
1311             if (alias == null) {
1312                 alias = keyAlias;
1313             }
1314             if (filename != null) {
1315                 try (PrintStream ps =
1316                          new PrintStream(new FileOutputStream(filename))) {
1317                     doGenCRL(ps);
1318                 }
1319             } else {
1320                 doGenCRL(out);
1321             }
1322         } else if (command == PRINTCERTREQ) {
1323             if (filename != null) {
1324                 try (InputStream inStream = new FileInputStream(filename)) {
1325                     doPrintCertReq(inStream, out);
1326                 }
1327             } else {
1328                 doPrintCertReq(System.in, out);
1329             }
1330         } else if (command == PRINTCRL) {
1331             doPrintCRL(filename, out);
1332         } else if (command == SHOWINFO) {
1333             doShowInfo();
1334         }
1335 
1336         // If we need to save the keystore, do so.
1337         if (kssave) {
1338             if (verbose) {
1339                 MessageFormat form = new MessageFormat
1340                         (rb.getString(&quot;.Storing.ksfname.&quot;));
1341                 Object[] source = {nullStream ? &quot;keystore&quot; : ksfname};
1342                 System.err.println(form.format(source));
1343             }
1344 
1345             if (token) {
1346                 keyStore.store(null, null);
1347             } else {
1348                 char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1349                 if (nullStream) {
1350                     keyStore.store(null, pass);
1351                 } else {
1352                     ByteArrayOutputStream bout = new ByteArrayOutputStream();
1353                     keyStore.store(bout, pass);
1354                     try (FileOutputStream fout = new FileOutputStream(ksfname)) {
1355                         fout.write(bout.toByteArray());
1356                     }
1357                 }
1358             }
1359         }
1360 
1361         if (isKeyStoreRelated(command)
1362                 &amp;&amp; !token &amp;&amp; !nullStream &amp;&amp; ksfname != null) {
1363 
1364             // JKS storetype warning on the final result keystore
1365             File f = new File(ksfname);
1366             char[] pass = (storePassNew!=null) ? storePassNew : storePass;
1367             if (f.exists()) {
1368                 // Probe for real type. A JKS can be loaded as PKCS12 because
1369                 // DualFormat support, vice versa.
1370                 String realType = storetype;
1371                 try {
1372                     keyStore = KeyStore.getInstance(f, pass);
1373                     realType = keyStore.getType();
1374                     if (realType.equalsIgnoreCase(&quot;JKS&quot;)
1375                             || realType.equalsIgnoreCase(&quot;JCEKS&quot;)) {
1376                         boolean allCerts = true;
1377                         for (String a : Collections.list(keyStore.aliases())) {
1378                             if (!keyStore.entryInstanceOf(
1379                                     a, TrustedCertificateEntry.class)) {
1380                                 allCerts = false;
1381                                 break;
1382                             }
1383                         }
1384                         // Don&#39;t warn for &quot;cacerts&quot; style keystore.
1385                         if (!allCerts) {
1386                             weakWarnings.add(String.format(
1387                                     rb.getString(&quot;jks.storetype.warning&quot;),
1388                                     realType, ksfname));
1389                         }
1390                     }
1391                 } catch (KeyStoreException e) {
1392                     // Probing not supported, therefore cannot be JKS or JCEKS.
1393                     // Skip the legacy type warning at all.
1394                 }
1395                 if (inplaceImport) {
1396                     String realSourceStoreType = srcstoretype;
1397                     try {
1398                         realSourceStoreType = KeyStore.getInstance(
1399                                 new File(inplaceBackupName), srcstorePass).getType();
1400                     } catch (KeyStoreException e) {
1401                         // Probing not supported. Assuming srcstoretype.
1402                     }
1403                     String format =
1404                             realType.equalsIgnoreCase(realSourceStoreType) ?
1405                             rb.getString(&quot;backup.keystore.warning&quot;) :
1406                             rb.getString(&quot;migrate.keystore.warning&quot;);
1407                     weakWarnings.add(
1408                             String.format(format,
1409                                     srcksfname,
1410                                     realSourceStoreType,
1411                                     inplaceBackupName,
1412                                     realType));
1413                 }
1414             }
1415         }
1416     }
1417 
1418     /**
1419      * Generate a certificate: Read PKCS10 request from in, and print
1420      * certificate to out. Use alias as CA, sigAlgName as the signature
1421      * type.
1422      */
1423     private void doGenCert(String alias, String sigAlgName, InputStream in, PrintStream out)
1424             throws Exception {
1425 
1426 
1427         if (keyStore.containsAlias(alias) == false) {
1428             MessageFormat form = new MessageFormat
1429                     (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1430             Object[] source = {alias};
1431             throw new Exception(form.format(source));
1432         }
1433         Certificate signerCert = keyStore.getCertificate(alias);
1434         byte[] encoded = signerCert.getEncoded();
1435         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1436         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1437                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1438         X500Name issuer = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1439                                            X509CertInfo.DN_NAME);
1440 
1441         Date firstDate = getStartDate(startDate);
1442         Date lastDate = new Date();
1443         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
1444         CertificateValidity interval = new CertificateValidity(firstDate,
1445                                                                lastDate);
1446 
1447         PrivateKey privateKey =
1448                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1449         if (sigAlgName == null) {
1450             sigAlgName = getCompatibleSigAlgName(privateKey);
1451         }
1452         Signature signature = Signature.getInstance(sigAlgName);
1453         AlgorithmParameterSpec params = AlgorithmId
1454                 .getDefaultAlgorithmParameterSpec(sigAlgName, privateKey);
1455 
1456         SignatureUtil.initSignWithParam(signature, privateKey, params, null);
1457 
1458         X509CertInfo info = new X509CertInfo();
1459         AlgorithmId algID = AlgorithmId.getWithParameterSpec(sigAlgName, params);
1460         info.set(X509CertInfo.VALIDITY, interval);
1461         info.set(X509CertInfo.SERIAL_NUMBER,
1462                 CertificateSerialNumber.newRandom64bit(new SecureRandom()));
1463         info.set(X509CertInfo.VERSION,
1464                     new CertificateVersion(CertificateVersion.V3));
1465         info.set(X509CertInfo.ALGORITHM_ID,
1466                     new CertificateAlgorithmId(algID));
1467         info.set(X509CertInfo.ISSUER, issuer);
1468 
1469         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1470         boolean canRead = false;
1471         StringBuffer sb = new StringBuffer();
1472         while (true) {
1473             String s = reader.readLine();
1474             if (s == null) break;
1475             // OpenSSL does not use NEW
1476             //if (s.startsWith(&quot;-----BEGIN NEW CERTIFICATE REQUEST-----&quot;)) {
1477             if (s.startsWith(&quot;-----BEGIN&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1478                 canRead = true;
1479             //} else if (s.startsWith(&quot;-----END NEW CERTIFICATE REQUEST-----&quot;)) {
1480             } else if (s.startsWith(&quot;-----END&quot;) &amp;&amp; s.indexOf(&quot;REQUEST&quot;) &gt;= 0) {
1481                 break;
1482             } else if (canRead) {
1483                 sb.append(s);
1484             }
1485         }
1486         byte[] rawReq = Pem.decode(new String(sb));
1487         PKCS10 req = new PKCS10(rawReq);
1488 
1489         checkWeak(rb.getString(&quot;the.certificate.request&quot;), req);
1490 
1491         info.set(X509CertInfo.KEY, new CertificateX509Key(req.getSubjectPublicKeyInfo()));
1492         info.set(X509CertInfo.SUBJECT,
1493                     dname==null?req.getSubjectName():new X500Name(dname));
1494         CertificateExtensions reqex = null;
1495         Iterator&lt;PKCS10Attribute&gt; attrs = req.getAttributes().getAttributes().iterator();
1496         while (attrs.hasNext()) {
1497             PKCS10Attribute attr = attrs.next();
1498             if (attr.getAttributeId().equals(PKCS9Attribute.EXTENSION_REQUEST_OID)) {
1499                 reqex = (CertificateExtensions)attr.getAttributeValue();
1500             }
1501         }
1502         CertificateExtensions ext = createV3Extensions(
1503                 reqex,
1504                 null,
1505                 v3ext,
1506                 req.getSubjectPublicKeyInfo(),
1507                 signerCert.getPublicKey());
1508         info.set(X509CertInfo.EXTENSIONS, ext);
1509         X509CertImpl cert = new X509CertImpl(info);
1510         cert.sign(privateKey, params, sigAlgName, null);
1511         dumpCert(cert, out);
1512         for (Certificate ca: keyStore.getCertificateChain(alias)) {
1513             if (ca instanceof X509Certificate) {
1514                 X509Certificate xca = (X509Certificate)ca;
1515                 if (!KeyStoreUtil.isSelfSigned(xca)) {
1516                     dumpCert(xca, out);
1517                 }
1518             }
1519         }
1520 
1521         checkWeak(rb.getString(&quot;the.issuer&quot;), keyStore.getCertificateChain(alias));
1522         checkWeak(rb.getString(&quot;the.generated.certificate&quot;), cert);
1523     }
1524 
1525     private void doGenCRL(PrintStream out)
1526             throws Exception {
1527         if (ids == null) {
1528             throw new Exception(&quot;Must provide -id when -gencrl&quot;);
1529         }
1530         Certificate signerCert = keyStore.getCertificate(alias);
1531         byte[] encoded = signerCert.getEncoded();
1532         X509CertImpl signerCertImpl = new X509CertImpl(encoded);
1533         X509CertInfo signerCertInfo = (X509CertInfo)signerCertImpl.get(
1534                 X509CertImpl.NAME + &quot;.&quot; + X509CertImpl.INFO);
1535         X500Name owner = (X500Name)signerCertInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
1536                                                       X509CertInfo.DN_NAME);
1537 
1538         Date firstDate = getStartDate(startDate);
1539         Date lastDate = (Date) firstDate.clone();
1540         lastDate.setTime(lastDate.getTime() + validity*1000*24*60*60);
1541         CertificateValidity interval = new CertificateValidity(firstDate,
1542                                                                lastDate);
1543 
1544 
1545         PrivateKey privateKey =
1546                 (PrivateKey)recoverKey(alias, storePass, keyPass).fst;
1547         if (sigAlgName == null) {
1548             sigAlgName = getCompatibleSigAlgName(privateKey);
1549         }
1550 
1551         X509CRLEntry[] badCerts = new X509CRLEntry[ids.size()];
1552         for (int i=0; i&lt;ids.size(); i++) {
1553             String id = ids.get(i);
1554             int d = id.indexOf(&#39;:&#39;);
1555             if (d &gt;= 0) {
1556                 CRLExtensions ext = new CRLExtensions();
1557                 ext.set(&quot;Reason&quot;, new CRLReasonCodeExtension(Integer.parseInt(id.substring(d+1))));
1558                 badCerts[i] = new X509CRLEntryImpl(new BigInteger(id.substring(0, d)),
1559                         firstDate, ext);
1560             } else {
1561                 badCerts[i] = new X509CRLEntryImpl(new BigInteger(ids.get(i)), firstDate);
1562             }
1563         }
1564         X509CRLImpl crl = new X509CRLImpl(owner, firstDate, lastDate, badCerts);
1565         crl.sign(privateKey, sigAlgName);
1566         if (rfc) {
1567             out.println(&quot;-----BEGIN X509 CRL-----&quot;);
1568             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(crl.getEncodedInternal()));
1569             out.println(&quot;-----END X509 CRL-----&quot;);
1570         } else {
1571             out.write(crl.getEncodedInternal());
1572         }
1573         checkWeak(rb.getString(&quot;the.generated.crl&quot;), crl, privateKey);
1574     }
1575 
1576     /**
1577      * Creates a PKCS#10 cert signing request, corresponding to the
1578      * keys (and name) associated with a given alias.
1579      */
1580     private void doCertReq(String alias, String sigAlgName, PrintStream out)
1581         throws Exception
1582     {
1583         if (alias == null) {
1584             alias = keyAlias;
1585         }
1586 
1587         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
1588         PrivateKey privKey = (PrivateKey)objs.fst;
1589         if (keyPass == null) {
1590             keyPass = objs.snd;
1591         }
1592 
1593         Certificate cert = keyStore.getCertificate(alias);
1594         if (cert == null) {
1595             MessageFormat form = new MessageFormat
1596                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
1597             Object[] source = {alias};
1598             throw new Exception(form.format(source));
1599         }
1600         PKCS10 request = new PKCS10(cert.getPublicKey());
1601         CertificateExtensions ext = createV3Extensions(null, null, v3ext, cert.getPublicKey(), null);
1602         // Attribute name is not significant
1603         request.getAttributes().setAttribute(X509CertInfo.EXTENSIONS,
1604                 new PKCS10Attribute(PKCS9Attribute.EXTENSION_REQUEST_OID, ext));
1605 
1606         // Construct a Signature object, so that we can sign the request
1607         if (sigAlgName == null) {
1608             sigAlgName = getCompatibleSigAlgName(privKey);
1609         }
1610 
1611         Signature signature = Signature.getInstance(sigAlgName);
1612         AlgorithmParameterSpec params = AlgorithmId
1613                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
1614         SignatureUtil.initSignWithParam(signature, privKey, params, null);
1615 
1616         X500Name subject = dname == null?
1617                 new X500Name(((X509Certificate)cert).getSubjectDN().toString()):
1618                 new X500Name(dname);
1619 
1620         // Sign the request and base-64 encode it
1621         request.encodeAndSign(subject, signature);
1622         request.print(out);
1623 
1624         checkWeak(rb.getString(&quot;the.generated.certificate.request&quot;), request);
1625     }
1626 
1627     /**
1628      * Deletes an entry from the keystore.
1629      */
1630     private void doDeleteEntry(String alias) throws Exception {
1631         if (keyStore.containsAlias(alias) == false) {
1632             MessageFormat form = new MessageFormat
1633                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1634             Object[] source = {alias};
1635             throw new Exception(form.format(source));
1636         }
1637         keyStore.deleteEntry(alias);
1638     }
1639 
1640     /**
1641      * Exports a certificate from the keystore.
1642      */
1643     private void doExportCert(String alias, PrintStream out)
1644         throws Exception
1645     {
1646         if (storePass == null
1647                 &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)
1648                 &amp;&amp; !isPasswordlessKeyStore) {
1649             printNoIntegrityWarning();
1650         }
1651         if (alias == null) {
1652             alias = keyAlias;
1653         }
1654         if (keyStore.containsAlias(alias) == false) {
1655             MessageFormat form = new MessageFormat
1656                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
1657             Object[] source = {alias};
1658             throw new Exception(form.format(source));
1659         }
1660 
1661         X509Certificate cert = (X509Certificate)keyStore.getCertificate(alias);
1662         if (cert == null) {
1663             MessageFormat form = new MessageFormat
1664                 (rb.getString(&quot;Alias.alias.has.no.certificate&quot;));
1665             Object[] source = {alias};
1666             throw new Exception(form.format(source));
1667         }
1668         dumpCert(cert, out);
1669         checkWeak(rb.getString(&quot;the.certificate&quot;), cert);
1670     }
1671 
1672     /**
1673      * Prompt the user for a keypass when generating a key entry.
1674      * @param alias the entry we will set password for
1675      * @param orig the original entry of doing a dup, null if generate new
1676      * @param origPass the password to copy from if user press ENTER
1677      */
1678     private char[] promptForKeyPass(String alias, String orig, char[] origPass) throws Exception{
1679         if (origPass != null &amp;&amp; P12KEYSTORE.equalsIgnoreCase(storetype)) {
1680             return origPass;
1681         } else if (!token &amp;&amp; !protectedPath) {
1682             // Prompt for key password
1683             int count;
1684             for (count = 0; count &lt; 3; count++) {
1685                 MessageFormat form = new MessageFormat(rb.getString
1686                         (&quot;Enter.key.password.for.alias.&quot;));
1687                 Object[] source = {alias};
1688                 System.err.print(form.format(source));
1689                 if (origPass != null) {
1690                     System.err.println();
1691                     if (orig == null) {
1692                         System.err.print(rb.getString
1693                                 (&quot;.RETURN.if.same.as.keystore.password.&quot;));
1694                     } else {
1695                         form = new MessageFormat(rb.getString
1696                                 (&quot;.RETURN.if.same.as.for.otherAlias.&quot;));
1697                         Object[] src = {orig};
1698                         System.err.print(form.format(src));
1699                     }
1700                 }
1701                 System.err.flush();
1702                 char[] entered = Password.readPassword(System.in);
1703                 passwords.add(entered);
1704                 if (entered == null &amp;&amp; origPass != null) {
1705                     return origPass;
1706                 } else if (entered != null &amp;&amp; entered.length &gt;= 6) {
1707                     System.err.print(rb.getString(&quot;Re.enter.new.password.&quot;));
1708                     char[] passAgain = Password.readPassword(System.in);
1709                     passwords.add(passAgain);
1710                     if (!Arrays.equals(entered, passAgain)) {
1711                         System.err.println
1712                             (rb.getString(&quot;They.don.t.match.Try.again&quot;));
1713                         continue;
1714                     }
1715                     return entered;
1716                 } else {
1717                     System.err.println(rb.getString
1718                         (&quot;Key.password.is.too.short.must.be.at.least.6.characters&quot;));
1719                 }
1720             }
1721             if (count == 3) {
1722                 if (command == KEYCLONE) {
1723                     throw new Exception(rb.getString
1724                         (&quot;Too.many.failures.Key.entry.not.cloned&quot;));
1725                 } else {
1726                     throw new Exception(rb.getString
1727                             (&quot;Too.many.failures.key.not.added.to.keystore&quot;));
1728                 }
1729             }
1730         }
1731         return null;    // PKCS11, MSCAPI, or -protected
1732     }
1733 
1734     /*
1735      * Prompt the user for the password credential to be stored.
1736      */
1737     private char[] promptForCredential() throws Exception {
1738         // Handle password supplied via stdin
1739         if (System.console() == null) {
1740             char[] importPass = Password.readPassword(System.in);
1741             passwords.add(importPass);
1742             return importPass;
1743         }
1744 
1745         int count;
1746         for (count = 0; count &lt; 3; count++) {
1747             System.err.print(
1748                 rb.getString(&quot;Enter.the.password.to.be.stored.&quot;));
1749             System.err.flush();
1750             char[] entered = Password.readPassword(System.in);
1751             passwords.add(entered);
1752             System.err.print(rb.getString(&quot;Re.enter.password.&quot;));
1753             char[] passAgain = Password.readPassword(System.in);
1754             passwords.add(passAgain);
1755             if (!Arrays.equals(entered, passAgain)) {
1756                 System.err.println(rb.getString(&quot;They.don.t.match.Try.again&quot;));
1757                 continue;
1758             }
1759             return entered;
1760         }
1761 
1762         if (count == 3) {
1763             throw new Exception(rb.getString
1764                 (&quot;Too.many.failures.key.not.added.to.keystore&quot;));
1765         }
1766 
1767         return null;
1768     }
1769 
1770     /**
1771      * Creates a new secret key.
1772      */
1773     private void doGenSecretKey(String alias, String keyAlgName,
1774                               int keysize)
1775         throws Exception
1776     {
1777         if (alias == null) {
1778             alias = keyAlias;
1779         }
1780         if (keyStore.containsAlias(alias)) {
1781             MessageFormat form = new MessageFormat(rb.getString
1782                 (&quot;Secret.key.not.generated.alias.alias.already.exists&quot;));
1783             Object[] source = {alias};
1784             throw new Exception(form.format(source));
1785         }
1786 
1787         // Use the keystore&#39;s default PBE algorithm for entry protection
1788         boolean useDefaultPBEAlgorithm = true;
1789         SecretKey secKey = null;
1790 
1791         if (keyAlgName.toUpperCase(Locale.ENGLISH).startsWith(&quot;PBE&quot;)) {
1792             SecretKeyFactory factory = SecretKeyFactory.getInstance(&quot;PBE&quot;);
1793 
1794             // User is prompted for PBE credential
1795             secKey =
1796                 factory.generateSecret(new PBEKeySpec(promptForCredential()));
1797 
1798             // Check whether a specific PBE algorithm was specified
1799             if (!&quot;PBE&quot;.equalsIgnoreCase(keyAlgName)) {
1800                 useDefaultPBEAlgorithm = false;
1801             }
1802 
1803             if (verbose) {
1804                 MessageFormat form = new MessageFormat(rb.getString(
1805                     &quot;Generated.keyAlgName.secret.key&quot;));
1806                 Object[] source =
1807                     {useDefaultPBEAlgorithm ? &quot;PBE&quot; : secKey.getAlgorithm()};
1808                 System.err.println(form.format(source));
1809             }
1810         } else {
1811             KeyGenerator keygen = KeyGenerator.getInstance(keyAlgName);
1812             if (keysize == -1) {
1813                 if (&quot;DES&quot;.equalsIgnoreCase(keyAlgName)) {
1814                     keysize = 56;
1815                 } else if (&quot;DESede&quot;.equalsIgnoreCase(keyAlgName)) {
1816                     keysize = 168;
1817                 } else {
1818                     throw new Exception(rb.getString
1819                         (&quot;Please.provide.keysize.for.secret.key.generation&quot;));
1820                 }
1821             }
1822             keygen.init(keysize);
1823             secKey = keygen.generateKey();
1824 
1825             MessageFormat form = new MessageFormat(rb.getString
1826                 (&quot;Generated.keysize.bit.keyAlgName.secret.key&quot;));
1827             Object[] source = {keysize,
1828                                 secKey.getAlgorithm()};
1829             System.err.println(form.format(source));
1830         }
1831 
1832         if (keyPass == null) {
1833             keyPass = promptForKeyPass(alias, null, storePass);
1834         }
1835 
1836         if (useDefaultPBEAlgorithm) {
1837             keyStore.setKeyEntry(alias, secKey, keyPass, null);
1838         } else {
1839             keyStore.setEntry(alias, new KeyStore.SecretKeyEntry(secKey),
1840                 new KeyStore.PasswordProtection(keyPass, keyAlgName, null));
1841         }
1842     }
1843 
1844     /**
1845      * If no signature algorithm was specified at the command line,
1846      * we choose one that is compatible with the selected private key
1847      */
1848     private static String getCompatibleSigAlgName(PrivateKey key)
1849             throws Exception {
1850         String result = AlgorithmId.getDefaultSigAlgForKey(key);
1851         if (result != null) {
1852             return result;
1853         } else {
1854             throw new Exception(rb.getString
1855                     (&quot;Cannot.derive.signature.algorithm&quot;));
1856         }
1857     }
1858 
1859     /**
1860      * Creates a new key pair and self-signed certificate.
1861      */
1862     private void doGenKeyPair(String alias, String dname, String keyAlgName,
1863                               int keysize, String groupName, String sigAlgName)
1864         throws Exception
1865     {
1866         if (groupName != null) {
1867             if (keysize != -1) {
1868                 throw new Exception(rb.getString(&quot;groupname.keysize.coexist&quot;));
1869             }
1870         } else {
1871             if (keysize == -1) {
1872                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1873                     keysize = SecurityProviderConstants.DEF_EC_KEY_SIZE;
1874                 } else if (&quot;RSA&quot;.equalsIgnoreCase(keyAlgName)) {
1875                     keysize = SecurityProviderConstants.DEF_RSA_KEY_SIZE;
1876                 } else if (&quot;DSA&quot;.equalsIgnoreCase(keyAlgName)) {
1877                     keysize = SecurityProviderConstants.DEF_DSA_KEY_SIZE;
1878                 } else if (&quot;EdDSA&quot;.equalsIgnoreCase(keyAlgName)) {
1879                     keysize = SecurityProviderConstants.DEF_ED_KEY_SIZE;
1880                 } else if (&quot;Ed25519&quot;.equalsIgnoreCase(keyAlgName)) {
1881                     keysize = 255;
1882                 } else if (&quot;Ed448&quot;.equalsIgnoreCase(keyAlgName)) {
1883                     keysize = 448;
1884                 }
1885             } else {
1886                 if (&quot;EC&quot;.equalsIgnoreCase(keyAlgName)) {
1887                     weakWarnings.add(String.format(
1888                             rb.getString(&quot;deprecate.keysize.for.ec&quot;),
1889                             ecGroupNameForSize(keysize)));
1890                 }
1891             }
1892         }
1893 
1894         if (alias == null) {
1895             alias = keyAlias;
1896         }
1897 
1898         if (keyStore.containsAlias(alias)) {
1899             MessageFormat form = new MessageFormat(rb.getString
1900                 (&quot;Key.pair.not.generated.alias.alias.already.exists&quot;));
1901             Object[] source = {alias};
1902             throw new Exception(form.format(source));
1903         }
1904 
1905         CertAndKeyGen keypair =
1906                 new CertAndKeyGen(keyAlgName, sigAlgName, providerName);
1907 
1908 
1909         // If DN is provided, parse it. Otherwise, prompt the user for it.
1910         X500Name x500Name;
1911         if (dname == null) {
1912             printWeakWarnings(true);
1913             x500Name = getX500Name();
1914         } else {
1915             x500Name = new X500Name(dname);
1916         }
1917 
1918         if (groupName != null) {
1919             keypair.generate(groupName);
1920         } else {
1921             // This covers keysize both specified and unspecified
1922             keypair.generate(keysize);
1923         }
1924 
1925         PrivateKey privKey = keypair.getPrivateKey();
1926 
1927         CertificateExtensions ext = createV3Extensions(
1928                 null,
1929                 null,
1930                 v3ext,
1931                 keypair.getPublicKeyAnyway(),
1932                 null);
1933 
1934         X509Certificate[] chain = new X509Certificate[1];
1935         chain[0] = keypair.getSelfCertificate(
1936                 x500Name, getStartDate(startDate), validity*24L*60L*60L, ext);
1937 
1938         MessageFormat form = new MessageFormat(rb.getString
1939             (&quot;Generating.keysize.bit.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.validality.days.for&quot;));
1940         Object[] source = {
1941                 groupName == null ? keysize : KeyUtil.getKeySize(privKey),
1942                 fullDisplayAlgName(privKey),
1943                 chain[0].getSigAlgName(),
1944                 validity,
1945                 x500Name};
1946         System.err.println(form.format(source));
1947 
1948         if (keyPass == null) {
1949             keyPass = promptForKeyPass(alias, null, storePass);
1950         }
1951         checkWeak(rb.getString(&quot;the.generated.certificate&quot;), chain[0]);
1952         keyStore.setKeyEntry(alias, privKey, keyPass, chain);
1953     }
1954 
1955     private String ecGroupNameForSize(int size) throws Exception {
1956         AlgorithmParameters ap = AlgorithmParameters.getInstance(&quot;EC&quot;);
1957         ap.init(new ECKeySizeParameterSpec(size));
1958         // The following line assumes the toString value is &quot;name (oid)&quot;
1959         return ap.toString().split(&quot; &quot;)[0];
1960     }
1961 
1962     /**
1963      * Clones an entry
1964      * @param orig original alias
1965      * @param dest destination alias
1966      * @changePassword if the password can be changed
1967      */
1968     private void doCloneEntry(String orig, String dest, boolean changePassword)
1969         throws Exception
1970     {
1971         if (orig == null) {
1972             orig = keyAlias;
1973         }
1974 
1975         if (keyStore.containsAlias(dest)) {
1976             MessageFormat form = new MessageFormat
1977                 (rb.getString(&quot;Destination.alias.dest.already.exists&quot;));
1978             Object[] source = {dest};
1979             throw new Exception(form.format(source));
1980         }
1981 
1982         Pair&lt;Entry,char[]&gt; objs = recoverEntry(keyStore, orig, storePass, keyPass);
1983         Entry entry = objs.fst;
1984         keyPass = objs.snd;
1985 
1986         PasswordProtection pp = null;
1987 
1988         if (keyPass != null) {  // protected
1989             if (!changePassword || P12KEYSTORE.equalsIgnoreCase(storetype)) {
1990                 keyPassNew = keyPass;
1991             } else {
1992                 if (keyPassNew == null) {
1993                     keyPassNew = promptForKeyPass(dest, orig, keyPass);
1994                 }
1995             }
1996             pp = new PasswordProtection(keyPassNew);
1997         }
1998         keyStore.setEntry(dest, entry, pp);
1999     }
2000 
2001     /**
2002      * Changes a key password.
2003      */
2004     private void doChangeKeyPasswd(String alias) throws Exception
2005     {
2006 
2007         if (alias == null) {
2008             alias = keyAlias;
2009         }
2010         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
2011         Key privKey = objs.fst;
2012         if (keyPass == null) {
2013             keyPass = objs.snd;
2014         }
2015 
2016         if (keyPassNew == null) {
2017             MessageFormat form = new MessageFormat
2018                 (rb.getString(&quot;key.password.for.alias.&quot;));
2019             Object[] source = {alias};
2020             keyPassNew = getNewPasswd(form.format(source), keyPass);
2021         }
2022         keyStore.setKeyEntry(alias, privKey, keyPassNew,
2023                              keyStore.getCertificateChain(alias));
2024     }
2025 
2026     /**
2027      * Imports a JDK 1.1-style identity database. We can only store one
2028      * certificate per identity, because we use the identity&#39;s name as the
2029      * alias (which references a keystore entry), and aliases must be unique.
2030      */
2031     private void doImportIdentityDatabase(InputStream in)
2032         throws Exception
2033     {
2034         System.err.println(rb.getString
2035             (&quot;No.entries.from.identity.database.added&quot;));
2036     }
2037 
2038     /**
2039      * Prints a single keystore entry.
2040      */
2041     private void doPrintEntry(String label, String alias, PrintStream out)
2042         throws Exception
2043     {
2044         if (keyStore.containsAlias(alias) == false) {
2045             MessageFormat form = new MessageFormat
2046                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
2047             Object[] source = {alias};
2048             throw new Exception(form.format(source));
2049         }
2050 
2051         if (verbose || rfc || debug) {
2052             MessageFormat form = new MessageFormat
2053                 (rb.getString(&quot;Alias.name.alias&quot;));
2054             Object[] source = {alias};
2055             out.println(form.format(source));
2056 
2057             if (!token) {
2058                 form = new MessageFormat(rb.getString
2059                     (&quot;Creation.date.keyStore.getCreationDate.alias.&quot;));
2060                 Object[] src = {keyStore.getCreationDate(alias)};
2061                 out.println(form.format(src));
2062             }
2063         } else {
2064             if (!token) {
2065                 MessageFormat form = new MessageFormat
2066                     (rb.getString(&quot;alias.keyStore.getCreationDate.alias.&quot;));
2067                 Object[] source = {alias, keyStore.getCreationDate(alias)};
2068                 out.print(form.format(source));
2069             } else {
2070                 MessageFormat form = new MessageFormat
2071                     (rb.getString(&quot;alias.&quot;));
2072                 Object[] source = {alias};
2073                 out.print(form.format(source));
2074             }
2075         }
2076 
2077         if (keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
2078             if (verbose || rfc || debug) {
2079                 Object[] source = {&quot;SecretKeyEntry&quot;};
2080                 out.println(new MessageFormat(
2081                         rb.getString(&quot;Entry.type.type.&quot;)).format(source));
2082             } else {
2083                 out.println(&quot;SecretKeyEntry, &quot;);
2084             }
2085         } else if (keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class)) {
2086             if (verbose || rfc || debug) {
2087                 Object[] source = {&quot;PrivateKeyEntry&quot;};
2088                 out.println(new MessageFormat(
2089                         rb.getString(&quot;Entry.type.type.&quot;)).format(source));
2090             } else {
2091                 out.println(&quot;PrivateKeyEntry, &quot;);
2092             }
2093 
2094             // Get the chain
2095             Certificate[] chain = keyStore.getCertificateChain(alias);
2096             if (chain != null) {
2097                 if (verbose || rfc || debug) {
2098                     out.println(rb.getString
2099                         (&quot;Certificate.chain.length.&quot;) + chain.length);
2100                     for (int i = 0; i &lt; chain.length; i ++) {
2101                         MessageFormat form = new MessageFormat
2102                                 (rb.getString(&quot;Certificate.i.1.&quot;));
2103                         Object[] source = {(i + 1)};
2104                         out.println(form.format(source));
2105                         if (verbose &amp;&amp; (chain[i] instanceof X509Certificate)) {
2106                             printX509Cert((X509Certificate)(chain[i]), out);
2107                         } else if (debug) {
2108                             out.println(chain[i].toString());
2109                         } else {
2110                             dumpCert(chain[i], out);
2111                         }
2112                         checkWeak(label, chain[i]);
2113                     }
2114                 } else {
2115                     // Print the digest of the user cert only
2116                     out.println
2117                         (rb.getString(&quot;Certificate.fingerprint.SHA.256.&quot;) +
2118                         getCertFingerPrint(&quot;SHA-256&quot;, chain[0]));
2119                     checkWeak(label, chain);
2120                 }
2121             } else {
2122                 out.println(rb.getString
2123                         (&quot;Certificate.chain.length.&quot;) + 0);
2124             }
2125         } else if (keyStore.entryInstanceOf(alias,
2126                 KeyStore.TrustedCertificateEntry.class)) {
2127             // We have a trusted certificate entry
2128             Certificate cert = keyStore.getCertificate(alias);
2129             Object[] source = {&quot;trustedCertEntry&quot;};
2130             String mf = new MessageFormat(
2131                     rb.getString(&quot;Entry.type.type.&quot;)).format(source) + &quot;\n&quot;;
2132             if (verbose &amp;&amp; (cert instanceof X509Certificate)) {
2133                 out.println(mf);
2134                 printX509Cert((X509Certificate)cert, out);
2135             } else if (rfc) {
2136                 out.println(mf);
2137                 dumpCert(cert, out);
2138             } else if (debug) {
2139                 out.println(cert.toString());
2140             } else {
2141                 out.println(&quot;trustedCertEntry, &quot;);
2142                 out.println(rb.getString(&quot;Certificate.fingerprint.SHA.256.&quot;)
2143                             + getCertFingerPrint(&quot;SHA-256&quot;, cert));
2144             }
2145             checkWeak(label, cert);
2146         } else {
2147             out.println(rb.getString(&quot;Unknown.Entry.Type&quot;));
2148         }
2149     }
2150 
2151     boolean inplaceImportCheck() throws Exception {
2152         if (P11KEYSTORE.equalsIgnoreCase(srcstoretype) ||
2153                 KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2154             return false;
2155         }
2156 
2157         if (srcksfname != null) {
2158             File srcksfile = new File(srcksfname);
2159             if (srcksfile.exists() &amp;&amp; srcksfile.length() == 0) {
2160                 throw new Exception(rb.getString
2161                         (&quot;Source.keystore.file.exists.but.is.empty.&quot;) +
2162                         srcksfname);
2163             }
2164             if (srcksfile.getCanonicalFile()
2165                     .equals(new File(ksfname).getCanonicalFile())) {
2166                 return true;
2167             } else {
2168                 // Informational, especially if destkeystore is not
2169                 // provided, which default to ~/.keystore.
2170                 System.err.println(String.format(rb.getString(
2171                         &quot;importing.keystore.status&quot;), srcksfname, ksfname));
2172                 return false;
2173             }
2174         } else {
2175             throw new Exception(rb.getString
2176                     (&quot;Please.specify.srckeystore&quot;));
2177         }
2178     }
2179 
2180     /**
2181      * Load the srckeystore from a stream, used in -importkeystore
2182      * @return the src KeyStore
2183      */
2184     KeyStore loadSourceKeyStore() throws Exception {
2185 
2186         InputStream is = null;
2187         File srcksfile = null;
2188         boolean srcIsPasswordless = false;
2189 
2190         if (P11KEYSTORE.equalsIgnoreCase(srcstoretype) ||
2191                 KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2192             if (!NONE.equals(srcksfname)) {
2193                 System.err.println(MessageFormat.format(rb.getString
2194                     (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), srcstoretype));
2195                 System.err.println();
2196                 tinyHelp();
2197             }
2198         } else {
2199             srcksfile = new File(srcksfname);
2200             is = new FileInputStream(srcksfile);
2201         }
2202 
2203         KeyStore store;
2204         try {
2205             // Probe for keystore type when filename is available
2206             if (srcksfile != null &amp;&amp; is != null &amp;&amp; srcProviderName == null &amp;&amp;
2207                     srcstoretype == null) {
2208                 store = KeyStore.getInstance(srcksfile, srcstorePass);
2209                 srcstoretype = store.getType();
2210                 if (srcstoretype.equalsIgnoreCase(&quot;pkcs12&quot;)) {
2211                     srcIsPasswordless = PKCS12KeyStore.isPasswordless(srcksfile);
2212                 }
2213             } else {
2214                 if (srcstoretype == null) {
2215                     srcstoretype = KeyStore.getDefaultType();
2216                 }
2217                 if (srcProviderName == null) {
2218                     store = KeyStore.getInstance(srcstoretype);
2219                 } else {
2220                     store = KeyStore.getInstance(srcstoretype, srcProviderName);
2221                 }
2222             }
2223 
2224             if (srcstorePass == null
2225                     &amp;&amp; !srcprotectedPath
2226                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(srcstoretype)
2227                     &amp;&amp; !srcIsPasswordless) {
2228                 System.err.print(rb.getString(&quot;Enter.source.keystore.password.&quot;));
2229                 System.err.flush();
2230                 srcstorePass = Password.readPassword(System.in);
2231                 passwords.add(srcstorePass);
2232             }
2233 
2234             // always let keypass be storepass when using pkcs12
2235             if (P12KEYSTORE.equalsIgnoreCase(srcstoretype)) {
2236                 if (srckeyPass != null &amp;&amp; srcstorePass != null &amp;&amp;
2237                         !Arrays.equals(srcstorePass, srckeyPass)) {
2238                     MessageFormat form = new MessageFormat(rb.getString(
2239                         &quot;Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.&quot;));
2240                     Object[] source = {&quot;-srckeypass&quot;};
2241                     System.err.println(form.format(source));
2242                     srckeyPass = srcstorePass;
2243                 }
2244             }
2245 
2246             store.load(is, srcstorePass);   // &quot;is&quot; already null in PKCS11
2247         } finally {
2248             if (is != null) {
2249                 is.close();
2250             }
2251         }
2252 
2253         if (srcstorePass == null
2254                 &amp;&amp; !srcIsPasswordless
2255                 &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {
2256             // anti refactoring, copied from printNoIntegrityWarning(),
2257             // but change 2 lines
2258             System.err.println();
2259             System.err.println(rb.getString
2260                 (&quot;.WARNING.WARNING.WARNING.&quot;));
2261             System.err.println(rb.getString
2262                 (&quot;.The.integrity.of.the.information.stored.in.the.srckeystore.&quot;));
2263             System.err.println(rb.getString
2264                 (&quot;.WARNING.WARNING.WARNING.&quot;));
2265             System.err.println();
2266         }
2267 
2268         return store;
2269     }
2270 
2271     /**
2272      * import all keys and certs from importkeystore.
2273      * keep alias unchanged if no name conflict, otherwise, prompt.
2274      * keep keypass unchanged for keys
2275      */
2276     private void doImportKeyStore(KeyStore srcKS) throws Exception {
2277 
2278         if (alias != null) {
2279             doImportKeyStoreSingle(srcKS, alias);
2280         } else {
2281             if (dest != null || srckeyPass != null) {
2282                 throw new Exception(rb.getString(
2283                         &quot;if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified&quot;));
2284             }
2285             doImportKeyStoreAll(srcKS);
2286         }
2287 
2288         if (inplaceImport) {
2289             // Backup to file.old or file.old2...
2290             // The keystore is not rewritten yet now.
2291             for (int n = 1; /* forever */; n++) {
2292                 inplaceBackupName = srcksfname + &quot;.old&quot; + (n == 1 ? &quot;&quot; : n);
2293                 File bkFile = new File(inplaceBackupName);
2294                 if (!bkFile.exists()) {
2295                     Files.copy(Path.of(srcksfname), bkFile.toPath());
2296                     break;
2297                 }
2298             }
2299 
2300         }
2301 
2302         /*
2303          * Information display rule of -importkeystore
2304          * 1. inside single, shows failure
2305          * 2. inside all, shows sucess
2306          * 3. inside all where there is a failure, prompt for continue
2307          * 4. at the final of all, shows summary
2308          */
2309     }
2310 
2311     /**
2312      * Import a single entry named alias from srckeystore
2313      * @return  1 if the import action succeed
2314      *          0 if user choose to ignore an alias-dumplicated entry
2315      *          2 if setEntry throws Exception
2316      */
2317     private int doImportKeyStoreSingle(KeyStore srckeystore, String alias)
2318             throws Exception {
2319 
2320         String newAlias = (dest==null) ? alias : dest;
2321 
2322         if (keyStore.containsAlias(newAlias)) {
2323             Object[] source = {alias};
2324             if (noprompt) {
2325                 System.err.println(new MessageFormat(rb.getString(
2326                         &quot;Warning.Overwriting.existing.alias.alias.in.destination.keystore&quot;)).format(source));
2327             } else {
2328                 String reply = getYesNoReply(new MessageFormat(rb.getString(
2329                         &quot;Existing.entry.alias.alias.exists.overwrite.no.&quot;)).format(source));
2330                 if (&quot;NO&quot;.equals(reply)) {
2331                     newAlias = inputStringFromStdin(rb.getString
2332                             (&quot;Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.&quot;));
2333                     if (&quot;&quot;.equals(newAlias)) {
2334                         System.err.println(new MessageFormat(rb.getString(
2335                                 &quot;Entry.for.alias.alias.not.imported.&quot;)).format(
2336                                 source));
2337                         return 0;
2338                     }
2339                 }
2340             }
2341         }
2342 
2343         Pair&lt;Entry,char[]&gt; objs = recoverEntry(srckeystore, alias, srcstorePass, srckeyPass);
2344         Entry entry = objs.fst;
2345 
2346         PasswordProtection pp = null;
2347 
2348         // According to keytool.html, &quot;The destination entry will be protected
2349         // using destkeypass. If destkeypass is not provided, the destination
2350         // entry will be protected with the source entry password.&quot;
2351         // so always try to protect with destKeyPass.
2352         char[] newPass = null;
2353         if (destKeyPass != null) {
2354             newPass = destKeyPass;
2355             pp = new PasswordProtection(destKeyPass);
2356         } else if (objs.snd != null) {
2357             newPass = P12KEYSTORE.equalsIgnoreCase(storetype) ?
2358                     storePass : objs.snd;
2359             pp = new PasswordProtection(newPass);
2360         }
2361 
2362         try {
2363             Certificate c = srckeystore.getCertificate(alias);
2364             if (c != null) {
2365                 checkWeak(&quot;&lt;&quot; + newAlias + &quot;&gt;&quot;, c);
2366             }
2367             keyStore.setEntry(newAlias, entry, pp);
2368             // Place the check so that only successful imports are blocked.
2369             // For example, we don&#39;t block a failed SecretEntry import.
2370             if (P12KEYSTORE.equalsIgnoreCase(storetype)) {
2371                 if (newPass != null &amp;&amp; !Arrays.equals(newPass, storePass)) {
2372                     throw new Exception(rb.getString(
2373                             &quot;The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.&quot;));
2374                 }
2375             }
2376             return 1;
2377         } catch (KeyStoreException kse) {
2378             Object[] source2 = {alias, kse.toString()};
2379             MessageFormat form = new MessageFormat(rb.getString(
2380                     &quot;Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.&quot;));
2381             System.err.println(form.format(source2));
2382             return 2;
2383         }
2384     }
2385 
2386     private void doImportKeyStoreAll(KeyStore srckeystore) throws Exception {
2387 
2388         int ok = 0;
2389         int count = srckeystore.size();
2390         for (Enumeration&lt;String&gt; e = srckeystore.aliases();
2391                                         e.hasMoreElements(); ) {
2392             String alias = e.nextElement();
2393             int result = doImportKeyStoreSingle(srckeystore, alias);
2394             if (result == 1) {
2395                 ok++;
2396                 Object[] source = {alias};
2397                 MessageFormat form = new MessageFormat(rb.getString(&quot;Entry.for.alias.alias.successfully.imported.&quot;));
2398                 System.err.println(form.format(source));
2399             } else if (result == 2) {
2400                 if (!noprompt) {
2401                     String reply = getYesNoReply(&quot;Do you want to quit the import process? [no]:  &quot;);
2402                     if (&quot;YES&quot;.equals(reply)) {
2403                         break;
2404                     }
2405                 }
2406             }
2407         }
2408         Object[] source = {ok, count-ok};
2409         MessageFormat form = new MessageFormat(rb.getString(
2410                 &quot;Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled&quot;));
2411         System.err.println(form.format(source));
2412     }
2413 
2414     /**
2415      * Prints all keystore entries.
2416      */
2417     private void doPrintEntries(PrintStream out)
2418         throws Exception
2419     {
2420         out.println(rb.getString(&quot;Keystore.type.&quot;) + keyStore.getType());
2421         out.println(rb.getString(&quot;Keystore.provider.&quot;) +
2422                 keyStore.getProvider().getName());
2423         out.println();
2424 
2425         MessageFormat form;
2426         form = (keyStore.size() == 1) ?
2427                 new MessageFormat(rb.getString
2428                         (&quot;Your.keystore.contains.keyStore.size.entry&quot;)) :
2429                 new MessageFormat(rb.getString
2430                         (&quot;Your.keystore.contains.keyStore.size.entries&quot;));
2431         Object[] source = {keyStore.size()};
2432         out.println(form.format(source));
2433         out.println();
2434 
2435         List&lt;String&gt; aliases = Collections.list(keyStore.aliases());
2436         aliases.sort(String::compareTo);
2437         for (String alias : aliases) {
2438             doPrintEntry(&quot;&lt;&quot; + alias + &quot;&gt;&quot;, alias, out);
2439             if (verbose || rfc) {
2440                 out.println(rb.getString(&quot;NEWLINE&quot;));
2441                 out.println(rb.getString
2442                         (&quot;STAR&quot;));
2443                 out.println(rb.getString
2444                         (&quot;STARNN&quot;));
2445             }
2446         }
2447     }
2448 
2449     /**
2450      * Loads CRLs from a source. This method is also called in JarSigner.
2451      * @param src the source, which means System.in if null, or a URI,
2452      *        or a bare file path name
2453      */
2454     public static Collection&lt;? extends CRL&gt; loadCRLs(String src) throws Exception {
2455         InputStream in = null;
2456         URI uri = null;
2457         if (src == null) {
2458             in = System.in;
2459         } else {
2460             try {
2461                 uri = new URI(src);
2462                 if (uri.getScheme().equals(&quot;ldap&quot;)) {
2463                     // No input stream for LDAP
2464                 } else {
2465                     in = uri.toURL().openStream();
2466                 }
2467             } catch (Exception e) {
2468                 try {
2469                     in = new FileInputStream(src);
2470                 } catch (Exception e2) {
2471                     if (uri == null || uri.getScheme() == null) {
2472                         throw e2;   // More likely a bare file path
2473                     } else {
2474                         throw e;    // More likely a protocol or network problem
2475                     }
2476                 }
2477             }
2478         }
2479         if (in != null) {
2480             try {
2481                 // Read the full stream before feeding to X509Factory,
2482                 // otherwise, keytool -gencrl | keytool -printcrl
2483                 // might not work properly, since -gencrl is slow
2484                 // and there&#39;s no data in the pipe at the beginning.
2485                 ByteArrayOutputStream bout = new ByteArrayOutputStream();
2486                 byte[] b = new byte[4096];
2487                 while (true) {
2488                     int len = in.read(b);
2489                     if (len &lt; 0) break;
2490                     bout.write(b, 0, len);
2491                 }
2492                 return CertificateFactory.getInstance(&quot;X509&quot;).generateCRLs(
2493                         new ByteArrayInputStream(bout.toByteArray()));
2494             } finally {
2495                 if (in != System.in) {
2496                     in.close();
2497                 }
2498             }
2499         } else {    // must be LDAP, and uri is not null
2500             URICertStoreParameters params =
2501                 new URICertStoreParameters(uri);
2502             CertStore s = CertStore.getInstance(&quot;LDAP&quot;, params);
2503             return s.getCRLs(new X509CRLSelector());
2504         }
2505     }
2506 
2507     /**
2508      * Returns CRLs described in a X509Certificate&#39;s CRLDistributionPoints
2509      * Extension. Only those containing a general name of type URI are read.
2510      */
2511     public static List&lt;CRL&gt; readCRLsFromCert(X509Certificate cert)
2512             throws Exception {
2513         List&lt;CRL&gt; crls = new ArrayList&lt;&gt;();
2514         CRLDistributionPointsExtension ext =
2515                 X509CertImpl.toImpl(cert).getCRLDistributionPointsExtension();
2516         if (ext == null) return crls;
2517         List&lt;DistributionPoint&gt; distPoints =
2518                 ext.get(CRLDistributionPointsExtension.POINTS);
2519         for (DistributionPoint o: distPoints) {
2520             GeneralNames names = o.getFullName();
2521             if (names != null) {
2522                 for (GeneralName name: names.names()) {
2523                     if (name.getType() == GeneralNameInterface.NAME_URI) {
2524                         URIName uriName = (URIName)name.getName();
2525                         for (CRL crl: loadCRLs(uriName.getName())) {
2526                             if (crl instanceof X509CRL) {
2527                                 crls.add((X509CRL)crl);
2528                             }
2529                         }
2530                         break;  // Different name should point to same CRL
2531                     }
2532                 }
2533             }
2534         }
2535         return crls;
2536     }
2537 
2538     private static String verifyCRL(KeyStore ks, CRL crl)
2539             throws Exception {
2540         X509CRLImpl xcrl = (X509CRLImpl)crl;
2541         X500Principal issuer = xcrl.getIssuerX500Principal();
2542         for (String s: Collections.list(ks.aliases())) {
2543             Certificate cert = ks.getCertificate(s);
2544             if (cert instanceof X509Certificate) {
2545                 X509Certificate xcert = (X509Certificate)cert;
2546                 if (xcert.getSubjectX500Principal().equals(issuer)) {
2547                     try {
2548                         ((X509CRLImpl)crl).verify(cert.getPublicKey());
2549                         return s;
2550                     } catch (Exception e) {
2551                     }
2552                 }
2553             }
2554         }
2555         return null;
2556     }
2557 
2558     private void doPrintCRL(String src, PrintStream out)
2559             throws Exception {
2560         for (CRL crl: loadCRLs(src)) {
2561             printCRL(crl, out);
2562             String issuer = null;
2563             Certificate signer = null;
2564             if (caks != null) {
2565                 issuer = verifyCRL(caks, crl);
2566                 if (issuer != null) {
2567                     signer = caks.getCertificate(issuer);
2568                     out.printf(rb.getString(
2569                             &quot;verified.by.s.in.s.weak&quot;),
2570                             issuer,
2571                             &quot;cacerts&quot;,
2572                             withWeak(signer.getPublicKey()));
2573                     out.println();
2574                 }
2575             }
2576             if (issuer == null &amp;&amp; keyStore != null) {
2577                 issuer = verifyCRL(keyStore, crl);
2578                 if (issuer != null) {
2579                     signer = keyStore.getCertificate(issuer);
2580                     out.printf(rb.getString(
2581                             &quot;verified.by.s.in.s.weak&quot;),
2582                             issuer,
2583                             &quot;keystore&quot;,
2584                             withWeak(signer.getPublicKey()));
2585                     out.println();
2586                 }
2587             }
2588             if (issuer == null) {
2589                 out.println(rb.getString
2590                         (&quot;STAR&quot;));
2591                 if (trustcacerts) {
2592                     out.println(rb.getString
2593                             (&quot;warning.not.verified.make.sure.keystore.is.correct&quot;));
2594                 } else {
2595                     out.println(rb.getString
2596                             (&quot;warning.not.verified.make.sure.keystore.is.correct.or.specify.trustcacerts&quot;));
2597                 }
2598                 out.println(rb.getString
2599                         (&quot;STARNN&quot;));
2600             }
2601             checkWeak(rb.getString(&quot;the.crl&quot;), crl, signer == null ? null : signer.getPublicKey());
2602         }
2603     }
2604 
2605     private void printCRL(CRL crl, PrintStream out)
2606             throws Exception {
2607         X509CRL xcrl = (X509CRL)crl;
2608         if (rfc) {
2609             out.println(&quot;-----BEGIN X509 CRL-----&quot;);
2610             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(xcrl.getEncoded()));
2611             out.println(&quot;-----END X509 CRL-----&quot;);
2612         } else {
2613             String s;
2614             if (crl instanceof X509CRLImpl) {
2615                 X509CRLImpl x509crl = (X509CRLImpl) crl;
2616                 s = x509crl.toStringWithAlgName(withWeak(&quot;&quot; + x509crl.getSigAlgId()));
2617             } else {
2618                 s = crl.toString();
2619             }
2620             out.println(s);
2621         }
2622     }
2623 
2624     private void doPrintCertReq(InputStream in, PrintStream out)
2625             throws Exception {
2626 
2627         BufferedReader reader = new BufferedReader(new InputStreamReader(in));
2628         StringBuffer sb = new StringBuffer();
2629         boolean started = false;
2630         while (true) {
2631             String s = reader.readLine();
2632             if (s == null) break;
2633             if (!started) {
2634                 if (s.startsWith(&quot;-----&quot;)) {
2635                     started = true;
2636                 }
2637             } else {
2638                 if (s.startsWith(&quot;-----&quot;)) {
2639                     break;
2640                 }
2641                 sb.append(s);
2642             }
2643         }
2644         PKCS10 req = new PKCS10(Pem.decode(new String(sb)));
2645 
2646         PublicKey pkey = req.getSubjectPublicKeyInfo();
2647         out.printf(rb.getString(&quot;PKCS.10.with.weak&quot;),
2648                 req.getSubjectName(),
2649                 pkey.getFormat(),
2650                 withWeak(pkey),
2651                 withWeak(req.getSigAlg()));
2652         for (PKCS10Attribute attr: req.getAttributes().getAttributes()) {
2653             ObjectIdentifier oid = attr.getAttributeId();
2654             if (oid.equals(PKCS9Attribute.EXTENSION_REQUEST_OID)) {
2655                 CertificateExtensions exts = (CertificateExtensions)attr.getAttributeValue();
2656                 if (exts != null) {
2657                     printExtensions(rb.getString(&quot;Extension.Request.&quot;), exts, out);
2658                 }
2659             } else {
2660                 out.println(&quot;Attribute: &quot; + attr.getAttributeId());
2661                 PKCS9Attribute pkcs9Attr =
2662                         new PKCS9Attribute(attr.getAttributeId(),
2663                                            attr.getAttributeValue());
2664                 out.print(pkcs9Attr.getName() + &quot;: &quot;);
2665                 Object attrVal = attr.getAttributeValue();
2666                 out.println(attrVal instanceof String[] ?
2667                             Arrays.toString((String[]) attrVal) :
2668                             attrVal);
2669             }
2670         }
2671         if (debug) {
2672             out.println(req);   // Just to see more, say, public key length...
2673         }
2674         checkWeak(rb.getString(&quot;the.certificate.request&quot;), req);
2675     }
2676 
2677     /**
2678      * Reads a certificate (or certificate chain) and prints its contents in
2679      * a human readable format.
2680      */
2681     private void printCertFromStream(InputStream in, PrintStream out)
2682         throws Exception
2683     {
2684         Collection&lt;? extends Certificate&gt; c = null;
2685         try {
2686             c = generateCertificates(in);
2687         } catch (CertificateException ce) {
2688             throw new Exception(rb.getString(&quot;Failed.to.parse.input&quot;), ce);
2689         }
2690         if (c.isEmpty()) {
2691             throw new Exception(rb.getString(&quot;Empty.input&quot;));
2692         }
2693         Certificate[] certs = c.toArray(new Certificate[c.size()]);
2694         for (int i=0; i&lt;certs.length; i++) {
2695             X509Certificate x509Cert = null;
2696             try {
2697                 x509Cert = (X509Certificate)certs[i];
2698             } catch (ClassCastException cce) {
2699                 throw new Exception(rb.getString(&quot;Not.X.509.certificate&quot;));
2700             }
2701             if (certs.length &gt; 1) {
2702                 MessageFormat form = new MessageFormat
2703                         (rb.getString(&quot;Certificate.i.1.&quot;));
2704                 Object[] source = {i + 1};
2705                 out.println(form.format(source));
2706             }
2707             if (rfc)
2708                 dumpCert(x509Cert, out);
2709             else
2710                 printX509Cert(x509Cert, out);
2711             if (i &lt; (certs.length-1)) {
2712                 out.println();
2713             }
2714             checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i, certs.length), x509Cert);
2715         }
2716     }
2717 
2718     private void doShowInfo() throws Exception {
2719         if (tlsInfo) {
2720             ShowInfo.tls(verbose);
2721         } else {
2722             System.out.println(rb.getString(&quot;showinfo.no.option&quot;));
2723         }
2724     }
2725 
2726     private Collection&lt;? extends Certificate&gt; generateCertificates(InputStream in)
2727             throws CertificateException, IOException {
2728         byte[] data = in.readAllBytes();
2729         try {
2730             return CertificateFactory.getInstance(&quot;X.509&quot;)
2731                     .generateCertificates(new ByteArrayInputStream(data));
2732         } catch (CertificateException e) {
2733             if (providerName != null) {
2734                 try {
2735                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2736                             .generateCertificates(new ByteArrayInputStream(data));
2737                 } catch (Exception e2) {
2738                     e.addSuppressed(e2);
2739                 }
2740             }
2741             throw e;
2742         }
2743     }
2744 
2745     private Certificate generateCertificate(InputStream in)
2746             throws CertificateException, IOException {
2747         byte[] data = in.readAllBytes();
2748         try {
2749             return CertificateFactory.getInstance(&quot;X.509&quot;)
2750                     .generateCertificate(new ByteArrayInputStream(data));
2751         } catch (CertificateException e) {
2752             if (providerName != null) {
2753                 try {
2754                     return CertificateFactory.getInstance(&quot;X.509&quot;, providerName)
2755                             .generateCertificate(new ByteArrayInputStream(data));
2756                 } catch (Exception e2) {
2757                     e.addSuppressed(e2);
2758                 }
2759             }
2760             throw e;
2761         }
2762     }
2763 
2764     private static String oneInMany(String label, int i, int num) {
2765         if (num == 1) {
2766             return label;
2767         } else {
2768             return String.format(rb.getString(&quot;one.in.many&quot;), label, i+1, num);
2769         }
2770     }
2771 
2772     private void doPrintCert(final PrintStream out) throws Exception {
2773         if (jarfile != null) {
2774             // reset &quot;jdk.certpath.disabledAlgorithms&quot; security property
2775             // to be able to read jars which were signed with weak algorithms
2776             Security.setProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS, &quot;&quot;);
2777 
2778             JarFile jf = new JarFile(jarfile, true);
2779             Enumeration&lt;JarEntry&gt; entries = jf.entries();
2780             Set&lt;CodeSigner&gt; ss = new HashSet&lt;&gt;();
2781             byte[] buffer = new byte[8192];
2782             int pos = 0;
2783             while (entries.hasMoreElements()) {
2784                 JarEntry je = entries.nextElement();
2785                 try (InputStream is = jf.getInputStream(je)) {
2786                     while (is.read(buffer) != -1) {
2787                         // we just read. this will throw a SecurityException
2788                         // if a signature/digest check fails. This also
2789                         // populate the signers
2790                     }
2791                 }
2792                 CodeSigner[] signers = je.getCodeSigners();
2793                 if (signers != null) {
2794                     for (CodeSigner signer: signers) {
2795                         if (!ss.contains(signer)) {
2796                             ss.add(signer);
2797                             out.printf(rb.getString(&quot;Signer.d.&quot;), ++pos);
2798                             out.println();
2799                             out.println();
2800                             out.println(rb.getString(&quot;Signature.&quot;));
2801                             out.println();
2802 
2803                             List&lt;? extends Certificate&gt; certs
2804                                     = signer.getSignerCertPath().getCertificates();
2805                             int cc = 0;
2806                             for (Certificate cert: certs) {
2807                                 X509Certificate x = (X509Certificate)cert;
2808                                 if (rfc) {
2809                                     out.println(rb.getString(&quot;Certificate.owner.&quot;) + x.getSubjectDN() + &quot;\n&quot;);
2810                                     dumpCert(x, out);
2811                                 } else {
2812                                     printX509Cert(x, out);
2813                                 }
2814                                 out.println();
2815                                 checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), cc++, certs.size()), x);
2816                             }
2817                             Timestamp ts = signer.getTimestamp();
2818                             if (ts != null) {
2819                                 out.println(rb.getString(&quot;Timestamp.&quot;));
2820                                 out.println();
2821                                 certs = ts.getSignerCertPath().getCertificates();
2822                                 cc = 0;
2823                                 for (Certificate cert: certs) {
2824                                     X509Certificate x = (X509Certificate)cert;
2825                                     if (rfc) {
2826                                         out.println(rb.getString(&quot;Certificate.owner.&quot;) + x.getSubjectDN() + &quot;\n&quot;);
2827                                         dumpCert(x, out);
2828                                     } else {
2829                                         printX509Cert(x, out);
2830                                     }
2831                                     out.println();
2832                                     checkWeak(oneInMany(rb.getString(&quot;the.tsa.certificate&quot;), cc++, certs.size()), x);
2833                                 }
2834                             }
2835                         }
2836                     }
2837                 }
2838             }
2839             jf.close();
2840             if (ss.isEmpty()) {
2841                 out.println(rb.getString(&quot;Not.a.signed.jar.file&quot;));
2842             }
2843         } else if (sslserver != null) {
2844             CertStore cs = SSLServerCertStore.getInstance(new URI(&quot;https://&quot; + sslserver));
2845             Collection&lt;? extends Certificate&gt; chain;
2846             try {
2847                 chain = cs.getCertificates(null);
2848                 if (chain.isEmpty()) {
2849                     // If the certs are not retrieved, we consider it an error
2850                     // even if the URL connection is successful.
2851                     throw new Exception(rb.getString(
2852                                         &quot;No.certificate.from.the.SSL.server&quot;));
2853                 }
2854             } catch (CertStoreException cse) {
2855                 if (cse.getCause() instanceof IOException) {
2856                     throw new Exception(rb.getString(
2857                                         &quot;No.certificate.from.the.SSL.server&quot;),
2858                                         cse.getCause());
2859                 } else {
2860                     throw cse;
2861                 }
2862             }
2863 
2864             int i = 0;
2865             for (Certificate cert : chain) {
2866                 try {
2867                     if (rfc) {
2868                         dumpCert(cert, out);
2869                     } else {
2870                         out.println(&quot;Certificate #&quot; + i);
2871                         out.println(&quot;====================================&quot;);
2872                         printX509Cert((X509Certificate)cert, out);
2873                         out.println();
2874                     }
2875                     checkWeak(oneInMany(rb.getString(&quot;the.certificate&quot;), i++, chain.size()), cert);
2876                 } catch (Exception e) {
2877                     if (debug) {
2878                         e.printStackTrace();
2879                     }
2880                 }
2881             }
2882         } else {
2883             if (filename != null) {
2884                 try (FileInputStream inStream = new FileInputStream(filename)) {
2885                     printCertFromStream(inStream, out);
2886                 }
2887             } else {
2888                 printCertFromStream(System.in, out);
2889             }
2890         }
2891     }
2892 
2893     private void doChangeStorePasswd() throws Exception {
2894         storePassNew = newPass;
2895         if (storePassNew == null) {
2896             storePassNew = getNewPasswd(&quot;keystore password&quot;, storePass);
2897         }
2898         if (P12KEYSTORE.equalsIgnoreCase(storetype)) {
2899             // When storetype is PKCS12, we need to change all keypass as well
2900             for (String alias : Collections.list(keyStore.aliases())) {
2901                 if (!keyStore.isCertificateEntry(alias)) {
2902                     // keyPass should be either null or same with storePass,
2903                     // but keep it in case one day we want to &quot;normalize&quot;
2904                     // a PKCS12 keystore having different passwords.
2905                     Pair&lt;Entry, char[]&gt; objs
2906                             = recoverEntry(keyStore, alias, storePass, keyPass);
2907                     keyStore.setEntry(alias, objs.fst,
2908                             new PasswordProtection(storePassNew));
2909                 }
2910             }
2911         }
2912     }
2913 
2914     /**
2915      * Creates a self-signed certificate, and stores it as a single-element
2916      * certificate chain.
2917      */
2918     private void doSelfCert(String alias, String dname, String sigAlgName)
2919         throws Exception
2920     {
2921         if (alias == null) {
2922             alias = keyAlias;
2923         }
2924 
2925         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
2926         PrivateKey privKey = (PrivateKey)objs.fst;
2927         if (keyPass == null)
2928             keyPass = objs.snd;
2929 
2930         // Determine the signature algorithm
2931         if (sigAlgName == null) {
2932             sigAlgName = getCompatibleSigAlgName(privKey);
2933         }
2934 
2935         // Get the old certificate
2936         Certificate oldCert = keyStore.getCertificate(alias);
2937         if (oldCert == null) {
2938             MessageFormat form = new MessageFormat
2939                 (rb.getString(&quot;alias.has.no.public.key&quot;));
2940             Object[] source = {alias};
2941             throw new Exception(form.format(source));
2942         }
2943         if (!(oldCert instanceof X509Certificate)) {
2944             MessageFormat form = new MessageFormat
2945                 (rb.getString(&quot;alias.has.no.X.509.certificate&quot;));
2946             Object[] source = {alias};
2947             throw new Exception(form.format(source));
2948         }
2949 
2950         // convert to X509CertImpl, so that we can modify selected fields
2951         // (no public APIs available yet)
2952         byte[] encoded = oldCert.getEncoded();
2953         X509CertImpl certImpl = new X509CertImpl(encoded);
2954         X509CertInfo certInfo = (X509CertInfo)certImpl.get(X509CertImpl.NAME
2955                                                            + &quot;.&quot; +
2956                                                            X509CertImpl.INFO);
2957 
2958         // Extend its validity
2959         Date firstDate = getStartDate(startDate);
2960         Date lastDate = new Date();
2961         lastDate.setTime(firstDate.getTime() + validity*1000L*24L*60L*60L);
2962         CertificateValidity interval = new CertificateValidity(firstDate,
2963                                                                lastDate);
2964         certInfo.set(X509CertInfo.VALIDITY, interval);
2965 
2966         // Make new serial number
2967         certInfo.set(X509CertInfo.SERIAL_NUMBER,
2968                 CertificateSerialNumber.newRandom64bit(new SecureRandom()));
2969 
2970         // Set owner and issuer fields
2971         X500Name owner;
2972         if (dname == null) {
2973             // Get the owner name from the certificate
2974             owner = (X500Name)certInfo.get(X509CertInfo.SUBJECT + &quot;.&quot; +
2975                                            X509CertInfo.DN_NAME);
2976         } else {
2977             // Use the owner name specified at the command line
2978             owner = new X500Name(dname);
2979             certInfo.set(X509CertInfo.SUBJECT + &quot;.&quot; +
2980                          X509CertInfo.DN_NAME, owner);
2981         }
2982         // Make issuer same as owner (self-signed!)
2983         certInfo.set(X509CertInfo.ISSUER + &quot;.&quot; +
2984                      X509CertInfo.DN_NAME, owner);
2985 
2986         // The inner and outer signature algorithms have to match.
2987         // The way we achieve that is really ugly, but there seems to be no
2988         // other solution: We first sign the cert, then retrieve the
2989         // outer sigalg and use it to set the inner sigalg
2990         X509CertImpl newCert = new X509CertImpl(certInfo);
2991         AlgorithmParameterSpec params = AlgorithmId
2992                 .getDefaultAlgorithmParameterSpec(sigAlgName, privKey);
2993         newCert.sign(privKey, params, sigAlgName, null);
2994         AlgorithmId sigAlgid = (AlgorithmId)newCert.get(X509CertImpl.SIG_ALG);
2995         certInfo.set(CertificateAlgorithmId.NAME + &quot;.&quot; +
2996                      CertificateAlgorithmId.ALGORITHM, sigAlgid);
2997 
2998         certInfo.set(X509CertInfo.VERSION,
2999                         new CertificateVersion(CertificateVersion.V3));
3000 
3001         CertificateExtensions ext = createV3Extensions(
3002                 null,
3003                 (CertificateExtensions)certInfo.get(X509CertInfo.EXTENSIONS),
3004                 v3ext,
3005                 oldCert.getPublicKey(),
3006                 null);
3007         certInfo.set(X509CertInfo.EXTENSIONS, ext);
3008         // Sign the new certificate
3009         newCert = new X509CertImpl(certInfo);
3010         newCert.sign(privKey, params, sigAlgName, null);
3011 
3012         // Store the new certificate as a single-element certificate chain
3013         keyStore.setKeyEntry(alias, privKey,
3014                              (keyPass != null) ? keyPass : storePass,
3015                              new Certificate[] { newCert } );
3016 
3017         if (verbose) {
3018             System.err.println(rb.getString(&quot;New.certificate.self.signed.&quot;));
3019             System.err.print(newCert.toString());
3020             System.err.println();
3021         }
3022     }
3023 
3024     /**
3025      * Processes a certificate reply from a certificate authority.
3026      *
3027      * &lt;p&gt;Builds a certificate chain on top of the certificate reply,
3028      * using trusted certificates from the keystore. The chain is complete
3029      * after a self-signed certificate has been encountered. The self-signed
3030      * certificate is considered a root certificate authority, and is stored
3031      * at the end of the chain.
3032      *
3033      * &lt;p&gt;The newly generated chain replaces the old chain associated with the
3034      * key entry.
3035      *
3036      * @return true if the certificate reply was installed, otherwise false.
3037      */
3038     private boolean installReply(String alias, InputStream in)
3039         throws Exception
3040     {
3041         if (alias == null) {
3042             alias = keyAlias;
3043         }
3044 
3045         Pair&lt;Key,char[]&gt; objs = recoverKey(alias, storePass, keyPass);
3046         PrivateKey privKey = (PrivateKey)objs.fst;
3047         if (keyPass == null) {
3048             keyPass = objs.snd;
3049         }
3050 
3051         Certificate userCert = keyStore.getCertificate(alias);
3052         if (userCert == null) {
3053             MessageFormat form = new MessageFormat
3054                 (rb.getString(&quot;alias.has.no.public.key.certificate.&quot;));
3055             Object[] source = {alias};
3056             throw new Exception(form.format(source));
3057         }
3058 
3059         // Read the certificates in the reply
3060         Collection&lt;? extends Certificate&gt; c = generateCertificates(in);
3061         if (c.isEmpty()) {
3062             throw new Exception(rb.getString(&quot;Reply.has.no.certificates&quot;));
3063         }
3064         Certificate[] replyCerts = c.toArray(new Certificate[c.size()]);
3065         Certificate[] newChain;
3066         if (replyCerts.length == 1) {
3067             // single-cert reply
3068             newChain = establishCertChain(userCert, replyCerts[0]);
3069         } else {
3070             // cert-chain reply (e.g., PKCS#7)
3071             newChain = validateReply(alias, userCert, replyCerts);
3072         }
3073 
3074         // Now store the newly established chain in the keystore. The new
3075         // chain replaces the old one. The chain can be null if user chooses no.
3076         if (newChain != null) {
3077             keyStore.setKeyEntry(alias, privKey,
3078                                  (keyPass != null) ? keyPass : storePass,
3079                                  newChain);
3080             return true;
3081         } else {
3082             return false;
3083         }
3084     }
3085 
3086     /**
3087      * Imports a certificate and adds it to the list of trusted certificates.
3088      *
3089      * @return true if the certificate was added, otherwise false.
3090      */
3091     private boolean addTrustedCert(String alias, InputStream in)
3092         throws Exception
3093     {
3094         if (alias == null) {
3095             throw new Exception(rb.getString(&quot;Must.specify.alias&quot;));
3096         }
3097         if (keyStore.containsAlias(alias)) {
3098             MessageFormat form = new MessageFormat(rb.getString
3099                 (&quot;Certificate.not.imported.alias.alias.already.exists&quot;));
3100             Object[] source = {alias};
3101             throw new Exception(form.format(source));
3102         }
3103 
3104         // Read the certificate
3105         X509Certificate cert = null;
3106         try {
3107             cert = (X509Certificate)generateCertificate(in);
3108         } catch (ClassCastException | CertificateException ce) {
3109             throw new Exception(rb.getString(&quot;Input.not.an.X.509.certificate&quot;));
3110         }
3111 
3112         if (noprompt) {
3113             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3114             keyStore.setCertificateEntry(alias, cert);
3115             return true;
3116         }
3117 
3118         // if certificate is self-signed, make sure it verifies
3119         boolean selfSigned = false;
3120         if (KeyStoreUtil.isSelfSigned(cert)) {
3121             cert.verify(cert.getPublicKey());
3122             selfSigned = true;
3123         }
3124 
3125         // check if cert already exists in keystore
3126         String reply = null;
3127         String trustalias = keyStore.getCertificateAlias(cert);
3128         if (trustalias != null) {
3129             MessageFormat form = new MessageFormat(rb.getString
3130                 (&quot;Certificate.already.exists.in.keystore.under.alias.trustalias.&quot;));
3131             Object[] source = {trustalias};
3132             System.err.println(form.format(source));
3133             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3134             printWeakWarnings(true);
3135             reply = getYesNoReply
3136                 (rb.getString(&quot;Do.you.still.want.to.add.it.no.&quot;));
3137         } else if (selfSigned) {
3138             if (trustcacerts &amp;&amp; (caks != null) &amp;&amp;
3139                     ((trustalias=caks.getCertificateAlias(cert)) != null)) {
3140                 MessageFormat form = new MessageFormat(rb.getString
3141                         (&quot;Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.&quot;));
3142                 Object[] source = {trustalias};
3143                 System.err.println(form.format(source));
3144                 checkWeak(rb.getString(&quot;the.input&quot;), cert);
3145                 printWeakWarnings(true);
3146                 reply = getYesNoReply
3147                         (rb.getString(&quot;Do.you.still.want.to.add.it.to.your.own.keystore.no.&quot;));
3148             }
3149             if (trustalias == null) {
3150                 // Print the cert and ask user if they really want to add
3151                 // it to their keystore
3152                 printX509Cert(cert, System.out);
3153                 checkWeak(rb.getString(&quot;the.input&quot;), cert);
3154                 printWeakWarnings(true);
3155                 reply = getYesNoReply
3156                         (rb.getString(&quot;Trust.this.certificate.no.&quot;));
3157             }
3158         }
3159         if (reply != null) {
3160             if (&quot;YES&quot;.equals(reply)) {
3161                 keyStore.setCertificateEntry(alias, cert);
3162                 return true;
3163             } else {
3164                 return false;
3165             }
3166         }
3167 
3168         // Not found in this keystore and not self-signed
3169         // Try to establish trust chain
3170         try {
3171             Certificate[] chain = establishCertChain(null, cert);
3172             if (chain != null) {
3173                 keyStore.setCertificateEntry(alias, cert);
3174                 return true;
3175             }
3176         } catch (Exception e) {
3177             // Print the cert and ask user if they really want to add it to
3178             // their keystore
3179             printX509Cert(cert, System.out);
3180             checkWeak(rb.getString(&quot;the.input&quot;), cert);
3181             printWeakWarnings(true);
3182             reply = getYesNoReply
3183                 (rb.getString(&quot;Trust.this.certificate.no.&quot;));
3184             if (&quot;YES&quot;.equals(reply)) {
3185                 keyStore.setCertificateEntry(alias, cert);
3186                 return true;
3187             } else {
3188                 return false;
3189             }
3190         }
3191 
3192         return false;
3193     }
3194 
3195     /**
3196      * Prompts user for new password. New password must be different from
3197      * old one.
3198      *
3199      * @param prompt the message that gets prompted on the screen
3200      * @param oldPasswd the current (i.e., old) password
3201      */
3202     private char[] getNewPasswd(String prompt, char[] oldPasswd)
3203         throws Exception
3204     {
3205         char[] entered = null;
3206         char[] reentered = null;
3207 
3208         for (int count = 0; count &lt; 3; count++) {
3209             MessageFormat form = new MessageFormat
3210                 (rb.getString(&quot;New.prompt.&quot;));
3211             Object[] source = {prompt};
3212             System.err.print(form.format(source));
3213             entered = Password.readPassword(System.in);
3214             passwords.add(entered);
3215             if (entered == null || entered.length &lt; 6) {
3216                 System.err.println(rb.getString
3217                     (&quot;Password.is.too.short.must.be.at.least.6.characters&quot;));
3218             } else if (Arrays.equals(entered, oldPasswd)) {
3219                 System.err.println(rb.getString(&quot;Passwords.must.differ&quot;));
3220             } else {
3221                 form = new MessageFormat
3222                         (rb.getString(&quot;Re.enter.new.prompt.&quot;));
3223                 Object[] src = {prompt};
3224                 System.err.print(form.format(src));
3225                 reentered = Password.readPassword(System.in);
3226                 passwords.add(reentered);
3227                 if (!Arrays.equals(entered, reentered)) {
3228                     System.err.println
3229                         (rb.getString(&quot;They.don.t.match.Try.again&quot;));
3230                 } else {
3231                     Arrays.fill(reentered, &#39; &#39;);
3232                     return entered;
3233                 }
3234             }
3235             if (entered != null) {
3236                 Arrays.fill(entered, &#39; &#39;);
3237                 entered = null;
3238             }
3239             if (reentered != null) {
3240                 Arrays.fill(reentered, &#39; &#39;);
3241                 reentered = null;
3242             }
3243         }
3244         throw new Exception(rb.getString(&quot;Too.many.failures.try.later&quot;));
3245     }
3246 
3247     /**
3248      * Prompts user for alias name.
3249      * @param prompt the {0} of &quot;Enter {0} alias name:  &quot; in prompt line
3250      * @return the string entered by the user, without the \n at the end
3251      */
3252     private String getAlias(String prompt) throws Exception {
3253         if (prompt != null) {
3254             MessageFormat form = new MessageFormat
3255                 (rb.getString(&quot;Enter.prompt.alias.name.&quot;));
3256             Object[] source = {prompt};
3257             System.err.print(form.format(source));
3258         } else {
3259             System.err.print(rb.getString(&quot;Enter.alias.name.&quot;));
3260         }
3261         return (new BufferedReader(new InputStreamReader(
3262                                         System.in))).readLine();
3263     }
3264 
3265     /**
3266      * Prompts user for an input string from the command line (System.in)
3267      * @prompt the prompt string printed
3268      * @return the string entered by the user, without the \n at the end
3269      */
3270     private String inputStringFromStdin(String prompt) throws Exception {
3271         System.err.print(prompt);
3272         return (new BufferedReader(new InputStreamReader(
3273                                         System.in))).readLine();
3274     }
3275 
3276     /**
3277      * Prompts user for key password. User may select to choose the same
3278      * password (&lt;code&gt;otherKeyPass&lt;/code&gt;) as for &lt;code&gt;otherAlias&lt;/code&gt;.
3279      */
3280     private char[] getKeyPasswd(String alias, String otherAlias,
3281                                 char[] otherKeyPass)
3282         throws Exception
3283     {
3284         int count = 0;
3285         char[] keyPass = null;
3286 
3287         do {
3288             if (otherKeyPass != null) {
3289                 MessageFormat form = new MessageFormat(rb.getString
3290                         (&quot;Enter.key.password.for.alias.&quot;));
3291                 Object[] source = {alias};
3292                 System.err.println(form.format(source));
3293 
3294                 form = new MessageFormat(rb.getString
3295                         (&quot;.RETURN.if.same.as.for.otherAlias.&quot;));
3296                 Object[] src = {otherAlias};
3297                 System.err.print(form.format(src));
3298             } else {
3299                 MessageFormat form = new MessageFormat(rb.getString
3300                         (&quot;Enter.key.password.for.alias.&quot;));
3301                 Object[] source = {alias};
3302                 System.err.print(form.format(source));
3303             }
3304             System.err.flush();
3305             keyPass = Password.readPassword(System.in);
3306             passwords.add(keyPass);
3307             if (keyPass == null) {
3308                 keyPass = otherKeyPass;
3309             }
3310             count++;
3311         } while ((keyPass == null) &amp;&amp; count &lt; 3);
3312 
3313         if (keyPass == null) {
3314             throw new Exception(rb.getString(&quot;Too.many.failures.try.later&quot;));
3315         }
3316 
3317         return keyPass;
3318     }
3319 
3320     private String withWeak(String alg) {
3321         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, alg, null)) {
3322             if (LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, alg, null)) {
3323                 return alg;
3324             } else {
3325                 return String.format(rb.getString(&quot;with.weak&quot;), alg);
3326             }
3327         } else {
3328             return String.format(rb.getString(&quot;with.disabled&quot;), alg);
3329         }
3330     }
3331 
3332     private String fullDisplayAlgName(Key key) {
3333         String result = key.getAlgorithm();
3334         if (key instanceof ECKey) {
3335             ECParameterSpec paramSpec = ((ECKey) key).getParams();
3336             if (paramSpec instanceof NamedCurve) {
3337                 result += &quot; (&quot; + paramSpec.toString().split(&quot; &quot;)[0] + &quot;)&quot;;
3338             }
3339         }
3340         return result;
3341     }
3342 
3343     private String withWeak(Key key) {
3344         int kLen = KeyUtil.getKeySize(key);
3345         String displayAlg = fullDisplayAlgName(key);
3346         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
3347             if (LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
3348                 if (kLen &gt;= 0) {
3349                     return String.format(rb.getString(&quot;key.bit&quot;), kLen, displayAlg);
3350                 } else {
3351                     return String.format(rb.getString(&quot;unknown.size.1&quot;), displayAlg);
3352                 }
3353             } else {
3354                 return String.format(rb.getString(&quot;key.bit.weak&quot;), kLen, displayAlg);
3355             }
3356         } else {
3357             return String.format(rb.getString(&quot;key.bit.disabled&quot;), kLen, displayAlg);
3358         }
3359     }
3360 
3361     /**
3362      * Prints a certificate in a human readable format.
3363      */
3364     private void printX509Cert(X509Certificate cert, PrintStream out)
3365         throws Exception
3366     {
3367 
3368         MessageFormat form = new MessageFormat
3369                 (rb.getString(&quot;.PATTERN.printX509Cert.with.weak&quot;));
3370         PublicKey pkey = cert.getPublicKey();
3371         String sigName = cert.getSigAlgName();
3372         // No need to warn about sigalg of a trust anchor
3373         if (!isTrustedCert(cert)) {
3374             sigName = withWeak(sigName);
3375         }
3376         Object[] source = {cert.getSubjectDN().toString(),
3377                         cert.getIssuerDN().toString(),
3378                         cert.getSerialNumber().toString(16),
3379                         cert.getNotBefore().toString(),
3380                         cert.getNotAfter().toString(),
3381                         getCertFingerPrint(&quot;SHA-1&quot;, cert),
3382                         getCertFingerPrint(&quot;SHA-256&quot;, cert),
3383                         sigName,
3384                         withWeak(pkey),
3385                         cert.getVersion()
3386                         };
3387         out.println(form.format(source));
3388 
3389         if (cert instanceof X509CertImpl) {
3390             X509CertImpl impl = (X509CertImpl)cert;
3391             X509CertInfo certInfo = (X509CertInfo)impl.get(X509CertImpl.NAME
3392                                                            + &quot;.&quot; +
3393                                                            X509CertImpl.INFO);
3394             CertificateExtensions exts = (CertificateExtensions)
3395                     certInfo.get(X509CertInfo.EXTENSIONS);
3396             if (exts != null) {
3397                 printExtensions(rb.getString(&quot;Extensions.&quot;), exts, out);
3398             }
3399         }
3400     }
3401 
3402     private static void printExtensions(String title, CertificateExtensions exts, PrintStream out)
3403             throws Exception {
3404         int extnum = 0;
3405         Iterator&lt;Extension&gt; i1 = exts.getAllExtensions().iterator();
3406         Iterator&lt;Extension&gt; i2 = exts.getUnparseableExtensions().values().iterator();
3407         while (i1.hasNext() || i2.hasNext()) {
3408             Extension ext = i1.hasNext()?i1.next():i2.next();
3409             if (extnum == 0) {
3410                 out.println();
3411                 out.println(title);
3412                 out.println();
3413             }
3414             out.print(&quot;#&quot;+(++extnum)+&quot;: &quot;+ ext);
3415             if (ext.getClass() == Extension.class) {
3416                 byte[] v = ext.getExtensionValue();
3417                 if (v.length == 0) {
3418                     out.println(rb.getString(&quot;.Empty.value.&quot;));
3419                 } else {
3420                     new sun.security.util.HexDumpEncoder().encodeBuffer(ext.getExtensionValue(), out);
3421                     out.println();
3422                 }
3423             }
3424             out.println();
3425         }
3426     }
3427 
3428     /**
3429      * Locates a signer for a given certificate from a given keystore and
3430      * returns the signer&#39;s certificate.
3431      * @param cert the certificate whose signer is searched, not null
3432      * @param ks the keystore to search with, not null
3433      * @return &lt;code&gt;cert&lt;/code&gt; itself if it&#39;s already inside &lt;code&gt;ks&lt;/code&gt;,
3434      * or a certificate inside &lt;code&gt;ks&lt;/code&gt; who signs &lt;code&gt;cert&lt;/code&gt;,
3435      * or null otherwise. A label is added.
3436      */
3437     private static Pair&lt;String,Certificate&gt;
3438             getSigner(Certificate cert, KeyStore ks) throws Exception {
3439         if (ks.getCertificateAlias(cert) != null) {
3440             return new Pair&lt;&gt;(&quot;&quot;, cert);
3441         }
3442         for (Enumeration&lt;String&gt; aliases = ks.aliases();
3443                 aliases.hasMoreElements(); ) {
3444             String name = aliases.nextElement();
3445             Certificate trustedCert = ks.getCertificate(name);
3446             if (trustedCert != null) {
3447                 try {
3448                     cert.verify(trustedCert.getPublicKey());
3449                     return new Pair&lt;&gt;(name, trustedCert);
3450                 } catch (Exception e) {
3451                     // Not verified, skip to the next one
3452                 }
3453             }
3454         }
3455         return null;
3456     }
3457 
3458     /**
3459      * Gets an X.500 name suitable for inclusion in a certification request.
3460      */
3461     private X500Name getX500Name() throws IOException {
3462         BufferedReader in;
3463         in = new BufferedReader(new InputStreamReader(System.in));
3464         String commonName = &quot;Unknown&quot;;
3465         String organizationalUnit = &quot;Unknown&quot;;
3466         String organization = &quot;Unknown&quot;;
3467         String city = &quot;Unknown&quot;;
3468         String state = &quot;Unknown&quot;;
3469         String country = &quot;Unknown&quot;;
3470         X500Name name;
3471         String userInput = null;
3472 
3473         int maxRetry = 20;
3474         do {
3475             if (maxRetry-- &lt; 0) {
3476                 throw new RuntimeException(rb.getString(
3477                         &quot;Too.many.retries.program.terminated&quot;));
3478             }
3479             commonName = inputString(in,
3480                     rb.getString(&quot;What.is.your.first.and.last.name.&quot;),
3481                     commonName);
3482             organizationalUnit = inputString(in,
3483                     rb.getString
3484                         (&quot;What.is.the.name.of.your.organizational.unit.&quot;),
3485                     organizationalUnit);
3486             organization = inputString(in,
3487                     rb.getString(&quot;What.is.the.name.of.your.organization.&quot;),
3488                     organization);
3489             city = inputString(in,
3490                     rb.getString(&quot;What.is.the.name.of.your.City.or.Locality.&quot;),
3491                     city);
3492             state = inputString(in,
3493                     rb.getString(&quot;What.is.the.name.of.your.State.or.Province.&quot;),
3494                     state);
3495             country = inputString(in,
3496                     rb.getString
3497                         (&quot;What.is.the.two.letter.country.code.for.this.unit.&quot;),
3498                     country);
3499             name = new X500Name(commonName, organizationalUnit, organization,
3500                                 city, state, country);
3501             MessageFormat form = new MessageFormat
3502                 (rb.getString(&quot;Is.name.correct.&quot;));
3503             Object[] source = {name};
3504             userInput = inputString
3505                 (in, form.format(source), rb.getString(&quot;no&quot;));
3506         } while (collator.compare(userInput, rb.getString(&quot;yes&quot;)) != 0 &amp;&amp;
3507                  collator.compare(userInput, rb.getString(&quot;y&quot;)) != 0);
3508 
3509         System.err.println();
3510         return name;
3511     }
3512 
3513     private String inputString(BufferedReader in, String prompt,
3514                                String defaultValue)
3515         throws IOException
3516     {
3517         System.err.println(prompt);
3518         MessageFormat form = new MessageFormat
3519                 (rb.getString(&quot;.defaultValue.&quot;));
3520         Object[] source = {defaultValue};
3521         System.err.print(form.format(source));
3522         System.err.flush();
3523 
3524         String value = in.readLine();
3525         if (value == null || collator.compare(value, &quot;&quot;) == 0) {
3526             value = defaultValue;
3527         }
3528         return value;
3529     }
3530 
3531     /**
3532      * Writes an X.509 certificate in base64 or binary encoding to an output
3533      * stream.
3534      */
3535     private void dumpCert(Certificate cert, PrintStream out)
3536         throws IOException, CertificateException
3537     {
3538         if (rfc) {
3539             out.println(X509Factory.BEGIN_CERT);
3540             out.println(Base64.getMimeEncoder(64, CRLF).encodeToString(cert.getEncoded()));
3541             out.println(X509Factory.END_CERT);
3542         } else {
3543             out.write(cert.getEncoded()); // binary
3544         }
3545     }
3546 
3547     /**
3548      * Converts a byte to hex digit and writes to the supplied buffer
3549      */
3550     private void byte2hex(byte b, StringBuffer buf) {
3551         char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,
3552                             &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };
3553         int high = ((b &amp; 0xf0) &gt;&gt; 4);
3554         int low = (b &amp; 0x0f);
3555         buf.append(hexChars[high]);
3556         buf.append(hexChars[low]);
3557     }
3558 
3559     /**
3560      * Converts a byte array to hex string
3561      */
3562     private String toHexString(byte[] block) {
3563         StringBuffer buf = new StringBuffer();
3564         int len = block.length;
3565         for (int i = 0; i &lt; len; i++) {
3566              byte2hex(block[i], buf);
3567              if (i &lt; len-1) {
3568                  buf.append(&quot;:&quot;);
3569              }
3570         }
3571         return buf.toString();
3572     }
3573 
3574     /**
3575      * Recovers (private) key associated with given alias.
3576      *
3577      * @return an array of objects, where the 1st element in the array is the
3578      * recovered private key, and the 2nd element is the password used to
3579      * recover it.
3580      */
3581     private Pair&lt;Key,char[]&gt; recoverKey(String alias, char[] storePass,
3582                                        char[] keyPass)
3583         throws Exception
3584     {
3585         Key key = null;
3586 
3587         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
3588             key = keyStore.getKey(alias, null);
3589             return Pair.of(key, null);
3590         }
3591 
3592         if (keyStore.containsAlias(alias) == false) {
3593             MessageFormat form = new MessageFormat
3594                 (rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3595             Object[] source = {alias};
3596             throw new Exception(form.format(source));
3597         }
3598         if (!keyStore.entryInstanceOf(alias, KeyStore.PrivateKeyEntry.class) &amp;&amp;
3599                 !keyStore.entryInstanceOf(alias, KeyStore.SecretKeyEntry.class)) {
3600             MessageFormat form = new MessageFormat
3601                 (rb.getString(&quot;Alias.alias.has.no.key&quot;));
3602             Object[] source = {alias};
3603             throw new Exception(form.format(source));
3604         }
3605 
3606         if (keyPass == null) {
3607             // Try to recover the key using the keystore password
3608             if (storePass != null) {
3609                 try {
3610                     key = keyStore.getKey(alias, storePass);
3611                     passwords.add(storePass);
3612                     return Pair.of(key, storePass);
3613                 } catch (UnrecoverableKeyException e) {
3614                     if (token) {
3615                         throw e;
3616                     }
3617                 }
3618             }
3619             // prompt user for key password
3620             keyPass = getKeyPasswd(alias, null, null);
3621             key = keyStore.getKey(alias, keyPass);
3622             return Pair.of(key, keyPass);
3623         } else {
3624             key = keyStore.getKey(alias, keyPass);
3625             return Pair.of(key, keyPass);
3626         }
3627     }
3628 
3629     /**
3630      * Recovers entry associated with given alias.
3631      *
3632      * @return an array of objects, where the 1st element in the array is the
3633      * recovered entry, and the 2nd element is the password used to
3634      * recover it (null if no password).
3635      */
3636     private Pair&lt;Entry,char[]&gt; recoverEntry(KeyStore ks,
3637                             String alias,
3638                             char[] pstore,
3639                             char[] pkey) throws Exception {
3640 
3641         if (!ks.containsAlias(alias)) {
3642             MessageFormat form = new MessageFormat(
3643                     rb.getString(&quot;Alias.alias.does.not.exist&quot;));
3644             Object[] source = {alias};
3645             throw new Exception(form.format(source));
3646         }
3647 
3648         // Step 1: First attempt to access entry without key password
3649         // (PKCS11 entry or trusted certificate entry, for example).
3650         // If fail, go next.
3651         try {
3652             Entry entry = ks.getEntry(alias, null);
3653             return Pair.of(entry, null);
3654         } catch (UnrecoverableEntryException une) {
3655             if(P11KEYSTORE.equalsIgnoreCase(ks.getType()) ||
3656                     KeyStoreUtil.isWindowsKeyStore(ks.getType())) {
3657                 // should not happen, but a possibility
3658                 throw une;
3659             }
3660         }
3661 
3662         // entry is protected
3663 
3664         // Step 2: try pkey if not null. If fail, fail.
3665         if (pkey != null) {
3666             PasswordProtection pp = new PasswordProtection(pkey);
3667             Entry entry = ks.getEntry(alias, pp);
3668             return Pair.of(entry, pkey);
3669         }
3670 
3671         // Step 3: try pstore if not null. If fail, go next.
3672         if (pstore != null) {
3673             try {
3674                 PasswordProtection pp = new PasswordProtection(pstore);
3675                 Entry entry = ks.getEntry(alias, pp);
3676                 return Pair.of(entry, pstore);
3677             } catch (UnrecoverableEntryException une) {
3678                 if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {
3679                     // P12 keystore currently does not support separate
3680                     // store and entry passwords. We will not prompt for
3681                     // entry password.
3682                     throw une;
3683                 }
3684             }
3685         }
3686 
3687         // Step 4: prompt for entry password
3688         pkey = getKeyPasswd(alias, null, null);
3689         PasswordProtection pp = new PasswordProtection(pkey);
3690         Entry entry = ks.getEntry(alias, pp);
3691         return Pair.of(entry, pkey);
3692     }
3693 
3694     /**
3695      * Gets the requested finger print of the certificate.
3696      */
3697     private String getCertFingerPrint(String mdAlg, Certificate cert)
3698         throws Exception
3699     {
3700         byte[] encCertInfo = cert.getEncoded();
3701         MessageDigest md = MessageDigest.getInstance(mdAlg);
3702         byte[] digest = md.digest(encCertInfo);
3703         return toHexString(digest);
3704     }
3705 
3706     /**
3707      * Prints warning about missing integrity check.
3708      */
3709     private void printNoIntegrityWarning() {
3710         System.err.println();
3711         System.err.println(rb.getString
3712             (&quot;.WARNING.WARNING.WARNING.&quot;));
3713         System.err.println(rb.getString
3714             (&quot;.The.integrity.of.the.information.stored.in.your.keystore.&quot;));
3715         System.err.println(rb.getString
3716             (&quot;.WARNING.WARNING.WARNING.&quot;));
3717         System.err.println();
3718     }
3719 
3720     /**
3721      * Validates chain in certification reply, and returns the ordered
3722      * elements of the chain (with user certificate first, and root
3723      * certificate last in the array).
3724      *
3725      * @param alias the alias name
3726      * @param userCert the user certificate of the alias
3727      * @param replyCerts the chain provided in the reply
3728      */
3729     private Certificate[] validateReply(String alias,
3730                                         Certificate userCert,
3731                                         Certificate[] replyCerts)
3732         throws Exception
3733     {
3734 
3735         checkWeak(rb.getString(&quot;reply&quot;), replyCerts);
3736 
3737         // order the certs in the reply (bottom-up).
3738         // we know that all certs in the reply are of type X.509, because
3739         // we parsed them using an X.509 certificate factory
3740         int i;
3741         PublicKey userPubKey = userCert.getPublicKey();
3742 
3743         // Remove duplicated certificates.
3744         HashSet&lt;Certificate&gt; nodup = new HashSet&lt;&gt;(Arrays.asList(replyCerts));
3745         replyCerts = nodup.toArray(new Certificate[nodup.size()]);
3746 
3747         for (i=0; i&lt;replyCerts.length; i++) {
3748             if (userPubKey.equals(replyCerts[i].getPublicKey())) {
3749                 break;
3750             }
3751         }
3752         if (i == replyCerts.length) {
3753             MessageFormat form = new MessageFormat(rb.getString
3754                 (&quot;Certificate.reply.does.not.contain.public.key.for.alias.&quot;));
3755             Object[] source = {alias};
3756             throw new Exception(form.format(source));
3757         }
3758 
3759         Certificate tmpCert = replyCerts[0];
3760         replyCerts[0] = replyCerts[i];
3761         replyCerts[i] = tmpCert;
3762 
3763         X509Certificate thisCert = (X509Certificate)replyCerts[0];
3764 
3765         for (i=1; i &lt; replyCerts.length-1; i++) {
3766             // find a cert in the reply who signs thisCert
3767             int j;
3768             for (j=i; j&lt;replyCerts.length; j++) {
3769                 if (KeyStoreUtil.signedBy(thisCert, (X509Certificate)replyCerts[j])) {
3770                     tmpCert = replyCerts[i];
3771                     replyCerts[i] = replyCerts[j];
3772                     replyCerts[j] = tmpCert;
3773                     thisCert = (X509Certificate)replyCerts[i];
3774                     break;
3775                 }
3776             }
3777             if (j == replyCerts.length) {
3778                 throw new Exception
3779                     (rb.getString(&quot;Incomplete.certificate.chain.in.reply&quot;));
3780             }
3781         }
3782 
3783         if (noprompt) {
3784             return replyCerts;
3785         }
3786 
3787         // do we trust the cert at the top?
3788         Certificate topCert = replyCerts[replyCerts.length-1];
3789         boolean fromKeyStore = true;
3790         Pair&lt;String,Certificate&gt; root = getSigner(topCert, keyStore);
3791         if (root == null &amp;&amp; trustcacerts &amp;&amp; caks != null) {
3792             root = getSigner(topCert, caks);
3793             fromKeyStore = false;
3794         }
3795         if (root == null) {
3796             System.err.println();
3797             System.err.println
3798                     (rb.getString(&quot;Top.level.certificate.in.reply.&quot;));
3799             printX509Cert((X509Certificate)topCert, System.out);
3800             System.err.println();
3801             System.err.print(rb.getString(&quot;.is.not.trusted.&quot;));
3802             printWeakWarnings(true);
3803             String reply = getYesNoReply
3804                     (rb.getString(&quot;Install.reply.anyway.no.&quot;));
3805             if (&quot;NO&quot;.equals(reply)) {
3806                 return null;
3807             }
3808         } else {
3809             if (root.snd != topCert) {
3810                 // append the root CA cert to the chain
3811                 Certificate[] tmpCerts =
3812                     new Certificate[replyCerts.length+1];
3813                 System.arraycopy(replyCerts, 0, tmpCerts, 0,
3814                                  replyCerts.length);
3815                 tmpCerts[tmpCerts.length-1] = root.snd;
3816                 replyCerts = tmpCerts;
3817                 checkWeak(String.format(fromKeyStore
3818                                 ? rb.getString(&quot;alias.in.keystore&quot;)
3819                                 : rb.getString(&quot;alias.in.cacerts&quot;),
3820                                         root.fst),
3821                           root.snd);
3822             }
3823         }
3824         return replyCerts;
3825     }
3826 
3827     /**
3828      * Establishes a certificate chain (using trusted certificates in the
3829      * keystore and cacerts), starting with the reply (certToVerify)
3830      * and ending at a self-signed certificate found in the keystore.
3831      *
3832      * @param userCert optional existing certificate, mostly likely be the
3833      *                 original self-signed cert created by -genkeypair.
3834      *                 It must have the same public key as certToVerify
3835      *                 but cannot be the same cert.
3836      * @param certToVerify the starting certificate to build the chain
3837      * @returns the established chain, might be null if user decides not
3838      */
3839     private Certificate[] establishCertChain(Certificate userCert,
3840                                              Certificate certToVerify)
3841         throws Exception
3842     {
3843         if (userCert != null) {
3844             // Make sure that the public key of the certificate reply matches
3845             // the original public key in the keystore
3846             PublicKey origPubKey = userCert.getPublicKey();
3847             PublicKey replyPubKey = certToVerify.getPublicKey();
3848             if (!origPubKey.equals(replyPubKey)) {
3849                 throw new Exception(rb.getString
3850                         (&quot;Public.keys.in.reply.and.keystore.don.t.match&quot;));
3851             }
3852 
3853             // If the two certs are identical, we&#39;re done: no need to import
3854             // anything
3855             if (certToVerify.equals(userCert)) {
3856                 throw new Exception(rb.getString
3857                         (&quot;Certificate.reply.and.certificate.in.keystore.are.identical&quot;));
3858             }
3859         }
3860 
3861         // Build a hash table of all certificates in the keystore.
3862         // Use the subject distinguished name as the key into the hash table.
3863         // All certificates associated with the same subject distinguished
3864         // name are stored in the same hash table entry as a vector.
3865         Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; certs = null;
3866         if (keyStore.size() &gt; 0) {
3867             certs = new Hashtable&lt;&gt;(11);
3868             keystorecerts2Hashtable(keyStore, certs);
3869         }
3870         if (trustcacerts) {
3871             if (caks!=null &amp;&amp; caks.size()&gt;0) {
3872                 if (certs == null) {
3873                     certs = new Hashtable&lt;&gt;(11);
3874                 }
3875                 keystorecerts2Hashtable(caks, certs);
3876             }
3877         }
3878 
3879         // start building chain
3880         Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; chain = new Vector&lt;&gt;(2);
3881         if (buildChain(
3882                 new Pair&lt;&gt;(rb.getString(&quot;the.input&quot;),
3883                            (X509Certificate) certToVerify),
3884                 chain, certs)) {
3885             for (Pair&lt;String,X509Certificate&gt; p : chain) {
3886                 checkWeak(p.fst, p.snd);
3887             }
3888             Certificate[] newChain =
3889                     new Certificate[chain.size()];
3890             // buildChain() returns chain with self-signed root-cert first and
3891             // user-cert last, so we need to invert the chain before we store
3892             // it
3893             int j=0;
3894             for (int i=chain.size()-1; i&gt;=0; i--) {
3895                 newChain[j] = chain.elementAt(i).snd;
3896                 j++;
3897             }
3898             return newChain;
3899         } else {
3900             throw new Exception
3901                 (rb.getString(&quot;Failed.to.establish.chain.from.reply&quot;));
3902         }
3903     }
3904 
3905     /**
3906      * Recursively tries to establish chain from pool of certs starting from
3907      * certToVerify until a self-signed cert is found, and fill the certs found
3908      * into chain. Each cert in the chain signs the next one.
3909      *
3910      * This method is able to recover from an error, say, if certToVerify
3911      * is signed by certA but certA has no issuer in certs and itself is not
3912      * self-signed, the method can try another certB that also signs
3913      * certToVerify and look for signer of certB, etc, etc.
3914      *
3915      * Each cert in chain comes with a label showing its origin. The label is
3916      * used in the warning message when the cert is considered a risk.
3917      *
3918      * @param certToVerify the cert that needs to be verified.
3919      * @param chain the chain that&#39;s being built.
3920      * @param certs the pool of trusted certs
3921      *
3922      * @return true if successful, false otherwise.
3923      */
3924     private boolean buildChain(Pair&lt;String,X509Certificate&gt; certToVerify,
3925             Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; chain,
3926             Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; certs) {
3927         if (KeyStoreUtil.isSelfSigned(certToVerify.snd)) {
3928             // reached self-signed root cert;
3929             // no verification needed because it&#39;s trusted.
3930             chain.addElement(certToVerify);
3931             return true;
3932         }
3933 
3934         Principal issuer = certToVerify.snd.getIssuerDN();
3935 
3936         // Get the issuer&#39;s certificate(s)
3937         Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; vec = certs.get(issuer);
3938         if (vec == null) {
3939             return false;
3940         }
3941 
3942         // Try out each certificate in the vector, until we find one
3943         // whose public key verifies the signature of the certificate
3944         // in question.
3945         for (Enumeration&lt;Pair&lt;String,X509Certificate&gt;&gt; issuerCerts = vec.elements();
3946                 issuerCerts.hasMoreElements(); ) {
3947             Pair&lt;String,X509Certificate&gt; issuerCert = issuerCerts.nextElement();
3948             PublicKey issuerPubKey = issuerCert.snd.getPublicKey();
3949             try {
3950                 certToVerify.snd.verify(issuerPubKey);
3951             } catch (Exception e) {
3952                 continue;
3953             }
3954             if (buildChain(issuerCert, chain, certs)) {
3955                 chain.addElement(certToVerify);
3956                 return true;
3957             }
3958         }
3959         return false;
3960     }
3961 
3962     /**
3963      * Prompts user for yes/no decision.
3964      *
3965      * @return the user&#39;s decision, can only be &quot;YES&quot; or &quot;NO&quot;
3966      */
3967     private String getYesNoReply(String prompt)
3968         throws IOException
3969     {
3970         String reply = null;
3971         int maxRetry = 20;
3972         do {
3973             if (maxRetry-- &lt; 0) {
3974                 throw new RuntimeException(rb.getString(
3975                         &quot;Too.many.retries.program.terminated&quot;));
3976             }
3977             System.err.print(prompt);
3978             System.err.flush();
3979             reply = (new BufferedReader(new InputStreamReader
3980                                         (System.in))).readLine();
3981             if (reply == null ||
3982                 collator.compare(reply, &quot;&quot;) == 0 ||
3983                 collator.compare(reply, rb.getString(&quot;n&quot;)) == 0 ||
3984                 collator.compare(reply, rb.getString(&quot;no&quot;)) == 0) {
3985                 reply = &quot;NO&quot;;
3986             } else if (collator.compare(reply, rb.getString(&quot;y&quot;)) == 0 ||
3987                        collator.compare(reply, rb.getString(&quot;yes&quot;)) == 0) {
3988                 reply = &quot;YES&quot;;
3989             } else {
3990                 System.err.println(rb.getString(&quot;Wrong.answer.try.again&quot;));
3991                 reply = null;
3992             }
3993         } while (reply == null);
3994         return reply;
3995     }
3996 
3997     /**
3998      * Stores the (leaf) certificates of a keystore in a hashtable.
3999      * All certs belonging to the same CA are stored in a vector that
4000      * in turn is stored in the hashtable, keyed by the CA&#39;s subject DN.
4001      * Each cert comes with a string label that shows its origin and alias.
4002      */
4003     private void keystorecerts2Hashtable(KeyStore ks,
4004                 Hashtable&lt;Principal, Vector&lt;Pair&lt;String,X509Certificate&gt;&gt;&gt; hash)
4005         throws Exception {
4006 
4007         for (Enumeration&lt;String&gt; aliases = ks.aliases();
4008                                         aliases.hasMoreElements(); ) {
4009             String alias = aliases.nextElement();
4010             Certificate cert = ks.getCertificate(alias);
4011             if (cert != null) {
4012                 Principal subjectDN = ((X509Certificate)cert).getSubjectDN();
4013                 Pair&lt;String,X509Certificate&gt; pair = new Pair&lt;&gt;(
4014                         String.format(
4015                                 rb.getString(ks == caks ?
4016                                         &quot;alias.in.cacerts&quot; :
4017                                         &quot;alias.in.keystore&quot;),
4018                                 alias),
4019                         (X509Certificate)cert);
4020                 Vector&lt;Pair&lt;String,X509Certificate&gt;&gt; vec = hash.get(subjectDN);
4021                 if (vec == null) {
4022                     vec = new Vector&lt;&gt;();
4023                     vec.addElement(pair);
4024                 } else {
4025                     if (!vec.contains(pair)) {
4026                         vec.addElement(pair);
4027                     }
4028                 }
4029                 hash.put(subjectDN, vec);
4030             }
4031         }
4032     }
4033 
4034     /**
4035      * Returns the issue time that&#39;s specified the -startdate option
4036      * @param s the value of -startdate option
4037      */
4038     private static Date getStartDate(String s) throws IOException {
4039         Calendar c = new GregorianCalendar();
4040         if (s != null) {
4041             IOException ioe = new IOException(
4042                     rb.getString(&quot;Illegal.startdate.value&quot;));
4043             int len = s.length();
4044             if (len == 0) {
4045                 throw ioe;
4046             }
4047             if (s.charAt(0) == &#39;-&#39; || s.charAt(0) == &#39;+&#39;) {
4048                 // Form 1: ([+-]nnn[ymdHMS])+
4049                 int start = 0;
4050                 while (start &lt; len) {
4051                     int sign = 0;
4052                     switch (s.charAt(start)) {
4053                         case &#39;+&#39;: sign = 1; break;
4054                         case &#39;-&#39;: sign = -1; break;
4055                         default: throw ioe;
4056                     }
4057                     int i = start+1;
4058                     for (; i&lt;len; i++) {
4059                         char ch = s.charAt(i);
4060                         if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) break;
4061                     }
4062                     if (i == start+1) throw ioe;
4063                     int number = Integer.parseInt(s.substring(start+1, i));
4064                     if (i &gt;= len) throw ioe;
4065                     int unit = 0;
4066                     switch (s.charAt(i)) {
4067                         case &#39;y&#39;: unit = Calendar.YEAR; break;
4068                         case &#39;m&#39;: unit = Calendar.MONTH; break;
4069                         case &#39;d&#39;: unit = Calendar.DATE; break;
4070                         case &#39;H&#39;: unit = Calendar.HOUR; break;
4071                         case &#39;M&#39;: unit = Calendar.MINUTE; break;
4072                         case &#39;S&#39;: unit = Calendar.SECOND; break;
4073                         default: throw ioe;
4074                     }
4075                     c.add(unit, sign * number);
4076                     start = i + 1;
4077                 }
4078             } else  {
4079                 // Form 2: [yyyy/mm/dd] [HH:MM:SS]
4080                 String date = null, time = null;
4081                 if (len == 19) {
4082                     date = s.substring(0, 10);
4083                     time = s.substring(11);
4084                     if (s.charAt(10) != &#39; &#39;)
4085                         throw ioe;
4086                 } else if (len == 10) {
4087                     date = s;
4088                 } else if (len == 8) {
4089                     time = s;
4090                 } else {
4091                     throw ioe;
4092                 }
4093                 if (date != null) {
4094                     if (date.matches(&quot;\\d\\d\\d\\d\\/\\d\\d\\/\\d\\d&quot;)) {
4095                         c.set(Integer.valueOf(date.substring(0, 4)),
4096                                 Integer.valueOf(date.substring(5, 7))-1,
4097                                 Integer.valueOf(date.substring(8, 10)));
4098                     } else {
4099                         throw ioe;
4100                     }
4101                 }
4102                 if (time != null) {
4103                     if (time.matches(&quot;\\d\\d:\\d\\d:\\d\\d&quot;)) {
4104                         c.set(Calendar.HOUR_OF_DAY, Integer.valueOf(time.substring(0, 2)));
4105                         c.set(Calendar.MINUTE, Integer.valueOf(time.substring(3, 5)));
4106                         c.set(Calendar.SECOND, Integer.valueOf(time.substring(6, 8)));
4107                         c.set(Calendar.MILLISECOND, 0);
4108                     } else {
4109                         throw ioe;
4110                     }
4111                 }
4112             }
4113         }
4114         return c.getTime();
4115     }
4116 
4117     /**
4118      * Match a command with a command set. The match can be exact, or
4119      * partial, or case-insensitive.
4120      *
4121      * @param s the command provided by user
4122      * @param list the legal command set represented by KnownOIDs enums.
4123      * @return the position of a single match, or -1 if none matched
4124      * @throws Exception if s is ambiguous
4125      */
4126     private static int oneOf(String s, KnownOIDs... list) throws Exception {
4127         String[] convertedList = new String[list.length];
4128         for (int i = 0; i &lt; list.length; i++) {
4129             convertedList[i] = list[i].stdName();
4130         }
4131         return oneOf(s, convertedList);
4132     }
4133 
4134     /**
4135      * Match a command with a command set. The match can be exact, or
4136      * partial, or case-insensitive.
4137      *
4138      * @param s the command provided by user
4139      * @param list the legal command set. If there is a null, commands after it
4140      *      are regarded experimental, which means they are supported but their
4141      *      existence should not be revealed to user.
4142      * @return the position of a single match, or -1 if none matched
4143      * @throws Exception if s is ambiguous
4144      */
4145     private static int oneOf(String s, String... list) throws Exception {
4146 
4147         // First, if there is an exact match, returns it.
4148         int res = oneOfMatch((a,b) -&gt; a.equals(b), s, list);
4149         if (res &gt;= 0) {
4150             return res;
4151         }
4152 
4153         // Second, if there is one single camelCase or prefix match, returns it.
4154         // This regex substitution removes all lowercase letters not at the
4155         // beginning, so &quot;keyCertSign&quot; becomes &quot;kCS&quot;.
4156         res = oneOfMatch((a,b) -&gt; a.equals(b.replaceAll(&quot;(?&lt;!^)[a-z]&quot;, &quot;&quot;))
4157                 || b.startsWith(a), s, list);
4158         if (res &gt;= 0) {
4159             return res;
4160         }
4161 
4162         // Finally, retry the 2nd step ignoring case
4163         return oneOfMatch((a,b) -&gt; a.equalsIgnoreCase(b.replaceAll(&quot;(?&lt;!^)[a-z]&quot;, &quot;&quot;))
4164                 || b.toUpperCase(Locale.ROOT).startsWith(a.toUpperCase(Locale.ROOT)),
4165                 s, list);
4166     }
4167 
4168     /**
4169      * Match a command with a command set.
4170      *
4171      * @param matcher a BiFunction which returns {@code true} if the 1st
4172      *               argument (user input) matches the 2nd one (full command)
4173      * @param s the command provided by user
4174      * @param list the legal command set
4175      * @return the position of a single match, or -1 if none matched
4176      * @throws Exception if s is ambiguous
4177      */
4178     private static int oneOfMatch(BiFunction&lt;String,String,Boolean&gt; matcher,
4179             String s, String... list) throws Exception {
4180         int[] match = new int[list.length];
4181         int nmatch = 0;
4182         int experiment = Integer.MAX_VALUE;
4183         for (int i = 0; i&lt;list.length; i++) {
4184             String one = list[i];
4185             if (one == null) {
4186                 experiment = i;
4187                 continue;
4188             }
4189             if (matcher.apply(s, one)) {
4190                 match[nmatch++] = i;
4191             }
4192         }
4193         if (nmatch == 0) {
4194             return -1;
4195         } else if (nmatch == 1) {
4196             return match[0];
4197         } else {
4198             // If multiple matches is in experimental commands, ignore them
4199             if (match[1] &gt; experiment) {
4200                 return match[0];
4201             }
4202             StringBuilder sb = new StringBuilder();
4203             MessageFormat form = new MessageFormat(rb.getString
4204                     (&quot;command.{0}.is.ambiguous.&quot;));
4205             Object[] source = {s};
4206             sb.append(form.format(source));
4207             sb.append(&quot;\n    &quot;);
4208             for (int i=0; i&lt;nmatch &amp;&amp; match[i]&lt;experiment; i++) {
4209                 sb.append(&#39; &#39;);
4210                 sb.append(list[match[i]]);
4211             }
4212             throw new Exception(sb.toString());
4213         }
4214     }
4215 
4216     /**
4217      * Create a GeneralName object from known types
4218      * @param t one of 5 known types
4219      * @param v value
4220      * @param exttype X.509 extension type
4221      * @return which one
4222      */
4223     private GeneralName createGeneralName(String t, String v, int exttype)
4224             throws Exception {
4225         GeneralNameInterface gn;
4226         int p = oneOf(t, &quot;EMAIL&quot;, &quot;URI&quot;, &quot;DNS&quot;, &quot;IP&quot;, &quot;OID&quot;);
4227         if (p &lt; 0) {
4228             throw new Exception(rb.getString(
4229                     &quot;Unrecognized.GeneralName.type.&quot;) + t);
4230         }
4231         switch (p) {
4232             case 0: gn = new RFC822Name(v); break;
4233             case 1: gn = new URIName(v); break;
4234             case 2:
4235                 if (exttype == 3) {
4236                     // Allow wildcard only for SAN extension
4237                     gn = new DNSName(v, true);
4238                 } else {
4239                     gn = new DNSName(v);
4240                 }
4241                 break;
4242             case 3: gn = new IPAddressName(v); break;
4243             default: gn = new OIDName(v); break; //4
4244         }
4245         return new GeneralName(gn);
4246     }
4247 
4248     private static final String[] extSupported = {
4249                         &quot;BasicConstraints&quot;,
4250                         &quot;KeyUsage&quot;,
4251                         &quot;ExtendedKeyUsage&quot;,
4252                         &quot;SubjectAlternativeName&quot;,
4253                         &quot;IssuerAlternativeName&quot;,
4254                         &quot;SubjectInfoAccess&quot;,
4255                         &quot;AuthorityInfoAccess&quot;,
4256                         null,
4257                         &quot;CRLDistributionPoints&quot;,
4258     };
4259 
4260     private ObjectIdentifier findOidForExtName(String type)
4261             throws Exception {
4262         switch (oneOf(type, extSupported)) {
4263             case 0: return PKIXExtensions.BasicConstraints_Id;
4264             case 1: return PKIXExtensions.KeyUsage_Id;
4265             case 2: return PKIXExtensions.ExtendedKeyUsage_Id;
4266             case 3: return PKIXExtensions.SubjectAlternativeName_Id;
4267             case 4: return PKIXExtensions.IssuerAlternativeName_Id;
4268             case 5: return PKIXExtensions.SubjectInfoAccess_Id;
4269             case 6: return PKIXExtensions.AuthInfoAccess_Id;
4270             case 8: return PKIXExtensions.CRLDistributionPoints_Id;
4271             default: return ObjectIdentifier.of(type);
4272         }
4273     }
4274 
4275     // Add an extension into a CertificateExtensions, always using OID as key
4276     private static void setExt(CertificateExtensions result, Extension ex)
4277             throws IOException {
4278         result.set(ex.getId(), ex);
4279     }
4280 
4281     /**
4282      * Create X509v3 extensions from a string representation. Note that the
4283      * SubjectKeyIdentifierExtension will always be created non-critical besides
4284      * the extension requested in the &lt;code&gt;extstr&lt;/code&gt; argument.
4285      *
4286      * @param requestedEx the requested extensions, can be null, used for -gencert
4287      * @param existingEx the original extensions, can be null, used for -selfcert
4288      * @param extstrs -ext values, Read keytool doc
4289      * @param pkey the public key for the certificate
4290      * @param akey the public key for the authority (issuer)
4291      * @return the created CertificateExtensions
4292      */
4293     private CertificateExtensions createV3Extensions(
4294             CertificateExtensions requestedEx,
4295             CertificateExtensions existingEx,
4296             List &lt;String&gt; extstrs,
4297             PublicKey pkey,
4298             PublicKey akey) throws Exception {
4299 
4300         // By design, inside a CertificateExtensions object, all known
4301         // extensions uses name (say, &quot;BasicConstraints&quot;) as key and
4302         // a child Extension type (say, &quot;BasicConstraintsExtension&quot;)
4303         // as value, unknown extensions uses OID as key and bare
4304         // Extension object as value. This works fine inside JDK.
4305         //
4306         // However, in keytool, there is no way to prevent people
4307         // using OID in -ext, either as a new extension, or in a
4308         // honored value. Thus here we (ab)use CertificateExtensions
4309         // by always using OID as key and value can be of any type.
4310 
4311         if (existingEx != null &amp;&amp; requestedEx != null) {
4312             // This should not happen
4313             throw new Exception(&quot;One of request and original should be null.&quot;);
4314         }
4315         // A new extensions always using OID as key
4316         CertificateExtensions result = new CertificateExtensions();
4317         if (existingEx != null) {
4318             for (Extension ex: existingEx.getAllExtensions()) {
4319                 setExt(result, ex);
4320             }
4321         }
4322         try {
4323             // name{:critical}{=value}
4324             // Honoring requested extensions
4325             if (requestedEx != null) {
4326                 // The existing requestedEx might use names as keys,
4327                 // translate to all-OID first.
4328                 CertificateExtensions request2 = new CertificateExtensions();
4329                 for (sun.security.x509.Extension ex: requestedEx.getAllExtensions()) {
4330                     request2.set(ex.getId(), ex);
4331                 }
4332                 for(String extstr: extstrs) {
4333                     if (extstr.toLowerCase(Locale.ENGLISH).startsWith(&quot;honored=&quot;)) {
4334                         List&lt;String&gt; list = Arrays.asList(
4335                                 extstr.toLowerCase(Locale.ENGLISH).substring(8).split(&quot;,&quot;));
4336                         // First check existence of &quot;all&quot;
4337                         if (list.contains(&quot;all&quot;)) {
4338                             for (Extension ex: request2.getAllExtensions()) {
4339                                 setExt(result, ex);
4340                             }
4341                         }
4342                         // one by one for others
4343                         for (String item: list) {
4344                             if (item.equals(&quot;all&quot;)) continue;
4345 
4346                             // add or remove
4347                             boolean add;
4348                             // -1, unchanged, 0 critical, 1 non-critical
4349                             int action = -1;
4350                             String type = null;
4351                             if (item.startsWith(&quot;-&quot;)) {
4352                                 add = false;
4353                                 type = item.substring(1);
4354                             } else {
4355                                 add = true;
4356                                 int colonpos = item.indexOf(&#39;:&#39;);
4357                                 if (colonpos &gt;= 0) {
4358                                     type = item.substring(0, colonpos);
4359                                     action = oneOf(item.substring(colonpos+1),
4360                                             &quot;critical&quot;, &quot;non-critical&quot;);
4361                                     if (action == -1) {
4362                                         throw new Exception(rb.getString
4363                                             (&quot;Illegal.value.&quot;) + item);
4364                                     }
4365                                 } else {
4366                                     type = item;
4367                                 }
4368                             }
4369                             String n = findOidForExtName(type).toString();
4370                             if (add) {
4371                                 Extension e = request2.get(n);
4372                                 if (!e.isCritical() &amp;&amp; action == 0
4373                                         || e.isCritical() &amp;&amp; action == 1) {
4374                                     e = Extension.newExtension(
4375                                             e.getExtensionId(),
4376                                             !e.isCritical(),
4377                                             e.getExtensionValue());
4378                                 }
4379                                 setExt(result, e);
4380                             } else {
4381                                 result.delete(n);
4382                             }
4383                         }
4384                         break;
4385                     }
4386                 }
4387             }
4388             for(String extstr: extstrs) {
4389                 String name, value;
4390                 boolean isCritical = false;
4391 
4392                 int eqpos = extstr.indexOf(&#39;=&#39;);
4393                 if (eqpos &gt;= 0) {
4394                     name = extstr.substring(0, eqpos);
4395                     value = extstr.substring(eqpos+1);
4396                 } else {
4397                     name = extstr;
4398                     value = null;
4399                 }
4400 
4401                 int colonpos = name.indexOf(&#39;:&#39;);
4402                 if (colonpos &gt;= 0) {
4403                     if (oneOf(name.substring(colonpos+1), &quot;critical&quot;) == 0) {
4404                         isCritical = true;
4405                     }
4406                     name = name.substring(0, colonpos);
4407                 }
4408 
4409                 if (name.equalsIgnoreCase(&quot;honored&quot;)) {
4410                     continue;
4411                 }
4412                 int exttype = oneOf(name, extSupported);
4413                 switch (exttype) {
4414                     case 0:     // BC
4415                         int pathLen = -1;
4416                         boolean isCA = false;
4417                         if (value == null) {
4418                             isCA = true;
4419                         } else {
4420                             try {   // the abbr format
4421                                 pathLen = Integer.parseInt(value);
4422                                 isCA = true;
4423                             } catch (NumberFormatException ufe) {
4424                                 // ca:true,pathlen:1
4425                                 for (String part: value.split(&quot;,&quot;)) {
4426                                     String[] nv = part.split(&quot;:&quot;);
4427                                     if (nv.length != 2) {
4428                                         throw new Exception(rb.getString
4429                                                 (&quot;Illegal.value.&quot;) + extstr);
4430                                     } else {
4431                                         if (nv[0].equalsIgnoreCase(&quot;ca&quot;)) {
4432                                             isCA = Boolean.parseBoolean(nv[1]);
4433                                         } else if (nv[0].equalsIgnoreCase(&quot;pathlen&quot;)) {
4434                                             pathLen = Integer.parseInt(nv[1]);
4435                                         } else {
4436                                             throw new Exception(rb.getString
4437                                                 (&quot;Illegal.value.&quot;) + extstr);
4438                                         }
4439                                     }
4440                                 }
4441                             }
4442                         }
4443                         setExt(result, new BasicConstraintsExtension(isCritical, isCA,
4444                                 pathLen));
4445                         break;
4446                     case 1:     // KU
4447                         if(value != null) {
4448                             boolean[] ok = new boolean[9];
4449                             for (String s: value.split(&quot;,&quot;)) {
4450                                 int p = oneOf(s,
4451                                        &quot;digitalSignature&quot;,  // (0),
4452                                        &quot;nonRepudiation&quot;,    // (1)
4453                                        &quot;keyEncipherment&quot;,   // (2),
4454                                        &quot;dataEncipherment&quot;,  // (3),
4455                                        &quot;keyAgreement&quot;,      // (4),
4456                                        &quot;keyCertSign&quot;,       // (5),
4457                                        &quot;cRLSign&quot;,           // (6),
4458                                        &quot;encipherOnly&quot;,      // (7),
4459                                        &quot;decipherOnly&quot;,      // (8)
4460                                        &quot;contentCommitment&quot;  // also (1)
4461                                        );
4462                                 if (p &lt; 0) {
4463                                     throw new Exception(rb.getString(&quot;Unknown.keyUsage.type.&quot;) + s);
4464                                 }
4465                                 if (p == 9) p = 1;
4466                                 ok[p] = true;
4467                             }
4468                             KeyUsageExtension kue = new KeyUsageExtension(ok);
4469                             // The above KeyUsageExtension constructor does not
4470                             // allow isCritical value, so...
4471                             setExt(result, Extension.newExtension(
4472                                     kue.getExtensionId(),
4473                                     isCritical,
4474                                     kue.getExtensionValue()));
4475                         } else {
4476                             throw new Exception(rb.getString
4477                                     (&quot;Illegal.value.&quot;) + extstr);
4478                         }
4479                         break;
4480                     case 2:     // EKU
4481                         if(value != null) {
4482                             Vector&lt;ObjectIdentifier&gt; v = new Vector&lt;&gt;();
4483                             KnownOIDs[] choices = {
4484                                     KnownOIDs.anyExtendedKeyUsage,
4485                                     KnownOIDs.serverAuth,
4486                                     KnownOIDs.clientAuth,
4487                                     KnownOIDs.codeSigning,
4488                                     KnownOIDs.emailProtection,
4489                                     KnownOIDs.KP_TimeStamping,
4490                                     KnownOIDs.OCSPSigning
4491                             };
4492                             for (String s: value.split(&quot;,&quot;)) {
4493                                 int p = oneOf(s, choices);
4494                                 String o = s;
4495                                 if (p &gt;= 0) {
4496                                     o = choices[p].value();
4497                                 }
4498                                 try {
4499                                     v.add(ObjectIdentifier.of(o));
4500                                 } catch (Exception e) {
4501                                     throw new Exception(rb.getString(
4502                                             &quot;Unknown.extendedkeyUsage.type.&quot;) + s);
4503                                 }
4504                             }
4505                             setExt(result, new ExtendedKeyUsageExtension(isCritical, v));
4506                         } else {
4507                             throw new Exception(rb.getString
4508                                     (&quot;Illegal.value.&quot;) + extstr);
4509                         }
4510                         break;
4511                     case 3:     // SAN
4512                     case 4:     // IAN
4513                         if(value != null) {
4514                             String[] ps = value.split(&quot;,&quot;);
4515                             GeneralNames gnames = new GeneralNames();
4516                             for(String item: ps) {
4517                                 colonpos = item.indexOf(&#39;:&#39;);
4518                                 if (colonpos &lt; 0) {
4519                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4520                                 }
4521                                 String t = item.substring(0, colonpos);
4522                                 String v = item.substring(colonpos+1);
4523                                 gnames.add(createGeneralName(t, v, exttype));
4524                             }
4525                             if (exttype == 3) {
4526                                 setExt(result, new SubjectAlternativeNameExtension(
4527                                         isCritical, gnames));
4528                             } else {
4529                                 setExt(result, new IssuerAlternativeNameExtension(
4530                                         isCritical, gnames));
4531                             }
4532                         } else {
4533                             throw new Exception(rb.getString
4534                                     (&quot;Illegal.value.&quot;) + extstr);
4535                         }
4536                         break;
4537                     case 5:     // SIA, always non-critical
4538                     case 6:     // AIA, always non-critical
4539                         if (isCritical) {
4540                             throw new Exception(rb.getString(
4541                                     &quot;This.extension.cannot.be.marked.as.critical.&quot;) + extstr);
4542                         }
4543                         if(value != null) {
4544                             List&lt;AccessDescription&gt; accessDescriptions =
4545                                     new ArrayList&lt;&gt;();
4546                             String[] ps = value.split(&quot;,&quot;);
4547                             for(String item: ps) {
4548                                 colonpos = item.indexOf(&#39;:&#39;);
4549                                 int colonpos2 = item.indexOf(&#39;:&#39;, colonpos+1);
4550                                 if (colonpos &lt; 0 || colonpos2 &lt; 0) {
4551                                     throw new Exception(rb.getString
4552                                             (&quot;Illegal.value.&quot;) + extstr);
4553                                 }
4554                                 String m = item.substring(0, colonpos);
4555                                 String t = item.substring(colonpos+1, colonpos2);
4556                                 String v = item.substring(colonpos2+1);
4557                                 KnownOIDs[] choices = {
4558                                     KnownOIDs.OCSP,
4559                                     KnownOIDs.caIssuers,
4560                                     KnownOIDs.AD_TimeStamping,
4561                                     KnownOIDs.caRepository
4562                                 };
4563                                 int p = oneOf(m, choices);
4564                                 ObjectIdentifier oid;
4565                                 if (p &gt;= 0) {
4566                                     oid = ObjectIdentifier.of(choices[p]);
4567                                 } else {
4568                                     try {
4569                                         oid = ObjectIdentifier.of(m);
4570                                     } catch (Exception e) {
4571                                         throw new Exception(rb.getString(
4572                                                 &quot;Unknown.AccessDescription.type.&quot;) + m);
4573                                     }
4574                                 }
4575                                 accessDescriptions.add(new AccessDescription(
4576                                         oid, createGeneralName(t, v, exttype)));
4577                             }
4578                             if (exttype == 5) {
4579                                 setExt(result, new SubjectInfoAccessExtension(accessDescriptions));
4580                             } else {
4581                                 setExt(result, new AuthorityInfoAccessExtension(accessDescriptions));
4582                             }
4583                         } else {
4584                             throw new Exception(rb.getString
4585                                     (&quot;Illegal.value.&quot;) + extstr);
4586                         }
4587                         break;
4588                     case 8: // CRL, experimental, only support 1 distributionpoint
4589                         if(value != null) {
4590                             String[] ps = value.split(&quot;,&quot;);
4591                             GeneralNames gnames = new GeneralNames();
4592                             for(String item: ps) {
4593                                 colonpos = item.indexOf(&#39;:&#39;);
4594                                 if (colonpos &lt; 0) {
4595                                     throw new Exception(&quot;Illegal item &quot; + item + &quot; in &quot; + extstr);
4596                                 }
4597                                 String t = item.substring(0, colonpos);
4598                                 String v = item.substring(colonpos+1);
4599                                 gnames.add(createGeneralName(t, v, exttype));
4600                             }
4601                             setExt(result, new CRLDistributionPointsExtension(
4602                                     isCritical, Collections.singletonList(
4603                                     new DistributionPoint(gnames, null, null))));
4604                         } else {
4605                             throw new Exception(rb.getString
4606                                     (&quot;Illegal.value.&quot;) + extstr);
4607                         }
4608                         break;
4609                     case -1:
4610                         ObjectIdentifier oid = ObjectIdentifier.of(name);
4611                         byte[] data = null;
4612                         if (value != null) {
4613                             data = new byte[value.length() / 2 + 1];
4614                             int pos = 0;
4615                             for (char c: value.toCharArray()) {
4616                                 int hex;
4617                                 if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
4618                                     hex = c - &#39;0&#39; ;
4619                                 } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) {
4620                                     hex = c - &#39;A&#39; + 10;
4621                                 } else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) {
4622                                     hex = c - &#39;a&#39; + 10;
4623                                 } else {
4624                                     continue;
4625                                 }
4626                                 if (pos % 2 == 0) {
4627                                     data[pos/2] = (byte)(hex &lt;&lt; 4);
4628                                 } else {
4629                                     data[pos/2] += hex;
4630                                 }
4631                                 pos++;
4632                             }
4633                             if (pos % 2 != 0) {
4634                                 throw new Exception(rb.getString(
4635                                         &quot;Odd.number.of.hex.digits.found.&quot;) + extstr);
4636                             }
4637                             data = Arrays.copyOf(data, pos/2);
4638                         } else {
4639                             data = new byte[0];
4640                         }
4641                         setExt(result, new Extension(oid, isCritical,
4642                                 new DerValue(DerValue.tag_OctetString, data)
4643                                         .toByteArray()));
4644                         break;
4645                     default:
4646                         throw new Exception(rb.getString(
4647                                 &quot;Unknown.extension.type.&quot;) + extstr);
4648                 }
4649             }
4650             // always non-critical
4651             setExt(result, new SubjectKeyIdentifierExtension(
4652                     new KeyIdentifier(pkey).getIdentifier()));
4653             if (akey != null &amp;&amp; !pkey.equals(akey)) {
4654                 setExt(result, new AuthorityKeyIdentifierExtension(
4655                                 new KeyIdentifier(akey), null, null));
4656             }
4657         } catch(IOException e) {
4658             throw new RuntimeException(e);
4659         }
4660         return result;
4661     }
4662 
4663     private boolean isTrustedCert(Certificate cert) throws KeyStoreException {
4664         if (caks != null &amp;&amp; caks.getCertificateAlias(cert) != null) {
4665             return true;
4666         } else {
4667             String inKS = keyStore.getCertificateAlias(cert);
4668             return inKS != null &amp;&amp; keyStore.isCertificateEntry(inKS);
4669         }
4670     }
4671 
4672     private void checkWeak(String label, String sigAlg, Key key) {
4673         if (sigAlg != null) {
4674             if (!DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, sigAlg, null)) {
4675                 weakWarnings.add(String.format(
4676                     rb.getString(&quot;whose.sigalg.disabled&quot;), label, sigAlg));
4677             } else if (!LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, sigAlg, null)) {
4678                 weakWarnings.add(String.format(
4679                     rb.getString(&quot;whose.sigalg.weak&quot;), label, sigAlg));
4680             }
4681         }
4682 
4683         if (key != null) {
4684             if (!DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
4685                 weakWarnings.add(String.format(
4686                     rb.getString(&quot;whose.key.disabled&quot;), label,
4687                     String.format(rb.getString(&quot;key.bit&quot;),
4688                     KeyUtil.getKeySize(key), fullDisplayAlgName(key))));
4689             } else if (!LEGACY_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
4690                 weakWarnings.add(String.format(
4691                     rb.getString(&quot;whose.key.weak&quot;), label,
4692                     String.format(rb.getString(&quot;key.bit&quot;),
4693                     KeyUtil.getKeySize(key), fullDisplayAlgName(key))));
4694             }
4695         }
4696     }
4697 
4698     private void checkWeak(String label, Certificate[] certs)
4699             throws KeyStoreException {
4700         for (int i = 0; i &lt; certs.length; i++) {
4701             Certificate cert = certs[i];
4702             if (cert instanceof X509Certificate) {
4703                 X509Certificate xc = (X509Certificate)cert;
4704                 String fullLabel = label;
4705                 if (certs.length &gt; 1) {
4706                     fullLabel = oneInMany(label, i, certs.length);
4707                 }
4708                 checkWeak(fullLabel, xc);
4709             }
4710         }
4711     }
4712 
4713     private void checkWeak(String label, Certificate cert)
4714             throws KeyStoreException {
4715         if (cert instanceof X509Certificate) {
4716             X509Certificate xc = (X509Certificate)cert;
4717             // No need to check the sigalg of a trust anchor
4718             String sigAlg = isTrustedCert(cert) ? null : xc.getSigAlgName();
4719             checkWeak(label, sigAlg, xc.getPublicKey());
4720         }
4721     }
4722 
4723     private void checkWeak(String label, PKCS10 p10) {
4724         checkWeak(label, p10.getSigAlg(), p10.getSubjectPublicKeyInfo());
4725     }
4726 
4727     private void checkWeak(String label, CRL crl, Key key) {
4728         if (crl instanceof X509CRLImpl) {
4729             X509CRLImpl impl = (X509CRLImpl)crl;
4730             checkWeak(label, impl.getSigAlgName(), key);
4731         }
4732     }
4733 
4734     private void printWeakWarnings(boolean newLine) {
4735         if (!weakWarnings.isEmpty() &amp;&amp; !nowarn) {
4736             System.err.println(&quot;\nWarning:&quot;);
4737             for (String warning : weakWarnings) {
4738                 System.err.println(warning);
4739             }
4740             if (newLine) {
4741                 // When calling before a yes/no prompt, add a new line
4742                 System.err.println();
4743             }
4744         }
4745         weakWarnings.clear();
4746     }
4747 
4748     /**
4749      * Prints the usage of this tool.
4750      */
4751     private void usage() {
4752         if (command != null) {
4753             System.err.println(&quot;keytool &quot; + command +
4754                     rb.getString(&quot;.OPTION.&quot;));
4755             System.err.println();
4756             System.err.println(rb.getString(command.description));
4757             System.err.println();
4758             System.err.println(rb.getString(&quot;Options.&quot;));
4759             System.err.println();
4760 
4761             // Left and right sides of the options list. Both might
4762             // contain &quot;\n&quot; and span multiple lines
4763             String[] left = new String[command.options.length];
4764             String[] right = new String[command.options.length];
4765 
4766             // Length of left side of options list
4767             int lenLeft = 0;
4768 
4769             for (int j = 0; j &lt; command.options.length; j++) {
4770                 Option opt = command.options[j];
4771                 left[j] = opt.toString();
4772                 if (opt.arg != null) {
4773                     left[j] += &quot; &quot; + opt.arg;
4774                 }
4775                 String[] lefts = left[j].split(&quot;\n&quot;);
4776                 for (String s : lefts) {
4777                     if (s.length() &gt; lenLeft) {
4778                         lenLeft = s.length();
4779                     }
4780                 }
4781                 right[j] = rb.getString(opt.description);
4782             }
4783             for (int j = 0; j &lt; left.length; j++) {
4784                 String[] lefts = left[j].split(&quot;\n&quot;);
4785                 String[] rights = right[j].split(&quot;\n&quot;);
4786                 for (int i = 0; i &lt; lefts.length &amp;&amp; i &lt; rights.length; i++) {
4787                     String s1 = i &lt; lefts.length ? lefts[i] : &quot;&quot;;
4788                     String s2 = i &lt; rights.length ? rights[i] : &quot;&quot;;
4789                     if (i == 0) {
4790                         System.err.printf(&quot; %-&quot; + lenLeft + &quot;s  %s\n&quot;, s1, s2);
4791                     } else {
4792                         System.err.printf(&quot;   %-&quot; + lenLeft + &quot;s  %s\n&quot;, s1, s2);
4793                     }
4794                 }
4795             }
4796             System.err.println();
4797             System.err.println(rb.getString(
4798                     &quot;Use.keytool.help.for.all.available.commands&quot;));
4799         } else {
4800             System.err.println(rb.getString(
4801                     &quot;Key.and.Certificate.Management.Tool&quot;));
4802             System.err.println();
4803             System.err.println(rb.getString(&quot;Commands.&quot;));
4804             System.err.println();
4805             for (Command c: Command.values()) {
4806                 if (c == KEYCLONE) break;
4807                 System.err.printf(&quot; %-20s%s\n&quot;, c, rb.getString(c.description));
4808             }
4809             System.err.println();
4810             System.err.println(rb.getString(
4811                     &quot;Use.keytool.help.for.all.available.commands&quot;));
4812             System.err.println(rb.getString(
4813                     &quot;Use.keytool.command.name.help.for.usage.of.command.name&quot;));
4814         }
4815     }
4816 
4817     private void tinyHelp() {
4818         usage();
4819         if (debug) {
4820             throw new RuntimeException(&quot;NO BIG ERROR, SORRY&quot;);
4821         } else {
4822             System.exit(1);
4823         }
4824     }
4825 
4826     private void errorNeedArgument(String flag) {
4827         Object[] source = {flag};
4828         System.err.println(new MessageFormat(
4829                 rb.getString(&quot;Command.option.flag.needs.an.argument.&quot;)).format(source));
4830         tinyHelp();
4831     }
4832 
4833     private char[] getPass(String modifier, String arg) {
4834         char[] output =
4835             KeyStoreUtil.getPassWithModifier(modifier, arg, rb, collator);
4836         if (output != null) return output;
4837         tinyHelp();
4838         return null;    // Useless, tinyHelp() already exits.
4839     }
4840 }
4841 
4842 // This class is exactly the same as com.sun.tools.javac.util.Pair,
4843 // it&#39;s copied here since the original one is not included in JRE.
4844 class Pair&lt;A, B&gt; {
4845 
4846     public final A fst;
4847     public final B snd;
4848 
4849     public Pair(A fst, B snd) {
4850         this.fst = fst;
4851         this.snd = snd;
4852     }
4853 
4854     public String toString() {
4855         return &quot;Pair[&quot; + fst + &quot;,&quot; + snd + &quot;]&quot;;
4856     }
4857 
4858     public boolean equals(Object other) {
4859         return
4860             other instanceof Pair &amp;&amp;
4861             Objects.equals(fst, ((Pair)other).fst) &amp;&amp;
4862             Objects.equals(snd, ((Pair)other).snd);
4863     }
4864 
4865     public int hashCode() {
4866         if (fst == null) return (snd == null) ? 0 : snd.hashCode() + 1;
4867         else if (snd == null) return fst.hashCode() + 2;
4868         else return fst.hashCode() * 17 + snd.hashCode();
4869     }
4870 
4871     public static &lt;A,B&gt; Pair&lt;A,B&gt; of(A a, B b) {
4872         return new Pair&lt;&gt;(a,b);
4873     }
4874 }
4875 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.base/share/classes/java/lang/invoke/LambdaFormEditor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 922         return putInCache(key, form);
 923     }
 924 
 925     LambdaForm collectReturnValueForm(MethodType combinerType) {
 926         LambdaFormBuffer buf = buffer();
 927         buf.startEdit();
 928         int combinerArity = combinerType.parameterCount();
 929         int argPos = lambdaForm.arity();
 930         int exprPos = lambdaForm.names.length;
 931 
 932         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 933         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 934 
 935         // The newly created LF will run with a different BMH.
 936         // Switch over any pre-existing BMH field references to the new BMH class.
 937         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 938         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 939         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 940         buf.renameParameter(0, newBaseAddress);
 941 

 942         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);

 943         Object[] combinerArgs = new Object[combinerArity + 1];
<span class="line-modified"> 944         combinerArgs[0] = getCombiner;</span>


 945         Name[] newParams = new Name[combinerArity - 1]; // last combiner parameter is the return adapter
 946         for (int i = 0; i &lt; newParams.length; i++) {
 947             newParams[i] = new Name(argPos + i, basicType(combinerType.parameterType(i)));
 948         }


 949         System.arraycopy(newParams, 0,
 950                 combinerArgs, 1, combinerArity - 1);


 951         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);
 952         Name callCombiner = new Name(combinerType, combinerArgs);
 953 

 954         buf.insertExpression(exprPos, getCombiner);
 955         buf.insertExpression(exprPos + 1, callCombiner);
 956 
<span class="line-modified"> 957         // insert the two new expressions</span>
 958         int insPos = argPos;
 959         for (Name newParam : newParams) {
 960             buf.insertParameter(insPos++, newParam);
 961         }
 962 
 963         buf.setResult(callCombiner);
 964         return buf.endEdit();
 965     }
 966 
 967     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
 968         int combinerArity = combinerType.parameterCount();
 969         byte kind = (dropResult ? Transform.FOLD_ARGS_TO_VOID : Transform.FOLD_ARGS);
 970         Transform key = Transform.of(kind, foldPos, combinerArity);
 971         LambdaForm form = getInCache(key);
 972         if (form != null) {
 973             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_ARGS ? 1 : 0));
 974             return form;
 975         }
 976         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
 977         return putInCache(key, form);
</pre>
</td>
<td>
<hr />
<pre>
 922         return putInCache(key, form);
 923     }
 924 
 925     LambdaForm collectReturnValueForm(MethodType combinerType) {
 926         LambdaFormBuffer buf = buffer();
 927         buf.startEdit();
 928         int combinerArity = combinerType.parameterCount();
 929         int argPos = lambdaForm.arity();
 930         int exprPos = lambdaForm.names.length;
 931 
 932         BoundMethodHandle.SpeciesData oldData = oldSpeciesData();
 933         BoundMethodHandle.SpeciesData newData = newSpeciesData(L_TYPE);
 934 
 935         // The newly created LF will run with a different BMH.
 936         // Switch over any pre-existing BMH field references to the new BMH class.
 937         Name oldBaseAddress = lambdaForm.parameter(0);  // BMH holding the values
 938         buf.replaceFunctions(oldData.getterFunctions(), newData.getterFunctions(), oldBaseAddress);
 939         Name newBaseAddress = oldBaseAddress.withConstraint(newData);
 940         buf.renameParameter(0, newBaseAddress);
 941 
<span class="line-added"> 942         // Now we set up the call to the filter</span>
 943         Name getCombiner = new Name(newData.getterFunction(oldData.fieldCount()), newBaseAddress);
<span class="line-added"> 944 </span>
 945         Object[] combinerArgs = new Object[combinerArity + 1];
<span class="line-modified"> 946         combinerArgs[0] = getCombiner; // first (synthetic) argument should be the MH that acts as a target of the invoke</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948         // set up additional adapter parameters (in case the combiner is not a unary function)</span>
 949         Name[] newParams = new Name[combinerArity - 1]; // last combiner parameter is the return adapter
 950         for (int i = 0; i &lt; newParams.length; i++) {
 951             newParams[i] = new Name(argPos + i, basicType(combinerType.parameterType(i)));
 952         }
<span class="line-added"> 953 </span>
<span class="line-added"> 954         // set up remaining filter parameters to point to the corresponding adapter parameters (see above)</span>
 955         System.arraycopy(newParams, 0,
 956                 combinerArgs, 1, combinerArity - 1);
<span class="line-added"> 957 </span>
<span class="line-added"> 958         // the last filter argument is set to point at the result of the target method handle</span>
 959         combinerArgs[combinerArity] = buf.name(lambdaForm.names.length - 1);
 960         Name callCombiner = new Name(combinerType, combinerArgs);
 961 
<span class="line-added"> 962         // insert the two new expressions</span>
 963         buf.insertExpression(exprPos, getCombiner);
 964         buf.insertExpression(exprPos + 1, callCombiner);
 965 
<span class="line-modified"> 966         // insert additional arguments</span>
 967         int insPos = argPos;
 968         for (Name newParam : newParams) {
 969             buf.insertParameter(insPos++, newParam);
 970         }
 971 
 972         buf.setResult(callCombiner);
 973         return buf.endEdit();
 974     }
 975 
 976     LambdaForm foldArgumentsForm(int foldPos, boolean dropResult, MethodType combinerType) {
 977         int combinerArity = combinerType.parameterCount();
 978         byte kind = (dropResult ? Transform.FOLD_ARGS_TO_VOID : Transform.FOLD_ARGS);
 979         Transform key = Transform.of(kind, foldPos, combinerArity);
 980         LambdaForm form = getInCache(key);
 981         if (form != null) {
 982             assert(form.arity == lambdaForm.arity - (kind == Transform.FOLD_ARGS ? 1 : 0));
 983             return form;
 984         }
 985         form = makeArgumentCombinationForm(foldPos, combinerType, true, dropResult);
 986         return putInCache(key, form);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
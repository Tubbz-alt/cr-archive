<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New agent/src/test/java/org/openjdk/jmc/agent/test/TestCompressedFrameTransformation.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 package org.openjdk.jmc.agent.test;
  2 
  3 import org.junit.Test;
  4 import org.objectweb.asm.ClassWriter;
  5 import org.objectweb.asm.Label;
  6 import org.objectweb.asm.MethodVisitor;
  7 import org.objectweb.asm.Opcodes;
  8 import org.openjdk.jmc.agent.TransformRegistry;
  9 import org.openjdk.jmc.agent.Transformer;
 10 import org.openjdk.jmc.agent.impl.DefaultTransformRegistry;
 11 
 12 import java.util.HashMap;
 13 import java.util.Map;
 14 
 15 public class TestCompressedFrameTransformation implements Opcodes {
 16 
 17 	private static final String XML_EVENT_DESCRIPTION = &quot;&lt;jfragent&gt;&quot; //
 18 			+ &quot;&lt;events&gt;&quot; // 
 19 			+ &quot;&lt;event id=\&quot;test.compressed.frame.transformation\&quot;&gt;&quot; // 
 20 			+ &quot;&lt;name&gt;Test Compressed Frame Transformation&lt;/name&gt;&quot; //
 21 			+ &quot;&lt;description&gt;agent instrumentation should be compatible with compressed frame types&lt;/description&gt;&quot; //
 22 			+ &quot;&lt;path&gt;test/frames&lt;/path&gt;&quot; //
 23 			+ &quot;&lt;class&gt;Target&lt;/class&gt;&quot; //
 24 			+ &quot;&lt;method&gt;&quot; //
 25 			+ &quot;&lt;name&gt;echo&lt;/name&gt;&quot; //
 26 			+ &quot;&lt;descriptor&gt;(I)I&lt;/descriptor&gt;&quot; // 
 27 			+ &quot;&lt;/method&gt;&quot; //
 28 			+ &quot;&lt;/event&gt;&quot; //
 29 			+ &quot;&lt;/events&gt;&quot; //
 30 			+ &quot;&lt;/jfragent&gt;&quot;;
 31 
 32 	// Class generator using asm lib. This makes sure we get the original bytecode that really consists a compressed frame.
 33 	public static byte[] generateClassBuffer(int frameType) {
 34 		ClassWriter classWriter = new ClassWriter(0);
 35 		MethodVisitor methodVisitor;
 36 
 37 		// class Target {
 38 		classWriter.visit(V11, ACC_PUBLIC | ACC_SUPER, &quot;Target&quot;, null, &quot;java/lang/Object&quot;, null);
 39 
 40 		{
 41 			// public Target() {
 42 			methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
 43 			methodVisitor.visitCode();
 44 			Label label0 = new Label();
 45 			methodVisitor.visitLabel(label0);
 46 			methodVisitor.visitVarInsn(ALOAD, 0);
 47 			methodVisitor.visitMethodInsn(INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false); // super()
 48 			methodVisitor.visitInsn(RETURN);
 49 			Label label1 = new Label();
 50 			methodVisitor.visitLabel(label1);
 51 			methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;LTarget;&quot;, null, label0, label1, 0);
 52 			methodVisitor.visitMaxs(1, 1);
 53 			methodVisitor.visitEnd(); // }
 54 		}
 55 		{
 56 			// public int echo(int arg)
 57 			methodVisitor = classWriter.visitMethod(ACC_PUBLIC, &quot;echo&quot;, &quot;(I)I&quot;, null, null);
 58 			methodVisitor.visitCode();
 59 			Label label0 = new Label();
 60 			methodVisitor.visitLabel(label0);
 61 			methodVisitor.visitVarInsn(ILOAD, 1);
 62 			methodVisitor.visitIntInsn(BIPUSH, 42);
 63 			Label label1 = new Label();
 64 			methodVisitor.visitJumpInsn(IF_ICMPLE, label1); // if (arg &gt; 42) {
 65 			Label label2 = new Label();
 66 			methodVisitor.visitLabel(label2);
 67 			methodVisitor.visitIntInsn(BIPUSH, 42); // return 42
 68 			methodVisitor.visitInsn(IRETURN); // }
 69 			methodVisitor.visitLabel(label1);
 70 			methodVisitor.visitFrame(frameType, 0, null, 0, null);
 71 			methodVisitor.visitVarInsn(ILOAD, 1); // return arg
 72 			methodVisitor.visitInsn(IRETURN); // }
 73 			Label label3 = new Label();
 74 			methodVisitor.visitLabel(label3);
 75 			methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;LTarget;&quot;, null, label0, label3, 0);
 76 			methodVisitor.visitLocalVariable(&quot;arg&quot;, &quot;I&quot;, null, label0, label3, 1);
 77 			methodVisitor.visitMaxs(2, 2);
 78 			methodVisitor.visitEnd();
 79 		}
 80 		classWriter.visitEnd(); // }
 81 
 82 		return classWriter.toByteArray();
 83 	}
 84 
 85 	private void testCompressedFrameNoVerificationError(int frameType) throws Exception {
 86 		TestClassLoader tcl = new TestClassLoader(TestCompressedFrameTransformation.class.getClassLoader());
 87 		byte[] classBuffer = generateClassBuffer(frameType);
 88 
 89 		TransformRegistry registry = DefaultTransformRegistry.empty();
 90 		Transformer transformer = new Transformer(registry);
 91 
 92 		registry.modify(XML_EVENT_DESCRIPTION);
 93 		classBuffer = transformer.transform(tcl, &quot;Target&quot;, null, null, classBuffer);
 94 
 95 		tcl.putClassBuffer(&quot;Target&quot;, classBuffer);
 96 		tcl.loadClass(&quot;Target&quot;);
 97 
 98 		// No need to run the actual code as we&#39;re just making sure there is no verification errors
 99 	}
100 
101 	@Test
102 	public void testSameFrameNoVerificationError() throws Exception {
103 		testCompressedFrameNoVerificationError(F_SAME);
104 	}
105 
106 	@Test
107 	public void testChopFrameNoVerificationError() throws Exception {
108 		testCompressedFrameNoVerificationError(F_CHOP);
109 	}
110 
111 	@Test
112 	public void testAppendFrameNoVerificationError() throws Exception {
113 		testCompressedFrameNoVerificationError(F_APPEND);
114 	}
115 
116 	static class TestClassLoader extends ClassLoader {
117 
118 		private Map&lt;String, byte[]&gt; classBuffers = new HashMap&lt;&gt;();
119 
120 		public TestClassLoader(ClassLoader parent) {
121 			super(parent);
122 		}
123 
124 		public void putClassBuffer(String name, byte[] bytes) {
125 			classBuffers.put(name, bytes);
126 		}
127 
128 		@Override
129 		public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
130 			if (classBuffers.containsKey(name)) {
131 				return loadClass(name, false);
132 			}
133 
134 			return getParent().loadClass(name);
135 		}
136 
137 		@Override
138 		protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
139 			Class&lt;?&gt; clazz = findClass(name);
140 
141 			if (resolve) {
142 				resolveClass(clazz);
143 			}
144 
145 			return clazz;
146 		}
147 
148 		@Override
149 		protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
150 			byte[] bytes = classBuffers.get(name);
151 			return defineClass(name, bytes, 0, bytes.length);
152 		}
153 	}
154 
155 	public void test() {
156 		//Dummy method for instrumentation
157 	}
158 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/resources/org/openjdk/jmc/flightrecorder/rules/jdk/messages/internal/messages.properties</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../../java/org/openjdk/jmc/flightrecorder/rules/jdk/messages/internal/Messages.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/resources/org/openjdk/jmc/flightrecorder/rules/jdk/messages/internal/messages.properties</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
600 SystemGcRule_CONFIG_WARNING_LIMIT_LONG=Warning limit for ratio between System.gc() and total garbage collections
601 SystemGcRuleFactory_RULE_NAME=GCs Caused by System.gc()
602 # {0} is a percentage
603 SystemGcRuleFactory_TEXT_INFO={0} of the garbage collections were caused by System.gc().
604 SystemGcRuleFactory_TEXT_INFO_LONG=Calling System.gc() can cause unnecessary garbage collections. If you&#39;re not sure that you need these calls, consider removing them.&lt;p&gt;If the calls are in libraries where you can&#39;t change the source code, you can use the command line flag &#39;-XX:+DisableExplicitGC&#39; to make the JVM ignore all System.gc() calls.
605 SystemGcRuleFactory_TEXT_OK=No garbage collections were caused by System.gc().
606 TlabAllocationRatioRuleFactory_RULE_NAME=TLAB Allocation Ratio
607 # {0} is a percentage
608 TlabAllocationRatioRuleFactory_TEXT_INFO=The program allocated {0} of the memory outside of TLABs.
609 TlabAllocationRatioRuleFactory_TEXT_RECOMMEND_LESS_ALLOCATION=Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.
610 TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE=The program only allocated objects outside of TLABs.
611 TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE_LONG=The program only allocated objects outside of Thread Local Allocation Buffers (TLABs).
612 TlabAllocationRatioRuleFactory_TEXT_OK_NO_OUTSIDE=No object allocations outside of TLABs detected.
613 UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO=The recording was performed on a JVM that had Experimental VM Options enabled.
614 UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO_LONG=Experimental VM options may be unreliable and should not be used in a production environment. Unless you have to use an experimental option, you should avoid the &#39;-XX:+UnlockExperimentalVMOptions&#39; command line option.
615 VMOperations_RULE_NAME=VMOperation Peak Duration
616 VMOperationRule_CONFIG_WARNING_LIMIT=Blocking VM operation duration warning limit
617 VMOperationRule_CONFIG_WARNING_LIMIT_LONG=The minimum duration for a blocking VM operation needed to trigger a warning
618 # {0} is a time period
619 VMOperationRuleFactory_TEXT_OK=No excessively long VM operations were found in this recording (the longest was {0}).

620 # {0} is a time period
621 VMOperationRuleFactory_TEXT_WARN=There are long lasting blocking VM operations in this recording (the longest is {0}).

622 # {0} is a time period, {1} is a time stamp, {2} is a thread name, {3} is a time stamp
623 VMOperationRuleFactory_TEXT_WARN_LONG=There are long lasting blocking VM operations in this recording. The longest was of type {1} and lasted for {0}. It was initiated from thread &#39;&#39;{2}&#39;&#39; and happened at {3}. &lt;p&gt;VM operations are JVM internal operations. Some VM operations are executed synchronously (i.e. will block the calling thread), and some need to be executed at so called safe points. Safe point polling is a cooperative suspension mechanism that halts byte code execution in the JVM. A VM operation occurring at a safe point will effectively be &quot;stopping the world&quot;, meaning that no Java code will be executing in any thread while executing VM operations at that safe point. Long lasting VM operations executing at safe points can decrease the responsiveness of an application. &lt;p&gt;If you do find such VM operations, then the type of operation and its caller thread provide vital information to understand why the VM operation happened. To find more details, check if there is an event in the caller thread intersecting this event time wise. Looking at the stack trace for such an event can help determining what caused it.&lt;/p&gt;&lt;p&gt;See &lt;a href=&quot;http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html&quot;&gt;Runtime Overview&lt;/a&gt; for further information.&lt;/p&gt;

</pre>
</td>
<td>
<hr />
<pre>
600 SystemGcRule_CONFIG_WARNING_LIMIT_LONG=Warning limit for ratio between System.gc() and total garbage collections
601 SystemGcRuleFactory_RULE_NAME=GCs Caused by System.gc()
602 # {0} is a percentage
603 SystemGcRuleFactory_TEXT_INFO={0} of the garbage collections were caused by System.gc().
604 SystemGcRuleFactory_TEXT_INFO_LONG=Calling System.gc() can cause unnecessary garbage collections. If you&#39;re not sure that you need these calls, consider removing them.&lt;p&gt;If the calls are in libraries where you can&#39;t change the source code, you can use the command line flag &#39;-XX:+DisableExplicitGC&#39; to make the JVM ignore all System.gc() calls.
605 SystemGcRuleFactory_TEXT_OK=No garbage collections were caused by System.gc().
606 TlabAllocationRatioRuleFactory_RULE_NAME=TLAB Allocation Ratio
607 # {0} is a percentage
608 TlabAllocationRatioRuleFactory_TEXT_INFO=The program allocated {0} of the memory outside of TLABs.
609 TlabAllocationRatioRuleFactory_TEXT_RECOMMEND_LESS_ALLOCATION=Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.
610 TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE=The program only allocated objects outside of TLABs.
611 TlabAllocationRatioRuleFactory_TEXT_INFO_ONLY_OUTSIDE_LONG=The program only allocated objects outside of Thread Local Allocation Buffers (TLABs).
612 TlabAllocationRatioRuleFactory_TEXT_OK_NO_OUTSIDE=No object allocations outside of TLABs detected.
613 UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO=The recording was performed on a JVM that had Experimental VM Options enabled.
614 UnlockExperimentalVMOptionsRuleFactory_TEXT_INFO_LONG=Experimental VM options may be unreliable and should not be used in a production environment. Unless you have to use an experimental option, you should avoid the &#39;-XX:+UnlockExperimentalVMOptions&#39; command line option.
615 VMOperations_RULE_NAME=VMOperation Peak Duration
616 VMOperationRule_CONFIG_WARNING_LIMIT=Blocking VM operation duration warning limit
617 VMOperationRule_CONFIG_WARNING_LIMIT_LONG=The minimum duration for a blocking VM operation needed to trigger a warning
618 # {0} is a time period
619 VMOperationRuleFactory_TEXT_OK=No excessively long VM operations were found in this recording (the longest was {0}).
<span class="line-added">620 VMOperationRuleFactory_TEXT_OK_COMBINED_DURATION=No excessively long VM operations were found in this recording. The longest was created from multiple close consecutive operations that lasted for {0} in total.</span>
621 # {0} is a time period
622 VMOperationRuleFactory_TEXT_WARN=There are long lasting blocking VM operations in this recording (the longest is {0}).
<span class="line-added">623 VMOperationRuleFactory_TEXT_WARN_COMBINED_DURATION=There are long lasting blocking VM operations in this recording. The longest was created from multiple close consecutive operations that lasted for {0} in total.</span>
624 # {0} is a time period, {1} is a time stamp, {2} is a thread name, {3} is a time stamp
625 VMOperationRuleFactory_TEXT_WARN_LONG=There are long lasting blocking VM operations in this recording. The longest was of type {1} and lasted for {0}. It was initiated from thread &#39;&#39;{2}&#39;&#39; and happened at {3}. &lt;p&gt;VM operations are JVM internal operations. Some VM operations are executed synchronously (i.e. will block the calling thread), and some need to be executed at so called safe points. Safe point polling is a cooperative suspension mechanism that halts byte code execution in the JVM. A VM operation occurring at a safe point will effectively be &quot;stopping the world&quot;, meaning that no Java code will be executing in any thread while executing VM operations at that safe point. Long lasting VM operations executing at safe points can decrease the responsiveness of an application. &lt;p&gt;If you do find such VM operations, then the type of operation and its caller thread provide vital information to understand why the VM operation happened. To find more details, check if there is an event in the caller thread intersecting this event time wise. Looking at the stack trace for such an event can help determining what caused it.&lt;/p&gt;&lt;p&gt;See &lt;a href=&quot;http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html&quot;&gt;Runtime Overview&lt;/a&gt; for further information.&lt;/p&gt;
<span class="line-added">626 VMOperationRuleFactory_TEXT_WARN_LONG_COMBINED_DURATION=There are long lasting blocking VM operations in this recording. The longest was created from multiple close consecutive operations that were of type {1} and lasted for {0} in total. They were initiated from thread &#39;&#39;{2}&#39;&#39; and started at {3}. &lt;p&gt;VM operations are JVM internal operations. Some VM operations are executed synchronously (i.e. will block the calling thread), and some need to be executed at so called safe points. Safe point polling is a cooperative suspension mechanism that halts byte code execution in the JVM. A VM operation occurring at a safe point will effectively be &quot;stopping the world&quot;, meaning that no Java code will be executing in any thread while executing VM operations at that safe point. Long lasting VM operations executing at safe points can decrease the responsiveness of an application. &lt;p&gt;If you do find such VM operations, then the type of operation and its caller thread provide vital information to understand why the VM operation happened. To find more details, check if there is an event in the caller thread intersecting this event time wise. Looking at the stack trace for such an event can help determining what caused it.&lt;/p&gt;&lt;p&gt;See &lt;a href=&quot;http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html&quot;&gt;Runtime Overview&lt;/a&gt; for further information.&lt;/p&gt;</span>
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../../java/org/openjdk/jmc/flightrecorder/rules/jdk/messages/internal/Messages.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
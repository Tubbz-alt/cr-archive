<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/VMOperationRule.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>core/org.openjdk.jmc.flightrecorder.rules.jdk/src/main/java/org/openjdk/jmc/flightrecorder/rules/jdk/latency/VMOperationRule.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
125 					JdkQueries.VM_OPERATIONS_BLOCKING);
126 		}
127 		String shortMessage = isCombinedDuration ? Messages.VMOperationRuleFactory_TEXT_OK_COMBINED_DURATION
128 				: Messages.VMOperationRuleFactory_TEXT_OK;
129 		return new Result(this, score, MessageFormat.format(Messages.getString(shortMessage), peakDuration), null,
130 				JdkQueries.FILE_READ);
131 	}
132 
133 	private void findLongestEventInfo(IItemCollection items) {
134 		IItem startingEvent = null;
135 		IQuantity longestDuration = null;
136 		IItem curStartingEvent = null;
137 		IQuantity prevEndTime = null;
138 		IQuantity curCombinedDur = null;
139 
140 		List&lt;IItem&gt; sortedEvents = sortEventsByStartTime(items);
141 		for (IItem event : sortedEvents) {
142 			if (curStartingEvent == null) {
143 				curStartingEvent = event;
144 				curCombinedDur = getDuration(event);
<span class="line-removed">145 				longestDuration = curCombinedDur;</span>
146 			} else {
147 				IQuantity startTime = getStartTime(event);
148 				IQuantity duration = getDuration(event);
149 				double timeBetweenEvents = startTime.subtract(prevEndTime).doubleValueIn(UnitLookup.SECOND);
150 				if (getOperation(curStartingEvent).equals(getOperation(event))
151 						&amp;&amp; getCaller(curStartingEvent).equals(getCaller(event))
152 						&amp;&amp; timeBetweenEvents &lt;= MAX_SECONDS_BETWEEN_EVENTS) {
153 					curCombinedDur = curCombinedDur.add(duration);
154 				} else {
155 					curCombinedDur = duration;
156 					curStartingEvent = event;
157 				}
158 			}
159 
<span class="line-modified">160 			if (longestDuration.compareTo(curCombinedDur) &lt; 0) {</span>
161 				longestDuration = curCombinedDur;
162 				startingEvent = curStartingEvent;
163 			}
164 			prevEndTime = getEndTime(event);
165 		}
166 		this.longestDuration = longestDuration;
167 		this.startingEvent = startingEvent;
168 	}
169 
170 	private List&lt;IItem&gt; sortEventsByStartTime(IItemCollection items) {
171 		List&lt;IItem&gt; sortedEvents = new ArrayList&lt;&gt;();
172 		for (IItemIterable iter : items) {
173 			for (IItem event : iter) {
174 				sortedEvents.add(event);
175 			}
176 		}
177 		Collections.sort(sortedEvents, new Comparator&lt;IItem&gt;() {
178 			@Override
179 			public int compare(IItem e1, IItem e2) {
180 				return getStartTime(e1).compareTo(getStartTime(e2));
</pre>
</td>
<td>
<hr />
<pre>
125 					JdkQueries.VM_OPERATIONS_BLOCKING);
126 		}
127 		String shortMessage = isCombinedDuration ? Messages.VMOperationRuleFactory_TEXT_OK_COMBINED_DURATION
128 				: Messages.VMOperationRuleFactory_TEXT_OK;
129 		return new Result(this, score, MessageFormat.format(Messages.getString(shortMessage), peakDuration), null,
130 				JdkQueries.FILE_READ);
131 	}
132 
133 	private void findLongestEventInfo(IItemCollection items) {
134 		IItem startingEvent = null;
135 		IQuantity longestDuration = null;
136 		IItem curStartingEvent = null;
137 		IQuantity prevEndTime = null;
138 		IQuantity curCombinedDur = null;
139 
140 		List&lt;IItem&gt; sortedEvents = sortEventsByStartTime(items);
141 		for (IItem event : sortedEvents) {
142 			if (curStartingEvent == null) {
143 				curStartingEvent = event;
144 				curCombinedDur = getDuration(event);

145 			} else {
146 				IQuantity startTime = getStartTime(event);
147 				IQuantity duration = getDuration(event);
148 				double timeBetweenEvents = startTime.subtract(prevEndTime).doubleValueIn(UnitLookup.SECOND);
149 				if (getOperation(curStartingEvent).equals(getOperation(event))
150 						&amp;&amp; getCaller(curStartingEvent).equals(getCaller(event))
151 						&amp;&amp; timeBetweenEvents &lt;= MAX_SECONDS_BETWEEN_EVENTS) {
152 					curCombinedDur = curCombinedDur.add(duration);
153 				} else {
154 					curCombinedDur = duration;
155 					curStartingEvent = event;
156 				}
157 			}
158 
<span class="line-modified">159 			if (longestDuration == null || longestDuration.compareTo(curCombinedDur) &lt; 0) {</span>
160 				longestDuration = curCombinedDur;
161 				startingEvent = curStartingEvent;
162 			}
163 			prevEndTime = getEndTime(event);
164 		}
165 		this.longestDuration = longestDuration;
166 		this.startingEvent = startingEvent;
167 	}
168 
169 	private List&lt;IItem&gt; sortEventsByStartTime(IItemCollection items) {
170 		List&lt;IItem&gt; sortedEvents = new ArrayList&lt;&gt;();
171 		for (IItemIterable iter : items) {
172 			for (IItem event : iter) {
173 				sortedEvents.add(event);
174 			}
175 		}
176 		Collections.sort(sortedEvents, new Comparator&lt;IItem&gt;() {
177 			@Override
178 			public int compare(IItem e1, IItem e2) {
179 				return getStartTime(e1).compareTo(getStartTime(e2));
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
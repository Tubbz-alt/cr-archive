<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.ui.views.stacktrace;
 34 
 35 import java.util.Arrays;
 36 import java.util.List;
 37 import java.util.Optional;
 38 import java.util.concurrent.CompletableFuture;
 39 import java.util.logging.Level;
 40 import java.util.stream.Collectors;
 41 import java.util.stream.IntStream;
 42 import java.util.stream.Stream;
 43 
 44 import org.eclipse.core.runtime.IAdapterFactory;
 45 import org.eclipse.core.runtime.Platform;
 46 import org.eclipse.jface.action.Action;
 47 import org.eclipse.jface.action.IAction;
 48 import org.eclipse.jface.action.IMenuManager;
 49 import org.eclipse.jface.action.IToolBarManager;
 50 import org.eclipse.jface.action.MenuManager;
 51 import org.eclipse.jface.action.Separator;
 52 import org.eclipse.jface.viewers.AbstractTreeViewer;
 53 import org.eclipse.jface.viewers.ColumnLabelProvider;
 54 import org.eclipse.jface.viewers.ColumnViewer;
 55 import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;
 56 import org.eclipse.jface.viewers.ISelection;
 57 import org.eclipse.jface.viewers.ISelectionChangedListener;
 58 import org.eclipse.jface.viewers.IStructuredSelection;
 59 import org.eclipse.jface.viewers.ITreeContentProvider;
 60 import org.eclipse.jface.viewers.SelectionChangedEvent;
 61 import org.eclipse.jface.viewers.StructuredSelection;
 62 import org.eclipse.jface.viewers.StructuredViewer;
 63 import org.eclipse.jface.viewers.TableViewer;
 64 import org.eclipse.jface.viewers.TableViewerColumn;
 65 import org.eclipse.jface.viewers.TreeViewer;
 66 import org.eclipse.jface.viewers.TreeViewerColumn;
 67 import org.eclipse.jface.viewers.ViewerCell;
 68 import org.eclipse.jface.viewers.ViewerColumn;
 69 import org.eclipse.jface.window.ToolTip;
 70 import org.eclipse.swt.SWT;
 71 import org.eclipse.swt.events.TraverseEvent;
 72 import org.eclipse.swt.events.TraverseListener;
 73 import org.eclipse.swt.graphics.Color;
 74 import org.eclipse.swt.graphics.Image;
 75 import org.eclipse.swt.graphics.RGB;
 76 import org.eclipse.swt.widgets.Composite;
 77 import org.eclipse.swt.widgets.Display;
 78 import org.eclipse.swt.widgets.Event;
 79 import org.eclipse.swt.widgets.Listener;
 80 import org.eclipse.swt.widgets.TableColumn;
 81 import org.eclipse.swt.widgets.TreeColumn;
 82 import org.eclipse.ui.IEditorPart;
 83 import org.eclipse.ui.IMemento;
 84 import org.eclipse.ui.ISelectionListener;
 85 import org.eclipse.ui.IViewSite;
 86 import org.eclipse.ui.IWorkbenchPart;
 87 import org.eclipse.ui.PartInitException;
 88 import org.eclipse.ui.PlatformUI;
 89 import org.eclipse.ui.forms.widgets.FormText;
 90 import org.eclipse.ui.part.ViewPart;
 91 
 92 import org.openjdk.jmc.common.IDisplayable;
 93 import org.openjdk.jmc.common.IMCFrame;
 94 import org.openjdk.jmc.common.IState;
 95 import org.openjdk.jmc.common.collection.SimpleArray;
 96 import org.openjdk.jmc.common.item.IItemCollection;
 97 import org.openjdk.jmc.common.unit.UnitLookup;
 98 import org.openjdk.jmc.common.util.StateToolkit;
 99 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;
100 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;
101 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;
102 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;
103 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel;
104 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Branch;
105 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Fork;
106 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
107 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
108 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
109 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
110 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
111 import org.openjdk.jmc.flightrecorder.ui.selection.IFlavoredSelection;
112 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore;
113 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
114 import org.openjdk.jmc.flightrecorder.ui.selection.StacktraceFrameSelection;
115 import org.openjdk.jmc.ui.CoreImages;
116 import org.openjdk.jmc.ui.UIPlugin;
117 import org.openjdk.jmc.ui.accessibility.FocusTracker;
118 import org.openjdk.jmc.ui.common.util.AdapterUtil;
119 import org.openjdk.jmc.ui.handlers.ActionToolkit;
120 import org.openjdk.jmc.ui.handlers.CopySelectionAction;
121 import org.openjdk.jmc.ui.handlers.InFocusHandlerActivator;
122 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
123 import org.openjdk.jmc.ui.handlers.MethodFormatter;
124 import org.openjdk.jmc.ui.misc.AbstractStructuredContentProvider;
125 import org.openjdk.jmc.ui.misc.CompositeToolkit;
126 import org.openjdk.jmc.ui.misc.CopySettings;
127 import org.openjdk.jmc.ui.misc.DisplayToolkit;
128 import org.openjdk.jmc.ui.misc.FormatToolkit;
129 import org.openjdk.jmc.ui.misc.MementoToolkit;
130 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
131 
132 public class StacktraceView extends ViewPart implements ISelectionListener {
133 
134 	static {
135 		// Adapt using IAdapterFactory to support object contribution for IMCMethod (e.g jump to source)
136 		Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {
137 
138 			@Override
139 			public &lt;T&gt; T getAdapter(Object adaptableObject, Class&lt;T&gt; adapterType) {
140 				if (adaptableObject instanceof StacktraceFrame &amp;&amp; adapterType == IMCFrame.class) {
141 					return adapterType.cast(((StacktraceFrame) adaptableObject).getFrame());
142 				}
143 				return null;
144 			}
145 
146 			@Override
147 			public Class&lt;?&gt;[] getAdapterList() {
148 				return new Class[] {IMCFrame.class};
149 			}
150 		}, StacktraceFrame.class);
151 	}
152 
153 	private class GroupByAction extends Action {
154 
155 		private final boolean fromThreadRootAction;
156 
157 		GroupByAction(boolean fromRoot) {
158 			super(fromRoot ? Messages.STACKTRACE_VIEW_THREAD_ROOT : Messages.STACKTRACE_VIEW_LAST_FRAME,
159 					IAction.AS_RADIO_BUTTON);
160 			fromThreadRootAction = fromRoot;
161 			setToolTipText(fromRoot ? Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_ROOT
162 					: Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_LAST_FRAME);
163 			setImageDescriptor(fromRoot ? CoreImages.THREAD : CoreImages.METHOD_NON_OPTIMIZED);
164 			setChecked(fromRoot == threadRootAtTop);
165 		}
166 
167 		@Override
168 		public void run() {
169 			boolean newValue = isChecked() == fromThreadRootAction;
170 			if (newValue != threadRootAtTop) {
171 				threadRootAtTop = newValue;
172 				rebuildModel();
173 			}
174 		}
175 	}
176 
177 	private static final String HELP_CONTEXT_ID = FlightRecorderUI.PLUGIN_ID + &quot;.StacktraceView&quot;; //$NON-NLS-1$
178 	// FIXME: Define dynamic color (editable in preferences, to handle dark themes etc.)
179 	private static final Color ALTERNATE_COLOR = SWTColorToolkit.getColor(new RGB(255, 255, 240));
180 	private static final String COUNT_IMG_KEY = &quot;countColor&quot;; //$NON-NLS-1$
181 	private static final Color COUNT_COLOR = SWTColorToolkit.getColor(new RGB(100, 200, 100));
182 	private static final String SIBLINGS_IMG_KEY = &quot;siblingsColor&quot;; //$NON-NLS-1$
183 	private static final Color SIBLINGS_COUNT_COLOR = SWTColorToolkit.getColor(new RGB(170, 250, 170));
184 	private static final int[] DEFAULT_COLUMN_WIDTHS = {650, 80, 120};
185 	private static final String THREAD_ROOT_KEY = &quot;threadRootAtTop&quot;; //$NON-NLS-1$
186 	private static final String FRAME_OPTIMIZATION_KEY = &quot;distinguishFramesByOptimization&quot;; //$NON-NLS-1$
187 	private static final String FRAME_CATEGORIZATION_KEY = &quot;distinguishFramesCategorization&quot;; //$NON-NLS-1$
188 	private static final String TREE_LAYOUT_KEY = &quot;treeLayout&quot;; //$NON-NLS-1$
189 	private static final String REDUCED_TREE_KEY = &quot;reducedTreeLayout&quot;; //$NON-NLS-1$
190 	private static final String METHOD_FORMAT_KEY = &quot;metodFormat&quot;; //$NON-NLS-1$
191 	private static final String COLUMNS_KEY = &quot;columns&quot;; //$NON-NLS-1$
192 	private static final String COLUMNS_SEPARATOR = &quot; &quot;; //$NON-NLS-1$
193 	private ColumnViewer viewer;
194 	private boolean treeLayout;
195 	private boolean reducedTree;
196 	private boolean threadRootAtTop;
197 	private IItemCollection itemsToShow;
198 	private MethodFormatter methodFormatter;
199 	private FrameSeparatorManager frameSeparatorManager;
200 	private GroupByAction[] groupByActions;
201 	private IAction[] layoutActions;
202 	private ViewerAction[] viewerActions;
203 	private int[] columnWidths;
204 
205 	private static class StacktraceViewToolTipSupport extends ColumnViewerToolTipSupport {
206 
207 		StacktraceViewToolTipSupport(ColumnViewer viewer) {
208 			super(viewer, ToolTip.NO_RECREATE, false);
209 		}
210 
211 		@Override
212 		protected Composite createViewerToolTipContentArea(Event event, ViewerCell cell, Composite parent) {
213 			FormText formText = CompositeToolkit.createInfoFormText(parent);
214 			formText.setImage(COUNT_IMG_KEY, SWTColorToolkit.getColorThumbnail(COUNT_COLOR.getRGB()));
215 			formText.setImage(SIBLINGS_IMG_KEY, SWTColorToolkit.getColorThumbnail(SIBLINGS_COUNT_COLOR.getRGB()));
216 			formText.setText(getText(event), true, false);
217 			return formText;
218 		}
219 
220 	}
221 
222 	private static class ViewerAction extends Action implements ISelectionChangedListener {
223 
224 		protected StructuredViewer provider = null;
225 
226 		public ViewerAction(String text) {
227 			super(text);
228 			setViewer(null);
229 			setEnabled(false);
230 		}
231 
232 		public void setViewer(StructuredViewer provider) {
233 			this.provider = provider;
234 			if (provider != null) {
235 				provider.addSelectionChangedListener(this);
236 				selectionChanged(getStructuredSelection());
237 			} else {
238 				setEnabled(false);
239 			}
240 		}
241 
242 		@Override
243 		public void selectionChanged(SelectionChangedEvent event) {
244 			ISelection selection = event.getSelection();
245 			if (selection instanceof IStructuredSelection) {
246 				selectionChanged((IStructuredSelection) selection);
247 			}
248 		}
249 
250 		protected void selectionChanged(IStructuredSelection selection) {
251 		}
252 
253 		protected IStructuredSelection getStructuredSelection() {
254 			if (provider != null) {
255 				ISelection selection = provider.getSelection();
256 				if (selection instanceof IStructuredSelection) {
257 					return (IStructuredSelection) selection;
258 				}
259 			}
260 			return new StructuredSelection();
261 		}
262 
263 	}
264 
265 	static class SelectFrameGroupAction extends ViewerAction {
266 
267 		SelectFrameGroupAction() {
268 			super(Messages.STACKTRACE_VIEW_FRAME_GROUP_CHOOSE);
269 			setImageDescriptor(
270 					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_STAR));
271 			setAccelerator(SWT.CR);
272 		}
273 
274 		@Override
275 		public void setViewer(StructuredViewer provider) {
276 			super.setViewer(provider);
277 			if (provider != null) {
278 				provider.addDoubleClickListener(e -&gt; {
279 					if (isEnabled()) {
280 						run();
281 					}
282 				});
283 			}
284 		}
285 
<a name="1" id="anc1"></a>

286 		@Override
287 		public void run() {
288 			StacktraceFrame frame = (StacktraceFrame) getStructuredSelection().getFirstElement();
289 			// FIXME: Would like to move the table cursor after changing sibling state, not just the selection.
290 			if (isInOpenFork(frame)) {
291 				frame.getBranch().selectSibling(0);
292 			} else {
293 				frame.getBranch().selectSibling(null);
294 			}
295 			provider.getControl().setRedraw(false);
296 			try {
297 				provider.refresh();
298 			} finally {
299 				provider.getControl().setRedraw(true);
300 			}
301 			provider.setSelection(new StructuredSelection(frame));
302 
303 		}
304 
305 		@Override
306 		public void selectionChanged(IStructuredSelection selection) {
307 			setEnabled(selection.size() == 1
308 					&amp;&amp; isFirstInBranchWithSiblings((StacktraceFrame) selection.getFirstElement()));
309 		}
310 
311 	}
312 
313 	static class NavigateAction extends ViewerAction implements TraverseListener {
314 
315 		private final int offset;
316 
317 		NavigateAction(boolean forward) {
318 			super(forward ? Messages.STACKTRACE_VIEW_FRAME_GROUP_NEXT : Messages.STACKTRACE_VIEW_FRAME_GROUP_PREVIOUS);
319 			setImageDescriptor(
320 					forward ? FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_RIGHT)
321 							: FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_LEFT));
322 			offset = forward ? 1 : -1;
323 			setAccelerator(forward ? SWT.ARROW_RIGHT : SWT.ARROW_LEFT);
324 		}
325 
326 		@Override
327 		public void setViewer(StructuredViewer provider) {
328 			super.setViewer(provider);
329 			if (provider != null) {
330 				provider.getControl().addTraverseListener(this);
331 			}
332 		}
333 
334 		@Override
335 		public void run() {
336 			Branch branch = ((StacktraceFrame) getStructuredSelection().getFirstElement()).getBranch();
<a name="2" id="anc2"></a>

337 			Branch selectedSibling = branch.selectSibling(offset);
338 			provider.refresh();
339 			provider.setSelection(new StructuredSelection(selectedSibling.getFirstFrame()));
340 		}
341 
342 		@Override
343 		protected void selectionChanged(IStructuredSelection selection) {
344 			setEnabled(selection.size() == 1 &amp;&amp; isNavigationFrame((StacktraceFrame) selection.getFirstElement()));
345 		}
346 
347 		@Override
348 		public void keyTraversed(TraverseEvent e) {
349 			if (isEnabled()) {
350 				if (e.keyCode == getAccelerator()) {
351 					run();
352 					e.detail = SWT.TRAVERSE_NONE;
353 					e.doit = true;
354 				}
355 			}
356 		}
357 
358 	};
359 
360 	@Override
361 	public void init(IViewSite site, IMemento memento) throws PartInitException {
362 		super.init(site, memento);
363 		IState state = MementoToolkit.asState(memento);
364 		threadRootAtTop = StateToolkit.readBoolean(state, THREAD_ROOT_KEY, false);
365 		groupByActions = new GroupByAction[] {new GroupByAction(false), new GroupByAction(true)};
366 		treeLayout = StateToolkit.readBoolean(state, TREE_LAYOUT_KEY, false);
367 		reducedTree = StateToolkit.readBoolean(state, REDUCED_TREE_KEY, true);
368 
369 		IAction reducedTreeAction = ActionToolkit.checkAction(this::setReducedTree,
370 				Messages.STACKTRACE_VIEW_REDUCE_TREE_DEPTH, null);
371 		reducedTreeAction.setChecked(reducedTree);
372 		IAction treeAction = ActionToolkit.checkAction(this::setTreeLayout, Messages.STACKTRACE_VIEW_SHOW_AS_TREE,
373 				CoreImages.TREE_MODE);
374 		treeAction.setChecked(treeLayout);
375 		layoutActions = new IAction[] {treeAction, reducedTreeAction};
376 
377 		NavigateAction forwardAction = new NavigateAction(true);
378 		NavigateAction backwardAction = new NavigateAction(false);
379 		SelectFrameGroupAction selectGroupAction = new SelectFrameGroupAction();
380 		viewerActions = new ViewerAction[] {selectGroupAction, forwardAction, backwardAction};
381 
382 		try {
383 			columnWidths = Optional.ofNullable(state)
384 					.map(s -&gt; Stream.of(s.getAttribute(COLUMNS_KEY).split(COLUMNS_SEPARATOR))
385 							.mapToInt(Integer::parseInt).toArray())
386 					.filter(widths -&gt; widths.length == DEFAULT_COLUMN_WIDTHS.length
387 							&amp;&amp; Arrays.stream(widths).allMatch(w -&gt; w &gt;= 0))
388 					.orElse(DEFAULT_COLUMN_WIDTHS);
389 		} catch (RuntimeException e) {
390 			columnWidths = DEFAULT_COLUMN_WIDTHS;
391 		}
392 
393 		FrameCategorization categorization = StateToolkit.readEnum(state, FRAME_CATEGORIZATION_KEY,
394 				FrameCategorization.METHOD, FrameCategorization.class);
395 		boolean byOptimization = StateToolkit.readBoolean(state, FRAME_OPTIMIZATION_KEY, false);
396 		frameSeparatorManager = new FrameSeparatorManager(this::rebuildModel,
397 				new FrameSeparator(categorization, byOptimization));
398 		methodFormatter = new MethodFormatter(memento == null ? null : memento.getChild(METHOD_FORMAT_KEY),
399 				() -&gt; viewer.refresh());
400 		IMenuManager siteMenu = site.getActionBars().getMenuManager();
401 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_TOP));
402 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_VIEWER_SETUP));
403 		addOptions(siteMenu);
404 		IToolBarManager toolBar = site.getActionBars().getToolBarManager();
405 		toolBar.add(selectGroupAction);
406 		toolBar.add(backwardAction);
407 		toolBar.add(forwardAction);
408 		toolBar.add(new Separator());
409 		toolBar.add(treeAction);
410 		toolBar.add(new Separator());
411 		Stream.of(groupByActions).forEach(toolBar::add);
412 
413 		getSite().getPage().addSelectionListener(this);
414 	}
415 
416 	@Override
417 	public void dispose() {
418 		getSite().getPage().removeSelectionListener(this);
419 		super.dispose();
420 	}
421 
422 	@Override
423 	public void createPartControl(Composite parent) {
424 		buildViewer(parent);
425 	}
426 
427 	private void setTreeLayout(boolean treeLayout) {
428 		this.treeLayout = treeLayout;
429 		rebuildViewer();
430 	}
431 
432 	private void setReducedTree(boolean reducedTree) {
433 		this.reducedTree = reducedTree;
434 		if (viewer instanceof TreeViewer) {
435 			viewer.setContentProvider(createTreeContentProvider());
436 		}
437 	}
438 
<a name="3" id="anc3"></a>

439 	private void rebuildViewer() {
440 		boolean hasFocus = viewer.getControl().isFocusControl();
441 		ISelection oldSelection = viewer.getSelection();
442 		Fork oldInput = (Fork) viewer.getInput();
443 		Composite parent = viewer.getControl().getParent();
444 		viewer.getControl().dispose();
445 		buildViewer(parent);
446 		if (hasFocus) {
447 			viewer.getControl().setFocus();
448 		}
449 		parent.layout();
450 		if (viewer instanceof TreeViewer) {
451 			// Async set input to avoid drawing issue with tree
452 			Display.getCurrent().asyncExec(() -&gt; {
453 				if (!viewer.getControl().isDisposed()) {
454 					setViewerInput(oldInput);
455 					if (reducedTree &amp;&amp; oldInput != null) {
456 						Branch selectedBranch = getLastSelectedBranch(oldInput);
457 						if (selectedBranch != null) {
458 							viewer.getControl().setRedraw(false);
459 							((TreeViewer) viewer).expandToLevel(selectedBranch.getLastFrame(),
460 									AbstractTreeViewer.ALL_LEVELS);
461 							viewer.getControl().setRedraw(true);
462 						}
463 					}
464 					viewer.setSelection(oldSelection, true);
465 				}
466 			});
467 		} else {
468 			Branch branch = null;
469 			for (Object o : ((IStructuredSelection) oldSelection).toList()) {
470 				if (branch == null) {
471 					branch = ((StacktraceFrame) o).getBranch();
472 				} else if (branch != ((StacktraceFrame) o).getBranch()) {
473 					branch = null;
474 					break;
475 				}
476 			}
477 			if (branch != null) {
478 				branch.selectSibling(0);
479 			}
480 			setViewerInput(oldInput);
481 			viewer.setSelection(oldSelection, true);
482 		}
483 	}
484 
485 	private void buildViewer(Composite parent) {
486 		if (treeLayout) {
487 			viewer = buildTree(parent);
488 		} else {
489 			viewer = buildTable(parent);
490 		}
491 		new StacktraceViewToolTipSupport(viewer);
492 		MCContextMenuManager mm = MCContextMenuManager.create(viewer.getControl());
493 		CopySelectionAction copyAction = new CopySelectionAction(viewer,
494 				FormatToolkit.selectionFormatter(stackTraceLabelProvider, countLabelProvider, percentageLabelProvider));
495 		InFocusHandlerActivator.install(viewer.getControl(), copyAction);
496 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, copyAction);
497 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, CopySettings.getInstance().createContributionItem());
498 		addOptions(mm);
499 		getSite().registerContextMenu(mm, viewer);
500 		if (!treeLayout) {
501 			String navigateGroupName = &quot;NAVIGATE&quot;; //$NON-NLS-1$
502 			mm.insert(0, new Separator(navigateGroupName));
503 			Stream.of(viewerActions).forEach(a -&gt; {
504 				a.setViewer(viewer);
505 				mm.appendToGroup(navigateGroupName, a);
506 			});
507 		} else {
508 			Stream.of(viewerActions).forEach(a -&gt; a.setViewer(null));
509 		}
510 
511 		viewer.getControl().addListener(SWT.EraseItem, PERCENTAGE_BACKGROUND_DRAWER);
512 		viewer.getControl().addDisposeListener(e -&gt; columnWidths = getColumnWidths());
513 
514 		buildColumn(viewer, Messages.STACKTRACE_VIEW_STACK_TRACE, SWT.NONE, columnWidths[0])
515 				.setLabelProvider(stackTraceLabelProvider);
516 		buildColumn(viewer, Messages.STACKTRACE_VIEW_COUNT_COLUMN_NAME, SWT.RIGHT, columnWidths[1])
517 				.setLabelProvider(countLabelProvider);
518 		buildColumn(viewer, Messages.STACKTRACE_VIEW_PERCENTAGE_COLUMN_NAME, SWT.RIGHT, columnWidths[2])
519 				.setLabelProvider(percentageLabelProvider);
520 
521 		PlatformUI.getWorkbench().getHelpSystem().setHelp(viewer.getControl(), HELP_CONTEXT_ID);
522 
523 		if (UIPlugin.getDefault().getAccessibilityMode()) {
524 			if (treeLayout) {
525 				FocusTracker.enableFocusTracking(((TreeViewer) viewer).getTree());
526 			} else {
527 				FocusTracker.enableFocusTracking(((TableViewer) viewer).getTable());
528 			}
529 		}
530 	}
531 
532 	private static TableViewer buildTable(Composite parent) {
533 		TableViewer tableViewer = new TableViewer(parent,
534 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
535 		tableViewer.setContentProvider(new AbstractStructuredContentProvider() {
536 			@Override
537 			public Object[] getElements(Object inputElement) {
538 				SimpleArray&lt;StacktraceFrame&gt; trace = new SimpleArray&lt;&gt;(new StacktraceFrame[100]);
539 				addSelectedBranches((Fork) inputElement, trace, false);
540 				return trace.elements();
541 			}
542 		});
543 		tableViewer.getTable().setHeaderVisible(true);
544 		tableViewer.getTable().setLinesVisible(true);
545 		return tableViewer;
546 	}
547 
548 	private TreeViewer buildTree(Composite parent) {
549 		TreeViewer treeViewer = new TreeViewer(parent,
550 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
551 		treeViewer.setContentProvider(createTreeContentProvider());
552 		treeViewer.getTree().setHeaderVisible(true);
553 		treeViewer.getTree().setLinesVisible(true);
554 		return treeViewer;
555 	}
556 
557 	private static ViewerColumn buildColumn(ColumnViewer viewer, String text, int style, int width) {
558 		if (viewer instanceof TableViewer) {
559 			TableViewerColumn vc = new TableViewerColumn((TableViewer) viewer, style);
560 			vc.getColumn().setWidth(width);
561 			vc.getColumn().setText(text);
562 			return vc;
563 		} else {
564 			TreeViewerColumn vc = new TreeViewerColumn((TreeViewer) viewer, style);
565 			vc.getColumn().setWidth(width);
566 			vc.getColumn().setText(text);
567 			return vc;
568 		}
569 	}
570 
571 	private int[] getColumnWidths() {
572 		if (!viewer.getControl().isDisposed()) {
573 			if (viewer instanceof TableViewer) {
574 				return Stream.of(((TableViewer) viewer).getTable().getColumns()).mapToInt(TableColumn::getWidth)
575 						.toArray();
576 			} else {
577 				return Stream.of(((TreeViewer) viewer).getTree().getColumns()).mapToInt(TreeColumn::getWidth).toArray();
578 			}
579 		}
580 		return columnWidths;
581 	}
582 
583 	private void addOptions(IMenuManager menu) {
584 		MenuManager groupMenu = new MenuManager(Messages.STACKTRACE_VIEW_GROUP_FROM);
585 		Stream.of(groupByActions).forEach(groupMenu::add);
586 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, groupMenu);
587 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, frameSeparatorManager.createMenu());
588 		MenuManager layoutMenu = new MenuManager(Messages.STACKTRACE_VIEW_LAYOUT_OPTIONS);
589 		Stream.of(layoutActions).forEach(layoutMenu::add);
590 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, layoutMenu);
591 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, methodFormatter.createMenu());
592 		SelectionStoreActionToolkit.addSelectionStoreActions(viewer, this::getSelectionStore,
593 				this::getFlavoredSelection, menu);
594 	}
595 
596 	private IFlavoredSelection getFlavoredSelection() {
597 		ISelection selection = viewer.getSelection();
598 		if (selection instanceof IStructuredSelection &amp;&amp; !selection.isEmpty()) {
599 			List&lt;?&gt; selected = ((StructuredSelection) selection).toList();
600 			StacktraceFrame frame = (StacktraceFrame) selected.get(0);
601 			return new StacktraceFrameSelection(frame.getFrame(),
602 					ItemCollectionToolkit.build(Stream.of(frame.getItems().elements())),
603 					Messages.STACKTRACE_VIEW_SELECTION);
604 		}
605 		return null;
606 	}
607 
608 	private SelectionStore getSelectionStore() {
609 		IEditorPart editorPart = null;
610 		try {
611 			PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
612 			editorPart = getSite().getPage().getActiveEditor();
613 		} catch (Exception e) {
614 			FlightRecorderUI.getDefault().getLogger().log(Level.INFO,
615 					&quot;Got exception while trying to get the active editor&quot;, e); //$NON-NLS-1$
616 		}
617 		if (editorPart instanceof IPageContainer) {
618 			return ((IPageContainer) editorPart).getSelectionStore();
619 		}
620 		return null;
621 	}
622 
623 	@Override
624 	public void setFocus() {
625 		viewer.getControl().setFocus();
626 	}
627 
628 	@Override
629 	public void saveState(IMemento memento) {
630 		memento.putString(COLUMNS_KEY, IntStream.of(getColumnWidths()).mapToObj(Integer::toString)
631 				.collect(Collectors.joining(COLUMNS_SEPARATOR)));
632 		methodFormatter.saveState(memento.createChild(METHOD_FORMAT_KEY));
633 		memento.putBoolean(THREAD_ROOT_KEY, threadRootAtTop);
634 		memento.putBoolean(TREE_LAYOUT_KEY, treeLayout);
635 		memento.putBoolean(REDUCED_TREE_KEY, reducedTree);
636 		FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
637 		memento.putBoolean(FRAME_OPTIMIZATION_KEY, frameSeparator.isDistinguishFramesByOptimization());
638 		memento.putString(FRAME_CATEGORIZATION_KEY, frameSeparator.getCategorization().name());
639 	}
640 
641 	@Override
642 	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
643 		if (selection instanceof IStructuredSelection) {
644 			Object first = ((IStructuredSelection) selection).getFirstElement();
645 			IItemCollection items = AdapterUtil.getAdapter(first, IItemCollection.class);
646 			if (items == null) {
647 				setItems(ItemCollectionToolkit.build(Stream.empty()));
648 			} else if (!items.equals(itemsToShow)) {
649 				setItems(items);
650 			}
651 		}
652 	}
653 
654 	private void setItems(IItemCollection items) {
655 		itemsToShow = items;
656 		rebuildModel();
657 	}
658 
659 	private StacktraceModel createStacktraceModel() {
660 		return new StacktraceModel(threadRootAtTop, frameSeparatorManager.getFrameSeparator(), itemsToShow);
661 	}
662 
663 	private void rebuildModel() {
664 		// Release old model before building the new
665 		setViewerInput(null);
666 		CompletableFuture&lt;StacktraceModel&gt; modelPreparer = getModelPreparer(createStacktraceModel(), !treeLayout);
667 		modelPreparer.thenAcceptAsync(this::setModel, DisplayToolkit.inDisplayThread())
668 				.exceptionally(StacktraceView::handleModelBuildException);
669 	}
670 
671 	private static CompletableFuture&lt;StacktraceModel&gt; getModelPreparer(
672 		StacktraceModel model, boolean materializeSelectedBranches) {
673 		return CompletableFuture.supplyAsync(() -&gt; {
674 			Fork root = model.getRootFork();
675 			if (materializeSelectedBranches) {
676 				Branch selectedBranch = getLastSelectedBranch(root);
677 				if (selectedBranch != null) {
678 					selectedBranch.getEndFork();
679 				}
680 			}
681 			return model;
682 		});
683 	}
684 
685 	private static Void handleModelBuildException(Throwable ex) {
686 		FlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, &quot;Failed to build stacktrace view model&quot;, ex); //$NON-NLS-1$
687 		return null;
688 	}
689 
690 	private void setModel(StacktraceModel model) {
691 		// Check that the model is up to date
692 		if (model.equals(createStacktraceModel()) &amp;&amp; !viewer.getControl().isDisposed()) {
693 			setViewerInput(model.getRootFork());
694 		}
695 	}
696 
697 	private void setViewerInput(Fork rootFork) {
698 		// NOTE: will be slow for TreeViewer if number of roots or children of a node are more than ~1000
699 		viewer.setInput(rootFork);
700 	}
701 
702 	private ITreeContentProvider createTreeContentProvider() {
703 		return reducedTree ? new StacktraceReducedTreeContentProvider() : new StacktraceTreeContentProvider();
704 	}
705 
706 	private static final Listener PERCENTAGE_BACKGROUND_DRAWER = new Listener() {
707 		@Override
708 		public void handleEvent(Event event) {
709 			StacktraceFrame frame = (StacktraceFrame) event.item.getData();
710 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
711 			double total;
712 			if (event.index == 2 &amp;&amp; (total = rootFork.getItemsInFork()) &gt; 0) { // index == 2 =&gt; percentage column
713 				// Draw siblings
714 				Fork parentFork = frame.getBranch().getParentFork();
715 				int forkOffset = parentFork.getItemOffset();
716 				int siblingsStart = (int) Math.floor(event.width * forkOffset / total);
717 				int siblingsWidth = (int) Math.round(event.width * parentFork.getItemsInFork() / total);
718 				event.gc.setBackground(SIBLINGS_COUNT_COLOR);
719 				event.gc.fillRectangle(event.x + siblingsStart, event.y, siblingsWidth, event.height);
720 				// Draw group
721 				double offset = (forkOffset + frame.getBranch().getItemOffsetInFork()) / total;
722 				double fraction = frame.getItemCount() / total;
723 				event.gc.setBackground(COUNT_COLOR);
724 				int startPixel = (int) Math.floor(event.width * offset);
725 				int widthPixel = (int) Math.round(event.width * fraction);
726 				event.gc.fillRectangle(event.x + startPixel, event.y, Math.max(widthPixel, 1), event.height);
727 				event.detail &amp;= ~SWT.BACKGROUND;
728 			}
729 		}
730 	};
731 
732 	private final ColumnLabelProvider percentageLabelProvider = new ColumnLabelProvider() {
733 		@Override
734 		public String getText(Object element) {
735 			StacktraceFrame frame = (StacktraceFrame) element;
736 			int itemCount = frame.getItemCount();
737 			int totalCount = getRootFork(frame.getBranch().getParentFork()).getItemsInFork();
738 			return UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount).displayUsing(IDisplayable.AUTO);
739 		}
740 
741 		@Override
742 		public String getToolTipText(Object element) {
743 			StacktraceFrame frame = (StacktraceFrame) element;
744 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
745 			int itemCount = frame.getItemCount();
746 			int totalCount = rootFork.getItemsInFork();
747 			Fork parentFork = frame.getBranch().getParentFork();
748 			int itemsInSiblings = parentFork.getItemsInFork() - frame.getBranch().getFirstFrame().getItemCount();
749 			String frameFraction = UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount)
750 					.displayUsing(IDisplayable.AUTO);
751 			StringBuilder sb = new StringBuilder(&quot;&lt;form&gt;&quot;); //$NON-NLS-1$
752 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + COUNT_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
753 			sb.append(Messages.stackTraceMessage(itemCount, totalCount, frameFraction));
754 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
755 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + SIBLINGS_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
756 			sb.append(Messages.siblingMessage(itemsInSiblings, parentFork.getBranchCount() - 1));
757 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
758 			sb.append(&quot;&lt;/form&gt;&quot;); //$NON-NLS-1$
759 			return sb.toString();
760 		}
761 	};
762 
763 	private final ColumnLabelProvider countLabelProvider = new ColumnLabelProvider() {
764 		@Override
765 		public String getText(Object element) {
766 			return Integer.toString(((StacktraceFrame) element).getItemCount());
767 		}
768 	};
769 
770 	private final ColumnLabelProvider stackTraceLabelProvider = new ColumnLabelProvider() {
771 
772 		@Override
773 		public String getText(Object element) {
774 			IMCFrame frame = ((StacktraceFrame) element).getFrame();
775 			FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
776 			return getText(frame, frameSeparator);
777 		}
778 
779 		private String getText(IMCFrame frame, FrameSeparator frameSeparator) {
780 			return StacktraceFormatToolkit.formatFrame(frame, frameSeparator, methodFormatter.showReturnValue(),
781 					methodFormatter.showReturnValuePackage(), methodFormatter.showClassName(),
782 					methodFormatter.showClassPackageName(), methodFormatter.showArguments(),
783 					methodFormatter.showArgumentsPackage());
784 		}
785 
786 		@Override
787 		public Image getImage(Object element) {
788 			StacktraceFrame frame = (StacktraceFrame) element;
789 			FlightRecorderUI plugin = FlightRecorderUI.getDefault();
790 			boolean isFirstInBranch = isFirstInBranchWithSiblings(frame);
791 			boolean firstInOpenFork = isFirstInBranch &amp;&amp; isInOpenFork(frame);
792 			if (firstInOpenFork || treeLayout &amp;&amp; (!reducedTree || isFirstInBranch)) {
793 				return plugin.getImage(
794 						threadRootAtTop ? ImageConstants.ICON_ARROW_CURVED_DOWN : ImageConstants.ICON_ARROW_CURVED_UP);
795 			} else if (isFirstInBranchWithSiblings(frame)) {
796 				return plugin.getImage(
797 						threadRootAtTop ? ImageConstants.ICON_ARROW_FORK3_DOWN : ImageConstants.ICON_ARROW_FORK3_UP);
798 			} else if (isLastFrame(frame)) {
799 				return plugin.getImage(
800 						threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN_END : ImageConstants.ICON_ARROW_UP_END);
801 			} else {
802 				return plugin.getImage(threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN : ImageConstants.ICON_ARROW_UP);
803 			}
804 		}
805 
806 		@Override
807 		public Color getBackground(Object element) {
808 			if (treeLayout) {
809 				return null;
810 			} else {
811 				int parentCount = 0;
812 				Branch e = ((StacktraceFrame) element).getBranch();
813 				while (e != null) {
814 					e = e.getParentFork().getParentBranch();
815 					parentCount++;
816 				}
817 				return parentCount % 2 == 0 ? null : ALTERNATE_COLOR;
818 			}
819 		}
820 	};
821 
822 	private static boolean isNavigationFrame(StacktraceFrame frame) {
823 		return isFirstInBranchWithSiblings(frame) &amp;&amp; !isInOpenFork(frame);
824 	}
825 
<a name="4" id="anc4"></a>

826 	private static boolean isInOpenFork(StacktraceFrame frame) {
827 		return frame.getBranch().getParentFork().getSelectedBranch() == null;
828 	}
829 
830 	private static boolean isFirstInBranchWithSiblings(StacktraceFrame frame) {
831 		return frame.getBranch().getFirstFrame() == frame &amp;&amp; frame.getBranch().getParentFork().getBranchCount() &gt; 1;
832 	}
833 
834 	private static boolean isLastFrame(StacktraceFrame frame) {
835 		return frame.getBranch().getLastFrame() == frame &amp;&amp; frame.getBranch().getEndFork().getBranchCount() == 0;
836 	}
837 
838 	/*
839 	 * FIXME: &#39;backwards&#39; argument was used for displaying trace groups built from thread roots with
840 	 * the thread roots at the bottom. If we don&#39;t want to support that scenario then we can remove
841 	 * this argument.
842 	 */
843 	private static void addSelectedBranches(Fork fork, SimpleArray&lt;StacktraceFrame&gt; input, boolean backwards) {
<a name="5" id="anc5"></a>

844 		Branch selectedBranch = fork.getSelectedBranch();
845 		if (selectedBranch == null) {
846 			Stream.of(fork.getFirstFrames()).forEach(input::add);
847 		} else if (backwards) {
848 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
849 			StacktraceFrame[] tail = selectedBranch.getTailFrames();
850 			for (int i = tail.length; i &gt; 0; i--) {
851 				input.add(tail[i - 1]);
852 			}
853 			input.add(selectedBranch.getFirstFrame());
854 		} else {
855 			input.add(selectedBranch.getFirstFrame());
856 			input.addAll(selectedBranch.getTailFrames());
857 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
858 		}
859 	}
860 
<a name="6" id="anc6"></a>

861 	private static Branch getLastSelectedBranch(Fork fromFork) {
862 		Branch lastSelectedBranch = null;
863 		Branch branch = fromFork.getSelectedBranch();
864 		while (branch != null) {
865 			lastSelectedBranch = branch;
866 			branch = branch.getEndFork().getSelectedBranch();
867 		}
868 		return lastSelectedBranch;
869 	}
870 
871 	private static Fork getRootFork(Fork fork) {
872 		while (fork.getParentBranch() != null) {
873 			fork = fork.getParentBranch().getParentFork();
874 		}
875 		return fork;
876 	}
877 
878 	private static class StacktraceTreeContentProvider extends AbstractStructuredContentProvider
879 			implements ITreeContentProvider {
880 
881 		@Override
882 		public StacktraceFrame[] getElements(Object inputElement) {
883 			return ((Fork) inputElement).getFirstFrames();
884 		}
885 
886 		@Override
887 		public boolean hasChildren(Object element) {
888 			StacktraceFrame frame = (StacktraceFrame) element;
889 			return !isLastFrame(frame);
890 		}
891 
892 		@Override
893 		public StacktraceFrame[] getChildren(Object parentElement) {
894 			StacktraceFrame frame = (StacktraceFrame) parentElement;
895 			StacktraceFrame[] tailFrames = frame.getBranch().getTailFrames();
896 			if (frame.getIndexInBranch() == tailFrames.length) {
897 				return frame.getBranch().getEndFork().getFirstFrames();
898 			} else {
899 				return new StacktraceFrame[] {tailFrames[frame.getIndexInBranch()]};
900 			}
901 		}
902 
903 		@Override
904 		public StacktraceFrame getParent(Object element) {
905 			StacktraceFrame frame = (StacktraceFrame) element;
906 			int parentIndexInBranch = frame.getIndexInBranch() - 1;
907 			if (parentIndexInBranch &gt; 0) {
908 				return frame.getBranch().getTailFrames()[parentIndexInBranch - 1];
909 			} else if (parentIndexInBranch == 0) {
910 				return frame.getBranch().getFirstFrame();
911 			} else {
912 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
913 				return parentBranch == null ? null : parentBranch.getLastFrame();
914 			}
915 		}
916 	};
917 
918 	private static class StacktraceReducedTreeContentProvider extends AbstractStructuredContentProvider
919 			implements ITreeContentProvider {
920 
921 		@Override
922 		public StacktraceFrame[] getElements(Object inputElement) {
923 			Fork rootFork = (Fork) inputElement;
924 			if (rootFork.getBranchCount() == 1) {
925 				Branch branch = rootFork.getBranch(0);
926 				return Stream
927 						.concat(Stream.concat(Stream.of(branch.getFirstFrame()), Stream.of(branch.getTailFrames())),
928 								Stream.of(branch.getEndFork().getFirstFrames()))
929 						.toArray(StacktraceFrame[]::new);
930 			} else {
931 				return rootFork.getFirstFrames();
932 			}
933 		}
934 
935 		@Override
936 		public boolean hasChildren(Object element) {
937 			StacktraceFrame frame = (StacktraceFrame) element;
938 			return isFirstInBranchWithSiblings(frame) &amp;&amp; frame.getBranch().hasTail();
939 		}
940 
941 		@Override
942 		public StacktraceFrame[] getChildren(Object parentElement) {
943 			Stream&lt;StacktraceFrame&gt; children = Stream.empty();
944 			StacktraceFrame frame = (StacktraceFrame) parentElement;
945 			if (isFirstInBranchWithSiblings(frame)) {
946 				children = Stream.concat(Stream.of(frame.getBranch().getTailFrames()),
947 						Stream.of(frame.getBranch().getEndFork().getFirstFrames()));
948 			}
949 			return children.toArray(StacktraceFrame[]::new);
950 		}
951 
952 		@Override
953 		public StacktraceFrame getParent(Object element) {
954 			StacktraceFrame frame = (StacktraceFrame) element;
955 			if (isFirstInBranchWithSiblings(frame) || frame.getBranch().getParentFork().getBranchCount() == 1) {
956 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
957 				return parentBranch == null ? null : parentBranch.getFirstFrame();
958 			} else {
959 				return frame.getBranch().getFirstFrame();
960 			}
961 		}
962 	}
963 
964 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
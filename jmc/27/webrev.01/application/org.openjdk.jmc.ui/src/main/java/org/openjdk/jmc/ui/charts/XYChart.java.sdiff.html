<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AWTChartToolkit.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../misc/ChartCanvas.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
</pre>
<hr />
<pre>
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.ui.charts;
 34 
 35 import java.awt.Color;
 36 import java.awt.Graphics2D;
 37 import java.awt.Point;
 38 import java.awt.geom.AffineTransform;
 39 import java.awt.geom.Point2D;
 40 import java.util.ArrayList;
 41 import java.util.HashSet;
 42 import java.util.List;
 43 import java.util.Set;

 44 import java.util.function.Consumer;
 45 
 46 import org.openjdk.jmc.common.IDisplayable;
 47 import org.openjdk.jmc.common.unit.IQuantity;
 48 import org.openjdk.jmc.common.unit.IRange;
 49 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 50 import org.openjdk.jmc.common.unit.QuantityRange;

 51 import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;



 52 
 53 public class XYChart {
 54 	private static final String ELLIPSIS = &quot;...&quot;; //$NON-NLS-1$
 55 	private static final Color SELECTION_COLOR = new Color(255, 255, 255, 220);
 56 	private static final Color RANGE_INDICATION_COLOR = new Color(255, 60, 20);
<span class="line-modified"> 57 	private static final int Y_OFFSET = 35;</span>
<span class="line-modified"> 58 	private static final int RANGE_INDICATOR_HEIGHT = 4;</span>
 59 	private final IQuantity start;
 60 	private final IQuantity end;

 61 	private IXDataRenderer rendererRoot;
 62 	private IRenderedRow rendererResult;
 63 	private final int xOffset;

 64 	private final int bucketWidth;
 65 	// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
 66 //	private final int ticksPerBucket = 4;
 67 
 68 	private IQuantity currentStart;
 69 	private IQuantity currentEnd;
 70 
 71 	private final Set&lt;Object&gt; selectedRows = new HashSet&lt;&gt;();


 72 	private IQuantity selectionStart;
 73 	private IQuantity selectionEnd;
 74 	private SubdividedQuantityRange xBucketRange;
 75 	private SubdividedQuantityRange xTickRange;
<span class="line-modified"> 76 	private int axisWidth;</span>











 77 
 78 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot) {
 79 		this(range.getStart(), range.getEnd(), rendererRoot);
 80 	}
 81 
 82 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset) {
 83 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
 84 	}
 85 













 86 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
 87 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset, bucketWidth);
 88 	}
 89 
 90 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot) {
 91 		this(start, end, rendererRoot, 60);
 92 	}
 93 
 94 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset) {
 95 		this(start, end, rendererRoot, xOffset, 25);
 96 	}
 97 
 98 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
 99 		this.rendererRoot = rendererRoot;
100 		// Start value must always be strictly less than end
101 		assert (start.compareTo(end) &lt; 0);
<span class="line-modified">102 		currentStart = start;</span>
103 		this.start = start;
<span class="line-modified">104 		currentEnd = end;</span>
105 		this.end = end;
106 		this.xOffset = xOffset;
107 		this.bucketWidth = bucketWidth;
108 	}
109 
110 	public void setRendererRoot(IXDataRenderer rendererRoot) {
111 		clearSelection();
112 		this.rendererRoot = rendererRoot;

113 	}
114 
115 	public IXDataRenderer getRendererRoot() {
116 		return rendererRoot;
117 	}
118 
119 	public Object[] getSelectedRows() {
120 		return selectedRows.toArray(new Object[selectedRows.size()]);
121 	}
122 
123 	public IQuantity getSelectionStart() {
124 		return selectionStart;
125 	}
126 
127 	public IQuantity getSelectionEnd() {
128 		return selectionEnd;
129 	}
130 
131 	public IRange&lt;IQuantity&gt; getSelectionRange() {
132 		return (selectionStart != null) &amp;&amp; (selectionEnd != null)
133 				? QuantityRange.createWithEnd(selectionStart, selectionEnd) : null;
134 	}
135 
<span class="line-modified">136 	public void render(Graphics2D context, int width, int height) {</span>
<span class="line-modified">137 		if (width &gt; xOffset &amp;&amp; height &gt; Y_OFFSET) {</span>
138 			axisWidth = width - xOffset;
139 			// FIXME: xBucketRange and xTickRange should be more related, so that each tick is typically an integer number of buckets (or possibly 2.5 buckets).
140 			xBucketRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
141 			// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
142 			xTickRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 100);
143 			AffineTransform oldTransform = context.getTransform();
144 			context.translate(xOffset, 0);
<span class="line-modified">145 			doRender(context, height - Y_OFFSET);</span>
146 			context.setTransform(oldTransform);
147 		}
148 	}
149 

















150 	private void renderRangeIndication(Graphics2D context, int rangeIndicatorY) {
151 		// FIXME: Extract the needed functionality from SubdividedQuantityRange
152 		SubdividedQuantityRange fullRangeAxis = new SubdividedQuantityRange(start, end, axisWidth, 25);
153 		int x1 = (int) fullRangeAxis.getPixel(currentStart);
154 		int x2 = (int) Math.ceil(fullRangeAxis.getPixel(currentEnd));
<span class="line-modified">155 		if (x1 &gt; 0 || x2 &lt; axisWidth) {</span>




156 			context.setPaint(RANGE_INDICATION_COLOR);
157 			context.fillRect(x1, rangeIndicatorY, x2 - x1, RANGE_INDICATOR_HEIGHT);
158 			context.setPaint(Color.DARK_GRAY);
159 			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
160 		}
161 	}
162 
<span class="line-modified">163 	private void doRender(Graphics2D context, int axisHeight) {</span>


















164 		context.setPaint(Color.LIGHT_GRAY);
165 		AWTChartToolkit.drawGrid(context, xTickRange, axisHeight, false);
166 		// Attempt to make graphs so low they cover the axis show by drawing the full axis first ...
167 		context.setPaint(Color.BLACK);
<span class="line-modified">168 		AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);</span>




169 		// ... then the graph ...
<span class="line-modified">170 		rendererResult = rendererRoot.render(context, xBucketRange, axisHeight);</span>
171 		AffineTransform oldTransform = context.getTransform();
<span class="line-modified">172 		renderText(context, rendererResult);</span>
173 		context.setTransform(oldTransform);
174 		if (!selectedRows.isEmpty()) {
<span class="line-modified">175 			renderSelection(context, rendererResult);</span>
176 			context.setTransform(oldTransform);
177 		}
178 		// .. and finally a semitransparent axis line again.
179 		context.setPaint(new Color(0, 0, 0, 64));
180 		context.drawLine(0, axisHeight - 1, axisWidth - 1, axisHeight - 1);
181 		renderRangeIndication(context, axisHeight + 25);
182 	}
183 
<span class="line-modified">184 	private void renderSelection(Graphics2D context, IRenderedRow row) {</span>












































185 		if (selectedRows.contains(row.getPayload())) {
186 			renderSelection(context, xBucketRange, row.getHeight());
187 		} else {
188 			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
189 			if (subdivision.isEmpty()) {
190 				dimRect(context, 0, axisWidth, row.getHeight());
191 			} else {
192 				for (IRenderedRow nestedRow : row.getNestedRows()) {
<span class="line-modified">193 					renderSelection(context, nestedRow);</span>
194 				}
195 				return;
196 			}
197 		}
198 		context.translate(0, row.getHeight());
199 	}
200 














201 	private void renderText(Graphics2D context, IRenderedRow row) {
202 		String text = row.getName();
203 		int height = row.getHeight();
204 		if (height &gt;= context.getFontMetrics().getHeight()) {
205 			if (text != null) {

206 				context.setColor(Color.BLACK);
<span class="line-modified">207 				int y;</span>
<span class="line-modified">208 				if (height &gt; 40) {</span>
<span class="line-removed">209 					context.drawLine(-xOffset, height - 1, -15, height - 1);</span>
<span class="line-removed">210 					y = height - context.getFontMetrics().getHeight() / 2;</span>
<span class="line-removed">211 				} else {</span>
<span class="line-removed">212 					// draw the string in the middle of the row</span>
<span class="line-removed">213 					y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();</span>
<span class="line-removed">214 				}</span>
215 				int charsWidth = context.getFontMetrics().charsWidth(text.toCharArray(), 0, text.length());
<span class="line-modified">216 				if (charsWidth &gt; xOffset) {</span>



217 					float fitRatio = ((float) xOffset) / (charsWidth
218 							+ context.getFontMetrics().charsWidth(ELLIPSIS.toCharArray(), 0, ELLIPSIS.length()));
219 					text = text.substring(0, ((int) (text.length() * fitRatio)) - 1) + ELLIPSIS;
220 				}
<span class="line-modified">221 				context.drawString(text, -xOffset + 2, y);</span>
222 			} else {
223 				List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
224 				if (!subdivision.isEmpty()) {
225 					for (IRenderedRow nestedRow : row.getNestedRows()) {
226 						renderText(context, nestedRow);
227 					}
228 					return;
229 				}
230 			}
231 		}
232 		context.translate(0, height);
233 	}
234 









235 	/**
236 	 * Pan the view.
237 	 *
238 	 * @param rightPercent
239 	 * @return true if the bounds changed. That is, if a redraw is required.
240 	 */
241 	public boolean pan(int rightPercent) {



242 		if (xBucketRange != null) {
243 			IQuantity oldStart = currentStart;
244 			IQuantity oldEnd = currentEnd;
245 			if (rightPercent &gt; 0) {
246 				currentEnd = QuantitiesToolkit
247 						.min(xBucketRange.getQuantityAtPixel(axisWidth + axisWidth * rightPercent / 100), end);
248 				currentStart = QuantitiesToolkit
249 						.max(xBucketRange.getQuantityAtPixel(xBucketRange.getPixel(currentEnd) - axisWidth), start);
250 			} else if (rightPercent &lt; 0) {
251 				currentStart = QuantitiesToolkit.max(xBucketRange.getQuantityAtPixel(axisWidth * rightPercent / 100),
252 						start);
253 				currentEnd = QuantitiesToolkit
254 						.min(xBucketRange.getQuantityAtPixel(xBucketRange.getPixel(currentStart) + axisWidth), end);
255 			}
256 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
257 		}
258 		// Return true since a redraw forces creation of xBucketRange.
259 		return true;
260 	}
261 




































262 	/**
263 	 * Zoom the view.
264 	 *
265 	 * @param zoomInSteps
266 	 * @return true if the bounds changed. That is, if a redraw is required.
267 	 */
268 	public boolean zoom(int zoomInSteps) {



269 		return zoomXAxis(axisWidth / 2, zoomInSteps);
270 	}
271 
272 	/**
273 	 * Zoom the view.
274 	 *
275 	 * @param x
276 	 * @param zoomInSteps
277 	 * @return true if the bounds changed. That is, if a redraw is required.
278 	 */
279 	public boolean zoom(int x, int zoomInSteps) {
280 		return zoomXAxis(x - xOffset, zoomInSteps);
281 	}
282 

283 	private boolean zoomXAxis(int x, int zoomInSteps) {
284 		if (xBucketRange == null) {
285 			// Return true since a redraw forces creation of xBucketRange.
286 			return true;
287 		}
288 		if ((x &gt; 0) &amp;&amp; (x &lt; axisWidth)) {
289 			IQuantity oldStart = currentStart;
290 			IQuantity oldEnd = currentEnd;
291 			// Absolute value of zoomFactor must be less than 1. Currently it ranges between -0.5 and 0.5.
292 			double zoomFactor = Math.atan(zoomInSteps) / Math.PI;
293 			int newStart = (int) (zoomFactor * x);
294 			int newEnd = (int) (axisWidth * (1 - zoomFactor)) + newStart;
295 			SubdividedQuantityRange xAxis = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 1);
296 			setVisibleRange(xAxis.getQuantityAtPixel(newStart), xAxis.getQuantityAtPixel(newEnd));
297 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
298 		}
299 		return false;
300 	}
301 


















































































































































































302 	public void setVisibleRange(IQuantity rangeStart, IQuantity rangeEnd) {




303 		rangeStart = QuantitiesToolkit.max(rangeStart, start);
304 		rangeEnd = QuantitiesToolkit.min(rangeEnd, end);
305 		if (rangeStart.compareTo(rangeEnd) &lt; 0) {
306 			SubdividedQuantityRange testRange = new SubdividedQuantityRange(rangeStart, rangeEnd, 10000, 1);
307 			if (testRange.getQuantityAtPixel(0).compareTo(testRange.getQuantityAtPixel(1)) &lt; 0) {
308 				currentStart = rangeStart;
309 				currentEnd = rangeEnd;
310 			} else {
311 				// Ensures that zoom out is always allowed
312 				currentStart = QuantitiesToolkit.min(rangeStart, currentStart);
313 				currentEnd = QuantitiesToolkit.max(rangeEnd, currentEnd);
314 			}




315 			rangeListeners.stream().forEach(l -&gt; l.accept(getVisibleRange()));
316 		}
317 	}
318 
319 	private List&lt;Consumer&lt;IRange&lt;IQuantity&gt;&gt;&gt; rangeListeners = new ArrayList&lt;&gt;();
320 
321 	public void addVisibleRangeListener(Consumer&lt;IRange&lt;IQuantity&gt;&gt; rangeListener) {
322 		rangeListeners.add(rangeListener);
323 	}
324 
325 	public IRange&lt;IQuantity&gt; getVisibleRange() {
326 		return (currentStart != null) &amp;&amp; (currentEnd != null) ? QuantityRange.createWithEnd(currentStart, currentEnd)
327 				: null;
328 	}
329 
330 	public void clearVisibleRange() {
331 		currentStart = start;
332 		currentEnd = end;
333 	}
334 
<span class="line-modified">335 	public boolean select(int x1, int x2, int y1, int y2) {</span>
<span class="line-modified">336 		int xStart = Math.min(x1, x2) - xOffset;</span>
<span class="line-modified">337 		int xEnd = Math.max(x1, x2) - xOffset;</span>
338 
<span class="line-modified">339 		if (xBucketRange != null &amp;&amp; (xEnd &gt;= 0)) {</span>
<span class="line-modified">340 			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart)), xBucketRange.getQuantityAtPixel(xEnd),</span>
<span class="line-modified">341 					y1, y2);</span>
342 		} else {
<span class="line-modified">343 			return select(null, null, y1, y2);</span>
344 		}
345 	}
346 
<span class="line-modified">347 	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2) {</span>
348 		if (xStart != null &amp;&amp; xStart.compareTo(start) &lt; 0) {
349 			xStart = start;
350 		}
351 		if (xEnd != null &amp;&amp; xEnd.compareTo(end) &gt; 0) {
352 			xEnd = end;
353 		}
354 		Set&lt;Object&gt; oldRows = null;
355 		if (QuantitiesToolkit.same(selectionStart, xStart) &amp;&amp; QuantitiesToolkit.same(selectionEnd, xEnd)) {
356 			oldRows = new HashSet&lt;&gt;(selectedRows);
357 		}
<span class="line-modified">358 		selectedRows.clear();</span>


359 		addSelectedRows(rendererResult, 0, Math.min(y1, y2), Math.max(y1, y2));
360 		selectionStart = xStart;
361 		selectionEnd = xEnd;
362 		return (oldRows == null) || !oldRows.equals(selectedRows);
363 	}
364 
365 	public boolean clearSelection() {
366 		if ((selectionStart == null) &amp;&amp; (selectionEnd == null) &amp;&amp; selectedRows.isEmpty()) {
367 			return false;
368 		}
369 		selectedRows.clear();
370 		selectionStart = selectionEnd = null;
371 		return true;
372 	}
373 
374 	private boolean addSelectedRows(IRenderedRow row, int yRowStart, int ySelectionStart, int ySelectionEnd) {
375 		List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
376 		if (subdivision.isEmpty()) {
377 			return addPayload(row);
378 		} else {
379 			boolean nestedHasPayload = false;
380 			for (IRenderedRow nestedRow : row.getNestedRows()) {
381 				int yRowEnd = yRowStart + nestedRow.getHeight();
382 				if (yRowStart &gt; ySelectionEnd) {
383 					break;
384 				} else if (yRowEnd &gt; ySelectionStart) {
385 					nestedHasPayload |= addSelectedRows(nestedRow, yRowStart, ySelectionStart, ySelectionEnd);
386 				}
387 				yRowStart = yRowEnd;
388 			}
389 			return nestedHasPayload || addPayload(row);
390 		}
391 	}
392 
393 	private boolean addPayload(IRenderedRow row) {
394 		Object payload = row.getPayload();
395 		if (payload != null) {
<span class="line-modified">396 			selectedRows.add(payload);</span>




397 			return true;
398 		}
399 		return false;
400 	}
401 
402 	private void renderSelection(Graphics2D context, SubdividedQuantityRange xRange, int height) {
403 		int selFrom = 0;
404 		int selTo = axisWidth;
405 		if (selectionStart != null &amp;&amp; selectionEnd != null) {
406 			selFrom = (int) xRange.getPixel(selectionStart);
407 			// Removed &quot;+ 1&quot; for now to make the selection symmetrical with respect to chart highlights.
408 			selTo = (int) xRange.getPixel(selectionEnd);
409 		}
410 		// FIXME: Would like to show selection by graying out the other parts, can we do that?
411 //		if (selWidth &gt; 0) {
412 //			context.setColor(Color.WHITE);
413 //			context.setXORMode(Color.BLACK);
414 //			Stroke oldStroke = context.getStroke();
415 //			context.setStroke(SELECTION_STROKE);
416 //			context.drawRect(selFrom, 0, selWidth, height);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
</pre>
<hr />
<pre>
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.ui.charts;
 34 
 35 import java.awt.Color;
 36 import java.awt.Graphics2D;
 37 import java.awt.Point;
 38 import java.awt.geom.AffineTransform;
 39 import java.awt.geom.Point2D;
 40 import java.util.ArrayList;
 41 import java.util.HashSet;
 42 import java.util.List;
 43 import java.util.Set;
<span class="line-added"> 44 import java.util.Stack;</span>
 45 import java.util.function.Consumer;
 46 
 47 import org.openjdk.jmc.common.IDisplayable;
 48 import org.openjdk.jmc.common.unit.IQuantity;
 49 import org.openjdk.jmc.common.unit.IRange;
 50 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 51 import org.openjdk.jmc.common.unit.QuantityRange;
<span class="line-added"> 52 import org.openjdk.jmc.common.unit.UnitLookup;</span>
 53 import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;
<span class="line-added"> 54 import org.openjdk.jmc.ui.misc.ChartDisplayControlBar;</span>
<span class="line-added"> 55 import org.openjdk.jmc.ui.misc.TimelineCanvas;</span>
<span class="line-added"> 56 import org.openjdk.jmc.ui.misc.PatternFly.Palette;</span>
 57 
 58 public class XYChart {
 59 	private static final String ELLIPSIS = &quot;...&quot;; //$NON-NLS-1$
 60 	private static final Color SELECTION_COLOR = new Color(255, 255, 255, 220);
 61 	private static final Color RANGE_INDICATION_COLOR = new Color(255, 60, 20);
<span class="line-modified"> 62 	private static final int BASE_ZOOM_LEVEL = 100;</span>
<span class="line-modified"> 63 	private static final int RANGE_INDICATOR_HEIGHT = 7;</span>
 64 	private final IQuantity start;
 65 	private final IQuantity end;
<span class="line-added"> 66 	private IQuantity rangeDuration;</span>
 67 	private IXDataRenderer rendererRoot;
 68 	private IRenderedRow rendererResult;
 69 	private final int xOffset;
<span class="line-added"> 70 	private int yOffset = 35;</span>
 71 	private final int bucketWidth;
 72 	// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
 73 //	private final int ticksPerBucket = 4;
 74 
 75 	private IQuantity currentStart;
 76 	private IQuantity currentEnd;
 77 
 78 	private final Set&lt;Object&gt; selectedRows = new HashSet&lt;&gt;();
<span class="line-added"> 79 	private int axisWidth;</span>
<span class="line-added"> 80 	private int rowColorCounter;</span>
 81 	private IQuantity selectionStart;
 82 	private IQuantity selectionEnd;
 83 	private SubdividedQuantityRange xBucketRange;
 84 	private SubdividedQuantityRange xTickRange;
<span class="line-modified"> 85 </span>
<span class="line-added"> 86 	// JFR Threads Page</span>
<span class="line-added"> 87 	private static final double ZOOM_PAN_FACTOR = 0.05;</span>
<span class="line-added"> 88 	private static final int ZOOM_PAN_MODIFIER = 2;</span>
<span class="line-added"> 89 	private double zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;</span>
<span class="line-added"> 90 	private double currentZoom;</span>
<span class="line-added"> 91 	private int zoomSteps;</span>
<span class="line-added"> 92 	private ChartDisplayControlBar displayBar;</span>
<span class="line-added"> 93 	private ChartFilterControlBar filterBar;</span>
<span class="line-added"> 94 	private Stack&lt;Integer&gt; modifiedSteps;</span>
<span class="line-added"> 95 	private TimelineCanvas timelineCanvas;</span>
<span class="line-added"> 96 	private int longestCharWidth = 0;</span>
 97 
 98 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot) {
 99 		this(range.getStart(), range.getEnd(), rendererRoot);
100 	}
101 
102 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset) {
103 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
104 	}
105 
<span class="line-added">106 	// JFR Threads Page</span>
<span class="line-added">107 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, Integer yOffset,</span>
<span class="line-added">108 			TimelineCanvas timelineCanvas, ChartFilterControlBar filterBar, ChartDisplayControlBar displayBar) {</span>
<span class="line-added">109 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);</span>
<span class="line-added">110 		this.yOffset = yOffset;</span>
<span class="line-added">111 		this.timelineCanvas = timelineCanvas;</span>
<span class="line-added">112 		this.filterBar = filterBar;</span>
<span class="line-added">113 		this.displayBar = displayBar;</span>
<span class="line-added">114 		this.rangeDuration = range.getExtent();</span>
<span class="line-added">115 		this.currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">116 		this.isZoomCalculated = false;</span>
<span class="line-added">117 	}</span>
<span class="line-added">118 </span>
119 	public XYChart(IRange&lt;IQuantity&gt; range, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
120 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset, bucketWidth);
121 	}
122 
123 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot) {
124 		this(start, end, rendererRoot, 60);
125 	}
126 
127 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset) {
128 		this(start, end, rendererRoot, xOffset, 25);
129 	}
130 
131 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
132 		this.rendererRoot = rendererRoot;
133 		// Start value must always be strictly less than end
134 		assert (start.compareTo(end) &lt; 0);
<span class="line-modified">135 		this.currentStart = start;</span>
136 		this.start = start;
<span class="line-modified">137 		this.currentEnd = end;</span>
138 		this.end = end;
139 		this.xOffset = xOffset;
140 		this.bucketWidth = bucketWidth;
141 	}
142 
143 	public void setRendererRoot(IXDataRenderer rendererRoot) {
144 		clearSelection();
145 		this.rendererRoot = rendererRoot;
<span class="line-added">146 		longestCharWidth = 0;</span>
147 	}
148 
149 	public IXDataRenderer getRendererRoot() {
150 		return rendererRoot;
151 	}
152 
153 	public Object[] getSelectedRows() {
154 		return selectedRows.toArray(new Object[selectedRows.size()]);
155 	}
156 
157 	public IQuantity getSelectionStart() {
158 		return selectionStart;
159 	}
160 
161 	public IQuantity getSelectionEnd() {
162 		return selectionEnd;
163 	}
164 
165 	public IRange&lt;IQuantity&gt; getSelectionRange() {
166 		return (selectionStart != null) &amp;&amp; (selectionEnd != null)
167 				? QuantityRange.createWithEnd(selectionStart, selectionEnd) : null;
168 	}
169 
<span class="line-modified">170 	public void renderChart(Graphics2D context, int width, int height) {</span>
<span class="line-modified">171 		if (width &gt; xOffset &amp;&amp; height &gt; yOffset) {</span>
172 			axisWidth = width - xOffset;
173 			// FIXME: xBucketRange and xTickRange should be more related, so that each tick is typically an integer number of buckets (or possibly 2.5 buckets).
174 			xBucketRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
175 			// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
176 			xTickRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 100);
177 			AffineTransform oldTransform = context.getTransform();
178 			context.translate(xOffset, 0);
<span class="line-modified">179 			doRenderChart(context, height - yOffset);</span>
180 			context.setTransform(oldTransform);
181 		}
182 	}
183 
<span class="line-added">184 	public void renderTextCanvasText(Graphics2D context, int width, int height) {</span>
<span class="line-added">185 		axisWidth = width;</span>
<span class="line-added">186 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">187 		doRenderTextCanvasText(context, height);</span>
<span class="line-added">188 		context.setTransform(oldTransform);</span>
<span class="line-added">189 	}</span>
<span class="line-added">190 </span>
<span class="line-added">191 	public void renderText(Graphics2D context, int width, int height) {</span>
<span class="line-added">192 		if (width &gt; xOffset &amp;&amp; height &gt; yOffset) {</span>
<span class="line-added">193 			axisWidth = xOffset;</span>
<span class="line-added">194 			AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">195 			doRenderText(context);</span>
<span class="line-added">196 			context.setTransform(oldTransform);</span>
<span class="line-added">197 			axisWidth = width - xOffset;</span>
<span class="line-added">198 		}</span>
<span class="line-added">199 	}</span>
<span class="line-added">200 </span>
201 	private void renderRangeIndication(Graphics2D context, int rangeIndicatorY) {
202 		// FIXME: Extract the needed functionality from SubdividedQuantityRange
203 		SubdividedQuantityRange fullRangeAxis = new SubdividedQuantityRange(start, end, axisWidth, 25);
204 		int x1 = (int) fullRangeAxis.getPixel(currentStart);
205 		int x2 = (int) Math.ceil(fullRangeAxis.getPixel(currentEnd));
<span class="line-modified">206 </span>
<span class="line-added">207 		if (timelineCanvas != null) {</span>
<span class="line-added">208 			timelineCanvas.renderRangeIndicator(x1, x2);</span>
<span class="line-added">209 			updateZoomPanIndicator();</span>
<span class="line-added">210 		} else {</span>
211 			context.setPaint(RANGE_INDICATION_COLOR);
212 			context.fillRect(x1, rangeIndicatorY, x2 - x1, RANGE_INDICATOR_HEIGHT);
213 			context.setPaint(Color.DARK_GRAY);
214 			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
215 		}
216 	}
217 
<span class="line-modified">218 	public void updateZoomPanIndicator() {</span>
<span class="line-added">219 		if (displayBar != null) {</span>
<span class="line-added">220 			displayBar.updateZoomPanIndicator();</span>
<span class="line-added">221 		}</span>
<span class="line-added">222 	}</span>
<span class="line-added">223 </span>
<span class="line-added">224 	private IRenderedRow getRendererResult(Graphics2D context, int axisHeight) {</span>
<span class="line-added">225 		if (xBucketRange == null) {</span>
<span class="line-added">226 			xBucketRange = getXBucketRange();</span>
<span class="line-added">227 		}</span>
<span class="line-added">228 		return rendererRoot.render(context, xBucketRange, axisHeight);</span>
<span class="line-added">229 	}</span>
<span class="line-added">230 </span>
<span class="line-added">231 	private SubdividedQuantityRange getXBucketRange() {</span>
<span class="line-added">232 		return new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);</span>
<span class="line-added">233 	}</span>
<span class="line-added">234 </span>
<span class="line-added">235 	private void doRenderChart(Graphics2D context, int axisHeight) {</span>
<span class="line-added">236 		rowColorCounter = 0;</span>
237 		context.setPaint(Color.LIGHT_GRAY);
238 		AWTChartToolkit.drawGrid(context, xTickRange, axisHeight, false);
239 		// Attempt to make graphs so low they cover the axis show by drawing the full axis first ...
240 		context.setPaint(Color.BLACK);
<span class="line-modified">241 		if (timelineCanvas != null) {</span>
<span class="line-added">242 			timelineCanvas.setXTickRange(xTickRange);</span>
<span class="line-added">243 		} else {</span>
<span class="line-added">244 			AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);</span>
<span class="line-added">245 		}</span>
246 		// ... then the graph ...
<span class="line-modified">247 		rendererResult = getRendererResult(context, axisHeight);</span>
248 		AffineTransform oldTransform = context.getTransform();
<span class="line-modified">249 </span>
250 		context.setTransform(oldTransform);
251 		if (!selectedRows.isEmpty()) {
<span class="line-modified">252 			renderSelectionChart(context, rendererResult);</span>
253 			context.setTransform(oldTransform);
254 		}
255 		// .. and finally a semitransparent axis line again.
256 		context.setPaint(new Color(0, 0, 0, 64));
257 		context.drawLine(0, axisHeight - 1, axisWidth - 1, axisHeight - 1);
258 		renderRangeIndication(context, axisHeight + 25);
259 	}
260 
<span class="line-modified">261 	private void doRenderText(Graphics2D context) {</span>
<span class="line-added">262 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">263 		rowColorCounter = -1;</span>
<span class="line-added">264 		renderText(context, rendererResult);</span>
<span class="line-added">265 		context.setTransform(oldTransform);</span>
<span class="line-added">266 	}</span>
<span class="line-added">267 </span>
<span class="line-added">268 	private void doRenderTextCanvasText(Graphics2D context, int height) {</span>
<span class="line-added">269 		if (rendererResult == null) {</span>
<span class="line-added">270 			rendererResult = getRendererResult(context, height - yOffset);</span>
<span class="line-added">271 		}</span>
<span class="line-added">272 		AffineTransform oldTransform = context.getTransform();</span>
<span class="line-added">273 		rowColorCounter = 0;</span>
<span class="line-added">274 		renderText(context, rendererResult);</span>
<span class="line-added">275 		context.setTransform(oldTransform);</span>
<span class="line-added">276 		if (!selectedRows.isEmpty()) {</span>
<span class="line-added">277 			renderSelectionText(context, rendererResult);</span>
<span class="line-added">278 			context.setTransform(oldTransform);</span>
<span class="line-added">279 		}</span>
<span class="line-added">280 	}</span>
<span class="line-added">281 </span>
<span class="line-added">282 	private void renderSelectionText(Graphics2D context, IRenderedRow row) {</span>
<span class="line-added">283 		if (selectedRows.contains(row.getPayload())) {</span>
<span class="line-added">284 			if (row.getHeight() != rendererResult.getHeight()) {</span>
<span class="line-added">285 				Color highlight = new Color(0, 206, 209, 20);</span>
<span class="line-added">286 				context.setColor(highlight);</span>
<span class="line-added">287 				context.fillRect(0, 0, axisWidth, row.getHeight());</span>
<span class="line-added">288 			} else {</span>
<span class="line-added">289 				selectedRows.clear();</span>
<span class="line-added">290 			}</span>
<span class="line-added">291 		} else {</span>
<span class="line-added">292 			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();</span>
<span class="line-added">293 			if (subdivision.isEmpty()) {</span>
<span class="line-added">294 				dimRect(context, 0, axisWidth, row.getHeight());</span>
<span class="line-added">295 			} else {</span>
<span class="line-added">296 				for (IRenderedRow nestedRow : row.getNestedRows()) {</span>
<span class="line-added">297 					renderSelectionText(context, nestedRow);</span>
<span class="line-added">298 				}</span>
<span class="line-added">299 				return;</span>
<span class="line-added">300 			}</span>
<span class="line-added">301 		}</span>
<span class="line-added">302 		context.translate(0, row.getHeight());</span>
<span class="line-added">303 	}</span>
<span class="line-added">304 </span>
<span class="line-added">305 	private void renderSelectionChart(Graphics2D context, IRenderedRow row) {</span>
306 		if (selectedRows.contains(row.getPayload())) {
307 			renderSelection(context, xBucketRange, row.getHeight());
308 		} else {
309 			List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
310 			if (subdivision.isEmpty()) {
311 				dimRect(context, 0, axisWidth, row.getHeight());
312 			} else {
313 				for (IRenderedRow nestedRow : row.getNestedRows()) {
<span class="line-modified">314 					renderSelectionChart(context, nestedRow);</span>
315 				}
316 				return;
317 			}
318 		}
319 		context.translate(0, row.getHeight());
320 	}
321 
<span class="line-added">322 	// Paint the background of every-other row in a slightly different shade</span>
<span class="line-added">323 	// to better differentiate the thread lanes from one another</span>
<span class="line-added">324 	private void paintRowBackground(Graphics2D context, int height) {</span>
<span class="line-added">325 		if (rowColorCounter &gt;= 0) {</span>
<span class="line-added">326 			if (rowColorCounter % 2 == 0) {</span>
<span class="line-added">327 				context.setColor(Palette.PF_BLACK_100.getAWTColor());</span>
<span class="line-added">328 			} else {</span>
<span class="line-added">329 				context.setColor(Palette.PF_BLACK_200.getAWTColor());</span>
<span class="line-added">330 			}</span>
<span class="line-added">331 			context.fillRect(0, 0, axisWidth, height);</span>
<span class="line-added">332 			rowColorCounter++;</span>
<span class="line-added">333 		}</span>
<span class="line-added">334 	}</span>
<span class="line-added">335 </span>
336 	private void renderText(Graphics2D context, IRenderedRow row) {
337 		String text = row.getName();
338 		int height = row.getHeight();
339 		if (height &gt;= context.getFontMetrics().getHeight()) {
340 			if (text != null) {
<span class="line-added">341 				paintRowBackground(context, row.getHeight());</span>
342 				context.setColor(Color.BLACK);
<span class="line-modified">343 				context.drawLine(0, height - 1, axisWidth - 15, height - 1);</span>
<span class="line-modified">344 				int y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();</span>






345 				int charsWidth = context.getFontMetrics().charsWidth(text.toCharArray(), 0, text.length());
<span class="line-modified">346 				if (charsWidth &gt; longestCharWidth) {</span>
<span class="line-added">347 					longestCharWidth = charsWidth;</span>
<span class="line-added">348 				}</span>
<span class="line-added">349 				if (xOffset &gt; 0 &amp;&amp; charsWidth &gt; xOffset) {</span>
350 					float fitRatio = ((float) xOffset) / (charsWidth
351 							+ context.getFontMetrics().charsWidth(ELLIPSIS.toCharArray(), 0, ELLIPSIS.length()));
352 					text = text.substring(0, ((int) (text.length() * fitRatio)) - 1) + ELLIPSIS;
353 				}
<span class="line-modified">354 				context.drawString(text, 2, y);</span>
355 			} else {
356 				List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
357 				if (!subdivision.isEmpty()) {
358 					for (IRenderedRow nestedRow : row.getNestedRows()) {
359 						renderText(context, nestedRow);
360 					}
361 					return;
362 				}
363 			}
364 		}
365 		context.translate(0, height);
366 	}
367 
<span class="line-added">368 	/**</span>
<span class="line-added">369 	 * Get the longest character width of a thread name to be rendered</span>
<span class="line-added">370 	 * </span>
<span class="line-added">371 	 * @return the character width of longest thread name</span>
<span class="line-added">372 	 */</span>
<span class="line-added">373 	public int getLongestCharWidth() {</span>
<span class="line-added">374 		return longestCharWidth;</span>
<span class="line-added">375 	}</span>
<span class="line-added">376 </span>
377 	/**
378 	 * Pan the view.
379 	 *
380 	 * @param rightPercent
381 	 * @return true if the bounds changed. That is, if a redraw is required.
382 	 */
383 	public boolean pan(int rightPercent) {
<span class="line-added">384 		if (rangeDuration != null) {</span>
<span class="line-added">385 			return panRange(Integer.signum(rightPercent));</span>
<span class="line-added">386 		}</span>
387 		if (xBucketRange != null) {
388 			IQuantity oldStart = currentStart;
389 			IQuantity oldEnd = currentEnd;
390 			if (rightPercent &gt; 0) {
391 				currentEnd = QuantitiesToolkit
392 						.min(xBucketRange.getQuantityAtPixel(axisWidth + axisWidth * rightPercent / 100), end);
393 				currentStart = QuantitiesToolkit
394 						.max(xBucketRange.getQuantityAtPixel(xBucketRange.getPixel(currentEnd) - axisWidth), start);
395 			} else if (rightPercent &lt; 0) {
396 				currentStart = QuantitiesToolkit.max(xBucketRange.getQuantityAtPixel(axisWidth * rightPercent / 100),
397 						start);
398 				currentEnd = QuantitiesToolkit
399 						.min(xBucketRange.getQuantityAtPixel(xBucketRange.getPixel(currentStart) + axisWidth), end);
400 			}
401 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
402 		}
403 		// Return true since a redraw forces creation of xBucketRange.
404 		return true;
405 	}
406 
<span class="line-added">407 	/**</span>
<span class="line-added">408 	 * Pan the view at a rate relative the current zoom level.</span>
<span class="line-added">409 	 * </span>
<span class="line-added">410 	 * @param panDirection</span>
<span class="line-added">411 	 *            -1 to pan left, 1 to pan right</span>
<span class="line-added">412 	 * @return true if the chart needs to be redrawn</span>
<span class="line-added">413 	 */</span>
<span class="line-added">414 	public boolean panRange(int panDirection) {</span>
<span class="line-added">415 		if (zoomSteps == 0 || panDirection == 0 || (currentStart.compareTo(start) == 0 &amp;&amp; panDirection == -1)</span>
<span class="line-added">416 				|| (currentEnd.compareTo(end) == 0 &amp;&amp; panDirection == 1)) {</span>
<span class="line-added">417 			return false;</span>
<span class="line-added">418 		}</span>
<span class="line-added">419 </span>
<span class="line-added">420 		IQuantity panDiff = rangeDuration.multiply(panDirection * zoomPanPower);</span>
<span class="line-added">421 		IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(panDiff);</span>
<span class="line-added">422 		IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(panDiff);</span>
<span class="line-added">423 </span>
<span class="line-added">424 		// if panning would flow over the recording range start or end time,</span>
<span class="line-added">425 		// calculate the difference and add it so the other side.</span>
<span class="line-added">426 		if (newStart.compareTo(start) &lt; 0) {</span>
<span class="line-added">427 			IQuantity diff = start.subtract(newStart);</span>
<span class="line-added">428 			newStart = start;</span>
<span class="line-added">429 			newEnd = newEnd.add(diff);</span>
<span class="line-added">430 		} else if (newEnd.compareTo(end) &gt; 0) {</span>
<span class="line-added">431 			IQuantity diff = newEnd.subtract(end);</span>
<span class="line-added">432 			newStart = newStart.add(diff);</span>
<span class="line-added">433 			newEnd = end;</span>
<span class="line-added">434 		}</span>
<span class="line-added">435 		currentStart = newStart;</span>
<span class="line-added">436 		currentEnd = newEnd;</span>
<span class="line-added">437 		filterBar.setStartTime(currentStart);</span>
<span class="line-added">438 		filterBar.setEndTime(currentEnd);</span>
<span class="line-added">439 		isZoomCalculated = true;</span>
<span class="line-added">440 		return true;</span>
<span class="line-added">441 	}</span>
<span class="line-added">442 </span>
443 	/**
444 	 * Zoom the view.
445 	 *
446 	 * @param zoomInSteps
447 	 * @return true if the bounds changed. That is, if a redraw is required.
448 	 */
449 	public boolean zoom(int zoomInSteps) {
<span class="line-added">450 		if (rangeDuration != null) {</span>
<span class="line-added">451 			return zoomRange(zoomInSteps);</span>
<span class="line-added">452 		}</span>
453 		return zoomXAxis(axisWidth / 2, zoomInSteps);
454 	}
455 
456 	/**
457 	 * Zoom the view.
458 	 *
459 	 * @param x
460 	 * @param zoomInSteps
461 	 * @return true if the bounds changed. That is, if a redraw is required.
462 	 */
463 	public boolean zoom(int x, int zoomInSteps) {
464 		return zoomXAxis(x - xOffset, zoomInSteps);
465 	}
466 
<span class="line-added">467 	// Default zoom mechanics</span>
468 	private boolean zoomXAxis(int x, int zoomInSteps) {
469 		if (xBucketRange == null) {
470 			// Return true since a redraw forces creation of xBucketRange.
471 			return true;
472 		}
473 		if ((x &gt; 0) &amp;&amp; (x &lt; axisWidth)) {
474 			IQuantity oldStart = currentStart;
475 			IQuantity oldEnd = currentEnd;
476 			// Absolute value of zoomFactor must be less than 1. Currently it ranges between -0.5 and 0.5.
477 			double zoomFactor = Math.atan(zoomInSteps) / Math.PI;
478 			int newStart = (int) (zoomFactor * x);
479 			int newEnd = (int) (axisWidth * (1 - zoomFactor)) + newStart;
480 			SubdividedQuantityRange xAxis = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 1);
481 			setVisibleRange(xAxis.getQuantityAtPixel(newStart), xAxis.getQuantityAtPixel(newEnd));
482 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
483 		}
484 		return false;
485 	}
486 
<span class="line-added">487 	/**</span>
<span class="line-added">488 	 * Zoom to a specific step count</span>
<span class="line-added">489 	 * </span>
<span class="line-added">490 	 * @param zoomToStep</span>
<span class="line-added">491 	 *            the desired end zoom step amount</span>
<span class="line-added">492 	 * @return true if a redraw is required as a result of a successful zoom</span>
<span class="line-added">493 	 */</span>
<span class="line-added">494 	public boolean zoomToStep(int zoomToStep) {</span>
<span class="line-added">495 		if (zoomToStep == 0) {</span>
<span class="line-added">496 			resetTimeline();</span>
<span class="line-added">497 			return true;</span>
<span class="line-added">498 		} else {</span>
<span class="line-added">499 			return zoomRange(zoomToStep - zoomSteps);</span>
<span class="line-added">500 		}</span>
<span class="line-added">501 	}</span>
<span class="line-added">502 </span>
<span class="line-added">503 	/**</span>
<span class="line-added">504 	 * Zoom based on a percentage of the recording range</span>
<span class="line-added">505 	 * </span>
<span class="line-added">506 	 * @param zoomInSteps</span>
<span class="line-added">507 	 *            the amount of desired steps to take</span>
<span class="line-added">508 	 * @return true if a redraw is required as a result of a successful zoom</span>
<span class="line-added">509 	 */</span>
<span class="line-added">510 	private boolean zoomRange(int steps) {</span>
<span class="line-added">511 		if (steps == 0) {</span>
<span class="line-added">512 			return false;</span>
<span class="line-added">513 		} else if (steps &gt; 0) {</span>
<span class="line-added">514 			zoomIn(steps);</span>
<span class="line-added">515 		} else {</span>
<span class="line-added">516 			zoomOut(steps);</span>
<span class="line-added">517 		}</span>
<span class="line-added">518 		// set displayBar text</span>
<span class="line-added">519 		displayBar.setZoomPercentageText(currentZoom);</span>
<span class="line-added">520 		return true;</span>
<span class="line-added">521 	}</span>
<span class="line-added">522 </span>
<span class="line-added">523 	/**</span>
<span class="line-added">524 	 * Zoom into the chart at a rate of 5% of the overall recording range at each step. If the chart</span>
<span class="line-added">525 	 * is zoomed in far enough such that one more step at 5% is not possible, the zoom power is</span>
<span class="line-added">526 	 * halved and the zoom will proceed. &lt;br&gt;</span>
<span class="line-added">527 	 * Every time the zoom power is halved, the instigating step value is pushed onto the</span>
<span class="line-added">528 	 * modifiedSteps stack. This stack is consulted on zoom out events in order to ensure the chart</span>
<span class="line-added">529 	 * zooms out the same way it was zoomed in.</span>
<span class="line-added">530 	 */</span>
<span class="line-added">531 	private void zoomIn(int steps) {</span>
<span class="line-added">532 		do {</span>
<span class="line-added">533 			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">534 			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">535 			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">536 			if (newStart.compareTo(newEnd) &gt;= 0) { // adjust the zoom factor</span>
<span class="line-added">537 				if (modifiedSteps == null) {</span>
<span class="line-added">538 					modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">539 				}</span>
<span class="line-added">540 				modifiedSteps.push(zoomSteps);</span>
<span class="line-added">541 				zoomPanPower = zoomPanPower / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">542 				zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">543 				newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">544 				newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">545 			}</span>
<span class="line-added">546 			currentZoom = currentZoom + (zoomPanPower * ZOOM_PAN_MODIFIER * 100);</span>
<span class="line-added">547 			isZoomCalculated = true;</span>
<span class="line-added">548 			zoomSteps++;</span>
<span class="line-added">549 			setVisibleRange(newStart, newEnd);</span>
<span class="line-added">550 			steps--;</span>
<span class="line-added">551 		} while (steps &gt; 0);</span>
<span class="line-added">552 	}</span>
<span class="line-added">553 </span>
<span class="line-added">554 	/**</span>
<span class="line-added">555 	 * Zoom out of the chart at a rate equal to the how the chart was zoomed in.</span>
<span class="line-added">556 	 */</span>
<span class="line-added">557 	private void zoomOut(int steps) {</span>
<span class="line-added">558 		do {</span>
<span class="line-added">559 			if (modifiedSteps != null &amp;&amp; modifiedSteps.size() &gt; 0 &amp;&amp; modifiedSteps.peek() == zoomSteps) {</span>
<span class="line-added">560 				modifiedSteps.pop();</span>
<span class="line-added">561 				zoomPanPower = zoomPanPower * ZOOM_PAN_MODIFIER;</span>
<span class="line-added">562 			}</span>
<span class="line-added">563 			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);</span>
<span class="line-added">564 			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);</span>
<span class="line-added">565 			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(zoomDiff);</span>
<span class="line-added">566 </span>
<span class="line-added">567 			// if zooming out would flow over the recording range start or end time,</span>
<span class="line-added">568 			// calculate the difference and add it to the other side.</span>
<span class="line-added">569 			if (newStart.compareTo(start) &lt; 0) {</span>
<span class="line-added">570 				IQuantity diff = start.subtract(newStart);</span>
<span class="line-added">571 				newStart = start;</span>
<span class="line-added">572 				newEnd = newEnd.add(diff);</span>
<span class="line-added">573 			} else if (newEnd.compareTo(end) &gt; 0) {</span>
<span class="line-added">574 				IQuantity diff = newEnd.subtract(end);</span>
<span class="line-added">575 				newStart = newStart.subtract(diff);</span>
<span class="line-added">576 				newEnd = end;</span>
<span class="line-added">577 			}</span>
<span class="line-added">578 			currentZoom = currentZoom - (zoomPanPower * ZOOM_PAN_MODIFIER * 100);</span>
<span class="line-added">579 			if (currentZoom &lt; BASE_ZOOM_LEVEL) {</span>
<span class="line-added">580 				currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">581 			}</span>
<span class="line-added">582 			isZoomCalculated = true;</span>
<span class="line-added">583 			zoomSteps--;</span>
<span class="line-added">584 			setVisibleRange(newStart, newEnd);</span>
<span class="line-added">585 			steps++;</span>
<span class="line-added">586 		} while (steps &lt; 0);</span>
<span class="line-added">587 	}</span>
<span class="line-added">588 </span>
<span class="line-added">589 	// need to check from ChartAndPopupTableUI if not using the OG start/end position,</span>
<span class="line-added">590 	// will have to calculate the new zoom level</span>
<span class="line-added">591 	public void resetZoomFactor() {</span>
<span class="line-added">592 		zoomSteps = 0;</span>
<span class="line-added">593 		zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">594 		currentZoom = BASE_ZOOM_LEVEL;</span>
<span class="line-added">595 		displayBar.setZoomPercentageText(currentZoom);</span>
<span class="line-added">596 		modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">597 	}</span>
<span class="line-added">598 </span>
<span class="line-added">599 	/**</span>
<span class="line-added">600 	 * Reset the visible range to be the recording range, and reset the zoom-related objects</span>
<span class="line-added">601 	 */</span>
<span class="line-added">602 	public void resetTimeline() {</span>
<span class="line-added">603 		resetZoomFactor();</span>
<span class="line-added">604 		setVisibleRange(start, end);</span>
<span class="line-added">605 	}</span>
<span class="line-added">606 </span>
<span class="line-added">607 	private void selectionZoom(IQuantity newStart, IQuantity newEnd) {</span>
<span class="line-added">608 		double percentage = calculateZoom(newStart, newEnd);</span>
<span class="line-added">609 		zoomSteps = calculateZoomSteps(percentage);</span>
<span class="line-added">610 		currentZoom = BASE_ZOOM_LEVEL + (percentage * 100);</span>
<span class="line-added">611 		displayBar.setScaleValue(zoomSteps);</span>
<span class="line-added">612 		displayBar.setZoomPercentageText(currentZoom);</span>
<span class="line-added">613 	}</span>
<span class="line-added">614 </span>
<span class="line-added">615 	/**</span>
<span class="line-added">616 	 * When a drag-select zoom occurs, use the new range value to determine how many steps have been</span>
<span class="line-added">617 	 * taken, and adjust zoomSteps and zoomPower accordingly</span>
<span class="line-added">618 	 */</span>
<span class="line-added">619 	private double calculateZoom(IQuantity newStart, IQuantity newEnd) {</span>
<span class="line-added">620 		// calculate the new visible range, and it&#39;s percentage of the total range</span>
<span class="line-added">621 		IQuantity newRange = newEnd.in(UnitLookup.EPOCH_NS).subtract(newStart.in(UnitLookup.EPOCH_NS));</span>
<span class="line-added">622 		return 1 - (newRange.longValue() / (double) rangeDuration.in(UnitLookup.NANOSECOND).longValue());</span>
<span class="line-added">623 	}</span>
<span class="line-added">624 </span>
<span class="line-added">625 	/**</span>
<span class="line-added">626 	 * Calculate the number of steps required to achieve the passed zoom percentage</span>
<span class="line-added">627 	 */</span>
<span class="line-added">628 	private int calculateZoomSteps(double percentage) {</span>
<span class="line-added">629 		int steps = (int) Math.floor(percentage / ZOOM_PAN_FACTOR);</span>
<span class="line-added">630 		double tempPercent = steps * ZOOM_PAN_FACTOR;</span>
<span class="line-added">631 </span>
<span class="line-added">632 		if (tempPercent &lt; percentage) {</span>
<span class="line-added">633 			if (percentage &gt; 1 - ZOOM_PAN_FACTOR) {</span>
<span class="line-added">634 				double factor = ZOOM_PAN_FACTOR;</span>
<span class="line-added">635 				do {</span>
<span class="line-added">636 					factor = factor / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">637 					tempPercent = tempPercent + factor;</span>
<span class="line-added">638 					if (modifiedSteps == null) {</span>
<span class="line-added">639 						modifiedSteps = new Stack&lt;Integer&gt;();</span>
<span class="line-added">640 					}</span>
<span class="line-added">641 					if (modifiedSteps.size() == 0 || modifiedSteps.peek() &lt; steps) {</span>
<span class="line-added">642 						modifiedSteps.push(steps);</span>
<span class="line-added">643 					}</span>
<span class="line-added">644 					steps++;</span>
<span class="line-added">645 				} while (tempPercent &lt;= percentage);</span>
<span class="line-added">646 				zoomPanPower = factor / ZOOM_PAN_MODIFIER;</span>
<span class="line-added">647 			} else {</span>
<span class="line-added">648 				steps++;</span>
<span class="line-added">649 			}</span>
<span class="line-added">650 		}</span>
<span class="line-added">651 		return steps;</span>
<span class="line-added">652 	}</span>
<span class="line-added">653 </span>
<span class="line-added">654 	private boolean isZoomCalculated;</span>
<span class="line-added">655 	private boolean isZoomPanDrag;</span>
<span class="line-added">656 </span>
<span class="line-added">657 	public void setIsZoomPanDrag(boolean isZoomPanDrag) {</span>
<span class="line-added">658 		this.isZoomPanDrag = isZoomPanDrag;</span>
<span class="line-added">659 	}</span>
<span class="line-added">660 </span>
<span class="line-added">661 	private boolean getIsZoomPanDrag() {</span>
<span class="line-added">662 		return isZoomPanDrag;</span>
<span class="line-added">663 	}</span>
<span class="line-added">664 </span>
665 	public void setVisibleRange(IQuantity rangeStart, IQuantity rangeEnd) {
<span class="line-added">666 		if (rangeDuration != null &amp;&amp; !isZoomCalculated &amp;&amp; !getIsZoomPanDrag()) {</span>
<span class="line-added">667 			selectionZoom(rangeStart, rangeEnd);</span>
<span class="line-added">668 		}</span>
<span class="line-added">669 		isZoomCalculated = false;</span>
670 		rangeStart = QuantitiesToolkit.max(rangeStart, start);
671 		rangeEnd = QuantitiesToolkit.min(rangeEnd, end);
672 		if (rangeStart.compareTo(rangeEnd) &lt; 0) {
673 			SubdividedQuantityRange testRange = new SubdividedQuantityRange(rangeStart, rangeEnd, 10000, 1);
674 			if (testRange.getQuantityAtPixel(0).compareTo(testRange.getQuantityAtPixel(1)) &lt; 0) {
675 				currentStart = rangeStart;
676 				currentEnd = rangeEnd;
677 			} else {
678 				// Ensures that zoom out is always allowed
679 				currentStart = QuantitiesToolkit.min(rangeStart, currentStart);
680 				currentEnd = QuantitiesToolkit.max(rangeEnd, currentEnd);
681 			}
<span class="line-added">682 			if (filterBar != null) {</span>
<span class="line-added">683 				filterBar.setStartTime(currentStart);</span>
<span class="line-added">684 				filterBar.setEndTime(currentEnd);</span>
<span class="line-added">685 			}</span>
686 			rangeListeners.stream().forEach(l -&gt; l.accept(getVisibleRange()));
687 		}
688 	}
689 
690 	private List&lt;Consumer&lt;IRange&lt;IQuantity&gt;&gt;&gt; rangeListeners = new ArrayList&lt;&gt;();
691 
692 	public void addVisibleRangeListener(Consumer&lt;IRange&lt;IQuantity&gt;&gt; rangeListener) {
693 		rangeListeners.add(rangeListener);
694 	}
695 
696 	public IRange&lt;IQuantity&gt; getVisibleRange() {
697 		return (currentStart != null) &amp;&amp; (currentEnd != null) ? QuantityRange.createWithEnd(currentStart, currentEnd)
698 				: null;
699 	}
700 
701 	public void clearVisibleRange() {
702 		currentStart = start;
703 		currentEnd = end;
704 	}
705 
<span class="line-modified">706 	public boolean select(int x1, int x2, int y1, int y2, boolean clear) {</span>
<span class="line-modified">707 		int xStart = Math.min(x1, x2);</span>
<span class="line-modified">708 		int xEnd = Math.max(x1, x2);</span>
709 
<span class="line-modified">710 		if (xBucketRange != null &amp;&amp; (xEnd != xStart) &amp;&amp; xEnd - xOffset &gt;= 0) {</span>
<span class="line-modified">711 			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart - xOffset)),</span>
<span class="line-modified">712 					xBucketRange.getQuantityAtPixel(xEnd - xOffset), y1, y2, clear);</span>
713 		} else {
<span class="line-modified">714 			return select(null, null, y1, y2, clear);</span>
715 		}
716 	}
717 
<span class="line-modified">718 	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2, boolean clear) {</span>
719 		if (xStart != null &amp;&amp; xStart.compareTo(start) &lt; 0) {
720 			xStart = start;
721 		}
722 		if (xEnd != null &amp;&amp; xEnd.compareTo(end) &gt; 0) {
723 			xEnd = end;
724 		}
725 		Set&lt;Object&gt; oldRows = null;
726 		if (QuantitiesToolkit.same(selectionStart, xStart) &amp;&amp; QuantitiesToolkit.same(selectionEnd, xEnd)) {
727 			oldRows = new HashSet&lt;&gt;(selectedRows);
728 		}
<span class="line-modified">729 		if (clear) {</span>
<span class="line-added">730 			selectedRows.clear();</span>
<span class="line-added">731 		}</span>
732 		addSelectedRows(rendererResult, 0, Math.min(y1, y2), Math.max(y1, y2));
733 		selectionStart = xStart;
734 		selectionEnd = xEnd;
735 		return (oldRows == null) || !oldRows.equals(selectedRows);
736 	}
737 
738 	public boolean clearSelection() {
739 		if ((selectionStart == null) &amp;&amp; (selectionEnd == null) &amp;&amp; selectedRows.isEmpty()) {
740 			return false;
741 		}
742 		selectedRows.clear();
743 		selectionStart = selectionEnd = null;
744 		return true;
745 	}
746 
747 	private boolean addSelectedRows(IRenderedRow row, int yRowStart, int ySelectionStart, int ySelectionEnd) {
748 		List&lt;IRenderedRow&gt; subdivision = row.getNestedRows();
749 		if (subdivision.isEmpty()) {
750 			return addPayload(row);
751 		} else {
752 			boolean nestedHasPayload = false;
753 			for (IRenderedRow nestedRow : row.getNestedRows()) {
754 				int yRowEnd = yRowStart + nestedRow.getHeight();
755 				if (yRowStart &gt; ySelectionEnd) {
756 					break;
757 				} else if (yRowEnd &gt; ySelectionStart) {
758 					nestedHasPayload |= addSelectedRows(nestedRow, yRowStart, ySelectionStart, ySelectionEnd);
759 				}
760 				yRowStart = yRowEnd;
761 			}
762 			return nestedHasPayload || addPayload(row);
763 		}
764 	}
765 
766 	private boolean addPayload(IRenderedRow row) {
767 		Object payload = row.getPayload();
768 		if (payload != null) {
<span class="line-modified">769 			if (selectedRows.contains(payload)) { // ctrl+click deselection</span>
<span class="line-added">770 				selectedRows.remove(payload);</span>
<span class="line-added">771 			} else {</span>
<span class="line-added">772 				selectedRows.add(payload);</span>
<span class="line-added">773 			}</span>
774 			return true;
775 		}
776 		return false;
777 	}
778 
779 	private void renderSelection(Graphics2D context, SubdividedQuantityRange xRange, int height) {
780 		int selFrom = 0;
781 		int selTo = axisWidth;
782 		if (selectionStart != null &amp;&amp; selectionEnd != null) {
783 			selFrom = (int) xRange.getPixel(selectionStart);
784 			// Removed &quot;+ 1&quot; for now to make the selection symmetrical with respect to chart highlights.
785 			selTo = (int) xRange.getPixel(selectionEnd);
786 		}
787 		// FIXME: Would like to show selection by graying out the other parts, can we do that?
788 //		if (selWidth &gt; 0) {
789 //			context.setColor(Color.WHITE);
790 //			context.setXORMode(Color.BLACK);
791 //			Stroke oldStroke = context.getStroke();
792 //			context.setStroke(SELECTION_STROKE);
793 //			context.drawRect(selFrom, 0, selWidth, height);
</pre>
</td>
</tr>
</table>
<center><a href="AWTChartToolkit.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../misc/ChartCanvas.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
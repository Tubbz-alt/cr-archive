<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * 
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * The contents of this file are subject to the terms of either the Universal Permissive License
   7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
   8  *
   9  * or the following license:
  10  *
  11  * Redistribution and use in source and binary forms, with or without modification, are permitted
  12  * provided that the following conditions are met:
  13  * 
  14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
  15  * and the following disclaimer.
  16  * 
  17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
  18  * conditions and the following disclaimer in the documentation and/or other materials provided with
  19  * the distribution.
  20  * 
  21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
  22  * endorse or promote products derived from this software without specific prior written permission.
  23  * 
  24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
  25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
  27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32  */
  33 package org.openjdk.jmc.flightrecorder.ui.common;
  34 
  35 import java.awt.Color;
  36 import java.io.FileInputStream;
  37 import java.io.InputStream;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Collection;
  41 import java.util.Collections;
  42 import java.util.Comparator;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.Objects;
  49 import java.util.Optional;
  50 import java.util.Set;
  51 import java.util.function.Consumer;
  52 import java.util.function.Predicate;
  53 import java.util.function.Supplier;
  54 import java.util.regex.Matcher;
  55 import java.util.regex.Pattern;
  56 import java.util.stream.Collectors;
  57 import java.util.stream.Stream;
  58 
  59 import org.eclipse.core.runtime.IAdaptable;
  60 import org.eclipse.jface.action.Action;
  61 import org.eclipse.jface.action.IAction;
  62 import org.eclipse.jface.action.IMenuListener;
  63 import org.eclipse.jface.action.IMenuManager;
  64 import org.eclipse.jface.action.MenuManager;
  65 import org.eclipse.jface.action.Separator;
  66 import org.eclipse.jface.dialogs.InputDialog;
  67 import org.eclipse.jface.resource.ImageDescriptor;
  68 import org.eclipse.jface.resource.JFaceResources;
  69 import org.eclipse.jface.viewers.ColumnViewer;
  70 import org.eclipse.jface.viewers.IBaseLabelProvider;
  71 import org.eclipse.jface.viewers.StyledCellLabelProvider;
  72 import org.eclipse.jface.viewers.ViewerCell;
  73 import org.eclipse.jface.window.ToolTip;
  74 import org.eclipse.jface.window.Window;
  75 import org.eclipse.jface.wizard.Wizard;
  76 import org.eclipse.jface.wizard.WizardDialog;
  77 import org.eclipse.jface.wizard.WizardPage;
  78 import org.eclipse.swt.SWT;
  79 import org.eclipse.swt.custom.CTabFolder;
  80 import org.eclipse.swt.custom.CTabItem;
  81 import org.eclipse.swt.events.SelectionAdapter;
  82 import org.eclipse.swt.events.SelectionEvent;
  83 import org.eclipse.swt.graphics.GC;
  84 import org.eclipse.swt.graphics.Image;
  85 import org.eclipse.swt.graphics.ImageData;
  86 import org.eclipse.swt.layout.FillLayout;
  87 import org.eclipse.swt.layout.GridData;
  88 import org.eclipse.swt.layout.GridLayout;
  89 import org.eclipse.swt.widgets.Button;
  90 import org.eclipse.swt.widgets.Composite;
  91 import org.eclipse.swt.widgets.Control;
  92 import org.eclipse.swt.widgets.Display;
  93 import org.eclipse.swt.widgets.Event;
  94 import org.eclipse.swt.widgets.FileDialog;
  95 import org.eclipse.swt.widgets.Label;
  96 import org.eclipse.ui.forms.widgets.Form;
  97 import org.eclipse.ui.forms.widgets.FormText;
  98 import org.eclipse.ui.forms.widgets.FormToolkit;
  99 import org.openjdk.jmc.common.item.IAggregator;
 100 import org.openjdk.jmc.common.item.IAttribute;
 101 import org.openjdk.jmc.common.item.ICanonicalAccessorFactory;
 102 import org.openjdk.jmc.common.item.IItem;
 103 import org.openjdk.jmc.common.item.IItemCollection;
 104 import org.openjdk.jmc.common.item.IItemFilter;
 105 import org.openjdk.jmc.common.item.IItemIterable;
 106 import org.openjdk.jmc.common.item.IItemQuery;
 107 import org.openjdk.jmc.common.item.IMemberAccessor;
 108 import org.openjdk.jmc.common.item.IType;
 109 import org.openjdk.jmc.common.item.ItemFilters;
 110 import org.openjdk.jmc.common.item.ItemToolkit;
 111 import org.openjdk.jmc.common.unit.IQuantity;
 112 import org.openjdk.jmc.common.unit.IRange;
 113 import org.openjdk.jmc.common.unit.KindOfQuantity;
 114 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 115 import org.openjdk.jmc.common.unit.QuantityRange;
 116 import org.openjdk.jmc.common.unit.RangeContentType;
 117 import org.openjdk.jmc.common.unit.UnitLookup;
 118 import org.openjdk.jmc.common.util.ColorToolkit;
 119 import org.openjdk.jmc.common.util.CompositeKey;
 120 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 121 import org.openjdk.jmc.flightrecorder.jdk.JdkAggregators;
 122 import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;
 123 import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;
 124 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
 125 import org.openjdk.jmc.flightrecorder.rules.Result;
 126 import org.openjdk.jmc.flightrecorder.rules.Severity;
 127 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
 128 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
 129 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
 130 import org.openjdk.jmc.flightrecorder.ui.ItemIterableToolkit;
 131 import org.openjdk.jmc.flightrecorder.ui.PageManager;
 132 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.CompositeKeyHistogramBuilder;
 133 import org.openjdk.jmc.flightrecorder.ui.common.ItemList.ItemListBuilder;
 134 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
 135 import org.openjdk.jmc.flightrecorder.ui.overview.ResultOverview;
 136 import org.openjdk.jmc.flightrecorder.ui.pages.itemhandler.ItemHandlerPage;
 137 import org.openjdk.jmc.flightrecorder.ui.pages.itemhandler.ItemHandlerPage.ItemHandlerUiStandIn;
 138 import org.openjdk.jmc.flightrecorder.ui.selection.IFilterFlavor;
 139 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore.SelectionStoreEntry;
 140 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
 141 import org.openjdk.jmc.ui.charts.AWTChartToolkit.IColorProvider;
 142 import org.openjdk.jmc.ui.charts.ChartFilterControlBar;
 143 import org.openjdk.jmc.ui.charts.IQuantitySeries;
 144 import org.openjdk.jmc.ui.charts.ISpanSeries;
 145 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 146 import org.openjdk.jmc.ui.charts.QuantitySeries;
 147 import org.openjdk.jmc.ui.charts.RendererToolkit;
 148 import org.openjdk.jmc.ui.charts.SpanRenderer;
 149 import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
 150 import org.openjdk.jmc.ui.charts.XYChart;
 151 import org.openjdk.jmc.ui.charts.XYDataRenderer;
 152 import org.openjdk.jmc.ui.charts.XYQuantities;
 153 import org.openjdk.jmc.ui.column.ColumnMenusFactory;
 154 import org.openjdk.jmc.ui.column.TableSettings;
 155 import org.openjdk.jmc.ui.column.TableSettings.ColumnSettings;
 156 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 157 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 158 import org.openjdk.jmc.ui.misc.ChartCanvas;
 159 import org.openjdk.jmc.ui.misc.ChartTextCanvas;
 160 import org.openjdk.jmc.ui.misc.CompositeToolkit;
 161 import org.openjdk.jmc.ui.misc.DisplayToolkit;
 162 import org.openjdk.jmc.ui.misc.FilterEditor;
 163 import org.openjdk.jmc.ui.misc.FilterEditor.AttributeValueProvider;
 164 import org.openjdk.jmc.ui.misc.OverlayImageDescriptor;
 165 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
 166 
 167 public class DataPageToolkit {
 168 
 169 	public static final IColorProvider&lt;IItem&gt; ITEM_COLOR = item -&gt; TypeLabelProvider
 170 			.getColorOrDefault(item.getType().getIdentifier());
 171 
 172 	public static final IColorProvider&lt;IItem&gt; getAttributeValueColor(final IAttribute&lt;?&gt; attribute) {
 173 		return new IColorProvider&lt;IItem&gt;() {
 174 
 175 			@Override
 176 			public Color getColor(IItem item) {
 177 				IMemberAccessor&lt;?, IItem&gt; accessor = attribute.getAccessor(ItemToolkit.getItemType(item));
 178 				Object attributeValue = accessor != null ? accessor.getMember(item) : null;
 179 				// FIXME: Should we include the type or not?
 180 				return attributeValue != null
 181 						? TypeLabelProvider.getColorOrDefault(attribute.getIdentifier() + &quot;=&quot; + attributeValue + &quot;(&quot; //$NON-NLS-1$ //$NON-NLS-2$
 182 								+ item.getType().getIdentifier() + &quot;)&quot;) //$NON-NLS-1$
 183 						: ITEM_COLOR.getColor(item);
 184 			}
 185 		};
 186 	}
 187 
 188 	private static final Map&lt;String, Color&gt; FIELD_COLOR_MAP = new HashMap&lt;&gt;();
 189 	private static final Map&lt;String, Integer&gt; DEFAULT_COLUMNS_ORDER;
 190 
 191 	static {
 192 
 193 		// FIXME: Create FieldAppearance class, similar to TypeAppearence?
 194 		FIELD_COLOR_MAP.put(JdkAttributes.MACHINE_TOTAL.getIdentifier(), new Color(255, 128, 0));
 195 		FIELD_COLOR_MAP.put(JdkAttributes.JVM_SYSTEM.getIdentifier(), new Color(128, 128, 128));
 196 		FIELD_COLOR_MAP.put(JdkAttributes.JVM_USER.getIdentifier(), new Color(0, 0, 255));
 197 		FIELD_COLOR_MAP.put(JdkAttributes.JVM_TOTAL.getIdentifier(), new Color(64, 64, 191));
 198 
 199 		// FIXME: Handle ColorProvider and combined events
 200 		Map&lt;String, Integer&gt; columnsOrderMap = new HashMap&lt;&gt;();
 201 		columnsOrderMap.put(createColumnId(JfrAttributes.START_TIME), 1);
 202 		columnsOrderMap.put(createColumnId(JfrAttributes.DURATION), 2);
 203 		columnsOrderMap.put(createColumnId(JfrAttributes.END_TIME), 3);
 204 		columnsOrderMap.put(createColumnId(JfrAttributes.EVENT_THREAD), 4);
 205 		DEFAULT_COLUMNS_ORDER = Collections.unmodifiableMap(columnsOrderMap);
 206 	}
 207 
 208 	public static final Color ALLOCATION_COLOR = new Color(64, 144, 230);
 209 
 210 	public static final String FORM_TOOLBAR_PAGE_RESULTS = &quot;pageResults&quot;; //$NON-NLS-1$
 211 	public static final String FORM_TOOLBAR_PAGE_SETUP = &quot;pageSetup&quot;; //$NON-NLS-1$
 212 	public static final String FORM_TOOLBAR_PAGE_NAV = &quot;pageNav&quot;; //$NON-NLS-1$
 213 
 214 	public static final String RESULT_ACTION_ID = &quot;resultAction&quot;; //$NON-NLS-1$
 215 
 216 	public static Color getFieldColor(String fieldId) {
 217 		return FIELD_COLOR_MAP.getOrDefault(fieldId, ColorToolkit.getDistinguishableColor(fieldId));
 218 	}
 219 
 220 	public static Color getFieldColor(IAttribute&lt;?&gt; attribute) {
 221 		return getFieldColor(attribute.getIdentifier());
 222 	}
 223 
 224 	public static TableSettings createTableSettingsByOrderByAndColumnsWithDefaultOrdering(
 225 		final String orderBy, final Collection&lt;ColumnSettings&gt; columns) {
 226 		final Stream&lt;ColumnSettings&gt; defaultOrderColumns = columns.stream()
 227 				.filter(c -&gt; DEFAULT_COLUMNS_ORDER.containsKey(c.getId())).filter(c -&gt; !c.isHidden())
 228 				.sorted((c1, c2) -&gt; Integer.compare(DEFAULT_COLUMNS_ORDER.get(c1.getId()),
 229 						DEFAULT_COLUMNS_ORDER.get(c2.getId())));
 230 		final Stream&lt;ColumnSettings&gt; naturalOrderColumns = columns.stream()
 231 				.filter(c -&gt; !DEFAULT_COLUMNS_ORDER.containsKey(c.getId()))
 232 				.sorted((c1, c2) -&gt; String.CASE_INSENSITIVE_ORDER.compare(c1.getId(), c2.getId()));
 233 		final List&lt;ColumnSettings&gt; resultColumns = Stream.concat(defaultOrderColumns, naturalOrderColumns)
 234 				.collect(Collectors.toList());
 235 		return new TableSettings(orderBy, resultColumns);
 236 	}
 237 
 238 	public static TableSettings createTableSettingsByAllAndVisibleColumns(
 239 		final Collection&lt;String&gt; allColumns, final Collection&lt;String&gt; visibleColumns) {
 240 		final List&lt;ColumnSettings&gt; defaultListCols = new ArrayList&lt;&gt;();
 241 		for (String columnId : allColumns) {
 242 			defaultListCols.add(new ColumnSettings(columnId, !visibleColumns.contains(columnId), null, null));
 243 		}
 244 		return createTableSettingsByOrderByAndColumnsWithDefaultOrdering(null, defaultListCols);
 245 	}
 246 
 247 	private static String createColumnId(IAttribute&lt;?&gt; attr) {
 248 		return new StringBuilder().append(attr.getIdentifier()).append(&quot;:&quot;) //$NON-NLS-1$
 249 				.append(attr.getContentType().getIdentifier()).toString();
 250 	}
 251 
 252 	public static IAction createAttributeCheckAction(IAttribute&lt;?&gt; attribute, Consumer&lt;Boolean&gt; onChange) {
 253 		return createCheckAction(attribute.getName(), attribute.getDescription(), attribute.getIdentifier(),
 254 				getFieldColor(attribute), onChange);
 255 	}
 256 
 257 	public static IAction createTypeCheckAction(
 258 		String actionId, String typeId, String name, String description, Consumer&lt;Boolean&gt; onChange) {
 259 		return createCheckAction(name, description, actionId, TypeLabelProvider.getColorOrDefault(typeId), onChange);
 260 	}
 261 
 262 	public static IAction createAggregatorCheckAction(
 263 		IAggregator&lt;?, ?&gt; aggregator, String id, Color color, Consumer&lt;Boolean&gt; onChange) {
 264 		return createCheckAction(aggregator.getName(), aggregator.getDescription(), id, color, onChange);
 265 	}
 266 
 267 	public static IAction createCheckAction(
 268 		String name, String description, String id, Color color, Consumer&lt;Boolean&gt; onChange) {
 269 		return createCheckAction(name, description, id,
 270 				SWTColorToolkit.getColorThumbnailDescriptor(SWTColorToolkit.asRGB(color)), onChange);
 271 	}
 272 
 273 	public static IAction createCheckAction(
 274 		String name, String description, String id, ImageDescriptor icon, Consumer&lt;Boolean&gt; onChange) {
 275 		return ActionToolkit.checkAction(onChange, name, description, icon, id);
 276 	}
 277 
 278 	public static Optional&lt;IXDataRenderer&gt; buildLinesRow(
 279 		String title, String description, IItemCollection items, boolean fill, IItemQuery query,
 280 		Predicate&lt;IAttribute&lt;IQuantity&gt;&gt; attributeFilter, IQuantity includeLow, IQuantity includeHigh) {
 281 		XYDataRenderer renderer = includeHigh != null
 282 				? new XYDataRenderer(includeLow, includeHigh, true, title, description)
 283 				: new XYDataRenderer(includeLow, title, description);
 284 		IItemCollection filteredItemsSupplier = items.apply(query.getFilter());
 285 		Stream&lt;IAttribute&lt;IQuantity&gt;&gt; attributes = getQuantityAttributes(query);
 286 		if (attributeFilter != null) {
 287 			attributes = attributes.filter(attributeFilter);
 288 		}
 289 		if (DataPageToolkit.addEndTimeLines(renderer, filteredItemsSupplier, fill, attributes)) {
 290 			return Optional.of(new ItemRow(title, description, renderer, filteredItemsSupplier));
 291 		}
 292 		return Optional.empty();
 293 	}
 294 
 295 	/**
 296 	 * @param q
 297 	 *            A query containing only {@code IAttribute&lt;IQuantity&gt;} attributes. Queries
 298 	 *            containing non-quantity attributes are not supported and may cause
 299 	 *            ClassCastExceptions later when the attributes are used.
 300 	 * @return a stream of the query attributes
 301 	 */
 302 	/*
 303 	 * FIXME: JMC-5125 - This cast chain is scary and should be reworked.
 304 	 * 
 305 	 * If the query contains any non-quantity attributes then there will be a ClassCastException
 306 	 * later when the attributes are used to extract values.
 307 	 */
 308 	@SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 309 	public static Stream&lt;IAttribute&lt;IQuantity&gt;&gt; getQuantityAttributes(IItemQuery q) {
 310 		return (Stream) q.getAttributes().stream();
 311 	}
 312 
 313 	public static void setChart(ChartCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener) {
 314 		setChart(canvas, chart, selectionListener, null);
 315 	}
 316 
 317 	public static void setChart(ChartTextCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener) {
 318 		setChart(canvas, chart, selectionListener, null);
 319 	}
 320 
 321 	public static void setChart(
 322 		ChartCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener,
 323 		Consumer&lt;IRange&lt;IQuantity&gt;&gt; selectRangeConsumer) {
 324 		IMenuManager contextMenu = canvas.getContextMenu();
 325 		contextMenu.removeAll();
 326 		canvas.getContextMenu().add(new Action(Messages.CHART_ZOOM_TO_SELECTED_RANGE) {
 327 			@Override
 328 			public void run() {
 329 				IQuantity selectionStart = chart.getSelectionStart();
 330 				IQuantity selectionEnd = chart.getSelectionEnd();
 331 				if (selectionStart == null || selectionEnd == null) {
 332 					chart.clearVisibleRange();
 333 				} else {
 334 					chart.setVisibleRange(selectionStart, selectionEnd);
 335 				}
 336 				canvas.redrawChart();
 337 			}
 338 		});
 339 
 340 		canvas.setSelectionListener(() -&gt; {
 341 			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));
 342 			IQuantity start = chart.getSelectionStart();
 343 			IQuantity end = chart.getSelectionEnd();
 344 			if (selectRangeConsumer != null) {
 345 				selectRangeConsumer
 346 						.accept(start != null &amp;&amp; end != null ? QuantityRange.createWithEnd(start, end) : null);
 347 			}
 348 		});
 349 		canvas.setChart(chart);
 350 	}
 351 
 352 	public static void setChart(
 353 		ChartTextCanvas canvas, XYChart chart, Consumer&lt;IItemCollection&gt; selectionListener,
 354 		Consumer&lt;IRange&lt;IQuantity&gt;&gt; selectRangeConsumer) {
 355 		IMenuManager contextMenu = canvas.getContextMenu();
 356 		contextMenu.removeAll();
 357 		canvas.getContextMenu().add(new Action(Messages.CHART_ZOOM_TO_SELECTED_RANGE) {
 358 			@Override
 359 			public void run() {
 360 				IQuantity selectionStart = chart.getSelectionStart();
 361 				IQuantity selectionEnd = chart.getSelectionEnd();
 362 				if (selectionStart == null || selectionEnd == null) {
 363 					chart.clearVisibleRange();
 364 				} else {
 365 					chart.setVisibleRange(selectionStart, selectionEnd);
 366 				}
 367 				canvas.redrawChartText();
 368 			}
 369 		});
 370 
 371 		canvas.setSelectionListener(() -&gt; {
 372 			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));
 373 			IQuantity start = chart.getSelectionStart();
 374 			IQuantity end = chart.getSelectionEnd();
 375 			if (selectRangeConsumer != null) {
 376 				selectRangeConsumer
 377 						.accept(start != null &amp;&amp; end != null ? QuantityRange.createWithEnd(start, end) : null);
 378 			}
 379 		});
 380 		canvas.setChart(chart);
 381 	}
 382 
 383 	public static void setChart(
 384 		ChartCanvas canvas, XYChart chart, IAttribute&lt;IQuantity&gt; selectionAttribute,
 385 		Consumer&lt;IItemCollection&gt; selectionListener) {
 386 		IMenuManager contextMenu = canvas.getContextMenu();
 387 		contextMenu.removeAll();
 388 		canvas.setSelectionListener(() -&gt; selectionListener.accept(ItemRow.getSelection(chart, selectionAttribute)));
 389 		canvas.setChart(chart);
 390 	}
 391 
 392 	/**
 393 	 * Only works for items that are either fully overlapping, or disjunct. Must be ensured by
 394 	 * client code.
 395 	 */
 396 	private static class RangePayload implements IAdaptable {
 397 		IItem item;
 398 		IQuantity start;
 399 		IQuantity end;
 400 		double rangeInPixels;
 401 
 402 		RangePayload(IItem item, IQuantity start, IQuantity end, double rangeInPixels) {
 403 			this.item = item;
 404 			this.start = start;
 405 			this.end = end;
 406 			this.rangeInPixels = rangeInPixels;
 407 		}
 408 
 409 		void combineWith(IItem item, IQuantity start, IQuantity end, double rangeInPixels) {
 410 			if (this.start.compareTo(start) &lt; 0) {
 411 				// Will choose the item that starts last
 412 				this.start = start;
 413 				this.end = end;
 414 				this.item = item;
 415 				extendRangeInPixels(this.end.compareTo(start) &gt; 0, rangeInPixels);
 416 			} else {
 417 				extendRangeInPixels(end.compareTo(this.start) &gt; 0, rangeInPixels);
 418 			}
 419 		}
 420 
 421 		void extendRangeInPixels(boolean overlapping, double rangeInPixels) {
 422 			this.rangeInPixels = overlapping ? Math.max(this.rangeInPixels, rangeInPixels)
 423 					: this.rangeInPixels + rangeInPixels;
 424 		}
 425 
 426 		@Override
 427 		public &lt;T&gt; T getAdapter(Class&lt;T&gt; adapter) {
 428 			return IItem.class.isAssignableFrom(adapter) ? adapter.cast(item) : null;
 429 		}
 430 	}
 431 
 432 	private static ISpanSeries&lt;RangePayload&gt; rangeSeries(
 433 		IItemCollection events, IAttribute&lt;IQuantity&gt; startAttribute, IAttribute&lt;IQuantity&gt; endAttribute) {
 434 		return new ISpanSeries&lt;RangePayload&gt;() {
 435 			@Override
 436 			public XYQuantities&lt;RangePayload[]&gt; getQuantities(SubdividedQuantityRange xBucketRange) {
 437 				SubdividedQuantityRange xRange = xBucketRange.copyWithPixelSubdividers();
 438 				List&lt;RangePayload&gt; spanningPixels = new ArrayList&lt;&gt;();
 439 				RangePayload[] pixelBuckets = new RangePayload[xRange.getNumSubdividers()];
 440 				events.forEach(is -&gt; {
 441 					IMemberAccessor&lt;IQuantity, IItem&gt; startAccessor = startAttribute.getAccessor(is.getType());
 442 					IMemberAccessor&lt;IQuantity, IItem&gt; endAccessor = endAttribute.getAccessor(is.getType());
 443 					is.forEach(item -&gt; {
 444 						IQuantity start = startAccessor.getMember(item);
 445 						IQuantity end = endAccessor.getMember(item);
 446 						int xPos = xRange.getFloorSubdivider(start);
 447 						int endPos = xRange.getFloorSubdivider(end);
 448 						if (xPos &lt; pixelBuckets.length &amp;&amp; endPos &gt;= 0) {
 449 							// FIXME: If we have very short events (nanosecond scale) we can sometimes get a negative range.
 450 							double rangeInPixels = xRange.getPixel(end) - xRange.getPixel(start);
 451 							if (xPos != endPos) {
 452 								spanningPixels.add(new RangePayload(item, start, end, rangeInPixels));
 453 							} else if (pixelBuckets[xPos] == null) {
 454 								pixelBuckets[xPos] = new RangePayload(item, start, end, rangeInPixels);
 455 							} else {
 456 								pixelBuckets[xPos].combineWith(item, start, end, rangeInPixels);
 457 							}
 458 						}
 459 					});
 460 				});
 461 				RangePayload[] sorted = Stream
 462 						.concat(Stream.of(pixelBuckets).filter(Objects::nonNull), spanningPixels.stream())
 463 						.sorted(Comparator.comparing(r -&gt; r.start)).toArray(RangePayload[]::new);
 464 				// FIXME: Should make it possible to use the RangePayload[] directly instead
 465 				List&lt;IQuantity&gt; starts = Stream.of(sorted).map(r -&gt; r.start).collect(Collectors.toList());
 466 				List&lt;IQuantity&gt; ends = Stream.of(sorted).map(r -&gt; r.end).collect(Collectors.toList());
 467 				return XYQuantities.create(sorted, starts, ends, xRange);
 468 			}
 469 
 470 			@Override
 471 			public IQuantity getStartX(RangePayload payload) {
 472 				return payload.start;
 473 			}
 474 		};
 475 	}
 476 
 477 	public final static Color GC_BASE_COLOR = TypeLabelProvider.getColor(JdkTypeIDs.GC_PAUSE);
 478 	private final static Color VM_OPERATIONS_BASE_COLOR = TypeLabelProvider.getColor(JdkTypeIDs.VM_OPERATIONS);
 479 	private final static IColorProvider&lt;RangePayload&gt; GC_COLOR = payload -&gt; adjustAlpha(GC_BASE_COLOR,
 480 			payload.rangeInPixels);
 481 	private final static IColorProvider&lt;RangePayload&gt; APPLICATION_PAUSE_COLOR = payload -&gt; adjustAlpha(
 482 			payload.item.getType().getIdentifier().equals(JdkTypeIDs.GC_PAUSE) ? GC_BASE_COLOR
 483 					: VM_OPERATIONS_BASE_COLOR,
 484 			payload.rangeInPixels);
 485 	public final static ImageDescriptor GC_LEGEND_ICON = new OverlayImageDescriptor(
 486 			SWTColorToolkit.getColorThumbnailDescriptor(SWTColorToolkit.asRGB(GC_BASE_COLOR)), false,
 487 			FlightRecorderUI.getDefault().getMCImageDescriptor(&quot;trash_overlay.png&quot;)); //$NON-NLS-1$
 488 
 489 	/**
 490 	 * Return a color with alpha calculated from a fraction.
 491 	 *
 492 	 * @param color
 493 	 *            a base color
 494 	 * @param fraction
 495 	 *            A value where 0 gives the lowest alpha value and 1 gives the highest. Fractions
 496 	 *            above 1 are accepted and treated as 1. Negative fractions should not be used.
 497 	 * @return a color with RGB from the base color and an alpha value depending on the fraction
 498 	 */
 499 	private static Color adjustAlpha(Color color, double fraction) {
 500 		return ColorToolkit.withAlpha(color, Math.min(200, (int) ((Math.max(0, fraction) + 0.15) * 255)));
 501 	}
 502 
 503 	public static ItemRow buildGcPauseRow(IItemCollection items) {
 504 		IItemCollection pauseEvents = items.apply(JdkFilters.GC_PAUSE);
 505 		ISpanSeries&lt;RangePayload&gt; gcBackdrop = rangeSeries(pauseEvents, JfrAttributes.START_TIME,
 506 				JfrAttributes.END_TIME);
 507 		return new ItemRow(SpanRenderer.build(gcBackdrop, GC_COLOR), pauseEvents);
 508 	}
 509 
 510 	public static ItemRow buildApplicationPauseRow(IItemCollection items) {
 511 		IItemFilter vmOperationPauseFilter = ItemFilters.and(JdkFilters.VM_OPERATIONS,
 512 				ItemFilters.equals(JdkAttributes.SAFEPOINT, true));
 513 		IItemCollection applicationPauses = items
 514 				.apply(ItemFilters.or(JdkFilters.GC_PAUSE, JdkFilters.SAFE_POINTS, vmOperationPauseFilter));
 515 		ISpanSeries&lt;RangePayload&gt; pausesSeries = rangeSeries(applicationPauses, JfrAttributes.START_TIME,
 516 				JfrAttributes.END_TIME);
 517 		return new ItemRow(SpanRenderer.build(pausesSeries, APPLICATION_PAUSE_COLOR), applicationPauses);
 518 	}
 519 
 520 	public static IXDataRenderer buildTimestampHistogramRenderer(
 521 		IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator, IAttribute&lt;IQuantity&gt; timestampAttribute,
 522 		Color color) {
 523 		IQuantitySeries&lt;IQuantity[]&gt; aggregatorSeries = BucketBuilder.aggregatorSeries(items, aggregator,
 524 				timestampAttribute);
 525 		XYDataRenderer renderer = new XYDataRenderer(getKindOfQuantity(aggregator).getDefaultUnit().quantity(0),
 526 				aggregator.getName(), aggregator.getDescription());
 527 		renderer.addBarChart(aggregator.getName(), aggregatorSeries, color);
 528 		return renderer;
 529 	}
 530 
 531 	public static IXDataRenderer buildTimestampHistogramRenderer(
 532 		IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator, Color color) {
 533 		return buildTimestampHistogramRenderer(items, aggregator, JfrAttributes.CENTER_TIME, color);
 534 	}
 535 
 536 	public static ItemRow buildTimestampHistogram(
 537 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator,
 538 		IAttribute&lt;IQuantity&gt; timestampAttribute, Color color) {
 539 		return new ItemRow(title, description,
 540 				buildTimestampHistogramRenderer(items, aggregator, timestampAttribute, color), items);
 541 	}
 542 
 543 	public static ItemRow buildTimestampHistogram(
 544 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; aggregator, Color color) {
 545 		return new ItemRow(title, description, buildTimestampHistogramRenderer(items, aggregator, color), items);
 546 	}
 547 
 548 	public static ItemHistogram createDistinctItemsTable(
 549 		Composite parent, IItemCollection items, IItemQuery query, TableSettings settings) {
 550 		CompositeKeyHistogramBuilder histogramBuilder = new CompositeKeyHistogramBuilder();
 551 		for (IAttribute&lt;?&gt; attribute : query.getAttributes()) {
 552 			histogramBuilder.addKeyColumn(attribute);
 553 		}
 554 		for (IAggregator&lt;?, ?&gt; aggregator : query.getAggregators()) {
 555 			histogramBuilder.addColumn(aggregator.getName(), aggregator);
 556 		}
 557 		ItemHistogram table = histogramBuilder.buildWithoutBorder(parent, settings);
 558 		return table;
 559 	}
 560 
 561 	public static IBaseLabelProvider createTableHighlightProvider(Pattern highlightPattern, boolean isWarning) {
 562 		return new StyledCellLabelProvider() {
 563 			@Override
 564 			public void update(ViewerCell cell) {
 565 				org.eclipse.swt.graphics.Color color = isWarning
 566 						? new org.eclipse.swt.graphics.Color(Display.getCurrent(), 240, 120, 140)
 567 						: new org.eclipse.swt.graphics.Color(Display.getCurrent(), 255, 144, 4);
 568 				String text = getText(cell.getElement(), cell.getColumnIndex());
 569 				Matcher matcher = highlightPattern.matcher(text);
 570 				if (matcher.find()) {
 571 					cell.getViewerRow().setBackground(0, color);
 572 					cell.getViewerRow().setBackground(1, color);
 573 				}
 574 				cell.setText(text);
 575 				super.update(cell);
 576 			}
 577 
 578 			private String getText(Object element, int index) {
 579 				Object key = AggregationGrid.getKey(element);
 580 				Object[] keyElements = ((CompositeKey) key).getKeyElements();
 581 				return keyElements[index].toString();
 582 			}
 583 		};
 584 	}
 585 
 586 	public static void addContextMenus(
 587 		IPageContainer pc, ItemHistogram h, String selectionName, IAction ... extraActions) {
 588 		MCContextMenuManager mm = MCContextMenuManager.create(h.getManager().getViewer().getControl());
 589 		ColumnMenusFactory.addDefaultMenus(h.getManager(), mm);
 590 		SelectionStoreActionToolkit.addSelectionStoreActions(pc.getSelectionStore(), h, selectionName, mm);
 591 		for (IAction action : extraActions) {
 592 			mm.add(action);
 593 		}
 594 	}
 595 
 596 	public static IXDataRenderer buildSizeRow(
 597 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; a, Color color,
 598 		IColorProvider&lt;IItem&gt; cp) {
 599 		return RendererToolkit.layers(buildSpanRenderer(items, cp),
 600 				buildTimestampHistogram(title, description, items, a, color));
 601 	}
 602 
 603 	public static ItemRow buildDurationHistogram(
 604 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; a, Color color) {
 605 		IQuantitySeries&lt;IQuantity[]&gt; allocationSeries = BucketBuilder.aggregatorSeries(items, a,
 606 				JfrAttributes.DURATION);
 607 		XYDataRenderer renderer = new XYDataRenderer(getKindOfQuantity(a).getDefaultUnit().quantity(0), title,
 608 				description);
 609 		renderer.addBarChart(a.getName(), allocationSeries, color);
 610 		return new ItemRow(title, description, renderer, items);
 611 	}
 612 
 613 	public static ItemRow buildSizeHistogram(
 614 		String title, String description, IItemCollection items, IAggregator&lt;IQuantity, ?&gt; a, Color color,
 615 		IAttribute&lt;IQuantity&gt; attribute) {
 616 		IQuantitySeries&lt;IQuantity[]&gt; allocationSeries = BucketBuilder.aggregatorSeries(items, a, JdkAttributes.IO_SIZE);
 617 		XYDataRenderer renderer = new XYDataRenderer(getKindOfQuantity(a).getDefaultUnit().quantity(0), title,
 618 				description);
 619 		renderer.addBarChart(a.getName(), allocationSeries, color);
 620 		return new ItemRow(title, description, renderer, items);
 621 	}
 622 
 623 	public static IRange&lt;IQuantity&gt; buildSizeRange(IItemCollection items, boolean isSocket) {
 624 		IQuantity end = null;
 625 		if (isSocket) {
 626 			end = QuantitiesToolkit.maxPresent(items.getAggregate(JdkAggregators.SOCKET_READ_LARGEST),
 627 					items.getAggregate(JdkAggregators.SOCKET_WRITE_LARGEST));
 628 		} else {
 629 			end = QuantitiesToolkit.maxPresent(items.getAggregate(JdkAggregators.FILE_READ_LARGEST),
 630 					items.getAggregate(JdkAggregators.FILE_WRITE_LARGEST));
 631 		}
 632 		end = end == null ? UnitLookup.BYTE.quantity(1024) : end;
 633 		return QuantityRange.createWithEnd(UnitLookup.BYTE.quantity(0), end);
 634 	}
 635 
 636 	// FIXME: Make something that can use something other than time as x-axis?
 637 	public static IXDataRenderer buildSpanRenderer(IItemCollection pathItems, IColorProvider&lt;IItem&gt; cp) {
 638 		ISpanSeries&lt;IItem&gt; dataSeries = QuantitySeries.max(pathItems, JfrAttributes.START_TIME, JfrAttributes.END_TIME);
 639 		return SpanRenderer.withBoundaries(dataSeries, cp);
 640 	}
 641 
 642 	public static boolean addEndTimeLines(
 643 		XYDataRenderer renderer, IItemCollection items, boolean fill, Stream&lt;IAttribute&lt;IQuantity&gt;&gt; yAttributes) {
 644 		// FIXME: JMC-4520 - Handle multiple item iterables
 645 		Iterator&lt;IItemIterable&gt; ii = items.iterator();
 646 		if (ii.hasNext()) {
 647 			IItemIterable itemStream = ii.next();
 648 			IType&lt;IItem&gt; type = itemStream.getType();
 649 			// FIXME: A better way to ensure sorting by endTime
 650 			return yAttributes.peek(a -&gt; addEndTimeLine(renderer, itemStream.iterator(), type, a, fill))
 651 					.mapToLong(a -&gt; 1L).sum() &gt; 0;
 652 		}
 653 		return false;
 654 	}
 655 
 656 	public static void addEndTimeLine(
 657 		XYDataRenderer renderer, Iterator&lt;? extends IItem&gt; items, IType&lt;IItem&gt; type, IAttribute&lt;IQuantity&gt; yAttribute,
 658 		boolean fill) {
 659 		IQuantitySeries&lt;?&gt; qs = buildQuantitySeries(items, type, JfrAttributes.END_TIME, yAttribute);
 660 		renderer.addLineChart(yAttribute.getName(), qs, getFieldColor(yAttribute), fill);
 661 	}
 662 
 663 	public static IQuantitySeries&lt;?&gt; buildQuantitySeries(
 664 		Iterator&lt;? extends IItem&gt; items, IType&lt;IItem&gt; type, IAttribute&lt;IQuantity&gt; xAttribute,
 665 		IAttribute&lt;IQuantity&gt; yAttribute) {
 666 		IMemberAccessor&lt;IQuantity, IItem&gt; yAccessor = yAttribute.getAccessor(type);
 667 		if (yAccessor == null) {
 668 			throw new RuntimeException(yAttribute.getIdentifier() + &quot; is not an attribute for &quot; + type.getIdentifier()); //$NON-NLS-1$
 669 		}
 670 		return buildQuantitySeries(items, type, xAttribute, yAccessor);
 671 	}
 672 
 673 	public static IQuantitySeries&lt;?&gt; buildQuantitySeries(
 674 		Iterator&lt;? extends IItem&gt; items, IType&lt;IItem&gt; type, IAttribute&lt;IQuantity&gt; xAttribute,
 675 		IMemberAccessor&lt;? extends IQuantity, IItem&gt; yAccessor) {
 676 		IMemberAccessor&lt;IQuantity, IItem&gt; xAccessor = xAttribute.getAccessor(type);
 677 		return QuantitySeries.all(items, xAccessor, yAccessor);
 678 	}
 679 
 680 	public static void createChartTooltip(ChartCanvas chart) {
 681 		createChartTooltip(chart, ChartToolTipProvider::new);
 682 	}
 683 
 684 	public static void createChartTimestampTooltip(ChartCanvas chart) {
 685 		createChartTooltip(chart, JfrAttributes.START_TIME, JfrAttributes.END_TIME, JfrAttributes.DURATION,
 686 				JfrAttributes.EVENT_TYPE, JfrAttributes.EVENT_STACKTRACE);
 687 	}
 688 
 689 	public static void createChartTooltip(ChartCanvas chart, IAttribute&lt;?&gt; ... excludedAttributes) {
 690 		createChartTooltip(chart, new HashSet&lt;&gt;(Arrays.asList(excludedAttributes)));
 691 	}
 692 
 693 	public static void createChartTooltip(ChartCanvas chart, Set&lt;IAttribute&lt;?&gt;&gt; excludedAttributes) {
 694 		createChartTooltip(chart, () -&gt; new ChartToolTipProvider() {
 695 			@Override
 696 			protected Stream&lt;IAttribute&lt;?&gt;&gt; getAttributeStream(IType&lt;IItem&gt; type) {
 697 				return type.getAttributes().stream().filter(a -&gt; !excludedAttributes.contains(a));
 698 			}
 699 		});
 700 	}
 701 
 702 	public static void createChartTooltip(ChartCanvas chart, Supplier&lt;ChartToolTipProvider&gt; toolTipProviderSupplier) {
 703 		new ToolTip(chart) {
 704 			String html;
 705 			Map&lt;String, Image&gt; images;
 706 
 707 			@Override
 708 			protected boolean shouldCreateToolTip(Event event) {
 709 				ChartToolTipProvider provider = toolTipProviderSupplier.get();
 710 				chart.infoAt(provider, event.x, event.y);
 711 				html = provider.getHTML();
 712 				images = provider.getImages();
 713 				return html != null;
 714 			}
 715 
 716 			@Override
 717 			protected Composite createToolTipContentArea(Event event, Composite parent) {
 718 				FormText formText = CompositeToolkit.createInfoFormText(parent);
 719 				for (Map.Entry&lt;String, Image&gt; imgEntry : images.entrySet()) {
 720 					formText.setImage(imgEntry.getKey(), imgEntry.getValue());
 721 				}
 722 				formText.setText(html, true, false);
 723 				return formText;
 724 			}
 725 
 726 		};
 727 
 728 	}
 729 
 730 	private static KindOfQuantity&lt;?&gt; getKindOfQuantity(IAggregator&lt;IQuantity, ?&gt; a) {
 731 		IType&lt;? super IQuantity&gt; ct = a.getValueType();
 732 		// FIXME: Refactor to avoid this cast
 733 		return ((KindOfQuantity&lt;?&gt;) ct);
 734 	}
 735 
 736 	public static Form createForm(Composite parent, FormToolkit toolkit, String title, Image img) {
 737 		Form form = toolkit.createForm(parent);
 738 		form.setText(title.replaceAll(&quot;&amp;&quot;, &quot;&amp;&amp;&quot;)); //$NON-NLS-1$ //$NON-NLS-2$
 739 		form.setImage(img);
 740 		toolkit.decorateFormHeading(form);
 741 		FillLayout fillLayout = new FillLayout();
 742 		fillLayout.marginHeight = 15;
 743 		fillLayout.marginWidth = 8;
 744 		form.getBody().setLayout(fillLayout);
 745 		form.getToolBarManager().add(new Separator(FORM_TOOLBAR_PAGE_RESULTS));
 746 		form.getToolBarManager().add(new Separator(FORM_TOOLBAR_PAGE_SETUP));
 747 		form.getToolBarManager().add(new Separator(FORM_TOOLBAR_PAGE_NAV));
 748 		return form;
 749 	}
 750 
 751 	public static class ShowResultAction extends Action {
 752 
 753 		private String[] topics;
 754 		private final IPageContainer pageContainer;
 755 		private volatile Severity maxSeverity;
 756 		private final List&lt;Consumer&lt;Result&gt;&gt; listeners = new ArrayList&lt;&gt;();
 757 
 758 		ShowResultAction(String title, int style, ImageDescriptor icon, Supplier&lt;String&gt; tooltip,
 759 				IPageContainer pageContainer, String ... topics) {
 760 			super(title, style);
 761 			setImageDescriptor(icon);
 762 			setToolTipText(tooltip.get());
 763 			this.topics = topics;
 764 			this.pageContainer = pageContainer;
 765 			maxSeverity = pageContainer.getRuleManager().getMaxSeverity(topics);
 766 			for (String topic : topics) {
 767 				Consumer&lt;Result&gt; listener = result -&gt; {
 768 					Severity severity = Severity.get(result.getScore());
 769 					if (severity.compareTo(maxSeverity) &gt; 0) {
 770 						maxSeverity = severity;
 771 						setImageDescriptor(getResultIcon(maxSeverity));
 772 					} else if (severity.compareTo(maxSeverity) &lt; 0) { // severity could be less than previous max
 773 						maxSeverity = pageContainer.getRuleManager().getMaxSeverity(topics);
 774 					}
 775 					setToolTipText(tooltip.get());
 776 				};
 777 				listeners.add(listener);
 778 				pageContainer.getRuleManager().addResultListener(topic, listener);
 779 			}
 780 		}
 781 
 782 		private void removeListeners() {
 783 			listeners.forEach(l -&gt; pageContainer.getRuleManager().removeResultListener(l));
 784 		}
 785 
 786 		@Override
 787 		public void run() {
 788 			pageContainer.showResults(topics);
 789 		}
 790 	}
 791 
 792 	public static void addRuleResultAction(
 793 		Form form, IPageContainer pageContainer, Supplier&lt;String&gt; tooltip, String[] topics) {
 794 		if (topics == null || topics.length == 0 || !FlightRecorderUI.getDefault().isAnalysisEnabled()) {
 795 			return;
 796 		}
 797 		ImageDescriptor icon = getResultIcon(pageContainer.getRuleManager().getMaxSeverity(topics));
 798 		ShowResultAction resultAction = new ShowResultAction(Messages.RULES_SHOW_RESULTS_ACTION, IAction.AS_PUSH_BUTTON,
 799 				icon, tooltip, pageContainer, topics);
 800 		resultAction.setId(RESULT_ACTION_ID);
 801 		form.getToolBarManager().appendToGroup(DataPageToolkit.FORM_TOOLBAR_PAGE_RESULTS, resultAction);
 802 		form.getToolBarManager().update(true);
 803 		form.addDisposeListener(e -&gt; resultAction.removeListeners());
 804 	}
 805 
 806 	private static ImageDescriptor getResultIcon(Severity severity) {
 807 		switch (severity) {
 808 		case OK:
 809 			return ResultOverview.ICON_OK;
 810 		case INFO:
 811 			return ResultOverview.ICON_INFO;
 812 		case WARNING:
 813 			return ResultOverview.ICON_WARNING;
 814 		case NA:
 815 			return ResultOverview.ICON_NA;
 816 		}
 817 		return null;
 818 	}
 819 
 820 	/**
 821 	 * Return a disabled Action.
 822 	 *
 823 	 * @param text
 824 	 *            text to be displayed by the MenuItem, and represent it as it&#39;s id.
 825 	 * @return an Action containing the desired text, which will be disabled in a UI component.
 826 	 */
 827 	public static IAction disabledAction(String text) {
 828 		IAction disabledAction = new Action(text) {
 829 			@Override
 830 			public boolean isEnabled() {
 831 				return false;
 832 			}
 833 		};
 834 		disabledAction.setId(text);
 835 		return disabledAction;
 836 	}
 837 
 838 	public static FilterEditor buildFilterSelector(
 839 		Composite parent, IItemFilter filter, IItemCollection items, Supplier&lt;Stream&lt;SelectionStoreEntry&gt;&gt; selections,
 840 		Consumer&lt;IItemFilter&gt; onSelect, boolean hasBorder) {
 841 		Supplier&lt;Collection&lt;IAttribute&lt;?&gt;&gt;&gt; attributeSupplier = () -&gt; getPersistableAttributes(
 842 				getAttributes(filter != null ? items.apply(filter) : items)).collect(Collectors.toList());
 843 
 844 		AttributeValueProvider valueSupplier = new AttributeValueProvider() {
 845 			@Override
 846 			public &lt;V&gt; V defaultValue(ICanonicalAccessorFactory&lt;V&gt; attribute) {
 847 				return findValueForFilter(items, attribute);
 848 			}
 849 		};
 850 
 851 		FilterEditor editor = new FilterEditor(parent, onSelect, filter, attributeSupplier, valueSupplier,
 852 				TypeLabelProvider::getColorOrDefault, hasBorder ? SWT.BORDER : SWT.NONE);
 853 
 854 		MenuManager addFromSelectionPredicate = new MenuManager(Messages.FILTER_ADD_FROM_SELECTION);
 855 		editor.getContextMenu().prependToGroup(MCContextMenuManager.GROUP_NEW, addFromSelectionPredicate);
 856 		addFromSelectionPredicate.setRemoveAllWhenShown(true);
 857 		addFromSelectionPredicate.addMenuListener(new IMenuListener() {
 858 
 859 			@Override
 860 			public void menuAboutToShow(IMenuManager manager) {
 861 				selections.get().forEach(entry -&gt; {
 862 					MenuManager selectionFlavors = new MenuManager(entry.getName());
 863 					entry.getSelection().getFlavors(editor.getFilter(), items, null)
 864 							.filter(f -&gt; f instanceof IFilterFlavor).forEach(flavor -&gt; {
 865 								selectionFlavors.add(new Action(flavor.getName()) {
 866 									@Override
 867 									public void run() {
 868 										editor.addRoot(((IFilterFlavor) flavor).getFilter());
 869 									}
 870 								});
 871 							});
 872 					if (!selectionFlavors.isEmpty()) {
 873 						if (manager.find(Messages.FILTER_NO_SELECTION_AVAILABLE) != null) {
 874 							manager.remove(Messages.FILTER_NO_SELECTION_AVAILABLE);
 875 						}
 876 						manager.add(selectionFlavors);
 877 					} else {
 878 						manager.add(disabledAction(Messages.FILTER_NO_SELECTION_AVAILABLE));
 879 					}
 880 				});
 881 			}
 882 		});
 883 
 884 		// FIXME: This could potentially move into the FilterEditor class
 885 		MenuManager addAttributeValuePredicate = new MenuManager(Messages.FILTER_ADD_FROM_ATTRIBUTE);
 886 		editor.getContextMenu().prependToGroup(MCContextMenuManager.GROUP_NEW, addAttributeValuePredicate);
 887 		addAttributeValuePredicate.setRemoveAllWhenShown(true);
 888 		addAttributeValuePredicate.addMenuListener(new IMenuListener() {
 889 			Collection&lt;IAttribute&lt;?&gt;&gt; attributes;
 890 
 891 			@Override
 892 			public void menuAboutToShow(IMenuManager manager) {
 893 				if (attributes == null) {
 894 					attributes = attributeSupplier.get();
 895 				}
 896 				if (!attributes.isEmpty()) {
 897 					if (manager.find(Messages.FILTER_NO_ATTRIBUTE_AVAILABLE) != null) {
 898 						manager.remove(Messages.FILTER_NO_ATTRIBUTE_AVAILABLE);
 899 					}
 900 					attributes.stream().distinct().sorted((a1, a2) -&gt; a1.getName().compareTo(a2.getName()))
 901 							.forEach(attr -&gt; {
 902 								addAttributeValuePredicate.add(new Action(attr.getName()) {
 903 									@Override
 904 									public void run() {
 905 										IItemFilter filter = createDefaultFilter(items, attr);
 906 										editor.addRoot(filter);
 907 									}
 908 								});
 909 							});
 910 				} else {
 911 					manager.add(disabledAction(Messages.FILTER_NO_ATTRIBUTE_AVAILABLE));
 912 				}
 913 
 914 			}
 915 		});
 916 		return editor;
 917 	}
 918 
 919 	// FIXME: Move to some AttributeToolkit?
 920 	private static Stream&lt;IAttribute&lt;?&gt;&gt; getAttributes(IItemCollection items) {
 921 		return ItemCollectionToolkit.stream(items).filter(IItemIterable::hasItems)
 922 				.flatMap(is -&gt; is.getType().getAttributes().stream());
 923 	}
 924 
 925 	public static Stream&lt;IAttribute&lt;?&gt;&gt; getPersistableAttributes(Stream&lt;IAttribute&lt;?&gt;&gt; attributes) {
 926 		// FIXME: Would like to always be able to persist a string representation of the attribute, because this is usable by filters.
 927 
 928 		// FIXME: Should we always include event type? Does it make any sense, except on the custom pages?
 929 
 930 		// FIXME: Transform both START_TIME and END_TIME to LIFETIME?
 931 		// FIXME: Add derived attributes, like a conversion of any THREAD or CLASS attribute? Thread group?
 932 		/*
 933 		 * Make sure to do the conversions in the right order, so for example a stack trace can be
 934 		 * converted to a top method, which then is converted to a method string.
 935 		 */
 936 		return attributes.map(a -&gt; a.equals(JfrAttributes.EVENT_THREAD) ? JdkAttributes.EVENT_THREAD_NAME : a)
 937 				.flatMap(a -&gt; a.equals(JfrAttributes.EVENT_STACKTRACE) ? Stream.of(JdkAttributes.STACK_TRACE_STRING,
 938 						JdkAttributes.STACK_TRACE_TOP_METHOD_STRING, JdkAttributes.STACK_TRACE_TOP_CLASS_STRING,
 939 						JdkAttributes.STACK_TRACE_TOP_PACKAGE, JdkAttributes.STACK_TRACE_BOTTOM_METHOD_STRING)
 940 						: Stream.of(a))
 941 				.map(a -&gt; a.equals(JdkAttributes.COMPILER_METHOD) ? JdkAttributes.COMPILER_METHOD_STRING : a)
 942 				// FIXME: String or id?
 943 				.map(a -&gt; a.equals(JdkAttributes.REC_SETTING_FOR) ? JdkAttributes.REC_SETTING_FOR_NAME : a)
 944 				.map(a -&gt; a.equals(JdkAttributes.CLASS_DEFINING_CLASSLOADER)
 945 						? JdkAttributes.CLASS_DEFINING_CLASSLOADER_STRING : a)
 946 				.map(a -&gt; a.equals(JdkAttributes.CLASS_INITIATING_CLASSLOADER)
 947 						? JdkAttributes.CLASS_INITIATING_CLASSLOADER_STRING : a)
 948 				.map(a -&gt; a.equals(JdkAttributes.PARENT_CLASSLOADER) ? JdkAttributes.PARENT_CLASSLOADER_STRING : a)
 949 				.map(a -&gt; a.equals(JdkAttributes.CLASSLOADER) ? JdkAttributes.CLASSLOADER_STRING : a)
 950 				.filter(a -&gt; a.equals(JfrAttributes.EVENT_TYPE) || (a.getContentType() instanceof RangeContentType)
 951 						|| (a.getContentType().getPersister() != null))
 952 				.distinct();
 953 	}
 954 
 955 	/**
 956 	 * Returns a value for attribute, firstly by trying to find one in the items, secondly by
 957 	 * creating a default value for some known content types. Returns null if the first two cases
 958 	 * fail.
 959 	 *
 960 	 * @param items
 961 	 * @param attribute
 962 	 * @return a value of type V, or null
 963 	 */
 964 	@SuppressWarnings(&quot;unchecked&quot;)
 965 	private static &lt;V&gt; V findValueForFilter(IItemCollection items, ICanonicalAccessorFactory&lt;V&gt; attribute) {
 966 		IItem firstItem = ItemCollectionToolkit.stream(items).filter(is -&gt; is.getType().hasAttribute(attribute))
 967 				.flatMap(ItemIterableToolkit::stream)
 968 				.filter(i -&gt; ((IMemberAccessor&lt;V, IItem&gt;) attribute.getAccessor(i.getType())).getMember(i) != null)
 969 				.findFirst().orElse(null);
 970 		if (firstItem != null) {
 971 			IMemberAccessor&lt;V, IItem&gt; accessor = (IMemberAccessor&lt;V, IItem&gt;) attribute.getAccessor(firstItem.getType());
 972 			return accessor.getMember(firstItem);
 973 		}
 974 		if (UnitLookup.PLAIN_TEXT.equals(attribute.getContentType())) {
 975 			return (V) &quot;&quot;; //$NON-NLS-1$
 976 		}
 977 		if (attribute.getContentType() instanceof KindOfQuantity&lt;?&gt;) {
 978 			return (V) ((KindOfQuantity&lt;?&gt;) attribute.getContentType()).getDefaultUnit().quantity(0);
 979 		}
 980 		return null;
 981 	}
 982 
 983 	/**
 984 	 * Returns an default filter for attribute, which might be an equals filter, hasAttribute
 985 	 * filter, or type filter, depending on the attribute and the contents of the items.
 986 	 *
 987 	 * @param items
 988 	 * @param attribute
 989 	 * @return a filter
 990 	 */
 991 	// FIXME: Should move to FilterEditor, or some subclass/specialization?
 992 	private static &lt;V&gt; IItemFilter createDefaultFilter(IItemCollection items, ICanonicalAccessorFactory&lt;V&gt; attribute) {
 993 		V value = findValueForFilter(items, attribute);
 994 		if (value == null) {
 995 			return ItemFilters.hasAttribute(attribute);
 996 		} else if (attribute.equals(JfrAttributes.EVENT_TYPE)) {
 997 			return ItemFilters.type(((IType&lt;?&gt;) value).getIdentifier());
 998 		}
 999 		return ItemFilters.equals(attribute, value);
1000 	}
1001 
1002 	public static void addRenameAction(Form form, IPageContainer editor) {
1003 		form.getMenuManager().add(new Action(Messages.PAGE_RENAME_MENU_ACTION) {
1004 			@Override
1005 			public void run() {
1006 				InputDialog dialog = new InputDialog(form.getShell(), Messages.PAGE_RENAME_DIALOG_TITLE,
1007 						Messages.PAGE_RENAME_DIALOG_MESSAGE, form.getText(), null);
1008 				if (dialog.open() == Window.OK) {
1009 					form.setText(dialog.getValue());
1010 					editor.currentPageRefresh();
1011 				}
1012 			}
1013 		});
1014 	}
1015 
1016 	public static void addIconChangeAction(Form form, IPageContainer editor, Consumer&lt;Image&gt; newIconConsumer) {
1017 		form.getMenuManager().add(new Action(Messages.PAGE_CHANGE_ICON_MENU_ACTION) {
1018 			@Override
1019 			public void run() {
1020 				WizardDialog dialog = new WizardDialog(form.getShell(),
1021 						new IconChangeWizard(form.getImage(), newIconConsumer));
1022 				dialog.open();
1023 				editor.currentPageRefresh();
1024 			}
1025 		});
1026 	}
1027 
1028 	private static class IconChangeWizard extends Wizard {
1029 
1030 		private final Image currentImage;
1031 		private final Consumer&lt;Image&gt; imageConsumer;
1032 		private Label imageLabel;
1033 
1034 		public IconChangeWizard(Image currentImage, Consumer&lt;Image&gt; imageConsumer) {
1035 			setWindowTitle(Messages.PAGE_CHANGE_ICON_WIZARD_TITLE);
1036 			this.currentImage = currentImage;
1037 			this.imageConsumer = imageConsumer;
1038 		}
1039 
1040 		@Override
1041 		public void addPages() {
1042 			addPage(new WizardPage(Messages.PAGE_CHANGE_ICON_WIZARD_PAGE_TITLE) {
1043 
1044 				@Override
1045 				public String getTitle() {
1046 					return Messages.PAGE_CHANGE_ICON_WIZARD_PAGE_TITLE;
1047 				}
1048 
1049 				@Override
1050 				public String getDescription() {
1051 					return Messages.PAGE_CHANGE_ICON_WIZARD_PAGE_DESC;
1052 				}
1053 
1054 				@Override
1055 				public void createControl(Composite parent) {
1056 					Composite container = new Composite(parent, SWT.NONE);
1057 					GridLayout layout = new GridLayout(1, false);
1058 					container.setLayout(layout);
1059 
1060 					Button button = new Button(container, SWT.NONE);
1061 					button.setText(Messages.PAGE_CHANGE_ICON_CHOOSE_IMAGE_FILE);
1062 
1063 					button.addSelectionListener(new SelectionAdapter() {
1064 						@Override
1065 						public void widgetSelected(SelectionEvent e) {
1066 							chooseImageFileDialog();
1067 						}
1068 					});
1069 
1070 					if (currentImage != null) {
1071 						new Label(container, SWT.NONE).setText(Messages.PAGE_CHANGE_ICON_CURRENT_ICON);
1072 						new Label(container, SWT.BORDER).setImage(currentImage);
1073 					}
1074 					new Label(container, SWT.NONE).setText(Messages.PAGE_CHANGE_ICON_NEW_ICON_PREVIEW);
1075 					imageLabel = new Label(container, SWT.BORDER);
1076 					GridData gd = new GridData(16, 16);
1077 					imageLabel.setLayoutData(gd);
1078 
1079 					setControl(container);
1080 				}
1081 
1082 				private void chooseImageFileDialog() {
1083 					FileDialog fileDialog = new FileDialog(getShell(), SWT.OPEN);
1084 					String[] filterNames = new String[] {&quot;Image Files&quot;, &quot;All Files (*)&quot;}; //$NON-NLS-1$ //$NON-NLS-2$
1085 					String[] filterExtensions = new String[] {&quot;*.gif;*.png;*.xpm;*.jpg;*.jpeg;*.tiff&quot;, &quot;*&quot;}; //$NON-NLS-1$ //$NON-NLS-2$
1086 					fileDialog.setFilterNames(filterNames);
1087 					fileDialog.setFilterExtensions(filterExtensions);
1088 					String filename = fileDialog.open();
1089 					if (filename == null) {
1090 						// Dialog was cancelled. Bail out early to avoid handling that case later. Premature?
1091 						return;
1092 					}
1093 					try (InputStream fis = new FileInputStream(filename)) {
1094 						ImageData imageData = new ImageData(fis);
1095 						// Validate image data
1096 						if (imageData.width != 16 || imageData.height != 16) {
1097 							imageData = resizeImage(imageData, 16, 16);
1098 						}
1099 						DisplayToolkit.dispose(imageLabel.getImage());
1100 						imageLabel.setImage(new Image(getShell().getDisplay(), imageData));
1101 						imageLabel.getParent().layout();
1102 						setPageComplete(isPageComplete());
1103 					} catch (Exception e) {
1104 						// FIXME: Add proper logging
1105 						e.printStackTrace();
1106 					}
1107 				}
1108 
1109 				private ImageData resizeImage(ImageData imageData, int width, int height) {
1110 					Image original = ImageDescriptor.createFromImageData(imageData).createImage();
1111 					Image scaled = new Image(Display.getDefault(), width, height);
1112 					GC gc = new GC(scaled);
1113 					gc.setAntialias(SWT.ON);
1114 					gc.setInterpolation(SWT.HIGH);
1115 					gc.drawImage(original, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
1116 					gc.dispose();
1117 					original.dispose();
1118 					ImageData scaledData = scaled.getImageData();
1119 					scaled.dispose();
1120 					return scaledData;
1121 				}
1122 
1123 				@Override
1124 				public boolean isPageComplete() {
1125 					return imageLabel.getImage() != null;
1126 				}
1127 
1128 			});
1129 		}
1130 
1131 		@Override
1132 		public boolean performFinish() {
1133 			imageConsumer.accept(imageLabel.getImage());
1134 			DisplayToolkit.dispose(currentImage);
1135 			return true;
1136 		}
1137 
1138 		@Override
1139 		public boolean performCancel() {
1140 			DisplayToolkit.dispose(imageLabel.getImage());
1141 			return true;
1142 		}
1143 
1144 	}
1145 
1146 	public static ItemList createSimpleItemList(
1147 		Composite parent, ItemListBuilder listBuilder, IPageContainer pageContainer, TableSettings tableSettings,
1148 		String selectionName) {
1149 
1150 		ItemList list = listBuilder.build(parent, tableSettings);
1151 		ColumnViewer viewer = list.getManager().getViewer();
1152 		MCContextMenuManager mm = MCContextMenuManager.create(viewer.getControl());
1153 		list.setMenuManager(mm);
1154 		ColumnMenusFactory.addDefaultMenus(list.getManager(), mm);
1155 		viewer.addSelectionChangedListener(
1156 				e -&gt; pageContainer.showSelection(ItemCollectionToolkit.build(list.getSelection().get())));
1157 
1158 		if (selectionName != null) {
1159 			SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), list, selectionName,
1160 					mm);
1161 		}
1162 
1163 		return list;
1164 	}
1165 
1166 	public static void addTabItem(CTabFolder tabFolder, Control section, String name) {
1167 		CTabItem tabItem = new CTabItem(tabFolder, SWT.NONE);
1168 		tabItem.setControl(section);
1169 		tabItem.setText(name);
1170 	}
1171 
1172 	public static TypeFilterBuilder buildEventTypeTree(
1173 		Composite parent, FormToolkit toolkit, Runnable onChange, boolean checkbox) {
1174 		// TODO: Make more accessible.
1175 		// TODO: Add support for storing the expansion state in a memento.
1176 		// TODO: Add input from selection store, output to selection store
1177 		// TODO: Add toolbar for choosing tree or checkbox tree.
1178 		Composite treeComposite = new Composite(parent, SWT.NONE);
1179 		treeComposite.setLayout(new GridLayout());
1180 		toolkit.adapt(treeComposite);
1181 		Label caption = toolkit.createLabel(treeComposite, Messages.EVENT_TYPE_TREE_TITLE);
1182 		caption.setFont(JFaceResources.getFontRegistry().getBold(JFaceResources.DEFAULT_FONT));
1183 		caption.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));
1184 
1185 		TypeFilterBuilder typeFilterTree = new TypeFilterBuilder(treeComposite, onChange, checkbox);
1186 
1187 		typeFilterTree.getControl().setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
1188 		return typeFilterTree;
1189 	}
1190 
1191 	public static boolean isTypeWithThreadAndDuration(IType&lt;?&gt; type) {
1192 		return JfrAttributes.EVENT_THREAD.getAccessor(type) != null
1193 				&amp;&amp; JfrAttributes.START_TIME.getAccessor(type) != JfrAttributes.END_TIME.getAccessor(type);
1194 	}
1195 
1196 	public static void addPage(Set&lt;IType&lt;?&gt;&gt; selectedTypes) {
1197 		PageManager pm = FlightRecorderUI.getDefault().getPageManager();
1198 		pm.makeRoot(pm.createPage(ItemHandlerPage.Factory.class, new ItemHandlerUiStandIn(selectedTypes)));
1199 	}
1200 }
    </pre>
  </body>
</html>
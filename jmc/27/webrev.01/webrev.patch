diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DataPageToolkit.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -137,10 +137,11 @@
 import org.openjdk.jmc.flightrecorder.ui.pages.itemhandler.ItemHandlerPage.ItemHandlerUiStandIn;
 import org.openjdk.jmc.flightrecorder.ui.selection.IFilterFlavor;
 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore.SelectionStoreEntry;
 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
 import org.openjdk.jmc.ui.charts.AWTChartToolkit.IColorProvider;
+import org.openjdk.jmc.ui.charts.ChartFilterControlBar;
 import org.openjdk.jmc.ui.charts.IQuantitySeries;
 import org.openjdk.jmc.ui.charts.ISpanSeries;
 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 import org.openjdk.jmc.ui.charts.QuantitySeries;
 import org.openjdk.jmc.ui.charts.RendererToolkit;
@@ -153,10 +154,11 @@
 import org.openjdk.jmc.ui.column.TableSettings;
 import org.openjdk.jmc.ui.column.TableSettings.ColumnSettings;
 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
 import org.openjdk.jmc.ui.misc.ChartCanvas;
+import org.openjdk.jmc.ui.misc.ChartTextCanvas;
 import org.openjdk.jmc.ui.misc.CompositeToolkit;
 import org.openjdk.jmc.ui.misc.DisplayToolkit;
 import org.openjdk.jmc.ui.misc.FilterEditor;
 import org.openjdk.jmc.ui.misc.FilterEditor.AttributeValueProvider;
 import org.openjdk.jmc.ui.misc.OverlayImageDescriptor;
@@ -310,10 +312,14 @@
 
 	public static void setChart(ChartCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener) {
 		setChart(canvas, chart, selectionListener, null);
 	}
 
+	public static void setChart(ChartTextCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener) {
+		setChart(canvas, chart, selectionListener, null);
+	}
+
 	public static void setChart(
 		ChartCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener,
 		Consumer<IRange<IQuantity>> selectRangeConsumer) {
 		IMenuManager contextMenu = canvas.getContextMenu();
 		contextMenu.removeAll();
@@ -333,10 +339,41 @@
 
 		canvas.setSelectionListener(() -> {
 			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));
 			IQuantity start = chart.getSelectionStart();
 			IQuantity end = chart.getSelectionEnd();
+			if (selectRangeConsumer != null) {
+				selectRangeConsumer
+						.accept(start != null && end != null ? QuantityRange.createWithEnd(start, end) : null);
+			}
+		});
+		canvas.setChart(chart);
+	}
+
+	public static void setChart(
+		ChartTextCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener,
+		Consumer<IRange<IQuantity>> selectRangeConsumer) {
+		IMenuManager contextMenu = canvas.getContextMenu();
+		contextMenu.removeAll();
+		canvas.getContextMenu().add(new Action(Messages.CHART_ZOOM_TO_SELECTED_RANGE) {
+			@Override
+			public void run() {
+				IQuantity selectionStart = chart.getSelectionStart();
+				IQuantity selectionEnd = chart.getSelectionEnd();
+				if (selectionStart == null || selectionEnd == null) {
+					chart.clearVisibleRange();
+				} else {
+					chart.setVisibleRange(selectionStart, selectionEnd);
+				}
+				canvas.redrawChartText();
+			}
+		});
+
+		canvas.setSelectionListener(() -> {
+			selectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));
+			IQuantity start = chart.getSelectionStart();
+			IQuantity end = chart.getSelectionEnd();
 			if (selectRangeConsumer != null) {
 				selectRangeConsumer
 						.accept(start != null && end != null ? QuantityRange.createWithEnd(start, end) : null);
 			}
 		});
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java
--- /dev/null
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/DropdownLaneFilter.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.ui.common;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ShellAdapter;
+import org.eclipse.swt.events.ShellEvent;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Shell;
+
+import org.openjdk.jmc.flightrecorder.ui.common.LaneEditor.EditLanesContainer;
+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class DropdownLaneFilter extends Composite {
+	private static final int EXTRA_SHELL_WIDTH = 300;
+	private static final int SHELL_HEIGHT = 500;
+	private Button dropdownButton;
+	private GridLayout layout;
+	private MCContextMenuManager[] mms;
+	private Shell shell;
+	private ThreadGraphLanes lanes;
+	private EditLanesContainer container;
+
+	public DropdownLaneFilter(Composite parent, ThreadGraphLanes lanes, MCContextMenuManager[] mms) {
+		super(parent, SWT.NONE);
+		this.lanes = lanes;
+		this.mms = mms;
+		this.setBackground(Palette.getThreadsPageBackgroundColor());
+		GridLayout layout = new GridLayout();
+		layout.marginHeight = 0;
+		layout.marginWidth = 0;
+		this.layout = layout;
+		setLayout(layout);
+		dropdownButton = new Button(this, SWT.TOGGLE);
+		dropdownButton.setLayoutData(new GridData(GridData.FILL_BOTH));
+		dropdownButton.setText(Messages.DropdownLaneFilter_THREAD_STATE_SELECTION);
+		dropdownButton.addListener(SWT.MouseUp, new Listener() {
+			@Override
+			public void handleEvent(Event e) {
+				if (dropdownButton.getSelection()) {
+					displayDropdown();
+				}
+			}
+		});
+	}
+
+	/**
+	 * Creates a new shell which is positioned below the dropdown button. This new shell creates the
+	 * appearance of a dropdown component, and it's contents will be the TypeFilterBuilder as found
+	 * in the Edit Thread Lanes dialog.
+	 */
+	private void displayDropdown() {
+		Point p = dropdownButton.getParent().toDisplay(dropdownButton.getLocation());
+		Point size = dropdownButton.getSize();
+		Rectangle shellRect = new Rectangle(p.x, p.y + size.y, size.x, 0);
+
+		shell = new Shell(DropdownLaneFilter.this.getShell(), SWT.BORDER);
+		shell.addShellListener(new ShellAdapter() {
+
+			public void shellDeactivated(ShellEvent e) {
+				if (!isCursorOnTopOfButton()) {
+					// If the shell is closed without clicking the button (i.e., not forcing
+					// a toggle), then the button must be toggled programmatically.
+					dropdownButton.setSelection(false);
+				}
+				disposeDropdown();
+			}
+		});
+
+		shell.setLayout(this.layout);
+		shell.setSize(shellRect.width + EXTRA_SHELL_WIDTH, SHELL_HEIGHT);
+		shell.setLocation(shellRect.x, shellRect.y);
+
+		container = new EditLanesContainer(shell, lanes.getTypeTree(), lanes.getLaneDefinitions(), () -> updateChart());
+		container.setLayoutData(new GridData(GridData.FILL_BOTH));
+		shell.open();
+	}
+
+	private void disposeDropdown() {
+		if (shell != null && !shell.isDisposed()) {
+			shell.close();
+		}
+	}
+
+	/**
+	 * Determine whether or not the mouse cursor is overlapping the dropdown button. An open
+	 * dropdown shell should close when the user clicks the button. In Linux, the MouseListener on
+	 * the button will fire. In Windows, the shell has priority and the MouseListener doesn't get
+	 * activated. This function is to be used in the ShellAdapter to determine if the user closed
+	 * the shell by trying to click the button, or by clicking away from the dropdown shell.
+	 *
+	 * @return true if the mouse cursor is on top of the button
+	 */
+	private boolean isCursorOnTopOfButton() {
+		Point cursor = Display.getCurrent().getCursorLocation();
+		Point buttonLoc = dropdownButton.toDisplay(1, 1);
+		Rectangle buttonRect = new Rectangle(buttonLoc.x, buttonLoc.y, dropdownButton.getSize().x,
+				dropdownButton.getSize().y);
+		return buttonRect.contains(cursor);
+	}
+
+	private void updateChart() {
+		lanes.buildChart();
+		lanes.updateContextMenus(mms, false);
+	}
+}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/FlavorSelector.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -63,11 +63,13 @@
 import org.eclipse.swt.graphics.RGB;
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Canvas;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Event;
 import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
 import org.eclipse.ui.forms.widgets.Form;
 
 import org.openjdk.jmc.common.IDisplayable;
 import org.openjdk.jmc.common.IMCThread;
 import org.openjdk.jmc.common.item.IAttribute;
@@ -299,11 +301,10 @@
 		sameThreadsButton.setEnabled(showConcurrentButton.getSelection());
 		sameThreadsButton.setSelection(flavorSelectorState.sameThreads);
 		sameThreadsButton.addSelectionListener(new SameThreadsSelectionListener());
 
 		// FIXME: Persist state for above checkboxes?
-
 		onShow.ifPresent(on -> {
 			Label rangeLabel = new Label(selectorRow, SWT.NONE);
 			rangeLabel.setLayoutData(GridDataFactory.swtDefaults().create());
 			rangeLabel.setText(Messages.FlavorSelector_LABEL_TIMERANGE);
 			showButton = new Button(selectorRow, SWT.PUSH);
@@ -312,10 +313,16 @@
 			showButton.setLayoutData(GridDataFactory.swtDefaults().create());
 			resetButton = new Button(selectorRow, SWT.PUSH);
 			resetButton.setText(Messages.FlavorSelector_BUTTON_TIMERANGE_CLEAR);
 			resetButton.setToolTipText(Messages.FlavorSelector_BUTTON_TIMERANGE_CLEAR_TOOLTIP);
 			resetButton.addListener(SWT.Selection, e -> on.accept(false));
+			resetButton.addListener(SWT.Selection, new Listener() {
+				@Override
+				public void handleEvent(Event event) {
+					on.accept(false);
+				}
+			});
 			resetButton.setLayoutData(GridDataFactory.swtDefaults().create());
 			showButton.addListener(SWT.Selection, e -> on.accept(true));
 		});
 
 		canvas = new Canvas(container, SWT.NO_BACKGROUND);
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/LaneEditor.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * 
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  *
@@ -101,33 +101,44 @@
 			}
 			return PredicateToolkit.falsePredicate();
 		}
 	};
 
-	private static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {
+	static class EditLanesContainer extends Composite {
+
+		final EventTypeFolderNode root;
+		final List<LaneDefinition> lanes;
 
-		private final EventTypeFolderNode root;
-		private final List<LaneDefinition> lanes;
 		private LaneDefinition restLane;
 		private TypeFilterBuilder filterEditor;
 		private CheckboxTableViewer lanesViewer;
 		private Object selected;
+		private Runnable updateChart;
+		private boolean isDropdownFilter;
+
+		EditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes) {
+			this(parent, root, lanes, null);
+        }
+
+		EditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes, Runnable action) {
+			super(parent, SWT.NONE);
+            this.root = root;
+            this.lanes = lanes;
+            this.updateChart = action;
+            restLane = ensureRestLane(lanes);
+            init();
+		}
 
-		private EditLanesWizardPage(EventTypeFolderNode root, Collection<LaneDefinition> lanesInput) {
-			super("EditFilterLanesPage"); //$NON-NLS-1$
-			this.root = root;
-			this.lanes = new ArrayList<>(lanesInput);
-			restLane = ensureRestLane(lanes);
+		public List<LaneDefinition> getLanes() {
+			return lanes;
 		}
 
-		@Override
-		public void createControl(Composite parent) {
-			// FIXME: Do we want to group under categories somehow, or just hide the filters that don't have any existing event types.
-			Composite container = new Composite(parent, SWT.NONE);
-			container.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
+        private void init() {
+            // FIXME: Do we want to group under categories somehow, or just hide the filters that don't have any existing event types.
+			this.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());
 
-			Composite laneHeaderContainer = new Composite(container, SWT.NONE);
+			Composite laneHeaderContainer = new Composite(this, SWT.NONE);
 			laneHeaderContainer.setLayout(GridLayoutFactory.swtDefaults().create());
 			laneHeaderContainer.setLayoutData(GridDataFactory.fillDefaults().create());
 
 			// FIXME: Add a duplicate action?
 			IAction moveUpAction = ActionToolkit.action(() -> moveSelected(true), Messages.LANES_MOVE_UP_ACTION,
@@ -143,16 +154,16 @@
 			toolbar.setLayoutData(GridDataFactory.fillDefaults().create());
 
 			Label lanesTitle = new Label(laneHeaderContainer, SWT.NONE);
 			lanesTitle.setText(Messages.LANES_EDITOR_LABEL);
 			lanesTitle.setLayoutData(GridDataFactory.fillDefaults().create());
-			Label filterTitle = new Label(container, SWT.NONE);
+			Label filterTitle = new Label(this, SWT.NONE);
 			filterTitle.setText(Messages.LANES_FILTER_LABEL);
 			filterTitle.setLayoutData(
 					GridDataFactory.fillDefaults().grab(true, false).align(SWT.BEGINNING, SWT.END).create());
 
-			lanesViewer = CheckboxTableViewer.newCheckList(container, SWT.BORDER | SWT.V_SCROLL);
+			lanesViewer = CheckboxTableViewer.newCheckList(this, SWT.BORDER | SWT.V_SCROLL);
 			TableViewerColumn viewerColumn = new TableViewerColumn(lanesViewer, SWT.NONE);
 			viewerColumn.getColumn().setText(Messages.LANES_LANE_COLUMN);
 			viewerColumn.getColumn().setWidth(200);
 			// FIXME: Would like to enable editing by some other means than single-clicking, but seems a bit tricky.
 			viewerColumn.setEditingSupport(new EditingSupport(lanesViewer) {
@@ -269,22 +280,21 @@
 			// FIXME: Add icon
 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, addAction);
 
 			mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, removeAction);
 
-			filterEditor = new TypeFilterBuilder(container, this::onTypeFilterChange);
+			filterEditor = new TypeFilterBuilder(this, this::onTypeFilterChange);
 			filterEditor.setInput(root);
 			filterEditor.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(true, true).create());
+			isDropdownFilter = updateChart != null ? true : false;
 			lanesViewer.getControl().setLayoutData(GridDataFactory.fillDefaults().grab(false, true).create());
 
 			lanesViewer.addSelectionChangedListener(
 					e -> laneSelectionChanges(((IStructuredSelection) e.getSelection()).getFirstElement()));
 			LaneDefinition firstLane = lanes.get(0);
 			lanesViewer.setSelection(new StructuredSelection(firstLane));
-
-			setControl(container);
-		}
+        }
 
 		private void addLane() {
 			int selectIndex = Math.max(0, lanes.indexOf(selected));
 			IItemFilter emptyFilter = ItemFilters.type(Collections.emptySet());
 			LaneDefinition newEmpty = new LaneDefinition(null, false, emptyFilter, false);
@@ -302,10 +312,13 @@
 							NLS.bind(Messages.LANES_EDIT_NOT_ALLOWED_WARNING_DESC, selectedLane.getName()));
 					// FIXME: Can we refresh the filter editor to show that nothing has changed?
 				}
 			}
 			lanesViewer.update(selected, null);
+			if (isDropdownFilter) {
+				updateChart();
+			}
 		}
 
 		private void deleteSelected() {
 			// FIXME: It's currently not possible to delete the last lane
 			int selectIndex = Math.max(0, lanes.indexOf(selected) - 1);
@@ -330,28 +343,53 @@
 			}
 		}
 
 		private void laneSelectionChanges(Object newSelected) {
 			int selectedIndex = lanes.indexOf(newSelected);
-			if (this.selected != newSelected) {
-				saveFilter();
-				this.selected = lanes.get(selectedIndex);
-				if (selected instanceof LaneDefinition) {
-					Types typesFilter;
-					if (((LaneDefinition) selected).getFilter() instanceof Types) {
-						typesFilter = ((Types) ((LaneDefinition) selected).getFilter());
-					} else {
-						typesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),
-								filterEditor.getAllTypes());
+			if (selectedIndex == -1 && isDropdownFilter) {
+				selectedIndex = findLaneDefinitionIndexByName(selected);
+			}
+			saveFilter();
+			this.selected = lanes.get(selectedIndex);
+			if (selected instanceof LaneDefinition) {
+				Types typesFilter;
+				if (((LaneDefinition) selected).getFilter() instanceof Types) {
+					typesFilter = ((Types) ((LaneDefinition) selected).getFilter());
+				} else {
+					typesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),
+							filterEditor.getAllTypes());
+				}
+				filterEditor.selectTypes(typesFilter.getTypes());
+			}
+			if (isDropdownFilter) {
+				updateChart();
+			}
+		}
+
+		private void updateChart() {
+			saveFilter(); // updates the LaneDefinition with the new filter
+			updateChart.run(); // repaints the chart and text canvases
+		}
+		
+		private int findLaneDefinitionIndexByName(Object selected) {
+			int index = -1;
+			if (selected != null) {
+				for (int i = 0; i < lanes.size(); i++) {
+					if (lanes.get(i).getName().equals(((LaneDefinition) selected).getName())) {
+						index = i;
+						break;
 					}
-					filterEditor.selectTypes(typesFilter.getTypes());
 				}
 			}
+			return index;
 		}
 
 		private void saveFilter() {
 			int selectedIndex = lanes.indexOf(selected);
+			if (selectedIndex == -1 && isDropdownFilter) {
+				selectedIndex = findLaneDefinitionIndexByName(selected);
+			}
 			if (selectedIndex >= 0) {
 				LaneDefinition ld = lanes.get(selectedIndex);
 				if (!ld.isRestLane()) {
 					IItemFilter newFilter = ItemFilters
 							.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));
@@ -369,18 +407,41 @@
 					}
 					lanesViewer.refresh();
 				}
 			}
 		}
+	}
+
+	private static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {
+
+		private EditLanesContainer container;
+		protected EventTypeFolderNode root;
+		private List<LaneDefinition> lanes;
+
+		private EditLanesWizardPage(EventTypeFolderNode root, Collection<LaneDefinition> lanesInput) {
+			super("EditFilterLanesPage"); //$NON-NLS-1$
+			this.root = root;
+			this.lanes = new ArrayList<>(lanesInput);
+		}
+
+		public List<LaneDefinition> getLanes() {
+			return lanes;
+		}
+
+		@Override
+		public void createControl(Composite parent) {
+			container = new EditLanesContainer(parent, root, lanes);
+			setControl(container);
+		}
 
 		@Override
 		public boolean performFinish() {
-			saveFilter();
+			container.saveFilter();
 			for (int i = 0; i < lanes.size(); i++) {
 				LaneDefinition ld = lanes.get(i);
-				if (ld.isEnabled() != lanesViewer.getChecked(ld)) {
-					lanes.set(i, new LaneDefinition(ld.name, lanesViewer.getChecked(ld), ld.filter, ld.isRestLane));
+				if (ld.isEnabled() != container.lanesViewer.getChecked(ld)) {
+					lanes.set(i, new LaneDefinition(ld.name, container.lanesViewer.getChecked(ld), ld.filter, ld.isRestLane));
 				}
 			}
 			return true;
 		}
 	}
@@ -432,10 +493,14 @@
 
 		public boolean isRestLane() {
 			return isRestLane;
 		}
 
+		public boolean isEnabledAndNotRestLane() {
+			return enabled && !isRestLane;
+		}
+
 		@Override
 		public void saveTo(IWritableState writableState) {
 			writableState.putString(NAME, name);
 			StateToolkit.writeBoolean(writableState, ENABLED, enabled);
 			StateToolkit.writeBoolean(writableState, IS_REST_LANE, isRestLane);
@@ -471,11 +536,11 @@
 		EventTypeFolderNode root, List<LaneDefinition> lanes, String title, String description) {
 		EditLanesWizardPage page = new EditLanesWizardPage(root, lanes);
 		page.setTitle(title);
 		page.setDescription(description);
 		if (OnePageWizardDialog.open(page, 500, 600) == Window.OK) {
-			return page.lanes.stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());
+			return page.getLanes().stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());
 		}
 		return lanes;
 	}
 
 	private static boolean laneIncludesTypes(LaneDefinition ld) {
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/ThreadGraphLanes.java
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * 
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ *
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  *
@@ -40,10 +40,11 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -59,10 +60,11 @@
 import org.openjdk.jmc.common.item.IItem;
 import org.openjdk.jmc.common.item.IItemCollection;
 import org.openjdk.jmc.common.item.IItemFilter;
 import org.openjdk.jmc.common.item.IItemIterable;
 import org.openjdk.jmc.common.item.ItemFilters;
+import org.openjdk.jmc.common.item.ItemFilters.Types;
 import org.openjdk.jmc.common.unit.IQuantity;
 import org.openjdk.jmc.flightrecorder.JfrAttributes;
 import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;
 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
 import org.openjdk.jmc.flightrecorder.ui.EventTypeFolderNode;
@@ -92,28 +94,48 @@
 	private List<LaneDefinition> naLanes;
 	private Supplier<StreamModel> dataSourceSupplier;
 	private Runnable buildChart;
 	private List<IAction> actions;
 	private String tooltipTitle;
+	private EventTypeFolderNode typeTree;
+	private boolean quickFilterExist;
 
 	public ThreadGraphLanes(Supplier<StreamModel> dataSourceSupplier, Runnable buildChart) {
 		this.dataSourceSupplier = dataSourceSupplier;
 		this.buildChart = buildChart;
 		this.actions = new ArrayList<>();
+		this.quickFilterExist = false;
+		this.typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
+				.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));
+	}
+
+	protected EventTypeFolderNode getTypeTree() {
+		return typeTree;
 	}
 
 	public void openEditLanesDialog(MCContextMenuManager mm, boolean isLegendMenu) {
 		// FIXME: Might there be other interesting events that don't really have duration?
-		EventTypeFolderNode typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
+		typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
 				.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));
 		laneDefs = LaneEditor.openDialog(typeTree, laneDefs.stream().collect(Collectors.toList()),
 				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_TITLE,
 				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_MESSAGE);
 		updateContextMenu(mm, isLegendMenu);
 		buildChart.run();
 	}
 
+	public void openEditLanesDialog(MCContextMenuManager[] mms, boolean isLegendMenu) {
+		// FIXME: Might there be other interesting events that don't really have duration?
+		typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit
+				.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));
+		laneDefs = LaneEditor.openDialog(typeTree, laneDefs.stream().collect(Collectors.toList()),
+				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_TITLE,
+				Messages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_MESSAGE);
+		updateContextMenus(mms, isLegendMenu);
+		buildChart.run();
+	}
+
 	public List<LaneDefinition> getLaneDefinitions() {
 		return laneDefs;
 	}
 
 	private Boolean typeWithThreadAndDuration(IItemIterable itemStream) {
@@ -125,10 +147,24 @@
 				.filter((Predicate<? super LaneDefinition>) LaneDefinition::isEnabled).map(ld -> ld.getFilter())
 				.collect(Collectors.toList());
 		return ItemFilters.or(laneFilters.toArray(new IItemFilter[laneFilters.size()]));
 	}
 
+	/**
+	 * Retrieves the set of lane names that are currently enabled.<br>
+	 * Note: The "Rest lane" is of type ItemFilters$Composite, and cannot be cast to Types, so it
+	 * gets filtered out of the end result.
+	 * 
+	 * @return the enabled lanes independent from the rest lane
+	 */
+	public Set<String> getEnabledLanes() {
+		List<IItemFilter> laneFilters = laneDefs.stream()
+				.filter((Predicate<? super LaneDefinition>) LaneDefinition::isEnabledAndNotRestLane)
+				.map(ld -> ld.getFilter()).collect(Collectors.toList());
+		return ((Types) ItemFilters.or(laneFilters.toArray(new IItemFilter[laneFilters.size()]))).getTypes();
+	}
+
 	private void setTooltipTitle(String description) {
 		this.tooltipTitle = description;
 	}
 
 	private String getTooltipTitle() {
@@ -137,10 +173,44 @@
 
 	private void resetTooltipTitle() {
 		this.tooltipTitle = null;
 	}
 
+	/**
+	 * Introduces a "Quick Filter" to the lane definitions which is controlled by the dropdown lane
+	 * filter. Initially, the enabled activity lanes will be a copy of the currently enabled lanes.
+	 * When initially used, the "Quick Filter" will be the only active lane definition in an attempt
+	 * to preserve the lane activity of the existing lane definitions. The "Quick Filter" is meant
+	 * for easy viewing of activities, and will not be persisted.
+	 */
+	public void useDropdownFilter(LaneDefinition quickFilterDef) {
+		if (quickFilterExist) {
+			for (int i = 0; i < laneDefs.size(); i++) {
+				if (quickFilterDef.getName().equals(laneDefs.get(i).getName())) {
+					laneDefs.remove(laneDefs.get(i));
+					laneDefs.add(i, quickFilterDef);
+				}
+			}
+		} else {
+			for (int i = 0; i < laneDefs.size(); i++) {
+				setLaneDefinitionEnablement(laneDefs.get(i), i, false);
+			}
+			laneDefs.add(0, quickFilterDef);
+			quickFilterExist = true;
+		}
+		buildChart.run();
+	}
+
+	public void buildChart() {
+		buildChart.run();
+	}
+
+	private void setLaneDefinitionEnablement(LaneDefinition oldLd, int laneIndex, boolean isEnabled) {
+		LaneDefinition newLd = new LaneDefinition(oldLd.getName(), isEnabled, oldLd.getFilter(), oldLd.isRestLane());
+		laneDefs.set(laneIndex, newLd);
+	}
+
 	public IXDataRenderer buildThreadRenderer(Object thread, IItemCollection items) {
 		this.resetTooltipTitle();
 		String threadName = thread == null ? "" : ((IMCThread) thread).getThreadName(); //$NON-NLS-1$
 		// FIXME: Workaround since this method can be called from super class constructor. Refactor to avoid this.
 		List<LaneDefinition> laneFilters = this.laneDefs == null ? Collections.emptyList() : this.laneDefs;
@@ -241,12 +311,64 @@
 
 	//create two action identifiers to handle the chart context menu and the legend context menu
 	private List<String> chartActionIdentifiers = new ArrayList<>();
 	private List<String> legendActionIdentifiers = new ArrayList<>();
 
-	public void updateContextMenu(MCContextMenuManager mm, boolean isLegendMenu) {
+	public void updateContextMenus(MCContextMenuManager[] mms, boolean isLegendMenu) {
+		if (isLegendMenu) {
+			for (String id : legendActionIdentifiers) {
+				for (MCContextMenuManager mm : mms) {
+					mm.remove(id);
+				}
+			}
+			legendActionIdentifiers.clear();
+		} else {
+			for (String id : chartActionIdentifiers) {
+				for (MCContextMenuManager mm : mms) {
+					mm.remove(id);
+				}
+			}
+			chartActionIdentifiers.clear();
+		}
+		if (mms[0].indexOf(EDIT_LANES) == -1) {
+			IAction action = ActionToolkit.action(() -> this.openEditLanesDialog(mms, isLegendMenu),
+					Messages.JavaApplicationPage_EDIT_THREAD_LANES_ACTION,
+					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT));
+			action.setId(EDIT_LANES);
+			for (MCContextMenuManager mm : mms) {
+				mm.add(action);
+				mm.add(new Separator());
+			}
+			actions.add(action);
+		}
+		laneDefs.stream().forEach(ld -> {
+			Action checkAction = new Action(ld.getName(), IAction.AS_CHECK_BOX) {
+				int laneIndex = laneDefs.indexOf(ld);
 
+				@Override
+				public void run() {
+					setLaneDefinitionEnablement(ld, laneIndex, isChecked());
+					buildChart.run();
+				}
+			};
+			String identifier = ld.getName() + checkAction.hashCode();
+			checkAction.setId(identifier);
+			if (isLegendMenu) {
+				legendActionIdentifiers.add(identifier);
+			} else {
+				chartActionIdentifiers.add(identifier);
+			}
+			checkAction.setChecked(ld.isEnabled());
+			// FIXME: Add a tooltip here
+			for (MCContextMenuManager mm : mms) {
+				mm.add(checkAction);
+			}
+			actions.add(checkAction);
+		});
+	}
+
+	public void updateContextMenu(MCContextMenuManager mm, boolean isLegendMenu) {
 		if (isLegendMenu) {
 			for (String id : legendActionIdentifiers) {
 				mm.remove(id);
 			}
 			legendActionIdentifiers.clear();
@@ -269,13 +391,11 @@
 			Action checkAction = new Action(ld.getName(), IAction.AS_CHECK_BOX) {
 				int laneIndex = laneDefs.indexOf(ld);
 
 				@Override
 				public void run() {
-					LaneDefinition newLd = new LaneDefinition(ld.getName(), isChecked(), ld.getFilter(),
-							ld.isRestLane());
-					laneDefs.set(laneIndex, newLd);
+					setLaneDefinitionEnablement(ld, laneIndex, isChecked());
 					buildChart.run();
 				}
 			};
 			String identifier = ld.getName() + checkAction.hashCode();
 			checkAction.setId(identifier);
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/common/TypeLabelProvider.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -34,44 +34,89 @@
 
 import java.awt.Color;
 
 import org.openjdk.jmc.common.util.ColorToolkit;
 import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 // May evolve into a label provider
 public class TypeLabelProvider {
 
 	public static Color getColor(String typeId) {
 		switch (typeId) {
-		case JdkTypeIDs.ERRORS_THROWN:
-			return new Color(0xFF0000);
-		case JdkTypeIDs.EXCEPTIONS_THROWN:
-			return new Color(0xC80000);
+		case JdkTypeIDs.RECORDINGS:
+			return Palette.PF_CYAN_300.getAWTColor();
+		case JdkTypeIDs.RECORDING_SETTING:
+			return Palette.PF_GREEN_300.getAWTColor();
+		case JdkTypeIDs.THROWABLES_STATISTICS:
+			return Palette.PF_GOLD_500.getAWTColor();
+		case JdkTypeIDs.BIASED_LOCK_CLASS_REVOCATION:
+			return Palette.PF_PURPLE_400.getAWTColor();
+		case JdkTypeIDs.BIASED_LOCK_REVOCATION:
+			return Palette.PF_LIGHT_GREEN_300.getAWTColor();
+		case JdkTypeIDs.BIASED_LOCK_SELF_REVOCATION:
+			return Palette.PF_LIGHT_GREEN_400.getAWTColor();
 		case JdkTypeIDs.FILE_READ:
-			return new Color(0xBE4422);
+			return Palette.PF_ORANGE_400.getAWTColor();
 		case JdkTypeIDs.FILE_WRITE:
-			return new Color(0x2C689E);
+			return Palette.PF_CYAN_600.getAWTColor();
+		case JdkTypeIDs.ERRORS_THROWN:
+			return Palette.PF_RED_100.getAWTColor();
+		case JdkTypeIDs.EXCEPTIONS_THROWN:
+			return Palette.PF_RED_300.getAWTColor();
 		case JdkTypeIDs.MONITOR_ENTER:
-			return new Color(0xFF6D64);
+			return Palette.PF_ORANGE_200.getAWTColor();
 		case JdkTypeIDs.MONITOR_WAIT:
-			return new Color(0xFFE75B);
+			return Palette.PF_GOLD_200.getAWTColor();
+		case JdkTypeIDs.THREAD_PARK:
+			return Palette.PF_BLACK_500.getAWTColor();
+		case JdkTypeIDs.THREAD_SLEEP:
+			return Palette.PF_BLUE_500.getAWTColor();
+		case JdkTypeIDs.OLD_OBJECT_SAMPLE:
+			return Palette.PF_CYAN_200.getAWTColor();
+		case JdkTypeIDs.SWEEP_CODE_CACHE:
+			return Palette.PF_LIGHT_GREEN_500.getAWTColor();
+		case JdkTypeIDs.SOCKET_READ:
+			return Palette.PF_RED_200.getAWTColor();
+		case JdkTypeIDs.SOCKET_WRITE:
+			return Palette.PF_LIGHT_BLUE_500.getAWTColor();
+		case JdkTypeIDs.CLASS_LOAD:
+			return Palette.PF_PURPLE_100.getAWTColor();
+		case JdkTypeIDs.COMPILATION:
+			return Palette.PF_GOLD_300.getAWTColor();
+		case JdkTypeIDs.GC_PAUSE:
+			return Palette.PF_ORANGE_500.getAWTColor();
+		case JdkTypeIDs.GC_PAUSE_L1:
+			return Palette.PF_GOLD_400.getAWTColor();
+		case JdkTypeIDs.GC_PAUSE_L2:
+			return Palette.PF_BLUE_400.getAWTColor();
+		case JdkTypeIDs.GC_PAUSE_L3:
+			return Palette.PF_PURPLE_300.getAWTColor();
+		case JdkTypeIDs.GC_PAUSE_L4:
+			return Palette.PF_LIGHT_GREEN_600.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_BEGIN:
+			return Palette.PF_PURPLE_200.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_CLEANUP:
+			return Palette.PF_PURPLE_500.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_CLEANUP_TASK:
+			return Palette.PF_BLUE_300.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_END:
+			return Palette.PF_GREEN_400.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_STATE_SYNC:
+			return Palette.PF_LIGHT_GREEN_200.getAWTColor();
+		case JdkTypeIDs.SAFEPOINT_WAIT_BLOCKED:
+			return Palette.PF_GREEN_500.getAWTColor();
+		case JdkTypeIDs.VM_OPERATIONS:
+			return Palette.PF_ORANGE_500.getAWTColor();
 		case JdkTypeIDs.ALLOC_INSIDE_TLAB:
 			return new Color(0xFF8000);
 		case JdkTypeIDs.ALLOC_OUTSIDE_TLAB:
 			return new Color(0x808000);
-		case JdkTypeIDs.SOCKET_READ:
-			return new Color(0xC8321E);
-		case JdkTypeIDs.SOCKET_WRITE:
-			return new Color(0x4678C8);
-		case JdkTypeIDs.THREAD_PARK:
-			return new Color(0x808080);
 		case JdkTypeIDs.JAVA_THREAD_END:
 			return new Color(0x408040);
 		case JdkTypeIDs.JAVA_THREAD_START:
 			return new Color(0x80FF80);
-		case JdkTypeIDs.CLASS_LOAD:
-			return new Color(0x9B81DB);
 		case JdkTypeIDs.CLASS_UNLOAD:
 			return new Color(0x00FF00);
 		case JdkTypeIDs.COMPILER_FAILURE:
 			return new Color(0xE67245);
 		case JdkTypeIDs.GARBAGE_COLLECTION:
@@ -82,30 +127,16 @@
 			return new Color(0xFF8080);
 		case JdkTypeIDs.GC_DETAILED_EVACUATION_FAILED:
 			return new Color(0xFF0000);
 		case JdkTypeIDs.GC_DETAILED_PROMOTION_FAILED:
 			return new Color(0xD04E4E);
-		case JdkTypeIDs.GC_PAUSE:
-			return new Color(0xDC3C00);
-		case JdkTypeIDs.GC_PAUSE_L1:
-			return new Color(0xE6CB45);
-		case JdkTypeIDs.GC_PAUSE_L2:
-			return new Color(0x458AE6);
-		case JdkTypeIDs.GC_PAUSE_L3:
-			return new Color(0xE645E2);
-		case JdkTypeIDs.GC_PAUSE_L4:
-			return new Color(0x85A115);
 		case JdkTypeIDs.EXECUTION_SAMPLE:
 			return new Color(0xCC66FF);
 		case JdkTypeIDs.EXECUTION_SAMPLING_INFO_EVENT_ID:
 			return new Color(0xE6C940);
-		case JdkTypeIDs.VM_OPERATIONS:
-			return new Color(0xBA6F1F);
 		case JdkTypeIDs.PROCESSES:
 			return new Color(0xE37A44);
-		case JdkTypeIDs.COMPILATION:
-			return new Color(0xF7EA2A);
 		case JdkTypeIDs.CONCURRENT_MODE_FAILURE:
 			return new Color(0xFF0000);
 		case JdkTypeIDs.CONTEXT_SWITCH_RATE:
 			return new Color(0x7940E6);
 		case JdkTypeIDs.CPU_INFORMATION:
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/messages/internal/Messages.java
@@ -97,10 +97,12 @@
 	public static String CompilationsPage_COMPILATIONS_TABLE_SELECTION;
 	public static String CompilationsPage_PAGE_NAME;
 	public static String CompilationsPage_ROW_DURATIONS;
 	public static String CompilationsPage_TAB_COMPILATIONS;
 	public static String CompilationsPage_TAB_COMPILATIONS_FAILED;
+	public static String DropdownLaneFilter_QUICK_FILTER;
+	public static String DropdownLaneFilter_THREAD_STATE_SELECTION;
 	public static String DUMP_RECORDING_DEFAULT_TIMESPAN_TO_DUMP;
 	public static String DUMP_RECORDING_NO_DEFAULT;
 	public static String DUMP_RECORDING_TIMESPAN;
 	public static String DUMP_RECORDING_TIMESPAN_LESS_THAN_ZERO;
 	public static String DUMP_RECORDING_TIMESPAN_UNPARSABLE;
@@ -507,13 +509,17 @@
 	public static String TABLECOMPONENT_HISTOGRAM_SELECTION;
 	public static String TABLECOMPONENT_NONE;
 	public static String ThreadDumpsPage_PAGE_NAME;
 	public static String ThreadsPage_EDIT_LANES;
 	public static String ThreadsPage_HIDE_THREAD_ACTION;
+	public static String ThreadsPage_LANE_FILTER_HEADER;
 	public static String ThreadsPage_LANE_TOOLTIP_TITLE;
 	public static String ThreadsPage_NAME;
 	public static String ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
+	public static String ThreadsPage_TABLE_POPUP_DESCRIPTION;
+	public static String ThreadsPage_TABLE_POPUP_TITLE;
+	public static String ThreadsPage_VIEW_THREAD_DETAILS;
 	public static String TlabPage_PAGE_NAME;
 	public static String TlabPage_THREADS_TAB_NAME;
 	public static String TlabPage_METHODS_TAB_NAME;
 	public static String TlabPage_ROW_TLAB_ALLOCATIONS;
 	public static String TlabPage_ROW_TLAB_ALLOCATIONS_DESC;
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndPopupTableUI.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndPopupTableUI.java
--- /dev/null
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndPopupTableUI.java
@@ -0,0 +1,379 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.flightrecorder.ui.pages;
+
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.osgi.util.NLS;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.layout.FillLayout;
+import org.eclipse.swt.layout.FormAttachment;
+import org.eclipse.swt.layout.FormData;
+import org.eclipse.swt.layout.FormLayout;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.ui.forms.widgets.FormToolkit;
+
+import org.openjdk.jmc.common.IState;
+import org.openjdk.jmc.common.IWritableState;
+import org.openjdk.jmc.common.item.IAttribute;
+import org.openjdk.jmc.common.item.IItemCollection;
+import org.openjdk.jmc.common.item.IItemFilter;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.flightrecorder.JfrAttributes;
+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
+import org.openjdk.jmc.flightrecorder.ui.StreamModel;
+import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;
+import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;
+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;
+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
+import org.openjdk.jmc.ui.charts.ChartFilterControlBar;
+import org.openjdk.jmc.ui.charts.IXDataRenderer;
+import org.openjdk.jmc.ui.charts.RendererToolkit;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.common.util.Environment;
+import org.openjdk.jmc.ui.handlers.ActionToolkit;
+import org.openjdk.jmc.ui.misc.ActionUiToolkit;
+import org.openjdk.jmc.ui.misc.ChartCanvas;
+import org.openjdk.jmc.ui.misc.ChartDisplayControlBar;
+import org.openjdk.jmc.ui.misc.ChartLaneHeightControls;
+import org.openjdk.jmc.ui.misc.ChartTextCanvas;
+import org.openjdk.jmc.ui.misc.PersistableSashForm;
+import org.openjdk.jmc.ui.misc.TimelineCanvas;
+
+abstract class ChartAndPopupTableUI extends ChartAndTableUI {
+
+	private static final double Y_SCALE = Display.getCurrent().getDPI().y / Environment.getNormalDPI();
+	private static final String SASH = "sash"; //$NON-NLS-1$
+	private static final String TABLE = "table"; //$NON-NLS-1$
+	private static final String CHART = "chart"; //$NON-NLS-1$
+	private static final String SELECTED = "selected"; //$NON-NLS-1$
+	private static final int TIMELINE_HEIGHT = 40;
+	private static final int X_OFFSET = 0;
+	private static final int Y_OFFSET = 0;
+	protected ChartFilterControlBar filterBar;
+	protected ChartTextCanvas textCanvas;
+	protected ItemHistogram hiddenTable;
+	protected IPageContainer pageContainer;
+	private ChartDisplayControlBar displayBar;
+	private Composite hiddenTableContainer;
+	private IItemCollection selectionItems;
+	private IItemFilter pageFilter;
+	private IRange<IQuantity> timeRange;
+	private TimelineCanvas timelineCanvas;
+	private ChartLaneHeightControls heightBtns;
+
+	ChartAndPopupTableUI(IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit,
+			IPageContainer pageContainer, IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
+			FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
+		super(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,
+				flavorSelectorState, classifier);
+	}
+
+	protected void init(
+		IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,
+		IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
+		FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
+		this.pageFilter = pageFilter;
+		this.model = model;
+		this.pageContainer = pageContainer;
+		form = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);
+
+		hiddenTableContainer = new Composite(form, SWT.NONE);
+		hiddenTableContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		hiddenTableContainer.setVisible(false);
+
+		hiddenTable = buildHistogram(hiddenTableContainer, state.getChild(TABLE), classifier);
+		hiddenTable.getManager().getViewer().addSelectionChangedListener(e -> buildChart());
+
+		tableFilterComponent = FilterComponent.createFilterComponent(hiddenTable.getManager().getViewer().getControl(),
+				hiddenTable.getManager(), tableFilter, model.getItems().apply(pageFilter),
+				pageContainer.getSelectionStore()::getSelections, this::onFilterChange);
+
+		/**
+		 * Scrolled Composite Page Container - Contains all page functionality Chart Container (1
+		 * column gridlayout) - Contains filter bar & graph container Graph Container (2 column
+		 * gridlayout) - Contains chart and timeline container & display bar Chart and Timeline
+		 * Container (1 column gridlayout) Contains chart and text container and timeline canvas
+		 * Timeline and Height Buttons Container (2 column gridlayout) Contains timeline and lane
+		 * height button controls Zoom-pan and Chart Container (formlayout) - Contains chart and
+		 * text container contents and zoom-pan overlay Zoom-pan Container (filllayout) - Contains
+		 * zoom-pan chart overlay Full screen Chart Container (1 column gridlayout) - Contains chart
+		 * container Chart and Text Container (2 column gridlayout) - Contains scText and
+		 * textCanvas) & scChart (and chart canvas)
+		 */
+
+		// Scrolled Composite containing all page functionality
+		ScrolledComposite scPageContainer = new ScrolledComposite(form.getBody(), SWT.H_SCROLL | SWT.V_SCROLL);
+
+		chartContainer = toolkit.createComposite(scPageContainer);
+		chartContainer.setLayout(new GridLayout());
+		chartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+
+		scPageContainer.setContent(chartContainer);
+		scPageContainer.setAlwaysShowScrollBars(false);
+		scPageContainer.setExpandHorizontal(true);
+		scPageContainer.setExpandVertical(true);
+		scPageContainer.addListener(SWT.Resize, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				int width = filterBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).x;
+				int height = filterBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).y
+						+ displayBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;
+				if (width > 0 && height > 0) {
+					scPageContainer.setMinSize(scPageContainer.computeSize(width, height));
+					scPageContainer.removeListener(SWT.Resize, this);
+				}
+			}
+		});
+
+		// Filter Controls
+		Listener resetListener = new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				onSetRange(false);
+			}
+		};
+		filterBar = new ChartFilterControlBar(chartContainer, resetListener, pageContainer.getRecordingRange());
+		filterBar.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
+
+		// Container to hold the chart (& timeline) and display toolbar
+		Composite graphContainer = toolkit.createComposite(chartContainer);
+		GridLayout gridLayout = new GridLayout(2, false);
+		gridLayout.marginWidth = 0;
+		gridLayout.marginHeight = 0;
+		graphContainer.setLayout(gridLayout);
+		graphContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+
+		// Container to hold the chart and timeline canvas
+		Composite chartAndTimelineContainer = toolkit.createComposite(graphContainer);
+		gridLayout = new GridLayout();
+		gridLayout.marginWidth = 0;
+		gridLayout.marginHeight = 0;
+		chartAndTimelineContainer.setLayout(gridLayout);
+		chartAndTimelineContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+
+		// Container to hold the chart and a zoom-pan overlay
+		Composite zoomPanAndChartContainer = toolkit.createComposite(chartAndTimelineContainer);
+		zoomPanAndChartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		zoomPanAndChartContainer.setLayout(new FormLayout());
+
+		// Container to hold fixed zoom-pan display
+		Composite zoomPanContainer = toolkit.createComposite(zoomPanAndChartContainer);
+		zoomPanContainer.setLayout(new FillLayout());
+		FormData fd = new FormData();
+		fd.height = 80;
+		fd.width = 150;
+		fd.bottom = new FormAttachment(100, -12);
+		fd.right = new FormAttachment(100, -12);
+		zoomPanContainer.setLayoutData(fd);
+
+		// Container to hold the chart
+		Composite fullScreenChartContainer = toolkit.createComposite(zoomPanAndChartContainer);
+		fullScreenChartContainer.setLayout(gridLayout);
+		fd = new FormData();
+		fd.right = new FormAttachment(100, -1);
+		fd.top = new FormAttachment(0, 1);
+		fd.left = new FormAttachment(0, 1);
+		fd.bottom = new FormAttachment(100, -1);
+		fullScreenChartContainer.setLayoutData(fd);
+
+		// Container to hold the text and chart canvases
+		Composite chartAndTextContainer = toolkit.createComposite(fullScreenChartContainer);
+		gridLayout = new GridLayout(2, false);
+		gridLayout.horizontalSpacing = 0;
+		gridLayout.marginWidth = 0;
+		gridLayout.marginHeight = 0;
+		chartAndTextContainer.setLayout(gridLayout);
+		chartAndTextContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+
+		sash = new SashForm(chartAndTextContainer, SWT.VERTICAL);
+		sash.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		toolkit.adapt(sash);
+
+		ScrolledComposite scText = new ScrolledComposite(sash, SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL);
+		GridData scTextGd = new GridData(SWT.FILL, SWT.FILL, false, true);
+		scTextGd.widthHint = 180;
+		scText.setLayoutData(scTextGd);
+		textCanvas = new ChartTextCanvas(scText);
+		textCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
+
+		ScrolledComposite scChart = new ScrolledComposite(sash, SWT.BORDER | SWT.V_SCROLL);
+		scChart.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+		chartCanvas = new ChartCanvas(scChart);
+		chartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
+
+		chartCanvas.setTextCanvas(textCanvas);
+		textCanvas.setChartCanvas(chartCanvas);
+
+		scChart.setContent(chartCanvas);
+		scChart.setAlwaysShowScrollBars(true);
+		scChart.setExpandHorizontal(true);
+		scChart.setExpandVertical(true);
+		scText.setContent(textCanvas);
+		scText.setAlwaysShowScrollBars(false);
+		scText.setExpandHorizontal(true);
+		scText.setExpandVertical(true);
+
+		Composite timelineAndHeightBtnsContainer = toolkit.createComposite(chartAndTimelineContainer);
+		gridLayout = new GridLayout(2, false);
+		gridLayout.horizontalSpacing = 0;
+		gridLayout.marginWidth = 0;
+		timelineAndHeightBtnsContainer.setLayout(gridLayout);
+		timelineAndHeightBtnsContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false));
+
+		heightBtns = new ChartLaneHeightControls(timelineAndHeightBtnsContainer, chartCanvas, textCanvas);
+		heightBtns.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));
+
+		timelineCanvas = new TimelineCanvas(timelineAndHeightBtnsContainer, chartCanvas, sash, Y_SCALE);
+		GridData gridData = new GridData(SWT.FILL, SWT.DEFAULT, true, false);
+		gridData.heightHint = (int) (TIMELINE_HEIGHT * Y_SCALE);
+		timelineCanvas.setLayoutData(gridData);
+
+		// add the display bar to the right of the chart scrolled composite
+		displayBar = new ChartDisplayControlBar(graphContainer);
+
+		allChartSeriesActions = initializeChartConfiguration(state);
+		IState chartState = state.getChild(CHART);
+		ActionToolkit.loadCheckState(chartState, allChartSeriesActions.stream());
+		chartLegend = ActionUiToolkit.buildCheckboxViewer(chartContainer, allChartSeriesActions.stream());
+		gridData = new GridData(SWT.FILL, SWT.FILL, false, true);
+		gridData.widthHint = 180;
+		chartLegend.getControl().setLayoutData(gridData);
+		PersistableSashForm.loadState(sash, state.getChild(SASH));
+		DataPageToolkit.createChartTimestampTooltip(chartCanvas);
+
+		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET, Y_OFFSET,
+				timelineCanvas, filterBar, displayBar);
+		DataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);
+		DataPageToolkit.setChart(textCanvas, chart, pageContainer::showSelection);
+		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
+				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
+				chartCanvas.getContextMenu());
+		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
+				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
+				textCanvas.getContextMenu());
+
+		// Wire-up the chart & text canvases to the filter and display bars
+		displayBar.setChart(chart);
+		displayBar.setChartCanvas(chartCanvas);
+		displayBar.setTextCanvas(textCanvas);
+		displayBar.createZoomPan(zoomPanContainer);
+		chartCanvas.setZoomOnClickListener(mouseDown -> displayBar.zoomOnClick(mouseDown));
+		chartCanvas.setZoomToSelectionListener(() -> displayBar.zoomToSelection());
+		timelineCanvas.setChart(chart);
+
+		if (chartState != null) {
+			final String legendSelection = chartState.getAttribute(SELECTED);
+
+			if (legendSelection != null) {
+				allChartSeriesActions.stream().filter(ia -> legendSelection.equals(ia.getId())).findFirst()
+						.ifPresent(a -> chartLegend.setSelection(new StructuredSelection(a)));
+			}
+		}
+
+		flavorSelector = FlavorSelector.itemsWithTimerange(form, pageFilter, model.getItems(), pageContainer,
+				this::onFlavorSelected, this::onSetRange, flavorSelectorState);
+	}
+
+	protected void onFilterChange(IItemFilter filter) {
+		IItemCollection items = getItems();
+		if (tableFilterComponent.isVisible()) {
+			table.show(items.apply(filter));
+			tableFilterComponent.setColor(table.getAllRows().getRowCount());
+		} else if (table != null) {
+			table.show(items);
+		}
+	}
+
+	@Override
+	public void saveTo(IWritableState writableState) {
+		table = getUndisposedTable();
+		super.saveTo(writableState);
+	}
+
+	private void onSetRange(Boolean useRange) {
+		IRange<IQuantity> range = useRange ? timeRange : pageContainer.getRecordingRange();
+		chart.setVisibleRange(range.getStart(), range.getEnd());
+		chart.resetZoomFactor();
+		displayBar.resetZoomScale();
+		buildChart();
+	}
+
+	private void onFlavorSelected(IItemCollection items, IRange<IQuantity> timeRange) {
+		this.selectionItems = items;
+		this.timeRange = timeRange;
+		hiddenTable.show(getItems());
+		if (selectionItems != null) {
+			Object[] tableInput = (Object[]) hiddenTable.getManager().getViewer().getInput();
+			if (tableInput != null) {
+				hiddenTable.getManager().getViewer().setSelection(new StructuredSelection(tableInput));
+			} else {
+				hiddenTable.getManager().getViewer().setSelection(null);
+			}
+		}
+	}
+
+	protected void buildChart() {
+		IXDataRenderer rendererRoot = getChartRenderer(getItems(), getUndisposedTable().getSelection());
+		chartCanvas.replaceRenderer(rendererRoot);
+		textCanvas.replaceRenderer(rendererRoot);
+	}
+
+	private IItemCollection getItems() {
+		return selectionItems != null ? selectionItems.apply(pageFilter) : model.getItems().apply(pageFilter);
+	}
+
+	public void setTimeRange(IRange<IQuantity> range) {
+		this.timeRange = range;
+	}
+
+	protected ItemHistogram getUndisposedTable() {
+		return isDisposed(table) ? hiddenTable : table;
+	}
+
+	private boolean isDisposed(ItemHistogram histogram) {
+		return histogram == null ? true : histogram.getManager().getViewer().getControl().isDisposed();
+	}
+}
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ChartAndTableUI.java
@@ -82,29 +82,38 @@
 
 	private static final String SASH = "sash"; //$NON-NLS-1$
 	private static final String TABLE = "table"; //$NON-NLS-1$
 	private static final String CHART = "chart"; //$NON-NLS-1$
 	private static final String SELECTED = "selected"; //$NON-NLS-1$
-	private final IItemFilter pageFilter;
-	private final StreamModel model;
+	private static final int X_OFFSET = 180;
+	private IItemFilter pageFilter;
+	protected StreamModel model;
 	protected CheckboxTableViewer chartLegend;
-	protected final Form form;
-	protected final Composite chartContainer;
-	protected final ChartCanvas chartCanvas;
-	protected final FilterComponent tableFilterComponent;
-	protected final ItemHistogram table;
-	protected final SashForm sash;
-	private final IPageContainer pageContainer;
+	protected Form form;
+	protected Composite chartContainer;
+	protected ChartCanvas chartCanvas;
+	protected FilterComponent tableFilterComponent;
+	protected ItemHistogram table;
+	protected SashForm sash;
+	private IPageContainer pageContainer;
 	protected List<IAction> allChartSeriesActions;
 	private IItemCollection selectionItems;
 	private IRange<IQuantity> timeRange;
 	protected XYChart chart;
 	protected FlavorSelector flavorSelector;
 
 	ChartAndTableUI(IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit,
 			IPageContainer pageContainer, IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
 			FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
+		init(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,
+				flavorSelectorState, classifier);
+	}
+
+	protected void init(
+		IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,
+		IState state, String sectionTitle, IItemFilter tableFilter, Image icon,
+		FlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {
 		this.pageFilter = pageFilter;
 		this.model = model;
 		this.pageContainer = pageContainer;
 		form = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);
 		sash = new SashForm(form.getBody(), SWT.VERTICAL);
@@ -137,11 +146,11 @@
 		gd.widthHint = 180;
 		chartLegend.getControl().setLayoutData(gd);
 		PersistableSashForm.loadState(sash, state.getChild(SASH));
 		DataPageToolkit.createChartTimestampTooltip(chartCanvas);
 
-		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), 180);
+		chart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET);
 		DataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);
 		SelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,
 				JfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),
 				chartCanvas.getContextMenu());
 		buildChart();
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/pages/ThreadsPage.java
@@ -42,12 +42,19 @@
 import java.util.stream.Stream;
 
 import org.eclipse.jface.action.IAction;
 import org.eclipse.jface.action.Separator;
 import org.eclipse.jface.resource.ImageDescriptor;
+import org.eclipse.jface.viewers.StructuredSelection;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.jface.wizard.WizardPage;
+import org.eclipse.osgi.util.NLS;
 import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
 import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Item;
 import org.eclipse.ui.forms.widgets.FormToolkit;
 import org.openjdk.jmc.common.IMCThread;
 import org.openjdk.jmc.common.IState;
 import org.openjdk.jmc.common.IWritableState;
 import org.openjdk.jmc.common.item.Aggregators;
@@ -68,26 +75,32 @@
 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
 import org.openjdk.jmc.flightrecorder.ui.IPageDefinition;
 import org.openjdk.jmc.flightrecorder.ui.IPageUI;
 import org.openjdk.jmc.flightrecorder.ui.StreamModel;
 import org.openjdk.jmc.flightrecorder.ui.common.AbstractDataPage;
+import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;
 import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;
 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.HistogramSelection;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram.ItemHistogramBuilder;
 import org.openjdk.jmc.flightrecorder.ui.common.ItemRow;
+import org.openjdk.jmc.flightrecorder.ui.common.DropdownLaneFilter;
 import org.openjdk.jmc.flightrecorder.ui.common.ThreadGraphLanes;
 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
+import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
 import org.openjdk.jmc.ui.UIPlugin;
 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 import org.openjdk.jmc.ui.charts.QuantitySpanRenderer;
 import org.openjdk.jmc.ui.charts.RendererToolkit;
 import org.openjdk.jmc.ui.column.ColumnManager.SelectionState;
+import org.openjdk.jmc.ui.column.ColumnMenusFactory;
 import org.openjdk.jmc.ui.column.TableSettings;
 import org.openjdk.jmc.ui.handlers.ActionToolkit;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.wizards.IPerformFinishable;
+import org.openjdk.jmc.ui.wizards.OnePageWizardDialog;
 
 public class ThreadsPage extends AbstractDataPage {
 
 	public static class ThreadsPageFactory implements IDataPageFactory {
 
@@ -152,45 +165,61 @@
 			return null;
 		}, Messages.JavaApplicationPage_COLUMN_THREAD_DURATION,
 				Messages.JavaApplicationPage_COLUMN_THREAD_DURATION_DESC);
 	}
 
-	private class ThreadsPageUi extends ChartAndTableUI {
+	private class ThreadsPageUi extends ChartAndPopupTableUI {
 		private static final String THREADS_TABLE_FILTER = "threadsTableFilter"; //$NON-NLS-1$
 		private static final String HIDE_THREAD = "hideThread"; //$NON-NLS-1$
 		private static final String RESET_CHART = "resetChart"; //$NON-NLS-1$
+		private static final String TABLE = "table"; //$NON-NLS-1$
 		private Boolean isChartMenuActionsInit;
 		private Boolean isChartModified;
 		private Boolean reloadThreads;
-		private IAction hideThreadAction;
+		private IAction hideThreadActionChart;
+		private IAction hideThreadActionText;
 		private IAction resetChartAction;
 		private List<IXDataRenderer> threadRows;
-		private MCContextMenuManager mm;
+		private MCContextMenuManager mmChart;
+		private MCContextMenuManager mmText;
 		private ThreadGraphLanes lanes;
+		private DropdownLaneFilter laneFilter;
 
 		ThreadsPageUi(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
 			super(pageFilter, getDataSource(), parent, toolkit, editor, state, getName(), pageFilter, getIcon(),
 					flavorSelectorState, JfrAttributes.EVENT_THREAD);
-			mm = (MCContextMenuManager) chartCanvas.getContextMenu();
+			mmChart = (MCContextMenuManager) chartCanvas.getContextMenu();
+			mmText = (MCContextMenuManager) textCanvas.getContextMenu();
 			sash.setOrientation(SWT.HORIZONTAL);
-			addActionsToContextMenu(mm);
+			addActionsToContextMenu();
 			// FIXME: The lanes field is initialized by initializeChartConfiguration which is called by the super constructor. This is too indirect for SpotBugs to resolve and should be simplified.
-			lanes.updateContextMenu(mm, false);
-
+			MCContextMenuManager[] mms = {mmChart, mmText};
+			lanes.updateContextMenus(mms, false);
 			form.getToolBarManager()
-					.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mm, false),
+					.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mms, false),
 							Messages.ThreadsPage_EDIT_LANES,
 							FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));
+			form.getToolBarManager()
+					.add(ActionToolkit.action(() -> openViewThreadDetailsDialog(state),
+							Messages.ThreadsPage_VIEW_THREAD_DETAILS,
+							FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_TABLE)));
 			form.getToolBarManager().update(true);
 			chartLegend.getControl().dispose();
+			setupFilterBar();
 			buildChart();
-			table.getManager().setSelectionState(histogramSelectionState);
-			tableFilterComponent.loadState(state.getChild(THREADS_TABLE_FILTER));
 			chart.setVisibleRange(visibleRange.getStart(), visibleRange.getEnd());
 			onFilterChange(tableFilter);
 		}
 
+		private void setupFilterBar() {
+			MCContextMenuManager[] mms = {mmChart, mmText};
+			laneFilter = new DropdownLaneFilter(filterBar, lanes, mms);
+			laneFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+			filterBar.setChart(chart);
+			filterBar.setChartCanvas(chartCanvas);
+		}
+
 		/**
 		 * Hides a thread from the chart and rebuilds the chart
 		 */
 		private void hideThread(Object thread) {
 			if (this.threadRows != null && this.threadRows.size() > 0 && thread instanceof IMCThread) {
@@ -229,27 +258,38 @@
 		}
 
 		/**
 		 * Update the context menu to include actions to hide threads and reset the chart
 		 */
-		private void addActionsToContextMenu(MCContextMenuManager mm) {
-			mm.add(new Separator());
+		private void addActionsToContextMenu() {
+			mmChart.add(new Separator());
+			IAction hideThreadActionChart = ActionToolkit.action(
+					() -> this.hideThread(chartCanvas.getHoveredItemData()), Messages.ThreadsPage_HIDE_THREAD_ACTION,
+					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
+
+			hideThreadActionChart.setId(HIDE_THREAD);
+			this.hideThreadActionChart = hideThreadActionChart;
+			mmChart.add(hideThreadActionChart);
 
-			IAction hideThreadAction = ActionToolkit.action(() -> this.hideThread(chartCanvas.getHoveredItemData()),
+			mmText.add(new Separator());
+			IAction hideThreadActionText = ActionToolkit.action(() -> this.hideThread(textCanvas.getHoveredItemData()),
 					Messages.ThreadsPage_HIDE_THREAD_ACTION,
 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));
-			hideThreadAction.setId(HIDE_THREAD);
-			this.hideThreadAction = hideThreadAction;
-			mm.add(hideThreadAction);
+
+			hideThreadActionText.setId(HIDE_THREAD);
+			this.hideThreadActionText = hideThreadActionText;
+			mmText.add(hideThreadActionText);
 
 			IAction resetChartAction = ActionToolkit.action(() -> this.resetChartToSelection(),
 					Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION,
 					UIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_REFRESH));
 			resetChartAction.setId(RESET_CHART);
 			resetChartAction.setEnabled(this.isChartModified);
 			this.resetChartAction = resetChartAction;
-			mm.add(resetChartAction);
+
+			mmChart.add(resetChartAction);
+			mmText.add(resetChartAction);
 
 			this.isChartMenuActionsInit = true;
 		}
 
 		/**
@@ -261,11 +301,12 @@
 			setResetChartActionEnablement(false);
 			setHideThreadActionEnablement(true);
 		}
 
 		private void setHideThreadActionEnablement(Boolean enabled) {
-			this.hideThreadAction.setEnabled(enabled);
+			this.hideThreadActionChart.setEnabled(enabled);
+			this.hideThreadActionText.setEnabled(enabled);
 		}
 
 		private void setResetChartActionEnablement(Boolean enabled) {
 			this.resetChartAction.setEnabled(enabled);
 		}
@@ -277,26 +318,28 @@
 		}
 
 		@Override
 		protected IXDataRenderer getChartRenderer(IItemCollection itemsInTable, HistogramSelection tableSelection) {
 			List<IXDataRenderer> rows = new ArrayList<>();
-
+			ItemHistogram histogram = getUndisposedTable();
 			IItemCollection selectedItems;
 			HistogramSelection selection;
 			if (tableSelection.getRowCount() == 0) {
 				selectedItems = itemsInTable;
-				selection = table.getAllRows();
+				selection = histogram.getAllRows();
 			} else {
 				selectedItems = tableSelection.getItems();
 				selection = tableSelection;
 			}
 			boolean useDefaultSelection = rows.size() > 1;
 			if (lanes.getLaneDefinitions().stream().anyMatch(a -> a.isEnabled()) && selection.getRowCount() > 0) {
 				if (this.reloadThreads) {
 					this.threadRows = selection
 							.getSelectedRows((object, items) -> lanes.buildThreadRenderer(object, items))
 							.collect(Collectors.toList());
+					chartCanvas.setNumItems(this.threadRows.size());
+					textCanvas.setNumItems(this.threadRows.size());
 					this.isChartModified = false;
 					if (this.isChartMenuActionsInit) {
 						setResetChartActionEnablement(false);
 						setHideThreadActionEnablement(true);
 					}
@@ -328,15 +371,16 @@
 		public void saveTo(IWritableState state) {
 			super.saveTo(state);
 			tableFilterComponent.saveState(state.createChild(THREADS_TABLE_FILTER));
 			lanes.saveTo(state);
 			saveToLocal();
+			Display.getCurrent().setData(NO_INPUT_METHOD, null);
 		}
 
 		private void saveToLocal() {
 			flavorSelectorState = flavorSelector.getFlavorSelectorState();
-			histogramSelectionState = table.getManager().getSelectionState();
+			histogramSelectionState = getUndisposedTable().getManager().getSelectionState();
 			visibleRange = chart.getVisibleRange();
 		}
 
 		@Override
 		protected List<IAction> initializeChartConfiguration(IState state) {
@@ -344,20 +388,92 @@
 			this.isChartModified = false;
 			this.reloadThreads = true;
 			lanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart());
 			return lanes.initializeChartConfiguration(Stream.of(state.getChildren(THREAD_LANE)));
 		}
+
+		private TablePopup tablePopup;
+
+		public void openViewThreadDetailsDialog(IState state) {
+			tablePopup = new TablePopup(state);
+			OnePageWizardDialog.openAndHideCancelButton(tablePopup, 500, 600);
+		}
+
+		private class TablePopup extends WizardPage implements IPerformFinishable {
+
+			private IState state;
+
+			protected TablePopup(IState state) {
+				super("ThreadDetailsPage"); //$NON-NLS-1$
+				this.state = state;
+				setTitle(Messages.ThreadsPage_TABLE_POPUP_TITLE);
+				setDescription(Messages.ThreadsPage_TABLE_POPUP_DESCRIPTION);
+			}
+
+			@Override
+			public void createControl(Composite parent) {
+				table = buildHistogram(parent, state.getChild(TABLE), JfrAttributes.EVENT_THREAD);
+				MCContextMenuManager mm = MCContextMenuManager.create(table.getManager().getViewer().getControl());
+				ColumnMenusFactory.addDefaultMenus(table.getManager(), mm);
+				table.getManager().getViewer().addSelectionChangedListener(e -> buildChart());
+				table.getManager().getViewer()
+						.addSelectionChangedListener(e -> pageContainer.showSelection(table.getSelection().getItems()));
+				SelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), table,
+						NLS.bind(Messages.ChartAndTableUI_HISTOGRAM_SELECTION, getName()), mm);
+				tableFilterComponent = FilterComponent.createFilterComponent(
+						table.getManager().getViewer().getControl(), table.getManager(), tableFilter,
+						model.getItems().apply(pageFilter), pageContainer.getSelectionStore()::getSelections,
+						this::onFilterChangeHelper);
+				mm.add(tableFilterComponent.getShowFilterAction());
+				mm.add(tableFilterComponent.getShowSearchAction());
+				table.getManager().setSelectionState(histogramSelectionState);
+				tableFilterComponent.loadState(state.getChild(THREADS_TABLE_FILTER));
+				onFilterChange(tableFilter);
+
+				if (selectionInput != null) {
+					table.getManager().getViewer().setSelection(new StructuredSelection(selectionInput));
+				}
+
+				Item[] columnWidgets = ((TableViewer) table.getManager().getViewer()).getTable().getColumns();
+				for (Item columWidget : columnWidgets) {
+					columWidget.addListener(SWT.Selection, e -> columnSortChanged());
+				}
+
+				setControl(parent);
+			}
+
+			private void columnSortChanged() {
+				if (!table.getSelection().getItems().hasItems()) {
+					buildChart();
+				}
+			}
+
+			private void onFilterChangeHelper(IItemFilter filter) {
+				onFilterChange(filter);
+			}
+
+			@Override
+			public boolean performFinish() {
+				IItemCollection lastSelection = table.getSelection().getItems();
+				table.show(lastSelection);
+				selectionInput = (Object[]) table.getManager().getViewer().getInput();
+				return true;
+			}
+		}
 	}
 
+	private static final String NO_INPUT_METHOD = "org.eclipse.swt.internal.gtk.noInputMethod"; //$NON-NLS-1$
+	private Object[] selectionInput;
 	private FlavorSelectorState flavorSelectorState;
 	private SelectionState histogramSelectionState;
 	private IItemFilter tableFilter;
 	private IRange<IQuantity> visibleRange;
 
 	public ThreadsPage(IPageDefinition definition, StreamModel model, IPageContainer editor) {
 		super(definition, model, editor);
 		visibleRange = editor.getRecordingRange();
+		Display.getCurrent().setData(NO_INPUT_METHOD, true);
 	}
 
 	@Override
 	public IPageUI display(Composite parent, FormToolkit toolkit, IPageContainer editor, IState state) {
 		return new ThreadsPageUi(parent, toolkit, editor, state);
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties b/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/resources/org/openjdk/jmc/flightrecorder/ui/messages/internal/messages.properties
@@ -102,10 +102,13 @@
 CompilationsPage_TAB_COMPILATIONS=Compilations
 CompilationsPage_TAB_COMPILATIONS_FAILED=Failed Compilations
 CONFIGURATION_EDIT_ACTION=Edit Configuration
 COUNT_COLUMN_NAME=Count
 
+DropdownLaneFilter_QUICK_FILTER=Quick Filter
+DropdownLaneFilter_THREAD_STATE_SELECTION=Thread State Selection
+
 DUMP_RECORDING_DEFAULT_TIMESPAN_TO_DUMP=When double-clicking on a recording in the JVM Browser
 DUMP_RECORDING_TIMESPAN_VALUE=Default time span when dumping the last part of a recording:
 DUMP_RECORDING_TIMESPAN=Dump the last part of the recording
 DUMP_RECORDING_WHOLE=Dump the whole recording
 DUMP_RECORDING_NO_DEFAULT=Show a dump dialog
@@ -490,14 +493,19 @@
 
 ThreadDumpsPage_PAGE_NAME=Thread Dumps
 
 ThreadsPage_EDIT_LANES=Edit Thread Lanes
 ThreadsPage_HIDE_THREAD_ACTION=Hide Thread From The Chart
+ThreadsPage_LANE_FILTER_HEADER=THREAD STATE SELECTION
 # {0} is the thread name, {1} is the lane name
 ThreadsPage_LANE_TOOLTIP_TITLE={0} / {1} Lane
 ThreadsPage_NAME=Threads
 ThreadsPage_RESET_CHART_TO_SELECTION_ACTION=Reset The Chart To Current Selection
+ThreadsPage_VIEW_THREAD_DETAILS=View Thread Details
+ThreadsPage_TABLE_POPUP_DESCRIPTION=Store a thread selection to make a new filter
+ThreadsPage_TABLE_POPUP_TITLE=Thread Details
+
 TlabPage_PAGE_NAME=TLAB Allocations
 TlabPage_THREADS_TAB_NAME=By Threads
 TlabPage_METHODS_TAB_NAME=By Top Methods
 TlabPage_ROW_TLAB_ALLOCATIONS=TLAB Allocations
 TlabPage_ROW_TLAB_ALLOCATIONS_DESC=Data generated from allocation samples. The samples are collected either when acquiring a new thread local allocation buffer (TLAB) or when allocating outside of such buffers.
diff a/application/org.openjdk.jmc.ui/icons/fa-minus-16.png b/application/org.openjdk.jmc.ui/icons/fa-minus-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-minus-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-plus-16.png b/application/org.openjdk.jmc.ui/icons/fa-plus-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-plus-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit-16.png b/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-scale-to-fit-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit.svg b/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-scale-to-fit.svg
@@ -0,0 +1,1 @@
+<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14"><title>Scale-to-fit_option2</title><path d="M10,10.77a.74.74,0,0,1,.21-.53.73.73,0,0,1,.54-.22h3.87a.4.4,0,0,1,.27.11.37.37,0,0,1,.11.27v1.25a.36.36,0,0,1-.11.26.4.4,0,0,1-.27.11H12v2.63a.36.36,0,0,1-.11.26.4.4,0,0,1-.27.11H10.37a.36.36,0,0,1-.26-.11.33.33,0,0,1-.11-.26ZM15,22.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11H12V19.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11H10.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27v3.87a.72.72,0,0,0,.21.53.73.73,0,0,0,.54.22h3.87a.4.4,0,0,0,.27-.11.36.36,0,0,0,.11-.26Zm4-10.75a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11H22v2.63a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11h1.25a.4.4,0,0,0,.27-.11.36.36,0,0,0,.11-.26V10.77a.75.75,0,0,0-.22-.53.73.73,0,0,0-.53-.22H19.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27ZM22.37,19a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27V22H19.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27v1.25a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11h3.88a.75.75,0,0,0,.75-.75V19.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11Z" transform="translate(-10 -10.02)"/></svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-select.svg b/application/org.openjdk.jmc.ui/icons/fa-select.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-select.svg
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 10.1 16.2" style="enable-background:new 0 0 10.1 16.2;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Select</title>
+<g class="st0">
+	<path d="M6.1,10.5l1.8,4.2C8,14.8,8,15,7.9,15.1s-0.2,0.2-0.3,0.3L6,16.1c-0.1,0.1-0.3,0.1-0.4,0s-0.2-0.2-0.3-0.3l-1.7-4l-2.7,2.8
+		c-0.2,0.2-0.4,0.2-0.6,0.1S0,14.4,0,14.2V0.7c0-0.3,0.1-0.4,0.3-0.5s0.4-0.1,0.6,0.1l8.9,9.2C10,9.7,10,9.9,9.9,10.1
+		s-0.3,0.4-0.5,0.4H6.1z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-selection-16.png b/application/org.openjdk.jmc.ui/icons/fa-selection-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-selection-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-in-16.png b/application/org.openjdk.jmc.ui/icons/fa-zoom-in-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-zoom-in-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-in.svg b/application/org.openjdk.jmc.ui/icons/fa-zoom-in.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-zoom-in.svg
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 16.7 16.2" style="enable-background:new 0 0 16.7 16.2;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Zoom-in</title>
+<g class="st0">
+	<path d="M14.9,15.9c-0.1,0.1-0.3,0.2-0.5,0.2S14,16,13.9,15.9l-3.1-3.1c-0.1-0.1-0.2-0.3-0.2-0.5v-0.5c-1.2,0.9-2.5,1.4-4,1.4
+		c-1.2,0-2.3-0.3-3.3-0.9s-1.8-1.4-2.4-2.4S0,7.8,0,6.6s0.3-2.3,0.9-3.3S2.2,1.5,3.2,1s2.1-0.9,3.3-0.9S8.8,0.4,9.8,1
+		s1.8,1.4,2.4,2.4s0.8,2,0.8,3.2c0,1.5-0.5,2.8-1.4,4h0.5c0.2,0,0.4,0.1,0.5,0.2l3.1,3.1c0.1,0.1,0.2,0.3,0.2,0.5s-0.1,0.4-0.2,0.5
+		L14.9,15.9z M10.2,4.5C9.8,3.8,9.3,3.3,8.6,2.9S7.3,2.3,6.5,2.3S5,2.5,4.4,2.9S3.2,3.8,2.8,4.5S2.2,5.8,2.2,6.6s0.2,1.5,0.6,2.1
+		s0.9,1.2,1.5,1.5s1.4,0.6,2.1,0.6s1.5-0.2,2.1-0.6S9.7,9.3,10,8.7s0.6-1.4,0.6-2.1S10.6,5.1,10.2,4.5z M9.5,7.1
+		c0,0.1,0,0.2-0.1,0.3C9.3,7.5,9.2,7.5,9.1,7.5H7.4v1.8c0,0.1,0,0.2-0.1,0.3s-0.2,0-0.3,0H6c-0.1,0-0.2,0-0.3-0.1S5.6,9.3,5.6,9.2
+		V7.5H3.9c-0.1,0-0.2,0-0.3-0.1S3.5,7.2,3.5,7.1v-1c0-0.1,0-0.2,0.1-0.3s0.2-0.1,0.3-0.1h1.8V4c0-0.1,0-0.2,0.1-0.3S5.9,3.6,6,3.6h1
+		c0.1,0,0.2,0,0.3,0.1S7.4,3.9,7.4,4v1.8h1.8c0.1,0,0.2,0,0.3,0.1s0.1,0.2,0.1,0.3v0.9H9.5z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-out-16.png b/application/org.openjdk.jmc.ui/icons/fa-zoom-out-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-zoom-out-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-out.svg b/application/org.openjdk.jmc.ui/icons/fa-zoom-out.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-zoom-out.svg
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 16.3 16.1" style="enable-background:new 0 0 16.3 16.1;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Zoom-out</title>
+<g class="st0">
+	<path d="M14.9,15.9c-0.1,0.1-0.3,0.2-0.5,0.2S14,16,13.9,15.9l-3.1-3.1c-0.1-0.1-0.2-0.3-0.2-0.5v-0.5c-1.2,0.9-2.5,1.4-4,1.4
+		c-1.2,0-2.3-0.3-3.3-0.9s-1.8-1.4-2.4-2.4S0,7.8,0,6.6s0.3-2.3,0.9-3.3S2.2,1.5,3.2,1s2.1-0.9,3.3-0.9S8.8,0.4,9.8,1
+		s1.8,1.4,2.4,2.4s0.8,2,0.8,3.2c0,1.5-0.5,2.8-1.4,4h0.5c0.2,0,0.4,0.1,0.5,0.2l3.1,3.1c0.1,0.1,0.2,0.3,0.2,0.5s-0.1,0.4-0.2,0.5
+		L14.9,15.9z M10.2,4.5C9.8,3.8,9.3,3.3,8.6,2.9S7.3,2.3,6.5,2.3S5,2.5,4.4,2.9S3.2,3.8,2.8,4.5S2.2,5.8,2.2,6.6s0.2,1.5,0.6,2.1
+		s0.9,1.2,1.5,1.5s1.4,0.6,2.1,0.6s1.5-0.2,2.1-0.6S9.7,9.3,10,8.7s0.6-1.4,0.6-2.1S10.6,5.1,10.2,4.5z M9.5,7.1
+		c0,0.1,0,0.2-0.1,0.3C9.3,7.5,9.2,7.5,9.1,7.5H3.9c-0.1,0-0.2,0-0.3-0.1S3.5,7.2,3.5,7.1v-1c0-0.1,0-0.2,0.1-0.3s0.2-0.1,0.3-0.1
+		h5.2c0.1,0,0.2,0,0.3,0.1S9.5,6,9.5,6.1V7.1z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-pan-16.png b/application/org.openjdk.jmc.ui/icons/fa-zoom-pan-16.png
Binary files /dev/null and application/org.openjdk.jmc.ui/icons/fa-zoom-pan-16.png differ
diff a/application/org.openjdk.jmc.ui/icons/fa-zoom-pan.svg b/application/org.openjdk.jmc.ui/icons/fa-zoom-pan.svg
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/icons/fa-zoom-pan.svg
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 viewBox="0 0 16.4 16.2" style="enable-background:new 0 0 16.4 16.2;" xml:space="preserve">
+<style type="text/css">
+	.st0{enable-background:new    ;}
+</style>
+<title>Zoom-pan</title>
+<g class="st0">
+	<path d="M8.5,15.9C8.4,16,8.2,16.1,8,16.1S7.6,16,7.5,15.9L5,13.4c-0.1-0.2-0.2-0.3-0.2-0.5s0.1-0.4,0.2-0.6s0.3-0.2,0.5-0.2h1.6V9
+		H4v1.5c0,0.2-0.1,0.4-0.2,0.5s-0.3,0.2-0.5,0.2S2.9,11.1,2.8,11L0.2,8.6C0.1,8.5,0,8.3,0,8.1s0.1-0.4,0.2-0.6L2.7,5
+		C2.9,4.9,3,4.8,3.2,4.8S3.6,4.9,3.7,5S4,5.4,4,5.6v1.6h3.2V4H5.5C5.3,4,5.1,4,5,3.8S4.8,3.5,4.8,3.3s0-0.4,0.2-0.5l2.5-2.5
+		C7.6,0.2,7.8,0.1,8,0.1s0.4,0.1,0.5,0.2L11,2.8c0.1,0.2,0.2,0.3,0.2,0.5S11.1,3.7,11,3.8S10.7,4,10.5,4H8.9v3.2H12V5.6
+		c0-0.2,0.1-0.4,0.2-0.5s0.3-0.2,0.5-0.2s0.4,0.1,0.5,0.2l2.6,2.4C15.9,7.7,16,7.9,16,8.1s-0.1,0.4-0.2,0.5l-2.5,2.5
+		c-0.2,0.2-0.3,0.2-0.5,0.2s-0.4-0.1-0.5-0.2S12,10.8,12,10.5V9H8.9v3.2h1.6c0.2,0,0.4,0.1,0.5,0.2s0.2,0.3,0.2,0.5
+		s-0.1,0.4-0.2,0.5L8.5,15.9z"/>
+</g>
+</svg>
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/UIPlugin.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -124,10 +124,19 @@
 	public static final String ICON_LOGICAL_PACKAGE = "logical_package_obj.gif"; //$NON-NLS-1$
 
 	// module
 	public static final String ICON_MODULE = "jigsaw-32.png"; //$NON-NLS-1$
 
+	// font awesome
+	public static final String ICON_FA_SCALE_TO_FIT = "fa-scale-to-fit-16.png";
+	public static final String ICON_FA_SELECTION = "fa-selection-16.png";
+	public static final String ICON_FA_ZOOM_IN = "fa-zoom-in-16.png";
+	public static final String ICON_FA_ZOOM_OUT = "fa-zoom-out-16.png";
+	public static final String ICON_FA_ZOOM_PAN = "fa-zoom-pan-16.png";
+	public static final String ICON_FA_PLUS = "fa-plus-16.png";
+	public static final String ICON_FA_MINUS = "fa-minus-16.png";
+
 	// thread
 	public final static String ICON_THREAD_RUNNING = "thread_obj.gif"; //$NON-NLS-1$
 	public final static String ICON_THREAD_SUSPENDED = "threads_obj.gif"; //$NON-NLS-1$
 	public final static String ICON_THREAD_TERMINATED = "threadt_obj.gif"; //$NON-NLS-1$
 	public static final String ICON_THREAD_DEADLOCKED = "live-thread-deadlocked-16.PNG"; //$NON-NLS-1$
@@ -270,10 +279,19 @@
 		registerImage(registry, ICON_PROPERTY_OBJECT, ICON_PROPERTY_OBJECT);
 
 		registerImage(registry, ICON_EXPAND_ALL, ICON_EXPAND_ALL);
 		registerImage(registry, ICON_COLLAPSE_ALL, ICON_COLLAPSE_ALL);
 
+		// font awesome
+		registerImage(registry, ICON_FA_SCALE_TO_FIT, ICON_FA_SCALE_TO_FIT);
+		registerImage(registry, ICON_FA_SELECTION, ICON_FA_SELECTION);
+		registerImage(registry, ICON_FA_ZOOM_IN, ICON_FA_ZOOM_IN);
+		registerImage(registry, ICON_FA_ZOOM_OUT, ICON_FA_ZOOM_OUT);
+		registerImage(registry, ICON_FA_ZOOM_PAN, ICON_FA_ZOOM_PAN);
+		registerImage(registry, ICON_FA_PLUS, ICON_FA_PLUS);
+		registerImage(registry, ICON_FA_MINUS, ICON_FA_MINUS);
+
 		// Threads
 		registerImage(registry, ICON_THREAD_RUNNING, ICON_THREAD_RUNNING);
 		registerImage(registry, ICON_THREAD_SUSPENDED, ICON_THREAD_SUSPENDED);
 		registerImage(registry, ICON_THREAD_TERMINATED, ICON_THREAD_TERMINATED);
 		registerImage(registry, ICON_THREAD_DEADLOCKED, ICON_THREAD_DEADLOCKED);
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/AWTChartToolkit.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -291,10 +291,16 @@
 	}
 
 	public static void drawAxis(
 		Graphics2D ctx, SubdividedQuantityRange range, int axisPos, boolean labelAhead, int labelLimit,
 		boolean vertical) {
+		drawAxis(ctx, range, axisPos, labelAhead, labelLimit, vertical, 0);
+	}
+
+	public static void drawAxis(
+		Graphics2D ctx, SubdividedQuantityRange range, int axisPos, boolean labelAhead, int labelLimit,
+		boolean vertical, int xOffset) {
 		int axisSize = range.getPixelExtent();
 		FontMetrics fm = ctx.getFontMetrics();
 		int textAscent = fm.getAscent();
 		int textYadjust = textAscent / 2;
 		int labelYPos = labelAhead ? axisPos - TICK_SIZE : axisPos + TICK_SIZE + textAscent;
@@ -303,11 +309,11 @@
 		if (vertical) {
 			ctx.drawLine(axisPos, Y_AXIS_TOP_SPACE, axisPos, axisSize - 1);
 			drawUpArrow(ctx, axisPos, Y_AXIS_TOP_SPACE, Math.min(ARROW_SIZE, axisSize - 2));
 			labelSpacing = fm.getHeight() - textAscent;
 		} else {
-			ctx.drawLine(0, axisPos, axisSize - 1, axisPos);
+			ctx.drawLine(0 + xOffset, axisPos, axisSize + xOffset, axisPos);
 			labelSpacing = fm.charWidth(' ') * 2;
 		}
 
 		IRange<IQuantity> firstBucket = QuantityRange.createWithEnd(range.getSubdivider(0), range.getSubdivider(1));
 		IQuantity lastShownTick = null;
@@ -352,18 +358,18 @@
 					if (changeFormatter != null) {
 						label = changeFormatter.formatAdjacent(lastShownTick, range.getSubdivider(i));
 					} else {
 						label = formatter.format(currentTick);
 					}
-					ctx.drawLine(tickPos, axisPos - TICK_LINE, tickPos, axisPos + TICK_LINE);
+					ctx.drawLine(tickPos + xOffset, axisPos - TICK_LINE, tickPos + xOffset, axisPos + TICK_LINE);
 					int textXadjust = fm.stringWidth(label) / 2;
 					// FIXME: Decide if truncated labels should be shown
 //					if ((tickPos + textXadjust) >= axisSize) {
 					if (tickPos >= axisSize) {
 						break;
 					} else if ((tickPos - textXadjust) >= labelLimit) {
-						ctx.drawString(label, tickPos - textXadjust, labelYPos);
+						ctx.drawString(label, tickPos - textXadjust + xOffset, labelYPos);
 						labelLimit = tickPos + textXadjust + labelSpacing;
 						lastShownTick = currentTick;
 					}
 				}
 			}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/ChartFilterControlBar.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/ChartFilterControlBar.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/ChartFilterControlBar.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.charts;
+
+import org.eclipse.jface.resource.JFaceResources;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.misc.ChartCanvas;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+import org.openjdk.jmc.ui.misc.TimeFilter;
+
+public class ChartFilterControlBar extends Composite {
+
+	private static final String THREADS_LABEL = "Threads";
+
+	private TimeFilter timeFilter;
+
+	public ChartFilterControlBar(Composite parent, Listener resetListener, IRange<IQuantity> recordingRange) {
+		super(parent, SWT.NONE);
+		this.setLayout(new GridLayout(3, false));
+		this.setBackground(Palette.getThreadsPageBackgroundColor());
+		Label nameLabel = new Label(this, SWT.CENTER | SWT.HORIZONTAL);
+		nameLabel.setText(THREADS_LABEL);
+		nameLabel.setBackground(Palette.getThreadsPageBackgroundColor());
+		GridData gd = new GridData(SWT.FILL, SWT.CENTER, false, true);
+		gd.widthHint = 180;
+		nameLabel.setLayoutData(gd);
+		nameLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.BANNER_FONT));
+
+		timeFilter = new TimeFilter(this, recordingRange, resetListener);
+		timeFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+	}
+
+	public void setChart(XYChart chart) {
+		timeFilter.setChart(chart);
+	}
+
+	public void setChartCanvas(ChartCanvas canvas) {
+		timeFilter.setChartCanvas(canvas);
+	}
+
+	public void setStartTime(IQuantity startTime) {
+		timeFilter.setStartTime(startTime);
+	}
+
+	public void setEndTime(IQuantity endTime) {
+		timeFilter.setEndTime(endTime);
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/charts/XYChart.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -39,52 +39,85 @@
 import java.awt.geom.Point2D;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.Stack;
 import java.util.function.Consumer;
 
 import org.openjdk.jmc.common.IDisplayable;
 import org.openjdk.jmc.common.unit.IQuantity;
 import org.openjdk.jmc.common.unit.IRange;
 import org.openjdk.jmc.common.unit.QuantitiesToolkit;
 import org.openjdk.jmc.common.unit.QuantityRange;
+import org.openjdk.jmc.common.unit.UnitLookup;
 import org.openjdk.jmc.ui.charts.IChartInfoVisitor.ITick;
+import org.openjdk.jmc.ui.misc.ChartDisplayControlBar;
+import org.openjdk.jmc.ui.misc.TimelineCanvas;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class XYChart {
 	private static final String ELLIPSIS = "..."; //$NON-NLS-1$
 	private static final Color SELECTION_COLOR = new Color(255, 255, 255, 220);
 	private static final Color RANGE_INDICATION_COLOR = new Color(255, 60, 20);
-	private static final int Y_OFFSET = 35;
-	private static final int RANGE_INDICATOR_HEIGHT = 4;
+	private static final int BASE_ZOOM_LEVEL = 100;
+	private static final int RANGE_INDICATOR_HEIGHT = 7;
 	private final IQuantity start;
 	private final IQuantity end;
+	private IQuantity rangeDuration;
 	private IXDataRenderer rendererRoot;
 	private IRenderedRow rendererResult;
 	private final int xOffset;
+	private int yOffset = 35;
 	private final int bucketWidth;
 	// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
 //	private final int ticksPerBucket = 4;
 
 	private IQuantity currentStart;
 	private IQuantity currentEnd;
 
 	private final Set<Object> selectedRows = new HashSet<>();
+	private int axisWidth;
+	private int rowColorCounter;
 	private IQuantity selectionStart;
 	private IQuantity selectionEnd;
 	private SubdividedQuantityRange xBucketRange;
 	private SubdividedQuantityRange xTickRange;
-	private int axisWidth;
+
+	// JFR Threads Page
+	private static final double ZOOM_PAN_FACTOR = 0.05;
+	private static final int ZOOM_PAN_MODIFIER = 2;
+	private double zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;
+	private double currentZoom;
+	private int zoomSteps;
+	private ChartDisplayControlBar displayBar;
+	private ChartFilterControlBar filterBar;
+	private Stack<Integer> modifiedSteps;
+	private TimelineCanvas timelineCanvas;
+	private int longestCharWidth = 0;
 
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot) {
 		this(range.getStart(), range.getEnd(), rendererRoot);
 	}
 
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset) {
 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
 	}
 
+	// JFR Threads Page
+	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset, Integer yOffset,
+			TimelineCanvas timelineCanvas, ChartFilterControlBar filterBar, ChartDisplayControlBar displayBar) {
+		this(range.getStart(), range.getEnd(), rendererRoot, xOffset);
+		this.yOffset = yOffset;
+		this.timelineCanvas = timelineCanvas;
+		this.filterBar = filterBar;
+		this.displayBar = displayBar;
+		this.rangeDuration = range.getExtent();
+		this.currentZoom = BASE_ZOOM_LEVEL;
+		this.isZoomCalculated = false;
+	}
+
 	public XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
 		this(range.getStart(), range.getEnd(), rendererRoot, xOffset, bucketWidth);
 	}
 
 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot) {
@@ -97,21 +130,22 @@
 
 	public XYChart(IQuantity start, IQuantity end, IXDataRenderer rendererRoot, int xOffset, int bucketWidth) {
 		this.rendererRoot = rendererRoot;
 		// Start value must always be strictly less than end
 		assert (start.compareTo(end) < 0);
-		currentStart = start;
+		this.currentStart = start;
 		this.start = start;
-		currentEnd = end;
+		this.currentEnd = end;
 		this.end = end;
 		this.xOffset = xOffset;
 		this.bucketWidth = bucketWidth;
 	}
 
 	public void setRendererRoot(IXDataRenderer rendererRoot) {
 		clearSelection();
 		this.rendererRoot = rendererRoot;
+		longestCharWidth = 0;
 	}
 
 	public IXDataRenderer getRendererRoot() {
 		return rendererRoot;
 	}
@@ -131,96 +165,195 @@
 	public IRange<IQuantity> getSelectionRange() {
 		return (selectionStart != null) && (selectionEnd != null)
 				? QuantityRange.createWithEnd(selectionStart, selectionEnd) : null;
 	}
 
-	public void render(Graphics2D context, int width, int height) {
-		if (width > xOffset && height > Y_OFFSET) {
+	public void renderChart(Graphics2D context, int width, int height) {
+		if (width > xOffset && height > yOffset) {
 			axisWidth = width - xOffset;
 			// FIXME: xBucketRange and xTickRange should be more related, so that each tick is typically an integer number of buckets (or possibly 2.5 buckets).
 			xBucketRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
 			// FIXME: Use bucketWidth * ticksPerBucket instead of hardcoded value?
 			xTickRange = new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, 100);
 			AffineTransform oldTransform = context.getTransform();
 			context.translate(xOffset, 0);
-			doRender(context, height - Y_OFFSET);
+			doRenderChart(context, height - yOffset);
 			context.setTransform(oldTransform);
 		}
 	}
 
+	public void renderTextCanvasText(Graphics2D context, int width, int height) {
+		axisWidth = width;
+		AffineTransform oldTransform = context.getTransform();
+		doRenderTextCanvasText(context, height);
+		context.setTransform(oldTransform);
+	}
+
+	public void renderText(Graphics2D context, int width, int height) {
+		if (width > xOffset && height > yOffset) {
+			axisWidth = xOffset;
+			AffineTransform oldTransform = context.getTransform();
+			doRenderText(context);
+			context.setTransform(oldTransform);
+			axisWidth = width - xOffset;
+		}
+	}
+
 	private void renderRangeIndication(Graphics2D context, int rangeIndicatorY) {
 		// FIXME: Extract the needed functionality from SubdividedQuantityRange
 		SubdividedQuantityRange fullRangeAxis = new SubdividedQuantityRange(start, end, axisWidth, 25);
 		int x1 = (int) fullRangeAxis.getPixel(currentStart);
 		int x2 = (int) Math.ceil(fullRangeAxis.getPixel(currentEnd));
-		if (x1 > 0 || x2 < axisWidth) {
+
+		if (timelineCanvas != null) {
+			timelineCanvas.renderRangeIndicator(x1, x2);
+			updateZoomPanIndicator();
+		} else {
 			context.setPaint(RANGE_INDICATION_COLOR);
 			context.fillRect(x1, rangeIndicatorY, x2 - x1, RANGE_INDICATOR_HEIGHT);
 			context.setPaint(Color.DARK_GRAY);
 			context.drawRect(0, rangeIndicatorY, axisWidth - 1, RANGE_INDICATOR_HEIGHT);
 		}
 	}
 
-	private void doRender(Graphics2D context, int axisHeight) {
+	public void updateZoomPanIndicator() {
+		if (displayBar != null) {
+			displayBar.updateZoomPanIndicator();
+		}
+	}
+
+	private IRenderedRow getRendererResult(Graphics2D context, int axisHeight) {
+		if (xBucketRange == null) {
+			xBucketRange = getXBucketRange();
+		}
+		return rendererRoot.render(context, xBucketRange, axisHeight);
+	}
+
+	private SubdividedQuantityRange getXBucketRange() {
+		return new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);
+	}
+
+	private void doRenderChart(Graphics2D context, int axisHeight) {
+		rowColorCounter = 0;
 		context.setPaint(Color.LIGHT_GRAY);
 		AWTChartToolkit.drawGrid(context, xTickRange, axisHeight, false);
 		// Attempt to make graphs so low they cover the axis show by drawing the full axis first ...
 		context.setPaint(Color.BLACK);
-		AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);
+		if (timelineCanvas != null) {
+			timelineCanvas.setXTickRange(xTickRange);
+		} else {
+			AWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);
+		}
 		// ... then the graph ...
-		rendererResult = rendererRoot.render(context, xBucketRange, axisHeight);
+		rendererResult = getRendererResult(context, axisHeight);
 		AffineTransform oldTransform = context.getTransform();
-		renderText(context, rendererResult);
+
 		context.setTransform(oldTransform);
 		if (!selectedRows.isEmpty()) {
-			renderSelection(context, rendererResult);
+			renderSelectionChart(context, rendererResult);
 			context.setTransform(oldTransform);
 		}
 		// .. and finally a semitransparent axis line again.
 		context.setPaint(new Color(0, 0, 0, 64));
 		context.drawLine(0, axisHeight - 1, axisWidth - 1, axisHeight - 1);
 		renderRangeIndication(context, axisHeight + 25);
 	}
 
-	private void renderSelection(Graphics2D context, IRenderedRow row) {
+	private void doRenderText(Graphics2D context) {
+		AffineTransform oldTransform = context.getTransform();
+		rowColorCounter = -1;
+		renderText(context, rendererResult);
+		context.setTransform(oldTransform);
+	}
+
+	private void doRenderTextCanvasText(Graphics2D context, int height) {
+		if (rendererResult == null) {
+			rendererResult = getRendererResult(context, height - yOffset);
+		}
+		AffineTransform oldTransform = context.getTransform();
+		rowColorCounter = 0;
+		renderText(context, rendererResult);
+		context.setTransform(oldTransform);
+		if (!selectedRows.isEmpty()) {
+			renderSelectionText(context, rendererResult);
+			context.setTransform(oldTransform);
+		}
+	}
+
+	private void renderSelectionText(Graphics2D context, IRenderedRow row) {
+		if (selectedRows.contains(row.getPayload())) {
+			if (row.getHeight() != rendererResult.getHeight()) {
+				Color highlight = new Color(0, 206, 209, 20);
+				context.setColor(highlight);
+				context.fillRect(0, 0, axisWidth, row.getHeight());
+			} else {
+				selectedRows.clear();
+			}
+		} else {
+			List<IRenderedRow> subdivision = row.getNestedRows();
+			if (subdivision.isEmpty()) {
+				dimRect(context, 0, axisWidth, row.getHeight());
+			} else {
+				for (IRenderedRow nestedRow : row.getNestedRows()) {
+					renderSelectionText(context, nestedRow);
+				}
+				return;
+			}
+		}
+		context.translate(0, row.getHeight());
+	}
+
+	private void renderSelectionChart(Graphics2D context, IRenderedRow row) {
 		if (selectedRows.contains(row.getPayload())) {
 			renderSelection(context, xBucketRange, row.getHeight());
 		} else {
 			List<IRenderedRow> subdivision = row.getNestedRows();
 			if (subdivision.isEmpty()) {
 				dimRect(context, 0, axisWidth, row.getHeight());
 			} else {
 				for (IRenderedRow nestedRow : row.getNestedRows()) {
-					renderSelection(context, nestedRow);
+					renderSelectionChart(context, nestedRow);
 				}
 				return;
 			}
 		}
 		context.translate(0, row.getHeight());
 	}
 
+	// Paint the background of every-other row in a slightly different shade
+	// to better differentiate the thread lanes from one another
+	private void paintRowBackground(Graphics2D context, int height) {
+		if (rowColorCounter >= 0) {
+			if (rowColorCounter % 2 == 0) {
+				context.setColor(Palette.PF_BLACK_100.getAWTColor());
+			} else {
+				context.setColor(Palette.PF_BLACK_200.getAWTColor());
+			}
+			context.fillRect(0, 0, axisWidth, height);
+			rowColorCounter++;
+		}
+	}
+
 	private void renderText(Graphics2D context, IRenderedRow row) {
 		String text = row.getName();
 		int height = row.getHeight();
 		if (height >= context.getFontMetrics().getHeight()) {
 			if (text != null) {
+				paintRowBackground(context, row.getHeight());
 				context.setColor(Color.BLACK);
-				int y;
-				if (height > 40) {
-					context.drawLine(-xOffset, height - 1, -15, height - 1);
-					y = height - context.getFontMetrics().getHeight() / 2;
-				} else {
-					// draw the string in the middle of the row
-					y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();
-				}
+				context.drawLine(0, height - 1, axisWidth - 15, height - 1);
+				int y = ((height - context.getFontMetrics().getHeight()) / 2) + context.getFontMetrics().getAscent();
 				int charsWidth = context.getFontMetrics().charsWidth(text.toCharArray(), 0, text.length());
-				if (charsWidth > xOffset) {
+				if (charsWidth > longestCharWidth) {
+					longestCharWidth = charsWidth;
+				}
+				if (xOffset > 0 && charsWidth > xOffset) {
 					float fitRatio = ((float) xOffset) / (charsWidth
 							+ context.getFontMetrics().charsWidth(ELLIPSIS.toCharArray(), 0, ELLIPSIS.length()));
 					text = text.substring(0, ((int) (text.length() * fitRatio)) - 1) + ELLIPSIS;
 				}
-				context.drawString(text, -xOffset + 2, y);
+				context.drawString(text, 2, y);
 			} else {
 				List<IRenderedRow> subdivision = row.getNestedRows();
 				if (!subdivision.isEmpty()) {
 					for (IRenderedRow nestedRow : row.getNestedRows()) {
 						renderText(context, nestedRow);
@@ -230,17 +363,29 @@
 			}
 		}
 		context.translate(0, height);
 	}
 
+	/**
+	 * Get the longest character width of a thread name to be rendered
+	 * 
+	 * @return the character width of longest thread name
+	 */
+	public int getLongestCharWidth() {
+		return longestCharWidth;
+	}
+
 	/**
 	 * Pan the view.
 	 *
 	 * @param rightPercent
 	 * @return true if the bounds changed. That is, if a redraw is required.
 	 */
 	public boolean pan(int rightPercent) {
+		if (rangeDuration != null) {
+			return panRange(Integer.signum(rightPercent));
+		}
 		if (xBucketRange != null) {
 			IQuantity oldStart = currentStart;
 			IQuantity oldEnd = currentEnd;
 			if (rightPercent > 0) {
 				currentEnd = QuantitiesToolkit
@@ -257,17 +402,56 @@
 		}
 		// Return true since a redraw forces creation of xBucketRange.
 		return true;
 	}
 
+	/**
+	 * Pan the view at a rate relative the current zoom level.
+	 * 
+	 * @param panDirection
+	 *            -1 to pan left, 1 to pan right
+	 * @return true if the chart needs to be redrawn
+	 */
+	public boolean panRange(int panDirection) {
+		if (zoomSteps == 0 || panDirection == 0 || (currentStart.compareTo(start) == 0 && panDirection == -1)
+				|| (currentEnd.compareTo(end) == 0 && panDirection == 1)) {
+			return false;
+		}
+
+		IQuantity panDiff = rangeDuration.multiply(panDirection * zoomPanPower);
+		IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(panDiff);
+		IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(panDiff);
+
+		// if panning would flow over the recording range start or end time,
+		// calculate the difference and add it so the other side.
+		if (newStart.compareTo(start) < 0) {
+			IQuantity diff = start.subtract(newStart);
+			newStart = start;
+			newEnd = newEnd.add(diff);
+		} else if (newEnd.compareTo(end) > 0) {
+			IQuantity diff = newEnd.subtract(end);
+			newStart = newStart.add(diff);
+			newEnd = end;
+		}
+		currentStart = newStart;
+		currentEnd = newEnd;
+		filterBar.setStartTime(currentStart);
+		filterBar.setEndTime(currentEnd);
+		isZoomCalculated = true;
+		return true;
+	}
+
 	/**
 	 * Zoom the view.
 	 *
 	 * @param zoomInSteps
 	 * @return true if the bounds changed. That is, if a redraw is required.
 	 */
 	public boolean zoom(int zoomInSteps) {
+		if (rangeDuration != null) {
+			return zoomRange(zoomInSteps);
+		}
 		return zoomXAxis(axisWidth / 2, zoomInSteps);
 	}
 
 	/**
 	 * Zoom the view.
@@ -278,10 +462,11 @@
 	 */
 	public boolean zoom(int x, int zoomInSteps) {
 		return zoomXAxis(x - xOffset, zoomInSteps);
 	}
 
+	// Default zoom mechanics
 	private boolean zoomXAxis(int x, int zoomInSteps) {
 		if (xBucketRange == null) {
 			// Return true since a redraw forces creation of xBucketRange.
 			return true;
 		}
@@ -297,11 +482,193 @@
 			return (currentStart.compareTo(oldStart) != 0) || (currentEnd.compareTo(oldEnd) != 0);
 		}
 		return false;
 	}
 
+	/**
+	 * Zoom to a specific step count
+	 * 
+	 * @param zoomToStep
+	 *            the desired end zoom step amount
+	 * @return true if a redraw is required as a result of a successful zoom
+	 */
+	public boolean zoomToStep(int zoomToStep) {
+		if (zoomToStep == 0) {
+			resetTimeline();
+			return true;
+		} else {
+			return zoomRange(zoomToStep - zoomSteps);
+		}
+	}
+
+	/**
+	 * Zoom based on a percentage of the recording range
+	 * 
+	 * @param zoomInSteps
+	 *            the amount of desired steps to take
+	 * @return true if a redraw is required as a result of a successful zoom
+	 */
+	private boolean zoomRange(int steps) {
+		if (steps == 0) {
+			return false;
+		} else if (steps > 0) {
+			zoomIn(steps);
+		} else {
+			zoomOut(steps);
+		}
+		// set displayBar text
+		displayBar.setZoomPercentageText(currentZoom);
+		return true;
+	}
+
+	/**
+	 * Zoom into the chart at a rate of 5% of the overall recording range at each step. If the chart
+	 * is zoomed in far enough such that one more step at 5% is not possible, the zoom power is
+	 * halved and the zoom will proceed. <br>
+	 * Every time the zoom power is halved, the instigating step value is pushed onto the
+	 * modifiedSteps stack. This stack is consulted on zoom out events in order to ensure the chart
+	 * zooms out the same way it was zoomed in.
+	 */
+	private void zoomIn(int steps) {
+		do {
+			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);
+			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);
+			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);
+			if (newStart.compareTo(newEnd) >= 0) { // adjust the zoom factor
+				if (modifiedSteps == null) {
+					modifiedSteps = new Stack<Integer>();
+				}
+				modifiedSteps.push(zoomSteps);
+				zoomPanPower = zoomPanPower / ZOOM_PAN_MODIFIER;
+				zoomDiff = rangeDuration.multiply(zoomPanPower);
+				newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);
+				newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);
+			}
+			currentZoom = currentZoom + (zoomPanPower * ZOOM_PAN_MODIFIER * 100);
+			isZoomCalculated = true;
+			zoomSteps++;
+			setVisibleRange(newStart, newEnd);
+			steps--;
+		} while (steps > 0);
+	}
+
+	/**
+	 * Zoom out of the chart at a rate equal to the how the chart was zoomed in.
+	 */
+	private void zoomOut(int steps) {
+		do {
+			if (modifiedSteps != null && modifiedSteps.size() > 0 && modifiedSteps.peek() == zoomSteps) {
+				modifiedSteps.pop();
+				zoomPanPower = zoomPanPower * ZOOM_PAN_MODIFIER;
+			}
+			IQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);
+			IQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);
+			IQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(zoomDiff);
+
+			// if zooming out would flow over the recording range start or end time,
+			// calculate the difference and add it to the other side.
+			if (newStart.compareTo(start) < 0) {
+				IQuantity diff = start.subtract(newStart);
+				newStart = start;
+				newEnd = newEnd.add(diff);
+			} else if (newEnd.compareTo(end) > 0) {
+				IQuantity diff = newEnd.subtract(end);
+				newStart = newStart.subtract(diff);
+				newEnd = end;
+			}
+			currentZoom = currentZoom - (zoomPanPower * ZOOM_PAN_MODIFIER * 100);
+			if (currentZoom < BASE_ZOOM_LEVEL) {
+				currentZoom = BASE_ZOOM_LEVEL;
+			}
+			isZoomCalculated = true;
+			zoomSteps--;
+			setVisibleRange(newStart, newEnd);
+			steps++;
+		} while (steps < 0);
+	}
+
+	// need to check from ChartAndPopupTableUI if not using the OG start/end position,
+	// will have to calculate the new zoom level
+	public void resetZoomFactor() {
+		zoomSteps = 0;
+		zoomPanPower = ZOOM_PAN_FACTOR / ZOOM_PAN_MODIFIER;
+		currentZoom = BASE_ZOOM_LEVEL;
+		displayBar.setZoomPercentageText(currentZoom);
+		modifiedSteps = new Stack<Integer>();
+	}
+
+	/**
+	 * Reset the visible range to be the recording range, and reset the zoom-related objects
+	 */
+	public void resetTimeline() {
+		resetZoomFactor();
+		setVisibleRange(start, end);
+	}
+
+	private void selectionZoom(IQuantity newStart, IQuantity newEnd) {
+		double percentage = calculateZoom(newStart, newEnd);
+		zoomSteps = calculateZoomSteps(percentage);
+		currentZoom = BASE_ZOOM_LEVEL + (percentage * 100);
+		displayBar.setScaleValue(zoomSteps);
+		displayBar.setZoomPercentageText(currentZoom);
+	}
+
+	/**
+	 * When a drag-select zoom occurs, use the new range value to determine how many steps have been
+	 * taken, and adjust zoomSteps and zoomPower accordingly
+	 */
+	private double calculateZoom(IQuantity newStart, IQuantity newEnd) {
+		// calculate the new visible range, and it's percentage of the total range
+		IQuantity newRange = newEnd.in(UnitLookup.EPOCH_NS).subtract(newStart.in(UnitLookup.EPOCH_NS));
+		return 1 - (newRange.longValue() / (double) rangeDuration.in(UnitLookup.NANOSECOND).longValue());
+	}
+
+	/**
+	 * Calculate the number of steps required to achieve the passed zoom percentage
+	 */
+	private int calculateZoomSteps(double percentage) {
+		int steps = (int) Math.floor(percentage / ZOOM_PAN_FACTOR);
+		double tempPercent = steps * ZOOM_PAN_FACTOR;
+
+		if (tempPercent < percentage) {
+			if (percentage > 1 - ZOOM_PAN_FACTOR) {
+				double factor = ZOOM_PAN_FACTOR;
+				do {
+					factor = factor / ZOOM_PAN_MODIFIER;
+					tempPercent = tempPercent + factor;
+					if (modifiedSteps == null) {
+						modifiedSteps = new Stack<Integer>();
+					}
+					if (modifiedSteps.size() == 0 || modifiedSteps.peek() < steps) {
+						modifiedSteps.push(steps);
+					}
+					steps++;
+				} while (tempPercent <= percentage);
+				zoomPanPower = factor / ZOOM_PAN_MODIFIER;
+			} else {
+				steps++;
+			}
+		}
+		return steps;
+	}
+
+	private boolean isZoomCalculated;
+	private boolean isZoomPanDrag;
+
+	public void setIsZoomPanDrag(boolean isZoomPanDrag) {
+		this.isZoomPanDrag = isZoomPanDrag;
+	}
+
+	private boolean getIsZoomPanDrag() {
+		return isZoomPanDrag;
+	}
+
 	public void setVisibleRange(IQuantity rangeStart, IQuantity rangeEnd) {
+		if (rangeDuration != null && !isZoomCalculated && !getIsZoomPanDrag()) {
+			selectionZoom(rangeStart, rangeEnd);
+		}
+		isZoomCalculated = false;
 		rangeStart = QuantitiesToolkit.max(rangeStart, start);
 		rangeEnd = QuantitiesToolkit.min(rangeEnd, end);
 		if (rangeStart.compareTo(rangeEnd) < 0) {
 			SubdividedQuantityRange testRange = new SubdividedQuantityRange(rangeStart, rangeEnd, 10000, 1);
 			if (testRange.getQuantityAtPixel(0).compareTo(testRange.getQuantityAtPixel(1)) < 0) {
@@ -310,10 +677,14 @@
 			} else {
 				// Ensures that zoom out is always allowed
 				currentStart = QuantitiesToolkit.min(rangeStart, currentStart);
 				currentEnd = QuantitiesToolkit.max(rangeEnd, currentEnd);
 			}
+			if (filterBar != null) {
+				filterBar.setStartTime(currentStart);
+				filterBar.setEndTime(currentEnd);
+			}
 			rangeListeners.stream().forEach(l -> l.accept(getVisibleRange()));
 		}
 	}
 
 	private List<Consumer<IRange<IQuantity>>> rangeListeners = new ArrayList<>();
@@ -330,34 +701,36 @@
 	public void clearVisibleRange() {
 		currentStart = start;
 		currentEnd = end;
 	}
 
-	public boolean select(int x1, int x2, int y1, int y2) {
-		int xStart = Math.min(x1, x2) - xOffset;
-		int xEnd = Math.max(x1, x2) - xOffset;
+	public boolean select(int x1, int x2, int y1, int y2, boolean clear) {
+		int xStart = Math.min(x1, x2);
+		int xEnd = Math.max(x1, x2);
 
-		if (xBucketRange != null && (xEnd >= 0)) {
-			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart)), xBucketRange.getQuantityAtPixel(xEnd),
-					y1, y2);
+		if (xBucketRange != null && (xEnd != xStart) && xEnd - xOffset >= 0) {
+			return select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart - xOffset)),
+					xBucketRange.getQuantityAtPixel(xEnd - xOffset), y1, y2, clear);
 		} else {
-			return select(null, null, y1, y2);
+			return select(null, null, y1, y2, clear);
 		}
 	}
 
-	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2) {
+	public boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2, boolean clear) {
 		if (xStart != null && xStart.compareTo(start) < 0) {
 			xStart = start;
 		}
 		if (xEnd != null && xEnd.compareTo(end) > 0) {
 			xEnd = end;
 		}
 		Set<Object> oldRows = null;
 		if (QuantitiesToolkit.same(selectionStart, xStart) && QuantitiesToolkit.same(selectionEnd, xEnd)) {
 			oldRows = new HashSet<>(selectedRows);
 		}
-		selectedRows.clear();
+		if (clear) {
+			selectedRows.clear();
+		}
 		addSelectedRows(rendererResult, 0, Math.min(y1, y2), Math.max(y1, y2));
 		selectionStart = xStart;
 		selectionEnd = xEnd;
 		return (oldRows == null) || !oldRows.equals(selectedRows);
 	}
@@ -391,11 +764,15 @@
 	}
 
 	private boolean addPayload(IRenderedRow row) {
 		Object payload = row.getPayload();
 		if (payload != null) {
-			selectedRows.add(payload);
+			if (selectedRows.contains(payload)) { // ctrl+click deselection
+				selectedRows.remove(payload);
+			} else {
+				selectedRows.add(payload);
+			}
 			return true;
 		}
 		return false;
 	}
 
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartCanvas.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -30,31 +30,33 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package org.openjdk.jmc.ui.misc;
 
-import java.awt.Color;
 import java.awt.Graphics2D;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.function.Consumer;
 
 import org.eclipse.jface.action.IMenuManager;
 import org.eclipse.jface.util.IPropertyChangeListener;
 import org.eclipse.jface.util.PropertyChangeEvent;
 import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
 import org.eclipse.swt.events.FocusEvent;
 import org.eclipse.swt.events.FocusListener;
 import org.eclipse.swt.events.KeyEvent;
 import org.eclipse.swt.events.KeyListener;
 import org.eclipse.swt.events.MouseAdapter;
 import org.eclipse.swt.events.MouseEvent;
 import org.eclipse.swt.events.MouseMoveListener;
 import org.eclipse.swt.events.MouseTrackListener;
 import org.eclipse.swt.events.PaintEvent;
 import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Cursor;
 import org.eclipse.swt.graphics.GC;
 import org.eclipse.swt.graphics.Point;
 import org.eclipse.swt.graphics.Rectangle;
 import org.eclipse.swt.widgets.Canvas;
 import org.eclipse.swt.widgets.Composite;
@@ -70,21 +72,28 @@
 import org.openjdk.jmc.ui.charts.IXDataRenderer;
 import org.openjdk.jmc.ui.charts.XYChart;
 import org.openjdk.jmc.ui.common.util.Environment;
 import org.openjdk.jmc.ui.common.util.Environment.OSType;
 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
 
 public class ChartCanvas extends Canvas {
+	private static final int DEFAULT_LANE_HEIGHT = 50;
+	private int laneHeight = DEFAULT_LANE_HEIGHT;
+	private int minLaneheight = 20;
 	private int lastMouseX = -1;
 	private int lastMouseY = -1;
 	private List<Rectangle2D> highlightRects;
 	private Object hoveredItemData;
 
 	private class Selector extends MouseAdapter implements MouseMoveListener, MouseTrackListener {
 
 		int selectionStartX = -1;
 		int selectionStartY = -1;
+		Point highlightSelectionStart;
+		Point highlightSelectionEnd;
+		Point lastSelection;
 		boolean selectionIsClick = false;
 
 		@Override
 		public void mouseDown(MouseEvent e) {
 			/*
@@ -101,15 +110,52 @@
 			 * The code below instead relies on ignoring mouse down events when SWT.MOD4 is
 			 * depressed. Since MOD4 is CTRL on OS X and 0 on all other current platforms, this
 			 * suffices. Except for an additional platform check, this approach is also used in
 			 * org.eclipse.swt.custom.StyledText.handleMouseDown(Event).
 			 */
-			if ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0)) {
+			if ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0) && ((e.stateMask & SWT.CTRL) == 0)
+					&& ((e.stateMask & SWT.SHIFT) == 0)) {
 				selectionStartX = e.x;
 				selectionStartY = e.y;
+				highlightSelectionEnd = new Point(-1, -1);
+				lastSelection = new Point(-1, -1);
 				selectionIsClick = true;
 				toggleSelect(selectionStartX, selectionStartY);
+			} else if (((e.stateMask & SWT.CTRL) != 0) && (e.button == 1)) {
+				select(e.x, e.x, e.y, e.y, false);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			} else if (((e.stateMask & SWT.SHIFT) != 0) && (e.button == 1)) {
+				if (highlightSelectionEnd.y == -1) {
+					highlightSelectionEnd = new Point(e.x, e.y);
+					lastSelection = highlightSelectionEnd;
+					if (highlightSelectionStart.y > highlightSelectionEnd.y) {
+						Point temp = highlightSelectionStart;
+						highlightSelectionStart = highlightSelectionEnd;
+						highlightSelectionEnd = temp;
+					}
+				} else {
+					if (e.y > highlightSelectionStart.y && e.y < highlightSelectionEnd.y) {
+						if (e.y < lastSelection.y) {
+							highlightSelectionEnd = new Point(e.x, e.y);
+						} else if (e.y > lastSelection.y) {
+							highlightSelectionStart = new Point(e.x, e.y);
+						}
+					} else if (e.y < highlightSelectionStart.y) {
+						highlightSelectionStart = new Point(e.x, e.y);
+						lastSelection = highlightSelectionStart;
+					} else if (e.y > highlightSelectionEnd.y) {
+						highlightSelectionEnd = new Point(e.x, e.y);
+						lastSelection = highlightSelectionEnd;
+					}
+				}
+				select(highlightSelectionStart.x, highlightSelectionEnd.x, highlightSelectionStart.y,
+						highlightSelectionEnd.y, true);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
 			}
 		}
 
 		@Override
 		public void mouseMove(MouseEvent e) {
@@ -129,22 +175,29 @@
 			if (selectionIsClick && ((Math.abs(x - selectionStartX) > 3) || (Math.abs(y - selectionStartY) > 3))) {
 				selectionIsClick = false;
 			}
 			if (!selectionIsClick) {
 				select((int) (selectionStartX / xScale), (int) (x / xScale), (int) (selectionStartY / yScale),
-						(int) (y / yScale));
+						(int) (y / yScale), true);
 			}
 		}
 
 		@Override
 		public void mouseUp(MouseEvent e) {
 			if (selectionStartX >= 0 && (e.button == 1)) {
 				updateSelectionState(e);
+				highlightSelectionStart = new Point(selectionStartX, selectionStartY);
 				selectionStartX = -1;
 				selectionStartY = -1;
+				if (selectionIsClick) {
+					notifyZoomOnClickListener(e.button);
+				}
 				if (selectionListener != null) {
 					selectionListener.run();
+					if (zoomToSelectionListener != null && !selectionIsClick) {
+						zoomToSelectionListener.run();
+					}
 				}
 			}
 		}
 
 		@Override
@@ -162,21 +215,43 @@
 		@Override
 		public void mouseHover(MouseEvent e) {
 		}
 	}
 
+	private int numItems = 0;
+
+	public void setNumItems(int numItems) {
+		this.numItems = numItems;
+	}
+
+	private int getNumItems() {
+		return numItems;
+	}
+
 	class Painter implements PaintListener {
 
 		@Override
 		public void paintControl(PaintEvent e) {
-			Rectangle rect = getClientArea();
+			Rectangle rect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			if (getNumItems() == 0) {
+				rect = getClientArea();
+			} else if (getNumItems() == 1 || (laneHeight * getNumItems() < rect.height)) {
+				// it fills the height
+			} else {
+				rect.height = laneHeight * getNumItems();
+			}
+
 			if (awtNeedsRedraw || !awtCanvas.hasImage(rect.width, rect.height)) {
 				Graphics2D g2d = awtCanvas.getGraphics(rect.width, rect.height);
-				g2d.setColor(Color.WHITE);
-				g2d.fillRect(0, 0, rect.width, rect.height);
+				minLaneheight = Math.max(20, (int) (g2d.getFontMetrics().getHeight() * xScale + 3));
 				Point adjusted = translateDisplayToImageCoordinates(rect.width, rect.height);
+				g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
+				g2d.fillRect(0, 0, adjusted.x, adjusted.y);
 				render(g2d, adjusted.x, adjusted.y);
+				if (getParent() instanceof ScrolledComposite) {
+					((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);
+				}
 				if (highlightRects != null) {
 					updateHighlightRects();
 				}
 				awtNeedsRedraw = false;
 			}
@@ -202,10 +277,18 @@
 				}
 			}
 		}
 	}
 
+	public void adjustLaneHeight(int amount) {
+		laneHeight = Math.min(Math.max(minLaneheight, laneHeight + amount), DEFAULT_LANE_HEIGHT);
+	}
+
+	public void resetLaneHeight() {
+		laneHeight = DEFAULT_LANE_HEIGHT;
+	}
+
 	class Zoomer implements Listener {
 
 		@Override
 		public void handleEvent(Event event) {
 			handleWheelEvent(event.stateMask, event.x, event.count);
@@ -285,10 +368,18 @@
 			case '-':
 				zoom(-1);
 				break;
 			default:
 				switch (event.keyCode) {
+				case SWT.ESC:
+					awtChart.clearSelection();
+					if (selectionListener != null) {
+						selectionListener.run();
+					}
+					redrawChart();
+					redrawChartText();
+					break;
 				case SWT.ARROW_RIGHT:
 					pan(10);
 					break;
 				case SWT.ARROW_LEFT:
 					pan(-10);
@@ -331,30 +422,45 @@
 	private final double yScale = Display.getDefault().getDPI().y / Environment.getNormalDPI();
 
 	private final AwtCanvas awtCanvas = new AwtCanvas();
 	private boolean awtNeedsRedraw;
 	private Runnable selectionListener;
+	private Runnable zoomToSelectionListener;
+	private Consumer<Boolean> zoomOnClickListener;
 	private IPropertyChangeListener aaListener;
 	private XYChart awtChart;
 	private MCContextMenuManager chartMenu;
+	private ChartTextCanvas textCanvas;
 
 	public ChartCanvas(Composite parent) {
 		super(parent, SWT.NO_BACKGROUND);
 		addPaintListener(new Painter());
 		Selector selector = new Selector();
 		addMouseListener(selector);
 		addMouseMoveListener(selector);
-		addMouseTrackListener(selector);
 		FocusTracker.enableFocusTracking(this);
-		addListener(SWT.MouseVerticalWheel, new Zoomer());
 		addKeyListener(new KeyNavigator());
 		aaListener = new AntiAliasingListener();
 		UIPlugin.getDefault().getPreferenceStore().addPropertyChangeListener(aaListener);
 		addDisposeListener(e -> UIPlugin.getDefault().getPreferenceStore().removePropertyChangeListener(aaListener));
 		if (Environment.getOSType() == OSType.WINDOWS) {
 			addMouseTrackListener(new WheelStealingZoomer());
 		}
+		if (getParent() instanceof ScrolledComposite) { // JFR Threads Page
+			((ScrolledComposite) getParent()).getVerticalBar().addListener(SWT.Selection, e -> vBarScroll());
+		} else {
+			addMouseTrackListener(selector);
+			addListener(SWT.MouseVerticalWheel, new Zoomer());
+		}
+	}
+
+	private void vBarScroll() {
+		if (textCanvas != null) {
+			Point location = ((ScrolledComposite) getParent()).getOrigin();
+			textCanvas.syncScroll(location);
+			awtChart.updateZoomPanIndicator();
+		}
 	}
 
 	public IMenuManager getContextMenu() {
 		if (chartMenu == null) {
 			chartMenu = MCContextMenuManager.create(this);
@@ -363,11 +469,15 @@
 		return chartMenu;
 	}
 
 	private void render(Graphics2D context, int width, int height) {
 		if (awtChart != null) {
-			awtChart.render(context, width, height);
+			awtChart.renderChart(context, width, height);
+			if (textCanvas == null) {
+				awtChart.renderText(context, width, height);
+			}
+			awtChart.updateZoomPanIndicator();
 		}
 	}
 
 	/**
 	 * Translates display coordinates into image coordinates for the chart.
@@ -376,11 +486,11 @@
 	 *            the provided x coordinate
 	 * @param y
 	 *            the provided y coordinate
 	 * @return a Point that represents the (x,y) coordinates in the chart's coordinate space
 	 */
-	private Point translateDisplayToImageCoordinates(int x, int y) {
+	protected Point translateDisplayToImageCoordinates(int x, int y) {
 		int xImage = (int) Math.round(x / xScale);
 		int yImage = (int) Math.round(y / yScale);
 		return new Point(xImage, yImage);
 	}
 
@@ -389,14 +499,25 @@
 	 *
 	 * @param x
 	 *            the provided display x coordinate
 	 * @return the x coordinate in the chart's coordinate space
 	 */
-	private int translateDisplayToImageXCoordinates(int x) {
+	protected int translateDisplayToImageXCoordinates(int x) {
 		return (int) Math.round(x / xScale);
 	}
 
+	/**
+	 * Translates a display x coordinate into an image x coordinate for the chart.
+	 *
+	 * @param x
+	 *            the provided display x coordinate
+	 * @return the x coordinate in the chart's coordinate space
+	 */
+	protected int translateDisplayToImageYCoordinates(int y) {
+		return (int) Math.round(y / yScale);
+	}
+
 	public Object getHoveredItemData() {
 		return this.hoveredItemData;
 	}
 
 	public void setHoveredItemData(Object data) {
@@ -405,10 +526,15 @@
 
 	public void resetHoveredItemData() {
 		this.hoveredItemData = null;
 	}
 
+	public void syncHighlightedRectangles(List<Rectangle2D> newRects) {
+		highlightRects = newRects;
+		redraw();
+	}
+
 	private void updateHighlightRects() {
 		List<Rectangle2D> newRects = new ArrayList<>();
 		infoAt(new IChartInfoVisitor.Adapter() {
 			@Override
 			public void visit(IBucket bucket) {
@@ -445,10 +571,13 @@
 			}
 		}, lastMouseX, lastMouseY);
 		// Attempt to reduce flicker by avoiding unnecessary updates.
 		if (!newRects.equals(highlightRects)) {
 			highlightRects = newRects;
+			if (textCanvas != null) {
+				textCanvas.syncHighlightedRectangles(highlightRects);
+			}
 			redraw();
 		}
 	}
 
 	private void clearHighlightRects() {
@@ -483,13 +612,16 @@
 		if ((awtChart != null) && awtChart.zoom(x, zoomInSteps)) {
 			redrawChart();
 		}
 	}
 
-	private void select(int x1, int x2, int y1, int y2) {
-		if ((awtChart != null) && awtChart.select(x1, x2, y1, y2)) {
+	private void select(int x1, int x2, int y1, int y2, boolean clear) {
+		Point p1 = translateDisplayToImageCoordinates(x1, y1);
+		Point p2 = translateDisplayToImageCoordinates(x2, y2);
+		if ((awtChart != null) && awtChart.select(p1.x, p2.x, p1.y, p2.y, clear)) {
 			redrawChart();
+			redrawChartText();
 		}
 	}
 
 	private void toggleSelect(int x, int y) {
 		Point p = translateDisplayToImageCoordinates(x, y);
@@ -513,26 +645,35 @@
 						range[1] = (x1 instanceof IQuantity) ? (IQuantity) x1 : null;
 					}
 				}
 			}, x, y);
 			if ((range[0] != null) || (range[1] != null)) {
-				if (!awtChart.select(range[0], range[1], p.y, p.y)) {
+				if (!awtChart.select(range[0], range[1], p.y, p.y, true)) {
 					awtChart.clearSelection();
 				}
 			} else {
-				if (!awtChart.select(p.x, p.x, p.y, p.y)) {
+				if (!awtChart.select(p.x, p.x, p.y, p.y, true)) {
 					awtChart.clearSelection();
 				}
 			}
+			notifyZoomOnClickListener(SWT.MouseDown);
 			redrawChart();
+			redrawChartText();
 		}
 	}
 
 	public void setChart(XYChart awtChart) {
 		this.awtChart = awtChart;
 		notifyListener();
-		redrawChart();
+	}
+
+	public void setTextCanvas(ChartTextCanvas textCanvas) {
+		this.textCanvas = textCanvas;
+	}
+
+	public void syncScroll(Point scrollPoint) {
+		((ScrolledComposite) getParent()).setOrigin(scrollPoint);
 	}
 
 	public void replaceRenderer(IXDataRenderer rendererRoot) {
 		assert awtChart != null;
 		awtChart.setRendererRoot(rendererRoot);
@@ -542,16 +683,34 @@
 
 	public void setSelectionListener(Runnable selectionListener) {
 		this.selectionListener = selectionListener;
 	}
 
+	public void setZoomToSelectionListener(Runnable zoomListener) {
+		this.zoomToSelectionListener = zoomListener;
+	}
+
+	public void setZoomOnClickListener(Consumer<Boolean> clickListener) {
+		this.zoomOnClickListener = clickListener;
+	}
+
+	private void notifyZoomOnClickListener(Integer button) {
+		if (zoomOnClickListener != null) {
+			zoomOnClickListener.accept(button == SWT.MouseDown);
+		}
+	}
+
 	private void notifyListener() {
 		if (selectionListener != null) {
 			selectionListener.run();
 		}
 	}
 
+	public void changeCursor(Cursor cursor) {
+		setCursor(cursor);
+	}
+
 	public void infoAt(IChartInfoVisitor visitor, int x, int y) {
 		Point p = translateDisplayToImageCoordinates(x, y);
 		if (awtChart != null) {
 			awtChart.infoAt(visitor, p.x, p.y);
 		}
@@ -562,6 +721,13 @@
 	 */
 	public void redrawChart() {
 		awtNeedsRedraw = true;
 		redraw();
 	}
+
+	private void redrawChartText() {
+		if (textCanvas != null) {
+			textCanvas.redrawChartText();
+		}
+	}
+
 }
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartDisplayControlBar.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartDisplayControlBar.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartDisplayControlBar.java
@@ -0,0 +1,571 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Timer;
+import java.util.TimerTask;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.MouseWheelListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Cursor;
+import org.eclipse.swt.graphics.GC;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Scale;
+import org.eclipse.swt.widgets.Text;
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class ChartDisplayControlBar extends Composite {
+	private static final String ZOOM_IN_CURSOR = "zoomInCursor";
+	private static final String ZOOM_OUT_CURSOR = "zoomOutCursor";
+	private static final String DEFAULT_CURSOR = "defaultCursor";
+	private static final String HAND_CURSOR = "handCursor";
+	private static final int ZOOM_INCREMENT = 1;
+	private Map<String, Cursor> cursors;
+	private Scale scale;
+	private Text zoomText;
+	private XYChart chart;
+	private ChartCanvas chartCanvas;
+	private ChartTextCanvas textCanvas;
+	private List<Button> buttonGroup;
+	private Button zoomInBtn;
+	private Button zoomOutBtn;
+	private Button selectionBtn;
+	private Button zoomPanBtn;
+	private Button scaleToFitBtn;
+
+	private ZoomPan zoomPan;
+
+	public ChartDisplayControlBar(Composite parent) {
+		super(parent, SWT.NONE);
+
+		this.setLayout(new GridLayout());
+		this.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));
+		this.setBackground(Palette.getThreadsPageBackgroundColor());
+
+		cursors = new HashMap<>();
+		cursors.put(DEFAULT_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_ARROW));
+		cursors.put(HAND_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_HAND));
+		cursors.put(ZOOM_IN_CURSOR, new Cursor(getDisplay(),
+				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN).getImageData(), 0, 0));
+		cursors.put(ZOOM_OUT_CURSOR, new Cursor(getDisplay(),
+				UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT).getImageData(), 0, 0));
+
+		buttonGroup = new ArrayList<>();
+		selectionBtn = new Button(this, SWT.TOGGLE);
+		selectionBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		selectionBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SELECTION));
+		selectionBtn.setSelection(true);
+		selectionBtn.setToolTipText(Messages.ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP);
+		selectionBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				setButtonSelectionStates(selectionBtn, null);
+				changeCursor(DEFAULT_CURSOR);
+			};
+		});
+		buttonGroup.add(selectionBtn);
+
+		zoomInBtn = new Button(this, SWT.TOGGLE);
+		zoomInBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomInBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));
+		zoomInBtn.setSelection(false);
+		StringBuilder sb = new StringBuilder();
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP);
+		sb.append(System.getProperty("line.separator"));
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP);
+		zoomInBtn.setToolTipText(sb.toString());
+		zoomInBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				if (scale.getSelection() > 0) {
+					setButtonSelectionStates(zoomInBtn, zoomPanBtn);
+					changeCursor(ZOOM_IN_CURSOR);
+				} else {
+					setButtonSelectionStates(selectionBtn, null);
+					changeCursor(DEFAULT_CURSOR);
+				}
+			}
+		});
+		zoomInBtn.addMouseListener(new LongPressListener(ZOOM_INCREMENT));
+		buttonGroup.add(zoomInBtn);
+
+		scale = new Scale(this, SWT.VERTICAL);
+		scale.setMinimum(0);
+		scale.setMaximum(30);
+		scale.setIncrement(1);
+		scale.setSelection(30);
+		scale.setLayoutData(new GridData(SWT.CENTER, SWT.FILL, true, true));
+		scale.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				chart.zoomToStep(scale.getMaximum() - scale.getSelection());
+				chartCanvas.redrawChart();
+			}
+		});
+
+		zoomText = new Text(this, SWT.BORDER | SWT.READ_ONLY | SWT.SINGLE);
+		zoomText.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		setZoomPercentageText(100);
+
+		zoomOutBtn = new Button(this, SWT.TOGGLE);
+		zoomOutBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomOutBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));
+		zoomOutBtn.setSelection(false);
+		sb = new StringBuilder();
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP);
+		sb.append(System.getProperty("line.separator"));
+		sb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP);
+		zoomOutBtn.setToolTipText(sb.toString());
+		zoomOutBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event e) {
+				if (scale.getSelection() < scale.getMaximum()) {
+					setButtonSelectionStates(zoomOutBtn, zoomPanBtn);
+					changeCursor(ZOOM_OUT_CURSOR);
+				} else {
+					setButtonSelectionStates(selectionBtn, null);
+					changeCursor(DEFAULT_CURSOR);
+				}
+			}
+		});
+		zoomOutBtn.addMouseListener(new LongPressListener(-ZOOM_INCREMENT));
+		buttonGroup.add(zoomOutBtn);
+
+		zoomPanBtn = new Button(this, SWT.TOGGLE);
+		zoomPanBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		zoomPanBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_PAN));
+		zoomPanBtn.setSelection(false);
+		zoomPanBtn.setToolTipText(Messages.ChartDisplayControlBar_ZOOM_PAN_TOOLTIP);
+		zoomPanBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				showZoomPanDisplay(zoomPanBtn.getSelection());
+			}
+		});
+		buttonGroup.add(zoomPanBtn);
+
+		scaleToFitBtn = new Button(this, SWT.PUSH);
+		scaleToFitBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		scaleToFitBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));
+		scaleToFitBtn.setSelection(false);
+		scaleToFitBtn.setToolTipText(Messages.ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP);
+		scaleToFitBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				resetZoomScale();
+				chart.resetTimeline();
+				chartCanvas.redrawChart();
+			}
+		});
+		buttonGroup.add(scaleToFitBtn);
+	}
+
+	public void setChart(XYChart chart) {
+		this.chart = chart;
+	}
+
+	public void setChartCanvas(ChartCanvas chartCanvas) {
+		this.chartCanvas = chartCanvas;
+	}
+
+	public void setTextCanvas(ChartTextCanvas textCanvas) {
+		this.textCanvas = textCanvas;
+	}
+
+	public void updateZoomPanIndicator() {
+		zoomPan.redraw();
+	}
+
+	public void zoomOnClick(Boolean mouseDown) {
+		boolean shouldZoom = zoomInBtn.getSelection() || zoomOutBtn.getSelection();
+		if (shouldZoom) {
+			if (mouseDown) {
+				chart.clearSelection();
+			} else {
+				int zoomAmount = zoomInBtn.getSelection() ? ZOOM_INCREMENT : -ZOOM_INCREMENT;
+				zoom(zoomAmount);
+				if (textCanvas != null) {
+					textCanvas.redrawChartText();
+				}
+			}
+		}
+	}
+
+	public void zoomToSelection() {
+		if (zoomInBtn.getSelection() && scale.getSelection() > 0) {
+			IQuantity selectionStart = chart.getSelectionStart();
+			IQuantity selectionEnd = chart.getSelectionEnd();
+			if (selectionStart == null || selectionEnd == null) {
+				chart.clearVisibleRange();
+			} else {
+				chart.setVisibleRange(selectionStart, selectionEnd);
+				chartCanvas.redrawChart();
+			}
+		}
+	}
+
+	public void setZoomPercentageText(double zoom) {
+		zoomText.setText(String.format("%.2f %s", zoom, "%"));
+	}
+
+	public void setScaleValue(int value) {
+		scale.setSelection(scale.getMaximum() - value);
+	}
+
+	public void increaseScaleValue() {
+		scale.setSelection(scale.getSelection() - 1);
+	}
+
+	public void decreaseScaleValue() {
+		scale.setSelection(scale.getSelection() + 1);
+	}
+
+	public void resetZoomScale() {
+		scale.setSelection(scale.getMaximum());
+		setZoomPercentageText(100);
+		resetLaneHeight();
+	}
+
+	private void resetLaneHeight() {
+		chartCanvas.resetLaneHeight();
+		if (textCanvas != null) {
+			textCanvas.resetLaneHeight();
+		}
+	}
+
+	private void changeCursor(String cursorName) {
+		chartCanvas.changeCursor(cursors.get(cursorName));
+	}
+
+	private void setButtonSelectionStates(Button buttonSelected, Button dependentButton) {
+		for (Button button : buttonGroup) {
+			if ((button.getStyle() & SWT.TOGGLE) != 0) {
+				if (button.equals(buttonSelected)) {
+					button.setSelection(true);
+				} else if (dependentButton != null) {
+					if (button.equals(dependentButton)) {
+						button.setSelection(true);
+					} else {
+						button.setSelection(false);
+					}
+				} else {
+					button.setSelection(false);
+				}
+			}
+			showZoomPanDisplay(zoomPanBtn.getSelection());
+		}
+	}
+
+	private class LongPressListener extends MouseAdapter {
+
+		private static final long LONG_PRESS_TIME = 500;
+		private Timer timer;
+		private int zoomAmount;
+
+		LongPressListener(int zoomAmount) {
+			this.zoomAmount = zoomAmount;
+		}
+
+		@Override
+		public void mouseDown(MouseEvent e) {
+			if (e.button == 1) {
+				timer = new Timer();
+				timer.schedule(new LongPress(), LONG_PRESS_TIME, (long) (LONG_PRESS_TIME * 1.5));
+			}
+		}
+
+		@Override
+		public void mouseUp(MouseEvent e) {
+			timer.cancel();
+		}
+
+		public class LongPress extends TimerTask {
+
+			@Override
+			public void run() {
+				doZoomInOut(zoomAmount);
+			}
+		}
+
+		private void doZoomInOut(int zoomAmount) {
+			DisplayToolkit.inDisplayThread().execute(() -> zoom(zoomAmount));
+		}
+	}
+
+	private void zoom(int zoomAmount) {
+		int newScaleValue = scale.getSelection() - zoomAmount;
+		if (newScaleValue >= scale.getMinimum() && newScaleValue <= scale.getMaximum()) {
+			scale.setSelection(scale.getSelection() - zoomAmount);
+			chart.zoom(zoomAmount);
+			chartCanvas.redrawChart();
+		}
+	}
+
+	public void createZoomPan(Composite parent) {
+		zoomPan = new ZoomPan(parent);
+		parent.setVisible(false);
+	}
+
+	private void showZoomPanDisplay(boolean show) {
+		if (show) {
+			zoomPan.getParent().setVisible(true);
+			zoomPan.redrawZoomPan();
+		} else {
+			zoomPan.getParent().setVisible(false);
+		}
+	}
+
+	private class ZoomPan extends Canvas {
+		private static final int BORDER_PADDING = 2;
+		private static final double MIN_HEIGHT_PERCENT = 0.15;
+		private static final double MIN_WIDTH_PERCENT = 0.08;
+		private IRange<IQuantity> chartRange;
+		private IRange<IQuantity> lastChartZoomedRange;
+		private Rectangle zoomRect;
+
+		public ZoomPan(Composite parent) {
+			super(parent, SWT.NO_BACKGROUND);
+			addPaintListener(new Painter());
+			PanDetector panDetector = new PanDetector();
+			addMouseListener(panDetector);
+			addMouseMoveListener(panDetector);
+			addMouseWheelListener(panDetector);
+			chartRange = chart.getVisibleRange();
+		}
+
+		public void redrawZoomPan() {
+			redraw();
+		}
+
+		private class PanDetector extends MouseAdapter implements MouseMoveListener, MouseWheelListener {
+			Point currentSelection;
+			Point lastSelection;
+			boolean isPan = false;
+
+			@Override
+			public void mouseDown(MouseEvent e) {
+				if (e.button == 1 && inBounds(e)) {
+					isPan = true;
+					chart.setIsZoomPanDrag(isPan);
+					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
+				}
+			}
+
+			private boolean inBounds(MouseEvent e) {
+				Point zoomCanvasBounds = getParent().getSize();
+				if (zoomRect.height < MIN_HEIGHT_PERCENT * zoomCanvasBounds.y
+						|| zoomRect.width < MIN_WIDTH_PERCENT * zoomCanvasBounds.x) {
+					return zoomCanvasBounds.x >= e.x && zoomCanvasBounds.y >= e.y;
+				} else {
+					return zoomRect.contains(e.x, e.y);
+				}
+			}
+
+			@Override
+			public void mouseUp(MouseEvent e) {
+				isPan = false;
+				chart.setIsZoomPanDrag(isPan);
+			}
+
+			@Override
+			public void mouseMove(MouseEvent e) {
+				zoomPan.setCursor(cursors.get(HAND_CURSOR));
+				if (isPan && getParent().getSize().x >= e.x && getParent().getSize().y >= e.y) {
+					lastSelection = currentSelection;
+					currentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);
+					int xdiff = currentSelection.x - lastSelection.x;
+					int ydiff = currentSelection.y - lastSelection.y;
+					updateZoomRectFromPan(xdiff, ydiff);
+				}
+			}
+
+			@Override
+			public void mouseScrolled(MouseEvent e) {
+				updateZoomRectFromPan(0, -e.count);
+			}
+		}
+
+		private void updateZoomRectFromPan(int xdiff, int ydiff) {
+			Point bounds = getParent().getSize();
+			boolean xModified = false;
+			boolean yModified = false;
+
+			int xOld = zoomRect.x;
+			zoomRect.x += xdiff;
+			if (zoomRect.x > (bounds.x - zoomRect.width - BORDER_PADDING - 1)) {
+				zoomRect.x = bounds.x - zoomRect.width - BORDER_PADDING - 1;
+			} else if (zoomRect.x < BORDER_PADDING) {
+				zoomRect.x = BORDER_PADDING;
+			}
+			xModified = xOld != zoomRect.x;
+
+			int yOld = zoomRect.y;
+			zoomRect.y += ydiff;
+			if (zoomRect.y < BORDER_PADDING) {
+				zoomRect.y = BORDER_PADDING;
+			} else if (zoomRect.y > (bounds.y - zoomRect.height - BORDER_PADDING - 1)) {
+				zoomRect.y = bounds.y - zoomRect.height - BORDER_PADDING - 1;
+			}
+			yModified = yOld != zoomRect.y;
+
+			if (xModified || yModified) {
+				updateChartFromZoomRect(xModified, yModified);
+				chartCanvas.redrawChart();
+			}
+		}
+
+		private void updateChartFromZoomRect(boolean updateXRange, boolean updateYRange) {
+			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			Rectangle totalBounds = chartCanvas.getBounds();
+
+			if (updateXRange) {
+				double ratio = getVisibilityRatio(zoomRect.x - BORDER_PADDING, zoomCanvasBounds.x,
+						zoomCanvasBounds.width - BORDER_PADDING);
+				int start = getPixelLocation(ratio, totalBounds.width, 0);
+
+				ratio = getVisibilityRatio(zoomRect.x + zoomRect.width + BORDER_PADDING + 1, zoomCanvasBounds.width,
+						zoomCanvasBounds.width - BORDER_PADDING);
+				int end = getPixelLocation(ratio, totalBounds.width, totalBounds.width);
+
+				SubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),
+						totalBounds.width, 1);
+				chart.setVisibleRange(xAxis.getQuantityAtPixel(start), xAxis.getQuantityAtPixel(end));
+				lastChartZoomedRange = chart.getVisibleRange();
+			}
+			if (updateYRange) {
+				double ratio = getVisibilityRatio(zoomRect.y - BORDER_PADDING, 0,
+						zoomCanvasBounds.height - BORDER_PADDING);
+				int top = getPixelLocation(ratio, totalBounds.height, 0);
+
+				Point p = ((ScrolledComposite) chartCanvas.getParent()).getOrigin();
+				p.y = top;
+
+				if (textCanvas != null) {
+					textCanvas.syncScroll(p);
+				}
+				chartCanvas.syncScroll(p);
+			}
+		}
+
+		class Painter implements PaintListener {
+			@Override
+			public void paintControl(PaintEvent e) {
+
+				Rectangle backgroundRect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+				GC gc = e.gc;
+
+				gc.setBackground(Palette.PF_BLACK_400.getSWTColor());
+				gc.fillRectangle(backgroundRect);
+				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
+				gc.drawRectangle(0, 0, backgroundRect.width - 1, backgroundRect.height - 1);
+
+				updateZoomRectFromChart();
+
+				gc.setBackground(Palette.PF_BLACK_100.getSWTColor());
+				gc.fillRectangle(zoomRect);
+				gc.setForeground(Palette.PF_BLACK_900.getSWTColor());
+				gc.drawRectangle(zoomRect);
+			}
+		}
+
+		private void updateZoomRectFromChart() {
+			Rectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);
+			IRange<IQuantity> zoomedRange = chart.getVisibleRange();
+			IQuantity visibleWidth = chartRange.getExtent();
+			double visibleHeight = chartCanvas.getParent().getBounds().height;
+			Rectangle totalBounds = chartCanvas.getBounds();
+
+			if (zoomRect == null) {
+				zoomRect = new Rectangle(0, 0, 0, 0);
+			}
+			if (!chart.getVisibleRange().equals(lastChartZoomedRange)) {
+				double ratio = getVisibilityRatio(zoomedRange.getStart(), chartRange.getStart(), visibleWidth);
+				int start = getPixelLocation(ratio, zoomCanvasBounds.width, 0);
+
+				ratio = getVisibilityRatio(zoomedRange.getEnd(), chartRange.getEnd(), visibleWidth);
+				int end = getPixelLocation(ratio, zoomCanvasBounds.width, zoomCanvasBounds.width);
+
+				zoomRect.x = start + BORDER_PADDING;
+				zoomRect.width = end - start - 2 * BORDER_PADDING - 1;
+				lastChartZoomedRange = chart.getVisibleRange();
+			}
+			double ratio = getVisibilityRatio(0, totalBounds.y, totalBounds.height);
+			int top = getPixelLocation(ratio, zoomCanvasBounds.height, 0);
+
+			ratio = getVisibilityRatio(visibleHeight, totalBounds.height + totalBounds.y, totalBounds.height);
+			int bottom = getPixelLocation(ratio, zoomCanvasBounds.height, zoomCanvasBounds.height);
+
+			zoomRect.y = top + BORDER_PADDING;
+			zoomRect.height = bottom - top - 2 * BORDER_PADDING - 1;
+
+		}
+
+		private double getVisibilityRatio(double visibleBound, double borderBound, double totalLength) {
+			double diff = visibleBound - borderBound;
+			return diff / totalLength;
+		}
+
+		private double getVisibilityRatio(IQuantity visibleBound, IQuantity borderBound, IQuantity totalLength) {
+			IQuantity diff = visibleBound.subtract(borderBound);
+			return diff.ratioTo(totalLength);
+		}
+
+		private int getPixelLocation(double visiblityRatio, int totalLength, int offset) {
+			return offset + (int) (visiblityRatio * totalLength);
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartLaneHeightControls.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Event;
+import org.eclipse.swt.widgets.Listener;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class ChartLaneHeightControls extends Composite {
+	private Button incHeightBtn;
+	private Button decHeightBtn;
+	private ChartCanvas chartCanvas;
+	private ChartTextCanvas textCanvas;
+
+	public ChartLaneHeightControls(Composite parent, ChartCanvas chartCanvas, ChartTextCanvas textCanvas) {
+		super(parent, SWT.NONE);
+		this.setLayout(new GridLayout(2, true));
+		this.chartCanvas = chartCanvas;
+		this.textCanvas = textCanvas;
+		this.setBackground(Palette.PF_BLACK_100.getSWTColor());
+
+		decHeightBtn = new Button(this, SWT.PUSH);
+		decHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		decHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_MINUS));
+		decHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP);
+		decHeightBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				adjustLaneHeight(-1);
+			}
+		});
+
+		incHeightBtn = new Button(this, SWT.PUSH);
+		incHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));
+		incHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP);
+		incHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_PLUS));
+		incHeightBtn.addListener(SWT.Selection, new Listener() {
+			@Override
+			public void handleEvent(Event event) {
+				adjustLaneHeight(1);
+			}
+		});
+	}
+
+	private void adjustLaneHeight(int amount) {
+		chartCanvas.adjustLaneHeight(amount);
+		chartCanvas.redrawChart();
+		if (textCanvas != null) {
+			textCanvas.adjustLaneHeight(amount);
+			textCanvas.redrawChartText();
+		}
+	}
+
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/ChartTextCanvas.java
@@ -0,0 +1,453 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.awt.Graphics2D;
+import java.awt.geom.Rectangle2D;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.ScrolledComposite;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.KeyListener;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.MouseTrackListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Display;
+import org.openjdk.jmc.ui.UIPlugin;
+import org.openjdk.jmc.ui.accessibility.FocusTracker;
+import org.openjdk.jmc.ui.charts.IChartInfoVisitor;
+import org.openjdk.jmc.ui.charts.IXDataRenderer;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.common.util.Environment;
+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class ChartTextCanvas extends Canvas {
+	private static final int DEFAULT_LANE_HEIGHT = 50;
+	private int laneHeight = DEFAULT_LANE_HEIGHT;
+	private int minLaneheight = 20;
+	private int numItems;
+	private int lastMouseX = -1;
+	private int lastMouseY = -1;
+	private List<Rectangle2D> highlightRects;
+
+	private class Selector extends MouseAdapter implements MouseMoveListener, MouseTrackListener {
+
+		int selectionStartX = -1;
+		int selectionStartY = -1;
+		Point highlightSelectionStart;
+		Point highlightSelectionEnd;
+		Point lastSelection;
+		boolean selectionIsClick = false;
+		Set<Point> highlightPoints;
+
+		@Override
+		public void mouseDown(MouseEvent e) {
+			/*
+			 * On Mac OS X, CTRL + left mouse button can be used to trigger a context menu. (This is
+			 * for historical reasons when the primary input device on Macs were a mouse with a
+			 * single physical button. All modern Macs have other means to bring up the context
+			 * menu, typically a two finger tap.)
+			 * 
+			 * Although I think it would be best to check that this MouseEvent does not cause a
+			 * platform specific popup trigger, like java.awt.event.MouseEvent.isPopupTrigger() for
+			 * AWT, SWT doesn't seem to have something as simple. It has the MenuDetectEvent, but
+			 * the order in relation to this MouseEvent is unspecified.
+			 * 
+			 * The code below instead relies on ignoring mouse down events when SWT.MOD4 is
+			 * depressed. Since MOD4 is CTRL on OS X and 0 on all other current platforms, this
+			 * suffices. Except for an additional platform check, this approach is also used in
+			 * org.eclipse.swt.custom.StyledText.handleMouseDown(Event).
+			 */
+			if ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0) && ((e.stateMask & SWT.CTRL) == 0)
+					&& ((e.stateMask & SWT.SHIFT) == 0)) {
+				highlightPoints = new HashSet<>();
+				highlightPoints.add(new Point(e.x, e.y));
+				selectionStartX = e.x;
+				selectionStartY = e.y;
+				highlightSelectionEnd = new Point(-1, -1);
+				lastSelection = new Point(-1, -1);
+				selectionIsClick = true;
+				toggleSelect(selectionStartX, selectionStartY);
+			} else if (((e.stateMask & SWT.CTRL) != 0) && (e.button == 1)) {
+				highlightPoints.add(new Point(e.x, e.y));
+				select(e.x, e.x, e.y, e.y, false);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			} else if (((e.stateMask & SWT.SHIFT) != 0) && (e.button == 1)) {
+				if (highlightSelectionEnd.y == -1) {
+					highlightSelectionEnd = new Point(e.x, e.y);
+					lastSelection = highlightSelectionEnd;
+					if (highlightSelectionStart.y > highlightSelectionEnd.y) {
+						Point temp = highlightSelectionStart;
+						highlightSelectionStart = highlightSelectionEnd;
+						highlightSelectionEnd = temp;
+					}
+				} else {
+					if (e.y > highlightSelectionStart.y && e.y < highlightSelectionEnd.y) {
+						if (e.y < lastSelection.y) {
+							highlightSelectionEnd = new Point(e.x, e.y);
+						} else if (e.y > lastSelection.y) {
+							highlightSelectionStart = new Point(e.x, e.y);
+						}
+					} else if (e.y < highlightSelectionStart.y) {
+						highlightSelectionStart = new Point(e.x, e.y);
+						lastSelection = highlightSelectionStart;
+					} else if (e.y > highlightSelectionEnd.y) {
+						highlightSelectionEnd = new Point(e.x, e.y);
+						lastSelection = highlightSelectionEnd;
+					}
+				}
+				select(highlightSelectionStart.x, highlightSelectionStart.x, highlightSelectionStart.y,
+						highlightSelectionEnd.y, true);
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			}
+		}
+
+		@Override
+		public void mouseMove(MouseEvent e) {
+			if (selectionStartX >= 0) {
+				highlightRects = null;
+				updateSelectionState(e);
+			} else {
+				lastMouseX = e.x;
+				lastMouseY = e.y;
+				updateHighlightRects();
+			}
+		}
+
+		private void updateSelectionState(MouseEvent e) {
+			int x = e.x;
+			int y = e.y;
+			if (selectionIsClick && ((Math.abs(x - selectionStartX) > 3) || (Math.abs(y - selectionStartY) > 3))) {
+				selectionIsClick = false;
+			}
+			if (!selectionIsClick) {
+				select((int) (selectionStartX / xScale), (int) (selectionStartX / xScale),
+						(int) (selectionStartY / yScale), (int) (y / yScale), true);
+			}
+		}
+
+		@Override
+		public void mouseUp(MouseEvent e) {
+			if (selectionStartX >= 0 && (e.button == 1)) {
+				updateSelectionState(e);
+				highlightSelectionStart = new Point(selectionStartX, selectionStartY);
+				selectionStartX = -1;
+				selectionStartY = -1;
+				if (selectionListener != null) {
+					selectionListener.run();
+				}
+			}
+		}
+
+		@Override
+		public void mouseEnter(MouseEvent e) {
+		}
+
+		@Override
+		public void mouseExit(MouseEvent e) {
+			if (!getClientArea().contains(e.x, e.y)) {
+				resetHoveredItemData();
+			}
+			clearHighlightRects();
+		}
+
+		@Override
+		public void mouseHover(MouseEvent e) {
+		}
+	}
+
+	public void setNumItems(int numItems) {
+		this.numItems = numItems;
+	}
+
+	private int getNumItems() {
+		return numItems;
+	}
+
+	class Painter implements PaintListener {
+
+		@Override
+		public void paintControl(PaintEvent e) {
+			int minScrollWidth = (int) ((awtChart.getLongestCharWidth() + 10) * xScale);
+			int rectWidth = Math.max(minScrollWidth, getParent().getSize().x);
+			Rectangle rect = new Rectangle(0, 0, rectWidth, getParent().getSize().y);
+			if (getNumItems() != 1 && !(laneHeight * getNumItems() < rect.height)) {
+				rect.height = laneHeight * getNumItems();
+			}
+
+			if (awtNeedsRedraw || !awtCanvas.hasImage(rect.width, rect.height)) {
+				Graphics2D g2d = awtCanvas.getGraphics(rect.width, rect.height);
+				minLaneheight = Math.max(20, (int) (g2d.getFontMetrics().getHeight() * xScale + 3));
+				Point adjusted = chartCanvas.translateDisplayToImageCoordinates(rect.width, rect.height);
+				g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
+				g2d.fillRect(0, 0, adjusted.x, adjusted.y);
+				render(g2d, adjusted.x, adjusted.y);
+				((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);
+				if (highlightRects != null) {
+					updateHighlightRects();
+				}
+				awtNeedsRedraw = false;
+			}
+			awtCanvas.paint(e, 0, 0);
+		}
+	}
+
+	public void adjustLaneHeight(int amount) {
+		laneHeight = Math.min(Math.max(minLaneheight, laneHeight + amount), DEFAULT_LANE_HEIGHT);
+	}
+
+	public void resetLaneHeight() {
+		laneHeight = DEFAULT_LANE_HEIGHT;
+	}
+
+	class KeyNavigator implements KeyListener {
+
+		@Override
+		public void keyPressed(KeyEvent event) {
+			switch (event.character) {
+			default:
+				switch (event.keyCode) {
+				case SWT.ESC:
+					awtChart.clearSelection();
+					if (selectionListener != null) {
+						selectionListener.run();
+					}
+					redrawChart();
+					redrawChartText();
+					break;
+				default:
+					// Ignore
+				}
+			}
+		}
+
+		@Override
+		public void keyReleased(KeyEvent event) {
+			// Ignore
+		}
+
+	}
+
+	private class AntiAliasingListener implements IPropertyChangeListener {
+
+		@Override
+		public void propertyChange(PropertyChangeEvent event) {
+			redrawChartText();
+		}
+
+	}
+
+	/**
+	 * This gets the "normal" DPI value for the system (72 on MacOS and 96 on Windows/Linux. It's
+	 * used to determine how much larger the current DPI is so that we can draw the charts based on
+	 * how large that area would be given the "normal" DPI value. Every draw on this smaller chart
+	 * is then scaled up by the Graphics2D objects DefaultTransform.
+	 */
+	private final double xScale = Display.getDefault().getDPI().x / Environment.getNormalDPI();
+	private final double yScale = Display.getDefault().getDPI().y / Environment.getNormalDPI();
+
+	public final AwtCanvas awtCanvas = new AwtCanvas();
+	private boolean awtNeedsRedraw;
+	private Runnable selectionListener;
+	private IPropertyChangeListener aaListener;
+	private XYChart awtChart;
+	private ChartCanvas chartCanvas;
+	private MCContextMenuManager chartMenu;
+	private Object hoveredItemData;
+
+	public ChartTextCanvas(Composite parent) {
+		super(parent, SWT.NO_BACKGROUND);
+		numItems = 0;
+		addPaintListener(new Painter());
+		Selector selector = new Selector();
+		addMouseListener(selector);
+		addMouseMoveListener(selector);
+		FocusTracker.enableFocusTracking(this);
+		addKeyListener(new KeyNavigator());
+		aaListener = new AntiAliasingListener();
+		UIPlugin.getDefault().getPreferenceStore().addPropertyChangeListener(aaListener);
+		addDisposeListener(e -> UIPlugin.getDefault().getPreferenceStore().removePropertyChangeListener(aaListener));
+		((ScrolledComposite) getParent()).getVerticalBar().addListener(SWT.Selection, e -> vBarScroll());
+	}
+
+	private void vBarScroll() {
+		if (chartCanvas != null) {
+			Point location = ((ScrolledComposite) getParent()).getOrigin();
+			chartCanvas.syncScroll(location);
+		}
+	}
+
+	public IMenuManager getContextMenu() {
+		if (chartMenu == null) {
+			chartMenu = MCContextMenuManager.create(this);
+			chartMenu.addMenuListener(manager -> clearHighlightRects());
+		}
+		return chartMenu;
+	}
+
+	private void render(Graphics2D context, int width, int height) {
+		if (awtChart != null) {
+			awtChart.renderTextCanvasText(context, width, height);
+		}
+	}
+
+	public Object getHoveredItemData() {
+		return this.hoveredItemData;
+	}
+
+	public void setHoveredItemData(Object data) {
+		this.hoveredItemData = data;
+	}
+
+	public void resetHoveredItemData() {
+		this.hoveredItemData = null;
+	}
+
+	public void syncHighlightedRectangles(List<Rectangle2D> newRects) {
+		highlightRects = newRects;
+		redraw();
+	}
+
+	private void updateHighlightRects() {
+		infoAt(new IChartInfoVisitor.Adapter() {
+			@Override
+			public void hover(Object data) {
+				if (data != null) {
+					setHoveredItemData(data);
+				}
+			}
+		}, lastMouseX, lastMouseY);
+		redraw();
+		if (chartCanvas != null) {
+			chartCanvas.syncHighlightedRectangles(highlightRects);
+		}
+	}
+
+	private void clearHighlightRects() {
+		if (highlightRects != null) {
+			highlightRects = null;
+			redraw();
+		}
+	}
+
+	public void select(int x1, int x2, int y1, int y2, boolean clear) {
+		Point p1 = chartCanvas.translateDisplayToImageCoordinates(x1, y1);
+		Point p2 = chartCanvas.translateDisplayToImageCoordinates(x2, y2);
+		if ((awtChart != null) && awtChart.select(p1.x, p2.x, p1.y, p2.y, clear)) {
+			redrawChartText();
+			redrawChart();
+		}
+	}
+
+	private void toggleSelect(int x, int y) {
+		Point p = chartCanvas.translateDisplayToImageCoordinates(x, y);
+		if (awtChart != null) {
+			if (!awtChart.select(p.x, p.x, p.y, p.y, true)) {
+				awtChart.clearSelection();
+			}
+			redrawChartText();
+			redrawChart();
+		}
+	}
+
+	public void setChart(XYChart awtChart) {
+		this.awtChart = awtChart;
+		notifyListener();
+	}
+
+	public void setChartCanvas(ChartCanvas chartCanvas) {
+		this.chartCanvas = chartCanvas;
+	}
+
+	public void syncScroll(Point scrollPoint) {
+		getParent().getVerticalBar().setVisible(false);
+		((ScrolledComposite) getParent()).setOrigin(scrollPoint);
+	}
+
+	public void replaceRenderer(IXDataRenderer rendererRoot) {
+		assert awtChart != null;
+		awtChart.setRendererRoot(rendererRoot);
+		notifyListener();
+		redrawChartText();
+	}
+
+	public void setSelectionListener(Runnable selectionListener) {
+		this.selectionListener = selectionListener;
+	}
+
+	private void notifyListener() {
+		if (selectionListener != null) {
+			selectionListener.run();
+		}
+	}
+
+	public void infoAt(IChartInfoVisitor visitor, int x, int y) {
+		Point p = chartCanvas.translateDisplayToImageCoordinates(x, y);
+		if (awtChart != null) {
+			awtChart.infoAt(visitor, p.x, p.y);
+		}
+	}
+
+	/**
+	 * Mark both the (AWT) chart and the SWT control as needing a redraw.
+	 */
+	public void redrawChartText() {
+		awtNeedsRedraw = true;
+		redraw();
+	}
+
+	private void redrawChart() {
+		if (chartCanvas != null) {
+			chartCanvas.redrawChart();
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/Messages.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -36,10 +36,19 @@
 
 public class Messages extends NLS {
 	private static final String BUNDLE_NAME = "org.openjdk.jmc.ui.misc.messages"; //$NON-NLS-1$
 
 	public static String AbstractWarningItem_WARNING;
+	public static String ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP;
+	public static String ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_PAN_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP;
+	public static String ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP;
+	public static String ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP;
+	public static String ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP;
 	public static String DIALOG_FILE_EXISTS_TITLE;
 	public static String DIALOG_OVERWRITE_QUESTION_TEXT;
 	public static String EXPORT_AS_IMAGE_ACTION_TEXT;
 	public static String ExceptionDialog_NO_DETAILS_AVAILABLE;
 	public static String FAILED_TO_SAVE_IMAGE;
@@ -92,10 +101,20 @@
 	public static String NumberFieldEditor_ERROR_MESSAGE_MUST_BE;
 	public static String NumberFieldEditor_ERROR_MESSAGE_NO_GREATER;
 	public static String NumberFieldEditor_ERROR_MESSAGE_NO_SMALLER;
 	public static String ProgressComposite_PLEASE_WAIT;
 	public static String QuestionLinkDialog_FAILED_OPEN_BROWSER;
+	public static String TimeFilter_END_TIME_EXCEEDS_ERROR;
+	public static String TimeFilter_ERROR;
+	public static String TimeFilter_FILTER;
+	public static String TimeFilter_FILTER_EVENTS;
+	public static String TimeFilter_FROM;
+	public static String TimeFilter_INVALID_FORMAT_ERROR;
+	public static String TimeFilter_RESET;
+	public static String TimeFilter_START_TIME_LONGER_THAN_END_ERROR;
+	public static String TimeFilter_START_TIME_PRECEEDS_ERROR;
+	public static String TimeFilter_TO;
 
 	static {
 		NLS.initializeMessages(BUNDLE_NAME, Messages.class);
 	}
 
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/PatternFly.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.widgets.Display;
+
+public class PatternFly {
+
+	private static final String AWT = "AWT";
+	private static final String SWT = "SWT";
+
+	/**
+	 * The following color Palette is based on the PatternFly palette for reinforcing application
+	 * content and workflows. https://www.patternfly.org/v3/styles/color-palette/
+	 */
+	public enum Palette {
+		/**
+		 * Primary Colors: Black & Blue
+		 */
+		PF_BLACK("#030303"),
+		PF_BLACK_100("#fafafa"),
+		PF_BLACK_150("#f5f5f5"),
+		PF_BLACK_200("#ededed"),
+		PF_BLACK_300("#d1d1d1"),
+		PF_BLACK_400("#bbbbbb"),
+		PF_BLACK_500("#8b8d8f"),
+		PF_BLACK_600("#72767b"),
+		PF_BLACK_700("#4d5258"),
+		PF_BLACK_800("#393f44"),
+		PF_BLACK_900("#292e34"),
+
+		PF_BLUE("#0088ce"),
+		PF_BLUE_50("#def3ff"),
+		PF_BLUE_100("#bee1f4"),
+		PF_BLUE_200("#7dc3e8"),
+		PF_BLUE_300("#39a5dc"),
+		PF_BLUE_400("#0088ce"),
+		PF_BLUE_500("#00659c"),
+		PF_BLUE_600("#004368"),
+		PF_BLUE_700("#002235"),
+
+		/**
+		 * Secondary Colors: Red, Orange, Gold, Light Green, Green, Light Blue, Purple
+		 */
+		PF_RED("#8b0000"),
+		PF_RED_100("#cc0000"),
+		PF_RED_200("#a30000"),
+		PF_RED_300("#8b0000"),
+		PF_RED_400("#470000"),
+		PF_RED_500("#2c0000"),
+
+		PF_ORANGE("#ec7a08"),
+		PF_ORANGE_100("#fbdebf"),
+		PF_ORANGE_200("#f7bd7f"),
+		PF_ORANGE_300("#f39d3c"),
+		PF_ORANGE_400("#ec7a08"),
+		PF_ORANGE_500("#b35c00"),
+		PF_ORANGE_600("#773d00"),
+		PF_ORANGE_700("#3b1f00"),
+
+		PF_GOLD("#f0ab00"),
+		PF_GOLD_100("#fbeabc"),
+		PF_GOLD_200("#f9d67a"),
+		PF_GOLD_300("#f5c12e"),
+		PF_GOLD_400("#f0ab00"),
+		PF_GOLD_500("#b58100"),
+		PF_GOLD_600("#795600"),
+		PF_GOLD_700("#3d2c00"),
+
+		PF_LIGHT_GREEN("#92d400"),
+		PF_LIGHT_GREEN_100("#e4f5bc"),
+		PF_LIGHT_GREEN_200("#c8eb79"),
+		PF_LIGHT_GREEN_300("#ace12e"),
+		PF_LIGHT_GREEN_400("#92d400"),
+		PF_LIGHT_GREEN_500("#6ca100"),
+		PF_LIGHT_GREEN_600("#486b00"),
+		PF_LIGHT_GREEN_700("#253600"),
+
+		PF_GREEN("#3f9c35"),
+		PF_GREEN_100("#cfe7cd"),
+		PF_GREEN_200("#9ecf99"),
+		PF_GREEN_300("#6ec664"),
+		PF_GREEN_400("#3f9c35"),
+		PF_GREEN_500("#2d7623"),
+		PF_GREEN_600("#1e4f18"),
+		PF_GREEN_700("#0f280d"),
+
+		PF_CYAN("#007a87"),
+		PF_CYAN_100("#bedee1"),
+		PF_CYAN_200("#7dbdc3"),
+		PF_CYAN_300("#3a9ca6"),
+		PF_CYAN_400("#007a87"),
+		PF_CYAN_500("#005c66"),
+		PF_CYAN_600("#003d44"),
+		PF_CYAN_700("#001f22"),
+
+		PF_LIGHT_BLUE("#00b9e4"),
+		PF_LIGHT_BLUE_100("#beedf9"),
+		PF_LIGHT_BLUE_200("#7cdbf3"),
+		PF_LIGHT_BLUE_300("#35caed"),
+		PF_LIGHT_BLUE_400("#00b9e4"),
+		PF_LIGHT_BLUE_500("#008bad"),
+		PF_LIGHT_BLUE_600("#005c73"),
+		PF_LIGHT_BLUE_700("#002d39"),
+
+		PF_PURPLE("#703fec"),
+		PF_PURPLE_100("#c7bfff"),
+		PF_PURPLE_200("#a18fff"),
+		PF_PURPLE_300("#8461f7"),
+		PF_PURPLE_400("#703fec"),
+		PF_PURPLE_500("#582fc0"),
+		PF_PURPLE_600("#40199a"),
+		PF_PURPLE_700("#1f0066");
+
+		private final String color;
+
+		Palette(String color) {
+			this.color = color;
+		}
+
+		/**
+		 * Return a color object of the type corresponding to the constant passed into the method.
+		 * This function first converts the PatternFly color hex value to an AWT Color object. Next,
+		 * it either returns the AWT Color object if the constant type is AWT, or uses the RGB
+		 * values to generate an SWT Color object.
+		 *
+		 * @param type
+		 *            String constant: AWT or SWT
+		 * @return a RGB color (as a regular Object to be casted later)
+		 */
+		private Object parseRGB(String type) {
+			java.awt.Color awtColor = new java.awt.Color(java.awt.Color.decode(this.color).getRGB());
+			switch (type) {
+			case (AWT):
+				return awtColor;
+			case (SWT):
+				return new org.eclipse.swt.graphics.Color(Display.getCurrent(), awtColor.getRed(), awtColor.getGreen(),
+						awtColor.getBlue());
+			default:
+				return null;
+			}
+		}
+
+		/**
+		 * Converts the PatternFly hex color value to an AWT Color object
+		 * 
+		 * @return AWT Color of the selected PatternFly color
+		 */
+		public java.awt.Color getAWTColor() {
+			return (java.awt.Color) parseRGB(AWT);
+		}
+
+		/**
+		 * Converts the PatternFly hex color value to an SWT Color object
+		 * 
+		 * @return SWT Color of the selected PatternFly color
+		 */
+		public org.eclipse.swt.graphics.Color getSWTColor() {
+			return (org.eclipse.swt.graphics.Color) parseRGB(SWT);
+		}
+
+		/**
+		 * Page & Component Specific Colors
+		 */
+		public static Color getThreadsPageBackgroundColor() {
+			return PF_BLACK_200.getSWTColor();
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimeFilter.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+
+import org.eclipse.jface.resource.JFaceResources;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Button;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Listener;
+import org.eclipse.swt.widgets.Text;
+
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.common.unit.UnitLookup;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class TimeFilter extends Composite {
+
+	private enum FilterType {
+		START, END
+	};
+
+	private static final String dateFormat = "yyyy-MM-dd ";
+	private static final String timeFormat = "HH:mm:ss:SSS";
+	private boolean isMultiDayRecording = false;
+	public Calendar calendar;
+	private ChartCanvas chartCanvas;
+	private XYChart chart;
+	private SimpleDateFormat sdf;
+	private SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);
+	private TimeDisplay startDisplay;
+	private TimeDisplay endDisplay;
+
+	public TimeFilter(Composite parent, IRange<IQuantity> recordingRange, Listener resetListener) {
+		super(parent, SWT.NONE);
+		this.setBackground(Palette.getThreadsPageBackgroundColor());
+		this.setLayout(new GridLayout(7, false));
+
+		inspectRecordingRange(recordingRange);
+
+		Label eventsLabel = new Label(this, SWT.LEFT);
+		eventsLabel.setText(Messages.TimeFilter_FILTER_EVENTS);
+		eventsLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.BANNER_FONT));
+		eventsLabel.setBackground(Palette.getThreadsPageBackgroundColor());
+
+		Label fromLabel = new Label(this, SWT.CENTER);
+		fromLabel.setText(Messages.TimeFilter_FROM);
+		fromLabel.setBackground(Palette.getThreadsPageBackgroundColor());
+
+		startDisplay = new TimeDisplay(this, FilterType.START, recordingRange.getStart());
+
+		Label toLabel = new Label(this, SWT.CENTER);
+		toLabel.setText(Messages.TimeFilter_TO);
+		toLabel.setBackground(Palette.getThreadsPageBackgroundColor());
+
+		endDisplay = new TimeDisplay(this, FilterType.END, recordingRange.getEnd());
+
+		Button resetBtn = new Button(this, SWT.PUSH);
+		resetBtn.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));
+		resetBtn.setText(Messages.TimeFilter_RESET);
+		resetBtn.addListener(SWT.Selection, resetListener);
+	}
+
+	/**
+	 * Determines whether or not the time range of the recording spans multiple days, and if not,
+	 * sets up a Calendar object to hold the date of the recording.
+	 * 
+	 * @param recordingRange
+	 */
+	private void inspectRecordingRange(IRange<IQuantity> recordingRange) {
+		long firstDateEpoch = recordingRange.getStart().in(UnitLookup.EPOCH_MS).longValue();
+		long secondDateEpoch = recordingRange.getEnd().in(UnitLookup.EPOCH_MS).longValue();
+		isMultiDayRecording = !dateFormatter.format(firstDateEpoch).equals(dateFormatter.format(secondDateEpoch));
+		if (!isMultiDayRecording) {
+			calendar = Calendar.getInstance();
+			calendar.setTimeInMillis(firstDateEpoch);
+			calendar.set(Calendar.HOUR_OF_DAY, 0);
+			calendar.set(Calendar.MINUTE, 0);
+			calendar.set(Calendar.SECOND, 0);
+			calendar.set(Calendar.MILLISECOND, 0);
+			calendar.add(Calendar.MILLISECOND, calendar.getTimeZone().getRawOffset());
+		}
+	}
+
+	protected void updateRange() {
+		chart.setVisibleRange(startDisplay.getCurrentTime(), endDisplay.getCurrentTime());
+		chartCanvas.redrawChart();
+	}
+
+	public void setChart(XYChart chart) {
+		this.chart = chart;
+	}
+
+	public void setChartCanvas(ChartCanvas canvas) {
+		this.chartCanvas = canvas;
+	}
+
+	public void setStartTime(IQuantity time) {
+		startDisplay.setTime(time);
+	}
+
+	public void setEndTime(IQuantity time) {
+		endDisplay.setTime(time);
+	}
+
+	private class TimeDisplay extends Composite {
+
+		private boolean bypassModifyListener;
+		private FilterType type;
+		private int lastEventTime;
+		private IQuantity defaultTime;
+		private IQuantity currentTime;
+		private Text timeText;
+
+		public TimeDisplay(TimeFilter parent, FilterType type, IQuantity defaultTime) {
+			super(parent, SWT.NONE);
+			this.type = type;
+			this.defaultTime = defaultTime;
+			this.setBackground(Palette.getThreadsPageBackgroundColor());
+			this.setLayout(new GridLayout());
+			timeText = new Text(this, SWT.SEARCH | SWT.SINGLE);
+			// if the recording spans multiple days, include the date in the time display
+			if (!isMultiDayRecording) {
+				timeText.setTextLimit(12);
+				sdf = new SimpleDateFormat(timeFormat);
+			} else {
+				timeText.setTextLimit(23);
+				sdf = new SimpleDateFormat(dateFormat + timeFormat);
+			}
+			timeText.addModifyListener(new ModifyListener() {
+				@Override
+				public void modifyText(ModifyEvent e) {
+					if (getBypassModifyListener()) {
+						setBypassModifyListener(false);
+						return;
+					}
+
+					/**
+					 * If the user edits a Text by highlighting a character and overwrites it with a
+					 * new one, the ModifyListener will fire twice. To prevent validation (and
+					 * potential error dialogs) from occurring twice, compare the time of the
+					 * current ModifyEvent to the last seen ModifyEvent.
+					 */
+					if (e.time == lastEventTime) {
+						return;
+					} else {
+						lastEventTime = e.time;
+					}
+
+					String newTimestring = timeText.getText();
+					if (!isValidSyntax(newTimestring)) {
+						return;
+					}
+					IQuantity newTime = convertStringToIQuantity(newTimestring);
+					if (currentTime == null || newTime == null) {
+						return;
+					}
+					if (isWithinRange(newTime)) {
+						timeText.setForeground(Palette.PF_BLACK.getSWTColor());
+						currentTime = newTime;
+						parent.updateRange();
+					} else {
+						timeText.setForeground(Palette.PF_RED_100.getSWTColor());
+					}
+				}
+			});
+		}
+
+		/**
+		 * Converts the IQuantity time to a string and displays it in the Text
+		 * 
+		 * @param time
+		 *            IQuantity
+		 */
+		public void setTime(IQuantity time) {
+			setBypassModifyListener(true);
+			String timestring = sdf.format(new Date(time.in(UnitLookup.EPOCH_MS).longValue()));
+			this.currentTime = time;
+			timeText.setText(timestring);
+			timeText.setForeground(Palette.PF_BLACK.getSWTColor());
+			setBypassModifyListener(false);
+		}
+
+		/**
+		 * Converts a formatted time string into an IQuantity. If the recording range is within a
+		 * single day, the SimpleDateFormat format will be HH:mm:ss:SSS and need to be added to the
+		 * base date (calendar) in order to calculate the epoch milliseconds.
+		 *
+		 * @param timestring
+		 *            String
+		 * @return IQuantity
+		 */
+		private IQuantity convertStringToIQuantity(String timestring) {
+			try {
+				long parsedTime = sdf.parse(timestring).getTime();
+				if (!isMultiDayRecording) {
+					parsedTime += calendar.getTimeInMillis();
+				}
+				return UnitLookup.EPOCH_MS.quantity(parsedTime);
+			} catch (ParseException e) {
+			}
+			return null;
+		}
+
+		/**
+		 * Verify that the passed time is within the recording range
+		 * 
+		 * @param time
+		 *            IQuantity
+		 * @return true if the specified time is within the time range of the recording
+		 */
+		private boolean isWithinRange(IQuantity time) {
+			if (time == null) {
+				return false;
+			}
+			long timeMillis = time.in(UnitLookup.EPOCH_MS).longValue();
+			if (type == FilterType.START) {
+				if (timeMillis < defaultTime.in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_START_TIME_PRECEEDS_ERROR);
+					return false;
+				} else if (timeMillis > endDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue()
+						|| timeMillis > endDisplay.getCurrentTime().in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_START_TIME_LONGER_THAN_END_ERROR);
+					endDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue();
+					return false;
+				}
+			} else {
+				if (timeMillis > defaultTime.in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_END_TIME_EXCEEDS_ERROR);
+					return false;
+				} else if (timeMillis < startDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue()
+						|| timeMillis < startDisplay.getCurrentTime().in(UnitLookup.EPOCH_MS).longValue()) {
+					DialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,
+							Messages.TimeFilter_START_TIME_LONGER_THAN_END_ERROR);
+					return false;
+				}
+			}
+			return true;
+		}
+
+		/**
+		 * Verify that the passed time string matches the expected time format
+		 * 
+		 * @param formattedTimestring
+		 *            String
+		 * @return true if the text corresponds to the current SimpleDateFormat format
+		 */
+		private boolean isValidSyntax(String formattedTimestring) {
+			if (formattedTimestring.length() != timeText.getTextLimit()) {
+				return false;
+			}
+			try {
+				sdf.parse(formattedTimestring);
+			} catch (ParseException e) {
+				return false;
+			}
+			return true;
+		}
+
+		private IQuantity getDefaultTime() {
+			return defaultTime;
+		}
+
+		private IQuantity getCurrentTime() {
+			return currentTime;
+		}
+
+		// When programmatically changing the Text (e.g., this.setTime()), use
+		// a boolean to prevent the ModifyListener from firing
+		private boolean getBypassModifyListener() {
+			return this.bypassModifyListener;
+		}
+
+		private void setBypassModifyListener(boolean bypassModifyListener) {
+			this.bypassModifyListener = bypassModifyListener;
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java
--- /dev/null
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/misc/TimelineCanvas.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.ui.misc;
+
+import java.awt.Graphics2D;
+
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.MouseMoveListener;
+import org.eclipse.swt.events.PaintEvent;
+import org.eclipse.swt.events.PaintListener;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Canvas;
+import org.eclipse.swt.widgets.Composite;
+
+import org.openjdk.jmc.common.unit.IQuantity;
+import org.openjdk.jmc.common.unit.IRange;
+import org.openjdk.jmc.ui.charts.AWTChartToolkit;
+import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;
+import org.openjdk.jmc.ui.charts.XYChart;
+import org.openjdk.jmc.ui.misc.PatternFly.Palette;
+
+public class TimelineCanvas extends Canvas {
+	private static final int BASE_RANGE_INDICATOR_HEIGHT = 10;
+	private static final int BASE_RANGE_INDICATOR_Y_OFFSET = 25;
+	private int rangeIndicatorHeight;
+	private int rangeIndicatorYOffset;
+	private int x1;
+	private int x2;
+	private int xOffset;
+	private AwtCanvas awtCanvas;
+	private ChartCanvas chartCanvas;
+	private Graphics2D g2d;
+	private IRange<IQuantity> chartRange;
+	private Rectangle dragRect;
+	private Rectangle indicatorRect;
+	private Rectangle timelineRect;
+	private SashForm sashForm;
+	private SubdividedQuantityRange xTickRange;
+	private XYChart chart;
+
+	public TimelineCanvas(Composite parent, ChartCanvas chartCanvas, SashForm sashForm, double yScale) {
+		super(parent, SWT.NONE);
+		this.chartCanvas = chartCanvas;
+		this.sashForm = sashForm;
+		awtCanvas = new AwtCanvas();
+		addPaintListener(new TimelineCanvasPainter());
+		DragDetector dragDetector = new DragDetector();
+		addMouseListener(dragDetector);
+		addMouseMoveListener(dragDetector);
+		rangeIndicatorHeight = (int) (BASE_RANGE_INDICATOR_HEIGHT * yScale);
+		rangeIndicatorYOffset = (int) (BASE_RANGE_INDICATOR_Y_OFFSET * yScale);
+	}
+
+	private int calculateXOffset() {
+		int offset = sashForm.getChildren()[0].getSize().x + sashForm.getSashWidth()
+				- getParent().getChildren()[0].getSize().x;
+		return Math.max(offset, 0);
+	}
+
+	public void renderRangeIndicator(int x1, int x2) {
+		this.x1 = x1;
+		this.x2 = x2;
+		this.redraw();
+	}
+
+	public void setXTickRange(SubdividedQuantityRange xTickRange) {
+		this.xTickRange = xTickRange;
+	}
+
+	public void setChart(XYChart chart) {
+		this.chart = chart;
+		chartRange = chart.getVisibleRange();
+	}
+
+	private class TimelineCanvasPainter implements PaintListener {
+
+		@Override
+		public void paintControl(PaintEvent e) {
+			xOffset = chartCanvas.translateDisplayToImageXCoordinates(calculateXOffset());
+
+			Rectangle rect = getClientArea();
+			g2d = awtCanvas.getGraphics(rect.width, rect.height);
+
+			// Draw the background
+			Point adjusted = chartCanvas.translateDisplayToImageCoordinates(rect.width, rect.height);
+			g2d.setColor(Palette.PF_BLACK_100.getAWTColor());
+			g2d.fillRect(0, 0, adjusted.x, adjusted.y);
+
+			// Draw the horizontal axis
+			if (xTickRange != null) {
+				g2d.setColor(Palette.PF_BLACK.getAWTColor());
+				AWTChartToolkit.drawAxis(g2d, xTickRange, 0, false, 1, false, xOffset);
+			}
+
+			// Draw the range indicator
+			indicatorRect = dragRect != null ? dragRect
+					: new Rectangle(x1 + xOffset,
+							chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorYOffset), x2 - x1,
+							chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorHeight));
+			dragRect = null;
+			g2d.setPaint(Palette.PF_ORANGE_400.getAWTColor());
+			g2d.fillRect(indicatorRect.x, indicatorRect.y, indicatorRect.width, indicatorRect.height);
+
+			Point totalSize = sashForm.getChildren()[1].getSize();
+			adjusted = chartCanvas.translateDisplayToImageCoordinates(totalSize.x, totalSize.y);
+			timelineRect = new Rectangle(xOffset,
+					chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorYOffset), adjusted.x,
+					chartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorHeight));
+			g2d.setPaint(Palette.PF_BLACK_600.getAWTColor());
+			g2d.drawRect(timelineRect.x, timelineRect.y, timelineRect.width, timelineRect.height);
+
+			awtCanvas.paint(e, 0, 0);
+		}
+	}
+
+	private class DragDetector extends MouseAdapter implements MouseMoveListener {
+
+		boolean isDrag = false;
+		Point currentSelection;
+		Point lastSelection;
+
+		@Override
+		public void mouseDown(MouseEvent e) {
+			e.x = chartCanvas.translateDisplayToImageXCoordinates(e.x);
+			e.y = chartCanvas.translateDisplayToImageYCoordinates(e.y);
+			if (isDrag || e.button == 1 && timelineRect.contains(e.x, e.y)) {
+				isDrag = true;
+				currentSelection = new Point(e.x, e.y);
+			}
+		}
+
+		@Override
+		public void mouseUp(MouseEvent e) {
+			isDrag = false;
+			chart.setIsZoomPanDrag(false);
+		}
+
+		@Override
+		public void mouseMove(MouseEvent e) {
+			e.x = chartCanvas.translateDisplayToImageXCoordinates(e.x);
+			e.y = chartCanvas.translateDisplayToImageYCoordinates(e.y);
+			if (timelineRect.contains(e.x, e.y)) {
+				setCursor(getDisplay().getSystemCursor(SWT.CURSOR_HAND));
+			} else {
+				setCursor(getDisplay().getSystemCursor(SWT.CURSOR_ARROW));
+			}
+			if (isDrag) {
+				lastSelection = currentSelection;
+				chart.setIsZoomPanDrag(true);
+				currentSelection = new Point(e.x, e.y);
+				int xdiff = currentSelection.x - lastSelection.x;
+				updateTimelineIndicatorFromDrag(xdiff);
+			}
+		}
+
+		private void updateTimelineIndicatorFromDrag(int xdiff) {
+			if (xdiff != 0 && (indicatorRect.x + xdiff) >= timelineRect.x
+					&& (indicatorRect.x + xdiff + indicatorRect.width) <= timelineRect.x + timelineRect.width) {
+				indicatorRect.x = indicatorRect.x + xdiff;
+				SubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),
+						timelineRect.width, 1);
+				chart.setVisibleRange(xAxis.getQuantityAtPixel(indicatorRect.x - xOffset),
+						xAxis.getQuantityAtPixel(indicatorRect.x - xOffset + indicatorRect.width));
+				dragRect = indicatorRect;
+				chartCanvas.redrawChart();
+			}
+		}
+	}
+}
diff a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java
--- a/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java
+++ b/application/org.openjdk.jmc.ui/src/main/java/org/openjdk/jmc/ui/wizards/OnePageWizardDialog.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -148,6 +148,14 @@
 		OnePageWizardDialog d = new OnePageWizardDialog(Display.getCurrent().getActiveShell(), wp);
 		d.setWidthConstraint(width, width);
 		d.setHeightConstraint(height, height);
 		return d.open();
 	}
+
+	public static int openAndHideCancelButton(IWizardPage wp, int width, int height) {
+		OnePageWizardDialog d = new OnePageWizardDialog(Display.getCurrent().getActiveShell(), wp);
+		d.setHideCancelButton(true);
+		d.setWidthConstraint(width, width);
+		d.setHeightConstraint(height, height);
+		return d.open();
+	}
 }
diff a/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties b/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
--- a/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
+++ b/application/org.openjdk.jmc.ui/src/main/resources/org/openjdk/jmc/ui/misc/messages.properties
@@ -1,7 +1,7 @@
 #
-#  Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+#  Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
 #
 #  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 #  The contents of this file are subject to the terms of either the Universal Permissive License 
 #  v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -28,10 +28,19 @@
 #  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 #  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 #  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 #  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
+ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP=Scale-to-Fit
+ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP=Selection Tool
+ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP=Click: Toggle Click-to-Zoom-In mode
+ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP=Hold: Continuous Zoom-In
+ChartDisplayControlBar_ZOOM_PAN_TOOLTIP=Toggle Zoom-Pan Display
+ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP=Click: Toggle Click-to-Zoom-Out mode
+ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP=Hold: Continuous Zoom-Out
+ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP=Decrease thread lane height
+ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP=Increase thread lane height
 NumberFieldEditor_ERROR_MESSAGE_INTERVAL=Must be {0} between {1} and {2}
 NumberFieldEditor_ERROR_MESSAGE_NO_GREATER=Must be {0} no greater than {2}
 NumberFieldEditor_ERROR_MESSAGE_NO_SMALLER=Must be {0} no smaller than {1}
 NumberFieldEditor_ERROR_MESSAGE_MUST_BE=Must be {0}
 IntFieldEditor_ERROR_MESSAGE_PART_POSITIVE_INTEGER=positive integer
@@ -93,5 +102,15 @@
 DIALOG_OVERWRITE_QUESTION_TEXT=A file with name {0} already exists. Do you want to overwrite it?
 MOVE_LEFT=Move left
 MOVE_RIGHT=Move right
 QuestionLinkDialog_FAILED_OPEN_BROWSER=Failed to open browser
 ProgressComposite_PLEASE_WAIT=Please Wait...
+TimeFilter_END_TIME_EXCEEDS_ERROR=The selected end time exceeds the range of the recording.
+TimeFilter_ERROR=Time Filter Error
+TimeFilter_FILTER=Filter
+TimeFilter_FILTER_EVENTS=Filter Events
+TimeFilter_FROM=From
+TimeFilter_INVALID_FORMAT_ERROR=Invalid time format
+TimeFilter_RESET=Reset
+TimeFilter_START_TIME_LONGER_THAN_END_ERROR=The selected start time exceeds the specified end time.
+TimeFilter_START_TIME_PRECEEDS_ERROR=The selected start time precedes the range of the recording.
+TimeFilter_TO=to
diff a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
--- a/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
+++ b/application/uitests/org.openjdk.jmc.flightrecorder.uitest/src/test/java/org/openjdk/jmc/flightrecorder/uitest/JfrThreadsPageTest.java
@@ -31,50 +31,173 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 package org.openjdk.jmc.flightrecorder.uitest;
 
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.function.Supplier;
+
 import org.junit.Assert;
 import org.junit.Rule;
 import org.junit.Test;
 import org.openjdk.jmc.test.jemmy.MCJemmyTestBase;
 import org.openjdk.jmc.test.jemmy.MCUITestRule;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCChartCanvas;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrNavigator;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.JfrUi;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCButton;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCMenu;
 import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTable;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCText;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTextCanvas;
+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCToolBar;
+import org.openjdk.jmc.ui.UIPlugin;
 
 public class JfrThreadsPageTest extends MCJemmyTestBase {
 
 	private static final String PLAIN_JFR = "plain_recording.jfr";
 	private static final String TABLE_COLUMN_HEADER = "Thread";
+	private static final String OK_BUTTON = "OK";
+	private static final String RESET_BUTTON = "Reset";
+	private static final String START_TIME = "08:06:19:489";
+	private static final String NEW_START_TIME = "08:06:19:500";
+	private static final String INVALID_START_TIME = "08:06:19:480";
+	private static final String INVALID_END_TIME = "08:07:19:733";
+	private static final String DEFAULT_ZOOM = "100.00 %";
 	private static final String HIDE_THREAD = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_HIDE_THREAD_ACTION;
 	private static final String RESET_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_RESET_CHART_TO_SELECTION_ACTION;
+	private static final String TABLE_TOOLTIP = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_VIEW_THREAD_DETAILS;
+	private static final String TABLE_SHELL_TEXT = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_TABLE_POPUP_TITLE;
+	private static final String TIME_FILTER_ERROR = org.openjdk.jmc.ui.misc.Messages.TimeFilter_ERROR;
 
 	private static MCChartCanvas chartCanvas;
+	private static MCTextCanvas textCanvas;
 	private static MCTable threadsTable;
+	private boolean selected;
 
 	@Rule
 	public MCUITestRule testRule = new MCUITestRule(verboseRuleOutput) {
 		@Override
 		public void before() {
 			JfrUi.openJfr(materialize("jfr", PLAIN_JFR, JfrThreadsPageTest.class));
 			JfrNavigator.selectTab(JfrUi.Tabs.THREADS);
-			threadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);
 			chartCanvas = MCChartCanvas.getChartCanvas();
+			textCanvas = MCTextCanvas.getTextCanvas();
+			selected = false;
 		}
 
 		@Override
 		public void after() {
+			selected = false;
 			MCMenu.closeActiveEditor();
 		}
 	};
 
+	@Test
+	public void testTextCanvasSelection() throws InterruptedException, ExecutionException, TimeoutException {
+		openThreadsTable();
+		threadsTable.selectItems(0, 0);
+		Assert.assertEquals(1, threadsTable.getSelectionCount());
+		closeThreadsTable();
+
+		CompletableFuture<Void> future = new CompletableFuture<>();
+		CompletableFuture.supplyAsync(new Supplier<Void>() {
+
+			@Override
+			public Void get() {
+				textCanvas.setSelectionListener(() -> {
+					selected = !selected;
+					future.complete(null);
+				});
+				textCanvas.clickTextCanvas();
+				return future.join();
+			}
+
+		}).get(10, TimeUnit.SECONDS);
+
+		Assert.assertTrue(selected);
+	}
+
+	@Test
+	public void testZoom() {
+		MCButton zoomInBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));
+		MCButton zoomOutBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));
+		MCText zoomDisplay = MCText.getByText(DEFAULT_ZOOM);
+
+		//zoom with display bar
+		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+		zoomInBtn.click();
+		chartCanvas.clickChart();
+		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+
+		zoomOutBtn.click();
+		chartCanvas.clickChart();
+		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+
+		//zoom with controls
+		chartCanvas.clickChart();
+		chartCanvas.keyboardZoomIn();
+		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+
+		chartCanvas.keyboardZoomOut();
+		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+	}
+
+	@Test
+	public void testResetButtons() {
+		MCText StartTimeField = MCText.getByText(START_TIME);
+		MCText zoomDisplay = MCText.getByText(DEFAULT_ZOOM);
+		MCButton resetBtn = MCButton.getByLabel(RESET_BUTTON);
+		MCButton scaleToFitBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));
+
+		StartTimeField.setText(NEW_START_TIME);
+		Assert.assertNotEquals(START_TIME, StartTimeField.getText());
+		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+
+		resetBtn.click();
+		Assert.assertEquals(START_TIME, StartTimeField.getText());
+		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+
+		StartTimeField.setText(NEW_START_TIME);
+		Assert.assertNotEquals(START_TIME, StartTimeField.getText());
+		Assert.assertNotEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+
+		scaleToFitBtn.click();
+		Assert.assertEquals(zoomDisplay.getText(), DEFAULT_ZOOM);
+		Assert.assertEquals(START_TIME, StartTimeField.getText());
+	}
+
+	@Test
+	public void testTimeFilterInvalid() {
+		MCText startTimeField = MCText.getByText(START_TIME);
+		MCText endTimeField = MCText.getByText(START_TIME);
+		MCButton resetBtn = MCButton.getByLabel(RESET_BUTTON);
+
+		startTimeField.setText(INVALID_START_TIME);
+		MCButton okButton = MCButton.getByLabel(TIME_FILTER_ERROR, OK_BUTTON);
+		Assert.assertNotNull(okButton);
+		okButton.click();
+
+		MCButton.focusMc();
+		resetBtn.click();
+		Assert.assertEquals(START_TIME, startTimeField.getText());
+
+		endTimeField.setText(INVALID_END_TIME);
+		okButton = MCButton.getByLabel(TIME_FILTER_ERROR, OK_BUTTON);
+		Assert.assertNotNull(okButton);
+		okButton.click();
+	}
+
 	@Test
 	public void testMenuItemEnablement() {
+		openThreadsTable();
 		final int numThreads = threadsTable.getItemCount();
+		closeThreadsTable();
+
 		Assert.assertTrue(numThreads > 0);
 
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 
@@ -90,17 +213,23 @@
 	}
 
 	@Test
 	public void testHideAllThreads() {
 		final int numSelection = 7;
+
+		openThreadsTable();
 		final int numThreads = threadsTable.getItemCount();
+		closeThreadsTable();
+
 		Assert.assertTrue(numThreads > 0 && numThreads >= numSelection);
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 
+		openThreadsTable();
 		// Select a limited number of threads in the chart using the table
 		threadsTable.selectItems(0, numSelection - 1);
+		closeThreadsTable();
 
 		// Hide all the threads from the chart
 		for (int i = 0; i < numSelection; i++) {
 			chartCanvas.clickContextMenuItem(HIDE_THREAD);
 		}
@@ -113,6 +242,43 @@
 
 		// Verify the menu item isEnabled values are back to their default values
 		Assert.assertTrue(chartCanvas.isContextMenuItemEnabled(HIDE_THREAD));
 		Assert.assertFalse(chartCanvas.isContextMenuItemEnabled(RESET_CHART));
 	}
+
+	@Test
+	public void testPopupTableSelection() {
+		openThreadsTable();
+		final int numSelection = 7;
+		final int numThreads = threadsTable.getItemCount();
+		Assert.assertTrue(numThreads > 0 && numThreads >= numSelection);
+
+		threadsTable.selectItems(0, numSelection - 1);
+		int originalSelection = threadsTable.getSelectionCount();
+		Assert.assertEquals(numSelection, originalSelection);
+		closeThreadsTable();
+
+		openThreadsTable();
+		int newSelection = threadsTable.getSelectionCount();
+		Assert.assertEquals(newSelection, originalSelection);
+		closeThreadsTable();
+	}
+
+	private void openThreadsTable() {
+		if (threadsTable == null) {
+			MCToolBar.focusMc();
+			MCToolBar tb = MCToolBar.getByToolTip(TABLE_TOOLTIP);
+			tb.clickToolItem(TABLE_TOOLTIP);
+			threadsTable = MCTable.getByColumnHeader(TABLE_SHELL_TEXT, TABLE_COLUMN_HEADER);
+		}
+	}
+
+	private void closeThreadsTable() {
+		if (threadsTable != null) {
+			MCButton okButton = MCButton.getByLabel(TABLE_SHELL_TEXT, OK_BUTTON);
+			okButton.click();
+			threadsTable = null;
+			MCToolBar.focusMc();
+		}
+	}
+
 }
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/base/wrappers/MCJemmyBase.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -211,10 +211,21 @@
 	 */
 	protected static Wrap<? extends Shell> getShell() {
 		return Shells.SHELLS.lookup(Shell.class, new ByTextShell<>("JDK Mission Control")).wrap();
 	}
 
+	/**
+	 * Gets a shell by text
+	 *
+	 * @param text
+	 *            the text string to lookup the shell with
+	 * @return the associated shell
+	 */
+	protected static Wrap<? extends Shell> getShellByText(String text) {
+		return Shells.SHELLS.lookup(Shell.class, new ByTextShell<>(text)).wrap();
+	}
+
 	/**
 	 * Tries to set focus on Mission Control
 	 */
 	public static void focusMc() {
 		getShell().as(Focusable.class).focuser().focus();
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCButton.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -34,10 +34,11 @@
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.swt.graphics.Image;
 import org.eclipse.swt.widgets.Button;
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.swt.widgets.Shell;
 import org.jemmy.Point;
 import org.jemmy.control.Wrap;
@@ -58,10 +59,49 @@
 
 	private MCButton(Wrap<? extends Button> button) {
 		this.control = button;
 	}
 
+	/**
+	 * Finds a button in the supplied shell by image and returns it.
+	 *
+	 * @param shell
+	 *            the shell where to search for the button
+	 * @param image
+	 *            the image to look up the button with
+	 * @return a {@link MCButton} (possibly null)
+	 */
+	@SuppressWarnings("unchecked")
+	public static MCButton getByImage(Wrap<? extends Shell> shell, Image image) {
+		List<Wrap<? extends Button>> allVisibleButtonWraps = getVisible(
+				shell.as(Parent.class, Button.class).lookup(Button.class));
+		for (final Wrap<? extends Button> buttonWrap : allVisibleButtonWraps) {
+			Fetcher<Image> fetcher = new Fetcher<Image>() {
+				@Override
+				public void run() {
+					setOutput(buttonWrap.getControl().getImage());
+				}
+			};
+			Display.getDefault().syncExec(fetcher);
+			if (image.equals(fetcher.getOutput())) {
+				return new MCButton(buttonWrap);
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Finds a button in the default Mission Control shell and returns it.
+	 *
+	 * @param image
+	 *            the image of the button
+	 * @return a {@link MCButton} in the default shell matching the image.
+	 */
+	public static MCButton getByImage(Image image) {
+		return getByImage(getShell(), image);
+	}
+
 	/**
 	 * Finds a button in the default Mission Control shell and returns it.
 	 *
 	 * @param label
 	 *            the {@link MCButton} Label of the button
@@ -93,10 +133,23 @@
 	 */
 	public static MCButton getByLabel(String label) {
 		return getByLabel(getShell(), label);
 	}
 
+	/**
+	 * Finds a button in a shell with the given text and returns it.
+	 *
+	 * @param label
+	 *            the label string of the button
+	 * @param shellText
+	 *            the text to look up the shell that the button is contained in
+	 * @return a {@link MCButton} in the shell matching the label
+	 */
+	public static MCButton getByLabel(String shellText, String label) {
+		return getByLabel(getShellByText(shellText), label);
+	}
+
 	/**
 	 * Finds a button by button label and returns it
 	 *
 	 * @param shell
 	 *            the shell where to find the button
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCChartCanvas.java
@@ -42,10 +42,12 @@
 import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;
 import org.openjdk.jmc.ui.misc.ChartCanvas;
 import org.jemmy.Point;
 import org.jemmy.control.Wrap;
 import org.jemmy.input.StringPopupOwner;
+import org.jemmy.interfaces.Keyboard.KeyboardButtons;
+import org.jemmy.interfaces.Mouse.MouseButtons;
 import org.jemmy.interfaces.Parent;
 import org.jemmy.resources.StringComparePolicy;
 
 /**
  * The Jemmy wrapper for the Mission Control Chart Canvas.
@@ -107,10 +109,36 @@
 		StringPopupOwner<Shell> contextMenu = control.as(StringPopupOwner.class);
 		contextMenu.setPolicy(StringComparePolicy.SUBSTRING);
 		contextMenu.push(getRelativeClickPoint(), new String[] {menuItemText});
 	}
 
+	/**
+	 * Click the center of the chart in the ChartCanvas
+	 */
+	@SuppressWarnings("unchecked")
+	public void clickChart() {
+		Display.getDefault().syncExec(() -> {
+			control.mouse().click(1, getRelativeClickPoint(), MouseButtons.BUTTON1);
+		});
+	}
+
+	/**
+	 * Zoom in the chart with keyboard controls
+	 */
+	public void keyboardZoomIn() {
+		control.keyboard().pushKey(KeyboardButtons.UP);
+		waitForIdle();
+	}
+
+	/**
+	 * Zoom out the chart with keyboard controls
+	 */
+	public void keyboardZoomOut() {
+		control.keyboard().pushKey(KeyboardButtons.DOWN);
+		waitForIdle();
+	}
+
 	/**
 	 * Checks the isEnabled value for a menu item in the context menu
 	 *
 	 * @param menuItemText
 	 *            the menu item of interest
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java
--- a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTable.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
  * 
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * The contents of this file are subject to the terms of either the Universal Permissive License
  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
@@ -276,10 +276,23 @@
 	 */
 	public static MCTable getByColumnHeader(String headerName) {
 		return getByColumnHeader(getShell(), headerName);
 	}
 
+	/**
+	 * Finds tables by column header (first match only)
+	 *
+	 * @param shellText
+	 *            text to look up the shell that contains the table
+	 * @param headerName
+	 *            the name of the column header
+	 * @return a {@link MCTable}
+	 */
+	public static MCTable getByColumnHeader(String shellText, String headerName) {
+		return getByColumnHeader(getShellByText(shellText), headerName);
+	}
+
 	/**
 	 * Finds tables by column header (first match only)
 	 *
 	 * @param shell
 	 *            the shell in which to look for the table
@@ -513,10 +526,28 @@
 		};
 		Display.getDefault().syncExec(fetcher);
 		return fetcher.getOutput().intValue();
 	}
 
+	/**
+	 * Gets the number of items selected in the table
+	 *
+	 * @return the number of items selected in the table
+	 */
+	public int getSelectionCount() {
+		final Table table = getWrap().getControl();
+		Fetcher<Integer> fetcher = new Fetcher<Integer>() {
+			@Override
+			public void run() {
+				int count = table.getSelectionCount();
+				setOutput(count);
+			}
+		};
+		Display.getDefault().syncExec(fetcher);
+		return fetcher.getOutput().intValue();
+	}
+
 	/**
 	 * Whether or not the table contains the text given
 	 *
 	 * @param item
 	 *            the text
diff a/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTextCanvas.java b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTextCanvas.java
--- /dev/null
+++ b/application/uitests/org.openjdk.jmc.test.jemmy/src/test/java/org/openjdk/jmc/test/jemmy/misc/wrappers/MCTextCanvas.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, Red Hat Inc. All rights reserved.
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * The contents of this file are subject to the terms of either the Universal Permissive License
+ * v 1.0 as shown at http://oss.oracle.com/licenses/upl
+ *
+ * or the following license:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
+ * conditions and the following disclaimer in the documentation and/or other materials provided with
+ * the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
+ * endorse or promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.openjdk.jmc.test.jemmy.misc.wrappers;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.swt.graphics.Rectangle;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.swt.widgets.Shell;
+import org.openjdk.jmc.test.jemmy.misc.base.wrappers.MCJemmyBase;
+import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;
+import org.openjdk.jmc.ui.misc.ChartTextCanvas;
+import org.jemmy.Point;
+import org.jemmy.control.Wrap;
+import org.jemmy.interfaces.Mouse.MouseButtons;
+import org.jemmy.interfaces.Parent;
+
+/**
+ * The Jemmy wrapper for the Mission Control Text Canvas.
+ */
+public class MCTextCanvas extends MCJemmyBase {
+	private MCTextCanvas(Wrap<? extends ChartTextCanvas> textCanvasWrap) {
+		this.control = textCanvasWrap;
+	}
+
+	/**
+	 * Returns all visible {@link MCtextCanvas} objects underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the ChartTextCanvas object
+	 * @return a {@link List} of {@link MCtextCanvas} objects
+	 */
+	@SuppressWarnings("unchecked")
+	public static List<MCTextCanvas> getAll(Wrap<? extends Shell> shell) {
+		List<Wrap<? extends ChartTextCanvas>> list = getVisible(
+				shell.as(Parent.class, ChartTextCanvas.class).lookup(ChartTextCanvas.class));
+		List<MCTextCanvas> canvases = new ArrayList<>();
+		for (int i = 0; i < list.size(); i++) {
+			canvases.add(new MCTextCanvas(list.get(i)));
+		}
+		return canvases;
+	}
+
+	/**
+	 * Returns the first visible {@link MCtextCanvas} object underneath the supplied shell
+	 *
+	 * @param shell
+	 *            the shell from where to start the search for the ChartTextCanvas object
+	 * @return a {@link MCtextCanvas} object
+	 */
+	public static MCTextCanvas getFirst(Wrap<? extends Shell> shell) {
+		return getAll(shell).get(0);
+	}
+
+	/**
+	 * Returns the first visible {@link MCTextCanvas} object underneath the Mission Control main
+	 * shell
+	 *
+	 * @return a {@link MCTextCanvas} object
+	 */
+	public static MCTextCanvas getTextCanvas() {
+		return getFirst(getShell());
+	}
+
+	/**
+	 * Sets a selection listener for the Text Canvas
+	 *
+	 * @param listener
+	 *            the selection listener to be set
+	 */
+	public void setSelectionListener(Runnable listener) {
+		ChartTextCanvas.class.cast(control.getControl()).setSelectionListener(listener);
+	}
+
+	/**
+	 * Click the middle thread listed in the Text Canvas
+	 */
+	@SuppressWarnings("unchecked")
+	public void clickTextCanvas() {
+		Display.getDefault().syncExec(() -> {
+			control.mouse().click(1, getRelativeClickPoint(), MouseButtons.BUTTON1);
+		});
+	}
+
+	/**
+	 * Calculates the click point of the Text Canvas
+	 *
+	 * @return the Point of the Text Canvas
+	 */
+	private Point getRelativeClickPoint() {
+		Fetcher<Point> fetcher = new Fetcher<Point>() {
+			@Override
+			public void run() {
+				Rectangle clientArea = ChartTextCanvas.class.cast(control.getControl()).getClientArea();
+				setOutput(new Point(clientArea.width / 2, clientArea.height / 2));
+			}
+		};
+		Display.getDefault().syncExec(fetcher);
+		return fetcher.getOutput();
+	}
+
+}

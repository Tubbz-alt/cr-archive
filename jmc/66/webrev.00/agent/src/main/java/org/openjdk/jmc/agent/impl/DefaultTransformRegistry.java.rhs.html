<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames agent/src/main/java/org/openjdk/jmc/agent/impl/DefaultTransformRegistry.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.agent.impl;
 34 
<a name="1" id="anc1"></a><span class="line-added"> 35 import java.io.ByteArrayInputStream;</span>
<span class="line-added"> 36 import java.io.IOException;</span>
 37 import java.io.InputStream;
 38 import java.io.StringReader;
 39 import java.util.ArrayList;
 40 import java.util.Collections;
 41 import java.util.HashMap;
 42 import java.util.LinkedList;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Map.Entry;
 46 import java.util.Set;
 47 import java.util.logging.Level;
 48 import java.util.logging.Logger;
 49 
<a name="2" id="anc2"></a><span class="line-added"> 50 import javax.xml.XMLConstants;</span>
 51 import javax.xml.namespace.QName;
 52 import javax.xml.stream.XMLInputFactory;
 53 import javax.xml.stream.XMLStreamException;
 54 import javax.xml.stream.XMLStreamReader;
<a name="3" id="anc3"></a><span class="line-added"> 55 import javax.xml.transform.stream.StreamSource;</span>
<span class="line-added"> 56 import javax.xml.validation.Schema;</span>
<span class="line-added"> 57 import javax.xml.validation.SchemaFactory;</span>
<span class="line-added"> 58 import javax.xml.validation.Validator;</span>
 59 
 60 import org.openjdk.jmc.agent.Method;
 61 import org.openjdk.jmc.agent.Parameter;
 62 import org.openjdk.jmc.agent.ReturnValue;
 63 import org.openjdk.jmc.agent.TransformDescriptor;
 64 import org.openjdk.jmc.agent.TransformRegistry;
 65 import org.openjdk.jmc.agent.Field;
 66 import org.openjdk.jmc.agent.jfr.JFRTransformDescriptor;
<a name="4" id="anc4"></a><span class="line-added"> 67 import org.openjdk.jmc.agent.util.IOToolkit;</span>
 68 import org.openjdk.jmc.agent.util.TypeUtils;
<a name="5" id="anc5"></a><span class="line-added"> 69 import org.xml.sax.SAXException;</span>
 70 
 71 public class DefaultTransformRegistry implements TransformRegistry {
 72 	private static final String XML_ATTRIBUTE_NAME_ID = &quot;id&quot;; //$NON-NLS-1$
 73 	private static final String XML_ELEMENT_NAME_EVENT = &quot;event&quot;; //$NON-NLS-1$
 74 	private static final String XML_ELEMENT_METHOD_NAME = &quot;method&quot;; //$NON-NLS-1$
 75 	private static final String XML_ELEMENT_FIELD_NAME = &quot;field&quot;; //$NON-NLS-1$
 76 	private static final String XML_ELEMENT_PARAMETER_NAME = &quot;parameter&quot;; //$NON-NLS-1$
 77 	private static final String XML_ELEMENT_RETURN_VALUE_NAME = &quot;returnvalue&quot;; //$NON-NLS-1$
 78 
 79 	// Global override section
 80 	private static final String XML_ELEMENT_CONFIGURATION = &quot;config&quot;; //$NON-NLS-1$
 81 	
 82 	// Logging
 83 	private static final Logger logger = Logger.getLogger(&quot;DefaultTransformRegistry&quot;);
 84 
 85 	// Maps class name -&gt; Transform Descriptors
 86 	// First step in update should be to check if we even have transformations for the given class
 87 	private final HashMap&lt;String, List&lt;TransformDescriptor&gt;&gt; transformData = new HashMap&lt;&gt;();
 88 
 89 	private volatile boolean revertInstrumentation = false;
 90 
<a name="6" id="anc6"></a><span class="line-added"> 91 	private static final String PROBE_SCHEMA_XSD = &quot;jfrprobes_schema.xsd&quot;; //$NON-NLS-1$</span>
<span class="line-added"> 92 	private static final Schema PROBE_SCHEMA;</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94 	static {</span>
<span class="line-added"> 95 		try {</span>
<span class="line-added"> 96 			SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span>
<span class="line-added"> 97 			PROBE_SCHEMA = factory</span>
<span class="line-added"> 98 					.newSchema(new StreamSource(DefaultTransformRegistry.class.getResourceAsStream(PROBE_SCHEMA_XSD)));</span>
<span class="line-added"> 99 		} catch (SAXException e) {</span>
<span class="line-added">100 			throw new ExceptionInInitializerError(e);</span>
<span class="line-added">101 		}</span>
<span class="line-added">102 	}</span>
<span class="line-added">103 </span>
104 	@Override
105 	public boolean hasPendingTransforms(String className) {
106 		List&lt;TransformDescriptor&gt; transforms = transformData.get(className);
107 		if (transforms == null || !isPendingTransforms(transforms)) {
108 			return false;
109 		}
110 		return true;
111 	}
112 
<a name="7" id="anc7"></a><span class="line-added">113 	private static void validateProbeDefinition(InputStream in) throws XMLStreamException {</span>
<span class="line-added">114 		try {</span>
<span class="line-added">115 			Validator validator = PROBE_SCHEMA.newValidator();</span>
<span class="line-added">116 			validator.validate(new StreamSource(in));</span>
<span class="line-added">117 		} catch (IOException | SAXException e) {</span>
<span class="line-added">118 			throw new XMLStreamException(e);</span>
<span class="line-added">119 		}</span>
<span class="line-added">120 	}</span>
<span class="line-added">121 </span>
<span class="line-added">122 	private static void validateProbeDefinition(String configuration) throws XMLStreamException {</span>
<span class="line-added">123 		validateProbeDefinition(new ByteArrayInputStream(configuration.getBytes()));</span>
<span class="line-added">124 	}</span>
<span class="line-added">125 </span>
126 	public static TransformRegistry from(InputStream in) throws XMLStreamException {
<a name="8" id="anc8"></a><span class="line-added">127 		byte[] buf;</span>
<span class="line-added">128 		InputStream configuration;</span>
<span class="line-added">129 		try {</span>
<span class="line-added">130 			buf = IOToolkit.readFully(in, -1, true);</span>
<span class="line-added">131 			configuration = new ByteArrayInputStream(buf);</span>
<span class="line-added">132 			configuration.mark(0);</span>
<span class="line-added">133 			validateProbeDefinition(configuration);</span>
<span class="line-added">134 			configuration.reset();</span>
<span class="line-added">135 		} catch (IOException e) {</span>
<span class="line-added">136 			throw new XMLStreamException(e);</span>
<span class="line-added">137 		}</span>
<span class="line-added">138 </span>
139 		HashMap&lt;String, String&gt; globalDefaults = new HashMap&lt;&gt;();
140 		DefaultTransformRegistry registry = new DefaultTransformRegistry();
141 		XMLInputFactory inputFactory = XMLInputFactory.newInstance();
<a name="9" id="anc9"></a><span class="line-modified">142 		XMLStreamReader streamReader = inputFactory.createXMLStreamReader(configuration);</span>
143 		while (streamReader.hasNext()) {
144 			if (streamReader.isStartElement()) {
145 				QName element = streamReader.getName();
146 				if (XML_ELEMENT_NAME_EVENT.equals(element.getLocalPart())) {
147 					TransformDescriptor td = parseTransformData(streamReader, globalDefaults);
148 					if (validate(registry,td)) {
149 						add(registry, td);
150 					}
151 					continue;
152 				} else if (XML_ELEMENT_CONFIGURATION.equals(element.getLocalPart())) {
153 					// These are the global defaults.
154 					streamReader.next();
155 					readGlobalConfig(streamReader, globalDefaults);
156 				}
157 			}
158 			streamReader.next();
159 		}
160 		return registry;
161 	}
162 
163 	private static void add(DefaultTransformRegistry registry, TransformDescriptor td) {
164 		List&lt;TransformDescriptor&gt; transformDataList = registry.getTransformData(td.getClassName());
165 		if (transformDataList == null) {
166 			transformDataList = new ArrayList&lt;&gt;();
167 			registry.transformData.put(td.getClassName(), transformDataList);
168 		}
169 		transformDataList.add(td);
170 	}
171 
172 	private static boolean validate(DefaultTransformRegistry registry, TransformDescriptor td) {
173 		if (td.getClassName() == null) {
174 			System.err.println(&quot;Encountered probe without associated class! Check probe definitions!&quot;); //$NON-NLS-1$
175 			return false;
176 		}
177 		if (td.getId() == null) {
178 			System.err.println(&quot;Encountered probe without associated id! Check probe definitions!&quot;); //$NON-NLS-1$
179 			return false;
180 		}
181 
182 		List&lt;TransformDescriptor&gt; transformDataList = registry.getTransformData(td.getClassName());
183 		if (transformDataList != null) {
184 			String tdEventClassName = ((JFRTransformDescriptor)td).getEventClassName();
185 			for (TransformDescriptor tdListEntry : transformDataList) {
186 				String existingName = ((JFRTransformDescriptor) tdListEntry).getEventClassName();
187 				if (existingName.equals(tdEventClassName)) {
188 					System.err.println(&quot;Encountered probe with an event class name that already exists. &quot;
189 							+ &quot;Check probe definitions!&quot;); //$NON-NLS-1$
190 					return false;
191 				}
192 			}
193 		}
194 
195 		return true;
196 	}
197 
198 	private static TransformDescriptor parseTransformData(
199 		XMLStreamReader streamReader, HashMap&lt;String, String&gt; globalDefaults) throws XMLStreamException {
200 		String id = streamReader.getAttributeValue(&quot;&quot;, XML_ATTRIBUTE_NAME_ID); //$NON-NLS-1$
201 		streamReader.next();
202 		Map&lt;String, String&gt; values = new HashMap&lt;&gt;();
203 		List&lt;Parameter&gt; parameters = new LinkedList&lt;&gt;();
204 		List&lt;Field&gt; fields = new LinkedList&lt;&gt;();
205 		Method method = null;
206 		ReturnValue[] returnValue = new ReturnValue[1];
207 		while (streamReader.hasNext()) {
208 			if (streamReader.isStartElement()) {
209 				String name = streamReader.getName().getLocalPart();
210 				if (XML_ELEMENT_METHOD_NAME.equals(name)) {
211 					method = parseMethod(streamReader, parameters, returnValue);
212 					continue;
213 				}
214 				if (XML_ELEMENT_FIELD_NAME.equals(name)) {
215 					fields.add(parseField(streamReader));
216 					continue;
217 				}
218 				streamReader.next();
219 				if (streamReader.hasText()) {
220 					String value = streamReader.getText();
221 					if (value != null) {
222 						value = value.trim();
223 					}
224 					values.put(name, value);
225 				}
226 			} else if (streamReader.isEndElement()) {
227 				String name = streamReader.getName().getLocalPart();
228 				if (XML_ELEMENT_NAME_EVENT.equals(name)) {
229 					break;
230 				}
231 			}
232 			streamReader.next();
233 		}
234 		transfer(globalDefaults, values);
235 		return TransformDescriptor.create(id, TypeUtils.getInternalName(values.get(&quot;class&quot;)), method, values, parameters, returnValue[0], fields); //$NON-NLS-1$
236 	}
237 
238 	private static void transfer(HashMap&lt;String, String&gt; globalDefaults, Map&lt;String, String&gt; values) {
239 		for (Entry&lt;String, String&gt; entry : globalDefaults.entrySet()) {
240 			if (!values.containsKey(entry.getKey())) {
241 				values.put(entry.getKey(), entry.getValue());
242 			}
243 		}
244 	}
245 
246 	private static void readGlobalConfig(XMLStreamReader streamReader, HashMap&lt;String, String&gt; globalDefaults) {
247 		addDefaults(globalDefaults);
248 		try {
249 			while (streamReader.hasNext()) {
250 				if (streamReader.isStartElement()) {
251 					String key = streamReader.getName().getLocalPart();
252 					streamReader.next();
253 					if (streamReader.hasText()) {
254 						String value = streamReader.getText();
255 						globalDefaults.put(key, value);
256 					}
257 				} else if (streamReader.isEndElement()) {
258 					String name = streamReader.getName().getLocalPart();
259 					if (XML_ELEMENT_CONFIGURATION.equals(name)) {
260 						break;
261 					}
262 				}
263 				streamReader.next();
264 			}
265 		} catch (XMLStreamException e) {
266 			e.printStackTrace();
267 		}
268 	}
269 
270 	private static void addDefaults(HashMap&lt;String, String&gt; globalDefaults) {
271 		globalDefaults.put(TransformDescriptor.ATTRIBUTE_CLASS_PREFIX, &quot;__JFREvent&quot;); //$NON-NLS-1$
272 		// For safety reasons, allowing toString is opt-in
273 		globalDefaults.put(TransformDescriptor.ATTRIBUTE_ALLOW_TO_STRING, &quot;false&quot;); //$NON-NLS-1$
274 		// For safety reasons, allowing converters is opt-in
275 		globalDefaults.put(TransformDescriptor.ATTRIBUTE_ALLOW_CONVERTER, &quot;false&quot;); //$NON-NLS-1$
276 	}
277 
278 	private static Parameter parseParameter(int index, XMLStreamReader streamReader) throws XMLStreamException {
279 		streamReader.next();
280 		String name = null;
281 		String description = null;
282 		String contentType = null;
283 		String relationKey = null;
284 		String converterClassName = null;
285 
286 		while (streamReader.hasNext()) {
287 			if (streamReader.isStartElement()) {
288 				String key = streamReader.getName().getLocalPart();
289 				streamReader.next();
290 				if (streamReader.hasText()) {
291 					String value = streamReader.getText();
292 					if (value != null) {
293 						value = value.trim();
294 					}
295 					if (&quot;name&quot;.equals(key)) { //$NON-NLS-1$
296 						name = value;
297 					} else if (&quot;description&quot;.equals(key)) { //$NON-NLS-1$
298 						description = value;
299 					} else if (&quot;contenttype&quot;.equals(key)) { //$NON-NLS-1$
300 						contentType = value;
301 					} else if (&quot;relationkey&quot;.equals(key)) { //$NON-NLS-1$
302 						relationKey = value;
303 					} else if (&quot;converter&quot;.equals(key)) { //$NON-NLS-1$
304 						converterClassName = value;
305 					}
306 				}
307 			} else if (streamReader.isEndElement()) {
308 				if (XML_ELEMENT_PARAMETER_NAME.equals(streamReader.getName().getLocalPart())) {
309 					break;
310 				}
311 			}
312 			streamReader.next();
313 		}
314 		return new Parameter(index, name, description, contentType, relationKey, converterClassName);
315 	}
316 
317 	private static Field parseField(XMLStreamReader streamReader) throws XMLStreamException {
318 		streamReader.next();
319 		String name = null;
320 		String expression = null;
321 		String description = null;
322 		String contentType = null;
323 		String relationKey = null;
324 		String converterClassName = null;
325 
326 		while (streamReader.hasNext()) {
327 			if (streamReader.isStartElement()) {
328 				String key = streamReader.getName().getLocalPart();
329 				streamReader.next();
330 				if (streamReader.hasText()) {
331 					String value = streamReader.getText();
332 					if (value != null) {
333 						value = value.trim();
334 					}
335 					if (&quot;name&quot;.equals(key)) { //$NON-NLS-1$
336 						name = value;
337 					} else if (&quot;expression&quot;.equals(key)) {
338 						expression = value;
339 					} else if (&quot;description&quot;.equals(key)) { //$NON-NLS-1$
340 						description = value;
341 					} else if (&quot;contenttype&quot;.equals(key)) { //$NON-NLS-1$
342 						contentType = value;
343 					} else if (&quot;relationkey&quot;.equals(key)) { //$NON-NLS-1$
344 						relationKey = value;
345 					} else if (&quot;converter&quot;.equals(key)) { //$NON-NLS-1$
346 						converterClassName = value;
347 					}
348 				}
349 			} else if (streamReader.isEndElement()) {
350 				if (XML_ELEMENT_FIELD_NAME.equals(streamReader.getName().getLocalPart())) {
351 					break;
352 				}
353 			}
354 			streamReader.next();
355 		}
356 		return new Field(name, expression, description, contentType, relationKey, converterClassName);
357 	}
358 
359 	private static ReturnValue parseReturnValue(XMLStreamReader streamReader) throws XMLStreamException {
360 		streamReader.next();
361 		String name = null;
362 		String description = null;
363 		String contentType = null;
364 		String relationKey = null;
365 		String converterClassName = null;
366 
367 		while (streamReader.hasNext()) {
368 			if (streamReader.isStartElement()) {
369 				String key = streamReader.getName().getLocalPart();
370 				streamReader.next();
371 				if (streamReader.hasText()) {
372 					String value = streamReader.getText();
373 					if (value != null) {
374 						value = value.trim();
375 					}
376 					if (&quot;name&quot;.equals(key)) { //$NON-NLS-1$
377 						name = value;
378 					} else if (&quot;description&quot;.equals(key)) { //$NON-NLS-1$
379 						description = value;
380 					} else if (&quot;contenttype&quot;.equals(key)) { //$NON-NLS-1$
381 						contentType = value;
382 					} else if (&quot;relationkey&quot;.equals(key)) { //$NON-NLS-1$
383 						relationKey = value;
384 					} else if (&quot;converter&quot;.equals(key)) { //$NON-NLS-1$
385 						converterClassName = value;
386 					}
387 				}
388 			} else if (streamReader.isEndElement()) {
389 				if (XML_ELEMENT_RETURN_VALUE_NAME.equals(streamReader.getName().getLocalPart())) {
390 					break;
391 				}
392 			}
393 			streamReader.next();
394 		}
395 		return new ReturnValue(name, description, contentType, relationKey, converterClassName);
396 	}
397 
398 	private static Method parseMethod(XMLStreamReader streamReader, List&lt;Parameter&gt; parameters, ReturnValue[] returnValue)
399 			throws XMLStreamException {
400 		streamReader.next();
401 		String name = null;
402 		String descriptor = null;
403 		while (streamReader.hasNext()) {
404 			if (streamReader.isStartElement()) {
405 				String key = streamReader.getName().getLocalPart();
406 				if (XML_ELEMENT_PARAMETER_NAME.equals(key)) {
407 					if (streamReader.getAttributeCount() &gt; 0) {
408 						String indexAttribute = streamReader.getAttributeValue(0);
409 						parameters.add(parseParameter(Integer.parseInt(indexAttribute), streamReader));
410 					}
411 					continue;
412 				}
413 				if (XML_ELEMENT_RETURN_VALUE_NAME.equals(key)) {
414 					returnValue[0] = parseReturnValue(streamReader);
415 					continue;
416 				}
417 				streamReader.next();
418 				if (streamReader.hasText()) {
419 					String value = streamReader.getText();
420 					if (&quot;name&quot;.equals(key)) { //$NON-NLS-1$
421 						name = value;
422 					} else if (&quot;descriptor&quot;.equals(key)) { //$NON-NLS-1$
423 						descriptor = value;
424 					}
425 				}
426 			} else if (streamReader.isEndElement()) {
427 				if (XML_ELEMENT_METHOD_NAME.equals(streamReader.getName().getLocalPart())) {
428 					break;
429 				}
430 			}
431 			streamReader.next();
432 		}
433 		return new Method(name, descriptor);
434 	}
435 
436 	@Override
437 	public List&lt;TransformDescriptor&gt; getTransformData(String className) {
438 		return transformData.get(className);
439 	}
440 
441 	private boolean isPendingTransforms(List&lt;TransformDescriptor&gt; transforms) {
442 		for (TransformDescriptor td : transforms) {
443 			if (td.isPendingTransforms()) {
444 				return true;
445 			}
446 		}
447 		return false;
448 	}
449 
450 	@Override
451 	public String toString() {
452 		StringBuilder builder = new StringBuilder();
453 		for (Entry&lt;String, List&lt;TransformDescriptor&gt;&gt; entry : transformData.entrySet()) {
454 			builder.append(&quot;Transformations for class: &quot;); //$NON-NLS-1$
455 			builder.append(entry.getKey());
456 			builder.append(&quot;\n&quot;); //$NON-NLS-1$
457 			for (TransformDescriptor td : entry.getValue()) {
458 				builder.append(&quot;\t&quot;); //$NON-NLS-1$
459 				builder.append(td.toString());
460 				builder.append(&quot;\n&quot;); //$NON-NLS-1$
461 			}
462 		}
463 		return builder.toString();
464 	}
465 
466 	public List&lt;TransformDescriptor&gt; modify(String xmlDescription) {
467 		try  {
<a name="10" id="anc10"></a><span class="line-added">468 			validateProbeDefinition(xmlDescription);</span>
<span class="line-added">469 </span>
470 			List&lt;TransformDescriptor&gt; tds = new ArrayList&lt;TransformDescriptor&gt;();
471 			StringReader reader = new StringReader(xmlDescription);
472 			XMLInputFactory inputFactory = XMLInputFactory.newInstance();
473 			XMLStreamReader streamReader = inputFactory.createXMLStreamReader(reader);
474 			HashMap&lt;String, String&gt; globalDefaults = new HashMap&lt;String, String&gt;();
475 			List&lt;String&gt; removedOldClasses = new ArrayList&lt;String&gt;();
476 			logger.info(xmlDescription);
477 			while (streamReader.hasNext()) {
478 				if (streamReader.isStartElement()) {
479 					QName element = streamReader.getName();
480 					if (XML_ELEMENT_NAME_EVENT.equals(element.getLocalPart())) {
481 						TransformDescriptor td = parseTransformData(streamReader, globalDefaults);
482 						if(!removedOldClasses.contains(td.getClassName())) {
483 							transformData.remove(td.getClassName());
484 							removedOldClasses.add(td.getClassName());
485 						}
486 						if (validate(this,td)) {
487 							add(this, td);
488 							tds.add(td);
489 						}
490 						continue;
491 					} else if (XML_ELEMENT_CONFIGURATION.equals(element.getLocalPart())) {
492 						readGlobalConfig(streamReader, globalDefaults);
493 					}
494 				}
495 				streamReader.next();
496 			}
497 			return tds;
498 		} catch (XMLStreamException xse) {
499 			logger.log(Level.SEVERE, &quot;Failed to create XML Stream Reader&quot;, xse);
500 			return null;
501 		}
502 	}
503 
504 	public List&lt;String&gt; clearAllTransformData() {
505 		List&lt;String&gt; classNames = new ArrayList&lt;&gt;(transformData.keySet());
506 		transformData.clear();
507 		return classNames;
508 	}
509 
510 	public Set&lt;String&gt; getClassNames() {
511 		return Collections.unmodifiableSet(transformData.keySet());
512 	}
513 
514 	public void setRevertInstrumentation(boolean shouldRevert) {
515 		this.revertInstrumentation = shouldRevert;
516 	}
517 
518 	public boolean isRevertIntrumentation() {
519 		return revertInstrumentation;
520 	}
521 
522 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
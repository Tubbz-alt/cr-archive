<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.ui.views.stacktrace;
 34 
<a name="1" id="anc1"></a>

 35 import java.util.Arrays;
 36 import java.util.List;
 37 import java.util.Optional;
 38 import java.util.concurrent.CompletableFuture;
<a name="2" id="anc2"></a>

 39 import java.util.logging.Level;
 40 import java.util.stream.Collectors;
 41 import java.util.stream.IntStream;
 42 import java.util.stream.Stream;
 43 
 44 import org.eclipse.core.runtime.IAdapterFactory;
 45 import org.eclipse.core.runtime.Platform;
 46 import org.eclipse.jface.action.Action;
 47 import org.eclipse.jface.action.IAction;
 48 import org.eclipse.jface.action.IMenuManager;
 49 import org.eclipse.jface.action.IToolBarManager;
 50 import org.eclipse.jface.action.MenuManager;
 51 import org.eclipse.jface.action.Separator;
 52 import org.eclipse.jface.viewers.AbstractTreeViewer;
 53 import org.eclipse.jface.viewers.ColumnLabelProvider;
 54 import org.eclipse.jface.viewers.ColumnViewer;
 55 import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;
 56 import org.eclipse.jface.viewers.ISelection;
 57 import org.eclipse.jface.viewers.ISelectionChangedListener;
 58 import org.eclipse.jface.viewers.IStructuredSelection;
 59 import org.eclipse.jface.viewers.ITreeContentProvider;
 60 import org.eclipse.jface.viewers.SelectionChangedEvent;
 61 import org.eclipse.jface.viewers.StructuredSelection;
 62 import org.eclipse.jface.viewers.StructuredViewer;
 63 import org.eclipse.jface.viewers.TableViewer;
 64 import org.eclipse.jface.viewers.TableViewerColumn;
 65 import org.eclipse.jface.viewers.TreeViewer;
 66 import org.eclipse.jface.viewers.TreeViewerColumn;
 67 import org.eclipse.jface.viewers.ViewerCell;
 68 import org.eclipse.jface.viewers.ViewerColumn;
 69 import org.eclipse.jface.window.ToolTip;
 70 import org.eclipse.swt.SWT;
 71 import org.eclipse.swt.events.TraverseEvent;
 72 import org.eclipse.swt.events.TraverseListener;
 73 import org.eclipse.swt.graphics.Color;
 74 import org.eclipse.swt.graphics.Image;
 75 import org.eclipse.swt.graphics.RGB;
 76 import org.eclipse.swt.widgets.Composite;
 77 import org.eclipse.swt.widgets.Display;
 78 import org.eclipse.swt.widgets.Event;
 79 import org.eclipse.swt.widgets.Listener;
 80 import org.eclipse.swt.widgets.TableColumn;
 81 import org.eclipse.swt.widgets.TreeColumn;
 82 import org.eclipse.ui.IEditorPart;
 83 import org.eclipse.ui.IMemento;
 84 import org.eclipse.ui.ISelectionListener;
 85 import org.eclipse.ui.IViewSite;
 86 import org.eclipse.ui.IWorkbenchPart;
 87 import org.eclipse.ui.PartInitException;
 88 import org.eclipse.ui.PlatformUI;
 89 import org.eclipse.ui.forms.widgets.FormText;
 90 import org.eclipse.ui.part.ViewPart;
<a name="3" id="anc3"></a><span class="line-removed"> 91 </span>
 92 import org.openjdk.jmc.common.IDisplayable;
 93 import org.openjdk.jmc.common.IMCFrame;
 94 import org.openjdk.jmc.common.IState;
 95 import org.openjdk.jmc.common.collection.SimpleArray;
 96 import org.openjdk.jmc.common.item.IItemCollection;
 97 import org.openjdk.jmc.common.unit.UnitLookup;
 98 import org.openjdk.jmc.common.util.StateToolkit;
 99 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;
100 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;
101 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;
102 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;
103 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel;
104 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Branch;
105 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Fork;
106 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
107 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
108 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
109 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
110 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
111 import org.openjdk.jmc.flightrecorder.ui.selection.IFlavoredSelection;
112 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore;
113 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
114 import org.openjdk.jmc.flightrecorder.ui.selection.StacktraceFrameSelection;
115 import org.openjdk.jmc.ui.CoreImages;
116 import org.openjdk.jmc.ui.UIPlugin;
117 import org.openjdk.jmc.ui.accessibility.FocusTracker;
118 import org.openjdk.jmc.ui.common.util.AdapterUtil;
119 import org.openjdk.jmc.ui.handlers.ActionToolkit;
120 import org.openjdk.jmc.ui.handlers.CopySelectionAction;
121 import org.openjdk.jmc.ui.handlers.InFocusHandlerActivator;
122 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
123 import org.openjdk.jmc.ui.handlers.MethodFormatter;
124 import org.openjdk.jmc.ui.misc.AbstractStructuredContentProvider;
125 import org.openjdk.jmc.ui.misc.CompositeToolkit;
126 import org.openjdk.jmc.ui.misc.CopySettings;
127 import org.openjdk.jmc.ui.misc.DisplayToolkit;
128 import org.openjdk.jmc.ui.misc.FormatToolkit;
129 import org.openjdk.jmc.ui.misc.MementoToolkit;
130 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
131 
132 public class StacktraceView extends ViewPart implements ISelectionListener {
133 
134 	static {
135 		// Adapt using IAdapterFactory to support object contribution for IMCMethod (e.g jump to source)
136 		Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {
137 
138 			@Override
139 			public &lt;T&gt; T getAdapter(Object adaptableObject, Class&lt;T&gt; adapterType) {
140 				if (adaptableObject instanceof StacktraceFrame &amp;&amp; adapterType == IMCFrame.class) {
141 					return adapterType.cast(((StacktraceFrame) adaptableObject).getFrame());
142 				}
143 				return null;
144 			}
145 
146 			@Override
147 			public Class&lt;?&gt;[] getAdapterList() {
148 				return new Class[] {IMCFrame.class};
149 			}
150 		}, StacktraceFrame.class);
151 	}
152 
153 	private class GroupByAction extends Action {
154 
155 		private final boolean fromThreadRootAction;
156 
157 		GroupByAction(boolean fromRoot) {
158 			super(fromRoot ? Messages.STACKTRACE_VIEW_THREAD_ROOT : Messages.STACKTRACE_VIEW_LAST_FRAME,
159 					IAction.AS_RADIO_BUTTON);
160 			fromThreadRootAction = fromRoot;
161 			setToolTipText(fromRoot ? Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_ROOT
162 					: Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_LAST_FRAME);
163 			setImageDescriptor(fromRoot ? CoreImages.THREAD : CoreImages.METHOD_NON_OPTIMIZED);
164 			setChecked(fromRoot == threadRootAtTop);
165 		}
166 
167 		@Override
168 		public void run() {
169 			boolean newValue = isChecked() == fromThreadRootAction;
170 			if (newValue != threadRootAtTop) {
171 				threadRootAtTop = newValue;
172 				rebuildModel();
173 			}
174 		}
175 	}
176 
<a name="4" id="anc4"></a>
177 	private static final String HELP_CONTEXT_ID = FlightRecorderUI.PLUGIN_ID + &quot;.StacktraceView&quot;; //$NON-NLS-1$
178 	// FIXME: Define dynamic color (editable in preferences, to handle dark themes etc.)
179 	private static final Color ALTERNATE_COLOR = SWTColorToolkit.getColor(new RGB(255, 255, 240));
180 	private static final String COUNT_IMG_KEY = &quot;countColor&quot;; //$NON-NLS-1$
181 	private static final Color COUNT_COLOR = SWTColorToolkit.getColor(new RGB(100, 200, 100));
182 	private static final String SIBLINGS_IMG_KEY = &quot;siblingsColor&quot;; //$NON-NLS-1$
183 	private static final Color SIBLINGS_COUNT_COLOR = SWTColorToolkit.getColor(new RGB(170, 250, 170));
184 	private static final int[] DEFAULT_COLUMN_WIDTHS = {650, 80, 120};
185 	private static final String THREAD_ROOT_KEY = &quot;threadRootAtTop&quot;; //$NON-NLS-1$
186 	private static final String FRAME_OPTIMIZATION_KEY = &quot;distinguishFramesByOptimization&quot;; //$NON-NLS-1$
187 	private static final String FRAME_CATEGORIZATION_KEY = &quot;distinguishFramesCategorization&quot;; //$NON-NLS-1$
188 	private static final String TREE_LAYOUT_KEY = &quot;treeLayout&quot;; //$NON-NLS-1$
189 	private static final String REDUCED_TREE_KEY = &quot;reducedTreeLayout&quot;; //$NON-NLS-1$
190 	private static final String METHOD_FORMAT_KEY = &quot;metodFormat&quot;; //$NON-NLS-1$
191 	private static final String COLUMNS_KEY = &quot;columns&quot;; //$NON-NLS-1$
192 	private static final String COLUMNS_SEPARATOR = &quot; &quot;; //$NON-NLS-1$
193 	private ColumnViewer viewer;
194 	private boolean treeLayout;
195 	private boolean reducedTree;
196 	private boolean threadRootAtTop;
197 	private IItemCollection itemsToShow;
198 	private MethodFormatter methodFormatter;
199 	private FrameSeparatorManager frameSeparatorManager;
200 	private GroupByAction[] groupByActions;
201 	private IAction[] layoutActions;
202 	private ViewerAction[] viewerActions;
203 	private int[] columnWidths;
204 
205 	private static class StacktraceViewToolTipSupport extends ColumnViewerToolTipSupport {
206 
207 		StacktraceViewToolTipSupport(ColumnViewer viewer) {
208 			super(viewer, ToolTip.NO_RECREATE, false);
209 		}
210 
211 		@Override
212 		protected Composite createViewerToolTipContentArea(Event event, ViewerCell cell, Composite parent) {
213 			FormText formText = CompositeToolkit.createInfoFormText(parent);
214 			formText.setImage(COUNT_IMG_KEY, SWTColorToolkit.getColorThumbnail(COUNT_COLOR.getRGB()));
215 			formText.setImage(SIBLINGS_IMG_KEY, SWTColorToolkit.getColorThumbnail(SIBLINGS_COUNT_COLOR.getRGB()));
216 			formText.setText(getText(event), true, false);
217 			return formText;
218 		}
219 
220 	}
221 
222 	private static class ViewerAction extends Action implements ISelectionChangedListener {
223 
224 		protected StructuredViewer provider = null;
225 
226 		public ViewerAction(String text) {
227 			super(text);
228 			setViewer(null);
229 			setEnabled(false);
230 		}
231 
232 		public void setViewer(StructuredViewer provider) {
233 			this.provider = provider;
234 			if (provider != null) {
235 				provider.addSelectionChangedListener(this);
236 				selectionChanged(getStructuredSelection());
237 			} else {
238 				setEnabled(false);
239 			}
240 		}
241 
242 		@Override
243 		public void selectionChanged(SelectionChangedEvent event) {
244 			ISelection selection = event.getSelection();
245 			if (selection instanceof IStructuredSelection) {
246 				selectionChanged((IStructuredSelection) selection);
247 			}
248 		}
249 
250 		protected void selectionChanged(IStructuredSelection selection) {
251 		}
252 
253 		protected IStructuredSelection getStructuredSelection() {
254 			if (provider != null) {
255 				ISelection selection = provider.getSelection();
256 				if (selection instanceof IStructuredSelection) {
257 					return (IStructuredSelection) selection;
258 				}
259 			}
260 			return new StructuredSelection();
261 		}
262 
263 	}
264 
265 	static class SelectFrameGroupAction extends ViewerAction {
266 
267 		SelectFrameGroupAction() {
268 			super(Messages.STACKTRACE_VIEW_FRAME_GROUP_CHOOSE);
269 			setImageDescriptor(
270 					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_STAR));
271 			setAccelerator(SWT.CR);
272 		}
273 
274 		@Override
275 		public void setViewer(StructuredViewer provider) {
276 			super.setViewer(provider);
277 			if (provider != null) {
278 				provider.addDoubleClickListener(e -&gt; {
279 					if (isEnabled()) {
280 						run();
281 					}
282 				});
283 			}
284 		}
285 
286 		// See JMC-6787
287 		@SuppressWarnings(&quot;deprecation&quot;)
288 		@Override
289 		public void run() {
290 			StacktraceFrame frame = (StacktraceFrame) getStructuredSelection().getFirstElement();
291 			// FIXME: Would like to move the table cursor after changing sibling state, not just the selection.
292 			if (isInOpenFork(frame)) {
293 				frame.getBranch().selectSibling(0);
294 			} else {
295 				frame.getBranch().selectSibling(null);
296 			}
297 			provider.getControl().setRedraw(false);
298 			try {
299 				provider.refresh();
300 			} finally {
301 				provider.getControl().setRedraw(true);
302 			}
303 			provider.setSelection(new StructuredSelection(frame));
304 
305 		}
306 
307 		@Override
308 		public void selectionChanged(IStructuredSelection selection) {
309 			setEnabled(selection.size() == 1
310 					&amp;&amp; isFirstInBranchWithSiblings((StacktraceFrame) selection.getFirstElement()));
311 		}
312 
313 	}
314 
315 	static class NavigateAction extends ViewerAction implements TraverseListener {
316 
317 		private final int offset;
318 
319 		NavigateAction(boolean forward) {
320 			super(forward ? Messages.STACKTRACE_VIEW_FRAME_GROUP_NEXT : Messages.STACKTRACE_VIEW_FRAME_GROUP_PREVIOUS);
321 			setImageDescriptor(
322 					forward ? FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_RIGHT)
323 							: FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_LEFT));
324 			offset = forward ? 1 : -1;
325 			setAccelerator(forward ? SWT.ARROW_RIGHT : SWT.ARROW_LEFT);
326 		}
327 
328 		@Override
329 		public void setViewer(StructuredViewer provider) {
330 			super.setViewer(provider);
331 			if (provider != null) {
332 				provider.getControl().addTraverseListener(this);
333 			}
334 		}
335 
336 		@Override
337 		public void run() {
338 			Branch branch = ((StacktraceFrame) getStructuredSelection().getFirstElement()).getBranch();
339 			// See JMC-6787
340 			@SuppressWarnings(&quot;deprecation&quot;)
341 			Branch selectedSibling = branch.selectSibling(offset);
342 			provider.refresh();
343 			provider.setSelection(new StructuredSelection(selectedSibling.getFirstFrame()));
344 		}
345 
346 		@Override
347 		protected void selectionChanged(IStructuredSelection selection) {
348 			setEnabled(selection.size() == 1 &amp;&amp; isNavigationFrame((StacktraceFrame) selection.getFirstElement()));
349 		}
350 
351 		@Override
352 		public void keyTraversed(TraverseEvent e) {
353 			if (isEnabled()) {
354 				if (e.keyCode == getAccelerator()) {
355 					run();
356 					e.detail = SWT.TRAVERSE_NONE;
357 					e.doit = true;
358 				}
359 			}
360 		}
361 
362 	};
363 
364 	@Override
365 	public void init(IViewSite site, IMemento memento) throws PartInitException {
366 		super.init(site, memento);
367 		IState state = MementoToolkit.asState(memento);
368 		threadRootAtTop = StateToolkit.readBoolean(state, THREAD_ROOT_KEY, false);
369 		groupByActions = new GroupByAction[] {new GroupByAction(false), new GroupByAction(true)};
370 		treeLayout = StateToolkit.readBoolean(state, TREE_LAYOUT_KEY, false);
371 		reducedTree = StateToolkit.readBoolean(state, REDUCED_TREE_KEY, true);
372 
373 		IAction reducedTreeAction = ActionToolkit.checkAction(this::setReducedTree,
374 				Messages.STACKTRACE_VIEW_REDUCE_TREE_DEPTH, null);
375 		reducedTreeAction.setChecked(reducedTree);
376 		IAction treeAction = ActionToolkit.checkAction(this::setTreeLayout, Messages.STACKTRACE_VIEW_SHOW_AS_TREE,
377 				CoreImages.TREE_MODE);
378 		treeAction.setChecked(treeLayout);
379 		layoutActions = new IAction[] {treeAction, reducedTreeAction};
380 
381 		NavigateAction forwardAction = new NavigateAction(true);
382 		NavigateAction backwardAction = new NavigateAction(false);
383 		SelectFrameGroupAction selectGroupAction = new SelectFrameGroupAction();
384 		viewerActions = new ViewerAction[] {selectGroupAction, forwardAction, backwardAction};
385 
386 		try {
387 			columnWidths = Optional.ofNullable(state)
388 					.map(s -&gt; Stream.of(s.getAttribute(COLUMNS_KEY).split(COLUMNS_SEPARATOR))
389 							.mapToInt(Integer::parseInt).toArray())
390 					.filter(widths -&gt; widths.length == DEFAULT_COLUMN_WIDTHS.length
391 							&amp;&amp; Arrays.stream(widths).allMatch(w -&gt; w &gt;= 0))
392 					.orElse(DEFAULT_COLUMN_WIDTHS);
393 		} catch (RuntimeException e) {
394 			columnWidths = DEFAULT_COLUMN_WIDTHS;
395 		}
396 
397 		FrameCategorization categorization = StateToolkit.readEnum(state, FRAME_CATEGORIZATION_KEY,
398 				FrameCategorization.METHOD, FrameCategorization.class);
399 		boolean byOptimization = StateToolkit.readBoolean(state, FRAME_OPTIMIZATION_KEY, false);
400 		frameSeparatorManager = new FrameSeparatorManager(this::rebuildModel,
401 				new FrameSeparator(categorization, byOptimization));
402 		methodFormatter = new MethodFormatter(memento == null ? null : memento.getChild(METHOD_FORMAT_KEY),
403 				() -&gt; viewer.refresh());
404 		IMenuManager siteMenu = site.getActionBars().getMenuManager();
405 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_TOP));
406 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_VIEWER_SETUP));
407 		addOptions(siteMenu);
408 		IToolBarManager toolBar = site.getActionBars().getToolBarManager();
409 		toolBar.add(selectGroupAction);
410 		toolBar.add(backwardAction);
411 		toolBar.add(forwardAction);
412 		toolBar.add(new Separator());
413 		toolBar.add(treeAction);
414 		toolBar.add(new Separator());
415 		Stream.of(groupByActions).forEach(toolBar::add);
416 
417 		getSite().getPage().addSelectionListener(this);
418 	}
419 
420 	@Override
421 	public void dispose() {
422 		getSite().getPage().removeSelectionListener(this);
423 		super.dispose();
424 	}
425 
426 	@Override
427 	public void createPartControl(Composite parent) {
428 		buildViewer(parent);
429 	}
430 
431 	private void setTreeLayout(boolean treeLayout) {
432 		this.treeLayout = treeLayout;
433 		rebuildViewer();
434 	}
435 
436 	private void setReducedTree(boolean reducedTree) {
437 		this.reducedTree = reducedTree;
438 		if (viewer instanceof TreeViewer) {
439 			viewer.setContentProvider(createTreeContentProvider());
440 		}
441 	}
442 
443 	// See JMC-6787
444 	@SuppressWarnings(&quot;deprecation&quot;)
445 	private void rebuildViewer() {
446 		boolean hasFocus = viewer.getControl().isFocusControl();
447 		ISelection oldSelection = viewer.getSelection();
448 		Fork oldInput = (Fork) viewer.getInput();
449 		Composite parent = viewer.getControl().getParent();
450 		viewer.getControl().dispose();
451 		buildViewer(parent);
452 		if (hasFocus) {
453 			viewer.getControl().setFocus();
454 		}
455 		parent.layout();
456 		if (viewer instanceof TreeViewer) {
457 			// Async set input to avoid drawing issue with tree
458 			Display.getCurrent().asyncExec(() -&gt; {
459 				if (!viewer.getControl().isDisposed()) {
460 					setViewerInput(oldInput);
461 					if (reducedTree &amp;&amp; oldInput != null) {
462 						Branch selectedBranch = getLastSelectedBranch(oldInput);
463 						if (selectedBranch != null) {
464 							viewer.getControl().setRedraw(false);
465 							((TreeViewer) viewer).expandToLevel(selectedBranch.getLastFrame(),
466 									AbstractTreeViewer.ALL_LEVELS);
467 							viewer.getControl().setRedraw(true);
468 						}
469 					}
470 					viewer.setSelection(oldSelection, true);
471 				}
472 			});
473 		} else {
474 			Branch branch = null;
475 			for (Object o : ((IStructuredSelection) oldSelection).toList()) {
476 				if (branch == null) {
477 					branch = ((StacktraceFrame) o).getBranch();
478 				} else if (branch != ((StacktraceFrame) o).getBranch()) {
479 					branch = null;
480 					break;
481 				}
482 			}
483 			if (branch != null) {
484 				branch.selectSibling(0);
485 			}
486 			setViewerInput(oldInput);
487 			viewer.setSelection(oldSelection, true);
488 		}
489 	}
490 
491 	private void buildViewer(Composite parent) {
492 		if (treeLayout) {
493 			viewer = buildTree(parent);
494 		} else {
495 			viewer = buildTable(parent);
496 		}
497 		new StacktraceViewToolTipSupport(viewer);
498 		MCContextMenuManager mm = MCContextMenuManager.create(viewer.getControl());
499 		CopySelectionAction copyAction = new CopySelectionAction(viewer,
500 				FormatToolkit.selectionFormatter(stackTraceLabelProvider, countLabelProvider, percentageLabelProvider));
501 		InFocusHandlerActivator.install(viewer.getControl(), copyAction);
502 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, copyAction);
503 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, CopySettings.getInstance().createContributionItem());
504 		addOptions(mm);
505 		getSite().registerContextMenu(mm, viewer);
506 		if (!treeLayout) {
507 			String navigateGroupName = &quot;NAVIGATE&quot;; //$NON-NLS-1$
508 			mm.insert(0, new Separator(navigateGroupName));
509 			Stream.of(viewerActions).forEach(a -&gt; {
510 				a.setViewer(viewer);
511 				mm.appendToGroup(navigateGroupName, a);
512 			});
513 		} else {
514 			Stream.of(viewerActions).forEach(a -&gt; a.setViewer(null));
515 		}
516 
517 		viewer.getControl().addListener(SWT.EraseItem, PERCENTAGE_BACKGROUND_DRAWER);
518 		viewer.getControl().addDisposeListener(e -&gt; columnWidths = getColumnWidths());
519 
520 		buildColumn(viewer, Messages.STACKTRACE_VIEW_STACK_TRACE, SWT.NONE, columnWidths[0])
521 				.setLabelProvider(stackTraceLabelProvider);
522 		buildColumn(viewer, Messages.STACKTRACE_VIEW_COUNT_COLUMN_NAME, SWT.RIGHT, columnWidths[1])
523 				.setLabelProvider(countLabelProvider);
524 		buildColumn(viewer, Messages.STACKTRACE_VIEW_PERCENTAGE_COLUMN_NAME, SWT.RIGHT, columnWidths[2])
525 				.setLabelProvider(percentageLabelProvider);
526 
527 		PlatformUI.getWorkbench().getHelpSystem().setHelp(viewer.getControl(), HELP_CONTEXT_ID);
528 
529 		if (UIPlugin.getDefault().getAccessibilityMode()) {
530 			if (treeLayout) {
531 				FocusTracker.enableFocusTracking(((TreeViewer) viewer).getTree());
532 			} else {
533 				FocusTracker.enableFocusTracking(((TableViewer) viewer).getTable());
534 			}
535 		}
536 	}
537 
538 	private static TableViewer buildTable(Composite parent) {
539 		TableViewer tableViewer = new TableViewer(parent,
540 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
541 		tableViewer.setContentProvider(new AbstractStructuredContentProvider() {
542 			@Override
543 			public Object[] getElements(Object inputElement) {
544 				SimpleArray&lt;StacktraceFrame&gt; trace = new SimpleArray&lt;&gt;(new StacktraceFrame[100]);
545 				addSelectedBranches((Fork) inputElement, trace, false);
546 				return trace.elements();
547 			}
548 		});
549 		tableViewer.getTable().setHeaderVisible(true);
550 		tableViewer.getTable().setLinesVisible(true);
551 		return tableViewer;
552 	}
553 
554 	private TreeViewer buildTree(Composite parent) {
555 		TreeViewer treeViewer = new TreeViewer(parent,
556 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
557 		treeViewer.setContentProvider(createTreeContentProvider());
558 		treeViewer.getTree().setHeaderVisible(true);
559 		treeViewer.getTree().setLinesVisible(true);
560 		return treeViewer;
561 	}
562 
563 	private static ViewerColumn buildColumn(ColumnViewer viewer, String text, int style, int width) {
564 		if (viewer instanceof TableViewer) {
565 			TableViewerColumn vc = new TableViewerColumn((TableViewer) viewer, style);
566 			vc.getColumn().setWidth(width);
567 			vc.getColumn().setText(text);
568 			return vc;
569 		} else {
570 			TreeViewerColumn vc = new TreeViewerColumn((TreeViewer) viewer, style);
571 			vc.getColumn().setWidth(width);
572 			vc.getColumn().setText(text);
573 			return vc;
574 		}
575 	}
576 
577 	private int[] getColumnWidths() {
578 		if (!viewer.getControl().isDisposed()) {
579 			if (viewer instanceof TableViewer) {
580 				return Stream.of(((TableViewer) viewer).getTable().getColumns()).mapToInt(TableColumn::getWidth)
581 						.toArray();
582 			} else {
583 				return Stream.of(((TreeViewer) viewer).getTree().getColumns()).mapToInt(TreeColumn::getWidth).toArray();
584 			}
585 		}
586 		return columnWidths;
587 	}
588 
589 	private void addOptions(IMenuManager menu) {
590 		MenuManager groupMenu = new MenuManager(Messages.STACKTRACE_VIEW_GROUP_FROM);
591 		Stream.of(groupByActions).forEach(groupMenu::add);
592 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, groupMenu);
593 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, frameSeparatorManager.createMenu());
594 		MenuManager layoutMenu = new MenuManager(Messages.STACKTRACE_VIEW_LAYOUT_OPTIONS);
595 		Stream.of(layoutActions).forEach(layoutMenu::add);
596 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, layoutMenu);
597 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, methodFormatter.createMenu());
598 		SelectionStoreActionToolkit.addSelectionStoreActions(viewer, this::getSelectionStore,
599 				this::getFlavoredSelection, menu);
600 	}
601 
602 	private IFlavoredSelection getFlavoredSelection() {
603 		ISelection selection = viewer.getSelection();
604 		if (selection instanceof IStructuredSelection &amp;&amp; !selection.isEmpty()) {
605 			List&lt;?&gt; selected = ((StructuredSelection) selection).toList();
606 			StacktraceFrame frame = (StacktraceFrame) selected.get(0);
607 			return new StacktraceFrameSelection(frame.getFrame(),
608 					ItemCollectionToolkit.build(Stream.of(frame.getItems().elements())),
609 					Messages.STACKTRACE_VIEW_SELECTION);
610 		}
611 		return null;
612 	}
613 
614 	private SelectionStore getSelectionStore() {
615 		IEditorPart editorPart = null;
616 		try {
617 			PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
618 			editorPart = getSite().getPage().getActiveEditor();
619 		} catch (Exception e) {
620 			FlightRecorderUI.getDefault().getLogger().log(Level.INFO,
621 					&quot;Got exception while trying to get the active editor&quot;, e); //$NON-NLS-1$
622 		}
623 		if (editorPart instanceof IPageContainer) {
624 			return ((IPageContainer) editorPart).getSelectionStore();
625 		}
626 		return null;
627 	}
628 
629 	@Override
630 	public void setFocus() {
631 		viewer.getControl().setFocus();
632 	}
633 
634 	@Override
635 	public void saveState(IMemento memento) {
636 		memento.putString(COLUMNS_KEY, IntStream.of(getColumnWidths()).mapToObj(Integer::toString)
637 				.collect(Collectors.joining(COLUMNS_SEPARATOR)));
638 		methodFormatter.saveState(memento.createChild(METHOD_FORMAT_KEY));
639 		memento.putBoolean(THREAD_ROOT_KEY, threadRootAtTop);
640 		memento.putBoolean(TREE_LAYOUT_KEY, treeLayout);
641 		memento.putBoolean(REDUCED_TREE_KEY, reducedTree);
642 		FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
643 		memento.putBoolean(FRAME_OPTIMIZATION_KEY, frameSeparator.isDistinguishFramesByOptimization());
644 		memento.putString(FRAME_CATEGORIZATION_KEY, frameSeparator.getCategorization().name());
645 	}
646 
647 	@Override
648 	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
649 		if (selection instanceof IStructuredSelection) {
650 			Object first = ((IStructuredSelection) selection).getFirstElement();
651 			IItemCollection items = AdapterUtil.getAdapter(first, IItemCollection.class);
652 			if (items == null) {
653 				setItems(ItemCollectionToolkit.build(Stream.empty()));
654 			} else if (!items.equals(itemsToShow)) {
655 				setItems(items);
656 			}
657 		}
658 	}
659 
660 	private void setItems(IItemCollection items) {
661 		itemsToShow = items;
662 		rebuildModel();
663 	}
664 
665 	private StacktraceModel createStacktraceModel() {
666 		return new StacktraceModel(threadRootAtTop, frameSeparatorManager.getFrameSeparator(), itemsToShow);
667 	}
668 
669 	private void rebuildModel() {
670 		// Release old model before building the new
671 		setViewerInput(null);
672 		CompletableFuture&lt;StacktraceModel&gt; modelPreparer = getModelPreparer(createStacktraceModel(), !treeLayout);
673 		modelPreparer.thenAcceptAsync(this::setModel, DisplayToolkit.inDisplayThread())
674 				.exceptionally(StacktraceView::handleModelBuildException);
675 	}
676 
677 	private static CompletableFuture&lt;StacktraceModel&gt; getModelPreparer(
678 		StacktraceModel model, boolean materializeSelectedBranches) {
679 		return CompletableFuture.supplyAsync(() -&gt; {
680 			Fork root = model.getRootFork();
681 			if (materializeSelectedBranches) {
682 				Branch selectedBranch = getLastSelectedBranch(root);
683 				if (selectedBranch != null) {
684 					selectedBranch.getEndFork();
685 				}
686 			}
687 			return model;
<a name="5" id="anc5"></a><span class="line-modified">688 		});</span>
689 	}
690 
691 	private static Void handleModelBuildException(Throwable ex) {
692 		FlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, &quot;Failed to build stacktrace view model&quot;, ex); //$NON-NLS-1$
693 		return null;
694 	}
695 
696 	private void setModel(StacktraceModel model) {
697 		// Check that the model is up to date
698 		if (model.equals(createStacktraceModel()) &amp;&amp; !viewer.getControl().isDisposed()) {
699 			setViewerInput(model.getRootFork());
700 		}
701 	}
702 
703 	private void setViewerInput(Fork rootFork) {
704 		// NOTE: will be slow for TreeViewer if number of roots or children of a node are more than ~1000
705 		viewer.setInput(rootFork);
706 	}
707 
708 	private ITreeContentProvider createTreeContentProvider() {
709 		return reducedTree ? new StacktraceReducedTreeContentProvider() : new StacktraceTreeContentProvider();
710 	}
711 
712 	private static final Listener PERCENTAGE_BACKGROUND_DRAWER = new Listener() {
713 		@Override
714 		public void handleEvent(Event event) {
715 			StacktraceFrame frame = (StacktraceFrame) event.item.getData();
716 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
717 			double total;
718 			if (event.index == 2 &amp;&amp; (total = rootFork.getItemsInFork()) &gt; 0) { // index == 2 =&gt; percentage column
719 				// Draw siblings
720 				Fork parentFork = frame.getBranch().getParentFork();
721 				int forkOffset = parentFork.getItemOffset();
722 				int siblingsStart = (int) Math.floor(event.width * forkOffset / total);
723 				int siblingsWidth = (int) Math.round(event.width * parentFork.getItemsInFork() / total);
724 				event.gc.setBackground(SIBLINGS_COUNT_COLOR);
725 				event.gc.fillRectangle(event.x + siblingsStart, event.y, siblingsWidth, event.height);
726 				// Draw group
727 				double offset = (forkOffset + frame.getBranch().getItemOffsetInFork()) / total;
728 				double fraction = frame.getItemCount() / total;
729 				event.gc.setBackground(COUNT_COLOR);
730 				int startPixel = (int) Math.floor(event.width * offset);
731 				int widthPixel = (int) Math.round(event.width * fraction);
732 				event.gc.fillRectangle(event.x + startPixel, event.y, Math.max(widthPixel, 1), event.height);
733 				event.detail &amp;= ~SWT.BACKGROUND;
734 			}
735 		}
736 	};
737 
738 	private final ColumnLabelProvider percentageLabelProvider = new ColumnLabelProvider() {
739 		@Override
740 		public String getText(Object element) {
741 			StacktraceFrame frame = (StacktraceFrame) element;
742 			int itemCount = frame.getItemCount();
743 			int totalCount = getRootFork(frame.getBranch().getParentFork()).getItemsInFork();
744 			return UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount).displayUsing(IDisplayable.AUTO);
745 		}
746 
747 		@Override
748 		public String getToolTipText(Object element) {
749 			StacktraceFrame frame = (StacktraceFrame) element;
750 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
751 			int itemCount = frame.getItemCount();
752 			int totalCount = rootFork.getItemsInFork();
753 			Fork parentFork = frame.getBranch().getParentFork();
754 			int itemsInSiblings = parentFork.getItemsInFork() - frame.getBranch().getFirstFrame().getItemCount();
755 			String frameFraction = UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount)
756 					.displayUsing(IDisplayable.AUTO);
757 			StringBuilder sb = new StringBuilder(&quot;&lt;form&gt;&quot;); //$NON-NLS-1$
758 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + COUNT_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
759 			sb.append(Messages.stackTraceMessage(itemCount, totalCount, frameFraction));
760 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
761 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + SIBLINGS_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
762 			sb.append(Messages.siblingMessage(itemsInSiblings, parentFork.getBranchCount() - 1));
763 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
764 			sb.append(&quot;&lt;/form&gt;&quot;); //$NON-NLS-1$
765 			return sb.toString();
766 		}
767 	};
768 
769 	private final ColumnLabelProvider countLabelProvider = new ColumnLabelProvider() {
770 		@Override
771 		public String getText(Object element) {
772 			return Integer.toString(((StacktraceFrame) element).getItemCount());
773 		}
774 	};
775 
776 	private final ColumnLabelProvider stackTraceLabelProvider = new ColumnLabelProvider() {
777 
778 		@Override
779 		public String getText(Object element) {
780 			IMCFrame frame = ((StacktraceFrame) element).getFrame();
781 			FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
782 			return getText(frame, frameSeparator);
783 		}
784 
785 		private String getText(IMCFrame frame, FrameSeparator frameSeparator) {
786 			return StacktraceFormatToolkit.formatFrame(frame, frameSeparator, methodFormatter.showReturnValue(),
787 					methodFormatter.showReturnValuePackage(), methodFormatter.showClassName(),
788 					methodFormatter.showClassPackageName(), methodFormatter.showArguments(),
789 					methodFormatter.showArgumentsPackage());
790 		}
791 
792 		@Override
793 		public Image getImage(Object element) {
794 			StacktraceFrame frame = (StacktraceFrame) element;
795 			FlightRecorderUI plugin = FlightRecorderUI.getDefault();
796 			boolean isFirstInBranch = isFirstInBranchWithSiblings(frame);
797 			boolean firstInOpenFork = isFirstInBranch &amp;&amp; isInOpenFork(frame);
798 			if (firstInOpenFork || treeLayout &amp;&amp; (!reducedTree || isFirstInBranch)) {
799 				return plugin.getImage(
800 						threadRootAtTop ? ImageConstants.ICON_ARROW_CURVED_DOWN : ImageConstants.ICON_ARROW_CURVED_UP);
801 			} else if (isFirstInBranchWithSiblings(frame)) {
802 				return plugin.getImage(
803 						threadRootAtTop ? ImageConstants.ICON_ARROW_FORK3_DOWN : ImageConstants.ICON_ARROW_FORK3_UP);
804 			} else if (isLastFrame(frame)) {
805 				return plugin.getImage(
806 						threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN_END : ImageConstants.ICON_ARROW_UP_END);
807 			} else {
808 				return plugin.getImage(threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN : ImageConstants.ICON_ARROW_UP);
809 			}
810 		}
811 
812 		@Override
813 		public Color getBackground(Object element) {
814 			if (treeLayout) {
815 				return null;
816 			} else {
817 				int parentCount = 0;
818 				Branch e = ((StacktraceFrame) element).getBranch();
819 				while (e != null) {
820 					e = e.getParentFork().getParentBranch();
821 					parentCount++;
822 				}
823 				return parentCount % 2 == 0 ? null : ALTERNATE_COLOR;
824 			}
825 		}
826 	};
827 
828 	private static boolean isNavigationFrame(StacktraceFrame frame) {
829 		return isFirstInBranchWithSiblings(frame) &amp;&amp; !isInOpenFork(frame);
830 	}
831 
832 	// See JMC-6787
833 	@SuppressWarnings(&quot;deprecation&quot;)
834 	private static boolean isInOpenFork(StacktraceFrame frame) {
835 		return frame.getBranch().getParentFork().getSelectedBranch() == null;
836 	}
837 
838 	private static boolean isFirstInBranchWithSiblings(StacktraceFrame frame) {
839 		return frame.getBranch().getFirstFrame() == frame &amp;&amp; frame.getBranch().getParentFork().getBranchCount() &gt; 1;
840 	}
841 
842 	private static boolean isLastFrame(StacktraceFrame frame) {
843 		return frame.getBranch().getLastFrame() == frame &amp;&amp; frame.getBranch().getEndFork().getBranchCount() == 0;
844 	}
845 
846 	/*
847 	 * FIXME: &#39;backwards&#39; argument was used for displaying trace groups built from thread roots with
848 	 * the thread roots at the bottom. If we don&#39;t want to support that scenario then we can remove
849 	 * this argument.
850 	 */
851 	private static void addSelectedBranches(Fork fork, SimpleArray&lt;StacktraceFrame&gt; input, boolean backwards) {
852 		// See JMC-6787
853 		@SuppressWarnings(&quot;deprecation&quot;)
854 		Branch selectedBranch = fork.getSelectedBranch();
855 		if (selectedBranch == null) {
856 			Stream.of(fork.getFirstFrames()).forEach(input::add);
857 		} else if (backwards) {
858 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
859 			StacktraceFrame[] tail = selectedBranch.getTailFrames();
860 			for (int i = tail.length; i &gt; 0; i--) {
861 				input.add(tail[i - 1]);
862 			}
863 			input.add(selectedBranch.getFirstFrame());
864 		} else {
865 			input.add(selectedBranch.getFirstFrame());
866 			input.addAll(selectedBranch.getTailFrames());
867 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
868 		}
869 	}
870 
<a name="6" id="anc6"></a><span class="line-removed">871 	// See JMC-6787</span>
<span class="line-removed">872 	@SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="line-removed">873 	private static Branch getLastSelectedBranch(Fork fromFork) {</span>
<span class="line-removed">874 		Branch lastSelectedBranch = null;</span>
<span class="line-removed">875 		Branch branch = fromFork.getSelectedBranch();</span>
<span class="line-removed">876 		while (branch != null) {</span>
<span class="line-removed">877 			lastSelectedBranch = branch;</span>
<span class="line-removed">878 			branch = branch.getEndFork().getSelectedBranch();</span>
<span class="line-removed">879 		}</span>
<span class="line-removed">880 		return lastSelectedBranch;</span>
<span class="line-removed">881 	}</span>
<span class="line-removed">882 </span>
883 	private static Fork getRootFork(Fork fork) {
884 		while (fork.getParentBranch() != null) {
885 			fork = fork.getParentBranch().getParentFork();
886 		}
887 		return fork;
888 	}
889 
890 	private static class StacktraceTreeContentProvider extends AbstractStructuredContentProvider
891 			implements ITreeContentProvider {
892 
893 		@Override
894 		public StacktraceFrame[] getElements(Object inputElement) {
895 			return ((Fork) inputElement).getFirstFrames();
896 		}
897 
898 		@Override
899 		public boolean hasChildren(Object element) {
900 			StacktraceFrame frame = (StacktraceFrame) element;
901 			return !isLastFrame(frame);
902 		}
903 
904 		@Override
905 		public StacktraceFrame[] getChildren(Object parentElement) {
906 			StacktraceFrame frame = (StacktraceFrame) parentElement;
907 			StacktraceFrame[] tailFrames = frame.getBranch().getTailFrames();
908 			if (frame.getIndexInBranch() == tailFrames.length) {
909 				return frame.getBranch().getEndFork().getFirstFrames();
910 			} else {
911 				return new StacktraceFrame[] {tailFrames[frame.getIndexInBranch()]};
912 			}
913 		}
914 
915 		@Override
916 		public StacktraceFrame getParent(Object element) {
917 			StacktraceFrame frame = (StacktraceFrame) element;
918 			int parentIndexInBranch = frame.getIndexInBranch() - 1;
919 			if (parentIndexInBranch &gt; 0) {
920 				return frame.getBranch().getTailFrames()[parentIndexInBranch - 1];
921 			} else if (parentIndexInBranch == 0) {
922 				return frame.getBranch().getFirstFrame();
923 			} else {
924 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
925 				return parentBranch == null ? null : parentBranch.getLastFrame();
926 			}
927 		}
928 	};
929 
930 	private static class StacktraceReducedTreeContentProvider extends AbstractStructuredContentProvider
931 			implements ITreeContentProvider {
932 
933 		@Override
934 		public StacktraceFrame[] getElements(Object inputElement) {
935 			Fork rootFork = (Fork) inputElement;
936 			if (rootFork.getBranchCount() == 1) {
937 				Branch branch = rootFork.getBranch(0);
938 				return Stream
939 						.concat(Stream.concat(Stream.of(branch.getFirstFrame()), Stream.of(branch.getTailFrames())),
940 								Stream.of(branch.getEndFork().getFirstFrames()))
941 						.toArray(StacktraceFrame[]::new);
942 			} else {
943 				return rootFork.getFirstFrames();
944 			}
945 		}
946 
947 		@Override
948 		public boolean hasChildren(Object element) {
949 			StacktraceFrame frame = (StacktraceFrame) element;
950 			return isFirstInBranchWithSiblings(frame) &amp;&amp; frame.getBranch().hasTail();
951 		}
952 
953 		@Override
954 		public StacktraceFrame[] getChildren(Object parentElement) {
955 			Stream&lt;StacktraceFrame&gt; children = Stream.empty();
956 			StacktraceFrame frame = (StacktraceFrame) parentElement;
957 			if (isFirstInBranchWithSiblings(frame)) {
958 				children = Stream.concat(Stream.of(frame.getBranch().getTailFrames()),
959 						Stream.of(frame.getBranch().getEndFork().getFirstFrames()));
960 			}
961 			return children.toArray(StacktraceFrame[]::new);
962 		}
963 
964 		@Override
965 		public StacktraceFrame getParent(Object element) {
966 			StacktraceFrame frame = (StacktraceFrame) element;
967 			if (isFirstInBranchWithSiblings(frame) || frame.getBranch().getParentFork().getBranchCount() == 1) {
968 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
969 				return parentBranch == null ? null : parentBranch.getFirstFrame();
970 			} else {
971 				return frame.getBranch().getFirstFrame();
972 			}
973 		}
974 	}
975 
976 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
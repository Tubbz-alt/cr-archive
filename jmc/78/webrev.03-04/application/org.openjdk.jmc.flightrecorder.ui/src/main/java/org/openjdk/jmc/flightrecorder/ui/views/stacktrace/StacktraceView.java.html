<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.ui.views.stacktrace;
 34 
 35 import static org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.getLastSelectedBranch;
 36 
 37 import java.util.Arrays;
 38 import java.util.List;
 39 import java.util.Optional;
 40 import java.util.concurrent.CompletableFuture;
 41 import java.util.concurrent.ExecutorService;
 42 import java.util.concurrent.Executors;
 43 import java.util.logging.Level;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.IntStream;
 46 import java.util.stream.Stream;
 47 
 48 import org.eclipse.core.runtime.IAdapterFactory;
 49 import org.eclipse.core.runtime.Platform;
 50 import org.eclipse.jface.action.Action;
 51 import org.eclipse.jface.action.IAction;
 52 import org.eclipse.jface.action.IMenuManager;
 53 import org.eclipse.jface.action.IToolBarManager;
 54 import org.eclipse.jface.action.MenuManager;
 55 import org.eclipse.jface.action.Separator;
 56 import org.eclipse.jface.viewers.AbstractTreeViewer;
 57 import org.eclipse.jface.viewers.ColumnLabelProvider;
 58 import org.eclipse.jface.viewers.ColumnViewer;
 59 import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;
 60 import org.eclipse.jface.viewers.ISelection;
 61 import org.eclipse.jface.viewers.ISelectionChangedListener;
 62 import org.eclipse.jface.viewers.IStructuredSelection;
 63 import org.eclipse.jface.viewers.ITreeContentProvider;
 64 import org.eclipse.jface.viewers.SelectionChangedEvent;
 65 import org.eclipse.jface.viewers.StructuredSelection;
 66 import org.eclipse.jface.viewers.StructuredViewer;
 67 import org.eclipse.jface.viewers.TableViewer;
 68 import org.eclipse.jface.viewers.TableViewerColumn;
 69 import org.eclipse.jface.viewers.TreeViewer;
 70 import org.eclipse.jface.viewers.TreeViewerColumn;
 71 import org.eclipse.jface.viewers.ViewerCell;
 72 import org.eclipse.jface.viewers.ViewerColumn;
 73 import org.eclipse.jface.window.ToolTip;
 74 import org.eclipse.swt.SWT;
 75 import org.eclipse.swt.events.TraverseEvent;
 76 import org.eclipse.swt.events.TraverseListener;
 77 import org.eclipse.swt.graphics.Color;
 78 import org.eclipse.swt.graphics.Image;
 79 import org.eclipse.swt.graphics.RGB;
 80 import org.eclipse.swt.widgets.Composite;
 81 import org.eclipse.swt.widgets.Display;
 82 import org.eclipse.swt.widgets.Event;
 83 import org.eclipse.swt.widgets.Listener;
 84 import org.eclipse.swt.widgets.TableColumn;
 85 import org.eclipse.swt.widgets.TreeColumn;
 86 import org.eclipse.ui.IEditorPart;
 87 import org.eclipse.ui.IMemento;
 88 import org.eclipse.ui.ISelectionListener;
 89 import org.eclipse.ui.IViewSite;
 90 import org.eclipse.ui.IWorkbenchPart;
 91 import org.eclipse.ui.PartInitException;
 92 import org.eclipse.ui.PlatformUI;
 93 import org.eclipse.ui.forms.widgets.FormText;
 94 import org.eclipse.ui.part.ViewPart;
 95 import org.openjdk.jmc.common.IDisplayable;
 96 import org.openjdk.jmc.common.IMCFrame;
 97 import org.openjdk.jmc.common.IState;
 98 import org.openjdk.jmc.common.collection.SimpleArray;
 99 import org.openjdk.jmc.common.item.IItemCollection;
100 import org.openjdk.jmc.common.unit.UnitLookup;
101 import org.openjdk.jmc.common.util.StateToolkit;
102 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;
103 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;
104 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;
105 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;
106 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel;
107 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Branch;
108 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Fork;
109 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
110 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
111 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
112 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
113 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
114 import org.openjdk.jmc.flightrecorder.ui.selection.IFlavoredSelection;
115 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore;
116 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
117 import org.openjdk.jmc.flightrecorder.ui.selection.StacktraceFrameSelection;
118 import org.openjdk.jmc.ui.CoreImages;
119 import org.openjdk.jmc.ui.UIPlugin;
120 import org.openjdk.jmc.ui.accessibility.FocusTracker;
121 import org.openjdk.jmc.ui.common.util.AdapterUtil;
122 import org.openjdk.jmc.ui.handlers.ActionToolkit;
123 import org.openjdk.jmc.ui.handlers.CopySelectionAction;
124 import org.openjdk.jmc.ui.handlers.InFocusHandlerActivator;
125 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
126 import org.openjdk.jmc.ui.handlers.MethodFormatter;
127 import org.openjdk.jmc.ui.misc.AbstractStructuredContentProvider;
128 import org.openjdk.jmc.ui.misc.CompositeToolkit;
129 import org.openjdk.jmc.ui.misc.CopySettings;
130 import org.openjdk.jmc.ui.misc.DisplayToolkit;
131 import org.openjdk.jmc.ui.misc.FormatToolkit;
132 import org.openjdk.jmc.ui.misc.MementoToolkit;
133 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
134 
135 public class StacktraceView extends ViewPart implements ISelectionListener {
136 
137 	static {
138 		// Adapt using IAdapterFactory to support object contribution for IMCMethod (e.g jump to source)
139 		Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {
140 
141 			@Override
142 			public &lt;T&gt; T getAdapter(Object adaptableObject, Class&lt;T&gt; adapterType) {
143 				if (adaptableObject instanceof StacktraceFrame &amp;&amp; adapterType == IMCFrame.class) {
144 					return adapterType.cast(((StacktraceFrame) adaptableObject).getFrame());
145 				}
146 				return null;
147 			}
148 
149 			@Override
150 			public Class&lt;?&gt;[] getAdapterList() {
151 				return new Class[] {IMCFrame.class};
152 			}
153 		}, StacktraceFrame.class);
154 	}
155 
156 	private class GroupByAction extends Action {
157 
158 		private final boolean fromThreadRootAction;
159 
160 		GroupByAction(boolean fromRoot) {
161 			super(fromRoot ? Messages.STACKTRACE_VIEW_THREAD_ROOT : Messages.STACKTRACE_VIEW_LAST_FRAME,
162 					IAction.AS_RADIO_BUTTON);
163 			fromThreadRootAction = fromRoot;
164 			setToolTipText(fromRoot ? Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_ROOT
165 					: Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_LAST_FRAME);
166 			setImageDescriptor(fromRoot ? CoreImages.THREAD : CoreImages.METHOD_NON_OPTIMIZED);
167 			setChecked(fromRoot == threadRootAtTop);
168 		}
169 
170 		@Override
171 		public void run() {
172 			boolean newValue = isChecked() == fromThreadRootAction;
173 			if (newValue != threadRootAtTop) {
174 				threadRootAtTop = newValue;
175 				rebuildModel();
176 			}
177 		}
178 	}
179 
180 	private static final ExecutorService MODEL_EXECUTOR = Executors.newFixedThreadPool(1);
181 	private static final String HELP_CONTEXT_ID = FlightRecorderUI.PLUGIN_ID + &quot;.StacktraceView&quot;; //$NON-NLS-1$
182 	// FIXME: Define dynamic color (editable in preferences, to handle dark themes etc.)
183 	private static final Color ALTERNATE_COLOR = SWTColorToolkit.getColor(new RGB(255, 255, 240));
184 	private static final String COUNT_IMG_KEY = &quot;countColor&quot;; //$NON-NLS-1$
185 	private static final Color COUNT_COLOR = SWTColorToolkit.getColor(new RGB(100, 200, 100));
186 	private static final String SIBLINGS_IMG_KEY = &quot;siblingsColor&quot;; //$NON-NLS-1$
187 	private static final Color SIBLINGS_COUNT_COLOR = SWTColorToolkit.getColor(new RGB(170, 250, 170));
188 	private static final int[] DEFAULT_COLUMN_WIDTHS = {650, 80, 120};
189 	private static final String THREAD_ROOT_KEY = &quot;threadRootAtTop&quot;; //$NON-NLS-1$
190 	private static final String FRAME_OPTIMIZATION_KEY = &quot;distinguishFramesByOptimization&quot;; //$NON-NLS-1$
191 	private static final String FRAME_CATEGORIZATION_KEY = &quot;distinguishFramesCategorization&quot;; //$NON-NLS-1$
192 	private static final String TREE_LAYOUT_KEY = &quot;treeLayout&quot;; //$NON-NLS-1$
193 	private static final String REDUCED_TREE_KEY = &quot;reducedTreeLayout&quot;; //$NON-NLS-1$
194 	private static final String METHOD_FORMAT_KEY = &quot;metodFormat&quot;; //$NON-NLS-1$
195 	private static final String COLUMNS_KEY = &quot;columns&quot;; //$NON-NLS-1$
196 	private static final String COLUMNS_SEPARATOR = &quot; &quot;; //$NON-NLS-1$
197 	private ColumnViewer viewer;
198 	private boolean treeLayout;
199 	private boolean reducedTree;
200 	private boolean threadRootAtTop;
201 	private IItemCollection itemsToShow;
202 	private MethodFormatter methodFormatter;
203 	private FrameSeparatorManager frameSeparatorManager;
204 	private GroupByAction[] groupByActions;
205 	private IAction[] layoutActions;
206 	private ViewerAction[] viewerActions;
207 	private int[] columnWidths;
208 
209 	private static class StacktraceViewToolTipSupport extends ColumnViewerToolTipSupport {
210 
211 		StacktraceViewToolTipSupport(ColumnViewer viewer) {
212 			super(viewer, ToolTip.NO_RECREATE, false);
213 		}
214 
215 		@Override
216 		protected Composite createViewerToolTipContentArea(Event event, ViewerCell cell, Composite parent) {
217 			FormText formText = CompositeToolkit.createInfoFormText(parent);
218 			formText.setImage(COUNT_IMG_KEY, SWTColorToolkit.getColorThumbnail(COUNT_COLOR.getRGB()));
219 			formText.setImage(SIBLINGS_IMG_KEY, SWTColorToolkit.getColorThumbnail(SIBLINGS_COUNT_COLOR.getRGB()));
220 			formText.setText(getText(event), true, false);
221 			return formText;
222 		}
223 
224 	}
225 
226 	private static class ViewerAction extends Action implements ISelectionChangedListener {
227 
228 		protected StructuredViewer provider = null;
229 
230 		public ViewerAction(String text) {
231 			super(text);
232 			setViewer(null);
233 			setEnabled(false);
234 		}
235 
236 		public void setViewer(StructuredViewer provider) {
237 			this.provider = provider;
238 			if (provider != null) {
239 				provider.addSelectionChangedListener(this);
240 				selectionChanged(getStructuredSelection());
241 			} else {
242 				setEnabled(false);
243 			}
244 		}
245 
246 		@Override
247 		public void selectionChanged(SelectionChangedEvent event) {
248 			ISelection selection = event.getSelection();
249 			if (selection instanceof IStructuredSelection) {
250 				selectionChanged((IStructuredSelection) selection);
251 			}
252 		}
253 
254 		protected void selectionChanged(IStructuredSelection selection) {
255 		}
256 
257 		protected IStructuredSelection getStructuredSelection() {
258 			if (provider != null) {
259 				ISelection selection = provider.getSelection();
260 				if (selection instanceof IStructuredSelection) {
261 					return (IStructuredSelection) selection;
262 				}
263 			}
264 			return new StructuredSelection();
265 		}
266 
267 	}
268 
269 	static class SelectFrameGroupAction extends ViewerAction {
270 
271 		SelectFrameGroupAction() {
272 			super(Messages.STACKTRACE_VIEW_FRAME_GROUP_CHOOSE);
273 			setImageDescriptor(
274 					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_STAR));
275 			setAccelerator(SWT.CR);
276 		}
277 
278 		@Override
279 		public void setViewer(StructuredViewer provider) {
280 			super.setViewer(provider);
281 			if (provider != null) {
282 				provider.addDoubleClickListener(e -&gt; {
283 					if (isEnabled()) {
284 						run();
285 					}
286 				});
287 			}
288 		}
289 
290 		// See JMC-6787
291 		@SuppressWarnings(&quot;deprecation&quot;)
292 		@Override
293 		public void run() {
294 			StacktraceFrame frame = (StacktraceFrame) getStructuredSelection().getFirstElement();
295 			// FIXME: Would like to move the table cursor after changing sibling state, not just the selection.
296 			if (isInOpenFork(frame)) {
297 				frame.getBranch().selectSibling(0);
298 			} else {
299 				frame.getBranch().selectSibling(null);
300 			}
301 			provider.getControl().setRedraw(false);
302 			try {
303 				provider.refresh();
304 			} finally {
305 				provider.getControl().setRedraw(true);
306 			}
307 			provider.setSelection(new StructuredSelection(frame));
308 
309 		}
310 
311 		@Override
312 		public void selectionChanged(IStructuredSelection selection) {
313 			setEnabled(selection.size() == 1
314 					&amp;&amp; isFirstInBranchWithSiblings((StacktraceFrame) selection.getFirstElement()));
315 		}
316 
317 	}
318 
319 	static class NavigateAction extends ViewerAction implements TraverseListener {
320 
321 		private final int offset;
322 
323 		NavigateAction(boolean forward) {
324 			super(forward ? Messages.STACKTRACE_VIEW_FRAME_GROUP_NEXT : Messages.STACKTRACE_VIEW_FRAME_GROUP_PREVIOUS);
325 			setImageDescriptor(
326 					forward ? FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_RIGHT)
327 							: FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_LEFT));
328 			offset = forward ? 1 : -1;
329 			setAccelerator(forward ? SWT.ARROW_RIGHT : SWT.ARROW_LEFT);
330 		}
331 
332 		@Override
333 		public void setViewer(StructuredViewer provider) {
334 			super.setViewer(provider);
335 			if (provider != null) {
336 				provider.getControl().addTraverseListener(this);
337 			}
338 		}
339 
340 		@Override
341 		public void run() {
342 			Branch branch = ((StacktraceFrame) getStructuredSelection().getFirstElement()).getBranch();
343 			// See JMC-6787
344 			@SuppressWarnings(&quot;deprecation&quot;)
345 			Branch selectedSibling = branch.selectSibling(offset);
346 			provider.refresh();
347 			provider.setSelection(new StructuredSelection(selectedSibling.getFirstFrame()));
348 		}
349 
350 		@Override
351 		protected void selectionChanged(IStructuredSelection selection) {
352 			setEnabled(selection.size() == 1 &amp;&amp; isNavigationFrame((StacktraceFrame) selection.getFirstElement()));
353 		}
354 
355 		@Override
356 		public void keyTraversed(TraverseEvent e) {
357 			if (isEnabled()) {
358 				if (e.keyCode == getAccelerator()) {
359 					run();
360 					e.detail = SWT.TRAVERSE_NONE;
361 					e.doit = true;
362 				}
363 			}
364 		}
365 
366 	};
367 
368 	@Override
369 	public void init(IViewSite site, IMemento memento) throws PartInitException {
370 		super.init(site, memento);
371 		IState state = MementoToolkit.asState(memento);
372 		threadRootAtTop = StateToolkit.readBoolean(state, THREAD_ROOT_KEY, false);
373 		groupByActions = new GroupByAction[] {new GroupByAction(false), new GroupByAction(true)};
374 		treeLayout = StateToolkit.readBoolean(state, TREE_LAYOUT_KEY, false);
375 		reducedTree = StateToolkit.readBoolean(state, REDUCED_TREE_KEY, true);
376 
377 		IAction reducedTreeAction = ActionToolkit.checkAction(this::setReducedTree,
378 				Messages.STACKTRACE_VIEW_REDUCE_TREE_DEPTH, null);
379 		reducedTreeAction.setChecked(reducedTree);
380 		IAction treeAction = ActionToolkit.checkAction(this::setTreeLayout, Messages.STACKTRACE_VIEW_SHOW_AS_TREE,
381 				CoreImages.TREE_MODE);
382 		treeAction.setChecked(treeLayout);
383 		layoutActions = new IAction[] {treeAction, reducedTreeAction};
384 
385 		NavigateAction forwardAction = new NavigateAction(true);
386 		NavigateAction backwardAction = new NavigateAction(false);
387 		SelectFrameGroupAction selectGroupAction = new SelectFrameGroupAction();
388 		viewerActions = new ViewerAction[] {selectGroupAction, forwardAction, backwardAction};
389 
390 		try {
391 			columnWidths = Optional.ofNullable(state)
392 					.map(s -&gt; Stream.of(s.getAttribute(COLUMNS_KEY).split(COLUMNS_SEPARATOR))
393 							.mapToInt(Integer::parseInt).toArray())
394 					.filter(widths -&gt; widths.length == DEFAULT_COLUMN_WIDTHS.length
395 							&amp;&amp; Arrays.stream(widths).allMatch(w -&gt; w &gt;= 0))
396 					.orElse(DEFAULT_COLUMN_WIDTHS);
397 		} catch (RuntimeException e) {
398 			columnWidths = DEFAULT_COLUMN_WIDTHS;
399 		}
400 
401 		FrameCategorization categorization = StateToolkit.readEnum(state, FRAME_CATEGORIZATION_KEY,
402 				FrameCategorization.METHOD, FrameCategorization.class);
403 		boolean byOptimization = StateToolkit.readBoolean(state, FRAME_OPTIMIZATION_KEY, false);
404 		frameSeparatorManager = new FrameSeparatorManager(this::rebuildModel,
405 				new FrameSeparator(categorization, byOptimization));
406 		methodFormatter = new MethodFormatter(memento == null ? null : memento.getChild(METHOD_FORMAT_KEY),
407 				() -&gt; viewer.refresh());
408 		IMenuManager siteMenu = site.getActionBars().getMenuManager();
409 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_TOP));
410 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_VIEWER_SETUP));
411 		addOptions(siteMenu);
412 		IToolBarManager toolBar = site.getActionBars().getToolBarManager();
413 		toolBar.add(selectGroupAction);
414 		toolBar.add(backwardAction);
415 		toolBar.add(forwardAction);
416 		toolBar.add(new Separator());
417 		toolBar.add(treeAction);
418 		toolBar.add(new Separator());
419 		Stream.of(groupByActions).forEach(toolBar::add);
420 
421 		getSite().getPage().addSelectionListener(this);
422 	}
423 
424 	@Override
425 	public void dispose() {
426 		getSite().getPage().removeSelectionListener(this);
427 		super.dispose();
428 	}
429 
430 	@Override
431 	public void createPartControl(Composite parent) {
432 		buildViewer(parent);
433 	}
434 
435 	private void setTreeLayout(boolean treeLayout) {
436 		this.treeLayout = treeLayout;
437 		rebuildViewer();
438 	}
439 
440 	private void setReducedTree(boolean reducedTree) {
441 		this.reducedTree = reducedTree;
442 		if (viewer instanceof TreeViewer) {
443 			viewer.setContentProvider(createTreeContentProvider());
444 		}
445 	}
446 
447 	// See JMC-6787
448 	@SuppressWarnings(&quot;deprecation&quot;)
449 	private void rebuildViewer() {
450 		boolean hasFocus = viewer.getControl().isFocusControl();
451 		ISelection oldSelection = viewer.getSelection();
452 		Fork oldInput = (Fork) viewer.getInput();
453 		Composite parent = viewer.getControl().getParent();
454 		viewer.getControl().dispose();
455 		buildViewer(parent);
456 		if (hasFocus) {
457 			viewer.getControl().setFocus();
458 		}
459 		parent.layout();
460 		if (viewer instanceof TreeViewer) {
461 			// Async set input to avoid drawing issue with tree
462 			Display.getCurrent().asyncExec(() -&gt; {
463 				if (!viewer.getControl().isDisposed()) {
464 					setViewerInput(oldInput);
465 					if (reducedTree &amp;&amp; oldInput != null) {
466 						Branch selectedBranch = getLastSelectedBranch(oldInput);
467 						if (selectedBranch != null) {
468 							viewer.getControl().setRedraw(false);
469 							((TreeViewer) viewer).expandToLevel(selectedBranch.getLastFrame(),
470 									AbstractTreeViewer.ALL_LEVELS);
471 							viewer.getControl().setRedraw(true);
472 						}
473 					}
474 					viewer.setSelection(oldSelection, true);
475 				}
476 			});
477 		} else {
478 			Branch branch = null;
479 			for (Object o : ((IStructuredSelection) oldSelection).toList()) {
480 				if (branch == null) {
481 					branch = ((StacktraceFrame) o).getBranch();
482 				} else if (branch != ((StacktraceFrame) o).getBranch()) {
483 					branch = null;
484 					break;
485 				}
486 			}
487 			if (branch != null) {
488 				branch.selectSibling(0);
489 			}
490 			setViewerInput(oldInput);
491 			viewer.setSelection(oldSelection, true);
492 		}
493 	}
494 
495 	private void buildViewer(Composite parent) {
496 		if (treeLayout) {
497 			viewer = buildTree(parent);
498 		} else {
499 			viewer = buildTable(parent);
500 		}
501 		new StacktraceViewToolTipSupport(viewer);
502 		MCContextMenuManager mm = MCContextMenuManager.create(viewer.getControl());
503 		CopySelectionAction copyAction = new CopySelectionAction(viewer,
504 				FormatToolkit.selectionFormatter(stackTraceLabelProvider, countLabelProvider, percentageLabelProvider));
505 		InFocusHandlerActivator.install(viewer.getControl(), copyAction);
506 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, copyAction);
507 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, CopySettings.getInstance().createContributionItem());
508 		addOptions(mm);
509 		getSite().registerContextMenu(mm, viewer);
510 		if (!treeLayout) {
511 			String navigateGroupName = &quot;NAVIGATE&quot;; //$NON-NLS-1$
512 			mm.insert(0, new Separator(navigateGroupName));
513 			Stream.of(viewerActions).forEach(a -&gt; {
514 				a.setViewer(viewer);
515 				mm.appendToGroup(navigateGroupName, a);
516 			});
517 		} else {
518 			Stream.of(viewerActions).forEach(a -&gt; a.setViewer(null));
519 		}
520 
521 		viewer.getControl().addListener(SWT.EraseItem, PERCENTAGE_BACKGROUND_DRAWER);
522 		viewer.getControl().addDisposeListener(e -&gt; columnWidths = getColumnWidths());
523 
524 		buildColumn(viewer, Messages.STACKTRACE_VIEW_STACK_TRACE, SWT.NONE, columnWidths[0])
525 				.setLabelProvider(stackTraceLabelProvider);
526 		buildColumn(viewer, Messages.STACKTRACE_VIEW_COUNT_COLUMN_NAME, SWT.RIGHT, columnWidths[1])
527 				.setLabelProvider(countLabelProvider);
528 		buildColumn(viewer, Messages.STACKTRACE_VIEW_PERCENTAGE_COLUMN_NAME, SWT.RIGHT, columnWidths[2])
529 				.setLabelProvider(percentageLabelProvider);
530 
531 		PlatformUI.getWorkbench().getHelpSystem().setHelp(viewer.getControl(), HELP_CONTEXT_ID);
532 
533 		if (UIPlugin.getDefault().getAccessibilityMode()) {
534 			if (treeLayout) {
535 				FocusTracker.enableFocusTracking(((TreeViewer) viewer).getTree());
536 			} else {
537 				FocusTracker.enableFocusTracking(((TableViewer) viewer).getTable());
538 			}
539 		}
540 	}
541 
542 	private static TableViewer buildTable(Composite parent) {
543 		TableViewer tableViewer = new TableViewer(parent,
544 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
545 		tableViewer.setContentProvider(new AbstractStructuredContentProvider() {
546 			@Override
547 			public Object[] getElements(Object inputElement) {
548 				SimpleArray&lt;StacktraceFrame&gt; trace = new SimpleArray&lt;&gt;(new StacktraceFrame[100]);
549 				addSelectedBranches((Fork) inputElement, trace, false);
550 				return trace.elements();
551 			}
552 		});
553 		tableViewer.getTable().setHeaderVisible(true);
554 		tableViewer.getTable().setLinesVisible(true);
555 		return tableViewer;
556 	}
557 
558 	private TreeViewer buildTree(Composite parent) {
559 		TreeViewer treeViewer = new TreeViewer(parent,
560 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
561 		treeViewer.setContentProvider(createTreeContentProvider());
562 		treeViewer.getTree().setHeaderVisible(true);
563 		treeViewer.getTree().setLinesVisible(true);
564 		return treeViewer;
565 	}
566 
567 	private static ViewerColumn buildColumn(ColumnViewer viewer, String text, int style, int width) {
568 		if (viewer instanceof TableViewer) {
569 			TableViewerColumn vc = new TableViewerColumn((TableViewer) viewer, style);
570 			vc.getColumn().setWidth(width);
571 			vc.getColumn().setText(text);
572 			return vc;
573 		} else {
574 			TreeViewerColumn vc = new TreeViewerColumn((TreeViewer) viewer, style);
575 			vc.getColumn().setWidth(width);
576 			vc.getColumn().setText(text);
577 			return vc;
578 		}
579 	}
580 
581 	private int[] getColumnWidths() {
582 		if (!viewer.getControl().isDisposed()) {
583 			if (viewer instanceof TableViewer) {
584 				return Stream.of(((TableViewer) viewer).getTable().getColumns()).mapToInt(TableColumn::getWidth)
585 						.toArray();
586 			} else {
587 				return Stream.of(((TreeViewer) viewer).getTree().getColumns()).mapToInt(TreeColumn::getWidth).toArray();
588 			}
589 		}
590 		return columnWidths;
591 	}
592 
593 	private void addOptions(IMenuManager menu) {
594 		MenuManager groupMenu = new MenuManager(Messages.STACKTRACE_VIEW_GROUP_FROM);
595 		Stream.of(groupByActions).forEach(groupMenu::add);
596 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, groupMenu);
597 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, frameSeparatorManager.createMenu());
598 		MenuManager layoutMenu = new MenuManager(Messages.STACKTRACE_VIEW_LAYOUT_OPTIONS);
599 		Stream.of(layoutActions).forEach(layoutMenu::add);
600 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, layoutMenu);
601 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, methodFormatter.createMenu());
602 		SelectionStoreActionToolkit.addSelectionStoreActions(viewer, this::getSelectionStore,
603 				this::getFlavoredSelection, menu);
604 	}
605 
606 	private IFlavoredSelection getFlavoredSelection() {
607 		ISelection selection = viewer.getSelection();
608 		if (selection instanceof IStructuredSelection &amp;&amp; !selection.isEmpty()) {
609 			List&lt;?&gt; selected = ((StructuredSelection) selection).toList();
610 			StacktraceFrame frame = (StacktraceFrame) selected.get(0);
611 			return new StacktraceFrameSelection(frame.getFrame(),
612 					ItemCollectionToolkit.build(Stream.of(frame.getItems().elements())),
613 					Messages.STACKTRACE_VIEW_SELECTION);
614 		}
615 		return null;
616 	}
617 
618 	private SelectionStore getSelectionStore() {
619 		IEditorPart editorPart = null;
620 		try {
621 			PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
622 			editorPart = getSite().getPage().getActiveEditor();
623 		} catch (Exception e) {
624 			FlightRecorderUI.getDefault().getLogger().log(Level.INFO,
625 					&quot;Got exception while trying to get the active editor&quot;, e); //$NON-NLS-1$
626 		}
627 		if (editorPart instanceof IPageContainer) {
628 			return ((IPageContainer) editorPart).getSelectionStore();
629 		}
630 		return null;
631 	}
632 
633 	@Override
634 	public void setFocus() {
635 		viewer.getControl().setFocus();
636 	}
637 
638 	@Override
639 	public void saveState(IMemento memento) {
640 		memento.putString(COLUMNS_KEY, IntStream.of(getColumnWidths()).mapToObj(Integer::toString)
641 				.collect(Collectors.joining(COLUMNS_SEPARATOR)));
642 		methodFormatter.saveState(memento.createChild(METHOD_FORMAT_KEY));
643 		memento.putBoolean(THREAD_ROOT_KEY, threadRootAtTop);
644 		memento.putBoolean(TREE_LAYOUT_KEY, treeLayout);
645 		memento.putBoolean(REDUCED_TREE_KEY, reducedTree);
646 		FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
647 		memento.putBoolean(FRAME_OPTIMIZATION_KEY, frameSeparator.isDistinguishFramesByOptimization());
648 		memento.putString(FRAME_CATEGORIZATION_KEY, frameSeparator.getCategorization().name());
649 	}
650 
651 	@Override
652 	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
653 		if (selection instanceof IStructuredSelection) {
654 			Object first = ((IStructuredSelection) selection).getFirstElement();
655 			IItemCollection items = AdapterUtil.getAdapter(first, IItemCollection.class);
656 			if (items == null) {
657 				setItems(ItemCollectionToolkit.build(Stream.empty()));
658 			} else if (!items.equals(itemsToShow)) {
659 				setItems(items);
660 			}
661 		}
662 	}
663 
664 	private void setItems(IItemCollection items) {
665 		itemsToShow = items;
666 		rebuildModel();
667 	}
668 
669 	private StacktraceModel createStacktraceModel() {
670 		return new StacktraceModel(threadRootAtTop, frameSeparatorManager.getFrameSeparator(), itemsToShow);
671 	}
672 
673 	private void rebuildModel() {
674 		// Release old model before building the new
675 		setViewerInput(null);
676 		CompletableFuture&lt;StacktraceModel&gt; modelPreparer = getModelPreparer(createStacktraceModel(), !treeLayout);
677 		modelPreparer.thenAcceptAsync(this::setModel, DisplayToolkit.inDisplayThread())
678 				.exceptionally(StacktraceView::handleModelBuildException);
679 	}
680 
681 	private static CompletableFuture&lt;StacktraceModel&gt; getModelPreparer(
682 		StacktraceModel model, boolean materializeSelectedBranches) {
683 		return CompletableFuture.supplyAsync(() -&gt; {
684 			Fork root = model.getRootFork();
685 			if (materializeSelectedBranches) {
686 				Branch selectedBranch = getLastSelectedBranch(root);
687 				if (selectedBranch != null) {
688 					selectedBranch.getEndFork();
689 				}
690 			}
691 			return model;
692 		}, MODEL_EXECUTOR);
693 	}
694 
695 	private static Void handleModelBuildException(Throwable ex) {
696 		FlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, &quot;Failed to build stacktrace view model&quot;, ex); //$NON-NLS-1$
697 		return null;
698 	}
699 
700 	private void setModel(StacktraceModel model) {
701 		// Check that the model is up to date
702 		if (model.equals(createStacktraceModel()) &amp;&amp; !viewer.getControl().isDisposed()) {
703 			setViewerInput(model.getRootFork());
704 		}
705 	}
706 
707 	private void setViewerInput(Fork rootFork) {
708 		// NOTE: will be slow for TreeViewer if number of roots or children of a node are more than ~1000
709 		viewer.setInput(rootFork);
710 	}
711 
712 	private ITreeContentProvider createTreeContentProvider() {
713 		return reducedTree ? new StacktraceReducedTreeContentProvider() : new StacktraceTreeContentProvider();
714 	}
715 
716 	private static final Listener PERCENTAGE_BACKGROUND_DRAWER = new Listener() {
717 		@Override
718 		public void handleEvent(Event event) {
719 			StacktraceFrame frame = (StacktraceFrame) event.item.getData();
720 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
721 			double total;
722 			if (event.index == 2 &amp;&amp; (total = rootFork.getItemsInFork()) &gt; 0) { // index == 2 =&gt; percentage column
723 				// Draw siblings
724 				Fork parentFork = frame.getBranch().getParentFork();
725 				int forkOffset = parentFork.getItemOffset();
726 				int siblingsStart = (int) Math.floor(event.width * forkOffset / total);
727 				int siblingsWidth = (int) Math.round(event.width * parentFork.getItemsInFork() / total);
728 				event.gc.setBackground(SIBLINGS_COUNT_COLOR);
729 				event.gc.fillRectangle(event.x + siblingsStart, event.y, siblingsWidth, event.height);
730 				// Draw group
731 				double offset = (forkOffset + frame.getBranch().getItemOffsetInFork()) / total;
732 				double fraction = frame.getItemCount() / total;
733 				event.gc.setBackground(COUNT_COLOR);
734 				int startPixel = (int) Math.floor(event.width * offset);
735 				int widthPixel = (int) Math.round(event.width * fraction);
736 				event.gc.fillRectangle(event.x + startPixel, event.y, Math.max(widthPixel, 1), event.height);
737 				event.detail &amp;= ~SWT.BACKGROUND;
738 			}
739 		}
740 	};
741 
742 	private final ColumnLabelProvider percentageLabelProvider = new ColumnLabelProvider() {
743 		@Override
744 		public String getText(Object element) {
745 			StacktraceFrame frame = (StacktraceFrame) element;
746 			int itemCount = frame.getItemCount();
747 			int totalCount = getRootFork(frame.getBranch().getParentFork()).getItemsInFork();
748 			return UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount).displayUsing(IDisplayable.AUTO);
749 		}
750 
751 		@Override
752 		public String getToolTipText(Object element) {
753 			StacktraceFrame frame = (StacktraceFrame) element;
754 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
755 			int itemCount = frame.getItemCount();
756 			int totalCount = rootFork.getItemsInFork();
757 			Fork parentFork = frame.getBranch().getParentFork();
758 			int itemsInSiblings = parentFork.getItemsInFork() - frame.getBranch().getFirstFrame().getItemCount();
759 			String frameFraction = UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount)
760 					.displayUsing(IDisplayable.AUTO);
761 			StringBuilder sb = new StringBuilder(&quot;&lt;form&gt;&quot;); //$NON-NLS-1$
762 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + COUNT_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
763 			sb.append(Messages.stackTraceMessage(itemCount, totalCount, frameFraction));
764 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
765 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + SIBLINGS_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
766 			sb.append(Messages.siblingMessage(itemsInSiblings, parentFork.getBranchCount() - 1));
767 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
768 			sb.append(&quot;&lt;/form&gt;&quot;); //$NON-NLS-1$
769 			return sb.toString();
770 		}
771 	};
772 
773 	private final ColumnLabelProvider countLabelProvider = new ColumnLabelProvider() {
774 		@Override
775 		public String getText(Object element) {
776 			return Integer.toString(((StacktraceFrame) element).getItemCount());
777 		}
778 	};
779 
780 	private final ColumnLabelProvider stackTraceLabelProvider = new ColumnLabelProvider() {
781 
782 		@Override
783 		public String getText(Object element) {
784 			IMCFrame frame = ((StacktraceFrame) element).getFrame();
785 			FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
786 			return getText(frame, frameSeparator);
787 		}
788 
789 		private String getText(IMCFrame frame, FrameSeparator frameSeparator) {
790 			return StacktraceFormatToolkit.formatFrame(frame, frameSeparator, methodFormatter.showReturnValue(),
791 					methodFormatter.showReturnValuePackage(), methodFormatter.showClassName(),
792 					methodFormatter.showClassPackageName(), methodFormatter.showArguments(),
793 					methodFormatter.showArgumentsPackage());
794 		}
795 
796 		@Override
797 		public Image getImage(Object element) {
798 			StacktraceFrame frame = (StacktraceFrame) element;
799 			FlightRecorderUI plugin = FlightRecorderUI.getDefault();
800 			boolean isFirstInBranch = isFirstInBranchWithSiblings(frame);
801 			boolean firstInOpenFork = isFirstInBranch &amp;&amp; isInOpenFork(frame);
802 			if (firstInOpenFork || treeLayout &amp;&amp; (!reducedTree || isFirstInBranch)) {
803 				return plugin.getImage(
804 						threadRootAtTop ? ImageConstants.ICON_ARROW_CURVED_DOWN : ImageConstants.ICON_ARROW_CURVED_UP);
805 			} else if (isFirstInBranchWithSiblings(frame)) {
806 				return plugin.getImage(
807 						threadRootAtTop ? ImageConstants.ICON_ARROW_FORK3_DOWN : ImageConstants.ICON_ARROW_FORK3_UP);
808 			} else if (isLastFrame(frame)) {
809 				return plugin.getImage(
810 						threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN_END : ImageConstants.ICON_ARROW_UP_END);
811 			} else {
812 				return plugin.getImage(threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN : ImageConstants.ICON_ARROW_UP);
813 			}
814 		}
815 
816 		@Override
817 		public Color getBackground(Object element) {
818 			if (treeLayout) {
819 				return null;
820 			} else {
821 				int parentCount = 0;
822 				Branch e = ((StacktraceFrame) element).getBranch();
823 				while (e != null) {
824 					e = e.getParentFork().getParentBranch();
825 					parentCount++;
826 				}
827 				return parentCount % 2 == 0 ? null : ALTERNATE_COLOR;
828 			}
829 		}
830 	};
831 
832 	private static boolean isNavigationFrame(StacktraceFrame frame) {
833 		return isFirstInBranchWithSiblings(frame) &amp;&amp; !isInOpenFork(frame);
834 	}
835 
836 	// See JMC-6787
837 	@SuppressWarnings(&quot;deprecation&quot;)
838 	private static boolean isInOpenFork(StacktraceFrame frame) {
839 		return frame.getBranch().getParentFork().getSelectedBranch() == null;
840 	}
841 
842 	private static boolean isFirstInBranchWithSiblings(StacktraceFrame frame) {
843 		return frame.getBranch().getFirstFrame() == frame &amp;&amp; frame.getBranch().getParentFork().getBranchCount() &gt; 1;
844 	}
845 
846 	private static boolean isLastFrame(StacktraceFrame frame) {
847 		return frame.getBranch().getLastFrame() == frame &amp;&amp; frame.getBranch().getEndFork().getBranchCount() == 0;
848 	}
849 
850 	/*
851 	 * FIXME: &#39;backwards&#39; argument was used for displaying trace groups built from thread roots with
852 	 * the thread roots at the bottom. If we don&#39;t want to support that scenario then we can remove
853 	 * this argument.
854 	 */
855 	private static void addSelectedBranches(Fork fork, SimpleArray&lt;StacktraceFrame&gt; input, boolean backwards) {
856 		// See JMC-6787
857 		@SuppressWarnings(&quot;deprecation&quot;)
858 		Branch selectedBranch = fork.getSelectedBranch();
859 		if (selectedBranch == null) {
860 			Stream.of(fork.getFirstFrames()).forEach(input::add);
861 		} else if (backwards) {
862 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
863 			StacktraceFrame[] tail = selectedBranch.getTailFrames();
864 			for (int i = tail.length; i &gt; 0; i--) {
865 				input.add(tail[i - 1]);
866 			}
867 			input.add(selectedBranch.getFirstFrame());
868 		} else {
869 			input.add(selectedBranch.getFirstFrame());
870 			input.addAll(selectedBranch.getTailFrames());
871 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
872 		}
873 	}
874 
875 	private static Fork getRootFork(Fork fork) {
876 		while (fork.getParentBranch() != null) {
877 			fork = fork.getParentBranch().getParentFork();
878 		}
879 		return fork;
880 	}
881 
882 	private static class StacktraceTreeContentProvider extends AbstractStructuredContentProvider
883 			implements ITreeContentProvider {
884 
885 		@Override
886 		public StacktraceFrame[] getElements(Object inputElement) {
887 			return ((Fork) inputElement).getFirstFrames();
888 		}
889 
890 		@Override
891 		public boolean hasChildren(Object element) {
892 			StacktraceFrame frame = (StacktraceFrame) element;
893 			return !isLastFrame(frame);
894 		}
895 
896 		@Override
897 		public StacktraceFrame[] getChildren(Object parentElement) {
898 			StacktraceFrame frame = (StacktraceFrame) parentElement;
899 			StacktraceFrame[] tailFrames = frame.getBranch().getTailFrames();
900 			if (frame.getIndexInBranch() == tailFrames.length) {
901 				return frame.getBranch().getEndFork().getFirstFrames();
902 			} else {
903 				return new StacktraceFrame[] {tailFrames[frame.getIndexInBranch()]};
904 			}
905 		}
906 
907 		@Override
908 		public StacktraceFrame getParent(Object element) {
909 			StacktraceFrame frame = (StacktraceFrame) element;
910 			int parentIndexInBranch = frame.getIndexInBranch() - 1;
911 			if (parentIndexInBranch &gt; 0) {
912 				return frame.getBranch().getTailFrames()[parentIndexInBranch - 1];
913 			} else if (parentIndexInBranch == 0) {
914 				return frame.getBranch().getFirstFrame();
915 			} else {
916 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
917 				return parentBranch == null ? null : parentBranch.getLastFrame();
918 			}
919 		}
920 	};
921 
922 	private static class StacktraceReducedTreeContentProvider extends AbstractStructuredContentProvider
923 			implements ITreeContentProvider {
924 
925 		@Override
926 		public StacktraceFrame[] getElements(Object inputElement) {
927 			Fork rootFork = (Fork) inputElement;
928 			if (rootFork.getBranchCount() == 1) {
929 				Branch branch = rootFork.getBranch(0);
930 				return Stream
931 						.concat(Stream.concat(Stream.of(branch.getFirstFrame()), Stream.of(branch.getTailFrames())),
932 								Stream.of(branch.getEndFork().getFirstFrames()))
933 						.toArray(StacktraceFrame[]::new);
934 			} else {
935 				return rootFork.getFirstFrames();
936 			}
937 		}
938 
939 		@Override
940 		public boolean hasChildren(Object element) {
941 			StacktraceFrame frame = (StacktraceFrame) element;
942 			return isFirstInBranchWithSiblings(frame) &amp;&amp; frame.getBranch().hasTail();
943 		}
944 
945 		@Override
946 		public StacktraceFrame[] getChildren(Object parentElement) {
947 			Stream&lt;StacktraceFrame&gt; children = Stream.empty();
948 			StacktraceFrame frame = (StacktraceFrame) parentElement;
949 			if (isFirstInBranchWithSiblings(frame)) {
950 				children = Stream.concat(Stream.of(frame.getBranch().getTailFrames()),
951 						Stream.of(frame.getBranch().getEndFork().getFirstFrames()));
952 			}
953 			return children.toArray(StacktraceFrame[]::new);
954 		}
955 
956 		@Override
957 		public StacktraceFrame getParent(Object element) {
958 			StacktraceFrame frame = (StacktraceFrame) element;
959 			if (isFirstInBranchWithSiblings(frame) || frame.getBranch().getParentFork().getBranchCount() == 1) {
960 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
961 				return parentBranch == null ? null : parentBranch.getFirstFrame();
962 			} else {
963 				return frame.getBranch().getFirstFrame();
964 			}
965 		}
966 	}
967 
968 }
    </pre>
  </body>
</html>
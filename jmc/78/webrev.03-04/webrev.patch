diff a/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/tree/TraceNode.java b/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/tree/TraceNode.java
--- a/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/tree/TraceNode.java
+++ b/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/tree/TraceNode.java
@@ -35,10 +35,11 @@
 
 import java.util.ArrayList;
 import java.util.List;
 
 public class TraceNode {
+	public static final TraceNode EMPTY = new TraceNode(null, 0, null);
 	private final int value;
 	private final String name;
 	private final String packageName;
 	private final List<TraceNode> children = new ArrayList<>();
 
diff a/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/views/FlameGraphView.java b/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/views/FlameGraphView.java
--- a/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/views/FlameGraphView.java
+++ b/application/org.openjdk.jmc.flightrecorder.flameview/src/main/java/org/openjdk/jmc/flightrecorder/flameview/views/FlameGraphView.java
@@ -60,10 +60,11 @@
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.logging.Level;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import org.eclipse.jface.action.Action;
@@ -162,14 +163,14 @@
 	private static final ExecutorService MODEL_EXECUTOR = Executors.newFixedThreadPool(1);
 	private FrameSeparator frameSeparator;
 
 	private Browser browser;
 	private SashForm container;
-	private volatile CompletableFuture<ModelsContainer> currentModelCalculator;
 	private boolean threadRootAtTop = true;
 	private boolean icicleViewActive = true;
 	private IItemCollection currentItems = ItemCollectionToolkit.build(Stream.empty());
+	private volatile AtomicBoolean modelCalculationActive = new AtomicBoolean();
 	private GroupByAction[] groupByActions;
 	private GroupByFlameviewAction[] groupByFlameviewActions;
 	private ExportAction[] exportActions;
 
 	private enum GroupActionType {
@@ -280,14 +281,15 @@
 
 	/**
 	 * Container for created {@link TraceNode} and {@link StacktraceModel}
 	 */
 	private static final class ModelsContainer {
+		private static final ModelsContainer EMPTY = new ModelsContainer(null, null);
 		private final TraceNode root;
 		private final StacktraceModel model;
 
-		public ModelsContainer(TraceNode root, StacktraceModel model) {
+		private ModelsContainer(TraceNode root, StacktraceModel model) {
 			super();
 			this.root = root;
 			this.model = model;
 		}
 
@@ -302,10 +304,45 @@
 		private boolean isReady() {
 			return root != null && model != null;
 		}
 	}
 
+	/**
+	 * JsonModel hold the calculated json string and has state that can not be finished due to the
+	 * usage inside the {@link CompletableFuture} future, can be only set to ready
+	 */
+	private static class JSonModelBuilder {
+		private static final JSonModelBuilder EMPTY = new JSonModelBuilder("\"\"", true);
+		private final StringBuilder builder = new StringBuilder();
+		private boolean ready;
+
+		private JSonModelBuilder() {
+			this.ready = false;
+		}
+
+		private JSonModelBuilder(String json, boolean ready) {
+			this.builder.append(json);
+			this.ready = ready;
+		}
+
+		private void append(String s) {
+			this.builder.append(s);
+		}
+
+		private String build() {
+			return builder.toString();
+		}
+
+		private boolean isReady() {
+			return ready;
+		}
+
+		private void setReady() {
+			this.ready = true;
+		}
+	}
+
 	@Override
 	public void init(IViewSite site, IMemento memento) throws PartInitException {
 		super.init(site, memento);
 		frameSeparator = new FrameSeparator(FrameCategorization.METHOD, false);
 		groupByActions = new GroupByAction[] {new GroupByAction(GroupActionType.LAST_FRAME),
@@ -371,49 +408,55 @@
 	}
 
 	private void setItems(IItemCollection items) {
 		currentItems = items;
 		rebuildModel();
+
 	}
 
 	private void rebuildModel() {
-		// try to cancel downstream calculation
-		if (currentModelCalculator != null) {
-			currentModelCalculator.cancel(true);
+		if (modelCalculationActive.get()) {
+			modelCalculationActive.set(false);
 		}
-
-		currentModelCalculator = getModelPreparer(frameSeparator, true);
+		final CompletableFuture<ModelsContainer> currentModelCalculator = getModelPreparer(createStacktraceModel(),
+				true);
 		currentModelCalculator.thenAcceptAsync(this::setModel, DisplayToolkit.inDisplayThread())
 				.exceptionally(FlameGraphView::handleModelBuildException);
 	}
 
 	private StacktraceModel createStacktraceModel() {
 		return new StacktraceModel(threadRootAtTop, frameSeparator, currentItems);
 	}
 
 	private CompletableFuture<ModelsContainer> getModelPreparer(
-		final FrameSeparator separator, final boolean materializeSelectedBranches) {
+		final StacktraceModel model, final boolean materializeSelectedBranches) {
 		return CompletableFuture.supplyAsync(() -> {
-			StacktraceModel model = createStacktraceModel();
+			modelCalculationActive.set(true);
 			Fork rootFork = model.getRootFork();
 			if (materializeSelectedBranches) {
 				Branch selectedBranch = getLastSelectedBranch(rootFork);
 				if (selectedBranch != null) {
 					selectedBranch.getEndFork();
 				}
 			}
 
-			TraceNode root = TraceTreeUtils.createRootWithDescription(currentItems, rootFork.getBranchCount());
-			return new ModelsContainer(TraceTreeUtils.createTree(root, model), model);
-
+			if (modelCalculationActive.get()) {
+				TraceNode root = TraceTreeUtils.createRootWithDescription(currentItems, rootFork.getBranchCount());
+				return new ModelsContainer(TraceTreeUtils.createTree(root, model), model);
+			} else {
+				System.out.println("FLAME, getModelPreparer CANCEL");
+				return ModelsContainer.EMPTY;
+			}
 		}, MODEL_EXECUTOR);
 	}
 
 	private void setModel(ModelsContainer container) {
 		// Check that the models are prepared and up to date 
 		if (container.isReady() && container.isEqualStacktraceModel(createStacktraceModel()) && !browser.isDisposed()) {
 			setViewerInput(container.root());
+		} else {
+			System.out.println("FLAME, setModel CANCEL");
 		}
 	}
 
 	private void setViewerInput(TraceNode root) {
 		Stream.of(exportActions).forEach((action) -> action.setEnabled(false));
@@ -426,13 +469,17 @@
 			@Override
 			public void completed(ProgressEvent event) {
 				browser.removeProgressListener(this);
 				browser.execute(String.format("configureTooltipText('%s', '%s', '%s', '%s', '%s');", TABLE_COLUMN_COUNT,
 						TABLE_COLUMN_EVENT_TYPE, TOOLTIP_PACKAGE, TOOLTIP_SAMPLES, TOOLTIP_DESCRIPTION));
-
-				browser.execute(String.format("processGraph(%s, %s);", toJSon(root), icicleViewActive));
-				Stream.of(exportActions).forEach((action) -> action.setEnabled(true));
+				JSonModelBuilder jsonModel = toJSonModel(root);
+				if (jsonModel.isReady()) {
+					browser.execute(String.format("processGraph(%s, %s);", jsonModel.build(), icicleViewActive));
+					Stream.of(exportActions).forEach((action) -> action.setEnabled(true));
+				} else {
+					System.out.println("FLAME, setViewerInput CANCEL");
+				}
 			}
 		});
 
 	}
 
@@ -504,41 +551,59 @@
 			FlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, "Failed to build stacktrace view model", ex); //$NON-NLS-1$
 		}
 		return null;
 	}
 
-	private static String toJSon(TraceNode root) {
+	private JSonModelBuilder toJSonModel(TraceNode root) {
 		if (root == null) {
-			return "\"\"";
+			return JSonModelBuilder.EMPTY;
 		}
 		return render(root);
 	}
 
-	private static String render(TraceNode root) {
-		StringBuilder builder = new StringBuilder();
+	private JSonModelBuilder render(TraceNode root) {
+		JSonModelBuilder builder = new JSonModelBuilder();
 		String rootNodeStart = createJsonRootTraceNode(root);
 		builder.append(rootNodeStart);
-		renderChildren(builder, root);
+		AtomicBoolean renderActive = new AtomicBoolean(true);
+		renderChildren(renderActive, builder, root);
 		builder.append("]}");
-		return builder.toString();
+		if (renderActive.get()) {
+			builder.setReady();
+		}
+		return builder;
 	}
 
-	private static void render(StringBuilder builder, TraceNode node) {
+	private void render(AtomicBoolean renderActive, JSonModelBuilder builder, TraceNode node) {
 		String start = UNCLASSIFIABLE_FRAME.equals(node.getName()) ? createJsonDescTraceNode(node)
 				: createJsonTraceNode(node);
 		builder.append(start);
-		renderChildren(builder, node);
+		renderChildren(renderActive, builder, node);
 		builder.append("]}");
 	}
 
-	private static void renderChildren(StringBuilder builder, TraceNode node) {
-		for (int i = 0; i < node.getChildren().size(); i++) {
-			render(builder, node.getChildren().get(i));
-			if (i < node.getChildren().size() - 1) {
-				builder.append(",");
+	private void renderChildren(AtomicBoolean renderActive, JSonModelBuilder builder, TraceNode node) {
+
+		int i = 0;
+		while (i < node.getChildren().size()) {
+			if (modelCalculationActive.get()) {
+				render(renderActive, builder, node.getChildren().get(i));
+				if (i < node.getChildren().size() - 1) {
+					builder.append(",");
+				}
+			} else {
+				modelCalculationActive.set(false);
 			}
+			i++;
 		}
+
+//		for (int i = 0; i < node.getChildren().size(); i++) {
+//			render(builder, node.getChildren().get(i));
+//			if (i < node.getChildren().size() - 1) {
+//				builder.append(",");
+//			}
+//		}
 	}
 
 	private static String createJsonRootTraceNode(TraceNode rootNode) {
 		return String.format("{%s,%s,%s, \"c\": [ ", toJSonKeyValue("n", rootNode.getName()), toJSonKeyValue("p", ""),
 				toJSonKeyValue("d", rootNode.getPackageName()));
diff a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java
--- a/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java
+++ b/application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java
@@ -36,10 +36,12 @@
 
 import java.util.Arrays;
 import java.util.List;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.logging.Level;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
@@ -173,10 +175,11 @@
 				rebuildModel();
 			}
 		}
 	}
 
+	private static final ExecutorService MODEL_EXECUTOR = Executors.newFixedThreadPool(1);
 	private static final String HELP_CONTEXT_ID = FlightRecorderUI.PLUGIN_ID + ".StacktraceView"; //$NON-NLS-1$
 	// FIXME: Define dynamic color (editable in preferences, to handle dark themes etc.)
 	private static final Color ALTERNATE_COLOR = SWTColorToolkit.getColor(new RGB(255, 255, 240));
 	private static final String COUNT_IMG_KEY = "countColor"; //$NON-NLS-1$
 	private static final Color COUNT_COLOR = SWTColorToolkit.getColor(new RGB(100, 200, 100));
@@ -684,11 +687,11 @@
 				if (selectedBranch != null) {
 					selectedBranch.getEndFork();
 				}
 			}
 			return model;
-		});
+		}, MODEL_EXECUTOR);
 	}
 
 	private static Void handleModelBuildException(Throwable ex) {
 		FlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, "Failed to build stacktrace view model", ex); //$NON-NLS-1$
 		return null;

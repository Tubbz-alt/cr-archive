<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New application/org.openjdk.jmc.flightrecorder.ui/src/main/java/org/openjdk/jmc/flightrecorder/ui/views/stacktrace/StacktraceView.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.ui.views.stacktrace;
 34 
 35 import static org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.getLastSelectedBranch;
 36 
 37 import java.util.Arrays;
 38 import java.util.List;
 39 import java.util.Optional;
 40 import java.util.concurrent.CompletableFuture;
 41 import java.util.logging.Level;
 42 import java.util.stream.Collectors;
 43 import java.util.stream.IntStream;
 44 import java.util.stream.Stream;
 45 
 46 import org.eclipse.core.runtime.IAdapterFactory;
 47 import org.eclipse.core.runtime.Platform;
 48 import org.eclipse.jface.action.Action;
 49 import org.eclipse.jface.action.IAction;
 50 import org.eclipse.jface.action.IMenuManager;
 51 import org.eclipse.jface.action.IToolBarManager;
 52 import org.eclipse.jface.action.MenuManager;
 53 import org.eclipse.jface.action.Separator;
 54 import org.eclipse.jface.viewers.AbstractTreeViewer;
 55 import org.eclipse.jface.viewers.ColumnLabelProvider;
 56 import org.eclipse.jface.viewers.ColumnViewer;
 57 import org.eclipse.jface.viewers.ColumnViewerToolTipSupport;
 58 import org.eclipse.jface.viewers.ISelection;
 59 import org.eclipse.jface.viewers.ISelectionChangedListener;
 60 import org.eclipse.jface.viewers.IStructuredSelection;
 61 import org.eclipse.jface.viewers.ITreeContentProvider;
 62 import org.eclipse.jface.viewers.SelectionChangedEvent;
 63 import org.eclipse.jface.viewers.StructuredSelection;
 64 import org.eclipse.jface.viewers.StructuredViewer;
 65 import org.eclipse.jface.viewers.TableViewer;
 66 import org.eclipse.jface.viewers.TableViewerColumn;
 67 import org.eclipse.jface.viewers.TreeViewer;
 68 import org.eclipse.jface.viewers.TreeViewerColumn;
 69 import org.eclipse.jface.viewers.ViewerCell;
 70 import org.eclipse.jface.viewers.ViewerColumn;
 71 import org.eclipse.jface.window.ToolTip;
 72 import org.eclipse.swt.SWT;
 73 import org.eclipse.swt.events.TraverseEvent;
 74 import org.eclipse.swt.events.TraverseListener;
 75 import org.eclipse.swt.graphics.Color;
 76 import org.eclipse.swt.graphics.Image;
 77 import org.eclipse.swt.graphics.RGB;
 78 import org.eclipse.swt.widgets.Composite;
 79 import org.eclipse.swt.widgets.Display;
 80 import org.eclipse.swt.widgets.Event;
 81 import org.eclipse.swt.widgets.Listener;
 82 import org.eclipse.swt.widgets.TableColumn;
 83 import org.eclipse.swt.widgets.TreeColumn;
 84 import org.eclipse.ui.IEditorPart;
 85 import org.eclipse.ui.IMemento;
 86 import org.eclipse.ui.ISelectionListener;
 87 import org.eclipse.ui.IViewSite;
 88 import org.eclipse.ui.IWorkbenchPart;
 89 import org.eclipse.ui.PartInitException;
 90 import org.eclipse.ui.PlatformUI;
 91 import org.eclipse.ui.forms.widgets.FormText;
 92 import org.eclipse.ui.part.ViewPart;
 93 import org.openjdk.jmc.common.IDisplayable;
 94 import org.openjdk.jmc.common.IMCFrame;
 95 import org.openjdk.jmc.common.IState;
 96 import org.openjdk.jmc.common.collection.SimpleArray;
 97 import org.openjdk.jmc.common.item.IItemCollection;
 98 import org.openjdk.jmc.common.unit.UnitLookup;
 99 import org.openjdk.jmc.common.util.StateToolkit;
100 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;
101 import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;
102 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFormatToolkit;
103 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;
104 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel;
105 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Branch;
106 import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Fork;
107 import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;
108 import org.openjdk.jmc.flightrecorder.ui.IPageContainer;
109 import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;
110 import org.openjdk.jmc.flightrecorder.ui.common.ImageConstants;
111 import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;
112 import org.openjdk.jmc.flightrecorder.ui.selection.IFlavoredSelection;
113 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStore;
114 import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;
115 import org.openjdk.jmc.flightrecorder.ui.selection.StacktraceFrameSelection;
116 import org.openjdk.jmc.ui.CoreImages;
117 import org.openjdk.jmc.ui.UIPlugin;
118 import org.openjdk.jmc.ui.accessibility.FocusTracker;
119 import org.openjdk.jmc.ui.common.util.AdapterUtil;
120 import org.openjdk.jmc.ui.handlers.ActionToolkit;
121 import org.openjdk.jmc.ui.handlers.CopySelectionAction;
122 import org.openjdk.jmc.ui.handlers.InFocusHandlerActivator;
123 import org.openjdk.jmc.ui.handlers.MCContextMenuManager;
124 import org.openjdk.jmc.ui.handlers.MethodFormatter;
125 import org.openjdk.jmc.ui.misc.AbstractStructuredContentProvider;
126 import org.openjdk.jmc.ui.misc.CompositeToolkit;
127 import org.openjdk.jmc.ui.misc.CopySettings;
128 import org.openjdk.jmc.ui.misc.DisplayToolkit;
129 import org.openjdk.jmc.ui.misc.FormatToolkit;
130 import org.openjdk.jmc.ui.misc.MementoToolkit;
131 import org.openjdk.jmc.ui.misc.SWTColorToolkit;
132 
133 public class StacktraceView extends ViewPart implements ISelectionListener {
134 
135 	static {
136 		// Adapt using IAdapterFactory to support object contribution for IMCMethod (e.g jump to source)
137 		Platform.getAdapterManager().registerAdapters(new IAdapterFactory() {
138 
139 			@Override
140 			public &lt;T&gt; T getAdapter(Object adaptableObject, Class&lt;T&gt; adapterType) {
141 				if (adaptableObject instanceof StacktraceFrame &amp;&amp; adapterType == IMCFrame.class) {
142 					return adapterType.cast(((StacktraceFrame) adaptableObject).getFrame());
143 				}
144 				return null;
145 			}
146 
147 			@Override
148 			public Class&lt;?&gt;[] getAdapterList() {
149 				return new Class[] {IMCFrame.class};
150 			}
151 		}, StacktraceFrame.class);
152 	}
153 
154 	private class GroupByAction extends Action {
155 
156 		private final boolean fromThreadRootAction;
157 
158 		GroupByAction(boolean fromRoot) {
159 			super(fromRoot ? Messages.STACKTRACE_VIEW_THREAD_ROOT : Messages.STACKTRACE_VIEW_LAST_FRAME,
160 					IAction.AS_RADIO_BUTTON);
161 			fromThreadRootAction = fromRoot;
162 			setToolTipText(fromRoot ? Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_ROOT
163 					: Messages.STACKTRACE_VIEW_GROUP_TRACES_FROM_LAST_FRAME);
164 			setImageDescriptor(fromRoot ? CoreImages.THREAD : CoreImages.METHOD_NON_OPTIMIZED);
165 			setChecked(fromRoot == threadRootAtTop);
166 		}
167 
168 		@Override
169 		public void run() {
170 			boolean newValue = isChecked() == fromThreadRootAction;
171 			if (newValue != threadRootAtTop) {
172 				threadRootAtTop = newValue;
173 				rebuildModel();
174 			}
175 		}
176 	}
177 
178 	private static final String HELP_CONTEXT_ID = FlightRecorderUI.PLUGIN_ID + &quot;.StacktraceView&quot;; //$NON-NLS-1$
179 	// FIXME: Define dynamic color (editable in preferences, to handle dark themes etc.)
180 	private static final Color ALTERNATE_COLOR = SWTColorToolkit.getColor(new RGB(255, 255, 240));
181 	private static final String COUNT_IMG_KEY = &quot;countColor&quot;; //$NON-NLS-1$
182 	private static final Color COUNT_COLOR = SWTColorToolkit.getColor(new RGB(100, 200, 100));
183 	private static final String SIBLINGS_IMG_KEY = &quot;siblingsColor&quot;; //$NON-NLS-1$
184 	private static final Color SIBLINGS_COUNT_COLOR = SWTColorToolkit.getColor(new RGB(170, 250, 170));
185 	private static final int[] DEFAULT_COLUMN_WIDTHS = {650, 80, 120};
186 	private static final String THREAD_ROOT_KEY = &quot;threadRootAtTop&quot;; //$NON-NLS-1$
187 	private static final String FRAME_OPTIMIZATION_KEY = &quot;distinguishFramesByOptimization&quot;; //$NON-NLS-1$
188 	private static final String FRAME_CATEGORIZATION_KEY = &quot;distinguishFramesCategorization&quot;; //$NON-NLS-1$
189 	private static final String TREE_LAYOUT_KEY = &quot;treeLayout&quot;; //$NON-NLS-1$
190 	private static final String REDUCED_TREE_KEY = &quot;reducedTreeLayout&quot;; //$NON-NLS-1$
191 	private static final String METHOD_FORMAT_KEY = &quot;metodFormat&quot;; //$NON-NLS-1$
192 	private static final String COLUMNS_KEY = &quot;columns&quot;; //$NON-NLS-1$
193 	private static final String COLUMNS_SEPARATOR = &quot; &quot;; //$NON-NLS-1$
194 	private ColumnViewer viewer;
195 	private boolean treeLayout;
196 	private boolean reducedTree;
197 	private boolean threadRootAtTop;
198 	private IItemCollection itemsToShow;
199 	private MethodFormatter methodFormatter;
200 	private FrameSeparatorManager frameSeparatorManager;
201 	private GroupByAction[] groupByActions;
202 	private IAction[] layoutActions;
203 	private ViewerAction[] viewerActions;
204 	private int[] columnWidths;
205 
206 	private static class StacktraceViewToolTipSupport extends ColumnViewerToolTipSupport {
207 
208 		StacktraceViewToolTipSupport(ColumnViewer viewer) {
209 			super(viewer, ToolTip.NO_RECREATE, false);
210 		}
211 
212 		@Override
213 		protected Composite createViewerToolTipContentArea(Event event, ViewerCell cell, Composite parent) {
214 			FormText formText = CompositeToolkit.createInfoFormText(parent);
215 			formText.setImage(COUNT_IMG_KEY, SWTColorToolkit.getColorThumbnail(COUNT_COLOR.getRGB()));
216 			formText.setImage(SIBLINGS_IMG_KEY, SWTColorToolkit.getColorThumbnail(SIBLINGS_COUNT_COLOR.getRGB()));
217 			formText.setText(getText(event), true, false);
218 			return formText;
219 		}
220 
221 	}
222 
223 	private static class ViewerAction extends Action implements ISelectionChangedListener {
224 
225 		protected StructuredViewer provider = null;
226 
227 		public ViewerAction(String text) {
228 			super(text);
229 			setViewer(null);
230 			setEnabled(false);
231 		}
232 
233 		public void setViewer(StructuredViewer provider) {
234 			this.provider = provider;
235 			if (provider != null) {
236 				provider.addSelectionChangedListener(this);
237 				selectionChanged(getStructuredSelection());
238 			} else {
239 				setEnabled(false);
240 			}
241 		}
242 
243 		@Override
244 		public void selectionChanged(SelectionChangedEvent event) {
245 			ISelection selection = event.getSelection();
246 			if (selection instanceof IStructuredSelection) {
247 				selectionChanged((IStructuredSelection) selection);
248 			}
249 		}
250 
251 		protected void selectionChanged(IStructuredSelection selection) {
252 		}
253 
254 		protected IStructuredSelection getStructuredSelection() {
255 			if (provider != null) {
256 				ISelection selection = provider.getSelection();
257 				if (selection instanceof IStructuredSelection) {
258 					return (IStructuredSelection) selection;
259 				}
260 			}
261 			return new StructuredSelection();
262 		}
263 
264 	}
265 
266 	static class SelectFrameGroupAction extends ViewerAction {
267 
268 		SelectFrameGroupAction() {
269 			super(Messages.STACKTRACE_VIEW_FRAME_GROUP_CHOOSE);
270 			setImageDescriptor(
271 					FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_STAR));
272 			setAccelerator(SWT.CR);
273 		}
274 
275 		@Override
276 		public void setViewer(StructuredViewer provider) {
277 			super.setViewer(provider);
278 			if (provider != null) {
279 				provider.addDoubleClickListener(e -&gt; {
280 					if (isEnabled()) {
281 						run();
282 					}
283 				});
284 			}
285 		}
286 
287 		// See JMC-6787
288 		@SuppressWarnings(&quot;deprecation&quot;)
289 		@Override
290 		public void run() {
291 			StacktraceFrame frame = (StacktraceFrame) getStructuredSelection().getFirstElement();
292 			// FIXME: Would like to move the table cursor after changing sibling state, not just the selection.
293 			if (isInOpenFork(frame)) {
294 				frame.getBranch().selectSibling(0);
295 			} else {
296 				frame.getBranch().selectSibling(null);
297 			}
298 			provider.getControl().setRedraw(false);
299 			try {
300 				provider.refresh();
301 			} finally {
302 				provider.getControl().setRedraw(true);
303 			}
304 			provider.setSelection(new StructuredSelection(frame));
305 
306 		}
307 
308 		@Override
309 		public void selectionChanged(IStructuredSelection selection) {
310 			setEnabled(selection.size() == 1
311 					&amp;&amp; isFirstInBranchWithSiblings((StacktraceFrame) selection.getFirstElement()));
312 		}
313 
314 	}
315 
316 	static class NavigateAction extends ViewerAction implements TraverseListener {
317 
318 		private final int offset;
319 
320 		NavigateAction(boolean forward) {
321 			super(forward ? Messages.STACKTRACE_VIEW_FRAME_GROUP_NEXT : Messages.STACKTRACE_VIEW_FRAME_GROUP_PREVIOUS);
322 			setImageDescriptor(
323 					forward ? FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_RIGHT)
324 							: FlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_ARROW_FORK3_LEFT));
325 			offset = forward ? 1 : -1;
326 			setAccelerator(forward ? SWT.ARROW_RIGHT : SWT.ARROW_LEFT);
327 		}
328 
329 		@Override
330 		public void setViewer(StructuredViewer provider) {
331 			super.setViewer(provider);
332 			if (provider != null) {
333 				provider.getControl().addTraverseListener(this);
334 			}
335 		}
336 
337 		@Override
338 		public void run() {
339 			Branch branch = ((StacktraceFrame) getStructuredSelection().getFirstElement()).getBranch();
340 			// See JMC-6787
341 			@SuppressWarnings(&quot;deprecation&quot;)
342 			Branch selectedSibling = branch.selectSibling(offset);
343 			provider.refresh();
344 			provider.setSelection(new StructuredSelection(selectedSibling.getFirstFrame()));
345 		}
346 
347 		@Override
348 		protected void selectionChanged(IStructuredSelection selection) {
349 			setEnabled(selection.size() == 1 &amp;&amp; isNavigationFrame((StacktraceFrame) selection.getFirstElement()));
350 		}
351 
352 		@Override
353 		public void keyTraversed(TraverseEvent e) {
354 			if (isEnabled()) {
355 				if (e.keyCode == getAccelerator()) {
356 					run();
357 					e.detail = SWT.TRAVERSE_NONE;
358 					e.doit = true;
359 				}
360 			}
361 		}
362 
363 	};
364 
365 	@Override
366 	public void init(IViewSite site, IMemento memento) throws PartInitException {
367 		super.init(site, memento);
368 		IState state = MementoToolkit.asState(memento);
369 		threadRootAtTop = StateToolkit.readBoolean(state, THREAD_ROOT_KEY, false);
370 		groupByActions = new GroupByAction[] {new GroupByAction(false), new GroupByAction(true)};
371 		treeLayout = StateToolkit.readBoolean(state, TREE_LAYOUT_KEY, false);
372 		reducedTree = StateToolkit.readBoolean(state, REDUCED_TREE_KEY, true);
373 
374 		IAction reducedTreeAction = ActionToolkit.checkAction(this::setReducedTree,
375 				Messages.STACKTRACE_VIEW_REDUCE_TREE_DEPTH, null);
376 		reducedTreeAction.setChecked(reducedTree);
377 		IAction treeAction = ActionToolkit.checkAction(this::setTreeLayout, Messages.STACKTRACE_VIEW_SHOW_AS_TREE,
378 				CoreImages.TREE_MODE);
379 		treeAction.setChecked(treeLayout);
380 		layoutActions = new IAction[] {treeAction, reducedTreeAction};
381 
382 		NavigateAction forwardAction = new NavigateAction(true);
383 		NavigateAction backwardAction = new NavigateAction(false);
384 		SelectFrameGroupAction selectGroupAction = new SelectFrameGroupAction();
385 		viewerActions = new ViewerAction[] {selectGroupAction, forwardAction, backwardAction};
386 
387 		try {
388 			columnWidths = Optional.ofNullable(state)
389 					.map(s -&gt; Stream.of(s.getAttribute(COLUMNS_KEY).split(COLUMNS_SEPARATOR))
390 							.mapToInt(Integer::parseInt).toArray())
391 					.filter(widths -&gt; widths.length == DEFAULT_COLUMN_WIDTHS.length
392 							&amp;&amp; Arrays.stream(widths).allMatch(w -&gt; w &gt;= 0))
393 					.orElse(DEFAULT_COLUMN_WIDTHS);
394 		} catch (RuntimeException e) {
395 			columnWidths = DEFAULT_COLUMN_WIDTHS;
396 		}
397 
398 		FrameCategorization categorization = StateToolkit.readEnum(state, FRAME_CATEGORIZATION_KEY,
399 				FrameCategorization.METHOD, FrameCategorization.class);
400 		boolean byOptimization = StateToolkit.readBoolean(state, FRAME_OPTIMIZATION_KEY, false);
401 		frameSeparatorManager = new FrameSeparatorManager(this::rebuildModel,
402 				new FrameSeparator(categorization, byOptimization));
403 		methodFormatter = new MethodFormatter(memento == null ? null : memento.getChild(METHOD_FORMAT_KEY),
404 				() -&gt; viewer.refresh());
405 		IMenuManager siteMenu = site.getActionBars().getMenuManager();
406 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_TOP));
407 		siteMenu.add(new Separator(MCContextMenuManager.GROUP_VIEWER_SETUP));
408 		addOptions(siteMenu);
409 		IToolBarManager toolBar = site.getActionBars().getToolBarManager();
410 		toolBar.add(selectGroupAction);
411 		toolBar.add(backwardAction);
412 		toolBar.add(forwardAction);
413 		toolBar.add(new Separator());
414 		toolBar.add(treeAction);
415 		toolBar.add(new Separator());
416 		Stream.of(groupByActions).forEach(toolBar::add);
417 
418 		getSite().getPage().addSelectionListener(this);
419 	}
420 
421 	@Override
422 	public void dispose() {
423 		getSite().getPage().removeSelectionListener(this);
424 		super.dispose();
425 	}
426 
427 	@Override
428 	public void createPartControl(Composite parent) {
429 		buildViewer(parent);
430 	}
431 
432 	private void setTreeLayout(boolean treeLayout) {
433 		this.treeLayout = treeLayout;
434 		rebuildViewer();
435 	}
436 
437 	private void setReducedTree(boolean reducedTree) {
438 		this.reducedTree = reducedTree;
439 		if (viewer instanceof TreeViewer) {
440 			viewer.setContentProvider(createTreeContentProvider());
441 		}
442 	}
443 
444 	// See JMC-6787
445 	@SuppressWarnings(&quot;deprecation&quot;)
446 	private void rebuildViewer() {
447 		boolean hasFocus = viewer.getControl().isFocusControl();
448 		ISelection oldSelection = viewer.getSelection();
449 		Fork oldInput = (Fork) viewer.getInput();
450 		Composite parent = viewer.getControl().getParent();
451 		viewer.getControl().dispose();
452 		buildViewer(parent);
453 		if (hasFocus) {
454 			viewer.getControl().setFocus();
455 		}
456 		parent.layout();
457 		if (viewer instanceof TreeViewer) {
458 			// Async set input to avoid drawing issue with tree
459 			Display.getCurrent().asyncExec(() -&gt; {
460 				if (!viewer.getControl().isDisposed()) {
461 					setViewerInput(oldInput);
462 					if (reducedTree &amp;&amp; oldInput != null) {
463 						Branch selectedBranch = getLastSelectedBranch(oldInput);
464 						if (selectedBranch != null) {
465 							viewer.getControl().setRedraw(false);
466 							((TreeViewer) viewer).expandToLevel(selectedBranch.getLastFrame(),
467 									AbstractTreeViewer.ALL_LEVELS);
468 							viewer.getControl().setRedraw(true);
469 						}
470 					}
471 					viewer.setSelection(oldSelection, true);
472 				}
473 			});
474 		} else {
475 			Branch branch = null;
476 			for (Object o : ((IStructuredSelection) oldSelection).toList()) {
477 				if (branch == null) {
478 					branch = ((StacktraceFrame) o).getBranch();
479 				} else if (branch != ((StacktraceFrame) o).getBranch()) {
480 					branch = null;
481 					break;
482 				}
483 			}
484 			if (branch != null) {
485 				branch.selectSibling(0);
486 			}
487 			setViewerInput(oldInput);
488 			viewer.setSelection(oldSelection, true);
489 		}
490 	}
491 
492 	private void buildViewer(Composite parent) {
493 		if (treeLayout) {
494 			viewer = buildTree(parent);
495 		} else {
496 			viewer = buildTable(parent);
497 		}
498 		new StacktraceViewToolTipSupport(viewer);
499 		MCContextMenuManager mm = MCContextMenuManager.create(viewer.getControl());
500 		CopySelectionAction copyAction = new CopySelectionAction(viewer,
501 				FormatToolkit.selectionFormatter(stackTraceLabelProvider, countLabelProvider, percentageLabelProvider));
502 		InFocusHandlerActivator.install(viewer.getControl(), copyAction);
503 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, copyAction);
504 		mm.appendToGroup(MCContextMenuManager.GROUP_EDIT, CopySettings.getInstance().createContributionItem());
505 		addOptions(mm);
506 		getSite().registerContextMenu(mm, viewer);
507 		if (!treeLayout) {
508 			String navigateGroupName = &quot;NAVIGATE&quot;; //$NON-NLS-1$
509 			mm.insert(0, new Separator(navigateGroupName));
510 			Stream.of(viewerActions).forEach(a -&gt; {
511 				a.setViewer(viewer);
512 				mm.appendToGroup(navigateGroupName, a);
513 			});
514 		} else {
515 			Stream.of(viewerActions).forEach(a -&gt; a.setViewer(null));
516 		}
517 
518 		viewer.getControl().addListener(SWT.EraseItem, PERCENTAGE_BACKGROUND_DRAWER);
519 		viewer.getControl().addDisposeListener(e -&gt; columnWidths = getColumnWidths());
520 
521 		buildColumn(viewer, Messages.STACKTRACE_VIEW_STACK_TRACE, SWT.NONE, columnWidths[0])
522 				.setLabelProvider(stackTraceLabelProvider);
523 		buildColumn(viewer, Messages.STACKTRACE_VIEW_COUNT_COLUMN_NAME, SWT.RIGHT, columnWidths[1])
524 				.setLabelProvider(countLabelProvider);
525 		buildColumn(viewer, Messages.STACKTRACE_VIEW_PERCENTAGE_COLUMN_NAME, SWT.RIGHT, columnWidths[2])
526 				.setLabelProvider(percentageLabelProvider);
527 
528 		PlatformUI.getWorkbench().getHelpSystem().setHelp(viewer.getControl(), HELP_CONTEXT_ID);
529 
530 		if (UIPlugin.getDefault().getAccessibilityMode()) {
531 			if (treeLayout) {
532 				FocusTracker.enableFocusTracking(((TreeViewer) viewer).getTree());
533 			} else {
534 				FocusTracker.enableFocusTracking(((TableViewer) viewer).getTable());
535 			}
536 		}
537 	}
538 
539 	private static TableViewer buildTable(Composite parent) {
540 		TableViewer tableViewer = new TableViewer(parent,
541 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
542 		tableViewer.setContentProvider(new AbstractStructuredContentProvider() {
543 			@Override
544 			public Object[] getElements(Object inputElement) {
545 				SimpleArray&lt;StacktraceFrame&gt; trace = new SimpleArray&lt;&gt;(new StacktraceFrame[100]);
546 				addSelectedBranches((Fork) inputElement, trace, false);
547 				return trace.elements();
548 			}
549 		});
550 		tableViewer.getTable().setHeaderVisible(true);
551 		tableViewer.getTable().setLinesVisible(true);
552 		return tableViewer;
553 	}
554 
555 	private TreeViewer buildTree(Composite parent) {
556 		TreeViewer treeViewer = new TreeViewer(parent,
557 				SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL | SWT.FULL_SELECTION | SWT.BORDER);
558 		treeViewer.setContentProvider(createTreeContentProvider());
559 		treeViewer.getTree().setHeaderVisible(true);
560 		treeViewer.getTree().setLinesVisible(true);
561 		return treeViewer;
562 	}
563 
564 	private static ViewerColumn buildColumn(ColumnViewer viewer, String text, int style, int width) {
565 		if (viewer instanceof TableViewer) {
566 			TableViewerColumn vc = new TableViewerColumn((TableViewer) viewer, style);
567 			vc.getColumn().setWidth(width);
568 			vc.getColumn().setText(text);
569 			return vc;
570 		} else {
571 			TreeViewerColumn vc = new TreeViewerColumn((TreeViewer) viewer, style);
572 			vc.getColumn().setWidth(width);
573 			vc.getColumn().setText(text);
574 			return vc;
575 		}
576 	}
577 
578 	private int[] getColumnWidths() {
579 		if (!viewer.getControl().isDisposed()) {
580 			if (viewer instanceof TableViewer) {
581 				return Stream.of(((TableViewer) viewer).getTable().getColumns()).mapToInt(TableColumn::getWidth)
582 						.toArray();
583 			} else {
584 				return Stream.of(((TreeViewer) viewer).getTree().getColumns()).mapToInt(TreeColumn::getWidth).toArray();
585 			}
586 		}
587 		return columnWidths;
588 	}
589 
590 	private void addOptions(IMenuManager menu) {
591 		MenuManager groupMenu = new MenuManager(Messages.STACKTRACE_VIEW_GROUP_FROM);
592 		Stream.of(groupByActions).forEach(groupMenu::add);
593 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, groupMenu);
594 		menu.appendToGroup(MCContextMenuManager.GROUP_TOP, frameSeparatorManager.createMenu());
595 		MenuManager layoutMenu = new MenuManager(Messages.STACKTRACE_VIEW_LAYOUT_OPTIONS);
596 		Stream.of(layoutActions).forEach(layoutMenu::add);
597 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, layoutMenu);
598 		menu.appendToGroup(MCContextMenuManager.GROUP_VIEWER_SETUP, methodFormatter.createMenu());
599 		SelectionStoreActionToolkit.addSelectionStoreActions(viewer, this::getSelectionStore,
600 				this::getFlavoredSelection, menu);
601 	}
602 
603 	private IFlavoredSelection getFlavoredSelection() {
604 		ISelection selection = viewer.getSelection();
605 		if (selection instanceof IStructuredSelection &amp;&amp; !selection.isEmpty()) {
606 			List&lt;?&gt; selected = ((StructuredSelection) selection).toList();
607 			StacktraceFrame frame = (StacktraceFrame) selected.get(0);
608 			return new StacktraceFrameSelection(frame.getFrame(),
609 					ItemCollectionToolkit.build(Stream.of(frame.getItems().elements())),
610 					Messages.STACKTRACE_VIEW_SELECTION);
611 		}
612 		return null;
613 	}
614 
615 	private SelectionStore getSelectionStore() {
616 		IEditorPart editorPart = null;
617 		try {
618 			PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
619 			editorPart = getSite().getPage().getActiveEditor();
620 		} catch (Exception e) {
621 			FlightRecorderUI.getDefault().getLogger().log(Level.INFO,
622 					&quot;Got exception while trying to get the active editor&quot;, e); //$NON-NLS-1$
623 		}
624 		if (editorPart instanceof IPageContainer) {
625 			return ((IPageContainer) editorPart).getSelectionStore();
626 		}
627 		return null;
628 	}
629 
630 	@Override
631 	public void setFocus() {
632 		viewer.getControl().setFocus();
633 	}
634 
635 	@Override
636 	public void saveState(IMemento memento) {
637 		memento.putString(COLUMNS_KEY, IntStream.of(getColumnWidths()).mapToObj(Integer::toString)
638 				.collect(Collectors.joining(COLUMNS_SEPARATOR)));
639 		methodFormatter.saveState(memento.createChild(METHOD_FORMAT_KEY));
640 		memento.putBoolean(THREAD_ROOT_KEY, threadRootAtTop);
641 		memento.putBoolean(TREE_LAYOUT_KEY, treeLayout);
642 		memento.putBoolean(REDUCED_TREE_KEY, reducedTree);
643 		FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
644 		memento.putBoolean(FRAME_OPTIMIZATION_KEY, frameSeparator.isDistinguishFramesByOptimization());
645 		memento.putString(FRAME_CATEGORIZATION_KEY, frameSeparator.getCategorization().name());
646 	}
647 
648 	@Override
649 	public void selectionChanged(IWorkbenchPart part, ISelection selection) {
650 		if (selection instanceof IStructuredSelection) {
651 			Object first = ((IStructuredSelection) selection).getFirstElement();
652 			IItemCollection items = AdapterUtil.getAdapter(first, IItemCollection.class);
653 			if (items == null) {
654 				setItems(ItemCollectionToolkit.build(Stream.empty()));
655 			} else if (!items.equals(itemsToShow)) {
656 				setItems(items);
657 			}
658 		}
659 	}
660 
661 	private void setItems(IItemCollection items) {
662 		itemsToShow = items;
663 		rebuildModel();
664 	}
665 
666 	private StacktraceModel createStacktraceModel() {
667 		return new StacktraceModel(threadRootAtTop, frameSeparatorManager.getFrameSeparator(), itemsToShow);
668 	}
669 
670 	private void rebuildModel() {
671 		// Release old model before building the new
672 		setViewerInput(null);
673 		CompletableFuture&lt;StacktraceModel&gt; modelPreparer = getModelPreparer(createStacktraceModel(), !treeLayout);
674 		modelPreparer.thenAcceptAsync(this::setModel, DisplayToolkit.inDisplayThread())
675 				.exceptionally(StacktraceView::handleModelBuildException);
676 	}
677 
678 	private static CompletableFuture&lt;StacktraceModel&gt; getModelPreparer(
679 		StacktraceModel model, boolean materializeSelectedBranches) {
680 		return CompletableFuture.supplyAsync(() -&gt; {
681 			Fork root = model.getRootFork();
682 			if (materializeSelectedBranches) {
683 				Branch selectedBranch = getLastSelectedBranch(root);
684 				if (selectedBranch != null) {
685 					selectedBranch.getEndFork();
686 				}
687 			}
688 			return model;
689 		});
690 	}
691 
692 	private static Void handleModelBuildException(Throwable ex) {
693 		FlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, &quot;Failed to build stacktrace view model&quot;, ex); //$NON-NLS-1$
694 		return null;
695 	}
696 
697 	private void setModel(StacktraceModel model) {
698 		// Check that the model is up to date
699 		if (model.equals(createStacktraceModel()) &amp;&amp; !viewer.getControl().isDisposed()) {
700 			setViewerInput(model.getRootFork());
701 		}
702 	}
703 
704 	private void setViewerInput(Fork rootFork) {
705 		// NOTE: will be slow for TreeViewer if number of roots or children of a node are more than ~1000
706 		viewer.setInput(rootFork);
707 	}
708 
709 	private ITreeContentProvider createTreeContentProvider() {
710 		return reducedTree ? new StacktraceReducedTreeContentProvider() : new StacktraceTreeContentProvider();
711 	}
712 
713 	private static final Listener PERCENTAGE_BACKGROUND_DRAWER = new Listener() {
714 		@Override
715 		public void handleEvent(Event event) {
716 			StacktraceFrame frame = (StacktraceFrame) event.item.getData();
717 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
718 			double total;
719 			if (event.index == 2 &amp;&amp; (total = rootFork.getItemsInFork()) &gt; 0) { // index == 2 =&gt; percentage column
720 				// Draw siblings
721 				Fork parentFork = frame.getBranch().getParentFork();
722 				int forkOffset = parentFork.getItemOffset();
723 				int siblingsStart = (int) Math.floor(event.width * forkOffset / total);
724 				int siblingsWidth = (int) Math.round(event.width * parentFork.getItemsInFork() / total);
725 				event.gc.setBackground(SIBLINGS_COUNT_COLOR);
726 				event.gc.fillRectangle(event.x + siblingsStart, event.y, siblingsWidth, event.height);
727 				// Draw group
728 				double offset = (forkOffset + frame.getBranch().getItemOffsetInFork()) / total;
729 				double fraction = frame.getItemCount() / total;
730 				event.gc.setBackground(COUNT_COLOR);
731 				int startPixel = (int) Math.floor(event.width * offset);
732 				int widthPixel = (int) Math.round(event.width * fraction);
733 				event.gc.fillRectangle(event.x + startPixel, event.y, Math.max(widthPixel, 1), event.height);
734 				event.detail &amp;= ~SWT.BACKGROUND;
735 			}
736 		}
737 	};
738 
739 	private final ColumnLabelProvider percentageLabelProvider = new ColumnLabelProvider() {
740 		@Override
741 		public String getText(Object element) {
742 			StacktraceFrame frame = (StacktraceFrame) element;
743 			int itemCount = frame.getItemCount();
744 			int totalCount = getRootFork(frame.getBranch().getParentFork()).getItemsInFork();
745 			return UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount).displayUsing(IDisplayable.AUTO);
746 		}
747 
748 		@Override
749 		public String getToolTipText(Object element) {
750 			StacktraceFrame frame = (StacktraceFrame) element;
751 			Fork rootFork = getRootFork(frame.getBranch().getParentFork());
752 			int itemCount = frame.getItemCount();
753 			int totalCount = rootFork.getItemsInFork();
754 			Fork parentFork = frame.getBranch().getParentFork();
755 			int itemsInSiblings = parentFork.getItemsInFork() - frame.getBranch().getFirstFrame().getItemCount();
756 			String frameFraction = UnitLookup.PERCENT_UNITY.quantity(itemCount / (double) totalCount)
757 					.displayUsing(IDisplayable.AUTO);
758 			StringBuilder sb = new StringBuilder(&quot;&lt;form&gt;&quot;); //$NON-NLS-1$
759 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + COUNT_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
760 			sb.append(Messages.stackTraceMessage(itemCount, totalCount, frameFraction));
761 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
762 			sb.append(&quot;&lt;li style=&#39;image&#39; value=&#39;&quot; + SIBLINGS_IMG_KEY + &quot;&#39;&gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$
763 			sb.append(Messages.siblingMessage(itemsInSiblings, parentFork.getBranchCount() - 1));
764 			sb.append(&quot;&lt;/li&gt;&quot;); //$NON-NLS-1$
765 			sb.append(&quot;&lt;/form&gt;&quot;); //$NON-NLS-1$
766 			return sb.toString();
767 		}
768 	};
769 
770 	private final ColumnLabelProvider countLabelProvider = new ColumnLabelProvider() {
771 		@Override
772 		public String getText(Object element) {
773 			return Integer.toString(((StacktraceFrame) element).getItemCount());
774 		}
775 	};
776 
777 	private final ColumnLabelProvider stackTraceLabelProvider = new ColumnLabelProvider() {
778 
779 		@Override
780 		public String getText(Object element) {
781 			IMCFrame frame = ((StacktraceFrame) element).getFrame();
782 			FrameSeparator frameSeparator = frameSeparatorManager.getFrameSeparator();
783 			return getText(frame, frameSeparator);
784 		}
785 
786 		private String getText(IMCFrame frame, FrameSeparator frameSeparator) {
787 			return StacktraceFormatToolkit.formatFrame(frame, frameSeparator, methodFormatter.showReturnValue(),
788 					methodFormatter.showReturnValuePackage(), methodFormatter.showClassName(),
789 					methodFormatter.showClassPackageName(), methodFormatter.showArguments(),
790 					methodFormatter.showArgumentsPackage());
791 		}
792 
793 		@Override
794 		public Image getImage(Object element) {
795 			StacktraceFrame frame = (StacktraceFrame) element;
796 			FlightRecorderUI plugin = FlightRecorderUI.getDefault();
797 			boolean isFirstInBranch = isFirstInBranchWithSiblings(frame);
798 			boolean firstInOpenFork = isFirstInBranch &amp;&amp; isInOpenFork(frame);
799 			if (firstInOpenFork || treeLayout &amp;&amp; (!reducedTree || isFirstInBranch)) {
800 				return plugin.getImage(
801 						threadRootAtTop ? ImageConstants.ICON_ARROW_CURVED_DOWN : ImageConstants.ICON_ARROW_CURVED_UP);
802 			} else if (isFirstInBranchWithSiblings(frame)) {
803 				return plugin.getImage(
804 						threadRootAtTop ? ImageConstants.ICON_ARROW_FORK3_DOWN : ImageConstants.ICON_ARROW_FORK3_UP);
805 			} else if (isLastFrame(frame)) {
806 				return plugin.getImage(
807 						threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN_END : ImageConstants.ICON_ARROW_UP_END);
808 			} else {
809 				return plugin.getImage(threadRootAtTop ? ImageConstants.ICON_ARROW_DOWN : ImageConstants.ICON_ARROW_UP);
810 			}
811 		}
812 
813 		@Override
814 		public Color getBackground(Object element) {
815 			if (treeLayout) {
816 				return null;
817 			} else {
818 				int parentCount = 0;
819 				Branch e = ((StacktraceFrame) element).getBranch();
820 				while (e != null) {
821 					e = e.getParentFork().getParentBranch();
822 					parentCount++;
823 				}
824 				return parentCount % 2 == 0 ? null : ALTERNATE_COLOR;
825 			}
826 		}
827 	};
828 
829 	private static boolean isNavigationFrame(StacktraceFrame frame) {
830 		return isFirstInBranchWithSiblings(frame) &amp;&amp; !isInOpenFork(frame);
831 	}
832 
833 	// See JMC-6787
834 	@SuppressWarnings(&quot;deprecation&quot;)
835 	private static boolean isInOpenFork(StacktraceFrame frame) {
836 		return frame.getBranch().getParentFork().getSelectedBranch() == null;
837 	}
838 
839 	private static boolean isFirstInBranchWithSiblings(StacktraceFrame frame) {
840 		return frame.getBranch().getFirstFrame() == frame &amp;&amp; frame.getBranch().getParentFork().getBranchCount() &gt; 1;
841 	}
842 
843 	private static boolean isLastFrame(StacktraceFrame frame) {
844 		return frame.getBranch().getLastFrame() == frame &amp;&amp; frame.getBranch().getEndFork().getBranchCount() == 0;
845 	}
846 
847 	/*
848 	 * FIXME: &#39;backwards&#39; argument was used for displaying trace groups built from thread roots with
849 	 * the thread roots at the bottom. If we don&#39;t want to support that scenario then we can remove
850 	 * this argument.
851 	 */
852 	private static void addSelectedBranches(Fork fork, SimpleArray&lt;StacktraceFrame&gt; input, boolean backwards) {
853 		// See JMC-6787
854 		@SuppressWarnings(&quot;deprecation&quot;)
855 		Branch selectedBranch = fork.getSelectedBranch();
856 		if (selectedBranch == null) {
857 			Stream.of(fork.getFirstFrames()).forEach(input::add);
858 		} else if (backwards) {
859 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
860 			StacktraceFrame[] tail = selectedBranch.getTailFrames();
861 			for (int i = tail.length; i &gt; 0; i--) {
862 				input.add(tail[i - 1]);
863 			}
864 			input.add(selectedBranch.getFirstFrame());
865 		} else {
866 			input.add(selectedBranch.getFirstFrame());
867 			input.addAll(selectedBranch.getTailFrames());
868 			addSelectedBranches(selectedBranch.getEndFork(), input, backwards);
869 		}
870 	}
871 
872 	private static Fork getRootFork(Fork fork) {
873 		while (fork.getParentBranch() != null) {
874 			fork = fork.getParentBranch().getParentFork();
875 		}
876 		return fork;
877 	}
878 
879 	private static class StacktraceTreeContentProvider extends AbstractStructuredContentProvider
880 			implements ITreeContentProvider {
881 
882 		@Override
883 		public StacktraceFrame[] getElements(Object inputElement) {
884 			return ((Fork) inputElement).getFirstFrames();
885 		}
886 
887 		@Override
888 		public boolean hasChildren(Object element) {
889 			StacktraceFrame frame = (StacktraceFrame) element;
890 			return !isLastFrame(frame);
891 		}
892 
893 		@Override
894 		public StacktraceFrame[] getChildren(Object parentElement) {
895 			StacktraceFrame frame = (StacktraceFrame) parentElement;
896 			StacktraceFrame[] tailFrames = frame.getBranch().getTailFrames();
897 			if (frame.getIndexInBranch() == tailFrames.length) {
898 				return frame.getBranch().getEndFork().getFirstFrames();
899 			} else {
900 				return new StacktraceFrame[] {tailFrames[frame.getIndexInBranch()]};
901 			}
902 		}
903 
904 		@Override
905 		public StacktraceFrame getParent(Object element) {
906 			StacktraceFrame frame = (StacktraceFrame) element;
907 			int parentIndexInBranch = frame.getIndexInBranch() - 1;
908 			if (parentIndexInBranch &gt; 0) {
909 				return frame.getBranch().getTailFrames()[parentIndexInBranch - 1];
910 			} else if (parentIndexInBranch == 0) {
911 				return frame.getBranch().getFirstFrame();
912 			} else {
913 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
914 				return parentBranch == null ? null : parentBranch.getLastFrame();
915 			}
916 		}
917 	};
918 
919 	private static class StacktraceReducedTreeContentProvider extends AbstractStructuredContentProvider
920 			implements ITreeContentProvider {
921 
922 		@Override
923 		public StacktraceFrame[] getElements(Object inputElement) {
924 			Fork rootFork = (Fork) inputElement;
925 			if (rootFork.getBranchCount() == 1) {
926 				Branch branch = rootFork.getBranch(0);
927 				return Stream
928 						.concat(Stream.concat(Stream.of(branch.getFirstFrame()), Stream.of(branch.getTailFrames())),
929 								Stream.of(branch.getEndFork().getFirstFrames()))
930 						.toArray(StacktraceFrame[]::new);
931 			} else {
932 				return rootFork.getFirstFrames();
933 			}
934 		}
935 
936 		@Override
937 		public boolean hasChildren(Object element) {
938 			StacktraceFrame frame = (StacktraceFrame) element;
939 			return isFirstInBranchWithSiblings(frame) &amp;&amp; frame.getBranch().hasTail();
940 		}
941 
942 		@Override
943 		public StacktraceFrame[] getChildren(Object parentElement) {
944 			Stream&lt;StacktraceFrame&gt; children = Stream.empty();
945 			StacktraceFrame frame = (StacktraceFrame) parentElement;
946 			if (isFirstInBranchWithSiblings(frame)) {
947 				children = Stream.concat(Stream.of(frame.getBranch().getTailFrames()),
948 						Stream.of(frame.getBranch().getEndFork().getFirstFrames()));
949 			}
950 			return children.toArray(StacktraceFrame[]::new);
951 		}
952 
953 		@Override
954 		public StacktraceFrame getParent(Object element) {
955 			StacktraceFrame frame = (StacktraceFrame) element;
956 			if (isFirstInBranchWithSiblings(frame) || frame.getBranch().getParentFork().getBranchCount() == 1) {
957 				Branch parentBranch = frame.getBranch().getParentFork().getParentBranch();
958 				return parentBranch == null ? null : parentBranch.getFirstFrame();
959 			} else {
960 				return frame.getBranch().getFirstFrame();
961 			}
962 		}
963 	}
964 
965 }
    </pre>
  </body>
</html>
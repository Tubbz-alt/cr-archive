<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames core/tests/org.openjdk.jmc.flightrecorder.rules.jdk.test/src/test/java/org/openjdk/jmc/flightrecorder/test/rules/jdk/TestRulesWithJfr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
  3  * 
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * The contents of this file are subject to the terms of either the Universal Permissive License
  7  * v 1.0 as shown at http://oss.oracle.com/licenses/upl
  8  *
  9  * or the following license:
 10  *
 11  * Redistribution and use in source and binary forms, with or without modification, are permitted
 12  * provided that the following conditions are met:
 13  * 
 14  * 1. Redistributions of source code must retain the above copyright notice, this list of conditions
 15  * and the following disclaimer.
 16  * 
 17  * 2. Redistributions in binary form must reproduce the above copyright notice, this list of
 18  * conditions and the following disclaimer in the documentation and/or other materials provided with
 19  * the distribution.
 20  * 
 21  * 3. Neither the name of the copyright holder nor the names of its contributors may be used to
 22  * endorse or promote products derived from this software without specific prior written permission.
 23  * 
 24  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 25  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 26  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 27  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 28  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 29  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 30  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 31  * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 32  */
 33 package org.openjdk.jmc.flightrecorder.test.rules.jdk;
 34 
 35 import java.io.File;
<a name="1" id="anc1"></a>
 36 import java.io.FileOutputStream;
 37 import java.io.IOException;
 38 import java.io.OutputStream;
 39 import java.util.ArrayDeque;
 40 import java.util.ArrayList;
 41 import java.util.Collection;
 42 import java.util.Deque;
 43 import java.util.Iterator;
 44 import java.util.List;
 45 import java.util.Objects;
 46 import java.util.SortedMap;
 47 import java.util.TimeZone;
 48 import java.util.TreeMap;
 49 import java.util.concurrent.ExecutionException;
 50 import java.util.concurrent.RunnableFuture;
 51 
 52 import javax.xml.parsers.DocumentBuilder;
 53 import javax.xml.parsers.DocumentBuilderFactory;
 54 import javax.xml.parsers.ParserConfigurationException;
 55 import javax.xml.transform.OutputKeys;
 56 import javax.xml.transform.Transformer;
 57 import javax.xml.transform.TransformerException;
 58 import javax.xml.transform.TransformerFactory;
 59 import javax.xml.transform.dom.DOMSource;
 60 import javax.xml.transform.stream.StreamResult;
 61 import javax.xml.xpath.XPath;
 62 import javax.xml.xpath.XPathConstants;
 63 import javax.xml.xpath.XPathExpression;
 64 import javax.xml.xpath.XPathExpressionException;
 65 import javax.xml.xpath.XPathFactory;
 66 
 67 import org.junit.After;
 68 import org.junit.Assert;
 69 import org.junit.Before;
 70 import org.junit.Test;
 71 import org.junit.experimental.categories.Category;
 72 import org.openjdk.jmc.common.item.IAttribute;
 73 import org.openjdk.jmc.common.item.IItem;
 74 import org.openjdk.jmc.common.item.IItemCollection;
 75 import org.openjdk.jmc.common.item.IItemIterable;
 76 import org.openjdk.jmc.common.item.IItemQuery;
 77 import org.openjdk.jmc.common.item.IMemberAccessor;
 78 import org.openjdk.jmc.common.item.IType;
 79 import org.openjdk.jmc.common.test.SlowTests;
 80 import org.openjdk.jmc.common.test.TestToolkit;
 81 import org.openjdk.jmc.common.test.io.IOResource;
 82 import org.openjdk.jmc.common.test.io.IOResourceSet;
 83 import org.openjdk.jmc.common.util.IPreferenceValueProvider;
 84 import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;
 85 import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;
 86 import org.openjdk.jmc.flightrecorder.rules.IRule;
 87 import org.openjdk.jmc.flightrecorder.rules.Result;
 88 import org.openjdk.jmc.flightrecorder.rules.RuleRegistry;
 89 import org.openjdk.jmc.flightrecorder.rules.Severity;
 90 import org.w3c.dom.Document;
 91 import org.w3c.dom.Element;
 92 import org.w3c.dom.Node;
 93 import org.w3c.dom.NodeList;
 94 import org.xml.sax.SAXException;
 95 
 96 /**
 97  * Class for testing jfr rule report consistency
 98  */
 99 @SuppressWarnings(&quot;nls&quot;)
100 public class TestRulesWithJfr {
101 	private static final String JFR_RULE_BASELINE_JFR = &quot;JfrRuleBaseline.xml&quot;;
102 	private static final String BASELINE_DIR = &quot;baseline&quot;;
103 	static final String RECORDINGS_DIR = &quot;jfr&quot;;
104 	static final String RECORDINGS_INDEXFILE = &quot;index.txt&quot;;
105 
106 	private TimeZone defaultTimeZone;
107 
108 	@Before
109 	public void before() {
110 		// empty the log before each test
111 		DetailsTracker.clear();
112 		// force UTC time zone during test
113 		defaultTimeZone = TimeZone.getDefault();
114 		TimeZone.setDefault(TimeZone.getTimeZone(&quot;UTC&quot;));
115 	}
116 
117 	@After
118 	public void after() {
119 		// restore previous default time zone
120 		TimeZone.setDefault(defaultTimeZone);
121 	}
122 
123 	@Test
124 	public void verifyOneResult() throws IOException {
125 		verifyRuleResults(true);
126 	}
127 
128 	@Category(value = {SlowTests.class})
129 	@Test
130 	public void verifyAllResults() throws IOException {
131 		verifyRuleResults(false);
132 	}
133 
134 	private void verifyRuleResults(boolean onlyOneRecording) throws IOException {
135 		IOResourceSet jfrs = TestToolkit.getResourcesInDirectory(TestRulesWithJfr.class, RECORDINGS_DIR,
136 				RECORDINGS_INDEXFILE);
137 		String reportName = null;
138 		if (onlyOneRecording) {
139 			IOResource firstJfr = jfrs.iterator().next();
140 			jfrs = new IOResourceSet(firstJfr);
141 			reportName = firstJfr.getName();
142 		}
143 		// Run all the .jfr files in the directory through the rule engine
144 		ReportCollection rulesReport = generateRulesReport(jfrs);
145 
146 		// Parse the baseline XML file
147 		ReportCollection baselineReport = parseRulesReportXml(BASELINE_DIR, JFR_RULE_BASELINE_JFR, reportName);
148 
149 		// Compare the baseline with the current rule results
150 		boolean resultsEqual = rulesReport.compareAndLog(baselineReport);
151 
152 		// Save file for later inspection and/or updating the baseline with
153 		if (!resultsEqual) {
154 			// Save the generated file to XML
155 			saveToFile(rulesReport.toXml(), BASELINE_DIR, JFR_RULE_BASELINE_JFR, onlyOneRecording);
156 		}
157 
158 		// Assert that the comparison returned true
159 		Assert.assertTrue(DetailsTracker.getEntries(), resultsEqual);
160 	}
161 
162 	private static void saveToFile(Document doc, String directory, String fileName, boolean onlyOneRecording) {
163 		String filePath = getResultDir().getAbsolutePath() + File.separator
164 				+ ((directory != null) ? (directory + File.separator) : &quot;&quot;)
165 				+ (onlyOneRecording ? &quot;Generated_One_&quot; : &quot;Generated_&quot;) + fileName;
166 		File resultFile = new File(filePath);
167 		prepareFile(resultFile);
168 		try (FileOutputStream resultFos = new FileOutputStream(resultFile)) {
169 			writeDomToStream(doc, resultFos);
170 		} catch (IOException e) {
171 			e.printStackTrace();
172 		}
173 	}
174 
175 	private static void prepareFile(File file) {
176 		if (file.exists()) {
177 			file.delete();
178 		}
179 		File parent = file.getParentFile();
180 		if (parent != null) {
181 			parent.mkdirs();
182 		}
183 		try {
184 			file.createNewFile();
185 		} catch (IOException e) {
186 			e.printStackTrace();
187 			Assert.fail(&quot;Error creating file \&quot;&quot; + file.getAbsolutePath() + &quot;\&quot;. Error:\n&quot; + e.getMessage());
188 		}
189 	}
190 
191 	private static void writeDomToStream(Document doc, OutputStream os) {
192 		try {
193 			TransformerFactory transformerFactory = TransformerFactory.newInstance();
194 			Transformer transformer = transformerFactory.newTransformer();
195 			transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);
196 			DOMSource source = new DOMSource(doc);
197 			StreamResult console = new StreamResult(os);
198 			transformer.transform(source, console);
199 		} catch (TransformerException e) {
200 			e.printStackTrace();
201 		}
202 	}
203 
204 	private static ReportCollection parseRulesReportXml(String directory, String fileName, String reportName) {
205 		ReportCollection collection = new ReportCollection();
206 		try {
207 			// FIXME: No need to go via temp file. Just get the input stream directly from the resource.
208 			File dir = TestToolkit.materialize(TestRulesWithJfr.class, directory, fileName);
209 			File file = new File(dir, fileName);
210 			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
211 			DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
212 			Document baselineDoc = docBuilder.parse(file);
213 			collection = ReportCollection.fromXml(baselineDoc, reportName);
214 		} catch (ParserConfigurationException | SAXException | IOException e) {
215 			e.printStackTrace();
216 		}
217 		return collection;
218 	}
219 
220 	private static ReportCollection generateRulesReport(IOResourceSet jfrs) {
221 		ReportCollection collection = new ReportCollection();
222 		for (IOResource jfr : jfrs) {
223 			Report report = generateReport(jfr, false, null);
224 			collection.put(report.getName(), report);
225 		}
226 		return collection;
227 	}
228 
229 	private static File getResultDir() {
230 		if (System.getProperty(&quot;results.dir&quot;) != null) {
231 			return new File(System.getProperty(&quot;results.dir&quot;));
232 		} else {
233 			return new File(System.getProperty(&quot;user.dir&quot;));
234 		}
235 	}
236 
237 	private static Report generateReport(IOResource jfr, boolean verbose, Severity minSeverity) {
238 		Report report = new Report(jfr.getName());
239 		try {
240 			IItemCollection events = JfrLoaderToolkit.loadEvents(jfr.open());
241 
242 			for (IRule rule : RuleRegistry.getRules()) {
243 				try {
244 					RunnableFuture&lt;Result&gt; future = rule.evaluate(events, IPreferenceValueProvider.DEFAULT_VALUES);
245 					future.run();
246 					Result result = future.get();
247 //					for (Result result : results) {
248 					if (minSeverity == null || Severity.get(result.getScore()).compareTo(minSeverity) &gt;= 0) {
249 						ItemSet itemSet = null;
250 						IItemQuery itemQuery = result.getItemQuery();
251 						if (verbose &amp;&amp; itemQuery != null &amp;&amp; !itemQuery.getAttributes().isEmpty()) {
252 							itemSet = new ItemSet();
253 							IItemCollection resultEvents = events.apply(itemQuery.getFilter());
254 							Collection&lt;? extends IAttribute&lt;?&gt;&gt; attributes = itemQuery.getAttributes();
255 							for (IAttribute&lt;?&gt; attribute : attributes) {
256 								itemSet.addField(attribute.getName());
257 							}
258 							Iterator&lt;? extends IItemIterable&gt; iterables = resultEvents.iterator();
259 							while (iterables.hasNext()) {
260 								IItemIterable ii = iterables.next();
261 								IType&lt;IItem&gt; type = ii.getType();
262 								List&lt;IMemberAccessor&lt;?, IItem&gt;&gt; accessors = new ArrayList&lt;&gt;(attributes.size());
263 								for (IAttribute&lt;?&gt; a : attributes) {
264 									accessors.add(a.getAccessor(type));
265 								}
266 								Iterator&lt;? extends IItem&gt; items = ii.iterator();
267 								while (items.hasNext()) {
268 									ItemList itemList = new ItemList();
269 									IItem item = items.next();
270 									for (IMemberAccessor&lt;?, IItem&gt; a : accessors) {
271 										itemList.add(String.valueOf(a.getMember(item)));
272 									}
273 									itemSet.addItem(itemList);
274 								}
275 							}
276 						}
277 						RuleResult ruleResult = new RuleResult(String.valueOf(result.getRule().getId()),
278 								Severity.get(result.getScore()).getLocalizedName(), String.valueOf(result.getScore()),
279 								result.getShortDescription(), result.getLongDescription(), itemSet);
280 						report.put(String.valueOf(result.getRule().getId()), ruleResult);
281 //						}
282 					}
283 				} catch (RuntimeException | InterruptedException | ExecutionException e) {
284 					System.out.println(&quot;Problem while evaluating rules for \&quot;&quot; + jfr.getName() + &quot;\&quot;. Message: &quot;
285 							+ e.getLocalizedMessage());
286 				}
287 			}
288 		} catch (IOException | CouldNotLoadRecordingException e) {
289 			e.printStackTrace();
290 		}
291 		return report;
292 	}
293 
294 	private static Element createValueNode(Document doc, String name, String value) {
295 		Element node = doc.createElement(name);
296 		node.appendChild(doc.createTextNode(value != null ? value : &quot;&quot;));
297 		return node;
298 	}
299 
300 	private static List&lt;String&gt; getNodeValues(String xpathExpr, Node node) {
301 		List&lt;String&gt; values = new ArrayList&lt;&gt;();
302 		try {
303 			XPath xpath = XPathFactory.newInstance().newXPath();
304 			XPathExpression expression = xpath.compile(xpathExpr);
305 			NodeList nodes = ((NodeList) expression.evaluate(node, XPathConstants.NODESET));
306 			for (int i = 0; i &lt; nodes.getLength(); i++) {
307 				Node thisNodeOnly = nodes.item(i);
308 				thisNodeOnly.getParentNode().removeChild(thisNodeOnly);
309 				Node child = thisNodeOnly.getFirstChild();
310 				if (child != null) {
311 					values.add(child.getNodeValue());
312 				} else {
313 					values.add(&quot;&quot;);
314 				}
315 			}
316 		} catch (XPathExpressionException e) {
317 			e.printStackTrace();
318 		}
319 		return values;
320 	}
321 
322 	private static NodeList getNodeSet(String expr, Node node) {
323 		NodeList result = null;
324 		try {
325 			XPath xpath = XPathFactory.newInstance().newXPath();
326 			XPathExpression xPath = xpath.compile(expr);
327 			result = (NodeList) xPath.evaluate(node, XPathConstants.NODESET);
328 		} catch (XPathExpressionException e) {
329 			e.printStackTrace();
330 		}
331 		return result;
332 	}
333 
334 	private static class ReportCollection {
335 		private SortedMap&lt;String, Report&gt; reports;
336 
337 		public ReportCollection() {
338 			reports = new TreeMap&lt;&gt;();
339 		}
340 
341 		public void put(String filename, Report report) {
342 			reports.put(filename, report);
343 		}
344 
345 		public Report get(String filename) {
346 			return reports.get(filename);
347 		}
348 
349 		public boolean compareAndLog(Object other) {
350 			ReportCollection otherReportCollection = (ReportCollection) other;
351 			boolean equals = reports.size() == otherReportCollection.reports.size();
352 			if (!equals) {
353 				if (reports.size() &gt; otherReportCollection.reports.size()) {
354 					for (String reportname : reports.keySet()) {
355 						if (otherReportCollection.get(reportname) == null) {
356 							DetailsTracker.log(&quot;Report for &quot; + reportname
357 									+ &quot; could not be found in the other report collection. &quot;);
358 						}
359 					}
360 				} else {
361 					for (String reportname : otherReportCollection.reports.keySet()) {
362 						if (reports.get(reportname) == null) {
363 							DetailsTracker.log(
364 									&quot;Report for &quot; + reportname + &quot; could not be found in this report collection. &quot;);
365 						}
366 					}
367 				}
368 				DetailsTracker.log(&quot;\n&quot;);
369 			}
370 			for (String reportname : reports.keySet()) {
371 				Report otherReport = otherReportCollection.get(reportname);
372 				if (otherReport != null) {
373 					equals = reports.get(reportname).compareAndLog(otherReport) &amp;&amp; equals;
374 				} else {
375 					DetailsTracker
376 							.log(&quot;\nReport for &quot; + reportname + &quot; could not be found in the other report collection. &quot;);
377 					equals = false;
378 				}
379 			}
380 			return equals;
381 		}
382 
383 		public Document toXml() {
384 			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
385 			DocumentBuilder docBuilder;
386 			Document doc = null;
387 			try {
388 				docBuilder = docFactory.newDocumentBuilder();
389 				doc = docBuilder.newDocument();
390 				Element rootElement = doc.createElement(&quot;reportcollection&quot;);
391 				doc.appendChild(rootElement);
392 				for (Report report : reports.values()) {
393 					report.toXml(rootElement);
394 				}
395 			} catch (ParserConfigurationException e) {
396 				e.printStackTrace();
397 			}
398 			return doc;
399 		}
400 
401 		public static ReportCollection fromXml(Document doc, String reportName) {
402 			ReportCollection collection = new ReportCollection();
403 			NodeList reports = getNodeSet(&quot;//report&quot;, doc);
404 			for (int i = 0; i &lt; reports.getLength(); i++) {
405 				Node thisReportOnly = reports.item(i);
406 				thisReportOnly.getParentNode().removeChild(thisReportOnly);
407 				Report report = Report.fromXml(thisReportOnly);
408 				if (reportName == null || report.getName().equals(reportName)) {
409 					collection.put(report.getName(), report);
410 				}
411 			}
412 			return collection;
413 		}
414 	}
415 
416 	private static class Report {
417 		private String filename;
418 		private SortedMap&lt;String, RuleResult&gt; rules;
419 
420 		public Report(String filename) {
421 			this.filename = filename;
422 			rules = new TreeMap&lt;&gt;();
423 		}
424 
425 		public void put(String id, RuleResult rule) {
426 			rules.put(id, rule);
427 		}
428 
429 		public RuleResult get(String id) {
430 			return rules.get(id);
431 		}
432 
433 		public String getName() {
434 			return filename;
435 		}
436 
437 		public boolean compareAndLog(Object other) {
438 			Report otherReport = (Report) other;
439 			boolean equals = rules.size() == otherReport.rules.size();
440 			boolean fileNamePrinted = false;
441 			if (equals) {
442 				for (String rulename : rules.keySet()) {
443 					RuleResult otherRule = otherReport.get(rulename);
444 					if (otherRule != null) {
445 						equals = rules.get(rulename).compareAndLog(otherRule) &amp;&amp; equals;
446 						if (!equals &amp;&amp; !fileNamePrinted) {
447 							DetailsTracker.log(&quot;\n\nReport: \&quot;&quot; + filename + &quot;\&quot;, &quot;);
448 							fileNamePrinted = true;
449 						}
450 					} else {
451 						DetailsTracker.log(&quot;\n\nReport: \&quot;&quot; + filename + &quot;\&quot;. Rule result for &quot; + rulename
452 								+ &quot; could not be found in the other report. &quot;);
453 						equals = false;
454 					}
455 				}
456 			} else {
457 				if (rules.size() &gt; otherReport.rules.size()) {
458 					for (String ruleId : rules.keySet()) {
459 						RuleResult otherRule = otherReport.get(ruleId);
460 						if (otherRule != null) {
461 							equals = rules.get(ruleId).compareAndLog(otherRule) &amp;&amp; equals;
462 						} else {
463 							DetailsTracker.log(&quot;\nReport for file \&quot;&quot; + filename + &quot;\&quot;, rule result for \&quot;&quot; + ruleId
464 									+ &quot;\&quot; could not be found in the other report. &quot;);
465 						}
466 					}
467 				} else {
468 					for (String ruleId : otherReport.rules.keySet()) {
469 						RuleResult rule = rules.get(ruleId);
470 						if (rule != null) {
471 							equals = rule.compareAndLog(otherReport.rules.get(ruleId)) &amp;&amp; equals;
472 						} else {
473 							DetailsTracker.log(&quot;\nReport for file \&quot;&quot; + filename + &quot;\&quot;, rule result for \&quot;&quot; + ruleId
474 									+ &quot;\&quot; could not be found in this report. &quot;);
475 						}
476 					}
477 				}
478 				DetailsTracker.log(&quot;\n&quot;);
479 			}
480 			return equals;
481 		}
482 
483 		public void toXml(Element parent) {
484 			Element reportNode = parent.getOwnerDocument().createElement(&quot;report&quot;);
485 			parent.appendChild(reportNode);
486 			reportNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;file&quot;, filename));
487 			for (RuleResult rule : rules.values()) {
488 				rule.toXml(reportNode);
489 			}
490 		}
491 
492 		public static Report fromXml(Node node) {
493 			Report report = new Report(getNodeValues(&quot;./file&quot;, node).get(0));
494 			NodeList rules = getNodeSet(&quot;./rule&quot;, node);
495 			for (int i = 0; i &lt; rules.getLength(); i++) {
496 				Node thisRuleOnly = rules.item(i);
497 				thisRuleOnly.getParentNode().removeChild(thisRuleOnly);
498 				RuleResult rule = RuleResult.fromXml(thisRuleOnly);
499 				report.put(rule.getId(), rule);
500 			}
501 			return report;
502 		}
503 	}
504 
505 	private static class RuleResult {
506 		private String id;
507 		private String severity;
508 		private String score;
509 		private String shortDescription;
510 		private String longDescription;
511 		private ItemSet itemset;
512 
513 		public RuleResult(String id, String severity, String score, String shortDescription, String longDescription,
514 				ItemSet itemset) {
515 			this.id = id;
516 			this.severity = severity;
517 			this.score = score;
518 			this.shortDescription = shortDescription;
519 			this.longDescription = longDescription;
520 			this.itemset = itemset;
521 		}
522 
523 		public String getId() {
524 			return id;
525 		}
526 
527 		public boolean compareAndLog(Object other) {
528 			RuleResult otherRule = (RuleResult) other;
529 			boolean scoreEquals = Objects.equals(score, otherRule.score);
530 			if (!scoreEquals) {
531 				// determine if this is just a rounding error
532 				scoreEquals = (Math.abs(Float.valueOf(score) - Float.valueOf(otherRule.score)) &lt; 0.0000000000001f)
533 						? true : false;
534 				if (scoreEquals) {
535 					// apparently a rounding issue. Print it out for informational purposes
536 					System.out
537 							.println(&quot;Rule \&quot;&quot; + id + &quot;\&quot;: Encountered rounding issue for score when comparing values &quot;
538 									+ score + &quot; and &quot; + otherRule.score);
539 				}
540 			}
541 			boolean itemSetEquality = compareAndLogItemSets(other);
542 			boolean ruleEquality = Objects.equals(severity, otherRule.severity) &amp;&amp; scoreEquals
543 					&amp;&amp; Objects.equals(shortDescription, otherRule.shortDescription)
544 					&amp;&amp; Objects.equals(longDescription, otherRule.longDescription);
545 			if (!ruleEquality) {
546 				if (!Objects.equals(severity, otherRule.severity)) {
547 					DetailsTracker.log(&quot;\n    Severity mismatch: \&quot;&quot; + severity + &quot;\&quot; was not equal to \&quot;&quot;
548 							+ otherRule.severity + &quot;\&quot;. &quot;);
549 				}
550 				if (!scoreEquals) {
551 					DetailsTracker.log(
552 							&quot;\n    Score mismatch: \&quot;&quot; + score + &quot;\&quot; was not equal to \&quot;&quot; + otherRule.score + &quot;\&quot;. &quot;);
553 				}
554 				if (!Objects.equals(shortDescription, otherRule.shortDescription)) {
555 					DetailsTracker.log(&quot;\n    Message mismatch: \&quot;&quot; + shortDescription + &quot;\&quot; was not equal to \&quot;&quot;
556 							+ otherRule.shortDescription + &quot;\&quot;. &quot;);
557 				}
558 				if (!Objects.equals(longDescription, otherRule.longDescription)) {
559 					DetailsTracker.log(&quot;\n    Description mismatch: \&quot;&quot; + longDescription + &quot;\&quot; was not equal to \&quot;&quot;
560 							+ otherRule.longDescription + &quot;\&quot;. &quot;);
561 				}
562 			}
563 			if (!(itemSetEquality &amp;&amp; ruleEquality)) {
564 				DetailsTracker.log(&quot;\n  Rule: \&quot;&quot; + id + &quot;\&quot;. &quot;);
565 			}
566 			return itemSetEquality &amp;&amp; ruleEquality;
567 		}
568 
569 		private boolean compareAndLogItemSets(Object other) {
570 			RuleResult otherRule = (RuleResult) other;
571 			if (itemset != null &amp;&amp; otherRule.itemset != null) {
572 				// both rules have items, compare these
573 				return itemset.compareAndLog(otherRule.itemset);
574 			} else if (itemset == null &amp;&amp; otherRule.itemset == null) {
575 				// no items in any of the rules (both null)
576 				return true;
577 			} else {
578 				if (itemset == null) {
579 					DetailsTracker.log(&quot;\n    This item set was null while the other wasn&#39;t. The other: &quot;
580 							+ otherRule.itemset + &quot;. &quot;);
581 				} else {
582 					DetailsTracker.log(&quot;\n    The other item set was null while this wasn&#39;t. This: &quot; + itemset + &quot;. &quot;);
583 				}
584 				return false;
585 			}
586 		}
587 
588 		public void toXml(Element parent) {
589 			Element ruleNode = parent.getOwnerDocument().createElement(&quot;rule&quot;);
590 			parent.appendChild(ruleNode);
591 			ruleNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;id&quot;, id));
592 			ruleNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;severity&quot;, severity));
593 			ruleNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;score&quot;, score));
594 			ruleNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;shortDescription&quot;, shortDescription));
595 			if (longDescription != null) {
596 				ruleNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;longDescription&quot;, longDescription));
597 			}
598 			if (itemset != null) {
599 				itemset.toXml(ruleNode);
600 			}
601 		}
602 
603 		public static RuleResult fromXml(Node node) {
604 			RuleResult rule = null;
605 			List&lt;String&gt; longDescriptions = getNodeValues(&quot;./longDescription&quot;, node);
606 			String longDescription = null;
607 			if (longDescriptions != null &amp;&amp; longDescriptions.size() == 1) {
608 				longDescription = longDescriptions.get(0);
609 			}
610 			NodeList items = getNodeSet(&quot;./itemset&quot;, node);
611 			ItemSet itemset = null;
612 			if (items != null &amp;&amp; items.getLength() == 1) {
613 				itemset = ItemSet.fromXml(items.item(0));
614 			}
615 			rule = new RuleResult(getNodeValues(&quot;./id&quot;, node).get(0), getNodeValues(&quot;./severity&quot;, node).get(0),
616 					getNodeValues(&quot;./score&quot;, node).get(0), getNodeValues(&quot;./shortDescription&quot;, node).get(0),
617 					longDescription, itemset);
618 			return rule;
619 		}
620 	}
621 
622 	private static class ItemSet {
623 		private List&lt;String&gt; fields;
624 		private List&lt;ItemList&gt; items;
625 
626 		public ItemSet() {
627 			fields = new ArrayList&lt;&gt;();
628 			items = new ArrayList&lt;&gt;();
629 		}
630 
631 		private ItemSet(List&lt;String&gt; fields, List&lt;ItemList&gt; items) {
632 			this.fields = fields;
633 			this.items = items;
634 		}
635 
636 		public void addField(String field) {
637 			fields.add(field);
638 		}
639 
640 		public void addItem(ItemList itemList) {
641 			items.add(itemList);
642 		}
643 
644 		@Override
645 		public String toString() {
646 			return &quot;Fields: &quot; + fields + &quot;\n      Items: &quot; + items;
647 		}
648 
649 		public boolean compareAndLog(Object other) {
650 			ItemSet otherItemSet = (ItemSet) other;
651 			boolean fieldEquality = fields.equals(otherItemSet.fields);
652 			if (!fieldEquality) {
653 				DetailsTracker.log(&quot;Item fields differ: &quot; + fields + &quot; was not equal to &quot; + otherItemSet.fields + &quot;. &quot;);
654 			}
655 			boolean itemEquality = items.equals(otherItemSet.items);
656 			return itemEquality &amp;&amp; fieldEquality;
657 		}
658 
659 		public void toXml(Element parent) {
660 			Element itemSetNode = parent.getOwnerDocument().createElement(&quot;itemset&quot;);
661 			parent.appendChild(itemSetNode);
662 			Element fieldsNode = parent.getOwnerDocument().createElement(&quot;fields&quot;);
663 			itemSetNode.appendChild(fieldsNode);
664 			for (String field : fields) {
665 				Element fieldNode = parent.getOwnerDocument().createElement(&quot;field&quot;);
666 				fieldsNode.appendChild(fieldNode);
667 				fieldNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;name&quot;, field));
668 			}
669 			Element itemsNode = parent.getOwnerDocument().createElement(&quot;items&quot;);
670 			itemSetNode.appendChild(itemsNode);
671 			for (ItemList list : items) {
672 				list.toXml(itemsNode);
673 			}
674 		}
675 
676 		public static ItemSet fromXml(Node node) {
677 			ItemSet set = null;
678 			List&lt;ItemList&gt; itemList = new ArrayList&lt;&gt;();
679 			NodeList items = getNodeSet(&quot;./items/item&quot;, node);
680 			for (int i = 0; i &lt; items.getLength(); i++) {
681 				Node thisItemOnly = items.item(i);
682 				thisItemOnly.getParentNode().removeChild(thisItemOnly);
683 				itemList.add(ItemList.fromXml(thisItemOnly));
684 			}
685 			List&lt;String&gt; fields = getNodeValues(&quot;./fields/field/name&quot;, node);
686 			set = new ItemSet(fields, itemList);
687 			return set;
688 		}
689 
690 	}
691 
692 	private static class ItemList {
693 		private List&lt;String&gt; items;
694 
695 		public ItemList() {
696 			items = new ArrayList&lt;&gt;();
697 		}
698 
699 		private ItemList(List&lt;String&gt; list) {
700 			items = list;
701 		}
702 
703 		public void add(String item) {
704 			items.add(item);
705 		}
706 
707 		@Override
708 		public String toString() {
709 			return items.toString();
710 		}
711 
712 		@Override
713 		public boolean equals(Object other) {
714 			ItemList otherItemList = (ItemList) other;
715 			boolean equals = items.equals(otherItemList.items);
716 			if (!equals) {
717 				DetailsTracker.log(&quot;Item lists differ: &quot; + items + &quot; was not equal to &quot; + otherItemList.items + &quot;. &quot;);
718 			}
719 			return equals;
720 		}
721 
722 		public void toXml(Element parent) {
723 			Element itemNode = parent.getOwnerDocument().createElement(&quot;item&quot;);
724 			parent.appendChild(itemNode);
725 			for (String item : items) {
726 				itemNode.appendChild(createValueNode(parent.getOwnerDocument(), &quot;value&quot;, item));
727 			}
728 		}
729 
730 		public static ItemList fromXml(Node node) {
731 			return new ItemList(getNodeValues(&quot;./value&quot;, node));
732 		}
733 	}
734 
735 	// FIXME: This class is not thread safe. Make non-static!
736 	private static class DetailsTracker {
737 		private static Deque&lt;String&gt; entries = new ArrayDeque&lt;&gt;();
738 
739 		private DetailsTracker() {
740 		}
741 
742 		public static void log(String entry) {
743 			entries.addFirst(entry);
744 		}
745 
746 		public static String getEntries() {
747 			StringBuilder sb = new StringBuilder();
748 			for (String entry : entries) {
749 				sb.append(entry);
750 			}
751 			return sb.toString();
752 		}
753 
754 		public static void clear() {
755 			entries.clear();
756 		}
757 	}
758 
759 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
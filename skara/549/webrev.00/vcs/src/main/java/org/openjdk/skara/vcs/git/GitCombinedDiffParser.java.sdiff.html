<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff vcs/src/main/java/org/openjdk/skara/vcs/git/GitCombinedDiffParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>vcs/src/main/java/org/openjdk/skara/vcs/git/GitCombinedDiffParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.util.*;
 31 
 32 class GitCombinedDiffParser {
 33     private final List&lt;Hash&gt; bases;
 34     private final int numParents;
 35     private final Hash head;
 36     private final String delimiter;
 37     private String line = null;
 38 
 39     public GitCombinedDiffParser(List&lt;Hash&gt; bases, Hash head, String delimiter) {
 40         this.bases = bases;
 41         this.numParents = bases.size();
 42         this.head = head;
 43         this.delimiter = delimiter;
 44     }
 45 
 46     private List&lt;List&lt;Hunk&gt;&gt; parseSingleFileMultiParentDiff(UnixStreamReader reader, List&lt;PatchHeader&gt; headers) throws IOException {
<span class="line-modified"> 47         assert line.startsWith(&quot;diff --combined&quot;);</span>
























 48 
 49         while ((line = reader.readLine()) != null &amp;&amp;
 50                 !line.startsWith(&quot;@@@&quot;) &amp;&amp;
 51                 !line.startsWith(&quot;diff --combined&quot;) &amp;&amp;
 52                 !line.equals(delimiter)) {
 53             // Skip all diff header lines (we already have them via the raw headers)
 54             // Note: this will also skip &#39;Binary files differ...&#39; on purpose
 55         }
 56 
 57         var hunksPerParent = new ArrayList&lt;List&lt;Hunk&gt;&gt;(numParents);
 58         for (int i = 0; i &lt; numParents; i++) {
 59             hunksPerParent.add(new ArrayList&lt;Hunk&gt;());
 60         }
 61 
 62         while (line != null &amp;&amp; line.startsWith(&quot;@@@&quot;)) {
 63             var words = line.split(&quot;\\s&quot;);
<span class="line-modified"> 64             assert words[0].startsWith(&quot;@@@&quot;);</span>


 65             var sourceRangesPerParent = new ArrayList&lt;Range&gt;(numParents);
 66             for (int i = 1; i &lt;= numParents; i++) {
 67                 var header = headers.get(i - 1);
 68                 if (header.status().isAdded()) {
 69                     // git reports wrong start for added files, they should
 70                     // always have range (0,0), but git reports (1,0)
 71                     sourceRangesPerParent.add(new Range(0, 0));
 72                 } else {
 73                     sourceRangesPerParent.add(GitRange.fromCombinedString(words[i].substring(1))); // skip initial &#39;-&#39;
 74                 }
 75             }
 76             var targetRange = GitRange.fromCombinedString(words[numParents + 1].substring(1)); // skip initial &#39;+&#39;
 77 
 78             var linesPerParent = new ArrayList&lt;List&lt;String&gt;&gt;(numParents);
 79             for (int i = 0; i &lt; numParents; i++) {
 80                 linesPerParent.add(new ArrayList&lt;String&gt;());
 81             }
 82 
 83             while ((line = reader.readLine()) != null &amp;&amp;
 84                    !line.startsWith(&quot;@@@&quot;) &amp;&amp;
</pre>
<hr />
<pre>
134         var dstType = FileType.fromOctal(words[index]);
135         index++;
136 
137         end = index + numParents;
138         var srcHashes = new ArrayList&lt;Hash&gt;(numParents);
139         while (index &lt; end) {
140             srcHashes.add(new Hash(words[index]));
141             index++;
142         }
143         var dstHash = new Hash(words[index]);
144         index++;
145 
146         var statuses = new ArrayList&lt;Status&gt;(numParents);
147         var statusWord = words[index];
148         for (int i = 0; i &lt; statusWord.length(); i++) {
149             statuses.add(Status.from(statusWord.charAt(i)));
150         }
151 
152         index++;
153         var dstPath = Path.of(words[index]);
<span class="line-modified">154         assert words.length == (index + 1);</span>


155 
156         for (int i = 0; i &lt; numParents; i++) {
157             var status = statuses.get(i);
158             var srcType = srcTypes.get(i);
159             var srcPath = status.isModified() ?  dstPath : null;
160             var srcHash = srcHashes.get(i);
161             headers.add(new PatchHeader(srcPath, srcType, srcHash,  dstPath, dstType, dstHash, status));
162         }
163 
164         return headers;
165     }
166 
167     public List&lt;Diff&gt; parse(UnixStreamReader reader) throws IOException {
168         line = reader.readLine();
169 
170         if (line == null || line.equals(delimiter)) {
171             // Not all merge commits contains non-trivial changes
172             var diffsPerParent = new ArrayList&lt;Diff&gt;(numParents);
173             for (int i = 0; i &lt; numParents; i++) {
174                 diffsPerParent.add(new Diff(bases.get(i), head, new ArrayList&lt;Patch&gt;()));
175             }
176             return diffsPerParent;
177         }
178 
179         var headersPerParent = new ArrayList&lt;List&lt;PatchHeader&gt;&gt;(numParents);
180         for (int i = 0; i &lt; numParents; i++) {
181             headersPerParent.add(new ArrayList&lt;PatchHeader&gt;());
182         }
183 
184         var headersForFiles = new ArrayList&lt;List&lt;PatchHeader&gt;&gt;();
185         while (line != null &amp;&amp; line.startsWith(&quot;::&quot;)) {
186             var headersForFile = parseCombinedRawLine(line);
187             headersForFiles.add(headersForFile);
<span class="line-modified">188             assert headersForFile.size() == numParents;</span>




189 
190             for (int i = 0; i &lt; numParents; i++) {
191                 headersPerParent.get(i).add(headersForFile.get(i));
192             }
193 
194             line = reader.readLine();
195         }
196 
197         // skip empty newline added by git
<span class="line-modified">198         assert line.equals(&quot;&quot;);</span>


199         line = reader.readLine();
200 
201         var hunksPerFilePerParent = new ArrayList&lt;List&lt;List&lt;Hunk&gt;&gt;&gt;(numParents);
202         for (int i = 0; i &lt; numParents; i++) {
203             hunksPerFilePerParent.add(new ArrayList&lt;List&lt;Hunk&gt;&gt;());
204         }
205 
206         int headerIndex = 0;
207         while (line != null &amp;&amp; !line.equals(delimiter)) {
208             var headersForFile = headersForFiles.get(headerIndex);

209             var hunksPerParentForFile = parseSingleFileMultiParentDiff(reader, headersForFile);
<span class="line-modified">210             assert hunksPerParentForFile.size() == numParents;</span>





211 
212             for (int i = 0; i &lt; numParents; i++) {
213                 hunksPerFilePerParent.get(i).add(hunksPerParentForFile.get(i));
214             }
215 
216             headerIndex++;
217         }
218 
219         var patchesPerParent = new ArrayList&lt;List&lt;Patch&gt;&gt;(numParents);
220         for (int i = 0; i &lt; numParents; i++) {
221             var headers = headersPerParent.get(i);
222             var hunks = hunksPerFilePerParent.get(i);




223             var patches = new ArrayList&lt;Patch&gt;();
224             for (int j = 0; j &lt; headers.size(); j++) {
225                 var h = headers.get(j);

226                 patches.add(new TextualPatch(h.sourcePath(), h.sourceFileType(), h.sourceHash(),
227                                              h.targetPath(), h.targetFileType(), h.targetHash(),
<span class="line-modified">228                                              h.status(), hunks.get(j)));</span>
229             }
230             patchesPerParent.add(patches);
231         }
232 
233         var diffs = new ArrayList&lt;Diff&gt;(numParents);
234         for (int i = 0; i &lt; numParents; i++) {
235             diffs.add(new Diff(bases.get(i), head, patchesPerParent.get(i)));
236         }
237         return diffs;
238     }
239 }
</pre>
</td>
<td>
<hr />
<pre>
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.util.*;
 31 
 32 class GitCombinedDiffParser {
 33     private final List&lt;Hash&gt; bases;
 34     private final int numParents;
 35     private final Hash head;
 36     private final String delimiter;
 37     private String line = null;
 38 
 39     public GitCombinedDiffParser(List&lt;Hash&gt; bases, Hash head, String delimiter) {
 40         this.bases = bases;
 41         this.numParents = bases.size();
 42         this.head = head;
 43         this.delimiter = delimiter;
 44     }
 45 
 46     private List&lt;List&lt;Hunk&gt;&gt; parseSingleFileMultiParentDiff(UnixStreamReader reader, List&lt;PatchHeader&gt; headers) throws IOException {
<span class="line-modified"> 47         if (!line.startsWith(&quot;diff --combined&quot;)) {</span>
<span class="line-added"> 48             throw new IllegalStateException(&quot;Expected line to start with &#39;diff --line combined&#39;, got: &quot; + line);</span>
<span class="line-added"> 49         }</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51         var filename = line.substring(&quot;diff --combined &quot;.length());</span>
<span class="line-added"> 52         var isRenamedWithRegardsToAllParents = headers.stream().allMatch(h -&gt; h.status().isRenamed());</span>
<span class="line-added"> 53         if (isRenamedWithRegardsToAllParents) {</span>
<span class="line-added"> 54             // git diff -c does not give a &quot;diff --combined&quot; line, nor hunks, for a rename without modifications</span>
<span class="line-added"> 55             if (headers.stream().noneMatch(h -&gt; filename.equals(h.targetPath().toString()))) {</span>
<span class="line-added"> 56                 // This diff is for another file, this must have been a rename without modifications</span>
<span class="line-added"> 57                 var result = new ArrayList&lt;List&lt;Hunk&gt;&gt;();</span>
<span class="line-added"> 58                 for (int i = 0; i &lt; numParents; i++) {</span>
<span class="line-added"> 59                     result.add(List.of());</span>
<span class="line-added"> 60                 }</span>
<span class="line-added"> 61                 return result;</span>
<span class="line-added"> 62             }</span>
<span class="line-added"> 63         }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65         for (var header : headers) {</span>
<span class="line-added"> 66             var targetPath = header.targetPath();</span>
<span class="line-added"> 67             if (targetPath != null &amp;&amp; !targetPath.toString().equals(filename)) {</span>
<span class="line-added"> 68                 throw new IllegalStateException(&quot;Got header for file &quot; + targetPath.toString() +</span>
<span class="line-added"> 69                                                 &quot; but hunks for file &quot; + filename);</span>
<span class="line-added"> 70             }</span>
<span class="line-added"> 71         }</span>
 72 
 73         while ((line = reader.readLine()) != null &amp;&amp;
 74                 !line.startsWith(&quot;@@@&quot;) &amp;&amp;
 75                 !line.startsWith(&quot;diff --combined&quot;) &amp;&amp;
 76                 !line.equals(delimiter)) {
 77             // Skip all diff header lines (we already have them via the raw headers)
 78             // Note: this will also skip &#39;Binary files differ...&#39; on purpose
 79         }
 80 
 81         var hunksPerParent = new ArrayList&lt;List&lt;Hunk&gt;&gt;(numParents);
 82         for (int i = 0; i &lt; numParents; i++) {
 83             hunksPerParent.add(new ArrayList&lt;Hunk&gt;());
 84         }
 85 
 86         while (line != null &amp;&amp; line.startsWith(&quot;@@@&quot;)) {
 87             var words = line.split(&quot;\\s&quot;);
<span class="line-modified"> 88             if (!words[0].startsWith(&quot;@@@&quot;)) {</span>
<span class="line-added"> 89                 throw new IllegalStateException(&quot;Expected word to starts with &#39;@@@&#39;, got: &quot; + words[0]);</span>
<span class="line-added"> 90             }</span>
 91             var sourceRangesPerParent = new ArrayList&lt;Range&gt;(numParents);
 92             for (int i = 1; i &lt;= numParents; i++) {
 93                 var header = headers.get(i - 1);
 94                 if (header.status().isAdded()) {
 95                     // git reports wrong start for added files, they should
 96                     // always have range (0,0), but git reports (1,0)
 97                     sourceRangesPerParent.add(new Range(0, 0));
 98                 } else {
 99                     sourceRangesPerParent.add(GitRange.fromCombinedString(words[i].substring(1))); // skip initial &#39;-&#39;
100                 }
101             }
102             var targetRange = GitRange.fromCombinedString(words[numParents + 1].substring(1)); // skip initial &#39;+&#39;
103 
104             var linesPerParent = new ArrayList&lt;List&lt;String&gt;&gt;(numParents);
105             for (int i = 0; i &lt; numParents; i++) {
106                 linesPerParent.add(new ArrayList&lt;String&gt;());
107             }
108 
109             while ((line = reader.readLine()) != null &amp;&amp;
110                    !line.startsWith(&quot;@@@&quot;) &amp;&amp;
</pre>
<hr />
<pre>
160         var dstType = FileType.fromOctal(words[index]);
161         index++;
162 
163         end = index + numParents;
164         var srcHashes = new ArrayList&lt;Hash&gt;(numParents);
165         while (index &lt; end) {
166             srcHashes.add(new Hash(words[index]));
167             index++;
168         }
169         var dstHash = new Hash(words[index]);
170         index++;
171 
172         var statuses = new ArrayList&lt;Status&gt;(numParents);
173         var statusWord = words[index];
174         for (int i = 0; i &lt; statusWord.length(); i++) {
175             statuses.add(Status.from(statusWord.charAt(i)));
176         }
177 
178         index++;
179         var dstPath = Path.of(words[index]);
<span class="line-modified">180         if (words.length != (index + 1)) {</span>
<span class="line-added">181             throw new IllegalStateException(&quot;Unexpected characters at end of raw line: &quot; + line);</span>
<span class="line-added">182         }</span>
183 
184         for (int i = 0; i &lt; numParents; i++) {
185             var status = statuses.get(i);
186             var srcType = srcTypes.get(i);
187             var srcPath = status.isModified() ?  dstPath : null;
188             var srcHash = srcHashes.get(i);
189             headers.add(new PatchHeader(srcPath, srcType, srcHash,  dstPath, dstType, dstHash, status));
190         }
191 
192         return headers;
193     }
194 
195     public List&lt;Diff&gt; parse(UnixStreamReader reader) throws IOException {
196         line = reader.readLine();
197 
198         if (line == null || line.equals(delimiter)) {
199             // Not all merge commits contains non-trivial changes
200             var diffsPerParent = new ArrayList&lt;Diff&gt;(numParents);
201             for (int i = 0; i &lt; numParents; i++) {
202                 diffsPerParent.add(new Diff(bases.get(i), head, new ArrayList&lt;Patch&gt;()));
203             }
204             return diffsPerParent;
205         }
206 
207         var headersPerParent = new ArrayList&lt;List&lt;PatchHeader&gt;&gt;(numParents);
208         for (int i = 0; i &lt; numParents; i++) {
209             headersPerParent.add(new ArrayList&lt;PatchHeader&gt;());
210         }
211 
212         var headersForFiles = new ArrayList&lt;List&lt;PatchHeader&gt;&gt;();
213         while (line != null &amp;&amp; line.startsWith(&quot;::&quot;)) {
214             var headersForFile = parseCombinedRawLine(line);
215             headersForFiles.add(headersForFile);
<span class="line-modified">216             if (headersForFile.size() != numParents) {</span>
<span class="line-added">217                 throw new IllegalStateException(&quot;Expected one raw diff line per parent, have &quot; +</span>
<span class="line-added">218                                                 numParents + &quot; parents and got &quot; + headersForFile.size() +</span>
<span class="line-added">219                                                 &quot; raw diff lines&quot;);</span>
<span class="line-added">220             }</span>
221 
222             for (int i = 0; i &lt; numParents; i++) {
223                 headersPerParent.get(i).add(headersForFile.get(i));
224             }
225 
226             line = reader.readLine();
227         }
228 
229         // skip empty newline added by git
<span class="line-modified">230         if (!line.equals(&quot;&quot;)) {</span>
<span class="line-added">231             throw new IllegalStateException(&quot;Expected empty line, got: &quot; + line);</span>
<span class="line-added">232         }</span>
233         line = reader.readLine();
234 
235         var hunksPerFilePerParent = new ArrayList&lt;List&lt;List&lt;Hunk&gt;&gt;&gt;(numParents);
236         for (int i = 0; i &lt; numParents; i++) {
237             hunksPerFilePerParent.add(new ArrayList&lt;List&lt;Hunk&gt;&gt;());
238         }
239 
240         int headerIndex = 0;
241         while (line != null &amp;&amp; !line.equals(delimiter)) {
242             var headersForFile = headersForFiles.get(headerIndex);
<span class="line-added">243             var isRenamedWithRegardsToAllParents = headersForFile.stream().allMatch(h -&gt; h.status().isRenamed());</span>
244             var hunksPerParentForFile = parseSingleFileMultiParentDiff(reader, headersForFile);
<span class="line-modified">245 </span>
<span class="line-added">246             if (hunksPerParentForFile.size() != numParents) {</span>
<span class="line-added">247                 throw new IllegalStateException(&quot;Expected at least one hunk per parent, have &quot; +</span>
<span class="line-added">248                                                 numParents + &quot; parents and got &quot; + hunksPerParentForFile.size() +</span>
<span class="line-added">249                                                 &quot; hunk lists&quot;);</span>
<span class="line-added">250             }</span>
251 
252             for (int i = 0; i &lt; numParents; i++) {
253                 hunksPerFilePerParent.get(i).add(hunksPerParentForFile.get(i));
254             }
255 
256             headerIndex++;
257         }
258 
259         var patchesPerParent = new ArrayList&lt;List&lt;Patch&gt;&gt;(numParents);
260         for (int i = 0; i &lt; numParents; i++) {
261             var headers = headersPerParent.get(i);
262             var hunks = hunksPerFilePerParent.get(i);
<span class="line-added">263             if (headers.size() != hunks.size()) {</span>
<span class="line-added">264                 throw new IllegalStateException(&quot;Header lists and hunk lists differ: &quot; + headers.size() +</span>
<span class="line-added">265                                                 &quot; headers vs &quot; + hunks.size() + &quot; hunks&quot;);</span>
<span class="line-added">266             }</span>
267             var patches = new ArrayList&lt;Patch&gt;();
268             for (int j = 0; j &lt; headers.size(); j++) {
269                 var h = headers.get(j);
<span class="line-added">270                 var hunksForParentPatch = hunks.get(j);</span>
271                 patches.add(new TextualPatch(h.sourcePath(), h.sourceFileType(), h.sourceHash(),
272                                              h.targetPath(), h.targetFileType(), h.targetHash(),
<span class="line-modified">273                                              h.status(), hunksForParentPatch));</span>
274             }
275             patchesPerParent.add(patches);
276         }
277 
278         var diffs = new ArrayList&lt;Diff&gt;(numParents);
279         for (int i = 0; i &lt; numParents; i++) {
280             diffs.add(new Diff(bases.get(i), head, patchesPerParent.get(i)));
281         }
282         return diffs;
283     }
284 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
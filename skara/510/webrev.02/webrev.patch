diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
@@ -161,23 +161,27 @@
             Set.of("customfield_10008", "customfield_10000", "customfield_10005");
 
     /**
      * Create a backport of issue.
      */
-    private Issue createBackportIssue(Issue primary) {
+    private Issue createBackportIssue(Issue primary) throws NonRetriableException {
         var filteredProperties = primary.properties().entrySet().stream()
                 .filter(entry -> !entry.getKey().startsWith("customfield_") || propagatedCustomProperties.contains(entry.getKey()))
                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
 
         var finalProperties = new HashMap<>(filteredProperties);
         finalProperties.put("issuetype", JSON.of("Backport"));
 
-        var backport = primary.project().createIssue(primary.title(), primary.body().lines().collect(Collectors.toList()), finalProperties);
+        try {
+            var backport = primary.project().createIssue(primary.title(), primary.body().lines().collect(Collectors.toList()), finalProperties);
 
-        var backportLink = Link.create(backport, "backported by").build();
-        primary.addLink(backportLink);;
-        return backport;
+            var backportLink = Link.create(backport, "backported by").build();
+            primary.addLink(backportLink);
+            return backport;
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
     }
 
     /**
      * Return issue or one of its backports that applies to fixVersion.
      *
@@ -190,11 +194,11 @@
      *
      * Otherwise, create a new Backport.
      *
      * A "scratch" fixVersion is empty, "tbd.*", or "unknown".
      */
-    private Issue findIssue(Issue primary, String fixVersion) {
+    private Issue findIssue(Issue primary, String fixVersion) throws NonRetriableException {
         log.info("Searching for properly versioned issue for primary issue " + primary.id());
         var candidates = Stream.concat(Stream.of(primary), findBackports(primary).stream()).collect(Collectors.toList());
         candidates.forEach(c -> log.fine("Candidate: " + c.id() + " with versions: " + String.join(",", fixVersions(c))));
         var matchingVersionIssue = candidates.stream()
                 .filter(i -> matchVersion(i, fixVersion))
@@ -237,11 +241,11 @@
         }
         return Optional.of(committerEmail.localPart());
     }
 
     @Override
-    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) {
+    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
         for (var commit : commits) {
             var commitNotification = CommitFormatters.toTextBrief(repository, commit);
             var commitMessage = CommitMessageParsers.v1.parse(commit);
             for (var commitIssue : commitMessage.issues()) {
                 var optionalIssue = issueProject.issue(commitIssue.id());
@@ -349,15 +353,10 @@
     @Override
     public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
 
     }
 
-    @Override
-    public boolean isIdempotent() {
-        return true;
-    }
-
     @Override
     public String name() {
         return "issue";
     }
 
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
@@ -74,30 +74,34 @@
 
         return ret;
     }
 
     @Override
-    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) {
+    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
         try (var writer = new JsonUpdateWriter(path, repository.name())) {
             for (var commit : commits) {
                 var json = commitToChanges(repository, localRepository, commit, defaultBuild);
                 writer.write(json);
             }
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
         }
     }
 
     @Override
-    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) {
+    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
         var build = String.format("b%02d", tag.buildNum());
         try (var writer = new JsonUpdateWriter(path, repository.name())) {
             var issues = new ArrayList<Issue>();
             for (var commit : commits) {
                 var parsedMessage = CommitMessageParsers.v1.parse(commit);
                 issues.addAll(parsedMessage.issues());
             }
             var json = issuesToChanges(repository, localRepository, issues, build);
             writer.write(json);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
         }
     }
 
     @Override
     public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) {
@@ -105,15 +109,10 @@
 
     @Override
     public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
     }
 
-    @Override
-    public boolean isIdempotent() {
-        return false;
-    }
-
     @Override
     public String name() {
         return "json";
     }
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
@@ -163,11 +163,11 @@
             ret.append("] ");
         }
         return ret.toString();
     }
 
-    private List<Commit> filterAndSendPrCommits(HostedRepository repository, List<Commit> commits, Branch branch) {
+    private List<Commit> filterAndSendPrCommits(HostedRepository repository, List<Commit> commits, Branch branch) throws NonRetriableException {
         var ret = new ArrayList<Commit>();
 
         var rfrsConvos = list.conversations(Duration.ofDays(365)).stream()
                        .filter(conv -> conv.first().subject().contains("RFR: "))
                        .collect(Collectors.toList());
@@ -208,17 +208,22 @@
                              .sender(sender)
                              .author(commitToAuthor(commit))
                              .recipient(recipient)
                              .headers(headers)
                              .build();
-            list.post(email);
+
+            try {
+                list.post(email);
+            } catch (RuntimeException e) {
+                throw new NonRetriableException(e);
+            }
         }
 
         return ret;
     }
 
-    private void sendCombinedCommits(HostedRepository repository, List<Commit> commits, Branch branch) {
+    private void sendCombinedCommits(HostedRepository repository, List<Commit> commits, Branch branch) throws NonRetriableException {
         if (commits.size() == 0) {
             return;
         }
 
         var writer = new StringWriter();
@@ -236,15 +241,19 @@
                          .author(commitAddress)
                          .recipient(recipient)
                          .headers(headers)
                          .build();
 
-        list.post(email);
+        try {
+            list.post(email);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
     }
 
     @Override
-    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) {
+    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
         switch (mode) {
             case PR_ONLY:
                 filterAndSendPrCommits(repository, commits, branch);
                 break;
             case PR:
@@ -255,11 +264,11 @@
                 break;
         }
     }
 
     @Override
-    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) {
+    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
         if ((mode == Mode.PR_ONLY) || (!reportNewTags)) {
             return;
         }
         if (!reportNewBuilds) {
             handleTagCommit(repository, localRepository, commits.get(commits.size() - 1), tag.tag(), annotation);
@@ -294,15 +303,19 @@
             email.author(annotationToAuthor(annotation));
         } else {
             email.author(commitToAuthor(taggedCommit));
         }
 
-        list.post(email.build());
+        try {
+            list.post(email.build());
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
     }
 
     @Override
-    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) {
+    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) throws NonRetriableException {
         if ((mode == Mode.PR_ONLY) || (!reportNewTags)) {
             return;
         }
         var writer = new StringWriter();
         var printer = new PrintWriter(writer);
@@ -322,11 +335,15 @@
             email.author(annotationToAuthor(annotation));
         } else {
             email.author(commitToAuthor(commit));
         }
 
-        list.post(email.build());
+        try {
+            list.post(email.build());
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
     }
 
     private String newBranchSubject(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
         var subject = new StringBuilder();
         subject.append(repository.repositoryType().shortName());
@@ -345,11 +362,11 @@
 
         return subject.toString();
     }
 
     @Override
-    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
+    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) throws NonRetriableException {
         if ((mode == Mode.PR_ONLY) || (!reportNewBranches)) {
             return;
         }
         var writer = new StringWriter();
         var printer = new PrintWriter(writer);
@@ -375,16 +392,15 @@
                          .sender(sender)
                          .author(finalAuthor)
                          .recipient(recipient)
                          .headers(headers)
                          .build();
-        list.post(email);
-    }
-
-    @Override
-    public boolean isIdempotent() {
-        return false;
+        try {
+            list.post(email);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
     }
 
     @Override
     public String name() {
         return "ml";
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NonRetriableException.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NonRetriableException.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NonRetriableException.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+public class NonRetriableException extends Exception {
+    private final Throwable cause;
+
+    public NonRetriableException(Throwable cause) {
+        this.cause = cause;
+    }
+
+    public Throwable cause() {
+        return cause;
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
@@ -22,12 +22,11 @@
  */
 package org.openjdk.skara.bots.notify;
 
 import org.openjdk.skara.bot.*;
 import org.openjdk.skara.forge.*;
-import org.openjdk.skara.storage.*;
-import org.openjdk.skara.vcs.Tag;
+import org.openjdk.skara.storage.StorageBuilder;
 
 import java.nio.file.Path;
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
@@ -35,21 +34,21 @@
 class NotifyBot implements Bot {
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
     private final HostedRepository repository;
     private final Path storagePath;
     private final Pattern branches;
-    private final StorageBuilder<Tag> tagStorageBuilder;
-    private final StorageBuilder<ResolvedBranch> branchStorageBuilder;
+    private final StorageBuilder<UpdatedTag> tagStorageBuilder;
+    private final StorageBuilder<UpdatedBranch> branchStorageBuilder;
     private final StorageBuilder<PullRequestIssues> prIssuesStorageBuilder;
     private final List<RepositoryUpdateConsumer> updaters;
     private final List<PullRequestUpdateConsumer> prUpdaters;
     private final PullRequestUpdateCache updateCache;
     private final Set<String> readyLabels;
     private final Map<String, Pattern> readyComments;
 
-    NotifyBot(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<Tag> tagStorageBuilder,
-              StorageBuilder<ResolvedBranch> branchStorageBuilder, StorageBuilder<PullRequestIssues> prIssuesStorageBuilder,
+    NotifyBot(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<UpdatedTag> tagStorageBuilder,
+              StorageBuilder<UpdatedBranch> branchStorageBuilder, StorageBuilder<PullRequestIssues> prIssuesStorageBuilder,
               List<RepositoryUpdateConsumer> updaters, List<PullRequestUpdateConsumer> prUpdaters,
               Set<String> readyLabels, Map<String, Pattern> readyComments) {
         this.repository = repository;
         this.storagePath = storagePath;
         this.branches = branches;
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotBuilder.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotBuilder.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotBuilder.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotBuilder.java
@@ -22,22 +22,21 @@
  */
 package org.openjdk.skara.bots.notify;
 
 import org.openjdk.skara.forge.HostedRepository;
 import org.openjdk.skara.storage.StorageBuilder;
-import org.openjdk.skara.vcs.Tag;
 
 import java.nio.file.Path;
 import java.util.*;
 import java.util.regex.Pattern;
 
 public class NotifyBotBuilder {
     private HostedRepository repository;
     private Path storagePath;
     private Pattern branches;
-    private StorageBuilder<Tag> tagStorageBuilder;
-    private StorageBuilder<ResolvedBranch> branchStorageBuilder;
+    private StorageBuilder<UpdatedTag> tagStorageBuilder;
+    private StorageBuilder<UpdatedBranch> branchStorageBuilder;
     private StorageBuilder<PullRequestIssues> prIssuesStorageBuilder;
     private List<RepositoryUpdateConsumer> updaters = List.of();
     private List<PullRequestUpdateConsumer> prUpdaters = List.of();
     private Set<String> readyLabels = Set.of();
     private Map<String, Pattern> readyComments = Map.of();
@@ -55,16 +54,16 @@
     public NotifyBotBuilder branches(Pattern branches) {
         this.branches = branches;
         return this;
     }
 
-    public NotifyBotBuilder tagStorageBuilder(StorageBuilder<Tag> tagStorageBuilder) {
+    public NotifyBotBuilder tagStorageBuilder(StorageBuilder<UpdatedTag> tagStorageBuilder) {
         this.tagStorageBuilder = tagStorageBuilder;
         return this;
     }
 
-    public NotifyBotBuilder branchStorageBuilder(StorageBuilder<ResolvedBranch> branchStorageBuilder) {
+    public NotifyBotBuilder branchStorageBuilder(StorageBuilder<UpdatedBranch> branchStorageBuilder) {
         this.branchStorageBuilder = branchStorageBuilder;
         return this;
     }
 
     public NotifyBotBuilder prIssuesStorageBuilder(StorageBuilder<PullRequestIssues> prIssuesStorageBuilder) {
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
@@ -185,13 +185,13 @@
                 continue;
             }
 
             var baseName = repo.value().contains("basename") ? repo.value().get("basename").asString() : configuration.repositoryName(repoName);
 
-            var tagStorageBuilder = new StorageBuilder<Tag>(baseName + ".tags.txt")
+            var tagStorageBuilder = new StorageBuilder<UpdatedTag>(baseName + ".tags.txt")
                     .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added tag for " + repoName);
-            var branchStorageBuilder = new StorageBuilder<ResolvedBranch>(baseName + ".branches.txt")
+            var branchStorageBuilder = new StorageBuilder<UpdatedBranch>(baseName + ".branches.txt")
                     .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added branch hash for " + repoName);
             var issueStorageBuilder = new StorageBuilder<PullRequestIssues>(baseName + ".prissues.txt")
                     .remoteRepository(databaseRepo, databaseRef, databaseName, databaseEmail, "Added pull request issue info for " + repoName);
             var bot = NotifyBot.newBuilder()
                                .repository(configuration.repository(repoName))
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
@@ -27,12 +27,11 @@
 import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
 
 import java.util.List;
 
 public interface RepositoryUpdateConsumer {
-    void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch);
-    void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotated);
-    void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation);
-    void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch);
-    boolean isIdempotent();
+    void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException;
+    void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotated) throws NonRetriableException;
+    void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) throws NonRetriableException;
+    void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) throws NonRetriableException;
     String name();
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
@@ -27,11 +27,10 @@
 import org.openjdk.skara.storage.StorageBuilder;
 import org.openjdk.skara.vcs.*;
 import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
 
 import java.io.*;
-import java.net.URI;
 import java.nio.file.*;
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
@@ -39,24 +38,24 @@
 public class RepositoryWorkItem implements WorkItem {
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
     private final HostedRepository repository;
     private final Path storagePath;
     private final Pattern branches;
-    private final StorageBuilder<Tag> tagStorageBuilder;
-    private final StorageBuilder<ResolvedBranch> branchStorageBuilder;
+    private final StorageBuilder<UpdatedTag> tagStorageBuilder;
+    private final StorageBuilder<UpdatedBranch> branchStorageBuilder;
     private final List<RepositoryUpdateConsumer> updaters;
 
-    RepositoryWorkItem(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<Tag> tagStorageBuilder, StorageBuilder<ResolvedBranch> branchStorageBuilder, List<RepositoryUpdateConsumer> updaters) {
+    RepositoryWorkItem(HostedRepository repository, Path storagePath, Pattern branches, StorageBuilder<UpdatedTag> tagStorageBuilder, StorageBuilder<UpdatedBranch> branchStorageBuilder, List<RepositoryUpdateConsumer> updaters) {
         this.repository = repository;
         this.storagePath = storagePath;
         this.branches = branches;
         this.tagStorageBuilder = tagStorageBuilder;
         this.branchStorageBuilder = branchStorageBuilder;
         this.updaters = updaters;
     }
 
-    private void handleNewRef(Repository localRepo, Reference ref, Collection<Reference> allRefs, RepositoryUpdateConsumer updater) {
+    private void handleNewRef(Repository localRepo, Reference ref, Collection<Reference> allRefs, RepositoryUpdateConsumer updater) throws NonRetriableException {
         // Figure out the best parent ref
         var candidates = new HashSet<>(allRefs);
         candidates.remove(ref);
         if (candidates.size() == 0) {
             log.warning("No parent candidates found for branch '" + ref.name() + "' - ignoring");
@@ -86,31 +85,29 @@
         var branch = new Branch(ref.name());
         var parent = new Branch(bestParent.getKey().name());
         updater.handleNewBranch(repository, localRepo, bestParentCommits, parent, branch);
     }
 
-    private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits, RepositoryUpdateConsumer updater) {
+    private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits, RepositoryUpdateConsumer updater) throws NonRetriableException {
         var branch = new Branch(ref.name());
         updater.handleCommits(repository, localRepo, commits, branch);
     }
 
-    private List<RuntimeException> handleRef(Repository localRepo, UpdateHistory history, Reference ref, Collection<Reference> allRefs) throws IOException {
-        var errors = new ArrayList<RuntimeException>();
+    private List<Throwable> handleRef(Repository localRepo, UpdateHistory history, Reference ref, Collection<Reference> allRefs) throws IOException {
+        var errors = new ArrayList<Throwable>();
         var branch = new Branch(ref.name());
         for (var updater : updaters) {
             var lastHash = history.branchHash(branch, updater.name());
             if (lastHash.isEmpty()) {
                 log.warning("No previous history found for branch '" + branch + "' and updater '" + updater.name() + " - resetting mark");
-                if (!updater.isIdempotent()) {
-                    history.setBranchHash(branch, updater.name(), ref.hash());
-                }
+                history.setBranchHash(branch, updater.name(), ref.hash());
                 try {
                     handleNewRef(localRepo, ref, allRefs, updater);
-                    if (updater.isIdempotent()) {
-                        history.setBranchHash(branch, updater.name(), ref.hash());
-                    }
+                } catch (NonRetriableException e) {
+                    errors.add(e.cause());
                 } catch (RuntimeException e) {
+                    // FIXME: Attempt rollback?
                     errors.add(e);
                 }
             } else {
                 var commitMetadata = localRepo.commitMetadata(lastHash.get() + ".." + ref.hash());
                 if (commitMetadata.size() == 0) {
@@ -123,19 +120,18 @@
                                                        updater.name() + "' - skipping notifications"));
                     continue;
                 }
 
                 var commits = localRepo.commits(lastHash.get() + ".." + ref.hash(), true).asList();
-                if (!updater.isIdempotent()) {
-                    history.setBranchHash(branch, updater.name(), ref.hash());
-                }
+                history.setBranchHash(branch, updater.name(), ref.hash());
                 try {
                     handleUpdatedRef(localRepo, ref, commits, updater);
-                    if (updater.isIdempotent()) {
-                        history.setBranchHash(branch, updater.name(), ref.hash());
-                    }
+                } catch (NonRetriableException e) {
+                    errors.add(e.cause());
                 } catch (RuntimeException e) {
+                    // Attempt to roll back
+                    history.setBranchHash(branch, updater.name(), lastHash.get());
                     errors.add(e);
                 }
             }
         }
         return errors;
@@ -153,28 +149,30 @@
             }
             return Optional.of(tag);
         }
     }
 
-    private void handleTags(Repository localRepo, UpdateHistory history) throws IOException {
+    private List<Throwable> handleTags(Repository localRepo, UpdateHistory history, RepositoryUpdateConsumer updater) throws IOException {
+        var errors = new ArrayList<Throwable>();
         var tags = localRepo.tags();
         var newTags = tags.stream()
-                          .filter(tag -> !history.hasTag(tag))
+                          .filter(tag -> !history.hasTag(tag, updater.name()))
                           .collect(Collectors.toList());
 
         if (tags.size() == newTags.size()) {
             if (tags.size() > 0) {
                 log.warning("No previous tag history found - ignoring all current tags");
-                history.addTags(tags);
+                history.addTags(tags, updater.name());
             }
-            return;
+            return errors;
         }
 
         if (newTags.size() > 10) {
-            history.addTags(newTags);
-            throw new RuntimeException("Excessive amount of new tags detected (" + newTags.size() +
-                                               ") - skipping notifications");
+            history.addTags(newTags, updater.name());
+            errors.add(new RuntimeException("Excessive amount of new tags detected (" + newTags.size() +
+                                               ") - skipping notifications"));
+            return errors;
         }
 
         var allJdkTags = tags.stream()
                              .map(OpenJDKTag::create)
                              .filter(Optional::isPresent)
@@ -206,22 +204,19 @@
             }
 
             Collections.reverse(commits);
             var annotation = localRepo.annotate(tag.tag());
 
-            // Run all notifiers that can be safely re-run
-            updaters.stream()
-                    .filter(RepositoryUpdateConsumer::isIdempotent)
-                    .forEach(updater -> updater.handleOpenJDKTagCommits(repository, localRepo, commits, tag, annotation.orElse(null)));
-
-            // Now update the history
-            history.addTags(List.of(tag.tag()));
-
-            // Finally run all one-shot notifiers
-            updaters.stream()
-                    .filter(updater -> !updater.isIdempotent())
-                    .forEach(updater -> updater.handleOpenJDKTagCommits(repository, localRepo, commits, tag, annotation.orElse(null)));
+            history.addTags(List.of(tag.tag()), updater.name());
+            try {
+                updater.handleOpenJDKTagCommits(repository, localRepo, commits, tag, annotation.orElse(null));
+            } catch (NonRetriableException e) {
+                errors.add(e.cause());
+            } catch (RuntimeException e) {
+                errors.add(e);
+                history.retryTagUpdate(tag.tag(), updater.name());
+            }
         }
 
         var newNonJdkTags = newTags.stream()
                                    .filter(tag -> OpenJDKTag.create(tag).isEmpty())
                                    .collect(Collectors.toList());
@@ -231,38 +226,24 @@
                 throw new RuntimeException("Failed to lookup tag '" + tag.toString() + "'");
             }
 
             var annotation = localRepo.annotate(tag);
 
-            // Run all notifiers that can be safely re-run
-            updaters.stream()
-                    .filter(RepositoryUpdateConsumer::isIdempotent)
-                    .forEach(updater -> updater.handleTagCommit(repository, localRepo, commit.get(), tag, annotation.orElse(null)));
-
-            // Now update the history
-            history.addTags(List.of(tag));
-
-            // Finally run all one-shot notifiers
-            updaters.stream()
-                    .filter(updater -> !updater.isIdempotent())
-                    .forEach(updater -> updater.handleTagCommit(repository, localRepo, commit.get(), tag, annotation.orElse(null)));
+            history.addTags(List.of(tag), updater.name());
+            try {
+                updater.handleTagCommit(repository, localRepo, commit.get(), tag, annotation.orElse(null));
+            } catch (NonRetriableException e) {
+                errors.add(e.cause());
+            } catch (RuntimeException e) {
+                errors.add(e);
+                history.retryTagUpdate(tag, updater.name());
+            }
         }
-    }
 
-    private Repository fetchAll(Path dir, URI remote) throws IOException {
-        Repository repo = null;
-        if (!Files.exists(dir)) {
-            Files.createDirectories(dir);
-            repo = Repository.clone(remote, dir);
-        } else {
-            repo = Repository.get(dir).orElseThrow(() -> new RuntimeException("Repository in " + dir + " has vanished"));
-        }
-        repo.fetchAll();
-        return repo;
+        return errors;
     }
 
-
     @Override
     public boolean concurrentWith(WorkItem other) {
         if (!(other instanceof RepositoryWorkItem)) {
             return true;
         }
@@ -285,14 +266,17 @@
                                      .filter(ref -> branches.matcher(ref.name()).matches())
                                      .collect(Collectors.toList());
             localRepo.fetchAll();
 
             var history = UpdateHistory.create(tagStorageBuilder, historyPath.resolve("tags"), branchStorageBuilder, historyPath.resolve("branches"));
-            handleTags(localRepo, history);
+            var errors = new ArrayList<Throwable>();
+
+            for (var updater : updaters) {
+                errors.addAll(handleTags(localRepo, history, updater));
+            }
 
             boolean hasBranchHistory = !history.isEmpty();
-            var errors = new ArrayList<RuntimeException>();
             for (var ref : knownRefs) {
                 if (!hasBranchHistory) {
                     log.warning("No previous history found for any branch - resetting mark for '" + ref.name());
                     for (var updater : updaters) {
                         log.info("Resetting mark for branch '" + ref.name() + "' for updater '" + updater.name() + "'");
@@ -302,11 +286,11 @@
                     errors.addAll(handleRef(localRepo, history, ref, knownRefs));
                 }
             }
             if (!errors.isEmpty()) {
                 errors.forEach(error -> log.throwing("RepositoryWorkItem", "run", error));
-                throw new RuntimeException("Errors detected during ref updating");
+                throw new RuntimeException("Errors detected when processing repository notifications");
             }
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/ResolvedBranch.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/ResolvedBranch.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/ResolvedBranch.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.vcs.*;
-
-import java.util.Objects;
-
-class ResolvedBranch {
-    private final Branch branch;
-    private final String updater;
-    private final Hash hash;
-
-    ResolvedBranch(Branch branch, String updater, Hash hash) {
-        this.branch = branch;
-        this.updater = updater;
-        this.hash = hash;
-    }
-
-    public Branch branch() {
-        return branch;
-    }
-
-    public String updater() {
-        return updater;
-    }
-
-    public Hash hash() {
-        return hash;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (o == null || getClass() != o.getClass()) {
-            return false;
-        }
-        ResolvedBranch that = (ResolvedBranch) o;
-        return branch.equals(that.branch) && updater.equals(that.updater) && hash.equals(that.hash);
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(branch, updater, hash);
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateHistory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateHistory.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateHistory.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdateHistory.java
@@ -29,124 +29,136 @@
 import java.util.*;
 import java.util.function.Function;
 import java.util.stream.*;
 
 class UpdateHistory {
-    private final Storage<Tag> tagStorage;
-    private final Storage<ResolvedBranch> branchStorage;
+    private final Storage<UpdatedTag> tagStorage;
+    private final Storage<UpdatedBranch> branchStorage;
 
     private Map<String, Hash> branchHashes;
-    private Set<Tag> tags;
+    private Map<String, Boolean> tagRetries;
 
-    private List<ResolvedBranch> parseSerializedEntry(String entry) {
+    private List<UpdatedBranch> parseSerializedBranch(String entry) {
         var parts = entry.split(" ");
         if (parts.length == 2) {
             // Transform legacy entry
-            var issueEntry = new ResolvedBranch(new Branch(parts[0]), "issue", new Hash(parts[1]));
-            var mlEntry = new ResolvedBranch(new Branch(parts[0]), "ml", new Hash(parts[1]));
+            var issueEntry = new UpdatedBranch(new Branch(parts[0]), "issue", new Hash(parts[1]));
+            var mlEntry = new UpdatedBranch(new Branch(parts[0]), "ml", new Hash(parts[1]));
             return List.of(issueEntry, mlEntry);
         }
-        return List.of(new ResolvedBranch(new Branch(parts[0]), parts[1], new Hash(parts[2])));
+        return List.of(new UpdatedBranch(new Branch(parts[0]), parts[1], new Hash(parts[2])));
     }
 
-    private Set<ResolvedBranch> loadBranches(String current) {
+    private Set<UpdatedBranch> loadBranches(String current) {
         return current.lines()
-                      .flatMap(line -> parseSerializedEntry(line).stream())
+                      .flatMap(line -> parseSerializedBranch(line).stream())
                       .collect(Collectors.toSet());
     }
 
-    private String serializeEntry(ResolvedBranch entry) {
+    private String serializeBranch(UpdatedBranch entry) {
         return entry.branch().toString() + " " + entry.updater() + " " + entry.hash().toString();
     }
 
-    private String serializeBranches(Collection<ResolvedBranch> added, Set<ResolvedBranch> existing) {
+    private String serializeBranches(Collection<UpdatedBranch> added, Set<UpdatedBranch> existing) {
         var updatedBranches = existing.stream()
                                       .collect(Collectors.toMap(entry -> entry.branch().toString() + ":" + entry.updater(),
                                                                 Function.identity()));
         added.forEach(a -> updatedBranches.put(a.branch().toString() + ":" + a.updater(), a));
         return updatedBranches.values().stream()
-                              .map(this::serializeEntry)
+                              .map(this::serializeBranch)
                               .sorted()
                               .collect(Collectors.joining("\n"));
     }
 
-    private Set<Tag> loadTags(String current) {
+    private List<UpdatedTag> parseSerializedTag(String entry) {
+        var parts = entry.split(" ");
+        if (parts.length == 1) {
+            // Transform legacy entry
+            var issueEntry = new UpdatedTag(new Tag(entry), "issue", false);
+            var mlEntry = new UpdatedTag(new Tag(entry), "ml", false);
+            return List.of(issueEntry, mlEntry);
+        }
+        return List.of(new UpdatedTag(new Tag(parts[0]), parts[1], parts[2].equals("retry")));
+    }
+
+    private Set<UpdatedTag> loadTags(String current) {
         return current.lines()
-                      .map(Tag::new)
+                      .flatMap(line -> parseSerializedTag(line).stream())
                       .collect(Collectors.toSet());
     }
 
-    private String serializeTags(Collection<Tag> added, Set<Tag> existing) {
-        return Stream.concat(existing.stream(),
-                             added.stream())
-                     .map(Tag::toString)
-                     .sorted()
-                     .collect(Collectors.joining("\n"));
+    private String serializeTag(UpdatedTag entry) {
+        return entry.tag().toString() + " " + entry.updater() + " " + (entry.shouldRetry() ? "retry" : "done");
     }
 
-    private Set<Tag> currentTags() {
-        return tagStorage.current();
+    private String serializeTags(Collection<UpdatedTag> added, Set<UpdatedTag> existing) {
+        var updatedTags = existing.stream()
+                                  .collect(Collectors.toMap(entry -> entry.tag().toString() + ":" + entry.updater(),
+                                                            Function.identity()));
+        added.forEach(a -> updatedTags.put(a.tag().toString() + ":" + a.updater(), a));
+        return updatedTags.values().stream()
+                          .map(this::serializeTag)
+                          .sorted()
+                          .collect(Collectors.joining("\n"));
     }
 
     private Map<String, Hash> currentBranchHashes() {
         return branchStorage.current().stream()
-                .collect(Collectors.toMap(rb -> rb.branch().toString() + " " + rb.updater(), ResolvedBranch::hash));
+                            .collect(Collectors.toMap(rb -> rb.branch().toString() + " " + rb.updater(), UpdatedBranch::hash));
     }
 
-    private UpdateHistory(StorageBuilder<Tag> tagStorageBuilder, Path tagLocation, StorageBuilder<ResolvedBranch> branchStorageBuilder, Path branchLocation) {
+    private Map<String, Boolean> currentTags() {
+        return tagStorage.current().stream()
+                         .collect(Collectors.toMap(u -> u.tag().toString() + " " + u.updater(), UpdatedTag::shouldRetry));
+    }
+
+    private UpdateHistory(StorageBuilder<UpdatedTag> tagStorageBuilder, Path tagLocation, StorageBuilder<UpdatedBranch> branchStorageBuilder, Path branchLocation) {
         this.tagStorage = tagStorageBuilder
                 .serializer(this::serializeTags)
                 .deserializer(this::loadTags)
                 .materialize(tagLocation);
 
         this.branchStorage = branchStorageBuilder
                 .serializer(this::serializeBranches)
                 .deserializer(this::loadBranches)
                 .materialize(branchLocation);
 
-        tags = currentTags();
+        tagRetries = currentTags();
         branchHashes = currentBranchHashes();
     }
 
-    static UpdateHistory create(StorageBuilder<Tag> tagStorageBuilder, Path tagLocation, StorageBuilder<ResolvedBranch> branchStorageBuilder, Path branchLocation) {
+    static UpdateHistory create(StorageBuilder<UpdatedTag> tagStorageBuilder, Path tagLocation, StorageBuilder<UpdatedBranch> branchStorageBuilder, Path branchLocation) {
         return new UpdateHistory(tagStorageBuilder, tagLocation, branchStorageBuilder, branchLocation);
     }
 
-    void addTags(Collection<Tag> addedTags) {
-        tagStorage.put(addedTags);
-        var newTags = currentTags();
+    void addTags(Collection<Tag> addedTags, String updater) {
+        var newEntries = addedTags.stream()
+                                  .map(t -> new UpdatedTag(t, updater, false))
+                                  .collect(Collectors.toSet());
+        tagStorage.put(newEntries);
+        tagRetries = currentTags();
+    }
 
-        if (addedTags != null) {
-            for (var existingTag : addedTags) {
-                if (!newTags.contains(existingTag)) {
-                    throw new RuntimeException("Tag '" + existingTag + "' has been removed");
-                }
-            }
-        }
+    void retryTagUpdate(Tag tagToRetry, String updater) {
+        var entry = new UpdatedTag(tagToRetry, updater, true);
+        tagStorage.put(List.of(entry));
+        tagRetries = currentTags();
+    }
 
-        tags = currentTags();
+    boolean hasTag(Tag tag, String updater) {
+        return tagRetries.containsKey(tag.toString() + " " + updater);
     }
 
-    boolean hasTag(Tag tag) {
-        return tags.contains(tag);
+    boolean shouldRetryTagUpdate(Tag tag, String updater) {
+        return tagRetries.getOrDefault(tag.toString() + " " + updater, false);
     }
 
     void setBranchHash(Branch branch, String updater, Hash hash) {
-        var entry = new ResolvedBranch(branch, updater, hash);
+        var entry = new UpdatedBranch(branch, updater, hash);
 
         branchStorage.put(entry);
-        var newBranchHashes = currentBranchHashes();
-
-        // Sanity check
-        if (branchHashes != null) {
-            for (var existingBranch : branchHashes.keySet()) {
-                if (!newBranchHashes.containsKey(existingBranch)) {
-                    throw new RuntimeException("Hash information for branch '" + existingBranch + "' is missing");
-                }
-            }
-        }
-        branchHashes = newBranchHashes;
+        branchHashes = currentBranchHashes();
     }
 
     Optional<Hash> branchHash(Branch branch, String updater) {
         var entry = branchHashes.get(branch.toString() + " " + updater);
         return Optional.ofNullable(entry);
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedBranch.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedBranch.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedBranch.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.vcs.*;
+
+import java.util.Objects;
+
+class UpdatedBranch {
+    private final Branch branch;
+    private final String updater;
+    private final Hash hash;
+
+    UpdatedBranch(Branch branch, String updater, Hash hash) {
+        this.branch = branch;
+        this.updater = updater;
+        this.hash = hash;
+    }
+
+    public Branch branch() {
+        return branch;
+    }
+
+    public String updater() {
+        return updater;
+    }
+
+    public Hash hash() {
+        return hash;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        UpdatedBranch that = (UpdatedBranch) o;
+        return branch.equals(that.branch) && updater.equals(that.updater) && hash.equals(that.hash);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(branch, updater, hash);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedTag.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedTag.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedTag.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.vcs.Tag;
+
+import java.util.Objects;
+
+public class UpdatedTag {
+    private final Tag tag;
+    private final String updater;
+    private final boolean shouldRetry;
+
+    public UpdatedTag(Tag tag, String updater, boolean shouldRetry) {
+        this.tag = tag;
+        this.updater = updater;
+        this.shouldRetry = shouldRetry;
+    }
+
+    public Tag tag() {
+        return tag;
+    }
+
+    public String updater() {
+        return updater;
+    }
+
+    public boolean shouldRetry() {
+        return shouldRetry;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        UpdatedTag that = (UpdatedTag) o;
+        return shouldRetry == that.shouldRetry &&
+                tag.equals(that.tag) &&
+                updater.equals(that.updater);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(tag, updater, shouldRetry);
+    }
+}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdateHistoryTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdateHistoryTests.java
--- a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdateHistoryTests.java
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdateHistoryTests.java
@@ -48,13 +48,13 @@
         return localRepository.defaultBranch().toString();
     }
 
     private UpdateHistory createHistory(HostedRepository repository, String ref) throws IOException {
         var folder = Files.createTempDirectory("updatehistory");
-        var tagStorage = new StorageBuilder<Tag>("tags.txt")
+        var tagStorage = new StorageBuilder<UpdatedTag>("tags.txt")
                                        .remoteRepository(repository, ref, "Duke", "duke@openjdk.java.net", "Updated tags");
-        var branchStorage = new StorageBuilder<ResolvedBranch>("branches.txt")
+        var branchStorage = new StorageBuilder<UpdatedBranch>("branches.txt")
                 .remoteRepository(repository, ref, "Duke", "duke@openjdk.java.net", "Updated branches");
         return UpdateHistory.create(tagStorage,folder.resolve("tags"), branchStorage, folder.resolve("branches"));
     }
 
     @Test
@@ -62,19 +62,19 @@
         try (var credentials = new HostCredentials(testInfo)) {
             var repository = credentials.getHostedRepository();
             var ref = resetHostedRepository(repository);
             var history = createHistory(repository, ref);
 
-            history.addTags(List.of(new Tag("1"), new Tag("2")));
+            history.addTags(List.of(new Tag("1"), new Tag("2")), "a");
 
-            assertTrue(history.hasTag(new Tag("1")));
-            assertTrue(history.hasTag(new Tag("2")));
+            assertTrue(history.hasTag(new Tag("1"), "a"));
+            assertTrue(history.hasTag(new Tag("2"), "a"));
 
             var newHistory = createHistory(repository, ref);
 
-            assertTrue(newHistory.hasTag(new Tag("1")));
-            assertTrue(newHistory.hasTag(new Tag("2")));
+            assertTrue(newHistory.hasTag(new Tag("1"), "a"));
+            assertTrue(newHistory.hasTag(new Tag("2"), "a"));
         }
     }
 
     @Test
     void branchesRetained(TestInfo testInfo) throws IOException {
@@ -121,39 +121,94 @@
             assertEquals(new Hash("d"), newHistory.branchHash(new Branch("2"), "a").orElseThrow());
             assertEquals(new Hash("c"), newHistory.branchHash(new Branch("1"), "b").orElseThrow());
         }
     }
 
+    @Test
+    void tagsSeparateUpdaters(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo)) {
+            var repository = credentials.getHostedRepository();
+            var ref = resetHostedRepository(repository);
+            var history = createHistory(repository, ref);
+
+            history.addTags(List.of(new Tag("1"), new Tag("2")), "a");
+            history.addTags(List.of(new Tag("2"), new Tag("3")), "b");
+
+            assertTrue(history.hasTag(new Tag("1"), "a"));
+            assertTrue(history.hasTag(new Tag("2"), "a"));
+            assertFalse(history.hasTag(new Tag("3"), "a"));
+            assertFalse(history.hasTag(new Tag("1"), "b"));
+            assertTrue(history.hasTag(new Tag("2"), "b"));
+            assertTrue(history.hasTag(new Tag("3"), "b"));
+
+            var newHistory = createHistory(repository, ref);
+
+            assertTrue(newHistory.hasTag(new Tag("1"), "a"));
+            assertTrue(newHistory.hasTag(new Tag("2"), "a"));
+            assertFalse(newHistory.hasTag(new Tag("3"), "a"));
+            assertFalse(newHistory.hasTag(new Tag("1"), "b"));
+            assertTrue(newHistory.hasTag(new Tag("2"), "b"));
+            assertTrue(newHistory.hasTag(new Tag("3"), "b"));
+        }
+    }
+
+    @Test
+    void tagsMarkRetry(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo)) {
+            var repository = credentials.getHostedRepository();
+            var ref = resetHostedRepository(repository);
+            var history = createHistory(repository, ref);
+
+            history.addTags(List.of(new Tag("1"), new Tag("2")), "a");
+            history.addTags(List.of(new Tag("2"), new Tag("3")), "b");
+
+            history.retryTagUpdate(new Tag("1"), "a");
+            history.retryTagUpdate(new Tag("2"), "b");
+
+            assertTrue(history.shouldRetryTagUpdate(new Tag("1"), "a"));
+            assertFalse(history.shouldRetryTagUpdate(new Tag("2"), "a"));
+            assertTrue(history.shouldRetryTagUpdate(new Tag("2"), "b"));
+            assertFalse(history.shouldRetryTagUpdate(new Tag("3"), "b"));
+
+            var newHistory = createHistory(repository, ref);
+
+            assertTrue(newHistory.shouldRetryTagUpdate(new Tag("1"), "a"));
+            assertFalse(newHistory.shouldRetryTagUpdate(new Tag("2"), "a"));
+            assertTrue(newHistory.shouldRetryTagUpdate(new Tag("2"), "b"));
+            assertFalse(newHistory.shouldRetryTagUpdate(new Tag("3"), "b"));
+        }
+    }
+
     @Test
     void tagsConcurrentModification(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo)) {
             var repository = credentials.getHostedRepository();
             var ref = resetHostedRepository(repository);
             var history = createHistory(repository, ref);
 
-            history.addTags(List.of(new Tag("1"), new Tag("2")));
+            history.addTags(List.of(new Tag("1"), new Tag("2")), "a");
 
-            assertTrue(history.hasTag(new Tag("1")));
-            assertTrue(history.hasTag(new Tag("2")));
+            assertTrue(history.hasTag(new Tag("1"), "a"));
+            assertTrue(history.hasTag(new Tag("2"), "a"));
 
             var history1 = createHistory(repository, ref);
-            assertTrue(history1.hasTag(new Tag("1")));
-            assertTrue(history1.hasTag(new Tag("2")));
-            assertFalse(history1.hasTag(new Tag("3")));
-            assertFalse(history1.hasTag(new Tag("4")));
+            assertTrue(history1.hasTag(new Tag("1"), "a"));
+            assertTrue(history1.hasTag(new Tag("2"), "a"));
+            assertFalse(history1.hasTag(new Tag("3"), "a"));
+            assertFalse(history1.hasTag(new Tag("4"), "a"));
 
             var history2 = createHistory(repository, ref);
-            assertTrue(history2.hasTag(new Tag("1")));
-            assertTrue(history2.hasTag(new Tag("2")));
-            assertFalse(history2.hasTag(new Tag("3")));
-            assertFalse(history2.hasTag(new Tag("4")));
-
-            history1.addTags(Set.of(new Tag("3")));
-            history2.addTags(Set.of(new Tag("4")));
-
-            assertTrue(history1.hasTag(new Tag("3")));
-            assertFalse(history1.hasTag(new Tag("4")));
-            assertTrue(history2.hasTag(new Tag("3")));
-            assertTrue(history2.hasTag(new Tag("4")));
+            assertTrue(history2.hasTag(new Tag("1"), "a"));
+            assertTrue(history2.hasTag(new Tag("2"), "a"));
+            assertFalse(history2.hasTag(new Tag("3"), "a"));
+            assertFalse(history2.hasTag(new Tag("4"), "a"));
+
+            history1.addTags(Set.of(new Tag("3")), "a");
+            history2.addTags(Set.of(new Tag("4")), "a");
+
+            assertTrue(history1.hasTag(new Tag("3"), "a"));
+            assertFalse(history1.hasTag(new Tag("4"), "a"));
+            assertTrue(history2.hasTag(new Tag("3"), "a"));
+            assertTrue(history2.hasTag(new Tag("4"), "a"));
         }
     }
 }
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
--- a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
@@ -53,17 +53,17 @@
                     .filter(path -> path.toString().endsWith(".json"))
                     .filter(path -> path.toString().contains(partialName))
                     .collect(Collectors.toList());
     }
 
-    private StorageBuilder<Tag> createTagStorage(HostedRepository repository) {
-        return new StorageBuilder<Tag>("tags.txt")
+    private StorageBuilder<UpdatedTag> createTagStorage(HostedRepository repository) {
+        return new StorageBuilder<UpdatedTag>("tags.txt")
                 .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated tags");
     }
 
-    private StorageBuilder<ResolvedBranch> createBranchStorage(HostedRepository repository) {
-        return new StorageBuilder<ResolvedBranch>("branches.txt")
+    private StorageBuilder<UpdatedBranch> createBranchStorage(HostedRepository repository) {
+        return new StorageBuilder<UpdatedBranch>("branches.txt")
                 .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated branches");
     }
 
     private StorageBuilder<PullRequestIssues> createPullRequestIssuesStorage(HostedRepository repository) {
         return new StorageBuilder<PullRequestIssues>("prissues.txt")
@@ -1925,14 +1925,18 @@
             this.idempotent = idempotent;
         }
 
         @Override
         public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits,
-                                  Branch branch) {
+                                  Branch branch) throws NonRetriableException {
             updateCount++;
             if (shouldFail) {
-                throw new RuntimeException("induced failure");
+                if (idempotent) {
+                    throw new RuntimeException("induced failure");
+                } else {
+                    throw new NonRetriableException(new RuntimeException("unretriable failure"));
+                }
             }
         }
 
         @Override
         public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository,
@@ -1950,15 +1954,10 @@
         public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits,
          Branch parent, Branch branch) {
             throw new RuntimeException("unexpected");
         }
 
-        @Override
-        public boolean isIdempotent() {
-            return idempotent;
-        }
-
         @Override
         public String name() {
             return name;
         }
     }

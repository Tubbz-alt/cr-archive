diff a/bots/notify/src/main/java/module-info.java b/bots/notify/src/main/java/module-info.java
--- a/bots/notify/src/main/java/module-info.java
+++ b/bots/notify/src/main/java/module-info.java
@@ -28,7 +28,16 @@
     requires org.openjdk.skara.storage;
     requires org.openjdk.skara.mailinglist;
     requires org.openjdk.skara.network;
     requires java.logging;
 
+    exports org.openjdk.skara.bots.notify;
+
     provides org.openjdk.skara.bot.BotFactory with org.openjdk.skara.bots.notify.NotifyBotFactory;
+
+    uses org.openjdk.skara.bots.notify.NotifierFactory;
+    provides org.openjdk.skara.bots.notify.NotifierFactory with
+            org.openjdk.skara.bots.notify.issue.IssueUpdaterFactory,
+            org.openjdk.skara.bots.notify.json.JsonUpdaterFactory,
+            org.openjdk.skara.bots.notify.mailinglist.MailingListUpdaterFactory,
+            org.openjdk.skara.bots.notify.slack.SlackUpdaterFactory;
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/CommitFormatters.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/CommitFormatters.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/CommitFormatters.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/CommitFormatters.java
@@ -26,12 +26,12 @@
 import org.openjdk.skara.vcs.*;
 
 import java.io.*;
 import java.time.format.DateTimeFormatter;
 
-class CommitFormatters {
-    static String toTextBrief(HostedRepository repository, Commit commit) {
+public class CommitFormatters {
+    public static String toTextBrief(HostedRepository repository, Commit commit) {
         var writer = new StringWriter();
         var printer = new PrintWriter(writer);
 
         printer.println("Changeset: " + commit.hash().abbreviate());
         printer.println("Author:    " + commit.author().name() + " <" + commit.author().email() + ">");
@@ -54,11 +54,11 @@
         } else {
             return "= " + patch.target().path().orElseThrow();
         }
     }
 
-    static String toText(HostedRepository repository, Commit commit) {
+    public static String toText(HostedRepository repository, Commit commit) {
         var writer = new StringWriter();
         var printer = new PrintWriter(writer);
 
         printer.print(toTextBrief(repository, commit));
         printer.println();
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdater.java
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.email.EmailAddress;
-import org.openjdk.skara.forge.*;
-import org.openjdk.skara.issuetracker.Issue;
-import org.openjdk.skara.issuetracker.*;
-import org.openjdk.skara.jcheck.JCheckConfiguration;
-import org.openjdk.skara.json.*;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.*;
-
-import java.io.IOException;
-import java.net.URI;
-import java.nio.file.Path;
-import java.util.*;
-import java.util.logging.Logger;
-import java.util.regex.Pattern;
-import java.util.stream.*;
-
-public class IssueUpdater implements RepositoryUpdateConsumer, PullRequestUpdateConsumer {
-    private final IssueProject issueProject;
-    private final boolean reviewLink;
-    private final URI reviewIcon;
-    private final boolean commitLink;
-    private final URI commitIcon;
-    private final boolean setFixVersion;
-    private final Map<String, String> fixVersions;
-    private final boolean prOnly;
-    private final Logger log = Logger.getLogger("org.openjdk.skara.bots.notify");
-
-    IssueUpdater(IssueProject issueProject, boolean reviewLink, URI reviewIcon, boolean commitLink, URI commitIcon,
-                 boolean setFixVersion, Map<String, String> fixVersions, boolean prOnly) {
-        this.issueProject = issueProject;
-        this.reviewLink = reviewLink;
-        this.reviewIcon = reviewIcon;
-        this.commitLink = commitLink;
-        this.commitIcon = commitIcon;
-        this.setFixVersion = setFixVersion;
-        this.fixVersions = fixVersions;
-        this.prOnly = prOnly;
-    }
-
-    static IssueUpdaterBuilder newBuilder() {
-        return new IssueUpdaterBuilder();
-    }
-
-    private final static Set<String> primaryTypes = Set.of("Bug", "New Feature", "Enhancement", "Task", "Sub-task");
-
-    private boolean isPrimaryIssue(Issue issue) {
-        var properties = issue.properties();
-        if (!properties.containsKey("issuetype")) {
-            throw new RuntimeException("Unknown type for issue " + issue);
-        }
-        var type = properties.get("issuetype");
-        return primaryTypes.contains(type.asString());
-    }
-
-    private final static Pattern majorVersionPattern = Pattern.compile("([0-9]+)(u[0-9]+)?");
-
-    /**
-     * Extracts the major version part of the string, if possible.
-     */
-    private Optional<String> majorVersion(String version) {
-        var matcher = majorVersionPattern.matcher(version);
-        if (matcher.matches()) {
-            return Optional.of(matcher.group(1));
-        } else {
-            return Optional.empty();
-        }
-    }
-
-    private List<Issue> findBackports(Issue primary) {
-        var links = primary.links();
-        return links.stream()
-                    .filter(l -> l.issue().isPresent())
-                    .map(l -> l.issue().get())
-                    .filter(i -> i.properties().containsKey("issuetype"))
-                    .filter(i -> i.properties().get("issuetype").asString().equals("Backport"))
-                    .collect(Collectors.toList());
-    }
-
-    private boolean isNonScratchVersion(String version) {
-        return !version.startsWith("tbd") && !version.toLowerCase().equals("unknown");
-    }
-
-    private Set<String> fixVersions(Issue issue) {
-        if (!issue.properties().containsKey("fixVersions")) {
-            return Set.of();
-        }
-        return issue.properties().get("fixVersions").stream()
-                    .map(JSONValue::asString)
-                    .collect(Collectors.toSet());
-    }
-
-    /**
-     * Return true if the issue's fixVersionList matches fixVersion.
-     *
-     * fixVersionsList must contain one entry that is an exact match for fixVersions; any
-     * other entries must be scratch values.
-     */
-    private boolean matchVersion(Issue issue, String fixVersion) {
-        var nonScratch = fixVersions(issue).stream()
-                                           .filter(this::isNonScratchVersion)
-                                           .collect(Collectors.toList());
-        return nonScratch.size() == 1 && nonScratch.get(0).equals(fixVersion);
-    }
-
-    /**
-     * Return true if the issue's fixVersionList is a match for fixVersion, using "-pool" or "-open".
-     *
-     * If fixVersion has a major release of <N>, it matches the fixVersionList has an
-     * <N>-pool or <N>-open entry and all other entries are scratch values.
-     */
-    private boolean matchPoolVersion(Issue issue, String fixVersion) {
-        var majorVersion = majorVersion(fixVersion);
-        if (majorVersion.isEmpty()) {
-            return false;
-        }
-        var poolVersion = majorVersion.get() + "-pool";
-        var openVersion = majorVersion.get() + "-open";
-
-        var nonScratch = fixVersions(issue).stream()
-                                           .filter(this::isNonScratchVersion)
-                                           .collect(Collectors.toList());
-        return nonScratch.size() == 1 && (nonScratch.get(0).equals(poolVersion) || nonScratch.get(0).equals(openVersion));
-    }
-
-    /**
-     * Return true if fixVersionList is empty or contains only scratch values.
-     */
-    private boolean matchScratchVersion(Issue issue) {
-        var nonScratch = fixVersions(issue).stream()
-                                           .filter(this::isNonScratchVersion)
-                                           .collect(Collectors.toList());
-        return nonScratch.size() == 0;
-    }
-
-    private final static Set<String> propagatedCustomProperties =
-            Set.of("customfield_10008", "customfield_10000", "customfield_10005");
-
-    /**
-     * Create a backport of issue.
-     */
-    private Issue createBackportIssue(Issue primary) throws NonRetriableException {
-        var filteredProperties = primary.properties().entrySet().stream()
-                .filter(entry -> !entry.getKey().startsWith("customfield_") || propagatedCustomProperties.contains(entry.getKey()))
-                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
-
-        var finalProperties = new HashMap<>(filteredProperties);
-        finalProperties.put("issuetype", JSON.of("Backport"));
-
-        try {
-            var backport = primary.project().createIssue(primary.title(), primary.body().lines().collect(Collectors.toList()), finalProperties);
-
-            var backportLink = Link.create(backport, "backported by").build();
-            primary.addLink(backportLink);
-            return backport;
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    /**
-     * Return issue or one of its backports that applies to fixVersion.
-     *
-     * If the main issue       has the correct fixVersion, use it.
-     * If an existing Backport has the correct fixVersion, use it.
-     * If the main issue       has a matching <N>-pool/open fixVersion, use it.
-     * If an existing Backport has a matching <N>-pool/open fixVersion, use it.
-     * If the main issue       has a "scratch" fixVersion, use it.
-     * If an existing Backport has a "scratch" fixVersion, use it.
-     *
-     * Otherwise, create a new Backport.
-     *
-     * A "scratch" fixVersion is empty, "tbd.*", or "unknown".
-     */
-    private Issue findIssue(Issue primary, String fixVersion) throws NonRetriableException {
-        log.info("Searching for properly versioned issue for primary issue " + primary.id());
-        var candidates = Stream.concat(Stream.of(primary), findBackports(primary).stream()).collect(Collectors.toList());
-        candidates.forEach(c -> log.fine("Candidate: " + c.id() + " with versions: " + String.join(",", fixVersions(c))));
-        var matchingVersionIssue = candidates.stream()
-                .filter(i -> matchVersion(i, fixVersion))
-                .findFirst();
-        if (matchingVersionIssue.isPresent()) {
-            log.info("Issue " + matchingVersionIssue.get().id() + " has a correct fixVersion");
-            return matchingVersionIssue.get();
-        }
-
-        var matchingPoolVersionIssue = candidates.stream()
-                .filter(i -> matchPoolVersion(i, fixVersion))
-                .findFirst();
-        if (matchingPoolVersionIssue.isPresent()) {
-            log.info("Issue " + matchingPoolVersionIssue.get().id() + " has a matching pool version");
-            return matchingPoolVersionIssue.get();
-        }
-
-        var matchingScratchVersionIssue = candidates.stream()
-                .filter(this::matchScratchVersion)
-                .findFirst();
-        if (matchingScratchVersionIssue.isPresent()) {
-            log.info("Issue " + matchingScratchVersionIssue.get().id() + " has a scratch fixVersion");
-            return matchingScratchVersionIssue.get();
-        }
-
-        log.info("Creating new backport for " + primary.id());
-        return createBackportIssue(primary);
-    }
-
-    private Optional<String> findIssueUsername(Commit commit) {
-        var authorEmail = EmailAddress.from(commit.author().email());
-        if (authorEmail.domain().equals("openjdk.org")) {
-            return Optional.of(authorEmail.localPart());
-        }
-
-        var committerEmail = EmailAddress.from(commit.committer().email());
-        if (!committerEmail.domain().equals("openjdk.org")) {
-            log.severe("Cannot determine issue tracker user name from committer email: " + committerEmail);
-            return Optional.empty();
-        }
-        return Optional.of(committerEmail.localPart());
-    }
-
-    @Override
-    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        for (var commit : commits) {
-            var commitNotification = CommitFormatters.toTextBrief(repository, commit);
-            var commitMessage = CommitMessageParsers.v1.parse(commit);
-            for (var commitIssue : commitMessage.issues()) {
-                var optionalIssue = issueProject.issue(commitIssue.shortId());
-                if (optionalIssue.isEmpty()) {
-                    log.severe("Cannot update issue " + commitIssue.id() + " with commit " + commit.hash().abbreviate()
-                                       + " - issue not found in issue project");
-                    continue;
-                }
-                var issue = optionalIssue.get();
-
-                // We only update primary type issues
-                if (!isPrimaryIssue(issue)) {
-                    log.severe("Issue " + issue.id() + " isn't of a primary type - ignoring");
-                    // TODO: search for the primary issue
-                    continue;
-                }
-
-                String requestedVersion = null;
-                if (prOnly) {
-                    var candidates = repository.findPullRequestsWithComment(null, "Pushed as commit " + commit.hash() + ".");
-                    if (candidates.size() != 1) {
-                        log.info("IssueUpdater@" + issue.id() + ": Skipping commit " + commit.hash().abbreviate() + " for repository " + repository.name() +
-                                         " on branch " + branch.name() + " - " + candidates.size() + " matching PRs found (needed 1)");
-                        continue;
-                    }
-                    var candidate = candidates.get(0);
-                    var prLink = candidate.webUrl();
-                    if (!candidate.targetRef().equals(branch.name())) {
-                        log.info("IssueUpdater@" + issue.id() + ": Pull request " + prLink + " targets " + candidate.targetRef() + " - commit is on " + branch.toString() + " - skipping");
-                        continue;
-                    }
-                } else {
-                    // The actual issue to be updated can change depending on the fix version
-                    if (setFixVersion) {
-                        requestedVersion = fixVersions != null ? fixVersions.getOrDefault(branch.name(), null) : null;
-                        if (requestedVersion == null) {
-                            try {
-                                var conf = localRepository.lines(Path.of(".jcheck/conf"), commit.hash());
-                                if (conf.isPresent()) {
-                                    var parsed = JCheckConfiguration.parse(conf.get());
-                                    var version = parsed.general().version();
-                                    requestedVersion = version.orElse(null);
-                                }
-                            } catch (IOException e) {
-                                throw new RuntimeException(e);
-                            }
-                        }
-
-                        if (requestedVersion != null) {
-                            issue = findIssue(issue, requestedVersion);
-                        }
-                    }
-                }
-
-                var existingComments = issue.comments();
-                var hashUrl = repository.webUrl(commit.hash()).toString();
-                var alreadyPostedComment = existingComments.stream()
-                                                           .filter(comment -> comment.author().equals(issueProject.issueTracker().currentUser()))
-                                                           .anyMatch(comment -> comment.body().contains(hashUrl));
-                if (!alreadyPostedComment) {
-                    issue.addComment(commitNotification);
-                }
-                if (issue.state() == Issue.State.OPEN) {
-                    issue.setState(Issue.State.RESOLVED);
-                    if (issue.assignees().isEmpty()) {
-                        var username = findIssueUsername(commit);
-                        if (username.isPresent()) {
-                            var assignee = issueProject.issueTracker().user(username.get());
-                            if (assignee.isPresent()) {
-                                issue.setAssignees(List.of(assignee.get()));
-                            }
-                        }
-                    }
-                }
-
-                if (commitLink) {
-                    var linkBuilder = Link.create(repository.webUrl(commit.hash()), "Commit")
-                                          .summary(repository.name() + "/" + commit.hash().abbreviate());
-                    if (commitIcon != null) {
-                        linkBuilder.iconTitle("Commit");
-                        linkBuilder.iconUrl(commitIcon);
-                    }
-                    issue.addLink(linkBuilder.build());
-                }
-
-                if (setFixVersion) {
-                    if (requestedVersion != null) {
-                        issue.setProperty("fixVersions", JSON.of(requestedVersion));
-                    }
-                }
-            }
-        }
-    }
-
-    @Override
-    public String name() {
-        return "issue";
-    }
-
-    @Override
-    public void handleNewIssue(PullRequest pr, org.openjdk.skara.vcs.openjdk.Issue issue) {
-        var realIssue = issueProject.issue(issue.shortId());
-        if (realIssue.isEmpty()) {
-            log.warning("Pull request " + pr + " added unknown issue: " + issue.id());
-            return;
-        }
-
-        if (reviewLink) {
-            var linkBuilder = Link.create(pr.webUrl(), "Review")
-                                  .summary(pr.repository().name() + "/" + pr.id());
-            if (reviewIcon != null) {
-                linkBuilder.iconTitle("Review");
-                linkBuilder.iconUrl(reviewIcon);
-            }
-
-            realIssue.get().addLink(linkBuilder.build());
-        }
-    }
-
-    @Override
-    public void handleRemovedIssue(PullRequest pr, org.openjdk.skara.vcs.openjdk.Issue issue) {
-        var realIssue = issueProject.issue(issue.shortId());
-        if (realIssue.isEmpty()) {
-            log.warning("Pull request " + pr + " removed unknown issue: " + issue.id());
-            return;
-        }
-
-        var link = Link.create(pr.webUrl(), "").build();
-        realIssue.get().removeLink(link);
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdaterBuilder.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdaterBuilder.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/IssueUpdaterBuilder.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.issuetracker.IssueProject;
-
-import java.net.URI;
-import java.util.Map;
-
-public class IssueUpdaterBuilder {
-    private IssueProject issueProject;
-    private boolean reviewLink = true;
-    private URI reviewIcon = null;
-    private boolean commitLink = true;
-    private URI commitIcon = null;
-    private boolean setFixVersion = false;
-    private Map<String, String> fixVersions = null;
-    private boolean prOnly = false;
-
-    public IssueUpdaterBuilder issueProject(IssueProject issueProject) {
-        this.issueProject = issueProject;
-        return this;
-    }
-
-    public IssueUpdaterBuilder reviewLink(boolean reviewLink) {
-        this.reviewLink = reviewLink;
-        return this;
-    }
-
-    public IssueUpdaterBuilder reviewIcon(URI reviewIcon) {
-        this.reviewIcon = reviewIcon;
-        return this;
-    }
-
-    public IssueUpdaterBuilder commitLink(boolean commitLink) {
-        this.commitLink = commitLink;
-        return this;
-    }
-
-    public IssueUpdaterBuilder commitIcon(URI commitIcon) {
-        this.commitIcon = commitIcon;
-        return this;
-    }
-
-    public IssueUpdaterBuilder setFixVersion(boolean setFixVersion) {
-        if (setFixVersion && prOnly) {
-            throw new IllegalArgumentException("Cannot combine setFixVersion with prOnly");
-        }
-        this.setFixVersion = setFixVersion;
-        return this;
-    }
-
-    public IssueUpdaterBuilder fixVersions(Map<String, String> fixVersions) {
-        this.fixVersions = fixVersions;
-        return this;
-    }
-
-    public IssueUpdaterBuilder prOnly(boolean prOnly) {
-        if (prOnly && setFixVersion) {
-            throw new IllegalArgumentException("Cannot combine prOnly with setFixVersion");
-        }
-        this.prOnly = prOnly;
-        return this;
-    }
-
-    public IssueUpdater build() {
-        return new IssueUpdater(issueProject, reviewLink, reviewIcon, commitLink, commitIcon, setFixVersion, fixVersions, prOnly);
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdateWriter.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdateWriter.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdateWriter.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.json.*;
-
-import java.io.*;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.*;
-import java.util.UUID;
-
-public class JsonUpdateWriter implements AutoCloseable {
-
-    private int sequence = 0;
-    private final String baseName;
-    private final Path path;
-    private JSONArray current;
-
-    private void flush() {
-        var tempName = path.resolve(String.format("%s.%03d.temp", baseName, sequence));
-        var finalName = path.resolve(String.format("%s.%03d.json", baseName, sequence));
-
-        try {
-            Files.write(tempName, current.toString().getBytes(StandardCharsets.UTF_8));
-            Files.move(tempName, finalName);
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-
-        sequence++;
-        current = JSON.array();
-    }
-
-    JsonUpdateWriter(Path path, String projectName) {
-        this.path = path;
-
-        var uuid = UUID.randomUUID();
-        baseName = "jbs." + projectName.replace("/", ".") + "." + uuid.toString().replace("-", "");
-        current = JSON.array();
-    }
-
-    public void write(JSONObject obj) {
-        current.add(obj);
-        if (current.size() > 100) {
-            flush();
-        }
-    }
-
-    @Override
-    public void close() {
-        if (current.size() > 0) {
-            flush();
-        }
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/JsonUpdater.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.forge.HostedRepository;
-import org.openjdk.skara.json.*;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.*;
-
-import java.nio.file.Path;
-import java.time.format.DateTimeFormatter;
-import java.util.*;
-
-public class JsonUpdater implements RepositoryUpdateConsumer {
-    private final Path path;
-    private final String version;
-    private final String defaultBuild;
-
-    JsonUpdater(Path path, String version, String defaultBuild) {
-        this.path = path;
-        this.version = version;
-        this.defaultBuild = defaultBuild;
-    }
-
-    private JSONObject commitToChanges(HostedRepository repository, Repository localRepository, Commit commit, String build) {
-        var ret = JSON.object();
-        ret.put("url",  repository.webUrl(commit.hash()).toString()); //FIXME
-        ret.put("version", version);
-        ret.put("build", build);
-
-        var parsedMessage = CommitMessageParsers.v1.parse(commit);
-        var issueIds = JSON.array();
-        for (var issue : parsedMessage.issues()) {
-            issueIds.add(JSON.of(issue.shortId()));
-        }
-        ret.put("issue", issueIds);
-        ret.put("user", commit.author().name());
-        ret.put("date", commit.date().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss +0000")));
-
-        return ret;
-    }
-
-    private JSONObject issuesToChanges(HostedRepository repository, Repository localRepository, List<Issue> issues, String build) {
-        var ret = JSON.object();
-        ret.put("version", version);
-        ret.put("build", build);
-
-        var issueIds = JSON.array();
-        for (var issue : issues) {
-            issueIds.add(JSON.of(issue.shortId()));
-        }
-
-        ret.put("issue", issueIds);
-
-        return ret;
-    }
-
-    @Override
-    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        try (var writer = new JsonUpdateWriter(path, repository.name())) {
-            for (var commit : commits) {
-                var json = commitToChanges(repository, localRepository, commit, defaultBuild);
-                writer.write(json);
-            }
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    @Override
-    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
-        var build = String.format("b%02d", tag.buildNum());
-        try (var writer = new JsonUpdateWriter(path, repository.name())) {
-            var issues = new ArrayList<Issue>();
-            for (var commit : commits) {
-                var parsedMessage = CommitMessageParsers.v1.parse(commit);
-                issues.addAll(parsedMessage.issues());
-            }
-            var json = issuesToChanges(repository, localRepository, issues, build);
-            writer.write(json);
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    @Override
-    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) {
-    }
-
-    @Override
-    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
-    }
-
-    @Override
-    public String name() {
-        return "json";
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdater.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.email.*;
-import org.openjdk.skara.forge.*;
-import org.openjdk.skara.mailinglist.MailingList;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
-
-import java.io.*;
-import java.time.format.DateTimeFormatter;
-import java.util.*;
-import java.util.logging.Logger;
-import java.util.regex.Pattern;
-
-public class MailingListUpdater implements RepositoryUpdateConsumer {
-    private final MailingList list;
-    private final EmailAddress recipient;
-    private final EmailAddress sender;
-    private final EmailAddress author;
-    private final boolean includeBranch;
-    private final boolean reportNewTags;
-    private final boolean reportNewBranches;
-    private final boolean reportNewBuilds;
-    private final Mode mode;
-    private final Map<String, String> headers;
-    private final Pattern allowedAuthorDomains;
-    private final Logger log = Logger.getLogger("org.openjdk.skara.bots.notify");
-
-    enum Mode {
-        ALL,
-        PR
-    }
-
-    MailingListUpdater(MailingList list, EmailAddress recipient, EmailAddress sender, EmailAddress author,
-                       boolean includeBranch, boolean reportNewTags, boolean reportNewBranches, boolean reportNewBuilds,
-                       Mode mode, Map<String, String> headers, Pattern allowedAuthorDomains) {
-        this.list = list;
-        this.recipient = recipient;
-        this.sender = sender;
-        this.author = author;
-        this.includeBranch = includeBranch;
-        this.reportNewTags = reportNewTags;
-        this.reportNewBranches = reportNewBranches;
-        this.reportNewBuilds = reportNewBuilds;
-        this.mode = mode;
-        this.headers = headers;
-        this.allowedAuthorDomains = allowedAuthorDomains;
-    }
-
-    static MailingListUpdaterBuilder newBuilder() {
-        return new MailingListUpdaterBuilder();
-    }
-
-    private String tagAnnotationToText(HostedRepository repository, Tag.Annotated annotation) {
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        printer.println("Tagged by: " + annotation.author().name() + " <" + annotation.author().email() + ">");
-        printer.println("Date:      " + annotation.date().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss +0000")));
-        printer.println();
-        printer.print(String.join("\n", annotation.message()));
-
-        return writer.toString();
-    }
-
-    private EmailAddress filteredAuthor(EmailAddress commitAddress) {
-        if (author != null) {
-            return author;
-        }
-        var allowedAuthorMatcher = allowedAuthorDomains.matcher(commitAddress.domain());
-        if (!allowedAuthorMatcher.matches()) {
-            return sender;
-        } else {
-            return commitAddress;
-        }
-    }
-
-    private EmailAddress commitToAuthor(Commit commit) {
-        return filteredAuthor(EmailAddress.from(commit.committer().name(), commit.committer().email()));
-    }
-
-    private EmailAddress annotationToAuthor(Tag.Annotated annotation) {
-        return filteredAuthor(EmailAddress.from(annotation.author().name(), annotation.author().email()));
-    }
-
-    private String commitsToSubject(HostedRepository repository, List<Commit> commits, Branch branch) {
-        var subject = new StringBuilder();
-        subject.append(repository.repositoryType().shortName());
-        subject.append(": ");
-        subject.append(repository.name());
-        subject.append(": ");
-        if (includeBranch) {
-            subject.append(branch.name());
-            subject.append(": ");
-        }
-        if (commits.size() > 1) {
-            subject.append(commits.size());
-            subject.append(" new changesets");
-        } else {
-            subject.append(commits.get(0).message().get(0));
-        }
-        return subject.toString();
-    }
-
-    private String tagToSubject(HostedRepository repository, Hash hash, Tag tag) {
-        return repository.repositoryType().shortName() +
-                ": " +
-                repository.name() +
-                ": Added tag " +
-                tag +
-                " for changeset " +
-                hash.abbreviate();
-    }
-
-    private List<Commit> filterPrCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        var ret = new ArrayList<Commit>();
-        var mergedHashes = new HashSet<Hash>();
-
-        for (var commit : commits) {
-            if (mergedHashes.contains(commit.hash())) {
-                log.info("Commit " + commit.hash() + " belongs to a merge PR - skipping");
-                continue;
-            }
-
-            var candidates = repository.findPullRequestsWithComment(null, "Pushed as commit " + commit.hash() + ".");
-            if (candidates.size() != 1) {
-                log.warning("Commit " + commit.hash() + " matches " + candidates.size() + " pull requests - expected 1");
-                ret.add(commit);
-                continue;
-            }
-
-            var candidate = candidates.get(0);
-            var prLink = candidate.webUrl();
-            if (!candidate.targetRef().equals(branch.name())) {
-                log.info("Pull request " + prLink + " targets " + candidate.targetRef() + " - commit is on " + branch.toString() + " - skipping");
-                ret.add(commit);
-                continue;
-            }
-
-            // For a merge PR, many other of these commits could belong here as well
-            try {
-                localRepository.fetch(repository.url(), candidate.fetchRef());
-                var baseHash = PullRequestUtils.baseHash(candidate, localRepository);
-                var prCommits = localRepository.commitMetadata(baseHash, candidate.headHash());
-                prCommits.forEach(prCommit -> mergedHashes.add(prCommit.hash()));
-            } catch (IOException e) {
-                log.warning("Could not fetch commits from " + prLink + " - cannot see if the belong to the PR");
-            }
-        }
-
-        return ret;
-    }
-
-    private void sendCombinedCommits(HostedRepository repository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        if (commits.size() == 0) {
-            return;
-        }
-
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        for (var commit : commits) {
-            printer.println(CommitFormatters.toText(repository, commit));
-        }
-
-        var subject = commitsToSubject(repository, commits, branch);
-        var lastCommit = commits.get(commits.size() - 1);
-        var commitAddress = filteredAuthor(EmailAddress.from(lastCommit.committer().name(), lastCommit.committer().email()));
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .author(commitAddress)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, commits))
-                         .build();
-
-        try {
-            list.post(email);
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    private Map<String, String> commitHeaders(HostedRepository repository, List<Commit> commits) {
-        var ret = new HashMap<String, String>();
-        ret.put("X-Git-URL", repository.webUrl().toString());
-        if (!commits.isEmpty()) {
-            ret.put("X-Git-Changeset", commits.get(0).hash().hex());
-        }
-        return ret;
-    }
-
-    @Override
-    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        if (mode == Mode.PR) {
-            commits = filterPrCommits(repository, localRepository, commits, branch);
-        }
-        sendCombinedCommits(repository, commits, branch);
-    }
-
-    @Override
-    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
-        if (!reportNewTags) {
-            return;
-        }
-        if (!reportNewBuilds) {
-            handleTagCommit(repository, localRepository, commits.get(commits.size() - 1), tag.tag(), annotation);
-            return;
-        }
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        var taggedCommit = commits.get(commits.size() - 1);
-        if (annotation != null) {
-            printer.println(tagAnnotationToText(repository, annotation));
-        }
-        printer.println(CommitFormatters.toTextBrief(repository, taggedCommit));
-
-        printer.println("The following commits are included in " + tag.tag());
-        printer.println("========================================================");
-        for (var commit : commits) {
-            printer.print(commit.hash().abbreviate());
-            if (commit.message().size() > 0) {
-                printer.print(": " + commit.message().get(0));
-            }
-            printer.println();
-        }
-
-        var subject = tagToSubject(repository, taggedCommit.hash(), tag.tag());
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, commits));
-
-        if (annotation != null) {
-            email.author(annotationToAuthor(annotation));
-        } else {
-            email.author(commitToAuthor(taggedCommit));
-        }
-
-        try {
-            list.post(email.build());
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    @Override
-    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) throws NonRetriableException {
-        if (!reportNewTags) {
-            return;
-        }
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        if (annotation != null) {
-            printer.println(tagAnnotationToText(repository, annotation));
-        }
-        printer.println(CommitFormatters.toTextBrief(repository, commit));
-
-        var subject = tagToSubject(repository, commit.hash(), tag);
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, List.of(commit)));
-
-        if (annotation != null) {
-            email.author(annotationToAuthor(annotation));
-        } else {
-            email.author(commitToAuthor(commit));
-        }
-
-        try {
-            list.post(email.build());
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    private String newBranchSubject(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
-        var subject = new StringBuilder();
-        subject.append(repository.repositoryType().shortName());
-        subject.append(": ");
-        subject.append(repository.name());
-        subject.append(": created branch ");
-        subject.append(branch);
-        subject.append(" based on the branch ");
-        subject.append(parent);
-        subject.append(" containing ");
-        subject.append(commits.size());
-        subject.append(" unique commit");
-        if (commits.size() != 1) {
-            subject.append("s");
-        }
-
-        return subject.toString();
-    }
-
-    @Override
-    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) throws NonRetriableException {
-        if (!reportNewBranches) {
-            return;
-        }
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        if (commits.size() > 0) {
-            printer.println("The following commits are unique to the " + branch.name() + " branch:");
-            printer.println("========================================================");
-            for (var commit : commits) {
-                printer.print(commit.hash().abbreviate());
-                if (commit.message().size() > 0) {
-                    printer.print(": " + commit.message().get(0));
-                }
-                printer.println();
-            }
-        } else {
-            printer.println("The new branch " + branch.name() + " is currently identical to the " + parent.name() + " branch.");
-        }
-
-        var subject = newBranchSubject(repository, localRepository, commits, parent, branch);
-        var finalAuthor = commits.size() > 0 ? commitToAuthor(commits.get(commits.size() - 1)) : sender;
-
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .author(finalAuthor)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, commits))
-                         .build();
-        try {
-            list.post(email);
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    @Override
-    public String name() {
-        return "ml";
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdaterBuilder.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdaterBuilder.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/MailingListUpdaterBuilder.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.email.EmailAddress;
-import org.openjdk.skara.mailinglist.MailingList;
-
-import java.util.Map;
-import java.util.regex.Pattern;
-
-public class MailingListUpdaterBuilder {
-    private MailingList list;
-    private EmailAddress recipient;
-    private EmailAddress sender;
-    private EmailAddress author = null;
-    private boolean includeBranch = false;
-    private boolean reportNewTags = true;
-    private boolean reportNewBranches = true;
-    private boolean reportNewBuilds = true;
-    private MailingListUpdater.Mode mode = MailingListUpdater.Mode.ALL;
-    private Map<String, String> headers = Map.of();
-    private Pattern allowedAuthorDomains = Pattern.compile(".*");
-    private boolean repoInSubject = false;
-    private Pattern branchInSubject = Pattern.compile("a^"); // Does not match anything
-
-    public MailingListUpdaterBuilder list(MailingList list) {
-        this.list = list;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder recipient(EmailAddress recipient) {
-        this.recipient = recipient;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder sender(EmailAddress sender) {
-        this.sender = sender;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder author(EmailAddress author) {
-        this.author = author;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder includeBranch(boolean includeBranch) {
-        this.includeBranch = includeBranch;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder reportNewTags(boolean reportNewTags) {
-        this.reportNewTags = reportNewTags;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder reportNewBranches(boolean reportNewBranches) {
-        this.reportNewBranches = reportNewBranches;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder reportNewBuilds(boolean reportNewBuilds) {
-        this.reportNewBuilds = reportNewBuilds;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder mode(MailingListUpdater.Mode mode) {
-        this.mode = mode;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder headers(Map<String, String> headers) {
-        this.headers = headers;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder allowedAuthorDomains(Pattern allowedAuthorDomains) {
-        this.allowedAuthorDomains = allowedAuthorDomains;
-        return this;
-    }
-
-    public MailingListUpdater build() {
-        return new MailingListUpdater(list, recipient, sender, author, includeBranch, reportNewTags, reportNewBranches,
-                                      reportNewBuilds, mode, headers, allowedAuthorDomains);
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/Notifier.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/Notifier.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/Notifier.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.bot.BotConfiguration;
+import org.openjdk.skara.json.JSONObject;
+
+public interface Notifier {
+    String name();
+
+    static Notifier create(String name, BotConfiguration botConfiguration, JSONObject notifierConfiguration) {
+        var factory = NotifierFactory.getNotifierFactories().stream()
+                .filter(f -> f.name().equals(name))
+                .findFirst();
+        if (factory.isEmpty()) {
+            throw new RuntimeException("No notifier factory named '" + name + "' found - check module path");
+        }
+        return factory.get().create(botConfiguration, notifierConfiguration);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifierFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifierFactory.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifierFactory.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.openjdk.skara.bot.BotConfiguration;
+import org.openjdk.skara.json.JSONObject;
+
+import java.util.*;
+import java.util.stream.*;
+
+public interface NotifierFactory {
+    /**
+     * A user-friendly name for the given notifier, used for configuration section naming. Should be lower case.
+     * @return
+     */
+    String name();
+
+    /**
+     * Creates instances of this notifier according to the provided configuration.
+     * @return
+     */
+    Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration);
+
+    static List<NotifierFactory> getNotifierFactories() {
+        return StreamSupport.stream(ServiceLoader.load(NotifierFactory.class).spliterator(), false)
+                .collect(Collectors.toList());
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBot.java
@@ -29,11 +29,11 @@
 import java.nio.file.Path;
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
 
-class NotifyBot implements Bot {
+public class NotifyBot implements Bot {
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots");;
     private final HostedRepository repository;
     private final Path storagePath;
     private final Pattern branches;
     private final StorageBuilder<UpdatedTag> tagStorageBuilder;
@@ -60,11 +60,11 @@
         this.updateCache = new PullRequestUpdateCache();
         this.readyLabels = readyLabels;
         this.readyComments = readyComments;
     }
 
-    static NotifyBotBuilder newBuilder() {
+    public static NotifyBotBuilder newBuilder() {
         return new NotifyBotBuilder();
     }
 
     private boolean isReady(PullRequest pr) {
         var labels = new HashSet<>(pr.labels());
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/NotifyBotFactory.java
@@ -21,19 +21,13 @@
  * questions.
  */
 package org.openjdk.skara.bots.notify;
 
 import org.openjdk.skara.bot.*;
-import org.openjdk.skara.email.EmailAddress;
 import org.openjdk.skara.json.*;
-import org.openjdk.skara.mailinglist.MailingListServerFactory;
-import org.openjdk.skara.network.URIBuilder;
 import org.openjdk.skara.storage.StorageBuilder;
 
-import java.net.URI;
-import java.nio.file.Path;
-import java.time.Duration;
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
@@ -43,10 +37,23 @@
     @Override
     public String name() {
         return "notify";
     }
 
+    private JSONObject combineConfiguration(JSONObject global, JSONObject specific) {
+        var ret = new JSONObject();
+        if (global != null) {
+            for (var globalField : global.fields()) {
+                ret.put(globalField.name(), globalField.value());
+            }
+        }
+        for (var specificField : specific.fields()) {
+            ret.put(specificField.name(), specificField.value());
+        }
+        return ret;
+    }
+
     @Override
     public List<Bot> create(BotConfiguration configuration) {
         var ret = new ArrayList<Bot>();
         var specific = configuration.specific();
 
@@ -62,135 +69,52 @@
         var readyComments = specific.get("ready").get("comments").stream()
                                     .map(JSONValue::asObject)
                                     .collect(Collectors.toMap(obj -> obj.get("user").asString(),
                                                               obj -> Pattern.compile(obj.get("pattern").asString())));
 
-        URI reviewIcon = null;
-        if (specific.contains("reviews")) {
-            if (specific.get("reviews").contains("icon")) {
-                reviewIcon = URI.create(specific.get("reviews").get("icon").asString());
-            }
-        }
-        URI commitIcon = null;
-        if (specific.contains("commits")) {
-            if (specific.get("commits").contains("icon")) {
-                commitIcon = URI.create(specific.get("commits").get("icon").asString());
+        // Collect configuration applicable to all instances of a specific notifier
+        var notifierFactories = NotifierFactory.getNotifierFactories();
+        notifierFactories.forEach(notifierFactory -> log.info("Available notifier: " + notifierFactory.name()));
+        var notifierConfiguration = new HashMap<String, JSONObject>();
+        for (var notifierFactory : notifierFactories) {
+            if (specific.contains(notifierFactory.name())) {
+                notifierConfiguration.put(notifierFactory.name(), specific.get(notifierFactory.name()).asObject());
             }
         }
+
         for (var repo : specific.get("repositories").fields()) {
             var repoName = repo.name();
             var branchPattern = Pattern.compile("^master$");
             if (repo.value().contains("branches")) {
                 branchPattern = Pattern.compile(repo.value().get("branches").asString());
             }
 
             var updaters = new ArrayList<RepositoryUpdateConsumer>();
             var prUpdaters = new ArrayList<PullRequestUpdateConsumer>();
-            if (repo.value().contains("json")) {
-                var folder = repo.value().get("folder").asString();
-                var build = repo.value().get("build").asString();
-                var version = repo.value().get("version").asString();
-                updaters.add(new JsonUpdater(Path.of(folder), version, build));
-            }
-
-            if (repo.value().contains("slack")) {
-                var slackConf = repo.value().get("slack");
-                URI prWebhook = null;
-                if (slackConf.contains("pr")) {
-                    prWebhook = URIBuilder.base(slackConf.get("pr").asString()).build();
-                }
-                URI commitWebhook = null;
-                if (slackConf.contains("commit")) {
-                    commitWebhook = URIBuilder.base(slackConf.get("commit").asString()).build();
-                }
-                var username = slackConf.get("username").asString();
-                var updater = new SlackUpdater(prWebhook, commitWebhook, username);
-                updaters.add(updater);
-                prUpdaters.add(updater);
-            }
-
-            if (repo.value().contains("mailinglists")) {
-                var email = specific.get("email").asObject();
-                var smtp = email.get("smtp").asString();
-                var sender = EmailAddress.parse(email.get("sender").asString());
-                var archive = URIBuilder.base(email.get("archive").asString()).build();
-                var interval = email.contains("interval") ? Duration.parse(email.get("interval").asString()) : Duration.ofSeconds(1);
-                var listServer = MailingListServerFactory.createMailmanServer(archive, smtp, interval);
-
-                for (var mailinglist : repo.value().get("mailinglists").asArray()) {
-                    var recipient = mailinglist.get("recipient").asString();
-                    var recipientAddress = EmailAddress.parse(recipient);
-
-                    var author = mailinglist.contains("author") ? EmailAddress.parse(mailinglist.get("author").asString()) : null;
-                    var allowedDomains = author == null ? Pattern.compile(mailinglist.get("domains").asString()) : null;
 
-                    var mailingListUpdaterBuilder = MailingListUpdater.newBuilder()
-                                                                      .list(listServer.getList(recipient))
-                                                                      .recipient(recipientAddress)
-                                                                      .sender(sender)
-                                                                      .author(author)
-                                                                      .allowedAuthorDomains(allowedDomains);
-
-                    if (mailinglist.contains("mode")) {
-                        var mode = MailingListUpdater.Mode.ALL;
-                        switch (mailinglist.get("mode").asString()) {
-                            case "pr":
-                                mode = MailingListUpdater.Mode.PR;
-                                break;
-                            default:
-                                throw new RuntimeException("Unknown mode");
-                        }
-                        mailingListUpdaterBuilder.mode(mode);
-                    }
-                    if (mailinglist.contains("headers")) {
-                        mailingListUpdaterBuilder.headers(mailinglist.get("headers").fields().stream()
-                                                                     .collect(Collectors.toMap(JSONObject.Field::name,
-                                                                                               field -> field.value().asString())));
-                    }
-                    if (mailinglist.contains("branchnames")) {
-                        mailingListUpdaterBuilder.includeBranch(mailinglist.get("branchnames").asBoolean());
+            for (var notifierFactory : notifierFactories) {
+                if (repo.value().contains(notifierFactory.name())) {
+                    var confArray = repo.value().get(notifierFactory.name());
+                    if (!confArray.isArray()) {
+                        confArray = JSON.array().add(confArray);
                     }
-                    if (mailinglist.contains("tags")) {
-                        mailingListUpdaterBuilder.reportNewTags(mailinglist.get("tags").asBoolean());
-                    }
-                    if (mailinglist.contains("branches")) {
-                        mailingListUpdaterBuilder.reportNewBranches(mailinglist.get("branches").asBoolean());
-                    }
-                    if (mailinglist.contains("builds")) {
-                        mailingListUpdaterBuilder.reportNewBuilds(mailinglist.get("builds").asBoolean());
+                    for (var conf : confArray.asArray()) {
+                        var finalConfiguration = combineConfiguration(notifierConfiguration.get(notifierFactory.name()), conf.asObject());
+                        var notifier = Notifier.create(notifierFactory.name(), configuration, finalConfiguration);
+                        log.info("Configuring notifier " + notifierFactory.name() + " for repository " + repoName);
+                        if (notifier instanceof PullRequestUpdateConsumer) {
+                            prUpdaters.add((PullRequestUpdateConsumer)notifier);
+                        }
+                        if (notifier instanceof RepositoryUpdateConsumer) {
+                            updaters.add((RepositoryUpdateConsumer)notifier);
+                        }
                     }
-
-                    updaters.add(mailingListUpdaterBuilder.build());
-                }
-            }
-            if (repo.value().contains("issues")) {
-                var issuesConf = repo.value().get("issues");
-                var issueProject = configuration.issueProject(issuesConf.get("project").asString());
-                var issueUpdaterBuilder = IssueUpdater.newBuilder()
-                                                      .issueProject(issueProject);
-
-                if (issuesConf.contains("reviewlink")) {
-                    issueUpdaterBuilder.reviewLink(issuesConf.get("reviewlink").asBoolean());
-                }
-                if (issuesConf.contains("commitlink")) {
-                    issueUpdaterBuilder.commitLink(issuesConf.get("commitlink").asBoolean());
-                }
-                if (issuesConf.contains("fixversions")) {
-                    issueUpdaterBuilder.setFixVersion(true);
-                    issueUpdaterBuilder.fixVersions(issuesConf.get("fixversions").fields().stream()
-                                                              .collect(Collectors.toMap(JSONObject.Field::name,
-                                                                                        f -> f.value().asString())));
-                }
-                if (issuesConf.contains("pronly")) {
-                    issueUpdaterBuilder.prOnly(issuesConf.get("pronly").asBoolean());
                 }
-                updaters.add(issueUpdaterBuilder.build());
-                prUpdaters.add(issueUpdaterBuilder.build());
             }
 
-            if (updaters.isEmpty()) {
-                log.warning("No consumers configured for notify bot repository: " + repoName);
+            if (updaters.isEmpty() && prUpdaters.isEmpty()) {
+                log.warning("No notifiers configured for notify bot repository: " + repoName);
                 continue;
             }
 
             var baseName = repo.value().contains("basename") ? repo.value().get("basename").asString() : configuration.repositoryName(repoName);
 
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestUpdateConsumer.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestUpdateConsumer.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestUpdateConsumer.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/PullRequestUpdateConsumer.java
@@ -23,11 +23,11 @@
 package org.openjdk.skara.bots.notify;
 
 import org.openjdk.skara.forge.PullRequest;
 import org.openjdk.skara.vcs.openjdk.Issue;
 
-public interface PullRequestUpdateConsumer {
+public interface PullRequestUpdateConsumer extends Notifier {
     default void handleNewIssue(PullRequest pr, Issue issue) {
     }
     default void handleRemovedIssue(PullRequest pr, Issue issue) {
     }
     default void handleNewPullRequest(PullRequest pr) {
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryUpdateConsumer.java
@@ -26,11 +26,11 @@
 import org.openjdk.skara.vcs.*;
 import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
 
 import java.util.List;
 
-public interface RepositoryUpdateConsumer {
+public interface RepositoryUpdateConsumer extends Notifier {
     default void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
     }
     default void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotated) throws NonRetriableException {
     }
     default void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) throws NonRetriableException {
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/SlackUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/SlackUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/SlackUpdater.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.openjdk.skara.forge.HostedRepository;
-import org.openjdk.skara.forge.PullRequest;
-import org.openjdk.skara.json.*;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.network.*;
-
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.net.URI;
-import java.util.List;
-import java.time.format.DateTimeFormatter;
-
-public class SlackUpdater implements RepositoryUpdateConsumer, PullRequestUpdateConsumer {
-    private final RestRequest prWebhook;
-    private final RestRequest commitWebhook;
-    private final String username;
-
-    public SlackUpdater(URI prWebhook, URI commitWebhook, String username) {
-        this.prWebhook = prWebhook != null ? new RestRequest(prWebhook) : null;
-        this.commitWebhook = commitWebhook != null ? new RestRequest(commitWebhook) : null;
-        this.username = username;
-    }
-
-    @Override
-    public void handleNewPullRequest(PullRequest pr) {
-        if (prWebhook == null) {
-            return;
-        }
-
-        try {
-            var query = JSON.object();
-            query.put("text", pr.nonTransformedWebUrl().toString());
-            if (username != null && !username.isEmpty()) {
-                query.put("username", username);
-            }
-            prWebhook.post("").body(query).executeUnparsed();
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-    }
-
-    @Override
-    public void handleCommits(HostedRepository repository,
-                              Repository localRepository,
-                              List<Commit> commits,
-                              Branch branch) throws NonRetriableException {
-        if (commitWebhook == null) {
-            return;
-        }
-
-        try {
-            for (var commit : commits) {
-                var query = JSON.object();
-                if (username != null && !username.isEmpty()) {
-                    query.put("username", username);
-                }
-                var title = commit.message().get(0);
-                query.put("text", branch.name() + ": " + commit.hash().abbreviate() + ": " + title + "\n" +
-                                  "Author: " + commit.author().name() + "\n" +
-                                  "Committer: " + commit.author().name() + "\n" +
-                                  "Date: " + commit.date().format(DateTimeFormatter.RFC_1123_DATE_TIME) + "\n");
-
-                var attachment = JSON.object();
-                attachment.put("fallback", "Link to commit");
-                attachment.put("color", "#cc0e31");
-                attachment.put("title", "View on " + repository.forge().name());
-                attachment.put("title_link", repository.webUrl(commit.hash()).toString());
-                var attachments = JSON.array();
-                attachments.add(attachment);
-                query.put("attachments", attachments);
-                commitWebhook.post("").body(query).executeUnparsed();
-            }
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
-        }
-    }
-
-    @Override
-    public String name() {
-        return "slack";
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedBranch.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedBranch.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedBranch.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/UpdatedBranch.java
@@ -24,11 +24,11 @@
 
 import org.openjdk.skara.vcs.*;
 
 import java.util.Objects;
 
-class UpdatedBranch {
+public class UpdatedBranch {
     private final Branch branch;
     private final String updater;
     private final Hash hash;
 
     UpdatedBranch(Branch branch, String updater, Hash hash) {
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdater.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdater.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.issue;
+
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.issuetracker.*;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
+
+import java.net.URI;
+import java.util.*;
+import java.util.logging.Logger;
+
+public class IssueUpdater implements RepositoryUpdateConsumer, PullRequestUpdateConsumer {
+    private final IssueProject issueProject;
+    private final boolean reviewLink;
+    private final URI reviewIcon;
+    private final boolean commitLink;
+    private final URI commitIcon;
+    private final Logger log = Logger.getLogger("org.openjdk.skara.bots.notify");
+
+    IssueUpdater(IssueProject issueProject, boolean reviewLink, URI reviewIcon, boolean commitLink, URI commitIcon) {
+        this.issueProject = issueProject;
+        this.reviewLink = reviewLink;
+        this.reviewIcon = reviewIcon;
+        this.commitLink = commitLink;
+        this.commitIcon = commitIcon;
+    }
+
+    public static IssueUpdaterBuilder newBuilder() {
+        return new IssueUpdaterBuilder();
+    }
+
+    @Override
+    public String name() {
+        return "issue";
+    }
+
+    private Optional<String> findIssueUsername(Commit commit) {
+        var authorEmail = EmailAddress.from(commit.author().email());
+        if (authorEmail.domain().equals("openjdk.org")) {
+            return Optional.of(authorEmail.localPart());
+        }
+
+        var committerEmail = EmailAddress.from(commit.committer().email());
+        if (!committerEmail.domain().equals("openjdk.org")) {
+            log.severe("Cannot determine issue tracker user name from committer email: " + committerEmail);
+            return Optional.empty();
+        }
+        return Optional.of(committerEmail.localPart());
+    }
+
+    @Override
+    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch)  {
+        for (var commit : commits) {
+            var commitMessage = CommitMessageParsers.v1.parse(commit);
+            for (var commitIssue : commitMessage.issues()) {
+                var optionalIssue = issueProject.issue(commitIssue.shortId());
+                if (optionalIssue.isEmpty()) {
+                    log.severe("Cannot update issue " + commitIssue.id() + " with commit " + commit.hash().abbreviate()
+                            + " - issue not found in issue project");
+                    continue;
+                }
+                var issue = optionalIssue.get();
+
+                var candidates = repository.findPullRequestsWithComment(null, "Pushed as commit " + commit.hash() + ".");
+                if (candidates.size() != 1) {
+                    log.info("IssueUpdater@" + issue.id() + ": Skipping commit " + commit.hash().abbreviate() + " for repository " + repository.name() +
+                            " on branch " + branch.name() + " - " + candidates.size() + " matching PRs found (needed 1)");
+                    continue;
+                }
+                var candidate = candidates.get(0);
+                var prLink = candidate.webUrl();
+                if (!candidate.targetRef().equals(branch.name())) {
+                    log.info("IssueUpdater@" + issue.id() + ": Pull request " + prLink + " targets " + candidate.targetRef() + " - commit is on " + branch.toString() + " - skipping");
+                    continue;
+                }
+
+                if (commitLink) {
+                    var linkBuilder = Link.create(repository.webUrl(commit.hash()), "Commit")
+                                          .summary(repository.name() + "/" + commit.hash().abbreviate());
+                    if (commitIcon != null) {
+                        linkBuilder.iconTitle("Commit");
+                        linkBuilder.iconUrl(commitIcon);
+                    }
+                    issue.addLink(linkBuilder.build());
+                }
+
+                if (issue.state() == Issue.State.OPEN) {
+                    issue.setState(Issue.State.RESOLVED);
+                    if (issue.assignees().isEmpty()) {
+                        var username = findIssueUsername(commit);
+                        if (username.isPresent()) {
+                            var assignee = issueProject.issueTracker().user(username.get());
+                            if (assignee.isPresent()) {
+                                issue.setAssignees(List.of(assignee.get()));
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void handleNewIssue(PullRequest pr, org.openjdk.skara.vcs.openjdk.Issue issue) {
+        var realIssue = issueProject.issue(issue.shortId());
+        if (realIssue.isEmpty()) {
+            log.warning("Pull request " + pr + " added unknown issue: " + issue.id());
+            return;
+        }
+
+        if (reviewLink) {
+            var linkBuilder = Link.create(pr.webUrl(), "Review")
+                                  .summary(pr.repository().name() + "/" + pr.id());
+            if (reviewIcon != null) {
+                linkBuilder.iconTitle("Review");
+                linkBuilder.iconUrl(reviewIcon);
+            }
+
+            realIssue.get().addLink(linkBuilder.build());
+        }
+    }
+
+    @Override
+    public void handleRemovedIssue(PullRequest pr, org.openjdk.skara.vcs.openjdk.Issue issue) {
+        var realIssue = issueProject.issue(issue.shortId());
+        if (realIssue.isEmpty()) {
+            log.warning("Pull request " + pr + " removed unknown issue: " + issue.id());
+            return;
+        }
+
+        var link = Link.create(pr.webUrl(), "").build();
+        realIssue.get().removeLink(link);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdaterBuilder.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdaterBuilder.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdaterBuilder.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.issue;
+
+import org.openjdk.skara.issuetracker.IssueProject;
+
+import java.net.URI;
+import java.util.Map;
+
+public class IssueUpdaterBuilder {
+    private IssueProject issueProject;
+    private boolean reviewLink = true;
+    private URI reviewIcon = null;
+    private boolean commitLink = true;
+    private URI commitIcon = null;
+
+    public IssueUpdaterBuilder issueProject(IssueProject issueProject) {
+        this.issueProject = issueProject;
+        return this;
+    }
+
+    public IssueUpdaterBuilder reviewLink(boolean reviewLink) {
+        this.reviewLink = reviewLink;
+        return this;
+    }
+
+    public IssueUpdaterBuilder reviewIcon(URI reviewIcon) {
+        this.reviewIcon = reviewIcon;
+        return this;
+    }
+
+    public IssueUpdaterBuilder commitLink(boolean commitLink) {
+        this.commitLink = commitLink;
+        return this;
+    }
+
+    public IssueUpdaterBuilder commitIcon(URI commitIcon) {
+        this.commitIcon = commitIcon;
+        return this;
+    }
+
+    public IssueUpdater build() {
+        return new IssueUpdater(issueProject, reviewLink, reviewIcon, commitLink, commitIcon);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdaterFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdaterFactory.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/issue/IssueUpdaterFactory.java
@@ -0,0 +1,41 @@
+package org.openjdk.skara.bots.notify.issue;
+
+import org.openjdk.skara.bot.BotConfiguration;
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.json.JSONObject;
+
+import java.net.URI;
+
+public class IssueUpdaterFactory implements NotifierFactory {
+    @Override
+    public String name() {
+        return "issue";
+    }
+
+    @Override
+    public Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration) {
+        var issueProject = botConfiguration.issueProject(notifierConfiguration.get("project").asString());
+        var issueUpdaterBuilder = IssueUpdater.newBuilder()
+                .issueProject(issueProject);
+
+        if (notifierConfiguration.contains("reviews")) {
+            if (notifierConfiguration.get("reviews").contains("icon")) {
+                issueUpdaterBuilder.reviewIcon(URI.create(notifierConfiguration.get("reviews").get("icon").asString()));
+            }
+        }
+        if (notifierConfiguration.contains("commits")) {
+            if (notifierConfiguration.get("commits").contains("icon")) {
+                issueUpdaterBuilder.commitIcon(URI.create(notifierConfiguration.get("commits").get("icon").asString()));
+            }
+        }
+
+        if (notifierConfiguration.contains("reviewlink")) {
+            issueUpdaterBuilder.reviewLink(notifierConfiguration.get("reviewlink").asBoolean());
+        }
+        if (notifierConfiguration.contains("commitlink")) {
+            issueUpdaterBuilder.commitLink(notifierConfiguration.get("commitlink").asBoolean());
+        }
+
+        return issueUpdaterBuilder.build();
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdateWriter.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdateWriter.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdateWriter.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.json;
+
+import org.openjdk.skara.json.*;
+
+import java.io.*;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.*;
+import java.util.UUID;
+
+public class JsonUpdateWriter implements AutoCloseable {
+
+    private int sequence = 0;
+    private final String baseName;
+    private final Path path;
+    private JSONArray current;
+
+    private void flush() {
+        var tempName = path.resolve(String.format("%s.%03d.temp", baseName, sequence));
+        var finalName = path.resolve(String.format("%s.%03d.json", baseName, sequence));
+
+        try {
+            Files.write(tempName, current.toString().getBytes(StandardCharsets.UTF_8));
+            Files.move(tempName, finalName);
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+
+        sequence++;
+        current = JSON.array();
+    }
+
+    JsonUpdateWriter(Path path, String projectName) {
+        this.path = path;
+
+        var uuid = UUID.randomUUID();
+        baseName = "jbs." + projectName.replace("/", ".") + "." + uuid.toString().replace("-", "");
+        current = JSON.array();
+    }
+
+    public void write(JSONObject obj) {
+        current.add(obj);
+        if (current.size() > 100) {
+            flush();
+        }
+    }
+
+    @Override
+    public void close() {
+        if (current.size() > 0) {
+            flush();
+        }
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdater.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdater.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.json;
+
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.forge.HostedRepository;
+import org.openjdk.skara.json.*;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.*;
+
+import java.nio.file.Path;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+
+public class JsonUpdater implements RepositoryUpdateConsumer {
+    private final Path path;
+    private final String version;
+    private final String defaultBuild;
+
+    public JsonUpdater(Path path, String version, String defaultBuild) {
+        this.path = path;
+        this.version = version;
+        this.defaultBuild = defaultBuild;
+    }
+
+    private JSONObject commitToChanges(HostedRepository repository, Repository localRepository, Commit commit, String build) {
+        var ret = JSON.object();
+        ret.put("url",  repository.webUrl(commit.hash()).toString()); //FIXME
+        ret.put("version", version);
+        ret.put("build", build);
+
+        var parsedMessage = CommitMessageParsers.v1.parse(commit);
+        var issueIds = JSON.array();
+        for (var issue : parsedMessage.issues()) {
+            issueIds.add(JSON.of(issue.shortId()));
+        }
+        ret.put("issue", issueIds);
+        ret.put("user", commit.author().name());
+        ret.put("date", commit.date().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss +0000")));
+
+        return ret;
+    }
+
+    private JSONObject issuesToChanges(HostedRepository repository, Repository localRepository, List<Issue> issues, String build) {
+        var ret = JSON.object();
+        ret.put("version", version);
+        ret.put("build", build);
+
+        var issueIds = JSON.array();
+        for (var issue : issues) {
+            issueIds.add(JSON.of(issue.shortId()));
+        }
+
+        ret.put("issue", issueIds);
+
+        return ret;
+    }
+
+    @Override
+    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
+        try (var writer = new JsonUpdateWriter(path, repository.name())) {
+            for (var commit : commits) {
+                var json = commitToChanges(repository, localRepository, commit, defaultBuild);
+                writer.write(json);
+            }
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    @Override
+    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
+        var build = String.format("b%02d", tag.buildNum());
+        try (var writer = new JsonUpdateWriter(path, repository.name())) {
+            var issues = new ArrayList<Issue>();
+            for (var commit : commits) {
+                var parsedMessage = CommitMessageParsers.v1.parse(commit);
+                issues.addAll(parsedMessage.issues());
+            }
+            var json = issuesToChanges(repository, localRepository, issues, build);
+            writer.write(json);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    @Override
+    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) {
+    }
+
+    @Override
+    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
+    }
+
+    @Override
+    public String name() {
+        return "json";
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdaterFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdaterFactory.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/json/JsonUpdaterFactory.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.json;
+
+import org.openjdk.skara.bot.BotConfiguration;
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.json.JSONObject;
+
+import java.nio.file.Path;
+
+public class JsonUpdaterFactory implements NotifierFactory {
+    @Override
+    public String name() {
+        return "json";
+    }
+
+    @Override
+    public Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration) {
+        var folder = notifierConfiguration.get("folder").asString();
+        var build = notifierConfiguration.get("build").asString();
+        var version = notifierConfiguration.get("version").asString();
+
+        return new JsonUpdater(Path.of(folder), version, build);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdater.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdater.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.mailinglist;
+
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.email.*;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.mailinglist.MailingList;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
+
+import java.io.*;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+import java.util.logging.Logger;
+import java.util.regex.Pattern;
+
+public class MailingListUpdater implements RepositoryUpdateConsumer {
+    private final MailingList list;
+    private final EmailAddress recipient;
+    private final EmailAddress sender;
+    private final EmailAddress author;
+    private final boolean includeBranch;
+    private final boolean reportNewTags;
+    private final boolean reportNewBranches;
+    private final boolean reportNewBuilds;
+    private final Mode mode;
+    private final Map<String, String> headers;
+    private final Pattern allowedAuthorDomains;
+    private final Logger log = Logger.getLogger("org.openjdk.skara.bots.notify");
+
+    public enum Mode {
+        ALL,
+        PR
+    }
+
+    MailingListUpdater(MailingList list, EmailAddress recipient, EmailAddress sender, EmailAddress author,
+                       boolean includeBranch, boolean reportNewTags, boolean reportNewBranches, boolean reportNewBuilds,
+                       Mode mode, Map<String, String> headers, Pattern allowedAuthorDomains) {
+        this.list = list;
+        this.recipient = recipient;
+        this.sender = sender;
+        this.author = author;
+        this.includeBranch = includeBranch;
+        this.reportNewTags = reportNewTags;
+        this.reportNewBranches = reportNewBranches;
+        this.reportNewBuilds = reportNewBuilds;
+        this.mode = mode;
+        this.headers = headers;
+        this.allowedAuthorDomains = allowedAuthorDomains;
+    }
+
+    public static MailingListUpdaterBuilder newBuilder() {
+        return new MailingListUpdaterBuilder();
+    }
+
+    private String tagAnnotationToText(HostedRepository repository, Tag.Annotated annotation) {
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        printer.println("Tagged by: " + annotation.author().name() + " <" + annotation.author().email() + ">");
+        printer.println("Date:      " + annotation.date().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss +0000")));
+        printer.println();
+        printer.print(String.join("\n", annotation.message()));
+
+        return writer.toString();
+    }
+
+    private EmailAddress filteredAuthor(EmailAddress commitAddress) {
+        if (author != null) {
+            return author;
+        }
+        var allowedAuthorMatcher = allowedAuthorDomains.matcher(commitAddress.domain());
+        if (!allowedAuthorMatcher.matches()) {
+            return sender;
+        } else {
+            return commitAddress;
+        }
+    }
+
+    private EmailAddress commitToAuthor(Commit commit) {
+        return filteredAuthor(EmailAddress.from(commit.committer().name(), commit.committer().email()));
+    }
+
+    private EmailAddress annotationToAuthor(Tag.Annotated annotation) {
+        return filteredAuthor(EmailAddress.from(annotation.author().name(), annotation.author().email()));
+    }
+
+    private String commitsToSubject(HostedRepository repository, List<Commit> commits, Branch branch) {
+        var subject = new StringBuilder();
+        subject.append(repository.repositoryType().shortName());
+        subject.append(": ");
+        subject.append(repository.name());
+        subject.append(": ");
+        if (includeBranch) {
+            subject.append(branch.name());
+            subject.append(": ");
+        }
+        if (commits.size() > 1) {
+            subject.append(commits.size());
+            subject.append(" new changesets");
+        } else {
+            subject.append(commits.get(0).message().get(0));
+        }
+        return subject.toString();
+    }
+
+    private String tagToSubject(HostedRepository repository, Hash hash, Tag tag) {
+        return repository.repositoryType().shortName() +
+                ": " +
+                repository.name() +
+                ": Added tag " +
+                tag +
+                " for changeset " +
+                hash.abbreviate();
+    }
+
+    private List<Commit> filterPrCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
+        var ret = new ArrayList<Commit>();
+        var mergedHashes = new HashSet<Hash>();
+
+        for (var commit : commits) {
+            if (mergedHashes.contains(commit.hash())) {
+                log.info("Commit " + commit.hash() + " belongs to a merge PR - skipping");
+                continue;
+            }
+
+            var candidates = repository.findPullRequestsWithComment(null, "Pushed as commit " + commit.hash() + ".");
+            if (candidates.size() != 1) {
+                log.warning("Commit " + commit.hash() + " matches " + candidates.size() + " pull requests - expected 1");
+                ret.add(commit);
+                continue;
+            }
+
+            var candidate = candidates.get(0);
+            var prLink = candidate.webUrl();
+            if (!candidate.targetRef().equals(branch.name())) {
+                log.info("Pull request " + prLink + " targets " + candidate.targetRef() + " - commit is on " + branch.toString() + " - skipping");
+                ret.add(commit);
+                continue;
+            }
+
+            // For a merge PR, many other of these commits could belong here as well
+            try {
+                localRepository.fetch(repository.url(), candidate.fetchRef());
+                var baseHash = PullRequestUtils.baseHash(candidate, localRepository);
+                var prCommits = localRepository.commitMetadata(baseHash, candidate.headHash());
+                prCommits.forEach(prCommit -> mergedHashes.add(prCommit.hash()));
+            } catch (IOException e) {
+                log.warning("Could not fetch commits from " + prLink + " - cannot see if the belong to the PR");
+            }
+        }
+
+        return ret;
+    }
+
+    private void sendCombinedCommits(HostedRepository repository, List<Commit> commits, Branch branch) throws NonRetriableException {
+        if (commits.size() == 0) {
+            return;
+        }
+
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        for (var commit : commits) {
+            printer.println(CommitFormatters.toText(repository, commit));
+        }
+
+        var subject = commitsToSubject(repository, commits, branch);
+        var lastCommit = commits.get(commits.size() - 1);
+        var commitAddress = filteredAuthor(EmailAddress.from(lastCommit.committer().name(), lastCommit.committer().email()));
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .author(commitAddress)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, commits))
+                         .build();
+
+        try {
+            list.post(email);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    private Map<String, String> commitHeaders(HostedRepository repository, List<Commit> commits) {
+        var ret = new HashMap<String, String>();
+        ret.put("X-Git-URL", repository.webUrl().toString());
+        if (!commits.isEmpty()) {
+            ret.put("X-Git-Changeset", commits.get(0).hash().hex());
+        }
+        return ret;
+    }
+
+    @Override
+    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
+        if (mode == Mode.PR) {
+            commits = filterPrCommits(repository, localRepository, commits, branch);
+        }
+        sendCombinedCommits(repository, commits, branch);
+    }
+
+    @Override
+    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
+        if (!reportNewTags) {
+            return;
+        }
+        if (!reportNewBuilds) {
+            handleTagCommit(repository, localRepository, commits.get(commits.size() - 1), tag.tag(), annotation);
+            return;
+        }
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        var taggedCommit = commits.get(commits.size() - 1);
+        if (annotation != null) {
+            printer.println(tagAnnotationToText(repository, annotation));
+        }
+        printer.println(CommitFormatters.toTextBrief(repository, taggedCommit));
+
+        printer.println("The following commits are included in " + tag.tag());
+        printer.println("========================================================");
+        for (var commit : commits) {
+            printer.print(commit.hash().abbreviate());
+            if (commit.message().size() > 0) {
+                printer.print(": " + commit.message().get(0));
+            }
+            printer.println();
+        }
+
+        var subject = tagToSubject(repository, taggedCommit.hash(), tag.tag());
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, commits));
+
+        if (annotation != null) {
+            email.author(annotationToAuthor(annotation));
+        } else {
+            email.author(commitToAuthor(taggedCommit));
+        }
+
+        try {
+            list.post(email.build());
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    @Override
+    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) throws NonRetriableException {
+        if (!reportNewTags) {
+            return;
+        }
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        if (annotation != null) {
+            printer.println(tagAnnotationToText(repository, annotation));
+        }
+        printer.println(CommitFormatters.toTextBrief(repository, commit));
+
+        var subject = tagToSubject(repository, commit.hash(), tag);
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, List.of(commit)));
+
+        if (annotation != null) {
+            email.author(annotationToAuthor(annotation));
+        } else {
+            email.author(commitToAuthor(commit));
+        }
+
+        try {
+            list.post(email.build());
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    private String newBranchSubject(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
+        var subject = new StringBuilder();
+        subject.append(repository.repositoryType().shortName());
+        subject.append(": ");
+        subject.append(repository.name());
+        subject.append(": created branch ");
+        subject.append(branch);
+        subject.append(" based on the branch ");
+        subject.append(parent);
+        subject.append(" containing ");
+        subject.append(commits.size());
+        subject.append(" unique commit");
+        if (commits.size() != 1) {
+            subject.append("s");
+        }
+
+        return subject.toString();
+    }
+
+    @Override
+    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) throws NonRetriableException {
+        if (!reportNewBranches) {
+            return;
+        }
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        if (commits.size() > 0) {
+            printer.println("The following commits are unique to the " + branch.name() + " branch:");
+            printer.println("========================================================");
+            for (var commit : commits) {
+                printer.print(commit.hash().abbreviate());
+                if (commit.message().size() > 0) {
+                    printer.print(": " + commit.message().get(0));
+                }
+                printer.println();
+            }
+        } else {
+            printer.println("The new branch " + branch.name() + " is currently identical to the " + parent.name() + " branch.");
+        }
+
+        var subject = newBranchSubject(repository, localRepository, commits, parent, branch);
+        var finalAuthor = commits.size() > 0 ? commitToAuthor(commits.get(commits.size() - 1)) : sender;
+
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .author(finalAuthor)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, commits))
+                         .build();
+        try {
+            list.post(email);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    @Override
+    public String name() {
+        return "ml";
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterBuilder.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterBuilder.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterBuilder.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.mailinglist;
+
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.mailinglist.MailingList;
+
+import java.util.Map;
+import java.util.regex.Pattern;
+
+public class MailingListUpdaterBuilder {
+    private MailingList list;
+    private EmailAddress recipient;
+    private EmailAddress sender;
+    private EmailAddress author = null;
+    private boolean includeBranch = false;
+    private boolean reportNewTags = true;
+    private boolean reportNewBranches = true;
+    private boolean reportNewBuilds = true;
+    private MailingListUpdater.Mode mode = MailingListUpdater.Mode.ALL;
+    private Map<String, String> headers = Map.of();
+    private Pattern allowedAuthorDomains = Pattern.compile(".*");
+    private boolean repoInSubject = false;
+    private Pattern branchInSubject = Pattern.compile("a^"); // Does not match anything
+
+    public MailingListUpdaterBuilder list(MailingList list) {
+        this.list = list;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder recipient(EmailAddress recipient) {
+        this.recipient = recipient;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder sender(EmailAddress sender) {
+        this.sender = sender;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder author(EmailAddress author) {
+        this.author = author;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder includeBranch(boolean includeBranch) {
+        this.includeBranch = includeBranch;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder reportNewTags(boolean reportNewTags) {
+        this.reportNewTags = reportNewTags;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder reportNewBranches(boolean reportNewBranches) {
+        this.reportNewBranches = reportNewBranches;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder reportNewBuilds(boolean reportNewBuilds) {
+        this.reportNewBuilds = reportNewBuilds;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder mode(MailingListUpdater.Mode mode) {
+        this.mode = mode;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder headers(Map<String, String> headers) {
+        this.headers = headers;
+        return this;
+    }
+
+    public MailingListUpdaterBuilder allowedAuthorDomains(Pattern allowedAuthorDomains) {
+        this.allowedAuthorDomains = allowedAuthorDomains;
+        return this;
+    }
+
+    public MailingListUpdater build() {
+        return new MailingListUpdater(list, recipient, sender, author, includeBranch, reportNewTags, reportNewBranches,
+                                      reportNewBuilds, mode, headers, allowedAuthorDomains);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterFactory.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterFactory.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.mailinglist;
+
+import org.openjdk.skara.bot.BotConfiguration;
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.json.JSONObject;
+import org.openjdk.skara.mailinglist.MailingListServerFactory;
+import org.openjdk.skara.network.URIBuilder;
+
+import java.time.Duration;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public class MailingListUpdaterFactory implements NotifierFactory {
+    @Override
+    public String name() {
+        return "mailinglist";
+    }
+
+    @Override
+    public Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration) {
+        var smtp = notifierConfiguration.get("smtp").asString();
+        var sender = EmailAddress.parse(notifierConfiguration.get("sender").asString());
+        var archive = URIBuilder.base(notifierConfiguration.get("archive").asString()).build();
+        var interval = notifierConfiguration.contains("interval") ? Duration.parse(notifierConfiguration.get("interval").asString()) : Duration.ofSeconds(1);
+        var listServer = MailingListServerFactory.createMailmanServer(archive, smtp, interval);
+
+        var recipient = notifierConfiguration.get("recipient").asString();
+        var recipientAddress = EmailAddress.parse(recipient);
+
+        var author = notifierConfiguration.contains("author") ? EmailAddress.parse(notifierConfiguration.get("author").asString()) : null;
+        var allowedDomains = author == null ? Pattern.compile(notifierConfiguration.get("domains").asString()) : null;
+
+        var mailingListUpdaterBuilder = MailingListUpdater.newBuilder()
+                                                          .list(listServer.getList(recipient))
+                                                          .recipient(recipientAddress)
+                                                          .sender(sender)
+                                                          .author(author)
+                                                          .allowedAuthorDomains(allowedDomains);
+
+        if (notifierConfiguration.contains("mode")) {
+            MailingListUpdater.Mode mode;
+            switch (notifierConfiguration.get("mode").asString()) {
+                case "all":
+                    mode = MailingListUpdater.Mode.ALL;
+                    break;
+                case "pr":
+                    mode = MailingListUpdater.Mode.PR;
+                    break;
+                default:
+                    throw new RuntimeException("Unknown mode");
+            }
+            mailingListUpdaterBuilder.mode(mode);
+        }
+        if (notifierConfiguration.contains("headers")) {
+            mailingListUpdaterBuilder.headers(notifierConfiguration.get("headers").fields().stream()
+                                                                   .collect(Collectors.toMap(JSONObject.Field::name,
+                                                                           field -> field.value().asString())));
+        }
+        if (notifierConfiguration.contains("branchnames")) {
+            mailingListUpdaterBuilder.includeBranch(notifierConfiguration.get("branchnames").asBoolean());
+        }
+        if (notifierConfiguration.contains("tags")) {
+            mailingListUpdaterBuilder.reportNewTags(notifierConfiguration.get("tags").asBoolean());
+        }
+        if (notifierConfiguration.contains("branches")) {
+            mailingListUpdaterBuilder.reportNewBranches(notifierConfiguration.get("branches").asBoolean());
+        }
+        if (notifierConfiguration.contains("builds")) {
+            mailingListUpdaterBuilder.reportNewBuilds(notifierConfiguration.get("builds").asBoolean());
+        }
+
+        return mailingListUpdaterBuilder.build();
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/slack/SlackUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/slack/SlackUpdater.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/slack/SlackUpdater.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.slack;
+
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.forge.HostedRepository;
+import org.openjdk.skara.forge.PullRequest;
+import org.openjdk.skara.json.*;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.network.*;
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.net.URI;
+import java.util.List;
+import java.time.format.DateTimeFormatter;
+
+public class SlackUpdater implements RepositoryUpdateConsumer, PullRequestUpdateConsumer {
+    private final RestRequest prWebhook;
+    private final RestRequest commitWebhook;
+    private final String username;
+
+    public SlackUpdater(URI prWebhook, URI commitWebhook, String username) {
+        this.prWebhook = prWebhook != null ? new RestRequest(prWebhook) : null;
+        this.commitWebhook = commitWebhook != null ? new RestRequest(commitWebhook) : null;
+        this.username = username;
+    }
+
+    @Override
+    public void handleNewPullRequest(PullRequest pr) {
+        if (prWebhook == null) {
+            return;
+        }
+
+        try {
+            var query = JSON.object();
+            query.put("text", pr.nonTransformedWebUrl().toString());
+            if (username != null && !username.isEmpty()) {
+                query.put("username", username);
+            }
+            prWebhook.post("").body(query).executeUnparsed();
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    @Override
+    public void handleCommits(HostedRepository repository,
+                              Repository localRepository,
+                              List<Commit> commits,
+                              Branch branch) throws NonRetriableException {
+        if (commitWebhook == null) {
+            return;
+        }
+
+        try {
+            for (var commit : commits) {
+                var query = JSON.object();
+                if (username != null && !username.isEmpty()) {
+                    query.put("username", username);
+                }
+                var title = commit.message().get(0);
+                query.put("text", branch.name() + ": " + commit.hash().abbreviate() + ": " + title + "\n" +
+                                  "Author: " + commit.author().name() + "\n" +
+                                  "Committer: " + commit.author().name() + "\n" +
+                                  "Date: " + commit.date().format(DateTimeFormatter.RFC_1123_DATE_TIME) + "\n");
+
+                var attachment = JSON.object();
+                attachment.put("fallback", "Link to commit");
+                attachment.put("color", "#cc0e31");
+                attachment.put("title", "View on " + repository.forge().name());
+                attachment.put("title_link", repository.webUrl(commit.hash()).toString());
+                var attachments = JSON.array();
+                attachments.add(attachment);
+                query.put("attachments", attachments);
+                commitWebhook.post("").body(query).executeUnparsed();
+            }
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    @Override
+    public String name() {
+        return "slack";
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/slack/SlackUpdaterFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/slack/SlackUpdaterFactory.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/slack/SlackUpdaterFactory.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.slack;
+
+import org.openjdk.skara.bot.BotConfiguration;
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.json.JSONObject;
+import org.openjdk.skara.network.URIBuilder;
+
+import java.net.URI;
+
+public class SlackUpdaterFactory implements NotifierFactory {
+    @Override
+    public String name() {
+        return "slack";
+    }
+
+    @Override
+    public Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration) {
+        URI prWebhook = null;
+        if (notifierConfiguration.contains("pr")) {
+            prWebhook = URIBuilder.base(notifierConfiguration.get("pr").asString()).build();
+        }
+        URI commitWebhook = null;
+        if (notifierConfiguration.contains("commit")) {
+            commitWebhook = URIBuilder.base(notifierConfiguration.get("commit").asString()).build();
+        }
+        var username = notifierConfiguration.get("username").asString();
+        var updater = new SlackUpdater(prWebhook, commitWebhook, username);
+        return updater;
+    }
+}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/IssueUpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/IssueUpdaterTests.java
--- /dev/null
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/IssueUpdaterTests.java
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.junit.jupiter.api.*;
+import org.openjdk.skara.bots.notify.issue.IssueUpdater;
+import org.openjdk.skara.json.JSON;
+import org.openjdk.skara.test.*;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.*;
+import java.util.regex.Pattern;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.openjdk.skara.bots.notify.UpdaterTests.*;
+
+public class IssueUpdaterTests {
+    @Test
+    void testIssueIdempotence(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var issueProject = credentials.getIssueProject();
+            var commitIcon = URI.create("http://www.example.com/commit.png");
+            var updater = IssueUpdater.newBuilder()
+                                      .issueProject(issueProject)
+                                      .reviewLink(false)
+                                      .commitIcon(commitIcon)
+                                      .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // Initialize history
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Save the state
+            var historyState = localRepo.fetch(repo.url(), "history");
+
+            // Create an issue and commit a fix
+            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
+            localRepo.push(editHash, repo.url(), "master");
+            var pr = credentials.createPullRequest(repo, "master", "master", issue.id() + ": Fix that issue");
+            pr.setBody("\n\n### Issue\n * [" + issue.id() + "](http://www.test.test/): The issue");
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The changeset should be reflected in a link
+            var links = issue.links();
+            assertEquals(1, links.size());
+            var link = links.get(0);
+            assertEquals(commitIcon, link.iconUrl().orElseThrow());
+            assertEquals("Commit", link.title().orElseThrow());
+            assertEquals(repo.webUrl(editHash), link.uri().orElseThrow());
+
+            // Wipe the history
+            localRepo.push(historyState, repo.url(), "history", true);
+
+            // Run it again
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // There should be no new links
+            var updatedIssue = issueProject.issue(issue.id()).orElseThrow();
+            assertEquals(1, updatedIssue.links().size());
+        }
+    }
+
+    @Test
+    void testPullRequest(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var reviewer = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var issueProject = credentials.getIssueProject();
+            var reviewIcon = URI.create("http://www.example.com/review.png");
+            var updater = IssueUpdater.newBuilder()
+                                      .issueProject(issueProject)
+                                      .reviewIcon(reviewIcon)
+                                      .commitLink(false)
+                                      .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .prUpdaters(List.of(updater))
+                                     .readyLabels(Set.of("rfr"))
+                                     .readyComments(Map.of(reviewer.forge().currentUser().userName(), Pattern.compile("This is now ready")))
+                                     .build();
+
+            // Initialize history
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Create an issue and a pull request to fix it
+            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "Fix that issue");
+            localRepo.push(editHash, repo.url(), "edit", true);
+            var pr = credentials.createPullRequest(repo, "edit", "master", issue.id() + ": Fix that issue");
+            pr.setBody("\n\n### Issue\n * [" + issue.id() + "](http://www.test.test/): The issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The issue should not yet contain a link to the PR
+            var links = issue.links();
+            assertEquals(0, links.size());
+
+            // Just a label isn't enough
+            pr.addLabel("rfr");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            links = issue.links();
+            assertEquals(0, links.size());
+
+            // Neither is just a comment
+            pr.removeLabel("rfr");
+            var reviewPr = reviewer.pullRequest(pr.id());
+            reviewPr.addComment("This is now ready");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            links = issue.links();
+            assertEquals(0, links.size());
+
+            // Both are needed
+            pr.addLabel("rfr");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The issue should now contain a link to the PR
+            links = issue.links();
+            assertEquals(1, links.size());
+            assertEquals(pr.webUrl(), links.get(0).uri().orElseThrow());
+            assertEquals(reviewIcon, links.get(0).iconUrl().orElseThrow());
+
+            // Add another issue
+            var issue2 = issueProject.createIssue("This is another issue", List.of("Yes indeed"), Map.of("issuetype", JSON.of("Enhancement")));
+            pr.setBody("\n\n### Issues\n * [" + issue.id() + "](http://www.test.test/): The issue\n * [" + issue2.id() +
+                    "](http://www.test2.test/): The second issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Both issues should contain a link to the PR
+            var links1 = issue.links();
+            assertEquals(1, links1.size());
+            assertEquals(pr.webUrl(), links1.get(0).uri().orElseThrow());
+            var links2 = issue2.links();
+            assertEquals(1, links2.size());
+            assertEquals(pr.webUrl(), links2.get(0).uri().orElseThrow());
+
+            // Drop the first one
+            pr.setBody("\n\n### Issues\n * [" + issue2.id() + "](http://www.test2.test/): That other issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Only the second issue should now contain a link to the PR
+            links1 = issue.links();
+            assertEquals(0, links1.size());
+            links2 = issue2.links();
+            assertEquals(1, links2.size());
+            assertEquals(pr.webUrl(), links2.get(0).uri().orElseThrow());
+        }
+    }
+
+    @Test
+    void testPullRequestNoReview(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var reviewer = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var issueProject = credentials.getIssueProject();
+            var reviewIcon = URI.create("http://www.example.com/review.png");
+            var updater = IssueUpdater.newBuilder()
+                                      .issueProject(issueProject)
+                                      .reviewLink(false)
+                                      .reviewIcon(reviewIcon)
+                                      .commitLink(false)
+                                      .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .prUpdaters(List.of(updater)).readyLabels(Set.of("rfr"))
+                                     .readyComments(Map.of(reviewer.forge().currentUser().userName(), Pattern.compile("This is now ready")))
+                                     .build();
+            // Initialize history
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Create an issue and a pull request to fix it
+            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "Fix that issue");
+            localRepo.push(editHash, repo.url(), "edit", true);
+            var pr = credentials.createPullRequest(repo, "edit", "master", issue.id() + ": Fix that issue");
+            pr.setBody("\n\n### Issue\n * [" + issue.id() + "](http://www.test.test/): The issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Add required label
+            pr.addLabel("rfr");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // And the required comment
+            var reviewPr = reviewer.pullRequest(pr.id());
+            reviewPr.addComment("This is now ready");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The issue should still not contain a link to the PR
+            var links = issue.links();
+            assertEquals(0, links.size());
+        }
+    }
+
+    @Test
+    void testPullRequestPROnly(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var issueProject = credentials.getIssueProject();
+            var reviewIcon = URI.create("http://www.example.com/review.png");
+            var updater = IssueUpdater.newBuilder()
+                                      .issueProject(issueProject)
+                                      .reviewIcon(reviewIcon)
+                                      .commitLink(true)
+                                      .commitIcon(reviewIcon)
+                                      .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile(".*"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .prUpdaters(List.of(updater))
+                                     .build();
+
+            // Initialize history
+            localRepo.push(localRepo.resolve("master").orElseThrow(), repo.url(), "other");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // Create an issue and a pull request to fix it
+            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
+            localRepo.push(editHash, repo.url(), "edit", true);
+            var pr = credentials.createPullRequest(repo, "other", "edit", issue.id() + ": Fix that issue");
+            pr.setBody("\n\n### Issue\n * [" + issue.id() + "](http://www.test.test/): The issue");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The issue should now contain a link to the PR
+            var links = issue.links();
+            assertEquals(1, links.size());
+            assertEquals(pr.webUrl(), links.get(0).uri().orElseThrow());
+            assertEquals(reviewIcon, links.get(0).iconUrl().orElseThrow());
+
+            // Simulate integration
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+            localRepo.push(editHash, repo.url(), "other");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // The changeset should be reflected in another link
+            var updatedIssue = issueProject.issue(issue.id()).orElseThrow();
+            links = updatedIssue.links();
+            assertEquals(2, links.size());
+
+            // Now simulate a merge to another branch
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+
+            // No additional link should have been created
+            updatedIssue = issueProject.issue(issue.id()).orElseThrow();
+            links = updatedIssue.links();
+            assertEquals(2, links.size());
+        }
+    }
+}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/JsonUpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/JsonUpdaterTests.java
--- /dev/null
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/JsonUpdaterTests.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.junit.jupiter.api.*;
+import org.openjdk.skara.bots.notify.json.JsonUpdater;
+import org.openjdk.skara.json.*;
+import org.openjdk.skara.test.*;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.*;
+import java.util.List;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.openjdk.skara.bots.notify.UpdaterTests.*;
+
+public class JsonUpdaterTests {
+    private List<Path> findJsonFiles(Path folder, String partialName) throws IOException {
+        return Files.walk(folder)
+                    .filter(path -> path.toString().endsWith(".json"))
+                    .filter(path -> path.toString().contains(partialName))
+                    .collect(Collectors.toList());
+    }
+
+    @Test
+    void testJsonUpdaterBranch(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var localRepoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var jsonFolder = tempFolder.path().resolve("json");
+            Files.createDirectory(jsonFolder);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var updater = new JsonUpdater(jsonFolder, "12", "team");
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "One more line", "12345678: Fixes");
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            var jsonFiles = findJsonFiles(jsonFolder, "");
+            assertEquals(1, jsonFiles.size());
+            var jsonData = Files.readString(jsonFiles.get(0), StandardCharsets.UTF_8);
+            var json = JSON.parse(jsonData);
+            assertEquals(1, json.asArray().size());
+            assertEquals(repo.webUrl(editHash).toString(), json.asArray().get(0).get("url").asString());
+            assertEquals(List.of("12345678"), json.asArray().get(0).get("issue").asArray().stream()
+                                                  .map(JSONValue::asString)
+                                                  .collect(Collectors.toList()));
+        }
+    }
+
+    @Test
+    void testJsonUpdaterTag(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var localRepoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke", "duke@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            var tagStorage = UpdaterTests.createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var jsonFolder = tempFolder.path().resolve("json");
+            Files.createDirectory(jsonFolder);
+            var storageFolder =tempFolder.path().resolve("storage");
+
+            var updater = new JsonUpdater(jsonFolder, "12", "team");
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.fetch(repo.url(), "history:history");
+            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke", "duke@openjdk.java.net");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line", "34567890: Even more fixes");
+            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke", "duke@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            var jsonFiles = findJsonFiles(jsonFolder, "");
+            assertEquals(3, jsonFiles.size());
+
+            for (var file : jsonFiles) {
+                var jsonData = Files.readString(file, StandardCharsets.UTF_8);
+                var json = JSON.parse(jsonData);
+
+                if (json.asArray().get(0).contains("date")) {
+                    assertEquals(2, json.asArray().size());
+                    assertEquals(List.of("23456789"), json.asArray().get(0).get("issue").asArray().stream()
+                                                          .map(JSONValue::asString)
+                                                          .collect(Collectors.toList()));
+                    assertEquals(repo.webUrl(editHash).toString(), json.asArray().get(0).get("url").asString());
+                    assertEquals("team", json.asArray().get(0).get("build").asString());
+                    assertEquals(List.of("34567890"), json.asArray().get(1).get("issue").asArray().stream()
+                                                          .map(JSONValue::asString)
+                                                          .collect(Collectors.toList()));
+                    assertEquals(repo.webUrl(editHash2).toString(), json.asArray().get(1).get("url").asString());
+                    assertEquals("team", json.asArray().get(1).get("build").asString());
+                } else {
+                    assertEquals(1, json.asArray().size());
+                    if (json.asArray().get(0).get("build").asString().equals("b02")) {
+                        assertEquals(List.of("23456789"), json.asArray().get(0).get("issue").asArray().stream()
+                                                              .map(JSONValue::asString)
+                                                              .collect(Collectors.toList()));
+                    } else {
+                        assertEquals("b04", json.asArray().get(0).get("build").asString());
+                        assertEquals(List.of("34567890"), json.asArray().get(0).get("issue").asArray().stream()
+                                                              .map(JSONValue::asString)
+                                                              .collect(Collectors.toList()));
+                    }
+                }
+            }
+        }
+    }}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/MailingListUpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/MailingListUpdaterTests.java
--- /dev/null
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/MailingListUpdaterTests.java
@@ -0,0 +1,975 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify;
+
+import org.junit.jupiter.api.*;
+import org.openjdk.skara.bots.notify.mailinglist.MailingListUpdater;
+import org.openjdk.skara.email.*;
+import org.openjdk.skara.mailinglist.MailingListServerFactory;
+import org.openjdk.skara.test.*;
+
+import java.io.IOException;
+import java.time.Duration;
+import java.util.*;
+import java.util.regex.Pattern;
+
+import static org.junit.jupiter.api.Assertions.*;
+import static org.openjdk.skara.bots.notify.UpdaterTests.*;
+
+public class MailingListUpdaterTests {
+    @Test
+    void testMailingList(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                            .allowedAuthorDomains(Pattern.compile("none"))
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(sender, email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.subject().contains(": 23456789: More fixes"));
+            assertFalse(email.subject().contains("master"));
+            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertFalse(email.body().contains("Committer"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+            assertTrue(email.hasHeader("extra1"));
+            assertEquals("value1", email.headerValue("extra1"));
+            assertTrue(email.hasHeader("extra2"));
+            assertEquals("value2", email.headerValue("extra2"));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash.hex(), email.headerValue("X-Git-Changeset"));
+        }
+    }
+
+    @Test
+    void testMailingListMultiple(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
+                    "first_author", "first@author.example.com");
+            localRepo.push(editHash1, repo.url(), "master");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes",
+                    "another_author", "another@author.example.com");
+            localRepo.push(editHash2, repo.url(), "master");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(EmailAddress.from("another_author", "another@author.example.com"), email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.subject().contains(": 2 new changesets"));
+            assertFalse(email.subject().contains("master"));
+            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
+            assertTrue(email.body().contains("3456789A: Even more fixes"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
+        }
+    }
+
+    @Test
+    void testMailingListSponsored(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
+                    "author", "author@test.test",
+                    "committer", "committer@test.test");
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(EmailAddress.from("committer", "committer@test.test"), email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertTrue(email.body().contains("Author:    author <author@test.test>"));
+            assertTrue(email.body().contains("Committer: committer <committer@test.test>"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+        }
+    }
+
+    @Test
+    void testMailingListMultipleBranches(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            var branch = localRepo.branch(masterHash, "another");
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var author = EmailAddress.from("author", "author@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .author(author)
+                                            .includeBranch(true)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|another"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash1, repo.url(), "master");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes");
+            localRepo.push(editHash2, repo.url(), "master");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(author, email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertFalse(email.subject().contains("another"));
+            assertTrue(email.subject().contains(": master: 2 new changesets"));
+            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
+            assertTrue(email.body().contains("3456789A: Even more fixes"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+            assertFalse(email.body().contains("456789AB: Yet more fixes"));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
+
+            localRepo.checkout(branch, true);
+            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another branch", "456789AB: Yet more fixes");
+            localRepo.push(editHash3, repo.url(), "another");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            conversations = mailmanList.conversations(Duration.ofDays(1));
+            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
+            email = conversations.get(0).first();
+            assertEquals(author, email.author());
+            assertEquals(listAddress, email.sender());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.subject().contains(": another: 456789AB: Yet more fixes"));
+            assertFalse(email.subject().contains("master"));
+            assertTrue(email.body().contains("Changeset: " + editHash3.abbreviate()));
+            assertTrue(email.body().contains("456789AB: Yet more fixes"));
+            assertFalse(email.body().contains("Changeset: " + editHash2.abbreviate()));
+            assertFalse(email.body().contains("3456789A: Even more fixes"));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash3.hex(), email.headerValue("X-Git-Changeset"));
+        }
+    }
+
+    @Test
+    void testMailingListPROnlyMultipleBranches(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var author = EmailAddress.from("author", "author@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .author(author)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .includeBranch(true)
+                                            .mode(MailingListUpdater.Mode.PR)
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|other"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // Populate our known branches
+            localRepo.push(masterHash, repo.url(), "master", true);
+            localRepo.push(masterHash, repo.url(), "other", true);
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            localRepo.checkout(masterHash, true);
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "edit");
+            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
+
+            // PR hasn't been integrated yet, so there should be no mail
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Simulate an RFR email
+            var rfr = Email.create(sender, "RFR: My PR", "PR: " + pr.webUrl().toString())
+                           .recipient(listAddress)
+                           .build();
+            mailmanList.post(rfr);
+            listServer.processIncoming();
+
+            // And an integration (but it hasn't reached master just yet)
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+
+            // Now push the same commit to another branch
+            localRepo.push(editHash, repo.url(), "other");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            // This one should generate a plain integration mail
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(2, conversations.size());
+            var secondEmail = conversations.get(0).first();
+            if (secondEmail.subject().contains("RFR")) {
+                secondEmail = conversations.get(1).first();
+            }
+            assertEquals("git: test: other: 23456789: More fixes", secondEmail.subject());
+        }
+    }
+
+    @Test
+    void testMailingListPR(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .mode(MailingListUpdater.Mode.PR)
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "edit");
+            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
+
+            // Create a potentially conflicting one
+            var otherHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(otherHash, repo.url(), "other");
+            var otherPr = credentials.createPullRequest(repo, "master", "other", "RFR: My other PR");
+
+            // PR hasn't been integrated yet, so there should be no mail
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Simulate an RFR email
+            var rfr = Email.create("[repo/branch] RFR: My PR", "PR:\n" + pr.webUrl().toString())
+                           .author(EmailAddress.from("duke", "duke@duke.duke"))
+                           .recipient(listAddress)
+                           .build();
+            mailmanList.post(rfr);
+            listServer.processIncoming();
+
+            // And an integration
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+            localRepo.push(editHash, repo.url(), "master");
+
+            // Push the other one without a matching PR
+            localRepo.push(otherHash, repo.url(), "master");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
+            assertEquals(2, conversations.size());
+
+            var prConversation = conversations.get(0);
+            var pushConversation = conversations.get(1);
+            assertEquals(1, prConversation.allMessages().size());
+
+            var pushEmail = pushConversation.first();
+            assertEquals(listAddress, pushEmail.sender());
+            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
+            assertEquals(pushEmail.recipients(), List.of(listAddress));
+            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
+        }
+    }
+
+    @Test
+    void testMailingListPROnce(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.branch(masterHash, "other");
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .author(null)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .mode(MailingListUpdater.Mode.PR)
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|other"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            localRepo.checkout(masterHash, true);
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "edit");
+            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
+
+            // PR hasn't been integrated yet, so there should be no mail
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Simulate an RFR email
+            var rfr = Email.create("RFR: My PR", "PR:\n" + pr.webUrl().toString())
+                           .author(EmailAddress.from("duke", "duke@duke.duke"))
+                           .recipient(listAddress)
+                           .build();
+            mailmanList.post(rfr);
+            listServer.processIncoming();
+
+            // And an integration
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+            localRepo.push(editHash, repo.url(), "master", true);
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(1, conversations.size());
+
+            var prConversation = conversations.get(0);
+            assertEquals(1, prConversation.allMessages().size());
+
+            // Now push the change to another monitored branch
+            localRepo.push(editHash, repo.url(), "other", true);
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            // The change should now end up as a separate notification thread
+            conversations = mailmanList.conversations(Duration.ofDays(1));
+            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
+            assertEquals(2, conversations.size());
+
+            var pushConversation = conversations.get(1);
+            var pushEmail = pushConversation.first();
+            assertEquals(listAddress, pushEmail.sender());
+            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
+            assertEquals(pushEmail.recipients(), List.of(listAddress));
+            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
+        }
+    }
+
+    @Test
+    void testMailinglistTag(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer()) {
+            var repo = credentials.getHostedRepository();
+            var localRepoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewBranches(false)
+                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                            .build();
+            var noTagsUpdater = MailingListUpdater.newBuilder()
+                                                  .list(mailmanList)
+                                                  .recipient(listAddress)
+                                                  .sender(sender)
+                                                  .reportNewTags(false)
+                                                  .reportNewBranches(false)
+                                                  .reportNewBuilds(false)
+                                                  .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater, noTagsUpdater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.fetch(repo.url(), "history:history");
+            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
+            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
+            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
+            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(4, conversations.size());
+
+            for (var conversation : conversations) {
+                var email = conversation.first();
+                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
+                    assertTrue(email.body().contains("23456789: More fixes"));
+                    assertFalse(email.body().contains("34567890: Even more fixes"));
+                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
+                    assertFalse(email.body().contains("56789012: Still even more fixes"));
+                    assertFalse(email.body().contains("67890123: Brand new fixes"));
+                    assertFalse(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
+                    assertFalse(email.body().contains("23456789: More fixes"));
+                    assertTrue(email.body().contains("34567890: Even more fixes"));
+                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
+                    assertTrue(email.body().contains("56789012: Still even more fixes"));
+                    assertFalse(email.body().contains("67890123: Brand new fixes"));
+                    assertFalse(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
+                    assertFalse(email.body().contains("23456789: More fixes"));
+                    assertFalse(email.body().contains("34567890: Even more fixes"));
+                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
+                    assertFalse(email.body().contains("56789012: Still even more fixes"));
+                    assertFalse(email.body().contains("67890123: Brand new fixes"));
+                    assertTrue(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: 6 new changesets")) {
+                    assertTrue(email.body().contains("23456789: More fixes"));
+                    assertTrue(email.body().contains("34567890: Even more fixes"));
+                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
+                    assertTrue(email.body().contains("56789012: Still even more fixes"));
+                    assertTrue(email.body().contains("67890123: Brand new fixes"));
+                    assertTrue(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
+                } else {
+                    fail("Mismatched subject: " + email.subject());
+                }
+                assertTrue(email.hasHeader("extra1"));
+                assertEquals("value1", email.headerValue("extra1"));
+                assertTrue(email.hasHeader("extra2"));
+                assertEquals("value2", email.headerValue("extra2"));
+            }
+        }
+    }
+
+    @Test
+    void testMailinglistPlainTags(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer()) {
+            var repo = credentials.getHostedRepository();
+            var localRepoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                            .build();
+            var noTagsUpdater = MailingListUpdater.newBuilder()
+                                                  .list(mailmanList)
+                                                  .recipient(listAddress)
+                                                  .sender(sender)
+                                                  .reportNewTags(false)
+                                                  .reportNewBranches(false)
+                                                  .reportNewBuilds(false)
+                                                  .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater, noTagsUpdater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.fetch(repo.url(), "history:history");
+            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
+            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
+            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
+            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(4, conversations.size());
+
+            for (var conversation : conversations) {
+                var email = conversation.first();
+                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: 6 new changesets")) {
+                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
+                } else {
+                    fail("Mismatched subject: " + email.subject());
+                }
+                assertTrue(email.hasHeader("extra1"));
+                assertEquals("value1", email.headerValue("extra1"));
+                assertTrue(email.hasHeader("extra2"));
+                assertEquals("value2", email.headerValue("extra2"));
+            }
+        }
+    }
+
+    @Test
+    void testMailingListBranch(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewTags(false)
+                                            .reportNewBuilds(false)
+                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|newbranch."))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            CheckableRepository.appendAndCommit(localRepo, "Another line", "12345678: Some fixes");
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "newbranch1");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertEquals("git: test: created branch newbranch1 based on the branch master containing 2 unique commits", email.subject());
+            assertTrue(email.body().contains("12345678: Some fixes"));
+            assertTrue(email.hasHeader("extra1"));
+            assertEquals("value1", email.headerValue("extra1"));
+            assertTrue(email.hasHeader("extra2"));
+            assertEquals("value2", email.headerValue("extra2"));
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            localRepo.push(editHash, repo.url(), "newbranch2");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var newConversation = mailmanList.conversations(Duration.ofDays(1)).stream()
+                                             .filter(c -> !c.equals(conversations.get(0)))
+                                             .findFirst().orElseThrow();
+            email = newConversation.first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(sender, email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertEquals("git: test: created branch newbranch2 based on the branch newbranch1 containing 0 unique commits", email.subject());
+            assertEquals("The new branch newbranch2 is currently identical to the newbranch1 branch.", email.body());
+        }
+    }
+
+    @Test
+    void testMailingListNoIdempotence(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prIssuesStorage = createPullRequestIssuesStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListUpdater.newBuilder()
+                                            .list(mailmanList)
+                                            .recipient(listAddress)
+                                            .sender(sender)
+                                            .reportNewTags(false)
+                                            .reportNewBranches(false)
+                                            .reportNewBuilds(false)
+                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                            .allowedAuthorDomains(Pattern.compile("none"))
+                                            .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prIssuesStorageBuilder(prIssuesStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Save history state
+            var historyHash = localRepo.fetch(repo.url(), "history");
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(1, conversations.size());
+
+            // Reset the history
+            localRepo.push(historyHash, repo.url(), "history", true);
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            // There should now be a duplicate mail
+            conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(2, conversations.size());
+        }
+    }
+}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
--- a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/UpdaterTests.java
@@ -20,1800 +20,40 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.bots.notify;
 
-import org.openjdk.skara.email.*;
+import org.junit.jupiter.api.*;
 import org.openjdk.skara.forge.HostedRepository;
-import org.openjdk.skara.issuetracker.Issue;
-import org.openjdk.skara.json.*;
-import org.openjdk.skara.mailinglist.MailingListServerFactory;
 import org.openjdk.skara.storage.StorageBuilder;
 import org.openjdk.skara.test.*;
-import org.openjdk.skara.vcs.*;
 import org.openjdk.skara.vcs.Tag;
+import org.openjdk.skara.vcs.*;
 import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
 
-import org.junit.jupiter.api.*;
-
 import java.io.IOException;
-import java.net.URI;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.*;
-import java.time.Duration;
-import java.util.*;
+import java.util.List;
 import java.util.regex.Pattern;
-import java.util.stream.Collectors;
 
 import static org.junit.jupiter.api.Assertions.*;
-import static org.openjdk.skara.issuetracker.Issue.State.*;
 
-class UpdaterTests {
-    private List<Path> findJsonFiles(Path folder, String partialName) throws IOException {
-        return Files.walk(folder)
-                    .filter(path -> path.toString().endsWith(".json"))
-                    .filter(path -> path.toString().contains(partialName))
-                    .collect(Collectors.toList());
-    }
-
-    private StorageBuilder<UpdatedTag> createTagStorage(HostedRepository repository) {
+public class UpdaterTests {
+    public static StorageBuilder<UpdatedTag> createTagStorage(HostedRepository repository) {
         return new StorageBuilder<UpdatedTag>("tags.txt")
                 .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated tags");
     }
 
-    private StorageBuilder<UpdatedBranch> createBranchStorage(HostedRepository repository) {
+    public static StorageBuilder<UpdatedBranch> createBranchStorage(HostedRepository repository) {
         return new StorageBuilder<UpdatedBranch>("branches.txt")
                 .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated branches");
     }
 
-    private StorageBuilder<PullRequestIssues> createPullRequestIssuesStorage(HostedRepository repository) {
+    public static StorageBuilder<PullRequestIssues> createPullRequestIssuesStorage(HostedRepository repository) {
         return new StorageBuilder<PullRequestIssues>("prissues.txt")
                 .remoteRepository(repository, "history", "Duke", "duke@openjdk.java.net", "Updated prissues");
     }
 
-    private Set<String> fixVersions(Issue issue) {
-        if (!issue.properties().containsKey("fixVersions")) {
-            return Set.of();
-        }
-        return issue.properties().get("fixVersions").stream()
-                    .map(JSONValue::asString)
-                    .collect(Collectors.toSet());
-    }
-
-    @Test
-    void testJsonUpdaterBranch(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var localRepoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var jsonFolder = tempFolder.path().resolve("json");
-            Files.createDirectory(jsonFolder);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var updater = new JsonUpdater(jsonFolder, "12", "team");
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "One more line", "12345678: Fixes");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            var jsonFiles = findJsonFiles(jsonFolder, "");
-            assertEquals(1, jsonFiles.size());
-            var jsonData = Files.readString(jsonFiles.get(0), StandardCharsets.UTF_8);
-            var json = JSON.parse(jsonData);
-            assertEquals(1, json.asArray().size());
-            assertEquals(repo.webUrl(editHash).toString(), json.asArray().get(0).get("url").asString());
-            assertEquals(List.of("12345678"), json.asArray().get(0).get("issue").asArray().stream()
-                                                  .map(JSONValue::asString)
-                                                  .collect(Collectors.toList()));
-        }
-    }
-
-    @Test
-    void testJsonUpdaterTag(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var localRepoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke", "duke@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var jsonFolder = tempFolder.path().resolve("json");
-            Files.createDirectory(jsonFolder);
-            var storageFolder =tempFolder.path().resolve("storage");
-
-            var updater = new JsonUpdater(jsonFolder, "12", "team");
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertEquals(List.of(), findJsonFiles(jsonFolder, ""));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.fetch(repo.url(), "history:history");
-            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke", "duke@openjdk.java.net");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line", "34567890: Even more fixes");
-            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke", "duke@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            var jsonFiles = findJsonFiles(jsonFolder, "");
-            assertEquals(3, jsonFiles.size());
-
-            for (var file : jsonFiles) {
-                var jsonData = Files.readString(file, StandardCharsets.UTF_8);
-                var json = JSON.parse(jsonData);
-
-                if (json.asArray().get(0).contains("date")) {
-                    assertEquals(2, json.asArray().size());
-                    assertEquals(List.of("23456789"), json.asArray().get(0).get("issue").asArray().stream()
-                                                          .map(JSONValue::asString)
-                                                          .collect(Collectors.toList()));
-                    assertEquals(repo.webUrl(editHash).toString(), json.asArray().get(0).get("url").asString());
-                    assertEquals("team", json.asArray().get(0).get("build").asString());
-                    assertEquals(List.of("34567890"), json.asArray().get(1).get("issue").asArray().stream()
-                                                          .map(JSONValue::asString)
-                                                          .collect(Collectors.toList()));
-                    assertEquals(repo.webUrl(editHash2).toString(), json.asArray().get(1).get("url").asString());
-                    assertEquals("team", json.asArray().get(1).get("build").asString());
-                } else {
-                    assertEquals(1, json.asArray().size());
-                    if (json.asArray().get(0).get("build").asString().equals("b02")) {
-                        assertEquals(List.of("23456789"), json.asArray().get(0).get("issue").asArray().stream()
-                                                              .map(JSONValue::asString)
-                                                              .collect(Collectors.toList()));
-                    } else {
-                        assertEquals("b04", json.asArray().get(0).get("build").asString());
-                        assertEquals(List.of("34567890"), json.asArray().get(0).get("issue").asArray().stream()
-                                                              .map(JSONValue::asString)
-                                                              .collect(Collectors.toList()));
-                    }
-                }
-            }
-        }
-    }
-
-    @Test
-    void testMailingList(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .allowedAuthorDomains(Pattern.compile("none"))
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(sender, email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.subject().contains(": 23456789: More fixes"));
-            assertFalse(email.subject().contains("master"));
-            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertFalse(email.body().contains("Committer"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-            assertTrue(email.hasHeader("extra1"));
-            assertEquals("value1", email.headerValue("extra1"));
-            assertTrue(email.hasHeader("extra2"));
-            assertEquals("value2", email.headerValue("extra2"));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash.hex(), email.headerValue("X-Git-Changeset"));
-        }
-    }
-
-    @Test
-    void testMailingListMultiple(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
-                                                                "first_author", "first@author.example.com");
-            localRepo.push(editHash1, repo.url(), "master");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes",
-                                                                "another_author", "another@author.example.com");
-            localRepo.push(editHash2, repo.url(), "master");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(EmailAddress.from("another_author", "another@author.example.com"), email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.subject().contains(": 2 new changesets"));
-            assertFalse(email.subject().contains("master"));
-            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
-            assertTrue(email.body().contains("3456789A: Even more fixes"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
-        }
-    }
-
-    @Test
-    void testMailingListSponsored(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
-                                                               "author", "author@test.test",
-                                                               "committer", "committer@test.test");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(EmailAddress.from("committer", "committer@test.test"), email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertTrue(email.body().contains("Author:    author <author@test.test>"));
-            assertTrue(email.body().contains("Committer: committer <committer@test.test>"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-        }
-    }
-
-    @Test
-    void testMailingListMultipleBranches(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            var branch = localRepo.branch(masterHash, "another");
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var author = EmailAddress.from("author", "author@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .author(author)
-                                            .includeBranch(true)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|another"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash1, repo.url(), "master");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes");
-            localRepo.push(editHash2, repo.url(), "master");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(author, email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertFalse(email.subject().contains("another"));
-            assertTrue(email.subject().contains(": master: 2 new changesets"));
-            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
-            assertTrue(email.body().contains("3456789A: Even more fixes"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-            assertFalse(email.body().contains("456789AB: Yet more fixes"));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
-
-            localRepo.checkout(branch, true);
-            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another branch", "456789AB: Yet more fixes");
-            localRepo.push(editHash3, repo.url(), "another");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            conversations = mailmanList.conversations(Duration.ofDays(1));
-            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
-            email = conversations.get(0).first();
-            assertEquals(author, email.author());
-            assertEquals(listAddress, email.sender());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.subject().contains(": another: 456789AB: Yet more fixes"));
-            assertFalse(email.subject().contains("master"));
-            assertTrue(email.body().contains("Changeset: " + editHash3.abbreviate()));
-            assertTrue(email.body().contains("456789AB: Yet more fixes"));
-            assertFalse(email.body().contains("Changeset: " + editHash2.abbreviate()));
-            assertFalse(email.body().contains("3456789A: Even more fixes"));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash3.hex(), email.headerValue("X-Git-Changeset"));
-        }
-    }
-
-    @Test
-    void testMailingListPROnlyMultipleBranches(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var author = EmailAddress.from("author", "author@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .author(author)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .includeBranch(true)
-                                            .mode(MailingListUpdater.Mode.PR)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|other"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Populate our known branches
-            localRepo.push(masterHash, repo.url(), "master", true);
-            localRepo.push(masterHash, repo.url(), "other", true);
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            localRepo.checkout(masterHash, true);
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "edit");
-            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
-
-            // PR hasn't been integrated yet, so there should be no mail
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Simulate an RFR email
-            var rfr = Email.create(sender, "RFR: My PR", "PR: " + pr.webUrl().toString())
-                           .recipient(listAddress)
-                           .build();
-            mailmanList.post(rfr);
-            listServer.processIncoming();
-
-            // And an integration (but it hasn't reached master just yet)
-            pr.addComment("Pushed as commit " + editHash.hex() + ".");
-
-            // Now push the same commit to another branch
-            localRepo.push(editHash, repo.url(), "other");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            // This one should generate a plain integration mail
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(2, conversations.size());
-            var secondEmail = conversations.get(0).first();
-            if (secondEmail.subject().contains("RFR")) {
-                secondEmail = conversations.get(1).first();
-            }
-            assertEquals("git: test: other: 23456789: More fixes", secondEmail.subject());
-        }
-    }
-
-    @Test
-    void testMailingListPR(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .mode(MailingListUpdater.Mode.PR)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "edit");
-            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
-
-            // Create a potentially conflicting one
-            var otherHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(otherHash, repo.url(), "other");
-            var otherPr = credentials.createPullRequest(repo, "master", "other", "RFR: My other PR");
-
-            // PR hasn't been integrated yet, so there should be no mail
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Simulate an RFR email
-            var rfr = Email.create("[repo/branch] RFR: My PR", "PR:\n" + pr.webUrl().toString())
-                           .author(EmailAddress.from("duke", "duke@duke.duke"))
-                           .recipient(listAddress)
-                           .build();
-            mailmanList.post(rfr);
-            listServer.processIncoming();
-
-            // And an integration
-            pr.addComment("Pushed as commit " + editHash.hex() + ".");
-            localRepo.push(editHash, repo.url(), "master");
-
-            // Push the other one without a matching PR
-            localRepo.push(otherHash, repo.url(), "master");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
-            assertEquals(2, conversations.size());
-
-            var prConversation = conversations.get(0);
-            var pushConversation = conversations.get(1);
-            assertEquals(1, prConversation.allMessages().size());
-
-            var pushEmail = pushConversation.first();
-            assertEquals(listAddress, pushEmail.sender());
-            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
-            assertEquals(pushEmail.recipients(), List.of(listAddress));
-            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
-        }
-    }
-
-    @Test
-    void testMailingListPROnce(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            localRepo.branch(masterHash, "other");
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .author(null)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .mode(MailingListUpdater.Mode.PR)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|other"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            localRepo.checkout(masterHash, true);
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "edit");
-            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
-
-            // PR hasn't been integrated yet, so there should be no mail
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Simulate an RFR email
-            var rfr = Email.create("RFR: My PR", "PR:\n" + pr.webUrl().toString())
-                           .author(EmailAddress.from("duke", "duke@duke.duke"))
-                           .recipient(listAddress)
-                           .build();
-            mailmanList.post(rfr);
-            listServer.processIncoming();
-
-            // And an integration
-            pr.addComment("Pushed as commit " + editHash.hex() + ".");
-            localRepo.push(editHash, repo.url(), "master", true);
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(1, conversations.size());
-
-            var prConversation = conversations.get(0);
-            assertEquals(1, prConversation.allMessages().size());
-
-            // Now push the change to another monitored branch
-            localRepo.push(editHash, repo.url(), "other", true);
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            // The change should now end up as a separate notification thread
-            conversations = mailmanList.conversations(Duration.ofDays(1));
-            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
-            assertEquals(2, conversations.size());
-
-            var pushConversation = conversations.get(1);
-            var pushEmail = pushConversation.first();
-            assertEquals(listAddress, pushEmail.sender());
-            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
-            assertEquals(pushEmail.recipients(), List.of(listAddress));
-            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
-        }
-    }
-
-    @Test
-    void testMailinglistTag(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory();
-             var listServer = new TestMailmanServer()) {
-            var repo = credentials.getHostedRepository();
-            var localRepoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewBranches(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .build();
-            var noTagsUpdater = MailingListUpdater.newBuilder()
-                                                  .list(mailmanList)
-                                                  .recipient(listAddress)
-                                                  .sender(sender)
-                                                  .reportNewTags(false)
-                                                  .reportNewBranches(false)
-                                                  .reportNewBuilds(false)
-                                                  .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater, noTagsUpdater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.fetch(repo.url(), "history:history");
-            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
-            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
-            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
-            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(4, conversations.size());
-
-            for (var conversation : conversations) {
-                var email = conversation.first();
-                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
-                    assertTrue(email.body().contains("23456789: More fixes"));
-                    assertFalse(email.body().contains("34567890: Even more fixes"));
-                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
-                    assertFalse(email.body().contains("56789012: Still even more fixes"));
-                    assertFalse(email.body().contains("67890123: Brand new fixes"));
-                    assertFalse(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
-                    assertFalse(email.body().contains("23456789: More fixes"));
-                    assertTrue(email.body().contains("34567890: Even more fixes"));
-                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
-                    assertTrue(email.body().contains("56789012: Still even more fixes"));
-                    assertFalse(email.body().contains("67890123: Brand new fixes"));
-                    assertFalse(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
-                    assertFalse(email.body().contains("23456789: More fixes"));
-                    assertFalse(email.body().contains("34567890: Even more fixes"));
-                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
-                    assertFalse(email.body().contains("56789012: Still even more fixes"));
-                    assertFalse(email.body().contains("67890123: Brand new fixes"));
-                    assertTrue(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: 6 new changesets")) {
-                    assertTrue(email.body().contains("23456789: More fixes"));
-                    assertTrue(email.body().contains("34567890: Even more fixes"));
-                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
-                    assertTrue(email.body().contains("56789012: Still even more fixes"));
-                    assertTrue(email.body().contains("67890123: Brand new fixes"));
-                    assertTrue(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
-                } else {
-                    fail("Mismatched subject: " + email.subject());
-                }
-                assertTrue(email.hasHeader("extra1"));
-                assertEquals("value1", email.headerValue("extra1"));
-                assertTrue(email.hasHeader("extra2"));
-                assertEquals("value2", email.headerValue("extra2"));
-            }
-        }
-    }
-
-    @Test
-    void testMailinglistPlainTags(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory();
-             var listServer = new TestMailmanServer()) {
-            var repo = credentials.getHostedRepository();
-            var localRepoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .build();
-            var noTagsUpdater = MailingListUpdater.newBuilder()
-                                                  .list(mailmanList)
-                                                  .recipient(listAddress)
-                                                  .sender(sender)
-                                                  .reportNewTags(false)
-                                                  .reportNewBranches(false)
-                                                  .reportNewBuilds(false)
-                                                  .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater, noTagsUpdater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.fetch(repo.url(), "history:history");
-            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
-            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
-            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
-            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(4, conversations.size());
-
-            for (var conversation : conversations) {
-                var email = conversation.first();
-                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: 6 new changesets")) {
-                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
-                } else {
-                    fail("Mismatched subject: " + email.subject());
-                }
-                assertTrue(email.hasHeader("extra1"));
-                assertEquals("value1", email.headerValue("extra1"));
-                assertTrue(email.hasHeader("extra2"));
-                assertEquals("value2", email.headerValue("extra2"));
-            }
-        }
-    }
-
-    @Test
-    void testMailingListBranch(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|newbranch."))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            CheckableRepository.appendAndCommit(localRepo, "Another line", "12345678: Some fixes");
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "newbranch1");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertEquals("git: test: created branch newbranch1 based on the branch master containing 2 unique commits", email.subject());
-            assertTrue(email.body().contains("12345678: Some fixes"));
-            assertTrue(email.hasHeader("extra1"));
-            assertEquals("value1", email.headerValue("extra1"));
-            assertTrue(email.hasHeader("extra2"));
-            assertEquals("value2", email.headerValue("extra2"));
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            localRepo.push(editHash, repo.url(), "newbranch2");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var newConversation = mailmanList.conversations(Duration.ofDays(1)).stream()
-                                             .filter(c -> !c.equals(conversations.get(0)))
-                                             .findFirst().orElseThrow();
-            email = newConversation.first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(sender, email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertEquals("git: test: created branch newbranch2 based on the branch newbranch1 containing 0 unique commits", email.subject());
-            assertEquals("The new branch newbranch2 is currently identical to the newbranch1 branch.", email.body());
-        }
-    }
-
-    @Test
-    void testMailingListNoIdempotence(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .allowedAuthorDomains(Pattern.compile("none"))
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Save history state
-            var historyHash = localRepo.fetch(repo.url(), "history");
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(1, conversations.size());
-
-            // Reset the history
-            localRepo.push(historyHash, repo.url(), "history", true);
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            // There should now be a duplicate mail
-            conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(2, conversations.size());
-        }
-    }
-
-    @Test
-    void testIssue(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var commitIcon = URI.create("http://www.example.com/commit.png");
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .commitIcon(commitIcon)
-                                      .setFixVersion(true)
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and commit a fix
-            var authorEmailAddress = issueProject.issueTracker().currentUser().userName() + "@openjdk.org";
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue", "Duke", authorEmailAddress);
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The changeset should be reflected in a comment
-            var updatedIssue = issueProject.issue(issue.id()).orElseThrow();
-
-            var comments = updatedIssue.comments();
-            assertEquals(1, comments.size());
-            var comment = comments.get(0);
-            assertTrue(comment.body().contains(editHash.abbreviate()));
-
-            // And in a link
-            var links = updatedIssue.links();
-            assertEquals(1, links.size());
-            var link = links.get(0);
-            assertEquals(commitIcon, link.iconUrl().orElseThrow());
-            assertEquals("Commit", link.title().orElseThrow());
-            assertEquals(repo.webUrl(editHash), link.uri().orElseThrow());
-
-            // As well as a fixVersion
-            assertEquals(Set.of("0.1"), fixVersions(updatedIssue));
-
-            // The issue should be assigned and resolved
-            assertEquals(RESOLVED, updatedIssue.state());
-            assertEquals(List.of(issueProject.issueTracker().currentUser()), updatedIssue.assignees());
-        }
-    }
-
-    @Test
-    void testIssueNoVersion(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType(), Path.of("appendable.txt"), Set.of(), null);
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var commitIcon = URI.create("http://www.example.com/commit.png");
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .commitIcon(commitIcon)
-                                      .setFixVersion(true)
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and commit a fix
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The changeset should be reflected in a comment
-            var comments = issue.comments();
-            assertEquals(1, comments.size());
-            var comment = comments.get(0);
-            assertTrue(comment.body().contains(editHash.abbreviate()));
-
-            // But not in the fixVersion
-            assertEquals(Set.of(), fixVersions(issue));
-        }
-    }
-
-    @Test
-    void testIssueConfiguredVersionNoCommit(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType(), Path.of("appendable.txt"), Set.of(), null);
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var commitIcon = URI.create("http://www.example.com/commit.png");
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .commitLink(false)
-                                      .commitIcon(commitIcon)
-                                      .setFixVersion(true)
-                                      .fixVersions(Map.of("master", "2.0"))
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and commit a fix
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The changeset should not reflected in a comment
-            var comments = issue.comments();
-            assertEquals(1, comments.size());
-            var comment = comments.get(0);
-            assertTrue(comment.body().contains(editHash.abbreviate()));
-
-            // As well as a fixVersion - but not the one from the repo
-            assertEquals(Set.of("2.0"), fixVersions(issue));
-
-            // And no commit link
-            var links = issue.links();
-            assertEquals(0, links.size());
-        }
-    }
-
-    @Test
-    void testIssueIdempotence(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var commitIcon = URI.create("http://www.example.com/commit.png");
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .commitIcon(commitIcon)
-                                      .setFixVersion(true)
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Save the state
-            var historyState = localRepo.fetch(repo.url(), "history");
-
-            // Create an issue and commit a fix
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The changeset should be reflected in a comment
-            var comments = issue.comments();
-            assertEquals(1, comments.size());
-            var comment = comments.get(0);
-            assertTrue(comment.body().contains(editHash.abbreviate()));
-
-            // And in a link
-            var links = issue.links();
-            assertEquals(1, links.size());
-            var link = links.get(0);
-            assertEquals(commitIcon, link.iconUrl().orElseThrow());
-            assertEquals("Commit", link.title().orElseThrow());
-            assertEquals(repo.webUrl(editHash), link.uri().orElseThrow());
-
-            // As well as a fixVersion
-            assertEquals(Set.of("0.1"), fixVersions(issue));
-
-            // Wipe the history
-            localRepo.push(historyState, repo.url(), "history", true);
-
-            // Run it again
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // There should be no new comments, links or fixVersions
-            var updatedIssue = issueProject.issue(issue.id()).orElseThrow();
-            assertEquals(1, updatedIssue.comments().size());
-            assertEquals(1, updatedIssue.links().size());
-            assertEquals(Set.of("0.1"), fixVersions(updatedIssue));
-        }
-    }
-
-    @Test
-    void testIssuePoolVersion(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType(), Path.of("appendable.txt"), Set.of(), null);
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .commitLink(false)
-                                      .setFixVersion(true)
-                                      .fixVersions(Map.of("master", "12u14"))
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and commit a fix
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            issue.setProperty("fixVersions", JSON.array().add("12-pool").add("tbd13").add("unknown"));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The fixVersion should have been updated
-            assertEquals(Set.of("12u14"), fixVersions(issue));
-        }
-    }
-
-    @Test
-    void testIssuePoolOpenVersion(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType(), Path.of("appendable.txt"), Set.of(), null);
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .commitLink(false)
-                                      .setFixVersion(true)
-                                      .fixVersions(Map.of("master", "12u14"))
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and commit a fix
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            issue.setProperty("fixVersions", JSON.array().add("12-pool").add("tbd13").add("unknown"));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The fixVersion should have been updated
-            assertEquals(Set.of("12u14"), fixVersions(issue));
-        }
-    }
-
-    @Test
-    void testIssueBackport(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType(), Path.of("appendable.txt"), Set.of(), null);
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .commitLink(false)
-                                      .setFixVersion(true)
-                                      .fixVersions(Map.of("master", "12.0.2"))
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and commit a fix
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"),
-                                                 Map.of("issuetype", JSON.of("Enhancement"),
-                                                        "customfield_10008", JSON.object()
-                                                                                 .put("id", 244)
-                                                                                 .put("name", "java.io"),
-                                                        "customfield_10005", JSON.array()
-                                                                                 .add(JSON.object()
-                                                                                          .put("id", "17010")
-                                                                                          .put("value", "generic"))
-                                                                                 .add(JSON.object()
-                                                                                          .put("id", "17019")
-                                                                                          .put("value", "other"))
-                                                 ));
-            issue.setProperty("fixVersions", JSON.array().add("13.0.1"));
-            issue.setProperty("priority", JSON.of("1"));
-
-            var authorEmailAddress = issueProject.issueTracker().currentUser().userName() + "@openjdk.org";
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue", "Duke", authorEmailAddress);
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The fixVersion should not have been updated
-            var updatedIssue = issueProject.issue(issue.id()).orElseThrow();
-            assertEquals(Set.of("13.0.1"), fixVersions(updatedIssue));
-            assertEquals(OPEN, updatedIssue.state());
-            assertEquals(List.of(), updatedIssue.assignees());
-
-            // There should be a link
-            var links = updatedIssue.links();
-            assertEquals(1, links.size());
-            var link = links.get(0);
-            var backport = link.issue().orElseThrow();
-
-            // The backport issue should have a correct fixVersion and assignee
-            assertEquals(Set.of("12.0.2"), fixVersions(backport));
-            assertEquals(RESOLVED, backport.state());
-            assertEquals(List.of(issueProject.issueTracker().currentUser()), backport.assignees());
-
-            // Custom properties should also propagate
-            assertEquals("1", backport.properties().get("priority").asString());
-            assertEquals(244, backport.properties().get("customfield_10008").get("id").asInt());
-            assertEquals("java.io", backport.properties().get("customfield_10008").get("name").asString());
-            assertEquals(2, backport.properties().get("customfield_10005").asArray().size());
-        }
-    }
-
-    @Test
-    void testPullRequest(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var reviewer = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var reviewIcon = URI.create("http://www.example.com/review.png");
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewIcon(reviewIcon)
-                                      .commitLink(false)
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .prUpdaters(List.of(updater))
-                                     .readyLabels(Set.of("rfr"))
-                                     .readyComments(Map.of(reviewer.forge().currentUser().userName(), Pattern.compile("This is now ready")))
-                                     .build();
-
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and a pull request to fix it
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "Fix that issue");
-            localRepo.push(editHash, repo.url(), "edit", true);
-            var pr = credentials.createPullRequest(repo, "edit", "master", issue.id() + ": Fix that issue");
-            pr.setBody("\n\n### Issue\n * [" + issue.id() + "](http://www.test.test/): The issue");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The issue should not yet contain a link to the PR
-            var links = issue.links();
-            assertEquals(0, links.size());
-
-            // Just a label isn't enough
-            pr.addLabel("rfr");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            links = issue.links();
-            assertEquals(0, links.size());
-
-            // Neither is just a comment
-            pr.removeLabel("rfr");
-            var reviewPr = reviewer.pullRequest(pr.id());
-            reviewPr.addComment("This is now ready");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            links = issue.links();
-            assertEquals(0, links.size());
-
-            // Both are needed
-            pr.addLabel("rfr");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The issue should now contain a link to the PR
-            links = issue.links();
-            assertEquals(1, links.size());
-            assertEquals(pr.webUrl(), links.get(0).uri().orElseThrow());
-            assertEquals(reviewIcon, links.get(0).iconUrl().orElseThrow());
-
-            // Add another issue
-            var issue2 = issueProject.createIssue("This is another issue", List.of("Yes indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            pr.setBody("\n\n### Issues\n * [" + issue.id() + "](http://www.test.test/): The issue\n * [" + issue2.id() +
-                               "](http://www.test2.test/): The second issue");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Both issues should contain a link to the PR
-            var links1 = issue.links();
-            assertEquals(1, links1.size());
-            assertEquals(pr.webUrl(), links1.get(0).uri().orElseThrow());
-            var links2 = issue2.links();
-            assertEquals(1, links2.size());
-            assertEquals(pr.webUrl(), links2.get(0).uri().orElseThrow());
-
-            // Drop the first one
-            pr.setBody("\n\n### Issues\n * [" + issue2.id() + "](http://www.test2.test/): That other issue");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Only the second issue should now contain a link to the PR
-            links1 = issue.links();
-            assertEquals(0, links1.size());
-            links2 = issue2.links();
-            assertEquals(1, links2.size());
-            assertEquals(pr.webUrl(), links2.get(0).uri().orElseThrow());
-        }
-    }
-
-    @Test
-    void testPullRequestNoReview(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var reviewer = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var reviewIcon = URI.create("http://www.example.com/review.png");
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewLink(false)
-                                      .reviewIcon(reviewIcon)
-                                      .commitLink(false)
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .prUpdaters(List.of(updater)).readyLabels(Set.of("rfr"))
-                                     .readyComments(Map.of(reviewer.forge().currentUser().userName(), Pattern.compile("This is now ready")))
-                                     .build();
-            // Initialize history
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and a pull request to fix it
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "Fix that issue");
-            localRepo.push(editHash, repo.url(), "edit", true);
-            var pr = credentials.createPullRequest(repo, "edit", "master", issue.id() + ": Fix that issue");
-            pr.setBody("\n\n### Issue\n * [" + issue.id() + "](http://www.test.test/): The issue");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Add required label
-            pr.addLabel("rfr");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // And the required comment
-            var reviewPr = reviewer.pullRequest(pr.id());
-            reviewPr.addComment("This is now ready");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The issue should still not contain a link to the PR
-            var links = issue.links();
-            assertEquals(0, links.size());
-        }
-    }
-
-    @Test
-    void testPullRequestPROnly(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prIssuesStorage = createPullRequestIssuesStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var issueProject = credentials.getIssueProject();
-            var reviewIcon = URI.create("http://www.example.com/review.png");
-            var updater = IssueUpdater.newBuilder()
-                                      .issueProject(issueProject)
-                                      .reviewIcon(reviewIcon)
-                                      .commitLink(false)
-                                      .prOnly(true)
-                                      .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile(".*"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prIssuesStorageBuilder(prIssuesStorage)
-                                     .updaters(List.of(updater))
-                                     .prUpdaters(List.of(updater))
-                                     .build();
-
-            // Initialize history
-            localRepo.push(localRepo.resolve("master").orElseThrow(), repo.url(), "other");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // Create an issue and a pull request to fix it
-            var issue = issueProject.createIssue("This is an issue", List.of("Indeed"), Map.of("issuetype", JSON.of("Enhancement")));
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", issue.id() + ": Fix that issue");
-            localRepo.push(editHash, repo.url(), "edit", true);
-            var pr = credentials.createPullRequest(repo, "other", "edit", issue.id() + ": Fix that issue");
-            pr.setBody("\n\n### Issue\n * [" + issue.id() + "](http://www.test.test/): The issue");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The issue should now contain a link to the PR
-            var links = issue.links();
-            assertEquals(1, links.size());
-            assertEquals(pr.webUrl(), links.get(0).uri().orElseThrow());
-            assertEquals(reviewIcon, links.get(0).iconUrl().orElseThrow());
-
-            // Simulate integration
-            pr.addComment("Pushed as commit " + editHash.hex() + ".");
-            localRepo.push(editHash, repo.url(), "other");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // The changeset should be reflected in a comment
-            var updatedIssue = issueProject.issue(issue.id()).orElseThrow();
-
-            var comments = updatedIssue.comments();
-            assertEquals(1, comments.size());
-            var comment = comments.get(0);
-            assertTrue(comment.body().contains(editHash.abbreviate()));
-
-            // Now simulate a merge to another branch
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-
-            // No additional comment should have been made
-            updatedIssue = issueProject.issue(issue.id()).orElseThrow();
-            comments = updatedIssue.comments();
-            assertEquals(1, comments.size());
-        }
-    }
-
     private static class TestRepositoryUpdateConsumer implements RepositoryUpdateConsumer {
         private final String name;
         private final boolean idempotent;
         private int updateCount = 0;
         private boolean shouldFail = false;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff cli/src/main/java/org/openjdk/skara/cli/pr/GitPrCreate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>cli/src/main/java/org/openjdk/skara/cli/pr/GitPrCreate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 92         );
 93 
 94         var inputs = List.of(
 95             Input.position(0)
 96                  .describe(&quot;ID&quot;)
 97                  .singular()
 98                  .optional()
 99         );
100 
101         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
102         var arguments = parse(parser, args);
103         var repo = getRepo();
104         var uri = getURI(repo, arguments);
105         var host = getForge(uri, repo, arguments);
106         var remote = getRemote(repo, arguments);
107         var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
108                 System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
109                 System.exit(1);
110                 return null;
111         });
<span class="line-modified">112         if (currentBranch.equals(repo.defaultBranch())) {</span>
<span class="line-modified">113             System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);</span>












114             System.err.println(&quot;&quot;);
<span class="line-modified">115             System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);</span>
116             System.err.println(&quot;&quot;);
117             System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
<span class="line-modified">118             System.err.println(&quot;    git branch --force master origin/master&quot;);</span>
119             System.err.println(&quot;&quot;);
120             System.exit(1);
121         }
122 
123         var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
124         if (!ignoreWorkspace) {
125             var diff = repo.diff(repo.head());
126             if (!diff.patches().isEmpty()) {
127                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
128                 System.err.println(&quot;&quot;);
129                 for (var patch : diff.patches()) {
130                     var path = patch.target().path().isPresent() ?
131                         patch.target().path().get() : patch.source().path().get();
132                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
133                 }
134                 System.err.println(&quot;&quot;);
135                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
136                 System.err.println(&quot;&quot;);
137                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
138                 System.err.println(&quot;&quot;);
139                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
140                 System.err.println(&quot;&quot;);
141                 System.err.println(&quot;    git stash&quot;);
142                 System.err.println(&quot;&quot;);
143                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
<span class="line-removed">144                 System.exit(1);</span>
<span class="line-removed">145             }</span>
<span class="line-removed">146         }</span>
<span class="line-removed">147 </span>
<span class="line-removed">148         var upstream = repo.upstreamFor(currentBranch);</span>
<span class="line-removed">149         if (upstream.isEmpty()) {</span>
<span class="line-removed">150             var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);</span>
<span class="line-removed">151             if (shouldPublish) {</span>
<span class="line-removed">152                 GitPublish.main(new String[] { &quot;--quiet&quot;, remote });</span>
<span class="line-removed">153                 upstream = repo.upstreamFor(currentBranch);</span>
<span class="line-removed">154             } else {</span>
<span class="line-removed">155                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);</span>
<span class="line-removed">156                 System.err.println(&quot;&quot;);</span>
<span class="line-removed">157                 System.err.println(&quot;A remote branch must be present at &quot; + uri + &quot; to create a pull request&quot;);</span>
<span class="line-removed">158                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);</span>
159                 System.err.println(&quot;&quot;);
<span class="line-modified">160                 System.err.println(&quot;    git publish&quot;);</span>
161                 System.err.println(&quot;&quot;);
<span class="line-modified">162                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);</span>
<span class="line-removed">163                 System.err.println(&quot;To update remote information for this repository, run:&quot;);</span>
<span class="line-removed">164                 System.err.println(&quot;&quot;);</span>
<span class="line-removed">165                 System.err.println(&quot;    git fetch &quot; + remote);</span>
<span class="line-removed">166                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);</span>
167                 System.err.println(&quot;&quot;);
168                 System.exit(1);
169             }
170         }
171 
<span class="line-modified">172         var upstreamRefName = upstream.get().substring(remote.length() + 1);</span>
<span class="line-modified">173         repo.fetch(uri, upstreamRefName);</span>




















174 
175         var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
<span class="line-modified">176         if (!shouldIgnoreLocalCommits) {</span>



177             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
178             if (!branchCommits.isEmpty()) {
179                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + uri);
180                 System.err.println(&quot;&quot;);
181                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
182                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
183                 System.err.println(&quot;&quot;);
184                 for (var commit : branchCommits) {
185                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
186                 }
187                 System.err.println(&quot;&quot;);
188                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
189                 System.err.println(&quot;&quot;);
190                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
191                 System.err.println(&quot;&quot;);




192                 System.exit(1);
193             }
194         }
195 
<span class="line-removed">196         var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;</span>
<span class="line-removed">197                 new IOException(&quot;Could not find repository at &quot; + uri.toString())</span>
<span class="line-removed">198         );</span>
<span class="line-removed">199         var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;</span>
<span class="line-removed">200                 new IOException(&quot;error: remote repository &quot; + uri + &quot; is not a fork of any repository&quot;)</span>
<span class="line-removed">201         );</span>
<span class="line-removed">202 </span>
203         var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
204         if (targetBranch == null) {
<span class="line-removed">205             var upstreamBranchNames = repo.remoteBranches(parentRepo.webUrl().toString())</span>
<span class="line-removed">206                                           .stream()</span>
<span class="line-removed">207                                           .map(r -&gt; r.name())</span>
<span class="line-removed">208                                           .collect(Collectors.toSet());</span>
209             var remoteBranches = repo.branches(remote);
210             var candidates = new ArrayList&lt;Branch&gt;();
211             for (var b : remoteBranches) {
212                 var withoutRemotePrefix = b.name().substring(remote.length() + 1);
213                 if (upstreamBranchNames.contains(withoutRemotePrefix)) {
214                     candidates.add(b);
215                 }
216             }
217 
218             var localBranches = repo.branches();
219             Branch closest = null;
220             var shortestDistance = Integer.MAX_VALUE;
221             for (var b : candidates) {
222                 var from = b.name();
223                 for (var localBranch : localBranches) {
224                     var trackingBranch = repo.upstreamFor(localBranch);
225                     if (trackingBranch.isPresent() &amp;&amp;
226                         trackingBranch.get().equals(b.name())) {
227                         from = localBranch.name();
228                     }
229                 }
230                 var distance = repo.commitMetadata(from + &quot;...&quot; + currentBranch.name()).size();
231                 if (distance &lt; shortestDistance) {
232                     closest = b;
233                     shortestDistance = distance;
234                 }
235             }
236 
237             if (closest != null) {
238                 targetBranch = closest.name().substring(remote.length() + 1);
239             } else {
240                 System.err.println(&quot;error: cannot automatically infer target branch&quot;);
241                 System.err.println(&quot;       use --branch to specify target branch&quot;);
242                 System.exit(1);
243             }
244         }
<span class="line-modified">245         var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();</span>


246         if (commits.isEmpty()) {
<span class="line-modified">247             System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());</span>
248             System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
249             System.exit(1);
250         }
251 
252         var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
253         if (shouldRunJCheck) {
<span class="line-modified">254             var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };</span>
255             var err = GitJCheck.run(jcheckArgs);
256             if (err != 0) {
257                 System.exit(err);
258             }
259         }
260 
261         var project = jbsProjectFromJcheckConf(repo, targetBranch);
262         var issue = getIssue(currentBranch, project);
263         var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
264         if (issue.isPresent()) {
265             Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
266         } else if (commits.size() == 1) {
267             var commit = commits.get(0);
268             issue = getIssue(commit, project);
269             if (issue.isPresent()) {
270                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
271             } else {
272                 var message = CommitMessageParsers.v1.parse(commit.message());
273                 Files.writeString(file, message.title() + &quot;\n&quot;);
274                 if (!message.summaries().isEmpty()) {
</pre>
<hr />
<pre>
328                          .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
329                          .collect(Collectors.toList());
330         var isEmpty = lines.stream().allMatch(String::isEmpty);
331         if (isEmpty) {
332             System.err.println(&quot;error: no message present, aborting&quot;);
333             System.exit(1);
334         }
335 
336         var title = lines.get(0);
337         List&lt;String&gt; body = null;
338         if (lines.size() &gt; 1) {
339             body = lines.subList(1, lines.size())
340                         .stream()
341                         .dropWhile(String::isEmpty)
342                         .collect(Collectors.toList());
343         } else {
344             body = List.of();
345         }
346 
347         var isDraft = getSwitch(&quot;draft&quot;, &quot;create&quot;, arguments);



348         var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body, isDraft);
349         var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
350         if (assigneesOption != null) {
351             var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
352             var assignees = usernames.stream()
353                                      .map(u -&gt; host.user(u))
354                                      .filter(Optional::isPresent)
355                                      .map(Optional::get)
356                                      .collect(Collectors.toList());
357             pr.setAssignees(assignees);
358         }
359         System.out.println(pr.webUrl().toString());
360         Files.deleteIfExists(file);
361 
362         repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
363     }
364 }
</pre>
</td>
<td>
<hr />
<pre>
 92         );
 93 
 94         var inputs = List.of(
 95             Input.position(0)
 96                  .describe(&quot;ID&quot;)
 97                  .singular()
 98                  .optional()
 99         );
100 
101         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
102         var arguments = parse(parser, args);
103         var repo = getRepo();
104         var uri = getURI(repo, arguments);
105         var host = getForge(uri, repo, arguments);
106         var remote = getRemote(repo, arguments);
107         var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
108                 System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
109                 System.exit(1);
110                 return null;
111         });
<span class="line-modified">112 </span>
<span class="line-modified">113         var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;</span>
<span class="line-added">114                 new IOException(&quot;Could not find repository at &quot; + uri.toString())</span>
<span class="line-added">115         );</span>
<span class="line-added">116         var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;</span>
<span class="line-added">117                 new IOException(&quot;error: remote repository &quot; + uri + &quot; is not a fork of any repository&quot;)</span>
<span class="line-added">118         );</span>
<span class="line-added">119 </span>
<span class="line-added">120         var upstreamBranchNames = repo.remoteBranches(parentRepo.webUrl().toString())</span>
<span class="line-added">121                                       .stream()</span>
<span class="line-added">122                                       .map(r -&gt; r.name())</span>
<span class="line-added">123                                       .collect(Collectors.toSet());</span>
<span class="line-added">124         if (upstreamBranchNames.contains(currentBranch.name())) {</span>
<span class="line-added">125             System.err.println(&quot;error: you should not create pull requests from a branch present in the upstream repository.&quot;);</span>
126             System.err.println(&quot;&quot;);
<span class="line-modified">127             System.err.println(&quot;To create a local branch for your changes and restore the &#39;&quot; + currentBranch.name() + &quot;&#39; branch, run:&quot;);</span>
128             System.err.println(&quot;&quot;);
129             System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
<span class="line-modified">130             System.err.println(&quot;    git branch --force &quot; + currentBranch.name() + &quot; origin/&quot; + currentBranch.name());</span>
131             System.err.println(&quot;&quot;);
132             System.exit(1);
133         }
134 
135         var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
136         if (!ignoreWorkspace) {
137             var diff = repo.diff(repo.head());
138             if (!diff.patches().isEmpty()) {
139                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
140                 System.err.println(&quot;&quot;);
141                 for (var patch : diff.patches()) {
142                     var path = patch.target().path().isPresent() ?
143                         patch.target().path().get() : patch.source().path().get();
144                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
145                 }
146                 System.err.println(&quot;&quot;);
147                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
148                 System.err.println(&quot;&quot;);
149                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
150                 System.err.println(&quot;&quot;);
151                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
152                 System.err.println(&quot;&quot;);
153                 System.err.println(&quot;    git stash&quot;);
154                 System.err.println(&quot;&quot;);
155                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);















156                 System.err.println(&quot;&quot;);
<span class="line-modified">157                 System.err.println(&quot;If you want to ignore this error, run:&quot;);</span>
158                 System.err.println(&quot;&quot;);
<span class="line-modified">159                 System.err.println(&quot;     git config --global pr.create.ignore-workspace true&quot;);</span>




160                 System.err.println(&quot;&quot;);
161                 System.exit(1);
162             }
163         }
164 
<span class="line-modified">165         var upstream = repo.upstreamFor(currentBranch);</span>
<span class="line-modified">166         var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);</span>
<span class="line-added">167         if (upstream.isEmpty() &amp;&amp; !shouldPublish) {</span>
<span class="line-added">168             System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);</span>
<span class="line-added">169             System.err.println(&quot;&quot;);</span>
<span class="line-added">170             System.err.println(&quot;A remote branch must be present at &quot; + uri + &quot; to create a pull request&quot;);</span>
<span class="line-added">171             System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);</span>
<span class="line-added">172             System.err.println(&quot;&quot;);</span>
<span class="line-added">173             System.err.println(&quot;    git publish&quot;);</span>
<span class="line-added">174             System.err.println(&quot;&quot;);</span>
<span class="line-added">175             System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);</span>
<span class="line-added">176             System.err.println(&quot;To update remote information for this repository, run:&quot;);</span>
<span class="line-added">177             System.err.println(&quot;&quot;);</span>
<span class="line-added">178             System.err.println(&quot;    git fetch &quot; + remote);</span>
<span class="line-added">179             System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);</span>
<span class="line-added">180             System.err.println(&quot;&quot;);</span>
<span class="line-added">181             System.err.println(&quot;If you want &#39;git pr create&#39; to automatically publish branches, run:&quot;);</span>
<span class="line-added">182             System.err.println(&quot;&quot;);</span>
<span class="line-added">183             System.err.println(&quot;    git config --global pr.create.publish true&quot;);</span>
<span class="line-added">184             System.err.println(&quot;&quot;);</span>
<span class="line-added">185             System.exit(1);</span>
<span class="line-added">186         }</span>
187 
188         var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
<span class="line-modified">189         if (!shouldIgnoreLocalCommits &amp;&amp; !shouldPublish) {</span>
<span class="line-added">190             var upstreamRefName = upstream.get().substring(remote.length() + 1);</span>
<span class="line-added">191             repo.fetch(uri, upstreamRefName);</span>
<span class="line-added">192 </span>
193             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
194             if (!branchCommits.isEmpty()) {
195                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + uri);
196                 System.err.println(&quot;&quot;);
197                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
198                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
199                 System.err.println(&quot;&quot;);
200                 for (var commit : branchCommits) {
201                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
202                 }
203                 System.err.println(&quot;&quot;);
204                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
205                 System.err.println(&quot;&quot;);
206                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
207                 System.err.println(&quot;&quot;);
<span class="line-added">208                 System.err.println(&quot;If you want to ignore this error, run:&quot;);</span>
<span class="line-added">209                 System.err.println(&quot;&quot;);</span>
<span class="line-added">210                 System.err.println(&quot;     git config --global pr.create.ignore-local-commits true&quot;);</span>
<span class="line-added">211                 System.err.println(&quot;&quot;);</span>
212                 System.exit(1);
213             }
214         }
215 







216         var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
217         if (targetBranch == null) {




218             var remoteBranches = repo.branches(remote);
219             var candidates = new ArrayList&lt;Branch&gt;();
220             for (var b : remoteBranches) {
221                 var withoutRemotePrefix = b.name().substring(remote.length() + 1);
222                 if (upstreamBranchNames.contains(withoutRemotePrefix)) {
223                     candidates.add(b);
224                 }
225             }
226 
227             var localBranches = repo.branches();
228             Branch closest = null;
229             var shortestDistance = Integer.MAX_VALUE;
230             for (var b : candidates) {
231                 var from = b.name();
232                 for (var localBranch : localBranches) {
233                     var trackingBranch = repo.upstreamFor(localBranch);
234                     if (trackingBranch.isPresent() &amp;&amp;
235                         trackingBranch.get().equals(b.name())) {
236                         from = localBranch.name();
237                     }
238                 }
239                 var distance = repo.commitMetadata(from + &quot;...&quot; + currentBranch.name()).size();
240                 if (distance &lt; shortestDistance) {
241                     closest = b;
242                     shortestDistance = distance;
243                 }
244             }
245 
246             if (closest != null) {
247                 targetBranch = closest.name().substring(remote.length() + 1);
248             } else {
249                 System.err.println(&quot;error: cannot automatically infer target branch&quot;);
250                 System.err.println(&quot;       use --branch to specify target branch&quot;);
251                 System.exit(1);
252             }
253         }
<span class="line-modified">254 </span>
<span class="line-added">255         var headRef = upstream.isEmpty() ? currentBranch.name() : upstream.get();</span>
<span class="line-added">256         var commits = repo.commits(targetBranch + &quot;..&quot; + headRef).asList();</span>
257         if (commits.isEmpty()) {
<span class="line-modified">258             System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + headRef);</span>
259             System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
260             System.exit(1);
261         }
262 
263         var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
264         if (shouldRunJCheck) {
<span class="line-modified">265             var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + headRef };</span>
266             var err = GitJCheck.run(jcheckArgs);
267             if (err != 0) {
268                 System.exit(err);
269             }
270         }
271 
272         var project = jbsProjectFromJcheckConf(repo, targetBranch);
273         var issue = getIssue(currentBranch, project);
274         var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
275         if (issue.isPresent()) {
276             Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
277         } else if (commits.size() == 1) {
278             var commit = commits.get(0);
279             issue = getIssue(commit, project);
280             if (issue.isPresent()) {
281                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
282             } else {
283                 var message = CommitMessageParsers.v1.parse(commit.message());
284                 Files.writeString(file, message.title() + &quot;\n&quot;);
285                 if (!message.summaries().isEmpty()) {
</pre>
<hr />
<pre>
339                          .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
340                          .collect(Collectors.toList());
341         var isEmpty = lines.stream().allMatch(String::isEmpty);
342         if (isEmpty) {
343             System.err.println(&quot;error: no message present, aborting&quot;);
344             System.exit(1);
345         }
346 
347         var title = lines.get(0);
348         List&lt;String&gt; body = null;
349         if (lines.size() &gt; 1) {
350             body = lines.subList(1, lines.size())
351                         .stream()
352                         .dropWhile(String::isEmpty)
353                         .collect(Collectors.toList());
354         } else {
355             body = List.of();
356         }
357 
358         var isDraft = getSwitch(&quot;draft&quot;, &quot;create&quot;, arguments);
<span class="line-added">359         if (upstream.isEmpty() &amp;&amp; shouldPublish) {</span>
<span class="line-added">360             GitPublish.main(new String[] { &quot;--quiet&quot;, remote });</span>
<span class="line-added">361         }</span>
362         var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body, isDraft);
363         var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
364         if (assigneesOption != null) {
365             var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
366             var assignees = usernames.stream()
367                                      .map(u -&gt; host.user(u))
368                                      .filter(Optional::isPresent)
369                                      .map(Optional::get)
370                                      .collect(Collectors.toList());
371             pr.setAssignees(assignees);
372         }
373         System.out.println(pr.webUrl().toString());
374         Files.deleteIfExists(file);
375 
376         repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
377     }
378 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
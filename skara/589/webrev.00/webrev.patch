diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -50,12 +50,10 @@
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
     private final String progressMarker = "<!-- Anything below this marker will be automatically updated, please do not edit manually! -->";
     private final String mergeReadyMarker = "<!-- PullRequestBot merge is ready comment -->";
     private final String outdatedHelpMarker = "<!-- PullRequestBot outdated help comment -->";
     private final String sourceBranchWarningMarker = "<!-- PullRequestBot source branch warning comment -->";
-    private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
-    private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
     private final Set<String> newLabels;
 
     private CheckRun(CheckWorkItem workItem, PullRequest pr, PullRequestInstance prInstance, List<Comment> comments,
                      List<Review> allReviews, List<Review> activeReviews, Set<String> labels,
                      CensusInstance censusInstance, boolean ignoreStaleReviews) {
@@ -110,46 +108,12 @@
         }
 
         return ((names.size() == 1) && emails.size() == 1);
     }
 
-    private static class MergeSource {
-        private final String repositoryName;
-        private final String branchName;
-
-        private MergeSource(String repositoryName, String branchName) {
-            this.repositoryName = repositoryName;
-            this.branchName = branchName;
-        }
-    }
-
-    private Optional<MergeSource> mergeSource() {
-        var repoMatcher = mergeSourceFullPattern.matcher(pr.title());
-        if (!repoMatcher.matches()) {
-            var branchMatcher = mergeSourceBranchOnlyPattern.matcher(pr.title());
-            if (!branchMatcher.matches()) {
-                return Optional.empty();
-            }
-
-            // Verify that the branch exists
-            var isValidBranch = prInstance.remoteBranches().stream()
-                                          .map(Reference::name)
-                                          .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
-            if (!isValidBranch) {
-                // Assume the name refers to a sibling repository
-                var repoName = Path.of(pr.repository().name()).resolveSibling(branchMatcher.group(1)).toString();
-                return Optional.of(new MergeSource(repoName, "master"));
-            }
-
-            return Optional.of(new MergeSource(pr.repository().name(), branchMatcher.group(1)));
-        }
-
-        return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
-    }
-
     // Additional bot-specific checks that are not handled by JCheck
-    private List<String> botSpecificChecks() throws IOException {
+    private List<String> botSpecificChecks(Hash finalHash) throws IOException {
         var ret = new ArrayList<String>();
 
         if (bodyWithoutStatus().isBlank()) {
             var error = "The pull request body must not be empty.";
             ret.add(error);
@@ -163,67 +127,19 @@
             ret.add(error);
         }
 
         var baseHash = prInstance.baseHash();
         var headHash = pr.headHash();
-        var commits = prInstance.localRepo().commitMetadata(baseHash, headHash);
+        var originalCommits = prInstance.localRepo().commitMetadata(baseHash, headHash);
 
-        if (!checkCommitAuthor(commits)) {
+        if (!checkCommitAuthor(originalCommits)) {
             var error = "For contributors who are not existing OpenJDK Authors, commit attribution will be taken from " +
                     "the commits in the PR. However, the commits in this PR have inconsistent user names and/or " +
                     "email addresses. Please amend the commits.";
             ret.add(error);
         }
 
-        if (pr.title().startsWith("Merge")) {
-            if (commits.size() < 2) {
-                ret.add("A Merge PR must contain at least two commits that are not already present in the target.");
-            } else {
-                // Find the first merge commit - the very last commit is not eligible (as the merge needs a parent)
-                int mergeCommitIndex = commits.size();
-                for (int i = 0; i < commits.size() - 1; ++i) {
-                    if (commits.get(i).isMerge()) {
-                        mergeCommitIndex = i;
-                        break;
-                    }
-                }
-                if (mergeCommitIndex >= commits.size() - 1) {
-                    ret.add("A Merge PR must contain a merge commit as well as at least one other commit from the merge source.");
-                }
-
-                var source = mergeSource();
-                if (source.isPresent()) {
-                    try {
-                        var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() ->
-                                new RuntimeException("Could not find repository " + source.get().repositoryName)
-                        );
-                        try {
-                            var sourceHash = prInstance.localRepo().fetch(mergeSourceRepo.url(), source.get().branchName, false);
-                            var mergeCommit = commits.get(mergeCommitIndex);
-                            for (int i = 0; i < mergeCommit.parents().size(); ++i) {
-                                if (!prInstance.localRepo().isAncestor(mergeCommit.parents().get(i), sourceHash)) {
-                                    if (!mergeCommit.parents().get(i).equals(prInstance.targetHash())) {
-                                        ret.add("The merge contains commits that are neither ancestors of the source nor the target.");
-                                        break;
-                                    }
-                                }
-                            }
-                        } catch (IOException e) {
-                            ret.add("Could not fetch branch `" + source.get().branchName + "` from project `" +
-                                            source.get().repositoryName + "` - check that they are correct.");
-                        }
-                    } catch (RuntimeException e) {
-                        ret.add("Could not find project `" +
-                                        source.get().repositoryName + "` - check that it is correct.");
-                    }
-                } else {
-                    ret.add("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
-                            "Merge `project`:`branch` to allow verification of the merge contents.");
-                }
-            }
-        }
-
         for (var blocker : workItem.bot.blockingCheckLabels().entrySet()) {
             if (labels.contains(blocker.getKey())) {
                 ret.add(blocker.getValue());
             }
         }
@@ -665,34 +581,35 @@
 
         try {
             // Post check in-progress
             log.info("Starting to run jcheck on PR head");
             pr.createCheck(checkBuilder.build());
+
+            var ignored = new PrintWriter(new StringWriter());
+            var rebasePossible = true;
+            var commitHash = pr.headHash();
+            var mergedHash = prInstance.mergeTarget(ignored);
+            if (mergedHash.isPresent()) {
+                commitHash = mergedHash.get();
+            } else {
+                rebasePossible = false;
+            }
+
             List<String> additionalErrors = List.of();
             Hash localHash;
             try {
-                localHash = prInstance.commit(censusInstance.namespace(), censusDomain, null);
+                localHash = prInstance.commit(commitHash, censusInstance.namespace(), censusDomain, null);
             } catch (CommitFailure e) {
-                additionalErrors = List.of("It was not possible to create a commit for the changes in this PR: " + e.getMessage());
+                additionalErrors = List.of(e.getMessage());
                 localHash = prInstance.baseHash();
             }
-            boolean rebasePossible = true;
             PullRequestCheckIssueVisitor visitor = prInstance.createVisitor(localHash, censusInstance);
             if (!localHash.equals(prInstance.baseHash())) {
-                // Try to rebase
-                var ignored = new PrintWriter(new StringWriter());
-                var rebasedHash = prInstance.rebase(localHash, ignored);
-                if (rebasedHash.isEmpty()) {
-                    rebasePossible = false;
-                } else {
-                    localHash = rebasedHash.get();
-                }
-
                 // Determine current status
                 var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), comments);
                 prInstance.executeChecks(localHash, censusInstance, visitor, additionalConfiguration);
-                additionalErrors = botSpecificChecks();
+                additionalErrors = botSpecificChecks(localHash);
             } else {
                 if (additionalErrors.isEmpty()) {
                     additionalErrors = List.of("This PR contains no changes");
                 }
             }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
@@ -94,12 +94,10 @@
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var prInstance = new PullRequestInstance(path,
                                                      new HostedRepositoryPool(seedPath),
                                                      pr,
                                                      bot.ignoreStaleReviews());
-            var localHash = prInstance.commit(censusInstance.namespace(), censusInstance.configuration().census().domain(), null);
-
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
                 var wantedHash = new Hash(args);
                 if (!prInstance.targetHash().equals(wantedHash)) {
@@ -107,22 +105,20 @@
                     reply.println(" - it has moved to " + prInstance.targetHash() + ". Aborting integration.");
                     return;
                 }
             };
 
-            // Now rebase onto the target hash
+            // Now merge the latest changes from the target
             var rebaseWriter = new PrintWriter(rebaseMessage);
-            var rebasedHash = prInstance.rebase(localHash, rebaseWriter);
+            var rebasedHash = prInstance.mergeTarget(rebaseWriter);
             if (rebasedHash.isEmpty()) {
                 reply.println(rebaseMessage.toString());
                 return;
-            } else {
-                if (!rebasedHash.get().equals(localHash)) {
-                    localHash = rebasedHash.get();
-                }
             }
 
+            var localHash = prInstance.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(), null);
+
             var issues = prInstance.createVisitor(localHash, censusInstance);
             var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), allComments);
             prInstance.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
             if (!issues.getMessages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
@@ -157,12 +153,11 @@
                 reply.print("Warning! Your commit did not result in any changes! ");
                 reply.println("No push attempt will be made.");
             }
         } catch (Exception e) {
             log.throwing("IntegrateCommand", "handle", e);
-            reply.println("An error occurred during final integration jcheck");
-            throw new RuntimeException(e);
+            reply.println("An error occurred during final integration jcheck. No push attempt will be made.");
         }
     }
 
     @Override
     public String description() {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
@@ -22,19 +22,20 @@
  */
 package org.openjdk.skara.bots.pr;
 
 import org.openjdk.skara.census.*;
 import org.openjdk.skara.forge.*;
-import org.openjdk.skara.host.*;
-import org.openjdk.skara.jcheck.*;
+import org.openjdk.skara.host.HostUser;
+import org.openjdk.skara.jcheck.JCheck;
 import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.Issue;
 import org.openjdk.skara.vcs.openjdk.*;
 
 import java.io.*;
 import java.nio.file.Path;
+import java.time.ZonedDateTime;
 import java.util.*;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 class CommitFailure extends Exception {
     CommitFailure(String reason) {
         super(reason);
@@ -105,18 +106,11 @@
         summary.ifPresent(commitMessageBuilder::summary);
 
         return String.join("\n", commitMessageBuilder.format(CommitMessageFormatters.v1));
     }
 
-    private Hash commitSquashed(List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException {
-        localRepo.checkout(baseHash, true);
-        localRepo.squash(headHash);
-        if (localRepo.isClean()) {
-            // There are no changes remaining after squashing
-            return baseHash;
-        }
-
+    private Hash commitSquashed(Hash finalHead, List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException {
         Author committer;
         Author author;
         var contributor = namespace.get(pr.author().id());
 
         if (contributor == null) {
@@ -133,43 +127,127 @@
         } else {
             committer = author;
         }
 
         var commitMessage = commitMessage(activeReviews, namespace);
-        return localRepo.commit(commitMessage, author.name(), author.email(), committer.name(), committer.email());
+        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
+                committer.name(), committer.email(), ZonedDateTime.now(), List.of(targetHash), localRepo.tree(finalHead));
+    }
+
+    private static class MergeSource {
+        private final String repositoryName;
+        private final String branchName;
+
+        private MergeSource(String repositoryName, String branchName) {
+            this.repositoryName = repositoryName;
+            this.branchName = branchName;
+        }
+    }
+
+    private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
+    private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
+
+    private Optional<MergeSource> mergeSource() {
+        var repoMatcher = mergeSourceFullPattern.matcher(pr.title());
+        if (!repoMatcher.matches()) {
+            var branchMatcher = mergeSourceBranchOnlyPattern.matcher(pr.title());
+            if (!branchMatcher.matches()) {
+                return Optional.empty();
+            }
+
+            // Verify that the branch exists
+            var isValidBranch = remoteBranches().stream()
+                    .map(Reference::name)
+                    .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
+            if (!isValidBranch) {
+                // Assume the name refers to a sibling repository
+                var repoName = Path.of(pr.repository().name()).resolveSibling(branchMatcher.group(1)).toString();
+                return Optional.of(new MergeSource(repoName, "master"));
+            }
+
+            return Optional.of(new MergeSource(pr.repository().name(), branchMatcher.group(1)));
+        }
+
+        return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
     }
 
-    private Hash commitMerge(List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
-        // Find the first merge commit with an incoming parent outside of the merge target
-        // The very last commit is not eligible (as the merge needs a parent)
-        var commits = localRepo.commitMetadata(baseHash, headHash);
+    private CommitMetadata findSourceMergeCommit(List<CommitMetadata> commits) throws IOException, CommitFailure {
+        if (commits.size() < 2) {
+            throw new CommitFailure("A merge PR must contain at least two commits that are not already present in the target.");
+        }
+
+        var source = mergeSource();
+        if (source.isEmpty()) {
+            throw new CommitFailure("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
+                    "Merge `project`:`branch` to allow verification of the merge contents.");
+        }
+
+        // Fetch the source
+        Hash sourceHash;
+        try {
+            var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() ->
+                    new RuntimeException("Could not find repository " + source.get().repositoryName)
+            );
+            try {
+                sourceHash = localRepo.fetch(mergeSourceRepo.url(), source.get().branchName, false);
+            } catch (IOException e) {
+                throw new CommitFailure("Could not fetch branch `" + source.get().branchName + "` from project `" +
+                        source.get().repositoryName + "` - check that they are correct.");
+            }
+        } catch (RuntimeException e) {
+            throw new CommitFailure("Could not find project `" +
+                    source.get().repositoryName + "` - check that it is correct.");
+        }
+
+
+        // Find the first merge commit with a parent that is an ancestor of the source
         int mergeCommitIndex = commits.size();
         for (int i = 0; i < commits.size() - 1; ++i) {
             if (commits.get(i).isMerge()) {
                 boolean isSourceMerge = false;
                 for (int j = 0; j < commits.get(i).parents().size(); ++j) {
-                    if (!localRepo.isAncestor(baseHash, commits.get(i).parents().get(j))) {
+                    if (localRepo.isAncestor(commits.get(i).parents().get(j), sourceHash)) {
                         isSourceMerge = true;
                     }
                 }
                 if (isSourceMerge) {
                     mergeCommitIndex = i;
                     break;
-                } else {
-                    // TODO: We can solve this with retroactive rerere
-                    throw new CommitFailure("A merge PR is only allowed to contain a single merge commit. You will need to amend your commits.");
                 }
             }
         }
+        if (mergeCommitIndex >= commits.size() - 1) {
+            throw new CommitFailure("A merge PR must contain a merge commit as well as at least one other commit from the merge source.");
+        }
+
+        return commits.get(mergeCommitIndex);
+    }
 
-        if (mergeCommitIndex == commits.size()) {
-            throw new CommitFailure("No merge commit containing incoming commits from another branch than the target was found");
+    private Hash commitMerge(Hash finalHead, List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
+        var commits = localRepo.commitMetadata(baseHash, finalHead);
+        var mergeCommit = findSourceMergeCommit(commits);
+
+        // Find the parent which is on the target branch - we will replace it with the target hash (if there were no merge conflicts)
+        Hash firstParent = null;
+        var finalParents = new ArrayList<Hash>();
+        for (int i = 0; i < mergeCommit.parents().size(); ++i) {
+            if (localRepo.isAncestor(mergeCommit.parents().get(i), targetHash)) {
+                if (firstParent == null) {
+                    firstParent = localRepo.mergeBase(targetHash, finalHead);
+                    continue;
+                }
+            }
+            finalParents.add(mergeCommit.parents().get(i));
         }
+        if (firstParent == null) {
+            throw new CommitFailure("The merge commit must have a commit on the target branch as one of its parents.");
+        }
+        finalParents.add(0, firstParent);
 
         var contributor = namespace.get(pr.author().id());
         if (contributor == null) {
-            throw new CommitFailure("Merges can only be performed by Committers");
+            throw new CommitFailure("Merges can only be performed by Committers.");
         }
 
         var author = new Author(contributor.fullName().orElseThrow(), contributor.username() + "@" + censusDomain);
         Author committer;
         if (sponsorId != null) {
@@ -178,27 +256,28 @@
         } else {
             committer = author;
         }
         var commitMessage = commitMessage(activeReviews, namespace);
 
-        localRepo.checkout(commits.get(mergeCommitIndex).hash(), true);
-        localRepo.squash(headHash);
-
-        return localRepo.amend(commitMessage, author.name(), author.email(), committer.name(), committer.email());
+        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
+                committer.name(), committer.email(), ZonedDateTime.now(), finalParents, localRepo.tree(finalHead));
     }
 
     private boolean isMergeCommit() {
         return pr.title().startsWith("Merge");
     }
 
-    Hash commit(Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
+    Hash commit(Hash finalHead, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
         var activeReviews = filterActiveReviews(pr.reviews());
+        Hash commit;
         if (!isMergeCommit()) {
-            return commitSquashed(activeReviews, namespace, censusDomain, sponsorId);
+            commit = commitSquashed(finalHead, activeReviews, namespace, censusDomain, sponsorId);
         } else {
-            return commitMerge(activeReviews, namespace, censusDomain, sponsorId);
+            commit = commitMerge(finalHead, activeReviews, namespace, censusDomain, sponsorId);
         }
+        localRepo.checkout(commit, true);
+        return commit;
     }
 
     List<CommitMetadata> divergingCommits() {
         return divergingCommits(headHash);
     }
@@ -210,47 +289,40 @@
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 
-    Optional<Hash> rebase(Hash commitHash, PrintWriter reply) {
-        var divergingCommits = divergingCommits(commitHash);
+    Optional<Hash> mergeTarget(PrintWriter reply) {
+        var divergingCommits = divergingCommits(headHash);
         if (divergingCommits.size() > 0) {
             reply.print("The following commits have been pushed to ");
             reply.print(pr.targetRef());
             reply.println(" since your change was applied:");
             divergingCommits.forEach(c -> reply.println(" * " + c.hash().hex() + ": " + c.message().get(0)));
 
             try {
-                var commit = localRepo.lookup(commitHash).orElseThrow();
-                if (isMergeCommit()) {
-                    // TODO: We can solve this with retroactive rerere
-                    reply.println("Merge PRs cannot currently be automatically rebased. You will need to rebase it manually.");
-                    return Optional.empty();
-                }
-
-                localRepo.rebase(targetHash, commit.committer().name(), commit.committer().email());
+                localRepo.checkout(headHash, true);
+                localRepo.merge(targetHash);
+                var hash = localRepo.commit("Automatic merge with latest target", "duke", "duke@openjdk.org");
                 reply.println();
                 reply.println("Your commit was automatically rebased without conflicts.");
-                var hash = localRepo.head();
                 return Optional.of(hash);
             } catch (IOException e) {
                 reply.println();
                 reply.print("It was not possible to rebase your changes automatically. Please merge `");
                 reply.print(pr.targetRef());
                 reply.println("` into your branch and try again.");
                 try {
-                    localRepo.checkout(commitHash, true);
+                    localRepo.checkout(headHash, true);
                 } catch (IOException e2) {
                     throw new UncheckedIOException(e2);
                 }
-                pr.addLabel("merge-conflict");
                 return Optional.empty();
             }
         } else {
-            // No rebase needed
-            return Optional.of(commitHash);
+            // No merge needed
+            return Optional.of(headHash);
         }
     }
 
     Repository localRepo() {
         return localRepo;
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
@@ -79,13 +79,10 @@
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var prInstance = new PullRequestInstance(path,
                                                      new HostedRepositoryPool(seedPath),
                                                      pr,
                                                      bot.ignoreStaleReviews());
-            var localHash = prInstance.commit(censusInstance.namespace(), censusInstance.configuration().census().domain(),
-                                         comment.author().id());
-
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
                 var wantedHash = new Hash(args);
                 if (!prInstance.targetHash().equals(wantedHash)) {
@@ -95,20 +92,19 @@
                 }
             }
 
             // Now rebase onto the target hash
             var rebaseWriter = new PrintWriter(rebaseMessage);
-            var rebasedHash = prInstance.rebase(localHash, rebaseWriter);
+            var rebasedHash = prInstance.mergeTarget(rebaseWriter);
             if (rebasedHash.isEmpty()) {
                 reply.println(rebaseMessage.toString());
                 return;
-            } else {
-                if (!rebasedHash.get().equals(localHash)) {
-                    localHash = rebasedHash.get();
-                }
             }
 
+            var localHash = prInstance.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(),
+                    comment.author().id());
+
             var issues = prInstance.createVisitor(localHash, censusInstance);
             var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), allComments);
             prInstance.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
             if (!issues.getMessages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
@@ -132,12 +128,11 @@
                 reply.print("Warning! This commit did not result in any changes! ");
                 reply.println("No push attempt will be made.");
             }
         } catch (Exception e) {
             log.throwing("SponsorCommand", "handle", e);
-            reply.println("An error occurred during sponsored integration");
-            throw new RuntimeException(e);
+            reply.println("An error occurred during sponsored integration. No push attempt will be made.");
         }
     }
 
     @Override
     public String description() {
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
@@ -1178,10 +1178,11 @@
             // Verify that the check failed
             var checks = pr.checks(editHash);
             assertEquals(1, checks.size());
             var check = checks.get("jcheck");
             assertEquals(CheckStatus.FAILURE, check.status());
+            assertEquals("- This PR contains no changes", check.summary().orElseThrow());
         }
     }
 
     @Test
     void ignoreStale(TestInfo testInfo) throws IOException {
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
@@ -207,11 +207,10 @@
             assertEquals("integrationcommitter1@openjdk.java.net", headCommit.committer().email());
         }
     }
 
     @Test
-    @Disabled
     void branchMergeRebase(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory()) {
 
             var author = credentials.getHostedRepository();
@@ -302,11 +301,10 @@
             assertEquals("integrationcommitter1@openjdk.java.net", headCommit.committer().email());
         }
     }
 
     @Test
-    @Disabled
     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory()) {
 
             var author = credentials.getHostedRepository();
@@ -409,10 +407,14 @@
             var headCommit = pushedRepo.commits(headHash.hex() + "^.." + headHash.hex()).asList().get(0);
             assertEquals("Generated Committer 1", headCommit.author().name());
             assertEquals("integrationcommitter1@openjdk.java.net", headCommit.author().email());
             assertEquals("Generated Committer 1", headCommit.committer().name());
             assertEquals("integrationcommitter1@openjdk.java.net", headCommit.committer().email());
+
+            // The latest content from the source and the updated master should be present
+            assertEquals("New on master", Files.readString(pushedRepoFolder.resolve("newmaster.txt")));
+            assertEquals("Unrelated", Files.readString(pushedRepoFolder.resolve("unrelated.txt")));
         }
     }
 
     @Test
     void invalidMergeCommit(TestInfo testInfo) throws IOException {
@@ -466,11 +468,11 @@
                           .filter(comment -> comment.body().contains("did not complete successfully"))
                           .count();
             assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
             var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- It was not possible to create a commit for the changes in this PR: A merge PR is only allowed to contain a single merge commit. You will need to amend your commits.", check.summary().orElseThrow());
+            assertEquals("- The merge commit must have a commit on the target branch as one of its parents.", check.summary().orElseThrow());
         }
     }
 
     @Test
     void invalidSourceRepo(TestInfo testInfo) throws IOException {
@@ -712,11 +714,11 @@
                           .filter(comment -> comment.body().contains("did not complete successfully"))
                           .count();
             assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
             var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- The merge contains commits that are neither ancestors of the source nor the target.", check.summary().orElseThrow());
+            assertEquals("- A merge PR must contain a merge commit as well as at least one other commit from the merge source.", check.summary().orElseThrow());
         }
     }
 
     @Test
     void invalidAuthor(TestInfo testInfo) throws IOException {
@@ -844,11 +846,11 @@
                     .filter(comment -> comment.body().contains("did not complete successfully"))
                     .count();
             assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
             var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- The merge contains commits that are neither ancestors of the source nor the target.", check.summary().orElseThrow());
+            assertEquals("- The merge commit must have a commit on the target branch as one of its parents.", check.summary().orElseThrow());
         }
     }
 
     @Test
     void invalidSyntax(TestInfo testInfo) throws IOException {
@@ -900,10 +902,9 @@
                           .filter(comment -> comment.body().contains("did not complete successfully"))
                           .count();
             assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
             var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.\n" +
-                                 "- Merge commit message is not Merge, but: Merge this or that", check.summary().orElseThrow());
+            assertEquals("- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.", check.summary().orElseThrow());
         }
     }
 }
diff a/jcheck/src/test/java/org/openjdk/skara/jcheck/TestRepository.java b/jcheck/src/test/java/org/openjdk/skara/jcheck/TestRepository.java
--- a/jcheck/src/test/java/org/openjdk/skara/jcheck/TestRepository.java
+++ b/jcheck/src/test/java/org/openjdk/skara/jcheck/TestRepository.java
@@ -299,10 +299,15 @@
 
     public List<Submodule> submodules() throws IOException {
         return null;
     }
 
+    @Override
+    public Tree tree(Hash h) throws IOException {
+        return null;
+    }
+
     public Optional<Tag.Annotated> annotate(Tag tag) throws IOException {
         return null;
     }
 
     public String range(Hash h) {
diff a/vcs/src/main/java/org/openjdk/skara/vcs/ReadOnlyRepository.java b/vcs/src/main/java/org/openjdk/skara/vcs/ReadOnlyRepository.java
--- a/vcs/src/main/java/org/openjdk/skara/vcs/ReadOnlyRepository.java
+++ b/vcs/src/main/java/org/openjdk/skara/vcs/ReadOnlyRepository.java
@@ -103,10 +103,17 @@
     boolean isValidRevisionRange(String expression) throws IOException;
     Optional<String> upstreamFor(Branch branch) throws IOException;
     List<Reference> remoteBranches(String remote) throws IOException;
     List<String> remotes() throws IOException;
     List<Submodule> submodules() throws IOException;
+    Tree tree(Hash h) throws IOException;
+    default Tree tree(Commit c) throws IOException {
+        return tree(c.hash());
+    }
+    default Tree tree(CommitMetadata c) throws IOException {
+        return tree(c.hash());
+    }
 
     static Optional<ReadOnlyRepository> get(Path p) throws IOException {
         return Repository.get(p).map(r -> r);
     }
 
diff a/vcs/src/main/java/org/openjdk/skara/vcs/Repository.java b/vcs/src/main/java/org/openjdk/skara/vcs/Repository.java
--- a/vcs/src/main/java/org/openjdk/skara/vcs/Repository.java
+++ b/vcs/src/main/java/org/openjdk/skara/vcs/Repository.java
@@ -91,10 +91,19 @@
                 String authorEmail,
                 ZonedDateTime authorDate,
                 String committerName,
                 String committerEmail,
                 ZonedDateTime committerDate) throws IOException;
+    Hash commit(String message,
+                String authorName,
+                String authorEmail,
+                ZonedDateTime authorDate,
+                String committerName,
+                String committerEmail,
+                ZonedDateTime committerDate,
+                List<Hash> parents,
+                Tree tree) throws IOException;
     Hash amend(String message,
                String authorName,
                String authorEmail) throws IOException;
     Hash amend(String message,
                String authorName,
diff a/vcs/src/main/java/org/openjdk/skara/vcs/Tree.java b/vcs/src/main/java/org/openjdk/skara/vcs/Tree.java
--- /dev/null
+++ b/vcs/src/main/java/org/openjdk/skara/vcs/Tree.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.vcs;
+
+import java.util.Objects;
+
+public class Tree {
+    private final Hash hash;
+
+    public Tree(Hash hash) {
+        this.hash = hash;
+    }
+
+    public Hash hash() {
+        return hash;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Tree tree = (Tree) o;
+        return hash.equals(tree.hash);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(hash);
+    }
+
+    @Override
+    public String toString() {
+        return "Tree{" +
+                "hash=" + hash +
+                '}';
+    }
+}
diff a/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java b/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java
--- a/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java
+++ b/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java
@@ -666,10 +666,52 @@
             await(p);
             return head();
         }
     }
 
+    @Override
+    public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate, String committerName, String committerEmail, ZonedDateTime committerDate, List<Hash> parents, Tree tree) throws IOException {
+        // Ensure we don't create identical commits
+        if (parents.size() == 1) {
+            var parentTree = tree(parents.get(0));
+            if (parentTree.equals(tree)) {
+                return parents.get(0);
+            }
+        }
+
+        var cmdLine = new ArrayList<>(List.of("git", "commit-tree", tree.hash().hex(), "-m", message));
+        for (var parent : parents) {
+            cmdLine.add("-p");
+            cmdLine.add(parent.hex());
+        }
+        var cmd = Process.capture(cmdLine.toArray(new String[0]))
+                .workdir(dir)
+                .environ("GIT_AUTHOR_NAME", authorName)
+                .environ("GIT_AUTHOR_EMAIL", authorEmail)
+                .environ("GIT_COMMITTER_NAME", committerName)
+                .environ("GIT_COMMITTER_EMAIL", committerEmail);
+        if (authorDate != null) {
+            cmd = cmd.environ("GIT_AUTHOR_DATE",
+                    authorDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
+        }
+        if (committerDate != null) {
+            cmd = cmd.environ("GIT_COMMITTER_DATE",
+                    committerDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
+        }
+        try (var p = cmd.execute()) {
+            var res = await(p);
+            if (res.stdout().size() != 1) {
+                throw new IOException("Unexpected output: " + res.stdout());
+            }
+            var commitHash = res.stdout().get(0).trim();
+            if (commitHash.length() != 40) {
+                throw new IOException("Unexpected output: " + commitHash);
+            }
+            return new Hash(commitHash);
+        }
+    }
+
     @Override
     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
         return amend(message, authorName, authorEmail, null, null);
     }
 
@@ -1311,10 +1353,32 @@
         }
 
         return modules;
     }
 
+    @Override
+    public Tree tree(Hash h) throws IOException {
+        String treeHash;
+        try (var p = capture("git", "cat-file", "-p", h.hex())) {
+            var res = p.await();
+            if (res.stdout().size() > 0) {
+                var line = res.stdout().get(0);
+                if (line.startsWith("tree ")) {
+                    treeHash = line.substring(5).trim();
+                    if (treeHash.length() != 40) {
+                        throw new IOException("Unexpected output: " + treeHash);
+                    }
+                } else {
+                    throw new IOException("Unexpected output: " + line);
+                }
+            } else {
+                throw new IOException("Unexpected output: " + res.stderr());
+            }
+        }
+        return new Tree(new Hash(treeHash));
+    }
+
     @Override
     public Optional<Tag.Annotated> annotate(Tag tag) throws IOException {
         var ref = "refs/tags/" + tag.name();
         var format = "%(refname:short)%0a%(*objectname)%0a%(taggername) %(taggeremail)%0a%(taggerdate:iso-strict)%0a%(contents)";
         try (var p = capture("git", "for-each-ref", "--format", format, ref)) {
diff a/vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java b/vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java
--- a/vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java
+++ b/vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java
@@ -614,10 +614,15 @@
         }
 
         return commit(message, authorName, authorEmail, authorDate);
     }
 
+    @Override
+    public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate, String committerName, String committerEmail, ZonedDateTime committerDate, List<Hash> parents, Tree tree) throws IOException {
+        throw new RuntimeException("not implemented yet");
+    }
+
     @Override
     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
         var user = authorEmail == null ? authorName : authorName + " <" + authorEmail + ">";
         try (var p = capture("hg", "commit", "--amend", "--message=" + message, "--user=" + user)) {
             await(p);
@@ -1297,10 +1302,15 @@
 
         return modules;
     }
 
     @Override
+    public Tree tree(Hash h) throws IOException {
+        throw new RuntimeException("not implemented yet");
+    }
+
+    @Override
     public Optional<Tag.Annotated> annotate(Tag tag) throws IOException {
         var hgtags = root().resolve(".hgtags");
         if (!Files.exists(hgtags)) {
             return Optional.empty();
         }

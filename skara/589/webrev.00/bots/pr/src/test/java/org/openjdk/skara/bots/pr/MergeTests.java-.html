<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.bots.pr;
 24 
 25 import org.openjdk.skara.forge.Review;
 26 import org.openjdk.skara.issuetracker.Comment;
 27 import org.openjdk.skara.process.Process;
 28 import org.openjdk.skara.test.*;
 29 import org.openjdk.skara.vcs.*;
 30 
 31 import org.junit.jupiter.api.*;
 32 
 33 import java.io.IOException;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.*;
 36 import java.util.Set;
 37 import java.util.stream.Collectors;
 38 
 39 import static org.junit.jupiter.api.Assertions.*;
 40 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 41 
 42 class MergeTests {
 43     @Test
 44     void branchMerge(TestInfo testInfo) throws IOException {
 45         try (var credentials = new HostCredentials(testInfo);
 46              var tempFolder = new TemporaryDirectory()) {
 47 
 48             var author = credentials.getHostedRepository();
 49             var integrator = credentials.getHostedRepository();
 50             var censusBuilder = credentials.getCensusBuilder()
 51                                            .addCommitter(author.forge().currentUser().id())
 52                                            .addReviewer(integrator.forge().currentUser().id());
 53             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 54 
 55             // Populate the projects repository
 56             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 57             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 58             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 59             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 60             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 61 
 62             // Make more changes in another branch
 63             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 64                                                                 &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 65             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 66             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 67                                                                 &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 68             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 69 
 70             // Go back to the original master
 71             localRepo.checkout(masterHash, true);
 72 
 73             // Make a change with a corresponding PR
 74             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 75             localRepo.add(unrelated);
 76             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 77             localRepo.merge(otherHash2);
 78             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 79 
 80             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 81             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 82             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 83 
 84             // Approve it as another user
 85             var approvalPr = integrator.pullRequest(pr.id());
 86             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 87 
 88             // Let the bot check the status
 89             TestBotRunner.runPeriodicItems(mergeBot);
 90 
 91             // Push it
 92             pr.addComment(&quot;/integrate&quot;);
 93             TestBotRunner.runPeriodicItems(mergeBot);
 94 
 95             // The bot should reply with an ok message
 96             var pushed = pr.comments().stream()
 97                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 98                            .count();
 99             assertEquals(1, pushed);
100 
101             // The change should now be present on the master branch
102             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
103             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
104             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
105 
106             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
107             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
108             Set&lt;Hash&gt; commits;
109             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
110                 commits = tempCommits.stream()
111                         .map(Commit::hash)
112                         .collect(Collectors.toSet());
113             }
114             assertTrue(commits.contains(otherHash1));
115             assertTrue(commits.contains(otherHash2));
116             assertFalse(commits.contains(mergeHash));
117 
118             // Author and committer should updated in the merge commit
119             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
120             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
121             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
122             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
123             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
124         }
125     }
126 
127     @Test
128     void branchMergeShortName(TestInfo testInfo) throws IOException {
129         try (var credentials = new HostCredentials(testInfo);
130              var tempFolder = new TemporaryDirectory()) {
131 
132             var author = credentials.getHostedRepository();
133             var integrator = credentials.getHostedRepository();
134             var censusBuilder = credentials.getCensusBuilder()
135                                            .addCommitter(author.forge().currentUser().id())
136                                            .addReviewer(integrator.forge().currentUser().id());
137             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
138 
139             // Populate the projects repository
140             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
141             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
142             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
143             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
144             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
145 
146             // Make more changes in another branch
147             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
148                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
149             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
150             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
151                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
152             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
153 
154             // Go back to the original master
155             localRepo.checkout(masterHash, true);
156 
157             // Make a change with a corresponding PR
158             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
159             localRepo.add(unrelated);
160             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
161             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
162 
163             localRepo.merge(otherHash2);
164             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
165             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
166             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge other&quot;);
167 
168             // Approve it as another user
169             var approvalPr = integrator.pullRequest(pr.id());
170             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
171 
172             // Let the bot check the status
173             TestBotRunner.runPeriodicItems(mergeBot);
174 
175             // Push it
176             pr.addComment(&quot;/integrate&quot;);
177             TestBotRunner.runPeriodicItems(mergeBot);
178 
179             // The bot should reply with an ok message
180             var pushed = pr.comments().stream()
181                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
182                            .count();
183             assertEquals(1, pushed);
184 
185             // The change should now be present on the master branch
186             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
187             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
188             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
189 
190             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
191             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
192             Set&lt;Hash&gt; commits;
193             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
194                 commits = tempCommits.stream()
195                                      .map(Commit::hash)
196                                      .collect(Collectors.toSet());
197             }
198             assertTrue(commits.contains(otherHash1));
199             assertTrue(commits.contains(otherHash2));
200             assertFalse(commits.contains(mergeHash));
201 
202             // Author and committer should updated in the merge commit
203             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
204             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
205             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
206             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
207             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
208         }
209     }
210 
211     @Test
212     @Disabled
213     void branchMergeRebase(TestInfo testInfo) throws IOException {
214         try (var credentials = new HostCredentials(testInfo);
215              var tempFolder = new TemporaryDirectory()) {
216 
217             var author = credentials.getHostedRepository();
218             var integrator = credentials.getHostedRepository();
219             var censusBuilder = credentials.getCensusBuilder()
220                                            .addCommitter(author.forge().currentUser().id())
221                                            .addReviewer(integrator.forge().currentUser().id());
222             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
223 
224             // Populate the projects repository
225             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
226             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
227             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
228             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
229             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
230 
231             // Make more changes in another branch
232             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
233                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
234             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
235             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
236                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
237             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
238 
239             // Go back to the original master
240             localRepo.checkout(masterHash, true);
241 
242             // Make a change with a corresponding PR
243             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
244             localRepo.add(unrelated);
245             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
246             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
247 
248             localRepo.merge(otherHash2);
249             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
250             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
251             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
252 
253             // Approve it as another user
254             var approvalPr = integrator.pullRequest(pr.id());
255             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
256 
257             // Let the bot check the status
258             TestBotRunner.runPeriodicItems(mergeBot);
259 
260             // Push something new to master
261             localRepo.checkout(updatedMaster, true);
262             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
263             localRepo.add(newMaster);
264             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
265             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
266 
267             // Let the bot notice
268             TestBotRunner.runPeriodicItems(mergeBot);
269 
270             // Push it
271             pr.addComment(&quot;/integrate&quot;);
272             TestBotRunner.runPeriodicItems(mergeBot);
273 
274             // The bot should reply with an ok message
275             var pushed = pr.comments().stream()
276                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
277                            .count();
278             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
279 
280             // The change should now be present on the master branch
281             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
282             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
283             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
284 
285             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
286             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
287             Set&lt;Hash&gt; commits;
288             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
289                 commits = tempCommits.stream()
290                         .map(Commit::hash)
291                         .collect(Collectors.toSet());
292             }
293             assertTrue(commits.contains(otherHash1));
294             assertTrue(commits.contains(otherHash2));
295             assertFalse(commits.contains(mergeHash));
296 
297             // Author and committer should updated in the merge commit
298             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
299             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
300             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
301             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
302             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
303         }
304     }
305 
306     @Test
307     @Disabled
308     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
309         try (var credentials = new HostCredentials(testInfo);
310              var tempFolder = new TemporaryDirectory()) {
311 
312             var author = credentials.getHostedRepository();
313             var integrator = credentials.getHostedRepository();
314             var censusBuilder = credentials.getCensusBuilder()
315                                            .addCommitter(author.forge().currentUser().id())
316                                            .addReviewer(integrator.forge().currentUser().id());
317             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
318 
319             // Populate the projects repository
320             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
321             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
322             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
323             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
324             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
325 
326             // Make more changes in another branch
327             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
328                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
329             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
330             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
331                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
332             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
333 
334             // Go back to the original master
335             localRepo.checkout(masterHash, true);
336 
337             // Make a change with a corresponding PR
338             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
339             localRepo.add(unrelated);
340             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
341             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
342 
343             localRepo.merge(otherHash2);
344             var mergeHash = localRepo.commit(&quot;Our own merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
345             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
346             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
347 
348             // Approve it as another user
349             var approvalPr = integrator.pullRequest(pr.id());
350             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
351 
352             // Let the bot check the status
353             TestBotRunner.runPeriodicItems(mergeBot);
354 
355             // Push something new to master
356             localRepo.checkout(updatedMaster, true);
357             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
358             localRepo.add(newMaster);
359             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
360             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
361 
362             // Let the bot notice
363             TestBotRunner.runPeriodicItems(mergeBot);
364 
365             // Add another commit on top of the merge commit
366             localRepo.checkout(mergeHash, true);
367             var extraHash = CheckableRepository.appendAndCommit(localRepo, &quot;Fixing up stuff after merge&quot;);
368             localRepo.push(extraHash, author.url(), &quot;edit&quot;);
369 
370             // Let the bot notice again
371             TestBotRunner.runPeriodicItems(mergeBot);
372 
373             // Merge the latest from master
374             localRepo.merge(newMasterHash);
375             var latestMergeHash = localRepo.commit(&quot;Our to be squashed merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
376             localRepo.push(latestMergeHash, author.url(), &quot;edit&quot;);
377 
378             // Let the bot notice again
379             TestBotRunner.runPeriodicItems(mergeBot);
380 
381             // Push it
382             pr.addComment(&quot;/integrate&quot;);
383             TestBotRunner.runPeriodicItems(mergeBot);
384 
385             // The bot should reply with an ok message
386             var pushed = pr.comments().stream()
387                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
388                            .count();
389             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
390 
391             // The change should now be present on the master branch
392             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
393             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
394             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
395 
396             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
397             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
398             String commits;
399             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
400                 commits = tempCommits.stream()
401                                      .map(c -&gt; c.hash().hex() + &quot;:&quot; + c.message().get(0))
402                                      .collect(Collectors.joining(&quot;,&quot;));
403             }
404             assertTrue(commits.contains(otherHash1.hex() + &quot;:First other&quot;));
405             assertTrue(commits.contains(otherHash2.hex() + &quot;:Second other&quot;));
406             assertFalse(commits.contains(&quot;Our own merge commit&quot;));
407 
408             // Author and committer should updated in the merge commit
409             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
410             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
411             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
412             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
413             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
414         }
415     }
416 
417     @Test
418     void invalidMergeCommit(TestInfo testInfo) throws IOException {
419         try (var credentials = new HostCredentials(testInfo);
420              var tempFolder = new TemporaryDirectory()) {
421 
422             var author = credentials.getHostedRepository();
423             var integrator = credentials.getHostedRepository();
424             var censusBuilder = credentials.getCensusBuilder()
425                                            .addCommitter(author.forge().currentUser().id())
426                                            .addReviewer(integrator.forge().currentUser().id());
427             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
428 
429             // Populate the projects repository
430             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
431             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
432             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
433             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
434             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
435 
436             // Make a change in another branch
437             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
438                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
439             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
440 
441             // Go back to the original master
442             localRepo.checkout(masterHash, true);
443 
444             // Make a change with a corresponding PR
445             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
446             localRepo.add(unrelated);
447             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
448             localRepo.merge(otherHash);
449             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
450             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
451             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
452 
453             // Approve it as another user
454             var approvalPr = integrator.pullRequest(pr.id());
455             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
456 
457             // Let the bot check the status
458             TestBotRunner.runPeriodicItems(mergeBot);
459 
460             // Push it
461             pr.addComment(&quot;/integrate&quot;);
462             TestBotRunner.runPeriodicItems(mergeBot);
463 
464             // The bot should reply with a failure message
465             var error = pr.comments().stream()
466                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
467                           .count();
468             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
469 
470             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
471             assertEquals(&quot;- It was not possible to create a commit for the changes in this PR: A merge PR is only allowed to contain a single merge commit. You will need to amend your commits.&quot;, check.summary().orElseThrow());
472         }
473     }
474 
475     @Test
476     void invalidSourceRepo(TestInfo testInfo) throws IOException {
477         try (var credentials = new HostCredentials(testInfo);
478              var tempFolder = new TemporaryDirectory()) {
479 
480             var author = credentials.getHostedRepository();
481             var integrator = credentials.getHostedRepository();
482             var censusBuilder = credentials.getCensusBuilder()
483                                            .addCommitter(author.forge().currentUser().id())
484                                            .addReviewer(integrator.forge().currentUser().id());
485             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
486 
487             // Populate the projects repository
488             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
489             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
490             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
491             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
492             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
493 
494             // Make a change in another branch
495             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
496                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
497             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
498 
499             // Go back to the original master
500             localRepo.checkout(masterHash, true);
501 
502             // Make a change with a corresponding PR
503             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
504             localRepo.add(unrelated);
505             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
506             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
507 
508             localRepo.merge(otherHash);
509             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
510             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
511             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;xyz&quot; + &quot;:other&quot;);
512 
513             // Approve it as another user
514             var approvalPr = integrator.pullRequest(pr.id());
515             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
516 
517             // Let the bot check the status
518             TestBotRunner.runPeriodicItems(mergeBot);
519 
520             // Push it
521             pr.addComment(&quot;/integrate&quot;);
522             TestBotRunner.runPeriodicItems(mergeBot);
523 
524             // The bot should reply with a failure message
525             var error = pr.comments().stream()
526                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
527                           .count();
528             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
529 
530             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
531             assertEquals(&quot;- Could not find project `&quot; + author.name() + &quot;xyz` - check that it is correct.&quot;, check.summary().orElseThrow());
532         }
533     }
534 
535     @Test
536     void invalidSourceBranch(TestInfo testInfo) throws IOException {
537         try (var credentials = new HostCredentials(testInfo);
538              var tempFolder = new TemporaryDirectory()) {
539 
540             var author = credentials.getHostedRepository();
541             var integrator = credentials.getHostedRepository();
542             var censusBuilder = credentials.getCensusBuilder()
543                                            .addCommitter(author.forge().currentUser().id())
544                                            .addReviewer(integrator.forge().currentUser().id());
545             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
546 
547             // Populate the projects repository
548             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
549             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
550             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
551             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
552             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
553 
554             // Make a change in another branch
555             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
556                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
557             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
558 
559             // Go back to the original master
560             localRepo.checkout(masterHash, true);
561 
562             // Make a change with a corresponding PR
563             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
564             localRepo.add(unrelated);
565             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
566             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
567 
568             localRepo.merge(otherHash);
569             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
570             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
571             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:otherxyz&quot;);
572 
573             // Approve it as another user
574             var approvalPr = integrator.pullRequest(pr.id());
575             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
576 
577             // Let the bot check the status
578             TestBotRunner.runPeriodicItems(mergeBot);
579 
580             // Push it
581             pr.addComment(&quot;/integrate&quot;);
582             TestBotRunner.runPeriodicItems(mergeBot);
583 
584             // The bot should reply with a failure message
585             var error = pr.comments().stream()
586                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
587                           .count();
588             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
589 
590             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
591             assertEquals(&quot;- Could not fetch branch `otherxyz` from project `&quot; + author.name() + &quot;` - check that they are correct.&quot;, check.summary().orElseThrow());
592         }
593     }
594 
595     @Test
596     void inferredSourceProject(TestInfo testInfo) throws IOException {
597         try (var credentials = new HostCredentials(testInfo);
598              var tempFolder = new TemporaryDirectory()) {
599 
600             var author = credentials.getHostedRepository();
601             var integrator = credentials.getHostedRepository();
602             var censusBuilder = credentials.getCensusBuilder()
603                                            .addCommitter(author.forge().currentUser().id())
604                                            .addReviewer(integrator.forge().currentUser().id());
605             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
606 
607             // Populate the projects repository
608             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
609             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
610             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
611             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
612             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
613 
614             // Make a change in another branch
615             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
616                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
617             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
618 
619             // Go back to the original master
620             localRepo.checkout(masterHash, true);
621 
622             // Make a change with a corresponding PR
623             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
624             localRepo.add(unrelated);
625             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
626             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
627 
628             localRepo.merge(otherHash);
629             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
630             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
631             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge otherxyz&quot;);
632 
633             // Approve it as another user
634             var approvalPr = integrator.pullRequest(pr.id());
635             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
636 
637             // Let the bot check the status
638             TestBotRunner.runPeriodicItems(mergeBot);
639 
640             // Push it
641             pr.addComment(&quot;/integrate&quot;);
642             TestBotRunner.runPeriodicItems(mergeBot);
643 
644             // The bot should reply with a failure message
645             var error = pr.comments().stream()
646                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
647                           .count();
648             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
649 
650             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
651             assertEquals(&quot;- Could not find project `otherxyz` - check that it is correct.&quot;, check.summary().orElseThrow());
652         }
653     }
654 
655     @Test
656     void wrongSourceBranch(TestInfo testInfo) throws IOException {
657         try (var credentials = new HostCredentials(testInfo);
658              var tempFolder = new TemporaryDirectory()) {
659 
660             var author = credentials.getHostedRepository();
661             var integrator = credentials.getHostedRepository();
662             var censusBuilder = credentials.getCensusBuilder()
663                                            .addCommitter(author.forge().currentUser().id())
664                                            .addReviewer(integrator.forge().currentUser().id());
665             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
666 
667             // Populate the projects repository
668             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
669             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
670             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
671             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
672             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
673 
674             // Make a change in another branch
675             var other1Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other1&quot;,
676                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
677             localRepo.push(other1Hash, author.url(), &quot;other1&quot;, true);
678 
679             // Go back to the original master
680             localRepo.checkout(masterHash, true);
681 
682             // Make yet another change in another branch
683             var other2Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other2&quot;,
684                                                                 &quot;Unrelated\n\nReviewed-by: integrationreviewer2&quot;);
685             localRepo.push(other2Hash, author.url(), &quot;other2&quot;, true);
686 
687             // Make a change with a corresponding PR
688             localRepo.checkout(masterHash, true);
689             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
690             localRepo.add(unrelated);
691             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
692             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
693 
694             localRepo.merge(other1Hash, &quot;ours&quot;);
695             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
696             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
697             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other2&quot;);
698 
699             // Approve it as another user
700             var approvalPr = integrator.pullRequest(pr.id());
701             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
702 
703             // Let the bot check the status
704             TestBotRunner.runPeriodicItems(mergeBot);
705 
706             // Push it
707             pr.addComment(&quot;/integrate&quot;);
708             TestBotRunner.runPeriodicItems(mergeBot);
709 
710             // The bot should reply with a failure message
711             var error = pr.comments().stream()
712                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
713                           .count();
714             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
715 
716             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
717             assertEquals(&quot;- The merge contains commits that are neither ancestors of the source nor the target.&quot;, check.summary().orElseThrow());
718         }
719     }
720 
721     @Test
722     void invalidAuthor(TestInfo testInfo) throws IOException {
723         try (var credentials = new HostCredentials(testInfo);
724              var tempFolder = new TemporaryDirectory()) {
725 
726             var author = credentials.getHostedRepository();
727             var integrator = credentials.getHostedRepository();
728             var censusBuilder = credentials.getCensusBuilder()
729                                            .addAuthor(author.forge().currentUser().id())
730                                            .addReviewer(integrator.forge().currentUser().id());
731             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
732 
733             // Populate the projects repository
734             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
735             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
736             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
737             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
738             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
739 
740             // Make a change in another branch
741             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
742                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
743             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
744 
745             // Go back to the original master
746             localRepo.checkout(masterHash, true);
747 
748             // Make a change with a corresponding PR
749             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
750             localRepo.add(unrelated);
751             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
752             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
753 
754             localRepo.merge(otherHash);
755             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
756             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
757             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
758 
759             // Approve it as another user
760             var approvalPr = integrator.pullRequest(pr.id());
761             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
762 
763             // Let the bot check the status
764             TestBotRunner.runPeriodicItems(mergeBot);
765 
766             // Push it
767             pr.addComment(&quot;/integrate&quot;);
768             TestBotRunner.runPeriodicItems(mergeBot);
769 
770             // The bot should reply with a need for sponsor
771             var error = pr.comments().stream()
772                           .filter(comment -&gt; comment.body().contains(&quot;Afterwards, your sponsor types `/sponsor`&quot;))
773                           .count();
774             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
775         }
776     }
777 
778     @Test
779     void unrelatedHistory(TestInfo testInfo) throws IOException {
780         try (var credentials = new HostCredentials(testInfo);
781              var tempFolder = new TemporaryDirectory()) {
782 
783             var author = credentials.getHostedRepository();
784             // Need to force merge unrelated histories
785             assumeTrue(author.repositoryType().equals(VCS.GIT));
786 
787             var integrator = credentials.getHostedRepository();
788             var censusBuilder = credentials.getCensusBuilder()
789                                            .addCommitter(author.forge().currentUser().id())
790                                            .addReviewer(integrator.forge().currentUser().id());
791             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
792 
793             // Populate the projects repository
794             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
795             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
796             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
797 
798             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
799             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
800 
801             // Make an unrelated change in another branch
802             var unrelatedRepoFolder = tempFolder.path().resolve(&quot;unrelated&quot;);
803             var unrelatedRepo = CheckableRepository.init(unrelatedRepoFolder, author.repositoryType(), Path.of(&quot;anotherfile.txt&quot;));
804             unrelatedRepo.amend(&quot;Unrelated initial commit\n\nReviewed-by: integrationreviewer2&quot;, &quot;some&quot;, &quot;one@mail&quot;);
805             var otherHash = CheckableRepository.appendAndCommit(unrelatedRepo, &quot;Change in other&quot;,
806                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
807             unrelatedRepo.push(otherHash, author.url(), &quot;other&quot;, true);
808             localRepo.fetch(author.url(), &quot;other&quot;);
809 
810             // Go back to the original master
811             localRepo.checkout(masterHash, true);
812 
813             // Make a change with a corresponding PR
814             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
815             localRepo.add(unrelated);
816             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
817             var mergeCmd = Process.command(&quot;git&quot;, &quot;merge&quot;, &quot;--no-commit&quot;, &quot;--allow-unrelated-histories&quot;, &quot;-s&quot;, &quot;ours&quot;, otherHash.hex())
818                                   .workdir(localRepo.root())
819                                   .environ(&quot;GIT_AUTHOR_NAME&quot;, &quot;some&quot;)
820                                   .environ(&quot;GIT_AUTHOR_EMAIL&quot;, &quot;some@one&quot;)
821                                   .environ(&quot;GIT_COMMITTER_NAME&quot;, &quot;another&quot;)
822                                   .environ(&quot;GIT_COMMITTER_EMAIL&quot;, &quot;another@one&quot;)
823                                   .execute();
824             mergeCmd.check();
825 
826             //localRepo.merge(otherHash);
827             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
828             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
829             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
830 
831             // Approve it as another user
832             var approvalPr = integrator.pullRequest(pr.id());
833             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
834 
835             // Let the bot check the status
836             TestBotRunner.runPeriodicItems(mergeBot);
837 
838             // Push it
839             pr.addComment(&quot;/integrate&quot;);
840             TestBotRunner.runPeriodicItems(mergeBot);
841 
842             // The bot should reply with a failure message
843             var error = pr.comments().stream()
844                     .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
845                     .count();
846             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
847 
848             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
849             assertEquals(&quot;- The merge contains commits that are neither ancestors of the source nor the target.&quot;, check.summary().orElseThrow());
850         }
851     }
852 
853     @Test
854     void invalidSyntax(TestInfo testInfo) throws IOException {
855         try (var credentials = new HostCredentials(testInfo);
856              var tempFolder = new TemporaryDirectory()) {
857 
858             var author = credentials.getHostedRepository();
859             var integrator = credentials.getHostedRepository();
860             var censusBuilder = credentials.getCensusBuilder()
861                                            .addCommitter(author.forge().currentUser().id())
862                                            .addReviewer(integrator.forge().currentUser().id());
863             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
864 
865             // Populate the projects repository
866             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
867             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(&quot;appendable.txt&quot;), Set.of(&quot;merge&quot;), &quot;1.0&quot;);
868             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
869             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
870             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
871 
872             // Make a change in another branch
873             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
874                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
875             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
876 
877             // Go back to the original master
878             localRepo.checkout(masterHash, true);
879 
880             // Make a change with a corresponding PR
881             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
882             localRepo.add(unrelated);
883             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
884             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
885 
886             localRepo.merge(otherHash);
887             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
888             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
889             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge this or that&quot;);
890 
891             // Let the bot check the status
892             TestBotRunner.runPeriodicItems(mergeBot);
893 
894             // Push it
895             pr.addComment(&quot;/integrate&quot;);
896             TestBotRunner.runPeriodicItems(mergeBot);
897 
898             // The bot should reply with a failure message
899             var error = pr.comments().stream()
900                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
901                           .count();
902             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
903 
904             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
905             assertEquals(&quot;- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.\n&quot; +
906                                  &quot;- Merge commit message is not Merge, but: Merge this or that&quot;, check.summary().orElseThrow());
907         }
908     }
909 }
    </pre>
  </body>
</html>
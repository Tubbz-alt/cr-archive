diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -49,10 +49,11 @@
 
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
     private final String progressMarker = "<!-- Anything below this marker will be automatically updated, please do not edit manually! -->";
     private final String mergeReadyMarker = "<!-- PullRequestBot merge is ready comment -->";
     private final String outdatedHelpMarker = "<!-- PullRequestBot outdated help comment -->";
+    private final String sourceBranchWarningMarker = "<!-- PullRequestBot source branch warning comment -->";
     private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
     private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
     private final Set<String> newLabels;
 
     private CheckRun(CheckWorkItem workItem, PullRequest pr, PullRequestInstance prInstance, List<Comment> comments,
@@ -81,17 +82,18 @@
         var matcher = workItem.bot.allowedTargetBranches().matcher(pr.targetRef());
         return matcher.matches();
     }
 
     private List<String> allowedTargetBranches() {
-        var remoteBranches = prInstance.remoteBranches().stream()
-                                       .map(Reference::name)
-                                       .map(name -> workItem.bot.allowedTargetBranches().matcher(name))
-                                       .filter(Matcher::matches)
-                                       .map(Matcher::group)
-                                       .collect(Collectors.toList());
-        return remoteBranches;
+        return pr.repository()
+                 .branches()
+                 .stream()
+                 .map(HostedBranch::name)
+                 .map(name -> workItem.bot.allowedTargetBranches().matcher(name))
+                 .filter(Matcher::matches)
+                 .map(Matcher::group)
+                 .collect(Collectors.toList());
     }
 
     // For unknown contributors, check that all commits have the same name and email
     private boolean checkCommitAuthor(List<Commit> commits) throws IOException {
         var author = censusInstance.namespace().get(pr.author().id());
@@ -558,10 +560,41 @@
         } else {
             existing.ifPresent(comment -> pr.updateComment(comment.id(), getMergeNoLongerReadyComment()));
         }
     }
 
+    private void addSourceBranchWarningComment(List<Comment> comments) {
+        var existing = findComment(comments, sourceBranchWarningMarker);
+        if (existing.isPresent()) {
+            // Only add the comment once per PR
+            return;
+        }
+        var branch = pr.sourceRef();
+        var message = ":warning: @" + pr.author().userName() + " " +
+            "a branch with the same name as the source branch for this pull request (`" + branch + "`) " +
+            "is present in the [target repository](" + pr.repository().nonTransformedWebUrl() + "). " +
+            "If you eventually integrate this pull request then the branch `" + branch + "` " +
+            "in your [personal fork](" + pr.sourceRepository().nonTransformedWebUrl() + ") will diverge once you sync " +
+            "your personal fork with the upstream repository.\n" +
+            "\n" +
+            "To avoid this situation, create a new branch for your changes and reset the `" + branch + "` branch. " +
+            "You can do this by running the following commands in a local repository for your personal fork. " +
+            "_Note_: you do *not* have to name the new branch `NEW-BRANCH-NAME`." +
+            "\n" +
+            "```" +
+            "$ git checkout " + branch + "\n" +
+            "$ git checkout -b NEW-BRANCH-NAME\n" +
+            "$ git branch -f " + branch + " " + prInstance.baseHash().hex() + "\n" +
+            "$ git push -f origin " + branch + "\n" +
+            "```\n" +
+            "\n" +
+            "Then proceed to create a new pull request with `NEW-BRANCH-NAME` as the source branch and " +
+            "close this one.\n" +
+            sourceBranchWarningMarker;
+        pr.addComment(message);
+    }
+
     private void addOutdatedComment(List<Comment> comments) {
         var existing = findComment(comments, outdatedHelpMarker);
         if (existing.isPresent()) {
             // Only add the comment once per PR
             return;
@@ -645,10 +678,15 @@
                 newLabels.add("merge-conflict");
             } else {
                 newLabels.remove("merge-conflict");
             }
 
+            var branchNames = pr.repository().branches().stream().map(HostedBranch::name).collect(Collectors.toSet());
+            if (!pr.repository().url().equals(pr.sourceRepository().url()) && branchNames.contains(pr.sourceRef())) {
+                addSourceBranchWarningComment(comments);
+            }
+
             // Ensure that the ready for sponsor label is up to date
             newLabels.remove("sponsor");
             var readyHash = ReadyForSponsorTracker.latestReadyForSponsor(pr.repository().forge().currentUser(), comments);
             if (readyHash.isPresent() && readyForIntegration) {
                 var acceptedHash = readyHash.get();

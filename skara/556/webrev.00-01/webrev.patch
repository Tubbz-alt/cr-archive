diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java
@@ -43,11 +43,12 @@
             "help", new HelpCommand(),
             "integrate", new IntegrateCommand(),
             "sponsor", new SponsorCommand(),
             "contributor", new ContributorCommand(),
             "summary", new SummaryCommand(),
-            "solves", new SolvesCommand(),
+            "issue", new IssueCommand(),
+            "solves", new IssueCommand("solves"),
             "reviewers", new ReviewersCommand(),
             "csr", new CSRCommand()
     );
 
     static class HelpCommand implements CommandHandler {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
--- /dev/null
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.pr;
+
+import org.openjdk.skara.forge.PullRequest;
+import org.openjdk.skara.issuetracker.Comment;
+import org.openjdk.skara.vcs.openjdk.Issue;
+
+import java.io.PrintWriter;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+class InvalidIssue extends Exception {
+    private String identifier;
+    private String reason;
+
+    InvalidIssue(String identifier, String reason) {
+        this.identifier = identifier;
+        this.reason = reason;
+    }
+
+    String identifier() {
+        return identifier;
+    }
+
+    String reason() {
+        return reason;
+    }
+}
+
+public class IssueCommand implements CommandHandler {
+    private final String name;
+
+    private void showHelp(PrintWriter reply) {
+        reply.println("Command syntax: `/" + name + " [add|remove] <id>[,<id>,...]` or `/issue [add] <id>: <description>`. For example:");
+        reply.println();
+        reply.println(" * `/" + name + " add JDK-1234567,4567890`");
+        reply.println(" * `/" + name + " remove JDK-4567890`");
+        reply.println(" * `/" + name + " 1234567: Use this exact title`");
+        reply.println();
+        reply.print("If issues are specified only by their ID, the title will be automatically retrieved from JBS. ");
+        reply.print("The project prefix (`JDK-` in the above examples) is optional. ");
+        reply.println("Separate multiple issue IDs using either spaces or commas.");
+    }
+
+    private static final Pattern shortIssuePattern = Pattern.compile("((?:[A-Za-z]+-)?[0-9]+)(?:,| |$)");
+
+    private List<Issue> parseIssueList(String allowedPrefix, String issueList) throws InvalidIssue {
+        List<Issue> ret;
+        // Is this a single fully described issue?
+        var singleIssue = Issue.fromString(issueList);
+        if (singleIssue.isPresent()) {
+            ret = List.of(singleIssue.get());
+        } else {
+            var shortIssueMatcher = shortIssuePattern.matcher(issueList);
+            ret = shortIssueMatcher.results()
+                                   .map(matchResult -> matchResult.group(1))
+                                   .map(identifier -> new Issue(identifier, null))
+                                   .collect(Collectors.toList());
+        }
+        for (var issue : ret) {
+            if (issue.id().contains("-") && !issue.id().startsWith(allowedPrefix)) {
+                throw new InvalidIssue(issue.id(), "This PR can only solve issues in the " + allowedPrefix + " project");
+            }
+        }
+
+        // Drop the validated project prefixes
+        return ret.stream()
+                  .map(issue -> issue.id().contains("-") ? new Issue(issue.id().split("-", 2)[1], issue.description()) : issue)
+                  .collect(Collectors.toList());
+    }
+
+    private final static Pattern subCommandPattern = Pattern.compile("^(add|remove|delete|(?:[A-Za-z]+-)?[0-9]+:?)[ ,]+.*$");
+
+    IssueCommand(String name) {
+        this.name = name;
+    }
+
+    IssueCommand() {
+        this("issue");
+    }
+
+    @Override
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
+        if (!comment.author().equals(pr.author())) {
+            reply.println("Only the author (@" + pr.author().userName() + ") is allowed to issue the `solves` command.");
+            return;
+        }
+        if (args.isBlank()) {
+            showHelp(reply);
+            return;
+        }
+        var subCommandMatcher = subCommandPattern.matcher(args);
+        if (!subCommandMatcher.matches()) {
+            showHelp(reply);
+            return;
+        }
+
+        var currentSolved = SolvesTracker.currentSolved(pr.repository().forge().currentUser(), allComments)
+                                         .stream()
+                                         .map(Issue::id)
+                                         .collect(Collectors.toSet());
+        try {
+            if (args.startsWith("remove") || args.startsWith("delete")) {
+                var issueListStart = args.indexOf(' ');
+                if (issueListStart == -1) {
+                    showHelp(reply);
+                    return;
+                }
+                if (currentSolved.isEmpty()) {
+                    reply.println("This PR does not contain any additional solved issues that can be removed. To remove the primary solved issue, simply edit the title of this PR.");
+                    return;
+                }
+                var issuesToRemove = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args.substring(issueListStart));
+                for (var issue : issuesToRemove) {
+                    if (currentSolved.contains(issue.id())) {
+                        reply.println(SolvesTracker.removeSolvesMarker(issue));
+                        reply.println("Removing additional issue from solves list: `" + issue.id() + "`.");
+                    } else {
+                        reply.print("The issue `" + issue.id() + "` was not found in the list of additional solved issues. The list currently contains these issues: ");
+                        var currentList = currentSolved.stream()
+                                                       .map(id -> "`" + id + "`")
+                                                       .collect(Collectors.joining(", "));
+                        reply.println(currentList);
+                    }
+                }
+            } else {
+                if (args.startsWith("add")) {
+                    var issueListStart = args.indexOf(' ');
+                    if (issueListStart == -1) {
+                        showHelp(reply);
+                        return;
+                    }
+                    args = args.substring(issueListStart);
+                }
+                var issues = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args);
+                if (issues.size() == 0) {
+                    showHelp(reply);
+                    return;
+                }
+                var validatedIssues = new ArrayList<Issue>();
+                for (var issue : issues) {
+                    try {
+                        if (bot.issueProject() == null) {
+                            if (issue.description() == null) {
+                                reply.print("This repository does not have an issue project configured - you will need to input the issue title manually ");
+                                reply.println("using the syntax `/solves " + issue.id() + ": title of the issue`.");
+                                return;
+                            } else {
+                                validatedIssues.add(issue);
+                                continue;
+                            }
+                        }
+                        var validatedIssue = bot.issueProject().issue(issue.id());
+                        if (validatedIssue.isEmpty()) {
+                            reply.println("The issue `" + issue.id() + "` was not found in the `" + bot.issueProject().name() + "` project - make sure you have entered it correctly.");
+                            continue;
+                        }
+                        if (validatedIssue.get().state() != org.openjdk.skara.issuetracker.Issue.State.OPEN) {
+                            reply.println("The issue [" + validatedIssue.get().id() + "](" + validatedIssue.get().webUrl() + ") isn't open - make sure you have selected the correct issue.");
+                            continue;
+                        }
+                        if (issue.description() == null) {
+                            validatedIssues.add(new Issue(validatedIssue.get().id(), validatedIssue.get().title()));
+                        } else {
+                            validatedIssues.add(new Issue(validatedIssue.get().id(), issue.description()));
+                        }
+
+                    } catch (RuntimeException e) {
+                        if (issue.description() == null) {
+                            reply.print("Temporary failure when trying to look up issue `" + issue.id() + "` - you will need to input the issue title manually ");
+                            reply.println("using the syntax `/solves " + issue.id() + ": title of the issue`.");
+                            return;
+                        } else {
+                            validatedIssues.add(issue);
+                        }
+                    }
+                }
+                if (validatedIssues.size() != issues.size()) {
+                    reply.println("As there were validation problems, no additional issues will be added to the list of solved issues.");
+                    return;
+                }
+
+                // Drop the validated project prefixes
+                var strippedValidatedIssues = validatedIssues.stream()
+                                                             .map(issue -> issue.id().contains("-") ? new Issue(issue.id().split("-", 2)[1], issue.description()) : issue)
+                                                             .collect(Collectors.toList());
+                var titleIssue = Issue.fromString(pr.title());
+                for (var issue : strippedValidatedIssues) {
+                    if (titleIssue.isEmpty()) {
+                        reply.print("The primary solved issue for a PR is set through the PR title. Since the current title does ");
+                        reply.println("not contain an issue reference, it will now be updated.");
+                        pr.setTitle(issue.toString());
+                        titleIssue = Optional.of(issue);
+                        continue;
+                    }
+                    if (titleIssue.get().id().equals(issue.id())) {
+                        reply.println("This issue is referenced in the PR title - it will now be updated.");
+                        pr.setTitle(issue.toString());
+                        continue;
+                    }
+                    reply.println(SolvesTracker.setSolvesMarker(issue));
+                    if (currentSolved.contains(issue.id())) {
+                        reply.println("Updating description of additional solved issue: `" + issue.toString() + "`.");
+                    } else {
+                        reply.println("Adding additional issue to solves list: `" + issue.toString() + "`.");
+                    }
+                }
+            }
+
+        } catch (InvalidIssue invalidIssue) {
+            reply.println("The issue identifier `" + invalidIssue.identifier() + "` is invalid: " + invalidIssue.reason() + ".");
+        }
+    }
+
+    @Override
+    public String description() {
+        return "edit the list of issues that this PR solves";
+    }
+}
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SolvesCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SolvesCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SolvesCommand.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.pr;
-
-import org.openjdk.skara.forge.PullRequest;
-import org.openjdk.skara.issuetracker.Comment;
-import org.openjdk.skara.vcs.openjdk.Issue;
-
-import java.io.PrintWriter;
-import java.nio.file.Path;
-import java.util.*;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-
-class InvalidIssue extends Exception {
-    private String identifier;
-    private String reason;
-
-    InvalidIssue(String identifier, String reason) {
-        this.identifier = identifier;
-        this.reason = reason;
-    }
-
-    String identifier() {
-        return identifier;
-    }
-
-    String reason() {
-        return reason;
-    }
-}
-
-public class SolvesCommand implements CommandHandler {
-    private void showHelp(PrintWriter reply) {
-        reply.println("Command syntax: `/solves [remove] <id>[,<id>,...]` or `/solves <id>: <description>`. For example:");
-        reply.println();
-        reply.println(" * `/solves JDK-1234567,4567890`");
-        reply.println(" * `/solves remove JDK-4567890`");
-        reply.println(" * `/solves 1234567: Use this exact title`");
-        reply.println();
-        reply.print("If issues are specified only by their ID, the title will be automatically retrieved from JBS. ");
-        reply.print("The project prefix (`JDK-` in the above examples) is optional. ");
-        reply.println("Separate multiple issue IDs using either spaces or commas.");
-    }
-
-    private static final Pattern shortIssuePattern = Pattern.compile("((?:[A-Za-z]+-)?[0-9]+)(?:,| |$)");
-
-    private List<Issue> parseIssueList(String allowedPrefix, String issueList) throws InvalidIssue {
-        List<Issue> ret;
-        // Is this a single fully described issue?
-        var singleIssue = Issue.fromString(issueList);
-        if (singleIssue.isPresent()) {
-            ret = List.of(singleIssue.get());
-        } else {
-            var shortIssueMatcher = shortIssuePattern.matcher(issueList);
-            ret = shortIssueMatcher.results()
-                                   .map(matchResult -> matchResult.group(1))
-                                   .map(identifier -> new Issue(identifier, null))
-                                   .collect(Collectors.toList());
-        }
-        for (var issue : ret) {
-            if (issue.id().contains("-") && !issue.id().startsWith(allowedPrefix)) {
-                throw new InvalidIssue(issue.id(), "This PR can only solve issues in the " + allowedPrefix + " project");
-            }
-        }
-
-        // Drop the validated project prefixes
-        return ret.stream()
-                  .map(issue -> issue.id().contains("-") ? new Issue(issue.id().split("-", 2)[1], issue.description()) : issue)
-                  .collect(Collectors.toList());
-    }
-
-    @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author())) {
-            reply.println("Only the author (@" + pr.author().userName() + ") is allowed to issue the `solves` command.");
-            return;
-        }
-        if (args.isBlank()) {
-            showHelp(reply);
-            return;
-        }
-
-        var currentSolved = SolvesTracker.currentSolved(pr.repository().forge().currentUser(), allComments)
-                                         .stream()
-                                         .map(Issue::id)
-                                         .collect(Collectors.toSet());
-        try {
-            if (args.startsWith("remove") || args.startsWith("delete")) {
-                var issueListStart = args.indexOf(' ');
-                if (issueListStart == -1) {
-                    showHelp(reply);
-                    return;
-                }
-                if (currentSolved.isEmpty()) {
-                    reply.println("This PR does not contain any additional solved issues that can be removed. To remove the primary solved issue, simply edit the title of this PR.");
-                    return;
-                }
-                var issuesToRemove = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args.substring(issueListStart));
-                for (var issue : issuesToRemove) {
-                    if (currentSolved.contains(issue.id())) {
-                        reply.println(SolvesTracker.removeSolvesMarker(issue));
-                        reply.println("Removing additional issue from solves list: `" + issue.id() + "`.");
-                    } else {
-                        reply.print("The issue `" + issue.id() + "` was not found in the list of additional solved issues. The list currently contains these issues: ");
-                        var currentList = currentSolved.stream()
-                                                       .map(id -> "`" + id + "`")
-                                                       .collect(Collectors.joining(", "));
-                        reply.println(currentList);
-                    }
-                }
-            } else {
-                var issues = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args);
-                if (issues.size() == 0) {
-                    showHelp(reply);
-                    return;
-                }
-                var validatedIssues = new ArrayList<Issue>();
-                for (var issue : issues) {
-                    try {
-                        if (bot.issueProject() == null) {
-                            if (issue.description() == null) {
-                                reply.print("This repository does not have an issue project configured - you will need to input the issue title manually ");
-                                reply.println("using the syntax `/solves " + issue.id() + ": title of the issue`.");
-                                return;
-                            } else {
-                                validatedIssues.add(issue);
-                                continue;
-                            }
-                        }
-                        var validatedIssue = bot.issueProject().issue(issue.id());
-                        if (validatedIssue.isEmpty()) {
-                            reply.println("The issue `" + issue.id() + "` was not found in the `" + bot.issueProject().name() + "` project - make sure you have entered it correctly.");
-                            continue;
-                        }
-                        if (validatedIssue.get().state() != org.openjdk.skara.issuetracker.Issue.State.OPEN) {
-                            reply.println("The issue [" + validatedIssue.get().id() + "](" + validatedIssue.get().webUrl() + ") isn't open - make sure you have selected the correct issue.");
-                            continue;
-                        }
-                        if (issue.description() == null) {
-                            validatedIssues.add(new Issue(validatedIssue.get().id(), validatedIssue.get().title()));
-                        } else {
-                            validatedIssues.add(new Issue(validatedIssue.get().id(), issue.description()));
-                        }
-
-                    } catch (RuntimeException e) {
-                        if (issue.description() == null) {
-                            reply.print("Temporary failure when trying to look up issue `" + issue.id() + "` - you will need to input the issue title manually ");
-                            reply.println("using the syntax `/solves " + issue.id() + ": title of the issue`.");
-                            return;
-                        } else {
-                            validatedIssues.add(issue);
-                        }
-                    }
-                }
-                if (validatedIssues.size() != issues.size()) {
-                    reply.println("As there were validation problems, no additional issues will be added to the list of solved issues.");
-                    return;
-                }
-
-                // Drop the validated project prefixes
-                var strippedValidatedIssues = validatedIssues.stream()
-                                                             .map(issue -> issue.id().contains("-") ? new Issue(issue.id().split("-", 2)[1], issue.description()) : issue)
-                                                             .collect(Collectors.toList());
-                var titleIssue = Issue.fromString(pr.title());
-                for (var issue : strippedValidatedIssues) {
-                    if (titleIssue.isEmpty()) {
-                        reply.print("The primary solved issue for a PR is set through the PR title. Since the current title does ");
-                        reply.println("not contain an issue reference, it will now be updated.");
-                        pr.setTitle(issue.toString());
-                        titleIssue = Optional.of(issue);
-                        continue;
-                    }
-                    if (titleIssue.get().id().equals(issue.id())) {
-                        reply.println("This issue is referenced in the PR title - it will now be updated.");
-                        pr.setTitle(issue.toString());
-                        continue;
-                    }
-                    reply.println(SolvesTracker.setSolvesMarker(issue));
-                    if (currentSolved.contains(issue.id())) {
-                        reply.println("Updating description of additional solved issue: `" + issue.toString() + "`.");
-                    } else {
-                        reply.println("Adding additional issue to solves list: `" + issue.toString() + "`.");
-                    }
-                }
-            }
-
-        } catch (InvalidIssue invalidIssue) {
-            reply.println("The issue identifier `" + invalidIssue.identifier() + "` is invalid: " + invalidIssue.reason() + ".");
-        }
-    }
-
-    @Override
-    public String description() {
-        return "add an additional issue that this PR solves";
-    }
-}
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IssueTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IssueTests.java
--- /dev/null
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IssueTests.java
@@ -0,0 +1,374 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.pr;
+
+import org.openjdk.skara.forge.Review;
+import org.openjdk.skara.issuetracker.Comment;
+import org.openjdk.skara.test.*;
+import org.openjdk.skara.vcs.Repository;
+
+import org.junit.jupiter.api.*;
+
+import java.io.IOException;
+import java.util.*;
+
+import static org.junit.jupiter.api.Assertions.*;
+import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;
+
+class IssueTests {
+    @Test
+    void simple(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addReviewer(integrator.forge().currentUser().id())
+                                           .addCommitter(author.forge().currentUser().id());
+            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
+
+            // Populate the projects repository
+            var localRepoFolder = tempFolder.path().resolve("localrepo");
+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "123: This is a pull request");
+
+            // No arguments
+            pr.addComment("/issue");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a help message
+            assertLastCommentContains(pr,"Command syntax: `/issue");
+
+            // Check that the alias works as well
+            pr.addComment("/solves");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a help message
+            assertLastCommentContains(pr,"Command syntax: `/solves");
+
+            // Invalid syntax
+            pr.addComment("/issue something I guess");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a failure message
+            assertLastCommentContains(pr,"Command syntax");
+
+            // Add an issue
+            pr.addComment("/issue 1234: An issue");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a success message
+            assertLastCommentContains(pr,"Adding additional");
+
+            // Try to remove a not-previously-added issue
+            pr.addComment("/issue remove 1235");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a failure message
+            assertLastCommentContains(pr,"was not found");
+
+            // Now remove the added one
+            pr.addComment("/issue remove 1234");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a success message
+            assertLastCommentContains(pr,"Removing additional");
+
+            // Add two more issues
+            pr.addComment("/issue 12345: Another issue");
+            pr.addComment("/issue 123456: Yet another issue");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a success message
+            assertLastCommentContains(pr,"Adding additional");
+
+            // Update the description of the first one
+            pr.addComment("/issue 12345: This is indeed another issue");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a success message
+            assertLastCommentContains(pr,"Updating description");
+
+            // Approve it as another user
+            var approvalPr = integrator.pullRequest(pr.id());
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
+            TestBotRunner.runPeriodicItems(prBot);
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The commit message preview should contain the additional issues
+            var preview = pr.comments().stream()
+                            .filter(comment -> comment.body().contains("the commit message will be"))
+                            .map(Comment::body)
+                            .findFirst()
+                            .orElseThrow();
+            assertTrue(preview.contains("123: This is a pull request"));
+            assertTrue(preview.contains("12345: This is indeed another issue"));
+            assertTrue(preview.contains("123456: Yet another issue"));
+
+            // Integrate
+            pr.addComment("/integrate");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with an ok message
+            assertLastCommentContains(pr,"Pushed as commit");
+
+            // The change should now be present on the master branch
+            var pushedFolder = tempFolder.path().resolve("pushed");
+            var pushedRepo = Repository.materialize(pushedFolder, author.url(), "master");
+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
+
+            var headHash = pushedRepo.resolve("HEAD").orElseThrow();
+            var headCommit = pushedRepo.commits(headHash.hex() + "^.." + headHash.hex()).asList().get(0);
+
+            // The additional issues should be present in the commit message
+            assertEquals(List.of("123: This is a pull request",
+                                 "12345: This is indeed another issue",
+                                 "123456: Yet another issue",
+                                 "",
+                                 "Reviewed-by: integrationreviewer1"), headCommit.message());
+        }
+    }
+
+    @Test
+    void multiple(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+            var issues = credentials.getIssueProject();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addReviewer(integrator.forge().currentUser().id())
+                                           .addCommitter(author.forge().currentUser().id());
+            var prBot = PullRequestBot.newBuilder()
+                                      .repo(integrator)
+                                      .censusRepo(censusBuilder.build())
+                                      .issueProject(issues)
+                                      .build();
+
+            // Populate the projects repository
+            var localRepoFolder = tempFolder.path().resolve("localrepo");
+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "123: This is a pull request");
+
+            var issue1 = credentials.createIssue(issues, "First");
+            var issue1Number = Integer.parseInt(issue1.id().split("-")[1]);
+            var issue2 = credentials.createIssue(issues, "Second");
+            var issue2Number = Integer.parseInt(issue2.id().split("-")[1]);
+
+            // Add two issues with the shorthand syntax
+            pr.addComment("/issue " + issue1.id() + "," + issue2Number);
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should add both
+            assertLastCommentContains(pr, "Adding additional issue to solves list");
+            assertLastCommentContains(pr, ": First");
+            assertLastCommentContains(pr, ": Second");
+
+            // Remove one
+            pr.addComment("/issue remove " + issue1.id());
+            TestBotRunner.runPeriodicItems(prBot);
+
+            assertLastCommentContains(pr, "Removing additional issue from solves list: `" + issue1Number + "`");
+
+            // Approve it as another user
+            var approvalPr = integrator.pullRequest(pr.id());
+            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
+            TestBotRunner.runPeriodicItems(prBot);
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The commit message preview should contain the additional issues
+            var preview = pr.comments().stream()
+                            .filter(comment -> comment.body().contains("the commit message will be"))
+                            .map(Comment::body)
+                            .findFirst()
+                            .orElseThrow();
+            assertTrue(preview.contains("123: This is a pull request"));
+            assertTrue(preview.contains(issue2Number + ": Second"));
+            assertFalse(preview.contains("First"));
+
+            // Integrate
+            pr.addComment("/integrate");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with an ok message
+            assertLastCommentContains(pr,"Pushed as commit");
+
+            // The change should now be present on the master branch
+            var pushedFolder = tempFolder.path().resolve("pushed");
+            var pushedRepo = Repository.materialize(pushedFolder, author.url(), "master");
+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
+
+            var headHash = pushedRepo.resolve("HEAD").orElseThrow();
+            var headCommit = pushedRepo.commits(headHash.hex() + "^.." + headHash.hex()).asList().get(0);
+
+            // The additional issues should be present in the commit message
+            assertEquals(List.of("123: This is a pull request",
+                                 "2: Second",
+                                 "",
+                                 "Reviewed-by: integrationreviewer1"), headCommit.message());
+        }
+    }
+
+    @Test
+    void invalidCommandAuthor(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+            var external = credentials.getHostedRepository();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
+
+            // Issue a solves command not as the PR author
+            var externalPr = external.pullRequest(pr.id());
+            externalPr.addComment("/issue 1234: an issue");
+            TestBotRunner.runPeriodicItems(mergeBot);
+
+            // The bot should reply with an error message
+            var error = pr.comments().stream()
+                          .filter(comment -> comment.body().contains("Only the author"))
+                          .count();
+            assertEquals(1, error);
+        }
+    }
+
+    @Test
+    void issueInTitle(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
+
+            // Add an issue
+            pr.addComment("/issue 1234: An issue");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a success message
+            assertLastCommentContains(pr,"current title");
+
+            var updatedPr = author.pullRequest(pr.id());
+            assertEquals("1234: An issue", updatedPr.title());
+
+            // Update the issue description
+            pr.addComment("/issue 1234: Yes this is an issue");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // The bot should reply with a success message
+            assertLastCommentContains(pr,"will now be updated");
+
+            updatedPr = author.pullRequest(pr.id());
+            assertEquals("1234: Yes this is an issue", updatedPr.title());
+        }
+    }
+
+    @Test
+    void issueInBody(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+            var issues = credentials.getIssueProject();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).issueProject(issues).build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var issue1 = issues.createIssue("First", List.of("Hello"), Map.of());
+            var pr = credentials.createPullRequest(author, "master", "edit",
+                                                   issue1.id() + ": This is a pull request");
+
+            // First check
+            TestBotRunner.runPeriodicItems(prBot);
+            assertTrue(pr.body().contains(issue1.id()));
+            assertTrue(pr.body().contains("First"));
+            assertTrue(pr.body().contains("## Issue\n"));
+
+            // Add an extra issue
+            var issue2 = issues.createIssue("Second", List.of("There"), Map.of());
+            pr.addComment("/issue " + issue2.id() + ": Description");
+
+            // Check that the body was updated
+            TestBotRunner.runPeriodicItems(prBot);
+            TestBotRunner.runPeriodicItems(prBot);
+            assertTrue(pr.body().contains(issue1.id()));
+            assertTrue(pr.body().contains("First"));
+            assertTrue(pr.body().contains(issue2.id()));
+            assertTrue(pr.body().contains("Second"));
+            assertFalse(pr.body().contains("## Issue\n"));
+            assertTrue(pr.body().contains("## Issues\n"));
+        }
+    }
+}
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SolvesTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SolvesTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SolvesTests.java
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.pr;
-
-import org.openjdk.skara.forge.Review;
-import org.openjdk.skara.issuetracker.Comment;
-import org.openjdk.skara.test.*;
-import org.openjdk.skara.vcs.Repository;
-
-import org.junit.jupiter.api.*;
-
-import java.io.IOException;
-import java.util.*;
-
-import static org.junit.jupiter.api.Assertions.*;
-import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;
-
-class SolvesTests {
-    @Test
-    void simple(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var author = credentials.getHostedRepository();
-            var integrator = credentials.getHostedRepository();
-
-            var censusBuilder = credentials.getCensusBuilder()
-                                           .addReviewer(integrator.forge().currentUser().id())
-                                           .addCommitter(author.forge().currentUser().id());
-            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
-
-            // Populate the projects repository
-            var localRepoFolder = tempFolder.path().resolve("localrepo");
-            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
-            localRepo.push(masterHash, author.url(), "master", true);
-
-            // Make a change with a corresponding PR
-            var editHash = CheckableRepository.appendAndCommit(localRepo);
-            localRepo.push(editHash, author.url(), "edit", true);
-            var pr = credentials.createPullRequest(author, "master", "edit", "123: This is a pull request");
-
-            // No arguments
-            pr.addComment("/solves");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a help message
-            assertLastCommentContains(pr,"Command syntax");
-
-            // Invalid syntax
-            pr.addComment("/solves something I guess");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a failure message
-            assertLastCommentContains(pr,"Command syntax");
-
-            // Add an issue
-            pr.addComment("/solves 1234: An issue");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a success message
-            assertLastCommentContains(pr,"Adding additional");
-
-            // Try to remove a not-previously-added issue
-            pr.addComment("/solves remove 1235");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a failure message
-            assertLastCommentContains(pr,"was not found");
-
-            // Now remove the added one
-            pr.addComment("/solves remove 1234");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a success message
-            assertLastCommentContains(pr,"Removing additional");
-
-            // Add two more issues
-            pr.addComment("/solves 12345: Another issue");
-            pr.addComment("/solves 123456: Yet another issue");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a success message
-            assertLastCommentContains(pr,"Adding additional");
-
-            // Update the description of the first one
-            pr.addComment("/solves 12345: This is indeed another issue");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a success message
-            assertLastCommentContains(pr,"Updating description");
-
-            // Approve it as another user
-            var approvalPr = integrator.pullRequest(pr.id());
-            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
-            TestBotRunner.runPeriodicItems(prBot);
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The commit message preview should contain the additional issues
-            var preview = pr.comments().stream()
-                            .filter(comment -> comment.body().contains("the commit message will be"))
-                            .map(Comment::body)
-                            .findFirst()
-                            .orElseThrow();
-            assertTrue(preview.contains("123: This is a pull request"));
-            assertTrue(preview.contains("12345: This is indeed another issue"));
-            assertTrue(preview.contains("123456: Yet another issue"));
-
-            // Integrate
-            pr.addComment("/integrate");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with an ok message
-            assertLastCommentContains(pr,"Pushed as commit");
-
-            // The change should now be present on the master branch
-            var pushedFolder = tempFolder.path().resolve("pushed");
-            var pushedRepo = Repository.materialize(pushedFolder, author.url(), "master");
-            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
-
-            var headHash = pushedRepo.resolve("HEAD").orElseThrow();
-            var headCommit = pushedRepo.commits(headHash.hex() + "^.." + headHash.hex()).asList().get(0);
-
-            // The additional issues should be present in the commit message
-            assertEquals(List.of("123: This is a pull request",
-                                 "12345: This is indeed another issue",
-                                 "123456: Yet another issue",
-                                 "",
-                                 "Reviewed-by: integrationreviewer1"), headCommit.message());
-        }
-    }
-
-    @Test
-    void multiple(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var author = credentials.getHostedRepository();
-            var integrator = credentials.getHostedRepository();
-            var issues = credentials.getIssueProject();
-
-            var censusBuilder = credentials.getCensusBuilder()
-                                           .addReviewer(integrator.forge().currentUser().id())
-                                           .addCommitter(author.forge().currentUser().id());
-            var prBot = PullRequestBot.newBuilder()
-                                      .repo(integrator)
-                                      .censusRepo(censusBuilder.build())
-                                      .issueProject(issues)
-                                      .build();
-
-            // Populate the projects repository
-            var localRepoFolder = tempFolder.path().resolve("localrepo");
-            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
-            localRepo.push(masterHash, author.url(), "master", true);
-
-            // Make a change with a corresponding PR
-            var editHash = CheckableRepository.appendAndCommit(localRepo);
-            localRepo.push(editHash, author.url(), "edit", true);
-            var pr = credentials.createPullRequest(author, "master", "edit", "123: This is a pull request");
-
-            var issue1 = credentials.createIssue(issues, "First");
-            var issue1Number = Integer.parseInt(issue1.id().split("-")[1]);
-            var issue2 = credentials.createIssue(issues, "Second");
-            var issue2Number = Integer.parseInt(issue2.id().split("-")[1]);
-
-            // Add two issues with the shorthand syntax
-            pr.addComment("/solves " + issue1.id() + "," + issue2Number);
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should add both
-            assertLastCommentContains(pr, "Adding additional issue to solves list");
-            assertLastCommentContains(pr, ": First");
-            assertLastCommentContains(pr, ": Second");
-
-            // Remove one
-            pr.addComment("/solves remove " + issue1.id());
-            TestBotRunner.runPeriodicItems(prBot);
-
-            assertLastCommentContains(pr, "Removing additional issue from solves list: `" + issue1Number + "`");
-
-            // Approve it as another user
-            var approvalPr = integrator.pullRequest(pr.id());
-            approvalPr.addReview(Review.Verdict.APPROVED, "Approved");
-            TestBotRunner.runPeriodicItems(prBot);
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The commit message preview should contain the additional issues
-            var preview = pr.comments().stream()
-                            .filter(comment -> comment.body().contains("the commit message will be"))
-                            .map(Comment::body)
-                            .findFirst()
-                            .orElseThrow();
-            assertTrue(preview.contains("123: This is a pull request"));
-            assertTrue(preview.contains(issue2Number + ": Second"));
-            assertFalse(preview.contains("First"));
-
-            // Integrate
-            pr.addComment("/integrate");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with an ok message
-            assertLastCommentContains(pr,"Pushed as commit");
-
-            // The change should now be present on the master branch
-            var pushedFolder = tempFolder.path().resolve("pushed");
-            var pushedRepo = Repository.materialize(pushedFolder, author.url(), "master");
-            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
-
-            var headHash = pushedRepo.resolve("HEAD").orElseThrow();
-            var headCommit = pushedRepo.commits(headHash.hex() + "^.." + headHash.hex()).asList().get(0);
-
-            // The additional issues should be present in the commit message
-            assertEquals(List.of("123: This is a pull request",
-                                 "2: Second",
-                                 "",
-                                 "Reviewed-by: integrationreviewer1"), headCommit.message());
-        }
-    }
-
-    @Test
-    void invalidCommandAuthor(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var author = credentials.getHostedRepository();
-            var integrator = credentials.getHostedRepository();
-            var external = credentials.getHostedRepository();
-
-            var censusBuilder = credentials.getCensusBuilder()
-                                           .addAuthor(author.forge().currentUser().id());
-            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
-
-            // Populate the projects repository
-            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
-            localRepo.push(masterHash, author.url(), "master", true);
-
-            // Make a change with a corresponding PR
-            var editHash = CheckableRepository.appendAndCommit(localRepo);
-            localRepo.push(editHash, author.url(), "edit", true);
-            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
-
-            // Issue a solves command not as the PR author
-            var externalPr = external.pullRequest(pr.id());
-            externalPr.addComment("/solves 1234: an issue");
-            TestBotRunner.runPeriodicItems(mergeBot);
-
-            // The bot should reply with an error message
-            var error = pr.comments().stream()
-                          .filter(comment -> comment.body().contains("Only the author"))
-                          .count();
-            assertEquals(1, error);
-        }
-    }
-
-    @Test
-    void issueInTitle(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var author = credentials.getHostedRepository();
-            var integrator = credentials.getHostedRepository();
-
-            var censusBuilder = credentials.getCensusBuilder()
-                                           .addAuthor(author.forge().currentUser().id());
-            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
-
-            // Populate the projects repository
-            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
-            localRepo.push(masterHash, author.url(), "master", true);
-
-            // Make a change with a corresponding PR
-            var editHash = CheckableRepository.appendAndCommit(localRepo);
-            localRepo.push(editHash, author.url(), "edit", true);
-            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
-
-            // Add an issue
-            pr.addComment("/solves 1234: An issue");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a success message
-            assertLastCommentContains(pr,"current title");
-
-            var updatedPr = author.pullRequest(pr.id());
-            assertEquals("1234: An issue", updatedPr.title());
-
-            // Update the issue description
-            pr.addComment("/solves 1234: Yes this is an issue");
-            TestBotRunner.runPeriodicItems(prBot);
-
-            // The bot should reply with a success message
-            assertLastCommentContains(pr,"will now be updated");
-
-            updatedPr = author.pullRequest(pr.id());
-            assertEquals("1234: Yes this is an issue", updatedPr.title());
-        }
-    }
-
-    @Test
-    void issueInBody(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var author = credentials.getHostedRepository();
-            var integrator = credentials.getHostedRepository();
-            var issues = credentials.getIssueProject();
-
-            var censusBuilder = credentials.getCensusBuilder()
-                                           .addAuthor(author.forge().currentUser().id());
-            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).issueProject(issues).build();
-
-            // Populate the projects repository
-            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
-            localRepo.push(masterHash, author.url(), "master", true);
-
-            // Make a change with a corresponding PR
-            var editHash = CheckableRepository.appendAndCommit(localRepo);
-            localRepo.push(editHash, author.url(), "edit", true);
-            var issue1 = issues.createIssue("First", List.of("Hello"), Map.of());
-            var pr = credentials.createPullRequest(author, "master", "edit",
-                                                   issue1.id() + ": This is a pull request");
-
-            // First check
-            TestBotRunner.runPeriodicItems(prBot);
-            assertTrue(pr.body().contains(issue1.id()));
-            assertTrue(pr.body().contains("First"));
-            assertTrue(pr.body().contains("## Issue\n"));
-
-            // Add an extra issue
-            var issue2 = issues.createIssue("Second", List.of("There"), Map.of());
-            pr.addComment("/solves " + issue2.id() + ": Description");
-
-            // Check that the body was updated
-            TestBotRunner.runPeriodicItems(prBot);
-            TestBotRunner.runPeriodicItems(prBot);
-            assertTrue(pr.body().contains(issue1.id()));
-            assertTrue(pr.body().contains("First"));
-            assertTrue(pr.body().contains(issue2.id()));
-            assertTrue(pr.body().contains("Second"));
-            assertFalse(pr.body().contains("## Issue\n"));
-            assertTrue(pr.body().contains("## Issues\n"));
-        }
-    }
-}

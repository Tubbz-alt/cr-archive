<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 
 31 import java.io.*;
 32 import java.nio.file.Paths;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.*;
 36 import java.util.logging.Logger;
 37 
 38 public class JCheck {
 39     private final ReadOnlyRepository repository;
 40     private final Census census;
 41     private final CommitMessageParser parser;
 42     private final String revisionRange;
 43     private final Map&lt;String, Set&lt;Hash&gt;&gt; whitelist;
 44     private final List&lt;CommitCheck&gt; commitChecks;
 45     private final List&lt;RepositoryCheck&gt; repositoryChecks;
 46     private final List&lt;String&gt; additionalConfiguration;
 47     private final JCheckConfiguration overridingConfiguration;
 48     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.jcheck&quot;);
 49 
<span class="line-removed"> 50     private JCheckConfiguration cachedConfiguration = null;</span>
<span class="line-removed"> 51 </span>
 52     JCheck(ReadOnlyRepository repository,
 53            Census census,
 54            CommitMessageParser parser,
 55            String revisionRange,
 56            Pattern allowedBranches,
 57            Pattern allowedTags,
 58            Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
 59            Set&lt;Hash&gt; blacklist,
 60            List&lt;String&gt; additionalConfiguration,
 61            JCheckConfiguration overridingConfiguration) throws IOException {
 62         this.repository = repository;
 63         this.census = census;
 64         this.parser = parser;
 65         this.revisionRange = revisionRange;
 66         this.whitelist = whitelist;
 67         this.additionalConfiguration = additionalConfiguration;
 68         this.overridingConfiguration = overridingConfiguration;
 69 
 70         var utils = new Utilities();
 71         commitChecks = List.of(
</pre>
<hr />
<pre>
 87         );
 88     }
 89 
 90     private static Optional&lt;JCheckConfiguration&gt; parseConfiguration(ReadOnlyRepository r, Hash h, List&lt;String&gt; additionalConfiguration) {
 91         try {
 92             var content = new ArrayList&lt;&gt;(r.lines(Paths.get(&quot;.jcheck/conf&quot;), h).orElse(Collections.emptyList()));
 93             content.addAll(additionalConfiguration);
 94             if (content.size() == 0) {
 95                 return Optional.empty();
 96             }
 97             return Optional.of(JCheckConfiguration.parse(content));
 98         } catch (IOException e) {
 99             throw new UncheckedIOException(e);
100         }
101     }
102 
103     private Optional&lt;JCheckConfiguration&gt; getConfigurationFor(Commit c) {
104         if (overridingConfiguration != null) {
105             return Optional.of(overridingConfiguration);
106         }
<span class="line-modified">107         var confPath = Paths.get(&quot;.jcheck/conf&quot;);</span>
<span class="line-removed">108         var changesConfiguration = c.parentDiffs()</span>
<span class="line-removed">109                                     .stream()</span>
<span class="line-removed">110                                     .map(Diff::patches)</span>
<span class="line-removed">111                                     .flatMap(List::stream)</span>
<span class="line-removed">112                                     .anyMatch(p -&gt; p.source().path().isPresent() &amp;&amp; p.source().path().get().equals(confPath) ||</span>
<span class="line-removed">113                                                    p.target().path().isPresent() &amp;&amp; p.target().path().get().equals(confPath));</span>
<span class="line-removed">114 </span>
<span class="line-removed">115 </span>
<span class="line-removed">116         if (changesConfiguration || cachedConfiguration == null) {</span>
<span class="line-removed">117             var confAtCommit = parseConfiguration(repository, c.hash(), additionalConfiguration);</span>
<span class="line-removed">118             confAtCommit.ifPresent(jCheckConfiguration -&gt; cachedConfiguration = jCheckConfiguration);</span>
<span class="line-removed">119             return confAtCommit;</span>
<span class="line-removed">120         } else {</span>
<span class="line-removed">121             return Optional.of(cachedConfiguration);</span>
<span class="line-removed">122         }</span>
123     }
124 
125     private Iterator&lt;Issue&gt; checkCommit(Commit commit) {
126         log.fine(&quot;Checking: &quot; + commit.hash().hex());
127         var configuration = getConfigurationFor(commit);
128         if (!configuration.isPresent()) {
129             log.finer(&quot;No .jcheck/conf present for &quot; + commit.hash().hex());
130             return Collections.emptyIterator();
131         }
132 
133         var conf = configuration.get();
134         var message = parser.parse(commit);
135         var enabled = conf.checks().enabled(commitChecks);
136         var iterator = new MapIterator&lt;CommitCheck, Iterator&lt;Issue&gt;&gt;(enabled.iterator(), c -&gt; {
137             var skip = whitelist.get(c.name());
138             if (skip != null &amp;&amp; skip.contains(commit.hash())) {
139                 log.finer(&quot;Commit check &#39;&quot; + c.name() + &quot;&#39; is whitelisted for &quot; + commit.hash().hex());
140                 return Collections.emptyIterator();
141             }
142             log.finer(&quot;Running commit check &#39;&quot; + c.name() + &quot;&#39; for &quot; + commit.hash().hex());
</pre>
</td>
<td>
<hr />
<pre>
 30 
 31 import java.io.*;
 32 import java.nio.file.Paths;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.*;
 36 import java.util.logging.Logger;
 37 
 38 public class JCheck {
 39     private final ReadOnlyRepository repository;
 40     private final Census census;
 41     private final CommitMessageParser parser;
 42     private final String revisionRange;
 43     private final Map&lt;String, Set&lt;Hash&gt;&gt; whitelist;
 44     private final List&lt;CommitCheck&gt; commitChecks;
 45     private final List&lt;RepositoryCheck&gt; repositoryChecks;
 46     private final List&lt;String&gt; additionalConfiguration;
 47     private final JCheckConfiguration overridingConfiguration;
 48     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.jcheck&quot;);
 49 


 50     JCheck(ReadOnlyRepository repository,
 51            Census census,
 52            CommitMessageParser parser,
 53            String revisionRange,
 54            Pattern allowedBranches,
 55            Pattern allowedTags,
 56            Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
 57            Set&lt;Hash&gt; blacklist,
 58            List&lt;String&gt; additionalConfiguration,
 59            JCheckConfiguration overridingConfiguration) throws IOException {
 60         this.repository = repository;
 61         this.census = census;
 62         this.parser = parser;
 63         this.revisionRange = revisionRange;
 64         this.whitelist = whitelist;
 65         this.additionalConfiguration = additionalConfiguration;
 66         this.overridingConfiguration = overridingConfiguration;
 67 
 68         var utils = new Utilities();
 69         commitChecks = List.of(
</pre>
<hr />
<pre>
 85         );
 86     }
 87 
 88     private static Optional&lt;JCheckConfiguration&gt; parseConfiguration(ReadOnlyRepository r, Hash h, List&lt;String&gt; additionalConfiguration) {
 89         try {
 90             var content = new ArrayList&lt;&gt;(r.lines(Paths.get(&quot;.jcheck/conf&quot;), h).orElse(Collections.emptyList()));
 91             content.addAll(additionalConfiguration);
 92             if (content.size() == 0) {
 93                 return Optional.empty();
 94             }
 95             return Optional.of(JCheckConfiguration.parse(content));
 96         } catch (IOException e) {
 97             throw new UncheckedIOException(e);
 98         }
 99     }
100 
101     private Optional&lt;JCheckConfiguration&gt; getConfigurationFor(Commit c) {
102         if (overridingConfiguration != null) {
103             return Optional.of(overridingConfiguration);
104         }
<span class="line-modified">105         return parseConfiguration(repository, c.hash(), additionalConfiguration);</span>















106     }
107 
108     private Iterator&lt;Issue&gt; checkCommit(Commit commit) {
109         log.fine(&quot;Checking: &quot; + commit.hash().hex());
110         var configuration = getConfigurationFor(commit);
111         if (!configuration.isPresent()) {
112             log.finer(&quot;No .jcheck/conf present for &quot; + commit.hash().hex());
113             return Collections.emptyIterator();
114         }
115 
116         var conf = configuration.get();
117         var message = parser.parse(commit);
118         var enabled = conf.checks().enabled(commitChecks);
119         var iterator = new MapIterator&lt;CommitCheck, Iterator&lt;Issue&gt;&gt;(enabled.iterator(), c -&gt; {
120             var skip = whitelist.get(c.name());
121             if (skip != null &amp;&amp; skip.contains(commit.hash())) {
122                 log.finer(&quot;Commit check &#39;&quot; + c.name() + &quot;&#39; is whitelisted for &quot; + commit.hash().hex());
123                 return Collections.emptyIterator();
124             }
125             log.finer(&quot;Running commit check &#39;&quot; + c.name() + &quot;&#39; for &quot; + commit.hash().hex());
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
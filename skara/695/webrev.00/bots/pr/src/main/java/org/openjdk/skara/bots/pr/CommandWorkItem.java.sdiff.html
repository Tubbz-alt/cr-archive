<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/java/org/openjdk/skara/bots/pr/CommandTests.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 42     private static final String commandReplyMarker = &quot;&lt;!-- Jmerge command reply message (%s) --&gt;&quot;;
 43     private static final Pattern commandReplyPattern = Pattern.compile(&quot;&lt;!-- Jmerge command reply message \\((\\S+)\\) --&gt;&quot;);
 44     private static final String selfCommandMarker = &quot;&lt;!-- Valid self-command --&gt;&quot;;
 45 
 46     private static final Map&lt;String, CommandHandler&gt; commandHandlers = Map.ofEntries(
 47             Map.entry(&quot;help&quot;, new HelpCommand()),
 48             Map.entry(&quot;integrate&quot;, new IntegrateCommand()),
 49             Map.entry(&quot;sponsor&quot;, new SponsorCommand()),
 50             Map.entry(&quot;contributor&quot;, new ContributorCommand()),
 51             Map.entry(&quot;summary&quot;, new SummaryCommand()),
 52             Map.entry(&quot;issue&quot;, new IssueCommand()),
 53             Map.entry(&quot;solves&quot;, new IssueCommand(&quot;solves&quot;)),
 54             Map.entry(&quot;reviewers&quot;, new ReviewersCommand()),
 55             Map.entry(&quot;csr&quot;, new CSRCommand()),
 56             Map.entry(&quot;reviewer&quot;, new ReviewerCommand()),
 57             Map.entry(&quot;label&quot;, new LabelCommand()),
 58             Map.entry(&quot;cc&quot;, new LabelCommand(&quot;cc&quot;))
 59     );
 60 
 61     static class HelpCommand implements CommandHandler {
<span class="line-removed"> 62         static private Map&lt;String, String&gt; external = null;</span>
<span class="line-removed"> 63 </span>
 64         @Override
 65         public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List&lt;Comment&gt; allComments, PrintWriter reply) {
 66             reply.println(&quot;Available commands:&quot;);
 67             Stream.concat(
 68                     commandHandlers.entrySet().stream()
 69                                    .map(entry -&gt; entry.getKey() + &quot; - &quot; + entry.getValue().description()),
<span class="line-modified"> 70                     external.entrySet().stream()</span>
<span class="line-modified"> 71                             .map(entry -&gt; entry.getKey() + &quot; - &quot; + entry.getValue())</span>
 72             ).sorted().forEachOrdered(c -&gt; reply.println(&quot; * &quot; + c));
 73         }
 74 
 75         @Override
 76         public String description() {
 77             return &quot;shows this text&quot;;
 78         }
 79     }
 80 
 81     CommandWorkItem(PullRequestBot bot, PullRequest pr, Consumer&lt;RuntimeException&gt; errorHandler) {
 82         super(bot, pr, errorHandler);
 83     }
 84 
 85     private List&lt;AbstractMap.SimpleEntry&lt;String, Comment&gt;&gt; findCommandComments(List&lt;Comment&gt; comments) {
 86         var self = pr.repository().forge().currentUser();
 87         var handled = comments.stream()
 88                               .filter(comment -&gt; comment.author().equals(self))
 89                               .map(comment -&gt; commandReplyPattern.matcher(comment.body()))
 90                               .filter(Matcher::find)
 91                               .map(matcher -&gt; matcher.group(1))
</pre>
<hr />
<pre>
160         return ret;
161     }
162 
163     private Optional&lt;CommandInvocation&gt; nextCommand(PullRequest pr, List&lt;Comment&gt; comments) {
164         var self = pr.repository().forge().currentUser();
165         var allCommands = Stream.concat(extractCommands(pr.body(), &quot;body&quot;, pr.author()).stream(),
166                                         comments.stream()
167                                                 .filter(comment -&gt; !comment.author().equals(self) || comment.body().endsWith(selfCommandMarker))
168                                                 .flatMap(c -&gt; extractCommands(c.body(), c.id(), c.author()).stream()))
169                                 .collect(Collectors.toList());
170 
171         var handled = comments.stream()
172                               .filter(comment -&gt; comment.author().equals(self))
173                               .map(comment -&gt; commandReplyPattern.matcher(comment.body()))
174                               .filter(Matcher::find)
175                               .map(matcher -&gt; matcher.group(1))
176                               .collect(Collectors.toSet());
177 
178         return allCommands.stream()
179                           .filter(ci -&gt; !handled.contains(ci.id()))

180                           .findFirst();
181     }
182 
183     private void processCommand(PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List&lt;Comment&gt; allComments) {
184         var writer = new StringWriter();
185         var printer = new PrintWriter(writer);
186 
187         printer.println(String.format(commandReplyMarker, command.id()));
188         printer.print(&quot;@&quot;);
189         printer.print(command.user().userName());
190         printer.print(&quot; &quot;);
191 
192         var handler = command.handler();
193         if (handler.isPresent()) {
194             handler.get().handle(bot, pr, censusInstance, scratchPath, command, allComments, printer);
195         } else {
<span class="line-modified">196             if (!bot.externalCommands().containsKey(command.name())) {</span>
<span class="line-modified">197                 printer.print(&quot;Unknown command `&quot;);</span>
<span class="line-modified">198                 printer.print(command.name());</span>
<span class="line-removed">199                 printer.println(&quot;` - for a list of valid commands use `/help`.&quot;);</span>
<span class="line-removed">200             } else {</span>
<span class="line-removed">201                 // Do not reply to external commands</span>
<span class="line-removed">202                 return;</span>
<span class="line-removed">203             }</span>
204         }
205 
206         pr.addComment(writer.toString());
207     }
208 
209     @Override
210     public Collection&lt;WorkItem&gt; run(Path scratchPath) {
211         log.info(&quot;Looking for PR commands&quot;);
212 
213         if (pr.labels().contains(&quot;integrated&quot;)) {
214             log.info(&quot;Skip checking for commands in integrated PR&quot;);
215             return List.of();
216         }
217 
218         var comments = pr.comments();
219         var nextCommand = nextCommand(pr, comments);
220         if (nextCommand.isEmpty()) {
<span class="line-modified">221             log.fine(&quot;No new PR commands found, stopping further processing&quot;);</span>
222             return List.of();
223         }
224 
<span class="line-removed">225         if (HelpCommand.external == null) {</span>
<span class="line-removed">226             HelpCommand.external = bot.externalCommands();</span>
<span class="line-removed">227         }</span>
<span class="line-removed">228 </span>
229         var census = CensusInstance.create(bot.censusRepo(), bot.censusRef(), scratchPath.resolve(&quot;census&quot;), pr);
<span class="line-modified">230         processCommand(pr, census, scratchPath.resolve(&quot;pr&quot;).resolve(&quot;command&quot;), nextCommand.get(), comments);</span>


231 
232         // Run another check to reflect potential changes from commands
233         return List.of(new CheckWorkItem(bot, pr, errorHandler));
234     }
235 
236     @Override
237     public String toString() {
238         return &quot;CommandWorkItem@&quot; + pr.repository().name() + &quot;#&quot; + pr.id();
239     }
240 }
</pre>
</td>
<td>
<hr />
<pre>
 42     private static final String commandReplyMarker = &quot;&lt;!-- Jmerge command reply message (%s) --&gt;&quot;;
 43     private static final Pattern commandReplyPattern = Pattern.compile(&quot;&lt;!-- Jmerge command reply message \\((\\S+)\\) --&gt;&quot;);
 44     private static final String selfCommandMarker = &quot;&lt;!-- Valid self-command --&gt;&quot;;
 45 
 46     private static final Map&lt;String, CommandHandler&gt; commandHandlers = Map.ofEntries(
 47             Map.entry(&quot;help&quot;, new HelpCommand()),
 48             Map.entry(&quot;integrate&quot;, new IntegrateCommand()),
 49             Map.entry(&quot;sponsor&quot;, new SponsorCommand()),
 50             Map.entry(&quot;contributor&quot;, new ContributorCommand()),
 51             Map.entry(&quot;summary&quot;, new SummaryCommand()),
 52             Map.entry(&quot;issue&quot;, new IssueCommand()),
 53             Map.entry(&quot;solves&quot;, new IssueCommand(&quot;solves&quot;)),
 54             Map.entry(&quot;reviewers&quot;, new ReviewersCommand()),
 55             Map.entry(&quot;csr&quot;, new CSRCommand()),
 56             Map.entry(&quot;reviewer&quot;, new ReviewerCommand()),
 57             Map.entry(&quot;label&quot;, new LabelCommand()),
 58             Map.entry(&quot;cc&quot;, new LabelCommand(&quot;cc&quot;))
 59     );
 60 
 61     static class HelpCommand implements CommandHandler {


 62         @Override
 63         public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List&lt;Comment&gt; allComments, PrintWriter reply) {
 64             reply.println(&quot;Available commands:&quot;);
 65             Stream.concat(
 66                     commandHandlers.entrySet().stream()
 67                                    .map(entry -&gt; entry.getKey() + &quot; - &quot; + entry.getValue().description()),
<span class="line-modified"> 68                     bot.externalCommands().entrySet().stream()</span>
<span class="line-modified"> 69                                           .map(entry -&gt; entry.getKey() + &quot; - &quot; + entry.getValue())</span>
 70             ).sorted().forEachOrdered(c -&gt; reply.println(&quot; * &quot; + c));
 71         }
 72 
 73         @Override
 74         public String description() {
 75             return &quot;shows this text&quot;;
 76         }
 77     }
 78 
 79     CommandWorkItem(PullRequestBot bot, PullRequest pr, Consumer&lt;RuntimeException&gt; errorHandler) {
 80         super(bot, pr, errorHandler);
 81     }
 82 
 83     private List&lt;AbstractMap.SimpleEntry&lt;String, Comment&gt;&gt; findCommandComments(List&lt;Comment&gt; comments) {
 84         var self = pr.repository().forge().currentUser();
 85         var handled = comments.stream()
 86                               .filter(comment -&gt; comment.author().equals(self))
 87                               .map(comment -&gt; commandReplyPattern.matcher(comment.body()))
 88                               .filter(Matcher::find)
 89                               .map(matcher -&gt; matcher.group(1))
</pre>
<hr />
<pre>
158         return ret;
159     }
160 
161     private Optional&lt;CommandInvocation&gt; nextCommand(PullRequest pr, List&lt;Comment&gt; comments) {
162         var self = pr.repository().forge().currentUser();
163         var allCommands = Stream.concat(extractCommands(pr.body(), &quot;body&quot;, pr.author()).stream(),
164                                         comments.stream()
165                                                 .filter(comment -&gt; !comment.author().equals(self) || comment.body().endsWith(selfCommandMarker))
166                                                 .flatMap(c -&gt; extractCommands(c.body(), c.id(), c.author()).stream()))
167                                 .collect(Collectors.toList());
168 
169         var handled = comments.stream()
170                               .filter(comment -&gt; comment.author().equals(self))
171                               .map(comment -&gt; commandReplyPattern.matcher(comment.body()))
172                               .filter(Matcher::find)
173                               .map(matcher -&gt; matcher.group(1))
174                               .collect(Collectors.toSet());
175 
176         return allCommands.stream()
177                           .filter(ci -&gt; !handled.contains(ci.id()))
<span class="line-added">178                           .filter(ci -&gt; !bot.externalCommands().containsKey(ci.name()))</span>
179                           .findFirst();
180     }
181 
182     private void processCommand(PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List&lt;Comment&gt; allComments) {
183         var writer = new StringWriter();
184         var printer = new PrintWriter(writer);
185 
186         printer.println(String.format(commandReplyMarker, command.id()));
187         printer.print(&quot;@&quot;);
188         printer.print(command.user().userName());
189         printer.print(&quot; &quot;);
190 
191         var handler = command.handler();
192         if (handler.isPresent()) {
193             handler.get().handle(bot, pr, censusInstance, scratchPath, command, allComments, printer);
194         } else {
<span class="line-modified">195             printer.print(&quot;Unknown command `&quot;);</span>
<span class="line-modified">196             printer.print(command.name());</span>
<span class="line-modified">197             printer.println(&quot;` - for a list of valid commands use `/help`.&quot;);</span>





198         }
199 
200         pr.addComment(writer.toString());
201     }
202 
203     @Override
204     public Collection&lt;WorkItem&gt; run(Path scratchPath) {
205         log.info(&quot;Looking for PR commands&quot;);
206 
207         if (pr.labels().contains(&quot;integrated&quot;)) {
208             log.info(&quot;Skip checking for commands in integrated PR&quot;);
209             return List.of();
210         }
211 
212         var comments = pr.comments();
213         var nextCommand = nextCommand(pr, comments);
214         if (nextCommand.isEmpty()) {
<span class="line-modified">215             log.info(&quot;No new non-external PR commands found, stopping further processing&quot;);</span>
216             return List.of();
217         }
218 




219         var census = CensusInstance.create(bot.censusRepo(), bot.censusRef(), scratchPath.resolve(&quot;census&quot;), pr);
<span class="line-modified">220         var command = nextCommand.get();</span>
<span class="line-added">221         log.info(&quot;Processing command: &quot; + command.id() + &quot; - &quot; + command.name());</span>
<span class="line-added">222         processCommand(pr, census, scratchPath.resolve(&quot;pr&quot;).resolve(&quot;command&quot;), command, comments);</span>
223 
224         // Run another check to reflect potential changes from commands
225         return List.of(new CheckWorkItem(bot, pr, errorHandler));
226     }
227 
228     @Override
229     public String toString() {
230         return &quot;CommandWorkItem@&quot; + pr.repository().name() + &quot;#&quot; + pr.id();
231     }
232 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/java/org/openjdk/skara/bots/pr/CommandTests.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
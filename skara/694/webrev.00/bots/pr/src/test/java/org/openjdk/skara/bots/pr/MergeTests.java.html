<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.bots.pr;
  24 
  25 import org.openjdk.skara.forge.Review;
  26 import org.openjdk.skara.issuetracker.Comment;
  27 import org.openjdk.skara.process.Process;
  28 import org.openjdk.skara.test.*;
  29 import org.openjdk.skara.vcs.*;
  30 
  31 import org.junit.jupiter.api.*;
  32 
  33 import java.io.IOException;
  34 import java.nio.charset.StandardCharsets;
  35 import java.nio.file.*;
  36 import java.util.Set;
  37 import java.util.stream.Collectors;
  38 
  39 import static org.junit.jupiter.api.Assertions.*;
  40 import static org.junit.jupiter.api.Assumptions.assumeTrue;
  41 import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;
  42 
  43 class MergeTests {
  44     @Test
  45     void branchMerge(TestInfo testInfo) throws IOException {
  46         try (var credentials = new HostCredentials(testInfo);
  47              var tempFolder = new TemporaryDirectory()) {
  48 
  49             var author = credentials.getHostedRepository();
  50             var integrator = credentials.getHostedRepository();
  51             var censusBuilder = credentials.getCensusBuilder()
  52                                            .addCommitter(author.forge().currentUser().id())
  53                                            .addReviewer(integrator.forge().currentUser().id());
  54             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
  55 
  56             // Populate the projects repository
  57             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
  58             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
  59             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
  60             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
  61             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
  62 
  63             // Make more changes in another branch
  64             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
  65                                                                 &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
  66             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
  67             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
  68                                                                 &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
  69             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
  70 
  71             // Go back to the original master
  72             localRepo.checkout(masterHash, true);
  73 
  74             // Make a change with a corresponding PR
  75             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
  76             localRepo.add(unrelated);
  77             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
  78             localRepo.merge(otherHash2);
  79             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
  80 
  81             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
  82             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
  83             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
  84 
  85             // Approve it as another user
  86             var approvalPr = integrator.pullRequest(pr.id());
  87             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
  88 
  89             // Let the bot check the status
  90             TestBotRunner.runPeriodicItems(mergeBot);
  91 
  92             // Push it
  93             pr.addComment(&quot;/integrate&quot;);
  94             TestBotRunner.runPeriodicItems(mergeBot);
  95 
  96             // The bot should reply with an ok message
  97             var pushed = pr.comments().stream()
  98                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
  99                            .count();
 100             assertEquals(1, pushed);
 101 
 102             // The change should now be present on the master branch
 103             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 104             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 105             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 106 
 107             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 108             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 109             Set&lt;Hash&gt; commits;
 110             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 111                 commits = tempCommits.stream()
 112                         .map(Commit::hash)
 113                         .collect(Collectors.toSet());
 114             }
 115             assertTrue(commits.contains(otherHash1));
 116             assertTrue(commits.contains(otherHash2));
 117             assertFalse(commits.contains(mergeHash));
 118 
 119             // Author and committer should updated in the merge commit
 120             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 121             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 122             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 123             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 124             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 125         }
 126     }
 127 
 128     @Test
 129     void branchMergeShortName(TestInfo testInfo) throws IOException {
 130         try (var credentials = new HostCredentials(testInfo);
 131              var tempFolder = new TemporaryDirectory()) {
 132 
 133             var author = credentials.getHostedRepository();
 134             var integrator = credentials.getHostedRepository();
 135             var censusBuilder = credentials.getCensusBuilder()
 136                                            .addCommitter(author.forge().currentUser().id())
 137                                            .addReviewer(integrator.forge().currentUser().id());
 138             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 139 
 140             // Populate the projects repository
 141             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 142             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 143             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 144             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 145             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 146 
 147             // Make more changes in another branch
 148             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 149                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 150             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 151             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 152                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 153             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 154 
 155             // Go back to the original master
 156             localRepo.checkout(masterHash, true);
 157 
 158             // Make a change with a corresponding PR
 159             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 160             localRepo.add(unrelated);
 161             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 162             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 163 
 164             localRepo.merge(otherHash2);
 165             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 166             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 167             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge other&quot;);
 168 
 169             // Approve it as another user
 170             var approvalPr = integrator.pullRequest(pr.id());
 171             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 172 
 173             // Let the bot check the status
 174             TestBotRunner.runPeriodicItems(mergeBot);
 175 
 176             // Push it
 177             pr.addComment(&quot;/integrate&quot;);
 178             TestBotRunner.runPeriodicItems(mergeBot);
 179 
 180             // The bot should reply with an ok message
 181             var pushed = pr.comments().stream()
 182                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 183                            .count();
 184             assertEquals(1, pushed);
 185 
 186             // The change should now be present on the master branch
 187             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 188             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 189             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 190 
 191             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 192             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 193             Set&lt;Hash&gt; commits;
 194             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 195                 commits = tempCommits.stream()
 196                                      .map(Commit::hash)
 197                                      .collect(Collectors.toSet());
 198             }
 199             assertTrue(commits.contains(otherHash1));
 200             assertTrue(commits.contains(otherHash2));
 201             assertFalse(commits.contains(mergeHash));
 202 
 203             // Author and committer should updated in the merge commit
 204             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 205             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 206             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 207             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 208             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 209         }
 210     }
 211 
 212     @Test
 213     void tagMerge(TestInfo testInfo) throws IOException {
 214         try (var credentials = new HostCredentials(testInfo);
 215              var tempFolder = new TemporaryDirectory()) {
 216 
 217             var author = credentials.getHostedRepository();
 218             var integrator = credentials.getHostedRepository();
 219             var censusBuilder = credentials.getCensusBuilder()
 220                                            .addCommitter(author.forge().currentUser().id())
 221                                            .addReviewer(integrator.forge().currentUser().id());
 222             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 223 
 224             // Populate the projects repository
 225             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 226             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 227             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 228             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 229             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 230 
 231             // Make more changes in another branch
 232             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 233                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 234             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 235             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 236                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 237             var tag = localRepo.tag(otherHash2, &quot;othertag&quot;, &quot;Tagging other&quot;, &quot;tagger&quot;, &quot;tagger@one&quot;);
 238             var tagHash = localRepo.lookup(tag).orElseThrow().hash();
 239             localRepo.push(tagHash, author.url(), &quot;refs/tags/othertag&quot;);
 240 
 241             // Go back to the original master
 242             localRepo.checkout(masterHash, true);
 243 
 244             // Make a change with a corresponding PR
 245             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 246             localRepo.add(unrelated);
 247             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 248             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 249 
 250             localRepo.merge(otherHash2);
 251             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 252             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 253             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge othertag&quot;);
 254 
 255             // Approve it as another user
 256             var approvalPr = integrator.pullRequest(pr.id());
 257             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 258 
 259             // Let the bot check the status
 260             TestBotRunner.runPeriodicItems(mergeBot);
 261 
 262             // Push it
 263             pr.addComment(&quot;/integrate&quot;);
 264             TestBotRunner.runPeriodicItems(mergeBot);
 265 
 266             // The bot should reply with an ok message
 267             var pushed = pr.comments().stream()
 268                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 269                            .count();
 270             assertEquals(1, pushed);
 271 
 272             // The change should now be present on the master branch
 273             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 274             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 275             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 276 
 277             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 278             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 279             Set&lt;Hash&gt; commits;
 280             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 281                 commits = tempCommits.stream()
 282                                      .map(Commit::hash)
 283                                      .collect(Collectors.toSet());
 284             }
 285             assertTrue(commits.contains(otherHash1));
 286             assertTrue(commits.contains(otherHash2));
 287             assertFalse(commits.contains(mergeHash));
 288 
 289             // Author and committer should updated in the merge commit
 290             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 291             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 292             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 293             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 294             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 295         }
 296     }
 297 
 298     @Test
 299     void branchMergeRebase(TestInfo testInfo) throws IOException {
 300         try (var credentials = new HostCredentials(testInfo);
 301              var tempFolder = new TemporaryDirectory()) {
 302 
 303             var author = credentials.getHostedRepository();
 304             var integrator = credentials.getHostedRepository();
 305             var censusBuilder = credentials.getCensusBuilder()
 306                                            .addCommitter(author.forge().currentUser().id())
 307                                            .addReviewer(integrator.forge().currentUser().id());
 308             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 309 
 310             // Populate the projects repository
 311             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 312             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 313             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 314             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 315             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 316 
 317             // Make more changes in another branch
 318             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 319                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 320             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 321             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 322                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 323             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 324 
 325             // Go back to the original master
 326             localRepo.checkout(masterHash, true);
 327 
 328             // Make a change with a corresponding PR
 329             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 330             localRepo.add(unrelated);
 331             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 332             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 333 
 334             localRepo.merge(otherHash2);
 335             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 336             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 337             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 338 
 339             // Approve it as another user
 340             var approvalPr = integrator.pullRequest(pr.id());
 341             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 342 
 343             // Let the bot check the status
 344             TestBotRunner.runPeriodicItems(mergeBot);
 345 
 346             // Push something new to master
 347             localRepo.checkout(updatedMaster, true);
 348             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
 349             localRepo.add(newMaster);
 350             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
 351             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
 352 
 353             // Let the bot notice
 354             TestBotRunner.runPeriodicItems(mergeBot);
 355 
 356             // Push it
 357             pr.addComment(&quot;/integrate&quot;);
 358             TestBotRunner.runPeriodicItems(mergeBot);
 359 
 360             // The bot should reply with an ok message
 361             var pushed = pr.comments().stream()
 362                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 363                            .count();
 364             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 365 
 366             // The change should now be present on the master branch
 367             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 368             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 369             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 370 
 371             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 372             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 373             Set&lt;Hash&gt; commits;
 374             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 375                 commits = tempCommits.stream()
 376                         .map(Commit::hash)
 377                         .collect(Collectors.toSet());
 378             }
 379             assertTrue(commits.contains(otherHash1));
 380             assertTrue(commits.contains(otherHash2));
 381             assertFalse(commits.contains(mergeHash));
 382 
 383             // Author and committer should updated in the merge commit
 384             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 385             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 386             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 387             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 388             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 389         }
 390     }
 391 
 392     @Test
 393     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
 394         try (var credentials = new HostCredentials(testInfo);
 395              var tempFolder = new TemporaryDirectory()) {
 396 
 397             var author = credentials.getHostedRepository();
 398             var integrator = credentials.getHostedRepository();
 399             var censusBuilder = credentials.getCensusBuilder()
 400                                            .addCommitter(author.forge().currentUser().id())
 401                                            .addReviewer(integrator.forge().currentUser().id());
 402             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 403 
 404             // Populate the projects repository
 405             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 406             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 407             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 408             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 409             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 410 
 411             // Make more changes in another branch
 412             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 413                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 414             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 415             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 416                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 417             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 418 
 419             // Go back to the original master
 420             localRepo.checkout(masterHash, true);
 421 
 422             // Make a change with a corresponding PR
 423             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 424             localRepo.add(unrelated);
 425             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 426             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 427 
 428             localRepo.merge(otherHash2);
 429             var mergeHash = localRepo.commit(&quot;Our own merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 430             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 431             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 432 
 433             // Approve it as another user
 434             var approvalPr = integrator.pullRequest(pr.id());
 435             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 436 
 437             // Let the bot check the status
 438             TestBotRunner.runPeriodicItems(mergeBot);
 439 
 440             // Push something new to master
 441             localRepo.checkout(updatedMaster, true);
 442             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
 443             localRepo.add(newMaster);
 444             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
 445             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
 446 
 447             // Let the bot notice
 448             TestBotRunner.runPeriodicItems(mergeBot);
 449 
 450             // Add another commit on top of the merge commit
 451             localRepo.checkout(mergeHash, true);
 452             var extraHash = CheckableRepository.appendAndCommit(localRepo, &quot;Fixing up stuff after merge&quot;);
 453             localRepo.push(extraHash, author.url(), &quot;edit&quot;);
 454 
 455             // Let the bot notice again
 456             TestBotRunner.runPeriodicItems(mergeBot);
 457 
 458             // Merge the latest from master
 459             localRepo.merge(newMasterHash);
 460             var latestMergeHash = localRepo.commit(&quot;Our to be squashed merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 461             localRepo.push(latestMergeHash, author.url(), &quot;edit&quot;);
 462 
 463             // Let the bot notice again
 464             TestBotRunner.runPeriodicItems(mergeBot);
 465 
 466             // Push it
 467             pr.addComment(&quot;/integrate&quot;);
 468             TestBotRunner.runPeriodicItems(mergeBot);
 469 
 470             // The bot should reply with an ok message
 471             var pushed = pr.comments().stream()
 472                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 473                            .count();
 474             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 475 
 476             // The change should now be present on the master branch
 477             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 478             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 479             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 480 
 481             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 482             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 483             String commits;
 484             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 485                 commits = tempCommits.stream()
 486                                      .map(c -&gt; c.hash().hex() + &quot;:&quot; + c.message().get(0))
 487                                      .collect(Collectors.joining(&quot;,&quot;));
 488             }
 489             assertTrue(commits.contains(otherHash1.hex() + &quot;:First other&quot;));
 490             assertTrue(commits.contains(otherHash2.hex() + &quot;:Second other&quot;));
 491             assertFalse(commits.contains(&quot;Our own merge commit&quot;));
 492 
 493             // Author and committer should updated in the merge commit
 494             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 495             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 496             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 497             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 498             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 499 
 500             // The latest content from the source and the updated master should be present
 501             assertEquals(&quot;New on master&quot;, Files.readString(pushedRepoFolder.resolve(&quot;newmaster.txt&quot;)));
 502             assertEquals(&quot;Unrelated&quot;, Files.readString(pushedRepoFolder.resolve(&quot;unrelated.txt&quot;)));
 503         }
 504     }
 505 
 506     @Test
 507     void invalidMergeCommit(TestInfo testInfo) throws IOException {
 508         try (var credentials = new HostCredentials(testInfo);
 509              var tempFolder = new TemporaryDirectory()) {
 510 
 511             var author = credentials.getHostedRepository();
 512             var integrator = credentials.getHostedRepository();
 513             var censusBuilder = credentials.getCensusBuilder()
 514                                            .addCommitter(author.forge().currentUser().id())
 515                                            .addReviewer(integrator.forge().currentUser().id());
 516             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 517 
 518             // Populate the projects repository
 519             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 520             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 521             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 522             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 523             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 524 
 525             // Make a change in another branch
 526             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 527                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 528             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 529 
 530             // Go back to the original master
 531             localRepo.checkout(masterHash, true);
 532 
 533             // Make a change with a corresponding PR
 534             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 535             localRepo.add(unrelated);
 536             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 537             localRepo.merge(otherHash);
 538             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 539             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 540             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 541 
 542             // Approve it as another user
 543             var approvalPr = integrator.pullRequest(pr.id());
 544             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 545 
 546             // Let the bot check the status
 547             TestBotRunner.runPeriodicItems(mergeBot);
 548 
 549             // Push it
 550             pr.addComment(&quot;/integrate&quot;);
 551             TestBotRunner.runPeriodicItems(mergeBot);
 552 
 553             // The bot will create a proper merge commit
 554             var pushed = pr.comments().stream()
 555                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 556                            .count();
 557             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 558 
 559             // The change should now be present with correct parents on the master branch
 560             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 561             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 562             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 563 
 564             var head = pushedRepo.commitMetadata(&quot;HEAD^!&quot;).get(0);
 565             assertEquals(2, head.parents().size());
 566             assertEquals(masterHash, head.parents().get(0));
 567             assertEquals(otherHash, head.parents().get(1));
 568         }
 569     }
 570 
 571     @Test
 572     void invalidSourceRepo(TestInfo testInfo) throws IOException {
 573         try (var credentials = new HostCredentials(testInfo);
 574              var tempFolder = new TemporaryDirectory()) {
 575 
 576             var author = credentials.getHostedRepository();
 577             var integrator = credentials.getHostedRepository();
 578             var censusBuilder = credentials.getCensusBuilder()
 579                                            .addCommitter(author.forge().currentUser().id())
 580                                            .addReviewer(integrator.forge().currentUser().id());
 581             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 582 
 583             // Populate the projects repository
 584             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 585             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 586             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 587             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 588             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 589 
 590             // Make a change in another branch
 591             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 592                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 593             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 594 
 595             // Go back to the original master
 596             localRepo.checkout(masterHash, true);
 597 
 598             // Make a change with a corresponding PR
 599             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 600             localRepo.add(unrelated);
 601             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 602             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 603 
 604             localRepo.merge(otherHash);
 605             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 606             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 607             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;xyz&quot; + &quot;:other&quot;);
 608 
 609             // Approve it as another user
 610             var approvalPr = integrator.pullRequest(pr.id());
 611             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 612 
 613             // Let the bot check the status
 614             TestBotRunner.runPeriodicItems(mergeBot);
 615 
 616             // Push it
 617             pr.addComment(&quot;/integrate&quot;);
 618             TestBotRunner.runPeriodicItems(mergeBot);
 619 
 620             // The bot should reply with a failure message
 621             var error = pr.comments().stream()
 622                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 623                           .count();
 624             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 625 
 626             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 627             assertEquals(&quot;- Could not find project `&quot; + author.name() + &quot;xyz` - check that it is correct.&quot;, check.summary().orElseThrow());
 628         }
 629     }
 630 
 631     @Test
 632     void invalidSourceBranch(TestInfo testInfo) throws IOException {
 633         try (var credentials = new HostCredentials(testInfo);
 634              var tempFolder = new TemporaryDirectory()) {
 635 
 636             var author = credentials.getHostedRepository();
 637             var integrator = credentials.getHostedRepository();
 638             var censusBuilder = credentials.getCensusBuilder()
 639                                            .addCommitter(author.forge().currentUser().id())
 640                                            .addReviewer(integrator.forge().currentUser().id());
 641             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 642 
 643             // Populate the projects repository
 644             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 645             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 646             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 647             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 648             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 649 
 650             // Make a change in another branch
 651             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 652                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 653             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 654 
 655             // Go back to the original master
 656             localRepo.checkout(masterHash, true);
 657 
 658             // Make a change with a corresponding PR
 659             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 660             localRepo.add(unrelated);
 661             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 662             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 663 
 664             localRepo.merge(otherHash);
 665             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 666             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 667             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:otherxyz&quot;);
 668 
 669             // Approve it as another user
 670             var approvalPr = integrator.pullRequest(pr.id());
 671             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 672 
 673             // Let the bot check the status
 674             TestBotRunner.runPeriodicItems(mergeBot);
 675 
 676             // Push it
 677             pr.addComment(&quot;/integrate&quot;);
 678             TestBotRunner.runPeriodicItems(mergeBot);
 679 
 680             // The bot should reply with a failure message
 681             var error = pr.comments().stream()
 682                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 683                           .count();
 684             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 685 
 686             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 687             assertEquals(&quot;- Could not find the branch or tag `otherxyz` in the project `&quot; + author.name() + &quot;` - check that it is correct.&quot;, check.summary().orElseThrow());
 688         }
 689     }
 690 
 691     @Test
 692     void inferredSourceProject(TestInfo testInfo) throws IOException {
 693         try (var credentials = new HostCredentials(testInfo);
 694              var tempFolder = new TemporaryDirectory()) {
 695 
 696             var author = credentials.getHostedRepository();
 697             var integrator = credentials.getHostedRepository();
 698             var censusBuilder = credentials.getCensusBuilder()
 699                                            .addCommitter(author.forge().currentUser().id())
 700                                            .addReviewer(integrator.forge().currentUser().id());
 701             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 702 
 703             // Populate the projects repository
 704             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 705             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 706             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 707             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 708             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 709 
 710             // Make a change in another branch
 711             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 712                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 713             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 714 
 715             // Go back to the original master
 716             localRepo.checkout(masterHash, true);
 717 
 718             // Make a change with a corresponding PR
 719             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 720             localRepo.add(unrelated);
 721             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 722             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 723 
 724             localRepo.merge(otherHash);
 725             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 726             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 727             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge otherxyz&quot;);
 728 
 729             // Approve it as another user
 730             var approvalPr = integrator.pullRequest(pr.id());
 731             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 732 
 733             // Let the bot check the status
 734             TestBotRunner.runPeriodicItems(mergeBot);
 735 
 736             // Push it
 737             pr.addComment(&quot;/integrate&quot;);
 738             TestBotRunner.runPeriodicItems(mergeBot);
 739 
 740             // The bot should reply with a failure message
 741             var error = pr.comments().stream()
 742                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 743                           .count();
 744             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 745 
 746             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 747             assertEquals(&quot;- Could not find project `otherxyz` - check that it is correct.&quot;, check.summary().orElseThrow());
 748         }
 749     }
 750 
 751     @Test
 752     void wrongSourceBranch(TestInfo testInfo) throws IOException {
 753         try (var credentials = new HostCredentials(testInfo);
 754              var tempFolder = new TemporaryDirectory()) {
 755 
 756             var author = credentials.getHostedRepository();
 757             var integrator = credentials.getHostedRepository();
 758             var censusBuilder = credentials.getCensusBuilder()
 759                                            .addCommitter(author.forge().currentUser().id())
 760                                            .addReviewer(integrator.forge().currentUser().id());
 761             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 762 
 763             // Populate the projects repository
 764             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 765             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 766             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 767             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 768             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 769 
 770             // Make a change in another branch
 771             var other1Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other1&quot;,
 772                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 773             localRepo.push(other1Hash, author.url(), &quot;other1&quot;, true);
 774 
 775             // Go back to the original master
 776             localRepo.checkout(masterHash, true);
 777 
 778             // Make yet another change in another branch
 779             var other2Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other2&quot;,
 780                                                                 &quot;Unrelated\n\nReviewed-by: integrationreviewer2&quot;);
 781             localRepo.push(other2Hash, author.url(), &quot;other2&quot;, true);
 782 
 783             // Make a change with a corresponding PR
 784             localRepo.checkout(masterHash, true);
 785             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 786             localRepo.add(unrelated);
 787             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 788             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 789 
 790             localRepo.merge(other1Hash, &quot;ours&quot;);
 791             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 792             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 793             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other2&quot;);
 794 
 795             // Approve it as another user
 796             var approvalPr = integrator.pullRequest(pr.id());
 797             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 798 
 799             // Let the bot check the status
 800             TestBotRunner.runPeriodicItems(mergeBot);
 801 
 802             // Push it
 803             pr.addComment(&quot;/integrate&quot;);
 804             TestBotRunner.runPeriodicItems(mergeBot);
 805 
 806             // The bot should reply with a failure message
 807             var error = pr.comments().stream()
 808                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 809                           .count();
 810             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 811 
 812             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 813             assertEquals(&quot;- A merge PR must contain at least one commit from the source branch that is not already present in the target.&quot;, check.summary().orElseThrow());
 814         }
 815     }
 816 
 817     @Test
 818     void invalidAuthor(TestInfo testInfo) throws IOException {
 819         try (var credentials = new HostCredentials(testInfo);
 820              var tempFolder = new TemporaryDirectory()) {
 821 
 822             var author = credentials.getHostedRepository();
 823             var integrator = credentials.getHostedRepository();
 824             var censusBuilder = credentials.getCensusBuilder()
 825                                            .addAuthor(author.forge().currentUser().id())
 826                                            .addReviewer(integrator.forge().currentUser().id());
 827             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 828 
 829             // Populate the projects repository
 830             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 831             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 832             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 833             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 834             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 835 
 836             // Make a change in another branch
 837             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 838                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 839             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 840 
 841             // Go back to the original master
 842             localRepo.checkout(masterHash, true);
 843 
 844             // Make a change with a corresponding PR
 845             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 846             localRepo.add(unrelated);
 847             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 848             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 849 
 850             localRepo.merge(otherHash);
 851             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 852             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 853             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 854 
 855             // Approve it as another user
 856             var approvalPr = integrator.pullRequest(pr.id());
 857             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 858 
 859             // Let the bot check the status
 860             TestBotRunner.runPeriodicItems(mergeBot);
 861 
 862             // Push it
 863             pr.addComment(&quot;/integrate&quot;);
 864             TestBotRunner.runPeriodicItems(mergeBot);
 865 
 866             // The bot should reply with a need for sponsor
 867             var error = pr.comments().stream()
 868                           .filter(comment -&gt; comment.body().contains(&quot;Afterwards, your sponsor types `/sponsor`&quot;))
 869                           .count();
 870             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 871         }
 872     }
 873 
 874     @Test
 875     void unrelatedHistory(TestInfo testInfo) throws IOException {
 876         try (var credentials = new HostCredentials(testInfo);
 877              var tempFolder = new TemporaryDirectory()) {
 878 
 879             var author = credentials.getHostedRepository();
 880             // Need to force merge unrelated histories
 881             assumeTrue(author.repositoryType().equals(VCS.GIT));
 882 
 883             var integrator = credentials.getHostedRepository();
 884             var censusBuilder = credentials.getCensusBuilder()
 885                                            .addCommitter(author.forge().currentUser().id())
 886                                            .addReviewer(integrator.forge().currentUser().id());
 887             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 888 
 889             // Populate the projects repository
 890             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 891             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 892             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 893 
 894             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 895             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 896 
 897             // Make an unrelated change in another branch
 898             var unrelatedRepoFolder = tempFolder.path().resolve(&quot;unrelated&quot;);
 899             var unrelatedRepo = CheckableRepository.init(unrelatedRepoFolder, author.repositoryType(), Path.of(&quot;anotherfile.txt&quot;));
 900             unrelatedRepo.amend(&quot;Unrelated initial commit\n\nReviewed-by: integrationreviewer2&quot;, &quot;some&quot;, &quot;one@mail&quot;);
 901             var otherHash = CheckableRepository.appendAndCommit(unrelatedRepo, &quot;Change in other&quot;,
 902                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 903             unrelatedRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 904             localRepo.fetch(author.url(), &quot;other&quot;);
 905 
 906             // Go back to the original master
 907             localRepo.checkout(masterHash, true);
 908 
 909             // Make a change with a corresponding PR
 910             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 911             localRepo.add(unrelated);
 912             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 913             var mergeCmd = Process.command(&quot;git&quot;, &quot;merge&quot;, &quot;--no-commit&quot;, &quot;--allow-unrelated-histories&quot;, &quot;-s&quot;, &quot;ours&quot;, otherHash.hex())
 914                                   .workdir(localRepo.root())
 915                                   .environ(&quot;GIT_AUTHOR_NAME&quot;, &quot;some&quot;)
 916                                   .environ(&quot;GIT_AUTHOR_EMAIL&quot;, &quot;some@one&quot;)
 917                                   .environ(&quot;GIT_COMMITTER_NAME&quot;, &quot;another&quot;)
 918                                   .environ(&quot;GIT_COMMITTER_EMAIL&quot;, &quot;another@one&quot;)
 919                                   .execute();
 920             mergeCmd.check();
 921 
 922             //localRepo.merge(otherHash);
 923             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 924             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 925             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 926 
 927             // Approve it as another user
 928             var approvalPr = integrator.pullRequest(pr.id());
 929             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 930 
 931             // Let the bot check the status
 932             TestBotRunner.runPeriodicItems(mergeBot);
 933 
 934             // Push it
 935             pr.addComment(&quot;/integrate&quot;);
 936             TestBotRunner.runPeriodicItems(mergeBot);
 937 
 938             // The bot should reply with a failure message
 939             var error = pr.comments().stream()
 940                     .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 941                     .count();
 942             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 943 
 944             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 945             assertEquals(&quot;- The target and the source branches do not share common history - cannot merge them.&quot;, check.summary().orElseThrow());
 946         }
 947     }
 948 
 949     @Test
 950     void invalidSyntax(TestInfo testInfo) throws IOException {
 951         try (var credentials = new HostCredentials(testInfo);
 952              var tempFolder = new TemporaryDirectory()) {
 953 
 954             var author = credentials.getHostedRepository();
 955             var integrator = credentials.getHostedRepository();
 956             var censusBuilder = credentials.getCensusBuilder()
 957                                            .addCommitter(author.forge().currentUser().id())
 958                                            .addReviewer(integrator.forge().currentUser().id());
 959             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 960 
 961             // Populate the projects repository
 962             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 963             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(&quot;appendable.txt&quot;), Set.of(&quot;merge&quot;), &quot;1.0&quot;);
 964             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 965             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 966             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 967 
 968             // Make a change in another branch
 969             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 970                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 971             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 972 
 973             // Go back to the original master
 974             localRepo.checkout(masterHash, true);
 975 
 976             // Make a change with a corresponding PR
 977             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 978             localRepo.add(unrelated);
 979             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 980             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 981 
 982             localRepo.merge(otherHash);
 983             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 984             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 985             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge this or that&quot;);
 986 
 987             // Let the bot check the status
 988             TestBotRunner.runPeriodicItems(mergeBot);
 989 
 990             // Push it
 991             pr.addComment(&quot;/integrate&quot;);
 992             TestBotRunner.runPeriodicItems(mergeBot);
 993 
 994             // The bot should reply with a failure message
 995             var error = pr.comments().stream()
 996                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 997                           .count();
 998             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 999 
1000             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
1001             assertEquals(&quot;- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.&quot;, check.summary().orElseThrow());
1002         }
1003     }
1004 
1005     @Test
1006     void foreignCommitWarning(TestInfo testInfo) throws IOException {
1007         try (var credentials = new HostCredentials(testInfo);
1008              var tempFolder = new TemporaryDirectory()) {
1009 
1010             var author = credentials.getHostedRepository();
1011             var integrator = credentials.getHostedRepository();
1012             var censusBuilder = credentials.getCensusBuilder()
1013                                            .addCommitter(author.forge().currentUser().id())
1014                                            .addReviewer(integrator.forge().currentUser().id());
1015             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
1016 
1017             // Populate the projects repository
1018             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
1019             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
1020             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
1021             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
1022             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
1023 
1024             // Make more changes in another branch
1025             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
1026                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
1027             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
1028             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
1029                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
1030             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
1031 
1032             // Go back to the original master
1033             localRepo.checkout(masterHash, true);
1034 
1035             // Make a change with a corresponding PR
1036             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
1037             localRepo.add(unrelated);
1038             var updatedMaster = localRepo.commit( &quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
1039             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
1040 
1041             // Go back to the original master again
1042             localRepo.checkout(masterHash, true);
1043             var editChange = Files.writeString(localRepo.root().resolve(&quot;edit.txt&quot;), &quot;Edit&quot;, StandardCharsets.UTF_8);
1044             localRepo.add(editChange);
1045             var editHash = localRepo.commit( &quot;Edit&quot;, &quot;some&quot;, &quot;some@one&quot;);
1046 
1047             // Merge the latest commit from master
1048             localRepo.merge(updatedMaster);
1049             var masterMergeHash = localRepo.commit(&quot;Master merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
1050             localRepo.push(masterMergeHash, author.url(), &quot;edit&quot;, true);
1051             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;1234: A change&quot;);
1052 
1053             // Let the bot check the status
1054             TestBotRunner.runPeriodicItems(mergeBot);
1055 
1056             // Merging latest master should not trigger a warning
1057             assertEquals(0, pr.comments().size());
1058 
1059             localRepo.merge(otherHash2);
1060             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
1061             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
1062 
1063             // Let the bot check the status
1064             TestBotRunner.runPeriodicItems(mergeBot);
1065 
1066             // There should be a warning
1067             assertLastCommentContains(pr, &quot;This pull request contains merges that bring in commits not present&quot;);
1068         }
1069     }
1070 }
    </pre>
  </body>
</html>
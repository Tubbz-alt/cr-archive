diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
@@ -35,13 +35,14 @@
         this.header = header;
         this.body = body;
         this.footer = footer;
     }
 
-    static ArchiveItem from(PullRequest pr, Repository localRepo, URI issueTracker, String issuePrefix,
-                            WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification,
-                            ZonedDateTime created, ZonedDateTime updated, Hash base, Hash head, String subjectPrefix) {
+    static ArchiveItem from(PullRequest pr, Repository localRepo, HostUserToEmailAuthor hostUserToEmailAuthor,
+                            URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator,
+                            WebrevNotification webrevNotification, ZonedDateTime created, ZonedDateTime updated,
+                            Hash base, Hash head, String subjectPrefix) {
         return new ArchiveItem(null, "fc", created, updated, pr.author(), Map.of("PR-Head-Hash", head.hex(), "PR-Base-Hash", base.hex()),
                                () -> subjectPrefix + "RFR: " + pr.title(),
                                () -> "",
                                () -> ArchiveMessages.composeConversation(pr, localRepo, base, head),
                                () -> {
@@ -60,25 +61,35 @@
         } catch (IOException e) {
             return Optional.empty();
         }
     }
 
-    static ArchiveItem from(PullRequest pr, Repository localRepo, WebrevStorage.WebrevGenerator webrevGenerator,
-                            WebrevNotification webrevNotification, ZonedDateTime created, ZonedDateTime updated,
-                            Hash lastBase, Hash lastHead, Hash base, Hash head, int index, ArchiveItem parent, String subjectPrefix) {
+    private static String hostUserToCommitterName(HostUserToEmailAuthor hostUserToEmailAuthor, HostUser hostUser) {
+        var email = hostUserToEmailAuthor.author(hostUser);
+        if (email.fullName().isPresent()) {
+            return email.fullName().get();
+        } else {
+            return hostUser.fullName();
+        }
+    }
+
+    static ArchiveItem from(PullRequest pr, Repository localRepo, HostUserToEmailAuthor hostUserToEmailAuthor,
+                            WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification,
+                            ZonedDateTime created, ZonedDateTime updated, Hash lastBase, Hash lastHead, Hash base,
+                            Hash head, int index, ArchiveItem parent, String subjectPrefix) {
         return new ArchiveItem(parent,"ha" + head.hex(), created, updated, pr.author(), Map.of("PR-Head-Hash", head.hex(), "PR-Base-Hash", base.hex()),
                                () -> String.format("Re: %s[Rev %02d] RFR: %s", subjectPrefix, index, pr.title()),
                                () -> "",
                                () -> {
                                    if (lastBase.equals(base)) {
-                                       return ArchiveMessages.composeIncrementalRevision(localRepo, head, lastHead);
+                                       return ArchiveMessages.composeIncrementalRevision(localRepo, hostUserToCommitterName(hostUserToEmailAuthor, pr.author()), head, lastHead);
                                    } else {
                                        var rebasedLastHead = rebasedLastHead(localRepo, base, lastHead);
                                        if (rebasedLastHead.isPresent()) {
-                                           return ArchiveMessages.composeRebasedIncrementalRevision(localRepo, head, rebasedLastHead.get());
+                                           return ArchiveMessages.composeRebasedIncrementalRevision(localRepo, hostUserToCommitterName(hostUserToEmailAuthor, pr.author()), head, rebasedLastHead.get());
                                        } else {
-                                           return ArchiveMessages.composeFullRevision(localRepo, base, head);
+                                           return ArchiveMessages.composeFullRevision(localRepo, hostUserToCommitterName(hostUserToEmailAuthor, pr.author()), base, head);
                                        }
                                    }
                                },
                                () -> {
                                    var fullWebrev = webrevGenerator.generate(base, head, String.format("%02d", index));
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
@@ -9,11 +9,11 @@
 
 import java.io.*;
 import java.net.URI;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
-import java.util.Optional;
+import java.util.*;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 class ArchiveMessages {
     private static final Pattern commentPattern = Pattern.compile("<!--.*?-->",
@@ -67,39 +67,58 @@
             ret.append(" - ").append(String.join("\n   ", message));
         }
         return ret.toString();
     }
 
-    private static Optional<String> formatCommitMessagesFull(Repository localRepo, Hash first, Hash last) {
-        try  {
-            var commits = localRepo.commitMetadata(first, last);
-            if (commits.size() == 0) {
-                return Optional.empty();
-            } else if (commits.size() == 1) {
-                return Optional.of(formatSingleCommit(commits.get(0)));
-            } else {
-                return Optional.of(commits.stream()
-                                          .map(ArchiveMessages::formatCommitInList)
-                                          .collect(Collectors.joining("\n")));
-            }
+    private static List<CommitMetadata> commits(Repository localRepo, Hash first, Hash last) {
+        try {
+            return localRepo.commitMetadata(first, last);
         } catch (IOException e) {
+            return List.of();
+        }
+    }
+
+    private static String formatNumber(int number) {
+        switch (number) {
+            case 0: return "no";
+            case 1: return "one";
+            case 2: return "two";
+            case 3: return "three";
+            case 4: return "four";
+            case 5: return "five";
+            case 6: return "six";
+            case 7: return "seven";
+            case 8: return "eight";
+            case 9: return "ten";
+            default: return Integer.toString(number);
+        }
+    }
+
+    private static String describeCommits(List<CommitMetadata> commits, String adjective) {
+        return formatNumber(commits.size()) + (adjective.isBlank() ? "" : " " + adjective) +
+                " commit" + (commits.size() != 1 ? "s" : "");
+    }
+
+    private static Optional<String> formatCommitMessagesFull(List<CommitMetadata> commits) {
+        if (commits.size() == 0) {
             return Optional.empty();
+        } else if (commits.size() == 1) {
+            return Optional.of(formatSingleCommit(commits.get(0)));
+        } else {
+            return Optional.of(commits.stream()
+                                      .map(ArchiveMessages::formatCommitInList)
+                                      .collect(Collectors.joining("\n")));
         }
     }
 
-    private static Optional<String> formatCommitMessagesBrief(Repository localRepo, Hash first, Hash last) {
-        try  {
-            var commits = localRepo.commitMetadata(first, last);
-            if (commits.size() == 0) {
-                return Optional.empty();
-            } else {
-                return Optional.of(commits.stream()
-                                          .map(ArchiveMessages::formatCommitBrief)
-                                          .collect(Collectors.joining("\n")));
-            }
-        } catch (IOException e) {
+    private static Optional<String> formatCommitMessagesBrief(List<CommitMetadata> commits) {
+        if (commits.size() == 0) {
             return Optional.empty();
+        } else {
+            return Optional.of(commits.stream()
+                                      .map(ArchiveMessages::formatCommitBrief)
+                                      .collect(Collectors.joining("\n")));
         }
     }
 
     private static Optional<String> issueUrl(PullRequest pr, URI issueTracker, String projectPrefix) {
         var issue = Issue.fromString(pr.title());
@@ -139,51 +158,72 @@
         }
 
         return filteredBody;
     }
 
-    static String composeIncrementalRevision(Repository localRepository, Hash head, Hash lastHead) {
+    static String composeIncrementalRevision(Repository localRepository, String author, Hash head, Hash lastHead) {
         var ret = new StringBuilder();
 
         var incrementalUpdate = false;
         try {
             incrementalUpdate = localRepository.isAncestor(lastHead, head);
         } catch (IOException ignored) {
         }
-        var newCommitMessages = formatCommitMessagesFull(localRepository, lastHead, head);
+        var commits = commits(localRepository, lastHead, head);
+        var newCommitMessages = formatCommitMessagesFull(commits);
         if (incrementalUpdate) {
-            ret.append("The pull request has been incrementally updated.");
-            newCommitMessages.ifPresent(m -> ret.append(" The following content has been added to the pull request since the last revision:\n\n")
-                                                .append(m));
+            ret.append(author);
+            ret.append(" has updated the pull request incrementally");
+            var commitsDescription = describeCommits(commits, "additional");
+            newCommitMessages.ifPresentOrElse(m -> ret.append(" with ")
+                                                      .append(commitsDescription)
+                                                      .append(" since the last revision:\n\n")
+                                                      .append(m),
+                                              () -> ret.append("."));
         } else {
-            ret.append("Previous commits in this pull request have been removed, probably due to a force push. ");
+            ret.append(author);
+            ret.append(" has refreshed the contents of this pull request, and previous commits have been removed. ");
             ret.append("The incremental views will show differences compared to the previous content of the PR.");
-            newCommitMessages.ifPresent(m -> ret.append(" The following content has been updated in the pull request since the last revision:\n\n")
+            var commitsDescription = describeCommits(commits, "new");
+            newCommitMessages.ifPresent(m -> ret.append(" The pull request contains ")
+                                                .append(commitsDescription)
+                                                .append(" since the last revision:\n\n")
                                                 .append(m));
         }
         return ret.toString();
     }
 
-    static String composeRebasedIncrementalRevision(Repository localRepository, Hash head, Hash lastHead) {
+    static String composeRebasedIncrementalRevision(Repository localRepository, String author, Hash head, Hash lastHead) {
         var ret = new StringBuilder();
 
-        ret.append("The pull request has been updated with a new target base due to a merge or a rebase. ");
+        ret.append(author);
+        ret.append(" has updated the pull request with a new target base due to a merge or a rebase. ");
         ret.append("The incremental webrev excludes the unrelated changes brought in by the merge/rebase.");
 
-        var newCommitMessages = formatCommitMessagesFull(localRepository, lastHead, head);
-        newCommitMessages.ifPresent(m -> ret.append(" The following content has been added to the pull request since the last revision:\n\n")
+        var commits = commits(localRepository, lastHead, head);
+        var newCommitMessages = formatCommitMessagesFull(commits);
+        var commitsDescription = describeCommits(commits, "additional");
+        newCommitMessages.ifPresent(m -> ret.append(" The pull request contains ")
+                                            .append(commitsDescription)
+                                            .append(" since the last revision:\n\n")
                                             .append(m));
         return ret.toString();
     }
 
-    static String composeFullRevision(Repository localRepository, Hash base, Hash head) {
+    static String composeFullRevision(Repository localRepository, String author, Hash base, Hash head) {
         var ret = new StringBuilder();
 
-        ret.append("The pull request has been updated with a new target base due to a merge or a rebase.");
+        ret.append(author);
+        ret.append(" has updated the pull request with a new target base due to a merge or a rebase.");
 
-        var newCommitMessages = formatCommitMessagesFull(localRepository, base, head);
-        newCommitMessages.ifPresent(m -> ret.append(" The current content of this pull request:\n\n").append(m));
+        var commits = commits(localRepository, base, head);
+        var newCommitMessages = formatCommitMessagesFull(commits);
+        var commitsDescription = describeCommits(commits, "");
+        newCommitMessages.ifPresent(m -> ret.append(" The pull request now contains ")
+                                            .append(commitsDescription)
+                                            .append(":\n\n")
+                                            .append(m));
         return ret.toString();
     }
 
     static String composeReplySubject(String parentSubject) {
         if (parentSubject.startsWith("Re: ")) {
@@ -197,13 +237,14 @@
         return "PR: " + pr.webUrl();
     }
 
     // When changing this, ensure that the PR pattern in the notifier still matches
     static String composeConversationFooter(PullRequest pr, URI issueProject, String projectPrefix, Repository localRepo, URI webrev, Hash base, Hash head) {
+        var commits = commits(localRepo, base, head);
         var issueString = issueUrl(pr, issueProject, projectPrefix).map(url -> "  Issue: " + url + "\n").orElse("");
         return "Commit messages:\n" +
-                formatCommitMessagesBrief(localRepo, base, head).orElse("") + "\n\n" +
+                formatCommitMessagesBrief(commits).orElse("") + "\n\n" +
                 "Changes: " + pr.changeUrl() + "\n" +
                 " Webrev: " + webrev + "\n" +
                 issueString +
                 "  Stats: " + stats(localRepo, base, head) + "\n" +
                 "  Patch: " + pr.diffUrl().toString() + "\n" +
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -67,14 +67,14 @@
                 var curBase = new Hash(email.headerValue("PR-Base-Hash"));
                 var curHead = new Hash(email.headerValue("PR-Head-Hash"));
                 var created = email.date();
 
                 if (generated.isEmpty()) {
-                    var first = ArchiveItem.from(pr, localRepo, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), curBase, curHead, subjectPrefix);
+                    var first = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), curBase, curHead, subjectPrefix);
                     generated.add(first);
                 } else {
-                    var revision = ArchiveItem.from(pr, localRepo, webrevGenerator, webrevNotification, created, created, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0), subjectPrefix);
+                    var revision = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, created, created, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0), subjectPrefix);
                     generated.add(revision);
                 }
 
                 lastBase = curBase;
                 lastHead = curHead;
@@ -82,14 +82,14 @@
         }
 
         // Check if we're at a revision not previously reported
         if (!base.equals(lastBase) || !head.equals(lastHead)) {
             if (generated.isEmpty()) {
-                var first = ArchiveItem.from(pr, localRepo, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), base, head, subjectPrefix);
+                var first = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), base, head, subjectPrefix);
                 generated.add(first);
             } else {
-                var revision = ArchiveItem.from(pr, localRepo, webrevGenerator, webrevNotification, pr.updatedAt(), pr.updatedAt(), lastBase, lastHead, base, head, ++revisionIndex, generated.get(0), subjectPrefix);
+                var revision = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, pr.updatedAt(), pr.updatedAt(), lastBase, lastHead, base, head, ++revisionIndex, generated.get(0), subjectPrefix);
                 generated.add(revision);
             }
         }
 
         // A review always have a revision mail as parent, so start with these
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
@@ -912,11 +912,11 @@
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should reference the updated push
             Repository.materialize(archiveFolder.path(), archive.url(), "master");
-            assertTrue(archiveContains(archiveFolder.path(), "content has been added"));
+            assertTrue(archiveContains(archiveFolder.path(), "has updated the pull request incrementally"));
             assertTrue(archiveContains(archiveFolder.path(), "full.*/" + pr.id() + "/webrev.01"));
             assertTrue(archiveContains(archiveFolder.path(), "inc.*/" + pr.id() + "/webrev.00-01"));
             assertTrue(archiveContains(archiveFolder.path(), "Patch"));
             assertTrue(archiveContains(archiveFolder.path(), "Fetch"));
             assertTrue(archiveContains(archiveFolder.path(), "Fixing"));
@@ -1041,11 +1041,11 @@
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should reference the rebased push
             Repository.materialize(archiveFolder.path(), archive.url(), "master");
-            assertTrue(archiveContains(archiveFolder.path(), "updated with a new target base"));
+            assertTrue(archiveContains(archiveFolder.path(), "has updated the pull request with a new target base"));
             assertTrue(archiveContains(archiveFolder.path(), pr.id() + "/webrev.01"));
             assertFalse(archiveContains(archiveFolder.path(), "Incremental"));
             assertTrue(archiveContains(archiveFolder.path(), "Patch"));
             assertTrue(archiveContains(archiveFolder.path(), "Fetch"));
             assertTrue(archiveContains(archiveFolder.path(), "Original msg"));
@@ -1152,11 +1152,11 @@
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should reference the rebased push
             Repository.materialize(archiveFolder.path(), archive.url(), "archive");
-            assertTrue(archiveContains(archiveFolder.path(), "updated with a new target base"));
+            assertTrue(archiveContains(archiveFolder.path(), "has updated the pull request with a new target base"));
             assertTrue(archiveContains(archiveFolder.path(), "excludes the unrelated changes"));
             assertTrue(archiveContains(archiveFolder.path(), pr.id() + "/webrev.01"));
             assertTrue(archiveContains(archiveFolder.path(), pr.id() + "/webrev.00-01"));
             assertTrue(archiveContains(archiveFolder.path(), "Original msg"));
             assertTrue(archiveContains(archiveFolder.path(), "More updates"));

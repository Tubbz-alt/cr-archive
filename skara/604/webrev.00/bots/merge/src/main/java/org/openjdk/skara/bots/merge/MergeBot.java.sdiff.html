<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bots/merge/src/main/java/org/openjdk/skara/bots/merge/MergeBot.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MergeBotFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>bots/merge/src/main/java/org/openjdk/skara/bots/merge/MergeBot.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
174 
175             int day() {
176                 return day;
177             }
178 
179             int hour() {
180                 return hour;
181             }
182 
183             int minute() {
184                 return minute;
185             }
186         }
187 
188         private final HostedRepository fromRepo;
189         private final Branch fromBranch;
190         private final Branch toBranch;
191         private final Frequency frequency;
192         private final String name;
193         private final List&lt;String&gt; dependencies;

194 
195         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch) {
<span class="line-modified">196             this(fromRepo, fromBranch, toBranch, null, null, List.of());</span>
197         }
198 
199         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch, String name) {
<span class="line-modified">200             this(fromRepo, fromBranch, toBranch, null, name, List.of());</span>
<span class="line-removed">201         }</span>
<span class="line-removed">202 </span>
<span class="line-removed">203         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch, String name, List&lt;String&gt; dependencies) {</span>
<span class="line-removed">204             this(fromRepo, fromBranch, toBranch, null, name, dependencies);</span>
205         }
206 
207         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch, Frequency frequency) {
<span class="line-modified">208             this(fromRepo, fromBranch, toBranch, frequency, null, List.of());</span>
<span class="line-removed">209         }</span>
<span class="line-removed">210 </span>
<span class="line-removed">211         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch, Frequency frequency, String name) {</span>
<span class="line-removed">212             this(fromRepo, fromBranch, toBranch, frequency, name, List.of());</span>
213         }
214 
<span class="line-modified">215         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch, Frequency frequency, String name, List&lt;String&gt; dependencies) {</span>






216             this.fromRepo = fromRepo;
217             this.fromBranch = fromBranch;
218             this.toBranch = toBranch;
219             this.frequency = frequency;
220             this.name = name;
221             this.dependencies = dependencies;

222         }
223 
224         HostedRepository fromRepo() {
225             return fromRepo;
226         }
227 
228         Branch fromBranch() {
229             return fromBranch;
230         }
231 
232         Branch toBranch() {
233             return toBranch;
234         }
235 
236         Optional&lt;Frequency&gt; frequency() {
237             return Optional.ofNullable(frequency);
238         }
239 
240         Optional&lt;String&gt; name() {
241             return Optional.ofNullable(name);
242         }
243 
244         List&lt;String&gt; dependencies() {
245             return dependencies;
246         }




247     }
248 
249     private static void deleteDirectory(Path dir) throws IOException {
250         Files.walk(dir)
251              .map(Path::toFile)
252              .sorted(Comparator.reverseOrder())
253              .forEach(File::delete);
254     }
255 
256     private Repository cloneAndSyncFork(Path to) throws IOException {
257         var repo = pool.materialize(fork, to);
258 
259         // Sync personal fork
260         var remoteBranches = repo.remoteBranches(target.url().toString());
261         for (var branch : remoteBranches) {
262             var fetchHead = repo.fetch(target.url(), branch.hash().hex(), false);
263             repo.push(fetchHead, fork.url(), branch.name());
264         }
265 
266         // Must fetch once to update refs/heads
</pre>
<hr />
<pre>
286             var dir = storage.resolve(sanitizedUrl);
287 
288             var repo = cloneAndSyncFork(dir);
289 
290             var prTarget = fork.forge().repository(target.name()).orElseThrow(() -&gt;
291                     new IllegalStateException(&quot;Can&#39;t get well-known repository &quot; + target.name())
292             );
293             var prs = prTarget.pullRequests();
294             var currentUser = prTarget.forge().currentUser();
295 
296             var unmerged = new HashSet&lt;String&gt;();
297             for (var spec : specs) {
298                 var toBranch = spec.toBranch();
299                 var fromRepo = spec.fromRepo();
300                 var fromBranch = spec.fromBranch();
301 
302                 var targetName = Path.of(target.name()).getFileName();
303                 var fromName = Path.of(fromRepo.name()).getFileName();
304                 var fromDesc = targetName.equals(fromName) ? fromBranch.name() : fromName + &quot;:&quot; + fromBranch.name();
305 
<span class="line-removed">306                 // Check if merge conflict pull request is present</span>
307                 var shouldMerge = true;


308                 var title = &quot;Merge &quot; + fromDesc;
309                 var marker = &quot;&lt;!-- AUTOMATIC MERGE PR --&gt;&quot;;
310                 for (var pr : prs) {
311                     if (pr.title().equals(title) &amp;&amp;
312                         pr.targetRef().equals(toBranch.name()) &amp;&amp;
313                         pr.body().startsWith(marker) &amp;&amp;
314                         currentUser.equals(pr.author())) {
315                         // Yes, this could be optimized do a merge &quot;this turn&quot;, but it is much simpler
316                         // to just wait until the next time the bot runs
317                         shouldMerge = false;
318 
319                         if (pr.labels().contains(&quot;ready&quot;) &amp;&amp; !pr.labels().contains(&quot;sponsor&quot;)) {
320                             var comments = pr.comments();
321                             var integrateComments =
322                                 comments.stream()
323                                         .filter(c -&gt; c.author().equals(currentUser))
324                                         .filter(c -&gt; c.body().equals(&quot;/integrate&quot;))
325                                         .collect(Collectors.toList());
326                             if (integrateComments.isEmpty()) {
327                                 pr.addComment(&quot;/integrate&quot;);
</pre>
<hr />
<pre>
337                                 if (replies.isEmpty()) {
338                                     // No reply yet, just wait
339                                 } else {
340                                     // Got a reply and the &quot;sponsor&quot; label is not present, check for error
341                                     // and if we should add the `/integrate` command again
342                                     var lastReply = replies.get(replies.size() - 1);
343                                     var lines = lastReply.body().split(&quot;\n&quot;);
344                                     var errorPrefix = &quot;@openjdk-bot Your merge request cannot be fulfilled at this time&quot;;
345                                     if (lines.length &gt; 1 &amp;&amp; lines[1].startsWith(errorPrefix)) {
346                                         // Try again
347                                         pr.addComment(&quot;/integrate&quot;);
348                                     }
349                                     // Other reply, potentially due to rebase issue, just
350                                     // wait for the labeler to add appropriate labels.
351                                 }
352                             }
353                         }
354                     }
355                 }
356 

357                 if (spec.frequency().isPresent()) {
358                     var now = clock.now();
359                     var desc = toBranch.name() + &quot;-&gt;&quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name();
360                     var freq = spec.frequency().get();
361                     if (freq.isHourly()) {
362                         if (!hourly.containsKey(desc)) {
363                             hourly.put(desc, new HashSet&lt;Integer&gt;());
364                         }
365                         var minute = now.getMinute();
366                         var hour = now.getHour();
367                         if (freq.minute() == minute &amp;&amp; !hourly.get(desc).contains(hour)) {
368                             hourly.get(desc).add(hour);
369                         } else {
370                             shouldMerge = false;
371                         }
372                     } else if (freq.isDaily()) {
373                         if (!daily.containsKey(desc)) {
374                             daily.put(desc, new HashSet&lt;Integer&gt;());
375                         }
376                         var hour = now.getHour();
</pre>
<hr />
<pre>
409                         }
410                     } else if (freq.isYearly()) {
411                         if (!yearly.containsKey(desc)) {
412                             yearly.put(desc, new HashSet&lt;Integer&gt;());
413                         }
414                         var month = now.getMonth();
415                         var day = now.getDayOfMonth();
416                         var hour = now.getHour();
417                         var year = now.getYear();
418                         if (freq.month().equals(month) &amp;&amp;
419                             freq.day() == day &amp;&amp;
420                             freq.hour() == hour &amp;&amp;
421                             !yearly.get(desc).contains(year)) {
422                             yearly.get(desc).add(year);
423                         } else {
424                             shouldMerge = false;
425                         }
426                     }
427                 }
428 
<span class="line-modified">429                 if (spec.dependencies().stream().anyMatch(unmerged::contains)) {</span>
<span class="line-modified">430                     var failed = spec.dependencies()</span>
<span class="line-modified">431                                      .stream()</span>
<span class="line-modified">432                                      .filter(unmerged::contains)</span>
<span class="line-modified">433                                      .collect(Collectors.toList());</span>
<span class="line-modified">434                     log.info(&quot;Will not merge because the following dependencies did not merge successfully: &quot; +</span>
<span class="line-modified">435                              String.join(&quot;, &quot;, failed));</span>
<span class="line-modified">436                     shouldMerge = false;</span>





















437                 }
438 
439                 if (!shouldMerge) {
440                     log.info(&quot;Will not merge &quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name() + &quot; to &quot; + toBranch.name());
441                     if (spec.name().isPresent()) {
442                         unmerged.add(spec.name().get());
443                     }
444                     continue;
445                 }
446 
447                 // Checkout the branch to merge into
448                 repo.checkout(toBranch, false);
449                 var remoteBranch = new Branch(repo.upstreamFor(toBranch).orElseThrow(() -&gt;
450                     new IllegalStateException(&quot;Could not get remote branch name for &quot; + toBranch.name())
451                 ));
452                 repo.merge(remoteBranch); // should always be a fast-forward merge
453 
454                 log.info(&quot;Trying to merge &quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name() + &quot; to &quot; + toBranch.name());
455                 log.info(&quot;Fetching &quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name());
456                 var fetchHead = repo.fetch(fromRepo.url(), fromBranch.name(), false);
</pre>
</td>
<td>
<hr />
<pre>
174 
175             int day() {
176                 return day;
177             }
178 
179             int hour() {
180                 return hour;
181             }
182 
183             int minute() {
184                 return minute;
185             }
186         }
187 
188         private final HostedRepository fromRepo;
189         private final Branch fromBranch;
190         private final Branch toBranch;
191         private final Frequency frequency;
192         private final String name;
193         private final List&lt;String&gt; dependencies;
<span class="line-added">194         private final List&lt;HostedRepository&gt; prerequisites;</span>
195 
196         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch) {
<span class="line-modified">197             this(fromRepo, fromBranch, toBranch, null, null, List.of(), List.of());</span>
198         }
199 
200         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch, String name) {
<span class="line-modified">201             this(fromRepo, fromBranch, toBranch, null, name, List.of(), List.of());</span>




202         }
203 
204         Spec(HostedRepository fromRepo, Branch fromBranch, Branch toBranch, Frequency frequency) {
<span class="line-modified">205             this(fromRepo, fromBranch, toBranch, frequency, null, List.of(), List.of());</span>




206         }
207 
<span class="line-modified">208         Spec(HostedRepository fromRepo,</span>
<span class="line-added">209              Branch fromBranch,</span>
<span class="line-added">210              Branch toBranch,</span>
<span class="line-added">211              Frequency frequency,</span>
<span class="line-added">212              String name,</span>
<span class="line-added">213              List&lt;String&gt; dependencies,</span>
<span class="line-added">214              List&lt;HostedRepository&gt; prerequisites) {</span>
215             this.fromRepo = fromRepo;
216             this.fromBranch = fromBranch;
217             this.toBranch = toBranch;
218             this.frequency = frequency;
219             this.name = name;
220             this.dependencies = dependencies;
<span class="line-added">221             this.prerequisites = prerequisites;</span>
222         }
223 
224         HostedRepository fromRepo() {
225             return fromRepo;
226         }
227 
228         Branch fromBranch() {
229             return fromBranch;
230         }
231 
232         Branch toBranch() {
233             return toBranch;
234         }
235 
236         Optional&lt;Frequency&gt; frequency() {
237             return Optional.ofNullable(frequency);
238         }
239 
240         Optional&lt;String&gt; name() {
241             return Optional.ofNullable(name);
242         }
243 
244         List&lt;String&gt; dependencies() {
245             return dependencies;
246         }
<span class="line-added">247 </span>
<span class="line-added">248         List&lt;HostedRepository&gt; prerequisites() {</span>
<span class="line-added">249             return prerequisites;</span>
<span class="line-added">250         }</span>
251     }
252 
253     private static void deleteDirectory(Path dir) throws IOException {
254         Files.walk(dir)
255              .map(Path::toFile)
256              .sorted(Comparator.reverseOrder())
257              .forEach(File::delete);
258     }
259 
260     private Repository cloneAndSyncFork(Path to) throws IOException {
261         var repo = pool.materialize(fork, to);
262 
263         // Sync personal fork
264         var remoteBranches = repo.remoteBranches(target.url().toString());
265         for (var branch : remoteBranches) {
266             var fetchHead = repo.fetch(target.url(), branch.hash().hex(), false);
267             repo.push(fetchHead, fork.url(), branch.name());
268         }
269 
270         // Must fetch once to update refs/heads
</pre>
<hr />
<pre>
290             var dir = storage.resolve(sanitizedUrl);
291 
292             var repo = cloneAndSyncFork(dir);
293 
294             var prTarget = fork.forge().repository(target.name()).orElseThrow(() -&gt;
295                     new IllegalStateException(&quot;Can&#39;t get well-known repository &quot; + target.name())
296             );
297             var prs = prTarget.pullRequests();
298             var currentUser = prTarget.forge().currentUser();
299 
300             var unmerged = new HashSet&lt;String&gt;();
301             for (var spec : specs) {
302                 var toBranch = spec.toBranch();
303                 var fromRepo = spec.fromRepo();
304                 var fromBranch = spec.fromBranch();
305 
306                 var targetName = Path.of(target.name()).getFileName();
307                 var fromName = Path.of(fromRepo.name()).getFileName();
308                 var fromDesc = targetName.equals(fromName) ? fromBranch.name() : fromName + &quot;:&quot; + fromBranch.name();
309 

310                 var shouldMerge = true;
<span class="line-added">311 </span>
<span class="line-added">312                 // Check if merge conflict pull request is present</span>
313                 var title = &quot;Merge &quot; + fromDesc;
314                 var marker = &quot;&lt;!-- AUTOMATIC MERGE PR --&gt;&quot;;
315                 for (var pr : prs) {
316                     if (pr.title().equals(title) &amp;&amp;
317                         pr.targetRef().equals(toBranch.name()) &amp;&amp;
318                         pr.body().startsWith(marker) &amp;&amp;
319                         currentUser.equals(pr.author())) {
320                         // Yes, this could be optimized do a merge &quot;this turn&quot;, but it is much simpler
321                         // to just wait until the next time the bot runs
322                         shouldMerge = false;
323 
324                         if (pr.labels().contains(&quot;ready&quot;) &amp;&amp; !pr.labels().contains(&quot;sponsor&quot;)) {
325                             var comments = pr.comments();
326                             var integrateComments =
327                                 comments.stream()
328                                         .filter(c -&gt; c.author().equals(currentUser))
329                                         .filter(c -&gt; c.body().equals(&quot;/integrate&quot;))
330                                         .collect(Collectors.toList());
331                             if (integrateComments.isEmpty()) {
332                                 pr.addComment(&quot;/integrate&quot;);
</pre>
<hr />
<pre>
342                                 if (replies.isEmpty()) {
343                                     // No reply yet, just wait
344                                 } else {
345                                     // Got a reply and the &quot;sponsor&quot; label is not present, check for error
346                                     // and if we should add the `/integrate` command again
347                                     var lastReply = replies.get(replies.size() - 1);
348                                     var lines = lastReply.body().split(&quot;\n&quot;);
349                                     var errorPrefix = &quot;@openjdk-bot Your merge request cannot be fulfilled at this time&quot;;
350                                     if (lines.length &gt; 1 &amp;&amp; lines[1].startsWith(errorPrefix)) {
351                                         // Try again
352                                         pr.addComment(&quot;/integrate&quot;);
353                                     }
354                                     // Other reply, potentially due to rebase issue, just
355                                     // wait for the labeler to add appropriate labels.
356                                 }
357                             }
358                         }
359                     }
360                 }
361 
<span class="line-added">362                 // Check if merge should happen at this time</span>
363                 if (spec.frequency().isPresent()) {
364                     var now = clock.now();
365                     var desc = toBranch.name() + &quot;-&gt;&quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name();
366                     var freq = spec.frequency().get();
367                     if (freq.isHourly()) {
368                         if (!hourly.containsKey(desc)) {
369                             hourly.put(desc, new HashSet&lt;Integer&gt;());
370                         }
371                         var minute = now.getMinute();
372                         var hour = now.getHour();
373                         if (freq.minute() == minute &amp;&amp; !hourly.get(desc).contains(hour)) {
374                             hourly.get(desc).add(hour);
375                         } else {
376                             shouldMerge = false;
377                         }
378                     } else if (freq.isDaily()) {
379                         if (!daily.containsKey(desc)) {
380                             daily.put(desc, new HashSet&lt;Integer&gt;());
381                         }
382                         var hour = now.getHour();
</pre>
<hr />
<pre>
415                         }
416                     } else if (freq.isYearly()) {
417                         if (!yearly.containsKey(desc)) {
418                             yearly.put(desc, new HashSet&lt;Integer&gt;());
419                         }
420                         var month = now.getMonth();
421                         var day = now.getDayOfMonth();
422                         var hour = now.getHour();
423                         var year = now.getYear();
424                         if (freq.month().equals(month) &amp;&amp;
425                             freq.day() == day &amp;&amp;
426                             freq.hour() == hour &amp;&amp;
427                             !yearly.get(desc).contains(year)) {
428                             yearly.get(desc).add(year);
429                         } else {
430                             shouldMerge = false;
431                         }
432                     }
433                 }
434 
<span class="line-modified">435                 // Check if any prerequisite repository has a conflict pull request open</span>
<span class="line-modified">436                 if (shouldMerge) {</span>
<span class="line-modified">437                     for (var prereq : spec.prerequisites()) {</span>
<span class="line-modified">438                         var openMergeConflictPRs = prereq.pullRequests()</span>
<span class="line-modified">439                                                          .stream()</span>
<span class="line-modified">440                                                          .filter(pr -&gt; pr.title().startsWith(&quot;Merge &quot;))</span>
<span class="line-modified">441                                                          .filter(pr -&gt; pr.body().startsWith(marker))</span>
<span class="line-modified">442                                                          .map(PullRequest::id)</span>
<span class="line-added">443                                                          .collect(Collectors.toList());</span>
<span class="line-added">444                         if (!openMergeConflictPRs.isEmpty()) {</span>
<span class="line-added">445                             log.info(&quot;Will not merge because the prerequisite &quot; + prereq.name() +</span>
<span class="line-added">446                                      &quot; has open merge conflicts PRs: &quot; +</span>
<span class="line-added">447                                      String.join(&quot;, &quot;, openMergeConflictPRs));</span>
<span class="line-added">448                             shouldMerge = false;</span>
<span class="line-added">449                         }</span>
<span class="line-added">450                     }</span>
<span class="line-added">451                 }</span>
<span class="line-added">452 </span>
<span class="line-added">453                 // Check if any dependencies failed</span>
<span class="line-added">454                 if (shouldMerge) {</span>
<span class="line-added">455                     if (spec.dependencies().stream().anyMatch(unmerged::contains)) {</span>
<span class="line-added">456                         var failed = spec.dependencies()</span>
<span class="line-added">457                                          .stream()</span>
<span class="line-added">458                                          .filter(unmerged::contains)</span>
<span class="line-added">459                                          .collect(Collectors.toList());</span>
<span class="line-added">460                         log.info(&quot;Will not merge because the following dependencies did not merge successfully: &quot; +</span>
<span class="line-added">461                                  String.join(&quot;, &quot;, failed));</span>
<span class="line-added">462                         shouldMerge = false;</span>
<span class="line-added">463                     }</span>
464                 }
465 
466                 if (!shouldMerge) {
467                     log.info(&quot;Will not merge &quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name() + &quot; to &quot; + toBranch.name());
468                     if (spec.name().isPresent()) {
469                         unmerged.add(spec.name().get());
470                     }
471                     continue;
472                 }
473 
474                 // Checkout the branch to merge into
475                 repo.checkout(toBranch, false);
476                 var remoteBranch = new Branch(repo.upstreamFor(toBranch).orElseThrow(() -&gt;
477                     new IllegalStateException(&quot;Could not get remote branch name for &quot; + toBranch.name())
478                 ));
479                 repo.merge(remoteBranch); // should always be a fast-forward merge
480 
481                 log.info(&quot;Trying to merge &quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name() + &quot; to &quot; + toBranch.name());
482                 log.info(&quot;Fetching &quot; + fromRepo.name() + &quot;:&quot; + fromBranch.name());
483                 var fetchHead = repo.fetch(fromRepo.url(), fromBranch.name(), false);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MergeBotFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
@@ -16,17 +16,14 @@
 import java.util.stream.Collectors;
 
 class ArchiveMessages {
     private static final Pattern commentPattern = Pattern.compile("<!--.*?-->",
                                                                   Pattern.DOTALL | Pattern.MULTILINE);
-    private static final Pattern cutoffPattern = Pattern.compile("(.*?)<!-- Anything below this marker will be .*? -->",
-                                                                 Pattern.DOTALL | Pattern.MULTILINE);
+
     private static String filterComments(String body) {
-        var cutoffMatcher = cutoffPattern.matcher(body);
-        if (cutoffMatcher.find()) {
-            body = cutoffMatcher.group(1);
-        }
+        var parsedBody = PullRequestBody.parse(body);
+        body = parsedBody.bodyText();
 
         var commentMatcher = commentPattern.matcher(body);
         body = commentMatcher.replaceAll("");
 
         body = MarkdownToText.removeFormatting(body);
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java
@@ -55,11 +55,11 @@
                       "the CSR request is approved.");
     }
 
     @Override
     public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!ProjectPermissions.mayReview(censusInstance, comment.author())) {
+        if (!censusInstance.isReviewer(comment.author())) {
             reply.println("only [Reviewers](https://openjdk.java.net/bylaws#reviewer) are allowed require a CSR.");
             return;
         }
 
         var labels = pr.labels();
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CensusInstance.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CensusInstance.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CensusInstance.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CensusInstance.java
@@ -22,12 +22,13 @@
  */
 package org.openjdk.skara.bots.pr;
 
 import org.openjdk.skara.census.*;
 import org.openjdk.skara.forge.*;
+import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.jcheck.JCheckConfiguration;
-import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.Repository;
 
 import java.io.*;
 import java.net.URLEncoder;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
@@ -117,6 +118,38 @@
     }
 
     Namespace namespace() {
         return namespace;
     }
+
+    Optional<Contributor> contributor(HostUser hostUser) {
+        var contributor = namespace.get(hostUser.id());
+        return Optional.ofNullable(contributor);
+    }
+
+    boolean isAuthor(HostUser hostUser) {
+        int version = census.version().format();
+        var contributor = namespace.get(hostUser.id());
+        if (contributor == null) {
+            return false;
+        }
+        return project.isAuthor(contributor.username(), version);
+    }
+
+    boolean isCommitter(HostUser hostUser) {
+        int version = census.version().format();
+        var contributor = namespace.get(hostUser.id());
+        if (contributor == null) {
+            return false;
+        }
+        return project.isCommitter(contributor.username(), version);
+    }
+
+    boolean isReviewer(HostUser hostUser) {
+        int version = census.version().format();
+        var contributor = namespace.get(hostUser.id());
+        if (contributor == null) {
+            return false;
+        }
+        return project.isReviewer(contributor.username(), version);
+    }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -584,11 +584,11 @@
             message.append("`/integrate ");
             message.append(pr.targetHash());
             message.append("`.\n");
         }
 
-        if (!ProjectPermissions.mayCommit(censusInstance, pr.author())) {
+        if (!censusInstance.isCommitter(pr.author())) {
             message.append("\n");
             var contributor = censusInstance.namespace().get(pr.author().id());
             if (contributor == null) {
                 message.append("As you are not a known OpenJDK [Author](https://openjdk.java.net/bylaws#author), ");
             } else {
@@ -596,11 +596,11 @@
             }
 
             message.append("an existing [Committer](https://openjdk.java.net/bylaws#committer) must agree to ");
             message.append("[sponsor](https://openjdk.java.net/sponsor/) your change. ");
             var candidates = reviews.stream()
-                                    .filter(review -> ProjectPermissions.mayCommit(censusInstance, review.reviewer()))
+                                    .filter(review -> censusInstance.isCommitter(review.reviewer()))
                                     .map(review -> "@" + review.reviewer().userName())
                                     .collect(Collectors.joining(", "));
             if (candidates.length() > 0) {
                 message.append("Possible candidates are the reviewers of this PR (");
                 message.append(candidates);
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
@@ -58,11 +58,11 @@
             reply.print("Only the author (@" + pr.author().userName() + ") is allowed to issue the `integrate` command.");
 
             // If the command author is allowed to sponsor this change, suggest that command
             var readyHash = ReadyForSponsorTracker.latestReadyForSponsor(pr.repository().forge().currentUser(), allComments);
             if (readyHash.isPresent()) {
-                if (ProjectPermissions.mayCommit(censusInstance, comment.author())) {
+                if (censusInstance.isCommitter(comment.author())) {
                     reply.print(" As this PR is ready to be sponsored, and you are an eligible sponsor, did you mean to issue the `/sponsor` command?");
                     return;
                 }
             }
             reply.println();
@@ -124,11 +124,11 @@
                       .forEach(reply::println);
                 return;
             }
 
             // Finally check if the author is allowed to perform the actual push
-            if (!ProjectPermissions.mayCommit(censusInstance, pr.author())) {
+            if (!censusInstance.isCommitter(pr.author())) {
                 reply.println(ReadyForSponsorTracker.addIntegrationMarker(pr.headHash()));
                 reply.println("Your change (at version " + pr.headHash() + ") is now ready to be sponsored by a Committer.");
                 if (!args.isBlank()) {
                     reply.println("Note that your sponsor will make the final decision onto which target hash to integrate.");
                 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
@@ -20,12 +20,14 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.bots.pr;
 
-import org.openjdk.skara.forge.PullRequest;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.issuetracker.Comment;
+import org.openjdk.skara.json.*;
 import org.openjdk.skara.vcs.openjdk.Issue;
 
 import java.io.PrintWriter;
 import java.nio.file.Path;
 import java.util.*;
@@ -52,23 +54,30 @@
 
 public class IssueCommand implements CommandHandler {
     private final String name;
 
     private void showHelp(PrintWriter reply) {
-        reply.println("Command syntax: `/" + name + " [add|remove] <id>[,<id>,...]` or `/issue [add] <id>: <description>`. For example:");
+        reply.println("Command syntax:");
+        reply.println(" * `/" + name + " [add|remove] <id>[,<id>,...]`");
+        reply.println(" * `/" + name + " [add] <id>: <description>`");
+        reply.println(" * `/" + name + " create [PX] <component>/[subcomponent]");
+        reply.println();
+        reply.println("Some examples:");
         reply.println();
         reply.println(" * `/" + name + " add JDK-1234567,4567890`");
         reply.println(" * `/" + name + " remove JDK-4567890`");
         reply.println(" * `/" + name + " 1234567: Use this exact title`");
+        reply.println(" * `/" + name + " create hotspot/jfr");
+        reply.println(" * `/" + name + " create P4 core-libs/java.nio");
         reply.println();
         reply.print("If issues are specified only by their ID, the title will be automatically retrieved from JBS. ");
         reply.print("The project prefix (`JDK-` in the above examples) is optional. ");
         reply.println("Separate multiple issue IDs using either spaces or commas.");
     }
 
     private static final Pattern shortIssuePattern = Pattern.compile("((?:[A-Za-z]+-)?[0-9]+)(?:,| |$)");
-    private final static Pattern subCommandPattern = Pattern.compile("^(add|remove|delete|(?:[A-Za-z]+-)?[0-9]+:?)[ ,]?.*$");
+    private final static Pattern subCommandPattern = Pattern.compile("^(add|remove|delete|create|(?:[A-Za-z]+-)?[0-9]+:?)[ ,]?.*$");
 
     private List<Issue> parseIssueList(String allowedPrefix, String issueList) throws InvalidIssue {
         List<Issue> ret;
         // Is this a single fully described issue?
         var singleIssue = Issue.fromString(issueList);
@@ -96,10 +105,174 @@
 
     IssueCommand() {
         this("issue");
     }
 
+    private void addIssue(PullRequestBot bot, PullRequest pr, String args, Set<String> currentSolved, PrintWriter reply) throws InvalidIssue {
+        if (args.startsWith("add")) {
+            var issueListStart = args.indexOf(' ');
+            if (issueListStart == -1) {
+                showHelp(reply);
+                return;
+            }
+            args = args.substring(issueListStart);
+        }
+        var issues = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args);
+        if (issues.size() == 0) {
+            showHelp(reply);
+            return;
+        }
+        var validatedIssues = new ArrayList<Issue>();
+        for (var issue : issues) {
+            try {
+                if (bot.issueProject() == null) {
+                    if (issue.description() == null) {
+                        reply.print("This repository does not have an issue project configured - you will need to input the issue title manually ");
+                        reply.println("using the syntax `/" + name + " " + issue.shortId() + ": title of the issue`.");
+                        return;
+                    } else {
+                        validatedIssues.add(issue);
+                        continue;
+                    }
+                }
+                var validatedIssue = bot.issueProject().issue(issue.shortId());
+                if (validatedIssue.isEmpty()) {
+                    reply.println("The issue `" + issue.shortId() + "` was not found in the `" + bot.issueProject().name() + "` project - make sure you have entered it correctly.");
+                    continue;
+                }
+                if (validatedIssue.get().state() != org.openjdk.skara.issuetracker.Issue.State.OPEN) {
+                    reply.println("The issue [" + validatedIssue.get().id() + "](" + validatedIssue.get().webUrl() + ") isn't open - make sure you have selected the correct issue.");
+                    continue;
+                }
+                if (issue.description() == null) {
+                    validatedIssues.add(new Issue(validatedIssue.get().id(), validatedIssue.get().title()));
+                } else {
+                    validatedIssues.add(new Issue(validatedIssue.get().id(), issue.description()));
+                }
+
+            } catch (RuntimeException e) {
+                if (issue.description() == null) {
+                    reply.print("Temporary failure when trying to look up issue `" + issue.shortId() + "` - you will need to input the issue title manually ");
+                    reply.println("using the syntax `/" + name + " " + issue.shortId() + ": title of the issue`.");
+                    return;
+                } else {
+                    validatedIssues.add(issue);
+                }
+            }
+        }
+        if (validatedIssues.size() != issues.size()) {
+            reply.println("As there were validation problems, no additional issues will be added to the list of solved issues.");
+            return;
+        }
+
+        var titleIssue = Issue.fromStringRelaxed(pr.title());
+        for (var issue : validatedIssues) {
+            if (titleIssue.isEmpty()) {
+                reply.print("The primary solved issue for a PR is set through the PR title. Since the current title does ");
+                reply.println("not contain an issue reference, it will now be updated.");
+                pr.setTitle(issue.toShortString());
+                titleIssue = Optional.of(issue);
+                continue;
+            }
+            if (titleIssue.get().shortId().equals(issue.shortId())) {
+                reply.println("This issue is referenced in the PR title - it will now be updated.");
+                pr.setTitle(issue.toShortString());
+                continue;
+            }
+            reply.println(SolvesTracker.setSolvesMarker(issue));
+            if (currentSolved.contains(issue.shortId())) {
+                reply.println("Updating description of additional solved issue: `" + issue.toShortString() + "`.");
+            } else {
+                reply.println("Adding additional issue to " + name + " list: `" + issue.toShortString() + "`.");
+            }
+        }
+    }
+
+    private void removeIssue(PullRequestBot bot, String args, Set<String> currentSolved, PrintWriter reply) throws InvalidIssue {
+        var issueListStart = args.indexOf(' ');
+        if (issueListStart == -1) {
+            showHelp(reply);
+            return;
+        }
+        if (currentSolved.isEmpty()) {
+            reply.println("This PR does not contain any additional solved issues that can be removed. To remove the primary solved issue, simply edit the title of this PR.");
+            return;
+        }
+        var issuesToRemove = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args.substring(issueListStart));
+        for (var issue : issuesToRemove) {
+            if (currentSolved.contains(issue.shortId())) {
+                reply.println(SolvesTracker.removeSolvesMarker(issue));
+                reply.println("Removing additional issue from " + name + " list: `" + issue.shortId() + "`.");
+            } else {
+                reply.print("The issue `" + issue.shortId() + "` was not found in the list of additional solved issues. The list currently contains these issues: ");
+                var currentList = currentSolved.stream()
+                                               .map(id -> "`" + id + "`")
+                                               .collect(Collectors.joining(", "));
+                reply.println(currentList);
+            }
+        }
+    }
+
+    private void createIssue(PullRequestBot bot, PullRequest pr, String args, CensusInstance censusInstance, HostUser author, PrintWriter reply) {
+        if (!censusInstance.isAuthor(author)) {
+            reply.println("Only [Authors](https://openjdk.java.net/bylaws#author) are allowed to create issues.");
+            return;
+        }
+
+        var currentTitleIssue = Issue.fromString(pr.title());
+        if (currentTitleIssue.isPresent()) {
+            reply.println("The PR title already references an issue (`" + currentTitleIssue.get().shortId() + "`) - will not create a new one.");
+            return;
+        }
+
+        var argSplit = new LinkedList<>(Arrays.asList(args.split("(?:\\s+|/)")));
+        argSplit.pollFirst();
+
+        String priority = null;
+        String subComponent = null;
+
+        // First argument can be a priority
+        var next = argSplit.pollFirst();
+        if (next != null && next.matches("^[pP]\\d$")) {
+            priority = next.substring(1);
+            next = argSplit.pollFirst();
+        }
+
+        // Next argument is the mandatory component name
+        if (next == null) {
+            showHelp(reply);
+            return;
+        }
+        var component = next;
+        next = argSplit.pollFirst();
+
+        // Finally there can be a subcomponent present
+        if (next != null) {
+            subComponent = next;
+        }
+
+        var properties = new HashMap<String, JSONValue>();
+        properties.put("components", JSON.array().add(JSON.of(component)));
+        if (subComponent != null) {
+            properties.put("customfield_10008", JSON.of(subComponent));
+        }
+        if (priority != null) {
+            properties.put("priority", JSON.of(priority));
+        }
+        properties.put("issuetype", JSON.of("enhancement"));
+
+        var bodyText = PullRequestBody.parse(pr).bodyText();
+        try {
+            var issue = bot.issueProject().createIssue(pr.title(), bodyText.lines().collect(Collectors.toList()), properties);
+            reply.println("The issue `" + issue.id() + "` was successfully created - the title of this PR will be updated to reference it. ");
+            var shortId = issue.id().contains("-") ? issue.id().split("-", 2)[1] : issue.id();
+            pr.setTitle(shortId + ": " + issue.title());
+        } catch (RuntimeException e) {
+            reply.println("An error occurred when attempting to create an issue: " + e.getMessage());
+        }
+    }
+
     @Override
     public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
         if (!comment.author().equals(pr.author())) {
             reply.println("Only the author (@" + pr.author().userName() + ") is allowed to issue the `/" + name + "` command.");
             return;
@@ -118,112 +291,16 @@
                                          .stream()
                                          .map(Issue::shortId)
                                          .collect(Collectors.toSet());
         try {
             if (args.startsWith("remove") || args.startsWith("delete")) {
-                var issueListStart = args.indexOf(' ');
-                if (issueListStart == -1) {
-                    showHelp(reply);
-                    return;
-                }
-                if (currentSolved.isEmpty()) {
-                    reply.println("This PR does not contain any additional solved issues that can be removed. To remove the primary solved issue, simply edit the title of this PR.");
-                    return;
-                }
-                var issuesToRemove = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args.substring(issueListStart));
-                for (var issue : issuesToRemove) {
-                    if (currentSolved.contains(issue.shortId())) {
-                        reply.println(SolvesTracker.removeSolvesMarker(issue));
-                        reply.println("Removing additional issue from " + name + " list: `" + issue.shortId() + "`.");
-                    } else {
-                        reply.print("The issue `" + issue.shortId() + "` was not found in the list of additional solved issues. The list currently contains these issues: ");
-                        var currentList = currentSolved.stream()
-                                                       .map(id -> "`" + id + "`")
-                                                       .collect(Collectors.joining(", "));
-                        reply.println(currentList);
-                    }
-                }
+                removeIssue(bot, args, currentSolved, reply);
+            } else if (args.startsWith("create")) {
+                createIssue(bot, pr, args, censusInstance, comment.author(), reply);
             } else {
-                if (args.startsWith("add")) {
-                    var issueListStart = args.indexOf(' ');
-                    if (issueListStart == -1) {
-                        showHelp(reply);
-                        return;
-                    }
-                    args = args.substring(issueListStart);
-                }
-                var issues = parseIssueList(bot.issueProject() == null ? "" : bot.issueProject().name(), args);
-                if (issues.size() == 0) {
-                    showHelp(reply);
-                    return;
-                }
-                var validatedIssues = new ArrayList<Issue>();
-                for (var issue : issues) {
-                    try {
-                        if (bot.issueProject() == null) {
-                            if (issue.description() == null) {
-                                reply.print("This repository does not have an issue project configured - you will need to input the issue title manually ");
-                                reply.println("using the syntax `/" + name + " " + issue.shortId() + ": title of the issue`.");
-                                return;
-                            } else {
-                                validatedIssues.add(issue);
-                                continue;
-                            }
-                        }
-                        var validatedIssue = bot.issueProject().issue(issue.shortId());
-                        if (validatedIssue.isEmpty()) {
-                            reply.println("The issue `" + issue.shortId() + "` was not found in the `" + bot.issueProject().name() + "` project - make sure you have entered it correctly.");
-                            continue;
-                        }
-                        if (validatedIssue.get().state() != org.openjdk.skara.issuetracker.Issue.State.OPEN) {
-                            reply.println("The issue [" + validatedIssue.get().id() + "](" + validatedIssue.get().webUrl() + ") isn't open - make sure you have selected the correct issue.");
-                            continue;
-                        }
-                        if (issue.description() == null) {
-                            validatedIssues.add(new Issue(validatedIssue.get().id(), validatedIssue.get().title()));
-                        } else {
-                            validatedIssues.add(new Issue(validatedIssue.get().id(), issue.description()));
-                        }
-
-                    } catch (RuntimeException e) {
-                        if (issue.description() == null) {
-                            reply.print("Temporary failure when trying to look up issue `" + issue.shortId() + "` - you will need to input the issue title manually ");
-                            reply.println("using the syntax `/" + name + " " + issue.shortId() + ": title of the issue`.");
-                            return;
-                        } else {
-                            validatedIssues.add(issue);
-                        }
-                    }
-                }
-                if (validatedIssues.size() != issues.size()) {
-                    reply.println("As there were validation problems, no additional issues will be added to the list of solved issues.");
-                    return;
-                }
-
-                var titleIssue = Issue.fromStringRelaxed(pr.title());
-                for (var issue : validatedIssues) {
-                    if (titleIssue.isEmpty()) {
-                        reply.print("The primary solved issue for a PR is set through the PR title. Since the current title does ");
-                        reply.println("not contain an issue reference, it will now be updated.");
-                        pr.setTitle(issue.toShortString());
-                        titleIssue = Optional.of(issue);
-                        continue;
-                    }
-                    if (titleIssue.get().shortId().equals(issue.shortId())) {
-                        reply.println("This issue is referenced in the PR title - it will now be updated.");
-                        pr.setTitle(issue.toShortString());
-                        continue;
-                    }
-                    reply.println(SolvesTracker.setSolvesMarker(issue));
-                    if (currentSolved.contains(issue.shortId())) {
-                        reply.println("Updating description of additional solved issue: `" + issue.toShortString() + "`.");
-                    } else {
-                        reply.println("Adding additional issue to " + name + " list: `" + issue.toShortString() + "`.");
-                    }
-                }
+                addIssue(bot, pr, args, currentSolved, reply);
             }
-
         } catch (InvalidIssue invalidIssue) {
             reply.println("The issue identifier `" + invalidIssue.identifier() + "` is invalid: " + invalidIssue.reason() + ".");
         }
     }
 
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java
@@ -58,11 +58,11 @@
         return bot.labelConfiguration().fromChanges(files);
     }
 
     @Override
     public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author()) && (!ProjectPermissions.mayCommit(censusInstance, comment.author()))) {
+        if (!comment.author().equals(pr.author()) && (!censusInstance.isCommitter(comment.author()))) {
             reply.println("Only the PR author and project [Committers](https://openjdk.java.net/bylaws#committer) are allowed to modify labels on a PR.");
             return;
         }
 
         var argumentMatcher = argumentPattern.matcher(args);
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ProjectPermissions.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ProjectPermissions.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ProjectPermissions.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.pr;
-
-import org.openjdk.skara.host.HostUser;
-
-class ProjectPermissions {
-    static boolean mayCommit(CensusInstance censusInstance, HostUser user) {
-        var census = censusInstance.census();
-        var project = censusInstance.project();
-        var namespace = censusInstance.namespace();
-        int version = census.version().format();
-
-        var contributor = namespace.get(user.id());
-        if (contributor == null) {
-            return false;
-        }
-        return project.isCommitter(contributor.username(), version) ||
-                project.isReviewer(contributor.username(), version) ||
-                project.isLead(contributor.username(), version);
-    }
-
-    static boolean mayReview(CensusInstance censusInstance, HostUser user) {
-        var census = censusInstance.census();
-        var project = censusInstance.project();
-        var namespace = censusInstance.namespace();
-        int version = census.version().format();
-
-        var contributor = namespace.get(user.id());
-        if (contributor == null) {
-            return false;
-        }
-        return project.isReviewer(contributor.username(), version) ||
-                project.isLead(contributor.username(), version);
-    }
-}
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java
@@ -34,11 +34,11 @@
     public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
         if (pr.author().equals(comment.author())) {
             reply.println("You can't reject your own changes.");
             return;
         }
-        if (!ProjectPermissions.mayReview(censusInstance, comment.author())) {
+        if (!censusInstance.isReviewer(comment.author())) {
             reply.println("Only [Reviewers](https://openjdk.java.net/bylaws#reviewer) are allowed to reject changes.");
             return;
         }
 
         var botUser = pr.repository().forge().currentUser();
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java
@@ -47,11 +47,11 @@
                               "If role is set, the reviewers need to have that project role. If omitted, role defaults to `authors`.");
     }
 
     @Override
     public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!ProjectPermissions.mayReview(censusInstance, comment.author())) {
+        if (!censusInstance.isReviewer(comment.author())) {
             reply.println("Only [Reviewers](https://openjdk.java.net/bylaws#reviewer) are allowed to change the number of required reviewers.");
             return;
         }
 
         var splitArgs = args.split(" ");
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
@@ -34,15 +34,15 @@
 public class SponsorCommand implements CommandHandler {
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
 
     @Override
     public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (ProjectPermissions.mayCommit(censusInstance, pr.author())) {
+        if (censusInstance.isCommitter(pr.author())) {
             reply.println("This change does not need sponsoring - the author is allowed to integrate it.");
             return;
         }
-        if (!ProjectPermissions.mayCommit(censusInstance, comment.author())) {
+        if (!censusInstance.isReviewer(comment.author())) {
             reply.println("Only [Committers](https://openjdk.java.net/bylaws#committer) are allowed to sponsor changes.");
             return;
         }
 
         var readyHash = ReadyForSponsorTracker.latestReadyForSponsor(pr.repository().forge().currentUser(), allComments);
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IssueTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IssueTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IssueTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IssueTests.java
@@ -20,19 +20,19 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.bots.pr;
 
-import org.openjdk.skara.forge.Review;
-import org.openjdk.skara.issuetracker.Comment;
+import org.junit.jupiter.api.*;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.issuetracker.*;
 import org.openjdk.skara.test.*;
 import org.openjdk.skara.vcs.Repository;
 
-import org.junit.jupiter.api.*;
-
 import java.io.IOException;
 import java.util.*;
+import java.util.regex.Pattern;
 
 import static org.junit.jupiter.api.Assertions.*;
 import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;
 
 class IssueTests {
@@ -63,18 +63,20 @@
             // No arguments
             pr.addComment("/issue");
             TestBotRunner.runPeriodicItems(prBot);
 
             // The bot should reply with a help message
-            assertLastCommentContains(pr,"Command syntax: `/issue");
+            assertLastCommentContains(pr,"Command syntax:");
+            assertLastCommentContains(pr,  "`/issue");
 
             // Check that the alias works as well
             pr.addComment("/solves");
             TestBotRunner.runPeriodicItems(prBot);
 
             // The bot should reply with a help message
-            assertLastCommentContains(pr,"Command syntax: `/solves");
+            assertLastCommentContains(pr,"Command syntax:");
+            assertLastCommentContains(pr,  "`/solves");
 
             // Invalid syntax
             pr.addComment("/issue something I guess");
             TestBotRunner.runPeriodicItems(prBot);
 
@@ -381,10 +383,123 @@
             assertFalse(pr.body().contains("## Issue\n"));
             assertTrue(pr.body().contains("## Issues\n"));
         }
     }
 
+    private static final Pattern addedIssuePattern = Pattern.compile("`(.*)` was successfully created", Pattern.MULTILINE);
+
+    private static Issue issueFromLastComment(PullRequest pr, IssueProject issueProject) {
+        var comments = pr.comments();
+        var lastComment = comments.get(comments.size() - 1);
+        var addedIssueMatcher = addedIssuePattern.matcher(lastComment.body());
+        assertTrue(addedIssueMatcher.find(), lastComment.body());
+        return issueProject.issue(addedIssueMatcher.group(1)).orElseThrow();
+    }
+
+    @Test
+    void createIssue(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+            var issues = credentials.getIssueProject();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).issueProject(issues).build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
+            pr.setBody("This is the body");
+
+            // Create an issue
+            pr.addComment("/issue create hotspot");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // Verify it
+            var issue = issueFromLastComment(pr, issues);
+            assertEquals("This is a pull request", issue.title());
+            assertEquals("hotspot", issue.properties().get("components").asArray().get(0).asString());
+            assertEquals("This is the body", issue.body());
+
+            var updatedPr = author.pullRequest(pr.id());
+            var issueNr = issue.id().split("-", 2)[1];
+            assertEquals(issueNr + ": This is a pull request", updatedPr.title());
+        }
+    }
+
+    @Test
+    void createIssueParameterized(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+            var issues = credentials.getIssueProject();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var prBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).issueProject(issues).build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
+
+            // Create an issue
+            pr.addComment("/issue create P2 hotspot");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // Verify it
+            var issue = issueFromLastComment(pr, issues);
+            assertEquals("This is a pull request", issue.title());
+            assertEquals("hotspot", issue.properties().get("components").asArray().get(0).asString());
+            assertEquals("2", issue.properties().get("priority").asString());
+
+            // Reset and try some more
+            pr.setTitle("This is another pull request");
+
+            // Create an issue
+            pr.addComment("/issue create P4 hotspot");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // Verify it
+            issue = issueFromLastComment(pr, issues);
+            assertEquals("This is another pull request", issue.title());
+            assertEquals("hotspot", issue.properties().get("components").asArray().get(0).asString());
+            assertEquals("4", issue.properties().get("priority").asString());
+            assertEquals("enhancement", issue.properties().get("issuetype").asString().toLowerCase());
+
+            // Reset and try some more
+            pr.setTitle("This is yet another pull request");
+
+            // Create an issue
+            pr.addComment("/issue create core-libs/java.io");
+            TestBotRunner.runPeriodicItems(prBot);
+
+            // Verify it
+            issue = issueFromLastComment(pr, issues);
+            assertEquals("This is yet another pull request", issue.title());
+            assertEquals("core-libs", issue.properties().get("components").asArray().get(0).asString());
+            assertEquals("enhancement", issue.properties().get("issuetype").asString().toLowerCase());
+            assertEquals("java.io", issue.properties().get("customfield_10008").asString());
+        }
+    }
+
     @Test
     void projectPrefix(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory()) {
             var author = credentials.getHostedRepository();
diff a/forge/src/main/java/org/openjdk/skara/forge/PullRequestBody.java b/forge/src/main/java/org/openjdk/skara/forge/PullRequestBody.java
--- a/forge/src/main/java/org/openjdk/skara/forge/PullRequestBody.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/PullRequestBody.java
@@ -21,23 +21,30 @@
  * questions.
  */
 package org.openjdk.skara.forge;
 
 import java.net.URI;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
+import java.util.*;
+import java.util.regex.Pattern;
 
 public class PullRequestBody {
+    private final String bodyText;
     private final List<URI> issues;
     private final List<String> contributors;
 
-    private PullRequestBody(List<URI> issues, List<String> contributors) {
+    private static final Pattern cutoffPattern = Pattern.compile("^<!-- Anything below this marker will be .*? -->$");
+
+    private PullRequestBody(String bodyText, List<URI> issues, List<String> contributors) {
+        this.bodyText = bodyText;
         this.issues = issues;
         this.contributors = contributors;
     }
 
+    public String bodyText() {
+        return bodyText;
+    }
+
     public List<URI> issues() {
         return issues;
     }
 
     public List<String> contributors() {
@@ -46,13 +53,19 @@
 
     public static PullRequestBody parse(PullRequest pr) {
         return parse(Arrays.asList(pr.body().split("\n")));
     }
 
+    public static PullRequestBody parse(String body) {
+        return parse(Arrays.asList(body.split("\n")));
+    }
+
     public static PullRequestBody parse(List<String> lines) {
         var issues = new ArrayList<URI>();
         var contributors = new ArrayList<String>();
+        var bodyText = new StringBuilder();
+        var inBotComment = false;
 
         var i = 0;
         while (i < lines.size()) {
             var line = lines.get(i);
             if (line.startsWith("### Issue")) {
@@ -83,10 +96,16 @@
                     i++;
                 }
             } else {
                 i++;
             }
+            if (line.startsWith("<!-- Anything below this marker will be")) {
+                inBotComment = true;
+            }
+            if (!inBotComment) {
+                bodyText.append(line).append("\n");
+            }
         }
 
-        return new PullRequestBody(issues, contributors);
+        return new PullRequestBody(bodyText.toString(), issues, contributors);
     }
 }
diff a/issuetracker/src/main/java/org/openjdk/skara/issuetracker/jira/JiraProject.java b/issuetracker/src/main/java/org/openjdk/skara/issuetracker/jira/JiraProject.java
--- a/issuetracker/src/main/java/org/openjdk/skara/issuetracker/jira/JiraProject.java
+++ b/issuetracker/src/main/java/org/openjdk/skara/issuetracker/jira/JiraProject.java
@@ -36,10 +36,11 @@
     private final String projectName;
     private final RestRequest request;
 
     private JSONObject projectMetadataCache = null;
     private List<JiraLinkType> linkTypes = null;
+    private JSONObject createMetaCache = null;
 
     private final Logger log = Logger.getLogger("org.openjdk.skara.issuetracker.jira");
 
     JiraProject(JiraHost host, RestRequest request, String projectName) {
         this.jiraHost = host;
@@ -52,26 +53,59 @@
             projectMetadataCache = request.get("project/" + projectName).execute().asObject();
         }
         return projectMetadataCache;
     }
 
+    private JSONObject createMeta() {
+        if (createMetaCache == null) {
+            createMetaCache = request.get("issue/createmeta")
+                                     .param("projectKeys", projectName)
+                                     .param("expand", "projects.issuetypes.fields")
+                                     .execute()
+                                     .asObject();
+        }
+        return createMetaCache;
+    }
+
     private Map<String, String> issueTypes() {
-        var ret = new HashMap<String, String>();
+        var ret = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);
         for (var type : project().get("issueTypes").asArray()) {
             ret.put(type.get("name").asString(), type.get("id").asString());
         }
         return ret;
     }
 
+    private String issueTypeId(String name) {
+        var ret = issueTypes().get(name);
+        if (ret == null) {
+            var allowedList = issueTypes().keySet().stream()
+                                          .map(s -> "`" + s + "`")
+                                          .collect(Collectors.joining(", "));
+            throw new RuntimeException("Unknown issue type `" + name + "`` Known issue types are " + allowedList + ".");
+        }
+        return ret;
+    }
+
     private Map<String, String> components() {
         var ret = new HashMap<String, String>();
         for (var type : project().get("components").asArray()) {
             ret.put(type.get("name").asString(), type.get("id").asString());
         }
         return ret;
     }
 
+    private String componentId(String name) {
+        var ret = components().get(name);
+        if (ret == null) {
+            var allowedList = components().keySet().stream()
+                                          .map(s -> "`" + s + "`")
+                                          .collect(Collectors.joining(", "));
+            throw new RuntimeException("Unknown component `" + name + "`. Known components are " + allowedList + ".");
+        }
+        return ret;
+    }
+
     private Map<String, String> versions() {
         var ret = new HashMap<String, String>();
         for (var type : project().get("versions").asArray()) {
             ret.put(type.get("name").asString(), type.get("id").asString());
         }
@@ -146,10 +180,11 @@
             case "versions": // fall-through
             case "components":
                 return Optional.of(new JSONArray(value.stream()
                                                       .map(obj -> obj.get("name"))
                                                       .collect(Collectors.toList())));
+            case "customfield_10008": // fall-through
             case "issuetype":
                 return Optional.of(JSON.of(value.get("name").asString()));
             case "priority":
                 return Optional.of(JSON.of(value.get("id").asString()));
             default:
@@ -170,52 +205,94 @@
                                                       .map(s -> JSON.object().put("id", versions().get(s)))
                                                       .collect(Collectors.toList())));
             case "components":
                 return Optional.of(new JSONArray(value.stream()
                                                       .map(JSONValue::asString)
-                                                      .map(s -> JSON.object().put("id", components().get(s)))
+                                                      .map(s -> JSON.object().put("id", componentId(s)))
                                                       .collect(Collectors.toList())));
             case "issuetype":
-                return Optional.of(JSON.object().put("id", issueTypes().get(value.asString())));
+                return Optional.of(JSON.object().put("id", issueTypeId(value.asString())));
             case "priority":
                 return Optional.of(JSON.object().put("id", value.asString()));
             default:
                 return Optional.of(value);
         }
     }
 
+    JSONValue encodeCustomFields(String name, JSONValue value, Map<String, JSONValue> allProperties) {
+        if (!name.startsWith("customfield_")) {
+            return value;
+        }
+
+        if (!name.equals("customfield_10008")) {
+            if (value.isObject()) {
+                if (value.asObject().contains("id")) {
+                    return value.get("id");
+                } else {
+                    return value;
+                }
+            } else {
+                return value;
+            }
+        }
+
+        var createMeta = createMeta();
+        var fields = createMeta.get("projects").stream()
+                               .filter(p -> p.contains("name"))
+                               .filter(p -> p.get("name").asString().equalsIgnoreCase(projectName))
+                               .findAny().orElseThrow()
+                               .get("issuetypes").stream()
+                               .filter(i -> i.get("id").asString().equals(allProperties.get("issuetype").get("id").asString()))
+                               .findAny().orElseThrow()
+                               .get("fields")
+                               .asObject();
+
+        var field = fields.get(name);
+        var componentIds = allProperties.get("components").stream()
+                                        .map(c -> c.get("id").asString())
+                                        .map(Integer::parseInt)
+                                        .collect(Collectors.toSet());
+        var allowed = field.get("allowedValues").stream()
+                           .filter(c -> componentIds.contains(c.get("id").asInt()))
+                           .flatMap(c -> c.get("subComponents").stream())
+                           .collect(Collectors.toMap(s -> s.get("name").asString(),
+                                                     s -> s.get("id").asInt()));
+        if (!allowed.containsKey(value.asString())) {
+            var allowedList = allowed.keySet().stream()
+                                     .map(s -> "`" + s + "`")
+                                     .collect(Collectors.joining(", "));
+            throw new RuntimeException("Unknown subcomponent `" + value.asString() + "`. Known subcomponents are " +
+                                               allowedList + ".");
+        }
+
+        return JSON.of(allowed.get(value.asString()));
+    }
+
     @Override
     public IssueTracker issueTracker() {
         return jiraHost;
     }
 
     @Override
     public URI webUrl() {
         return URIBuilder.base(jiraHost.getUri()).setPath("/projects/" + projectName).build();
     }
 
-    private boolean isInitialField(String name, JSONValue value) {
-        if (name.equals("project") || name.equals("summary") || name.equals("description") || name.equals("components")) {
-            return true;
-        }
-        return false;
-    }
-
-    // Custom fields are set a bit differently depending on their type
-    private JSONValue filterCustomFieldValue(String name, JSONValue unfiltered) {
-        if (!name.startsWith("customfield_")) {
-            return unfiltered;
-        }
-        if (unfiltered.isObject()) {
-            if (unfiltered.asObject().contains("id")) {
-                return unfiltered.get("id");
-            } else {
-                return unfiltered;
-            }
-        } else {
-            return unfiltered;
-        }
+    private boolean isInitialField(String issueType, String name, JSONValue value) {
+        var createMeta = createMeta();
+        var fields = createMeta.get("projects").stream()
+                               .filter(p -> p.contains("name"))
+                               .filter(p -> p.get("name").asString().equalsIgnoreCase(projectName))
+                               .findAny().orElseThrow()
+                               .get("issuetypes").stream()
+                               .filter(i -> i.get("id").asString().equals(issueType))
+                               .findAny().orElseThrow()
+                               .get("fields").fields().stream()
+                               .map(JSONObject.Field::name)
+                               .collect(Collectors.toSet());
+
+        return fields.contains(name);
     }
 
     @Override
     public Issue createIssue(String title, List<String> body, Map<String, JSONValue> properties) {
         var query = JSON.object();
@@ -235,33 +312,34 @@
         finalProperties.put("summary", JSON.of(title));
         finalProperties.put("description", JSON.of(String.join("\n", body)));
 
         // Provide default values for required fields if not present
         finalProperties.putIfAbsent("components", JSON.array().add(JSON.object().put("id", defaultComponent())));
+        finalProperties.putIfAbsent("issuetype", JSON.object().put("id", defaultIssueType()));
 
         // Filter out the fields that can be set at creation time
+        var issueType = finalProperties.get("issuetype").get("id").asString();
         var fields = JSON.object();
         finalProperties.entrySet().stream()
-                       .filter(entry -> isInitialField(entry.getKey(), entry.getValue()))
-                       .forEach(entry -> fields.put(entry.getKey(), entry.getValue()));
-
-        // Certain types can only be set after creation, so always start with the default value
-        fields.put("issuetype", JSON.object().put("id", defaultIssueType()));
-
+                       .filter(entry -> isInitialField(issueType, entry.getKey(), entry.getValue()))
+                       .forEach(entry -> fields.put(entry.getKey(), encodeCustomFields(entry.getKey(),
+                                                                                       entry.getValue(),
+                                                                                       finalProperties)));
         query.put("fields", fields);
         jiraHost.securityLevel().ifPresent(securityLevel -> fields.put("security", JSON.object()
                                                                                        .put("id", securityLevel)));
         var data = request.post("issue")
                           .body(query)
                           .execute();
 
         // Apply fields that have to be set later (if any)
         var editFields = JSON.object();
         finalProperties.entrySet().stream()
-                       .filter(entry -> !isInitialField(entry.getKey(), entry.getValue()))
-                       .forEach(entry -> editFields.put(entry.getKey(), filterCustomFieldValue(entry.getKey(),
-                                                                                               entry.getValue())));
+                       .filter(entry -> !isInitialField(issueType, entry.getKey(), entry.getValue()))
+                       .forEach(entry -> editFields.put(entry.getKey(), encodeCustomFields(entry.getKey(),
+                                                                                           entry.getValue(),
+                                                                                           finalProperties)));
 
         if (editFields.fields().size() > 0) {
             var id = data.get("key").asString();
             if (id.indexOf('-') < 0) {
                 id = projectName.toUpperCase() + "-" + id;

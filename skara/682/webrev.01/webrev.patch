diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/AllowCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/AllowCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/AllowCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/AllowCommand.java
@@ -29,15 +29,15 @@
 import java.nio.file.Path;
 import java.util.List;
 
 public class AllowCommand implements CommandHandler {
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
         var botUser = pr.repository().forge().currentUser();
         var vetoers = Veto.vetoers(botUser, allComments);
 
-        if (!vetoers.contains(comment.author().id())) {
+        if (!vetoers.contains(command.user().id())) {
             reply.println("You have not rejected this change");
             return;
         }
 
         reply.print("You have removed your rejection from this change. ");
@@ -46,11 +46,11 @@
             pr.removeLabel("rejected");
         } else {
             reply.println("However, it still remains blocked by other rejections.");
         }
 
-        reply.println(Veto.removeVeto(comment.author()));
+        reply.println(Veto.removeVeto(command.user()));
     }
 
     @Override
     public String description() {
         return "flag a PR as allowed to be integrated";
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CSRCommand.java
@@ -54,26 +54,26 @@
                       "[" + issue.id() + "](" + issue.webUrl() + "). This pull request cannot be integrated until " +
                       "the CSR request is approved.");
     }
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!censusInstance.isReviewer(comment.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!censusInstance.isReviewer(command.user())) {
             reply.println("only [Reviewers](https://openjdk.java.net/bylaws#reviewer) are allowed require a CSR.");
             return;
         }
 
         var labels = pr.labels();
 
-        if (args.trim().toLowerCase().equals("unneeded")) {
+        if (command.args().trim().toLowerCase().equals("unneeded")) {
             if (labels.contains(CSR_LABEL)) {
                 pr.removeLabel(CSR_LABEL);
             }
             reply.println("determined that a [CSR](https://wiki.openjdk.java.net/display/csr/Main) request " +
                           "is no longer needed for this pull request.");
             return;
-        } else if (!args.isEmpty()) {
+        } else if (!command.args().isEmpty()) {
             showHelp(reply);
             return;
         }
 
         if (labels.contains(CSR_LABEL)) {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
@@ -157,8 +157,8 @@
                 CheckRun.execute(this, pr, localRepo, comments, allReviews, activeReviews, labels, census, bot.ignoreStaleReviews());
             } catch (IOException e) {
                 throw new UncheckedIOException(e);
             }
         }
-        return List.of();
+        return List.of(new CommandWorkItem(bot, pr, errorHandler));
     }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandHandler.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandHandler.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandHandler.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandHandler.java
@@ -28,8 +28,15 @@
 import java.io.PrintWriter;
 import java.nio.file.Path;
 import java.util.List;
 
 interface CommandHandler {
-    void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply);
+    void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply);
     String description();
+
+    default boolean multiLine() {
+        return false;
+    }
+    default boolean allowedInBody() {
+        return false;
+    }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandInvocation.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandInvocation.java
--- /dev/null
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandInvocation.java
@@ -0,0 +1,41 @@
+package org.openjdk.skara.bots.pr;
+
+import org.openjdk.skara.host.HostUser;
+
+import java.util.Optional;
+
+class CommandInvocation {
+    private final String id;
+    private final HostUser user;
+    private final CommandHandler handler;
+    private final String name;
+    private final String args;
+
+    CommandInvocation(String id, HostUser user, CommandHandler handler, String name, String args) {
+        this.id = id;
+        this.user = user;
+        this.handler = handler;
+        this.name = name;
+        this.args = args != null ? args.strip() : "";
+    }
+
+    String id() {
+        return id;
+    }
+
+    HostUser user() {
+        return user;
+    }
+
+    Optional<CommandHandler> handler() {
+        return Optional.ofNullable(handler);
+    }
+
+    String name() {
+        return name;
+    }
+
+    String args() {
+        return args;
+    }
+}
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CommandWorkItem.java
@@ -22,10 +22,11 @@
  */
 package org.openjdk.skara.bots.pr;
 
 import org.openjdk.skara.bot.WorkItem;
 import org.openjdk.skara.forge.PullRequest;
+import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.issuetracker.Comment;
 
 import java.io.*;
 import java.nio.file.Path;
 import java.util.*;
@@ -35,11 +36,11 @@
 import java.util.stream.*;
 
 public class CommandWorkItem extends PullRequestWorkItem {
     private static final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
 
-    private static final Pattern commandPattern = Pattern.compile("^/(.*)");
+    private static final Pattern commandPattern = Pattern.compile("^\\s*/([A-Za-z]+)(?:\\s+(.*))?");
     private static final String commandReplyMarker = "<!-- Jmerge command reply message (%s) -->";
     private static final Pattern commandReplyPattern = Pattern.compile("<!-- Jmerge command reply message \\((\\S+)\\) -->");
     private static final String selfCommandMarker = "<!-- Valid self-command -->";
 
     private static final Map<String, CommandHandler> commandHandlers = Map.ofEntries(
@@ -59,18 +60,18 @@
 
     static class HelpCommand implements CommandHandler {
         static private Map<String, String> external = null;
 
         @Override
-        public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
+        public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
             reply.println("Available commands:");
             Stream.concat(
                     commandHandlers.entrySet().stream()
                                    .map(entry -> entry.getKey() + " - " + entry.getValue().description()),
                     external.entrySet().stream()
                             .map(entry -> entry.getKey() + " - " + entry.getValue())
-            ).sorted().forEachOrdered(command -> reply.println(" * " + command));
+            ).sorted().forEachOrdered(c -> reply.println(" * " + c));
         }
 
         @Override
         public String description() {
             return "shows this text";
@@ -97,31 +98,106 @@
                        .filter(entry -> !handled.contains(entry.getKey().id()))
                        .map(entry -> new AbstractMap.SimpleEntry<>(entry.getValue().group(1), entry.getKey()))
                        .collect(Collectors.toList());
     }
 
-    private void processCommand(PullRequest pr, CensusInstance censusInstance, Path scratchPath, String command, Comment comment, List<Comment> allComments) {
+    private String formatId(String baseId, int subId) {
+        if (subId > 0) {
+            return String.format("%s:%d", baseId, subId);
+        } else {
+            return baseId;
+        }
+    }
+
+    private static class InvalidBodyCommandHandler implements CommandHandler {
+        @Override
+        public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+            reply.println("The command `" + command.name() + "` cannot be used in the pull request body. Please use it in a new comment.");
+        }
+
+        @Override
+        public String description() {
+            return "";
+        }
+    }
+
+    private List<CommandInvocation> extractCommands(String text, String baseId, HostUser user) {
+        var ret = new ArrayList<CommandInvocation>();
+        CommandHandler multiLineHandler = null;
+        List<String> multiLineBuffer = null;
+        String multiLineCommand = null;
+        int subId = 0;
+        for (var line : text.split("\\R")) {
+            var commandMatcher = commandPattern.matcher(line);
+            if (commandMatcher.matches()) {
+                if (multiLineHandler != null) {
+                    ret.add(new CommandInvocation(formatId(baseId, subId++), user, multiLineHandler, multiLineCommand, String.join("\n", multiLineBuffer)));
+                    multiLineHandler = null;
+                }
+                var command = commandMatcher.group(1).toLowerCase();
+                var handler = commandHandlers.get(command);
+                if (handler != null && baseId.equals("body") && !handler.allowedInBody()) {
+                    handler = new InvalidBodyCommandHandler();
+                }
+                if (handler != null && handler.multiLine()) {
+                    multiLineHandler = handler;
+                    multiLineBuffer = new ArrayList<>();
+                    if (commandMatcher.group(2) != null) {
+                        multiLineBuffer.add(commandMatcher.group(2));
+                    }
+                    multiLineCommand = command;
+                } else {
+                    ret.add(new CommandInvocation(formatId(baseId, subId++), user, handler, command, commandMatcher.group(2)));
+                }
+            } else {
+                if (multiLineHandler != null) {
+                    multiLineBuffer.add(line);
+                }
+            }
+        }
+        if (multiLineHandler != null) {
+            ret.add(new CommandInvocation(formatId(baseId, subId), user, multiLineHandler, multiLineCommand, String.join("\n", multiLineBuffer)));
+        }
+        return ret;
+    }
+
+    private Optional<CommandInvocation> nextCommand(PullRequest pr, List<Comment> comments) {
+        var self = pr.repository().forge().currentUser();
+        var allCommands = Stream.concat(extractCommands(pr.body(), "body", pr.author()).stream(),
+                                        comments.stream()
+                                                .filter(comment -> !comment.author().equals(self) || comment.body().endsWith(selfCommandMarker))
+                                                .flatMap(c -> extractCommands(c.body(), c.id(), c.author()).stream()))
+                                .collect(Collectors.toList());
+
+        var handled = comments.stream()
+                              .filter(comment -> comment.author().equals(self))
+                              .map(comment -> commandReplyPattern.matcher(comment.body()))
+                              .filter(Matcher::find)
+                              .map(matcher -> matcher.group(1))
+                              .collect(Collectors.toSet());
+
+        return allCommands.stream()
+                          .filter(ci -> !handled.contains(ci.id()))
+                          .findFirst();
+    }
+
+    private void processCommand(PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments) {
         var writer = new StringWriter();
         var printer = new PrintWriter(writer);
 
-        printer.println(String.format(commandReplyMarker, comment.id()));
+        printer.println(String.format(commandReplyMarker, command.id()));
         printer.print("@");
-        printer.print(comment.author().userName());
+        printer.print(command.user().userName());
         printer.print(" ");
 
-        command = command.strip();
-        var argSplit = command.indexOf(' ');
-        var commandWord = argSplit > 0 ? command.substring(0, argSplit) : command;
-        var commandArgs = argSplit > 0 ? command.substring(argSplit + 1) : "";
-
-        var handler = commandHandlers.get(commandWord);
-        if (handler != null) {
-            handler.handle(bot, pr, censusInstance, scratchPath, commandArgs, comment, allComments, printer);
+        var handler = command.handler();
+        if (handler.isPresent()) {
+            handler.get().handle(bot, pr, censusInstance, scratchPath, command, allComments, printer);
         } else {
-            if (!bot.externalCommands().containsKey(commandWord)) {
+            if (!bot.externalCommands().containsKey(command.name())) {
                 printer.print("Unknown command `");
-                printer.print(command);
+                printer.print(command.name());
                 printer.println("` - for a list of valid commands use `/help`.");
             } else {
                 // Do not reply to external commands
                 return;
             }
@@ -130,32 +206,30 @@
         pr.addComment(writer.toString());
     }
 
     @Override
     public Collection<WorkItem> run(Path scratchPath) {
-        log.info("Looking for merge commands");
+        log.info("Looking for PR commands");
 
         if (pr.labels().contains("integrated")) {
             log.info("Skip checking for commands in integrated PR");
             return List.of();
         }
 
         var comments = pr.comments();
-        var unprocessedCommands = findCommandComments(comments);
-        if (unprocessedCommands.isEmpty()) {
-            log.fine("No new merge commands found, stopping further processing");
+        var nextCommand = nextCommand(pr, comments);
+        if (nextCommand.isEmpty()) {
+            log.fine("No new PR commands found, stopping further processing");
             return List.of();
         }
 
         if (HelpCommand.external == null) {
             HelpCommand.external = bot.externalCommands();
         }
 
         var census = CensusInstance.create(bot.censusRepo(), bot.censusRef(), scratchPath.resolve("census"), pr);
-        for (var entry : unprocessedCommands) {
-            processCommand(pr, census, scratchPath.resolve("pr").resolve("command"), entry.getKey(), entry.getValue(), comments);
-        }
+        processCommand(pr, census, scratchPath.resolve("pr").resolve("command"), nextCommand.get(), comments);
 
         // Run another check to reflect potential changes from commands
         return List.of(new CheckWorkItem(bot, pr, errorHandler));
     }
 
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ContributorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ContributorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ContributorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ContributorCommand.java
@@ -77,17 +77,17 @@
             return Optional.of(EmailAddress.from(contributor.username() + "@openjdk.org"));
         }
     }
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!command.user().equals(pr.author())) {
             reply.println("Only the author (@" + pr.author().userName() + ") is allowed to issue the `contributor` command.");
             return;
         }
 
-        var matcher = commandPattern.matcher(args);
+        var matcher = commandPattern.matcher(command.args());
         if (!matcher.matches()) {
             showHelp(pr, reply);
             return;
         }
 
@@ -128,6 +128,11 @@
 
     @Override
     public String description() {
         return "adds or removes additional contributors for a PR";
     }
+
+    @Override
+    public boolean allowedInBody() {
+        return true;
+    }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
@@ -51,18 +51,18 @@
         }
         return Optional.of(String.format(outdated, pr.headHash()));
     }
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!command.user().equals(pr.author())) {
             reply.print("Only the author (@" + pr.author().userName() + ") is allowed to issue the `integrate` command.");
 
             // If the command author is allowed to sponsor this change, suggest that command
             var readyHash = ReadyForSponsorTracker.latestReadyForSponsor(pr.repository().forge().currentUser(), allComments);
             if (readyHash.isPresent()) {
-                if (censusInstance.isCommitter(comment.author())) {
+                if (censusInstance.isCommitter(command.user())) {
                     reply.print(" As this PR is ready to be sponsored, and you are an eligible sponsor, did you mean to issue the `/sponsor` command?");
                     return;
                 }
             }
             reply.println();
@@ -92,12 +92,12 @@
             var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);
             var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews());
 
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
-            if (!args.isBlank()) {
-                var wantedHash = new Hash(args);
+            if (!command.args().isBlank()) {
+                var wantedHash = new Hash(command.args());
                 if (!pr.targetHash().equals(wantedHash)) {
                     reply.print("The head of the target branch is no longer at the requested hash " + wantedHash);
                     reply.println(" - it has moved to " + pr.targetHash() + ". Aborting integration.");
                     return;
                 }
@@ -127,11 +127,11 @@
 
             // Finally check if the author is allowed to perform the actual push
             if (!censusInstance.isCommitter(pr.author())) {
                 reply.println(ReadyForSponsorTracker.addIntegrationMarker(pr.headHash()));
                 reply.println("Your change (at version " + pr.headHash() + ") is now ready to be sponsored by a Committer.");
-                if (!args.isBlank()) {
+                if (!command.args().isBlank()) {
                     reply.println("Note that your sponsor will make the final decision onto which target hash to integrate.");
                 }
                 pr.addLabel("sponsor");
                 return;
             }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IssueCommand.java
@@ -270,15 +270,16 @@
             reply.println("An error occurred when attempting to create an issue: " + e.getMessage());
         }
     }
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!command.user().equals(pr.author())) {
             reply.println("Only the author (@" + pr.author().userName() + ") is allowed to issue the `/" + name + "` command.");
             return;
         }
+        var args = command.args();
         if (args.isBlank()) {
             showHelp(reply);
             return;
         }
         var subCommandMatcher = subCommandPattern.matcher(args);
@@ -293,11 +294,11 @@
                                          .collect(Collectors.toSet());
         try {
             if (args.startsWith("remove") || args.startsWith("delete")) {
                 removeIssue(bot, args, currentSolved, reply);
             } else if (args.startsWith("create")) {
-                createIssue(bot, pr, args, censusInstance, comment.author(), reply);
+                createIssue(bot, pr, args, censusInstance, command.user(), reply);
             } else {
                 addIssue(bot, pr, args, currentSolved, reply);
             }
         } catch (InvalidIssue invalidIssue) {
             reply.println("The issue identifier `" + invalidIssue.identifier() + "` is invalid: " + invalidIssue.reason() + ".");
@@ -306,6 +307,11 @@
 
     @Override
     public String description() {
         return "edit the list of issues that this PR solves";
     }
+
+    @Override
+    public boolean allowedInBody() {
+        return true;
+    }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelCommand.java
@@ -57,17 +57,17 @@
         var files = PullRequestUtils.changedFiles(pr, localRepo);
         return bot.labelConfiguration().fromChanges(files);
     }
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author()) && (!censusInstance.isCommitter(comment.author()))) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!command.user().equals(pr.author()) && (!censusInstance.isCommitter(command.user()))) {
             reply.println("Only the PR author and project [Committers](https://openjdk.java.net/bylaws#committer) are allowed to modify labels on a PR.");
             return;
         }
 
-        var argumentMatcher = argumentPattern.matcher(args);
+        var argumentMatcher = argumentPattern.matcher(command.args());
         if (!argumentMatcher.matches()) {
             showHelp(bot.labelConfiguration(), reply);
             return;
         }
 
@@ -116,6 +116,11 @@
 
     @Override
     public String description() {
         return "add or remove an additional classification label";
     }
+
+    @Override
+    public boolean allowedInBody() {
+        return true;
+    }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestBot.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestBot.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestBot.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestBot.java
@@ -117,11 +117,10 @@
                 if (!isReady(pr)) {
                     continue;
                 }
 
                 ret.add(new CheckWorkItem(this, pr, e -> updateCache.invalidate(pr)));
-                ret.add(new CommandWorkItem(this, pr, e -> updateCache.invalidate(pr)));
                 ret.add(new LabelerWorkItem(this, pr, e -> updateCache.invalidate(pr)));
             }
         }
 
         return ret;
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/RejectCommand.java
@@ -29,35 +29,35 @@
 import java.nio.file.Path;
 import java.util.List;
 
 public class RejectCommand implements CommandHandler {
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (pr.author().equals(comment.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (pr.author().equals(command.user())) {
             reply.println("You can't reject your own changes.");
             return;
         }
-        if (!censusInstance.isReviewer(comment.author())) {
+        if (!censusInstance.isReviewer(command.user())) {
             reply.println("Only [Reviewers](https://openjdk.java.net/bylaws#reviewer) are allowed to reject changes.");
             return;
         }
 
         var botUser = pr.repository().forge().currentUser();
         var vetoers = Veto.vetoers(botUser, allComments);
 
-        if (vetoers.contains(comment.author().id())) {
+        if (vetoers.contains(command.user().id())) {
             reply.println("You have already rejected this change.");
             return;
         }
 
         // Notify the author as well
         reply.print("@" + pr.author().userName() + " ");
 
         reply.println("This change cannot be integrated while the rejection is in place. To lift the rejection, ");
         reply.println("issue an allow command: `/allow`");
 
-        reply.println(Veto.addVeto(comment.author()));
+        reply.println(Veto.addVeto(command.user()));
 
         if (vetoers.isEmpty()) {
             pr.addLabel("rejected");
         }
     }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewerCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewerCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewerCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewerCommand.java
@@ -64,21 +64,21 @@
         }
         return Optional.of(contributor);
     }
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!command.user().equals(pr.author())) {
             reply.println("Only the author (@" + pr.author().userName() + ") is allowed to issue the `reviewer` command.");
             return;
         }
         if (bot.ignoreStaleReviews()) {
             reply.println("This project requires authenticated reviews - please ask your reviewer to flag this PR as reviewed.");
             return;
         }
 
-        var matcher = commandPattern.matcher(args);
+        var matcher = commandPattern.matcher(command.args());
         if (!matcher.matches()) {
             showHelp(pr, reply);
             return;
         }
 
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/ReviewersCommand.java
@@ -46,17 +46,17 @@
         reply.println("Usage: `/reviewers <n> [<role>]` where `<n>` is the number of required reviewers. " +
                               "If role is set, the reviewers need to have that project role. If omitted, role defaults to `authors`.");
     }
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!censusInstance.isReviewer(comment.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!censusInstance.isReviewer(command.user())) {
             reply.println("Only [Reviewers](https://openjdk.java.net/bylaws#reviewer) are allowed to change the number of required reviewers.");
             return;
         }
 
-        var splitArgs = args.split(" ");
+        var splitArgs = command.args().split(" ");
         if (splitArgs.length < 1 || splitArgs.length > 2) {
             showHelp(reply);
             return;
         }
 
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
@@ -33,16 +33,16 @@
 
 public class SponsorCommand implements CommandHandler {
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
 
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
         if (censusInstance.isCommitter(pr.author())) {
             reply.println("This change does not need sponsoring - the author is allowed to integrate it.");
             return;
         }
-        if (!censusInstance.isReviewer(comment.author())) {
+        if (!censusInstance.isReviewer(command.user())) {
             reply.println("Only [Committers](https://openjdk.java.net/bylaws#committer) are allowed to sponsor changes.");
             return;
         }
 
         var readyHash = ReadyForSponsorTracker.latestReadyForSponsor(pr.repository().forge().currentUser(), allComments);
@@ -77,12 +77,12 @@
             var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);
             var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews());
 
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
-            if (!args.isBlank()) {
-                var wantedHash = new Hash(args);
+            if (!command.args().isBlank()) {
+                var wantedHash = new Hash(command.args());
                 if (!pr.targetHash().equals(wantedHash)) {
                     reply.print("The head of the target branch is no longer at the requested hash " + wantedHash);
                     reply.println(" - it has moved to " + pr.targetHash() + ". Aborting integration.");
                     return;
                 }
@@ -95,11 +95,11 @@
                 reply.println(rebaseMessage.toString());
                 return;
             }
 
             var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(),
-                    comment.author().id());
+                    command.user().id());
 
             var issues = checkablePr.createVisitor(localHash, censusInstance);
             var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash, pr.repository().forge().currentUser(), allComments);
             checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
             if (!issues.messages().isEmpty()) {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SummaryCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SummaryCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SummaryCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SummaryCommand.java
@@ -25,74 +25,54 @@
 import org.openjdk.skara.forge.PullRequest;
 import org.openjdk.skara.issuetracker.Comment;
 
 import java.io.PrintWriter;
 import java.nio.file.Path;
-import java.util.Arrays;
-import java.util.List;
-import java.util.stream.Collectors;
+import java.util.*;
 
 public class SummaryCommand implements CommandHandler {
     @Override
-    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, String args, Comment comment, List<Comment> allComments, PrintWriter reply) {
-        if (!comment.author().equals(pr.author())) {
+    public void handle(PullRequestBot bot, PullRequest pr, CensusInstance censusInstance, Path scratchPath, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {
+        if (!command.user().equals(pr.author())) {
             reply.println("Only the author (@" + pr.author().userName() + ") is allowed to issue the `/summary` command.");
             return;
         }
 
         var currentSummary = Summary.summary(pr.repository().forge().currentUser(), allComments);
-        var lines = Arrays.asList(comment.body().split("\n"));
-
-        if (args.isBlank()) {
-            if (lines.size() == 1) {
-                if (currentSummary.isPresent()) {
-                    reply.println("Removing existing summary");
-                    reply.println(Summary.setSummaryMarker(""));
-                } else {
-                    reply.println("To set a summary, use the syntax `/summary <summary text>`");
-                }
+        if (command.args().isBlank()) {
+            if (currentSummary.isPresent()) {
+                reply.println("Removing existing summary");
+                reply.println(Summary.setSummaryMarker(""));
             } else {
-                // A multi-line summary
-                var summaryLines = lines.subList(1, lines.size())
-                                        .stream()
-                                        .dropWhile(String::isEmpty)
-                                        .collect(Collectors.toList());
-                var lastIndexWithNonBlankLine = summaryLines.size() - 1;
-                while (lastIndexWithNonBlankLine >= 0 && summaryLines.get(lastIndexWithNonBlankLine).isEmpty()) {
-                    lastIndexWithNonBlankLine--;
-                }
-                if (lastIndexWithNonBlankLine == 0) {
-                    reply.println("To set a summary, use the syntax `/summary <summary text>`");
-                } else {
-                    var summary = String.join("\n", summaryLines.subList(0, lastIndexWithNonBlankLine + 1));
-                    var action = currentSummary.isPresent() ? "Updating existing" : "Setting";
-                    reply.println(action + " summary to:\n" +
-                                  "\n" +
-                                  "```\n" +
-                                  summary +
-                                  "\n```");
-                    reply.println(Summary.setSummaryMarker(summary));
-                }
+                reply.println("To set a summary, use the syntax `/summary <summary text>`");
             }
         } else {
-            // A single-line summary
-            if (lines.size() > 1) {
-                reply.println("To set a multi-line summary, use the syntax:\n" +
-                              "\n```\n" +
-                              "/summary\n" +
-                              "This is the first line\n" +
-                              "This is the second line\n" +
-                              "```");
+            var summary = command.args().strip();
+            var action = currentSummary.isPresent() ? "Updating existing" : "Setting";
+            if (summary.contains("\n")) {
+                reply.println(action + " summary to:\n" +
+                                      "\n" +
+                                      "```\n" +
+                                      summary +
+                                      "\n```");
             } else {
-                var summary = args.strip();
-                var action = currentSummary.isPresent() ? "Updating existing" : "Setting";
                 reply.println(action + " summary to `" + summary + "`");
-                reply.println(Summary.setSummaryMarker(summary));
             }
+            reply.println(Summary.setSummaryMarker(summary));
         }
     }
 
     @Override
     public String description() {
         return "updates the summary in the commit message";
     }
+
+    @Override
+    public boolean multiLine() {
+        return true;
+    }
+
+    @Override
+    public boolean allowedInBody() {
+        return true;
+    }
 }
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CommandTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CommandTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CommandTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CommandTests.java
@@ -20,17 +20,17 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.bots.pr;
 
-import org.openjdk.skara.test.*;
-
 import org.junit.jupiter.api.*;
+import org.openjdk.skara.test.*;
 
 import java.io.IOException;
 
 import static org.junit.jupiter.api.Assertions.*;
+import static org.openjdk.skara.bots.pr.PullRequestAsserts.assertLastCommentContains;
 
 class CommandTests {
     @Test
     void invalidCommand(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
@@ -102,10 +102,53 @@
                           .count();
             assertEquals(1, error);
         }
     }
 
+    @Test
+    void multipleCommands(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "refs/heads/edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
+
+            // Issue multiple commands in a comment
+            pr.addComment("/contributor add A <a@b.c>\n/summary line 1\nline 2\n/contributor add B <b@c.d>");
+            TestBotRunner.runPeriodicItems(mergeBot);
+
+            // Each command should get a separate reply
+            assertEquals(4, pr.comments().size());
+            assertTrue(pr.comments().get(1).body().contains("Contributor `A <a@b.c>` successfully added"), pr.comments().get(1).body());
+            assertTrue(pr.comments().get(2).body().contains("Setting summary to:\n" +
+                                                                    "\n" +
+                                                                    "```\n" +
+                                                                    "line 1\n" +
+                                                                    "line 2"), pr.comments().get(2).body());
+            assertTrue(pr.comments().get(3).body().contains("Contributor `B <b@c.d>` successfully added"), pr.comments().get(3).body());
+
+            // They should only be executed once
+            TestBotRunner.runPeriodicItems(mergeBot);
+            TestBotRunner.runPeriodicItems(mergeBot);
+            assertEquals(4, pr.comments().size());
+        }
+    }
+
     @Test
     void selfCommand(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory()) {
             var author = credentials.getHostedRepository();
@@ -147,6 +190,74 @@
                          .filter(comment -> comment.body().contains("help"))
                          .count();
             assertEquals(1, help);
         }
     }
+
+    @Test
+    void inBody(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var mergeBot = PullRequestBot.newBuilder()
+                                         .repo(integrator)
+                                         .censusRepo(censusBuilder.build())
+                                         .build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
+
+            // Issue an invalid body command
+            pr.setBody("This is a body\n/contributor add A <a@b.c>\n/contributor add B <b@c.d>");
+            TestBotRunner.runPeriodicItems(mergeBot);
+
+            // The second command reply should be the last comment
+            assertLastCommentContains(pr, "Contributor `B <b@c.d>` successfully added.");
+
+            // The first command should also be reflected in the body
+            assertTrue(pr.body().contains("A `<a@b.c>`"));
+        }
+    }
+
+    @Test
+    void disallowedInBody(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var integrator = credentials.getHostedRepository();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            var editHash = CheckableRepository.appendAndCommit(localRepo);
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
+
+            // Issue an invalid body command
+            pr.setBody("/help");
+            TestBotRunner.runPeriodicItems(mergeBot);
+
+            // The bot should reply with some help
+            assertLastCommentContains(pr, "The command `help` cannot be used in the pull request body");
+        }
+    }
 }
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/IntegrateTests.java
@@ -181,13 +181,18 @@
             // Make a change with a corresponding PR
             var editHash = CheckableRepository.appendAndCommit(localRepo);
             localRepo.push(editHash, author.url(), "refs/heads/edit", true);
             var pr = credentials.createPullRequest(author, "master", "edit", "This is a pull request");
 
-            // Attempt a merge, do not run the check from the bot
+            // Attempt a merge, but point the check at some other commit
             pr.addComment("/integrate");
-            TestBotRunner.runPeriodicItems(mergeBot, item -> item instanceof CheckWorkItem);
+            TestBotRunner.runPeriodicItems(mergeBot, item -> {
+                if (item instanceof CheckWorkItem) {
+                    var newCheck = CheckBuilder.create("jcheck", masterHash).build();
+                    pr.updateCheck(newCheck);
+                }
+            });
 
             // The bot should reply with an error message
             var error = pr.comments().stream()
                           .filter(comment -> comment.body().contains("merge request cannot be fulfilled at this time"))
                           .filter(comment -> comment.body().contains("status check"))
@@ -303,13 +308,18 @@
 
             // Now push another change
             var updatedHash = CheckableRepository.appendAndCommit(localRepo, "Yet another line");
             localRepo.push(updatedHash, author.url(), "edit", true);
 
-            // Attempt a merge - avoid running checks from the bot
+            // Attempt a merge, but point the check at some other commit
             pr.addComment("/integrate");
-            TestBotRunner.runPeriodicItems(mergeBot, item -> item instanceof CheckWorkItem);
+            TestBotRunner.runPeriodicItems(mergeBot, item -> {
+                if (item instanceof CheckWorkItem) {
+                    var newCheck = CheckBuilder.create("jcheck", masterHash).build();
+                    pr.updateCheck(newCheck);
+                }
+            });
 
             // The bot should reply with an error message
             var error = pr.comments().stream()
                           .filter(comment -> comment.body().contains("merge request cannot be fulfilled at this time"))
                           .filter(comment -> comment.body().contains("status check"))
@@ -578,19 +588,19 @@
             Files.writeString(censusFolder.path().resolve("contributors.xml"), "This is not xml", StandardCharsets.UTF_8);
             localCensus.add(censusFolder.path().resolve("contributors.xml"));
             var badCensusHash = localCensus.commit("Bad census update", "duke", "duke@openjdk.org");
             localCensus.push(badCensusHash, censusRepo.url(), "master", true);
 
-            // Attempt a merge (without triggering another check)
+            // Attempt a merge
             pr.addComment("/integrate");
-            assertThrows(RuntimeException.class, () -> TestBotRunner.runPeriodicItems(mergeBot, wi -> wi instanceof CheckWorkItem));
+            assertThrows(RuntimeException.class, () -> TestBotRunner.runPeriodicItems(mergeBot));
 
             // Restore the census
             localCensus.push(currentCensusHash, censusRepo.url(), "master", true);
 
             // The bot should now retry
-            TestBotRunner.runPeriodicItems(mergeBot, wi -> wi instanceof CheckWorkItem);
+            TestBotRunner.runPeriodicItems(mergeBot);
 
             // The bot should reply with an ok message
             var pushed = pr.comments().stream()
                            .filter(comment -> comment.body().contains("Pushed as commit"))
                            .count();
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SummaryTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SummaryTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SummaryTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/SummaryTests.java
@@ -374,10 +374,16 @@
 
             // Try setting a summary when none has been set yet
             pr.addComment("/summary inline\nnext line");
             TestBotRunner.runPeriodicItems(prBot);
 
-            // The bot should reply with a help message
-            assertLastCommentContains(pr,"To set a multi-line summary, use the syntax:");
+            // This should also be interpreted as a multi-line summary
+            assertLastCommentContains(pr,
+                                      "Setting summary to:\n" +
+                                              "\n" +
+                                              "```\n" +
+                                              "inline\n" +
+                                              "next line\n" +
+                                              "```");
         }
     }
 }
diff a/test/src/main/java/org/openjdk/skara/test/TestBotRunner.java b/test/src/main/java/org/openjdk/skara/test/TestBotRunner.java
--- a/test/src/main/java/org/openjdk/skara/test/TestBotRunner.java
+++ b/test/src/main/java/org/openjdk/skara/test/TestBotRunner.java
@@ -24,31 +24,34 @@
 
 import org.openjdk.skara.bot.*;
 
 import java.io.IOException;
 import java.util.*;
-import java.util.function.Predicate;
 
 public class TestBotRunner {
+    @FunctionalInterface
+    public interface AfterItemHook {
+        void run(WorkItem item);
+    }
+
     public static void runPeriodicItems(Bot bot) throws IOException {
-        runPeriodicItems(bot, wi -> false);
+        runPeriodicItems(bot, item -> {});
     }
 
-    public static void runPeriodicItems(Bot bot, Predicate<WorkItem> ignored) throws IOException {
+    public static void runPeriodicItems(Bot bot, AfterItemHook afterItemHook) throws IOException {
         var items = new LinkedList<>(bot.getPeriodicItems());
         for (var item = items.pollFirst(); item != null; item = items.pollFirst()) {
-            if (!ignored.test(item)) {
-                Collection<WorkItem> followUpItems = null;
-                try (var scratchFolder = new TemporaryDirectory()) {
-                    followUpItems = item.run(scratchFolder.path());
-                } catch (RuntimeException e) {
-                    item.handleRuntimeException(e);
-                    // Allow tests to assert on these as well
-                    throw e;
-                }
-                if (followUpItems != null) {
-                    items.addAll(followUpItems);
-                }
+            Collection<WorkItem> followUpItems = null;
+            try (var scratchFolder = new TemporaryDirectory()) {
+                followUpItems = item.run(scratchFolder.path());
+                afterItemHook.run(item);
+            } catch (RuntimeException e) {
+                item.handleRuntimeException(e);
+                // Allow tests to assert on these as well
+                throw e;
+            }
+            if (followUpItems != null) {
+                items.addAll(followUpItems);
             }
         }
     }
 }

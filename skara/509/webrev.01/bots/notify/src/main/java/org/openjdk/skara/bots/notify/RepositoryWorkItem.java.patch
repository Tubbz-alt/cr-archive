diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/RepositoryWorkItem.java
@@ -52,11 +52,11 @@
         this.tagStorageBuilder = tagStorageBuilder;
         this.branchStorageBuilder = branchStorageBuilder;
         this.updaters = updaters;
     }
 
-    private void handleNewRef(Repository localRepo, Reference ref, Collection<Reference> allRefs, boolean runOnlyIdempotent) {
+    private void handleNewRef(Repository localRepo, Reference ref, Collection<Reference> allRefs, RepositoryUpdateConsumer updater) {
         // Figure out the best parent ref
         var candidates = new HashSet<>(allRefs);
         candidates.remove(ref);
         if (candidates.size() == 0) {
             log.warning("No parent candidates found for branch '" + ref.name() + "' - ignoring");
@@ -75,59 +75,72 @@
                                    .orElseThrow();
         if (bestParent.getValue().size() > 1000) {
             throw new RuntimeException("Excessive amount of unique commits on new branch " + ref.name() +
                                                " detected (" + bestParent.getValue().size() + ") - skipping notifications");
         }
+        List<Commit> bestParentCommits;
         try {
-            var bestParentCommits = localRepo.commits(bestParent.getKey().hash().hex() + ".." + ref.hash(), true);
-            for (var updater : updaters) {
-                if (updater.isIdempotent() != runOnlyIdempotent) {
-                    continue;
-                }
-                var branch = new Branch(ref.name());
-                var parent = new Branch(bestParent.getKey().name());
-                updater.handleNewBranch(repository, localRepo, bestParentCommits.asList(), parent, branch);
-            }
+            bestParentCommits = localRepo.commits(bestParent.getKey().hash().hex() + ".." + ref.hash(), true).asList();
         } catch (IOException e) {
-            e.printStackTrace();
+            throw new UncheckedIOException(e);
         }
+        var branch = new Branch(ref.name());
+        var parent = new Branch(bestParent.getKey().name());
+        updater.handleNewBranch(repository, localRepo, bestParentCommits, parent, branch);
     }
 
-    private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits, boolean runOnlyIdempotent) {
-        for (var updater : updaters) {
-            if (updater.isIdempotent() != runOnlyIdempotent) {
-                continue;
-            }
-            var branch = new Branch(ref.name());
-            updater.handleCommits(repository, localRepo, commits, branch);
-        }
+    private void handleUpdatedRef(Repository localRepo, Reference ref, List<Commit> commits, RepositoryUpdateConsumer updater) {
+        var branch = new Branch(ref.name());
+        updater.handleCommits(repository, localRepo, commits, branch);
     }
 
-    private void handleRef(Repository localRepo, UpdateHistory history, Reference ref, Collection<Reference> allRefs) throws IOException {
+    private List<RuntimeException> handleRef(Repository localRepo, UpdateHistory history, Reference ref, Collection<Reference> allRefs) throws IOException {
+        var errors = new ArrayList<RuntimeException>();
         var branch = new Branch(ref.name());
-        var lastHash = history.branchHash(branch);
-        if (lastHash.isEmpty()) {
-            log.warning("No previous history found for branch '" + branch + "' - resetting mark");
-            handleNewRef(localRepo, ref, allRefs, true);
-            history.setBranchHash(branch, ref.hash());
-            handleNewRef(localRepo, ref, allRefs, false);
-        } else {
-            var commitMetadata = localRepo.commitMetadata(lastHash.get() + ".." + ref.hash());
-            if (commitMetadata.size() == 0) {
-                return;
-            }
-            if (commitMetadata.size() > 1000) {
-                history.setBranchHash(branch, ref.hash());
-                throw new RuntimeException("Excessive amount of new commits on branch " + branch.name() +
-                                                   " detected (" + commitMetadata.size() + ") - skipping notifications");
-            }
+        for (var updater : updaters) {
+            var lastHash = history.branchHash(branch, updater.name());
+            if (lastHash.isEmpty()) {
+                log.warning("No previous history found for branch '" + branch + "' and updater '" + updater.name() + " - resetting mark");
+                if (!updater.isIdempotent()) {
+                    history.setBranchHash(branch, updater.name(), ref.hash());
+                }
+                try {
+                    handleNewRef(localRepo, ref, allRefs, updater);
+                    if (updater.isIdempotent()) {
+                        history.setBranchHash(branch, updater.name(), ref.hash());
+                    }
+                } catch (RuntimeException e) {
+                    errors.add(e);
+                }
+            } else {
+                var commitMetadata = localRepo.commitMetadata(lastHash.get() + ".." + ref.hash());
+                if (commitMetadata.size() == 0) {
+                    continue;
+                }
+                if (commitMetadata.size() > 1000) {
+                    history.setBranchHash(branch, updater.name(), ref.hash());
+                    errors.add(new RuntimeException("Excessive amount of new commits on branch " + branch.name() +
+                                                       " detected (" + commitMetadata.size() + ") for updater '" +
+                                                       updater.name() + "' - skipping notifications"));
+                    continue;
+                }
 
-            var commits = localRepo.commits(lastHash.get() + ".." + ref.hash(), true).asList();
-            handleUpdatedRef(localRepo, ref, commits, true);
-            history.setBranchHash(branch, ref.hash());
-            handleUpdatedRef(localRepo, ref, commits, false);
+                var commits = localRepo.commits(lastHash.get() + ".." + ref.hash(), true).asList();
+                if (!updater.isIdempotent()) {
+                    history.setBranchHash(branch, updater.name(), ref.hash());
+                }
+                try {
+                    handleUpdatedRef(localRepo, ref, commits, updater);
+                    if (updater.isIdempotent()) {
+                        history.setBranchHash(branch, updater.name(), ref.hash());
+                    }
+                } catch (RuntimeException e) {
+                    errors.add(e);
+                }
+            }
         }
+        return errors;
     }
 
     private Optional<OpenJDKTag> existingPrevious(OpenJDKTag tag, Set<OpenJDKTag> allJdkTags) {
         while (true) {
             var candidate = tag.previous();
@@ -274,21 +287,27 @@
             localRepo.fetchAll();
 
             var history = UpdateHistory.create(tagStorageBuilder, historyPath.resolve("tags"), branchStorageBuilder, historyPath.resolve("branches"));
             handleTags(localRepo, history);
 
-            boolean hasBranchHistory = knownRefs.stream()
-                                                .map(ref -> history.branchHash(new Branch(ref.name())))
-                                                .anyMatch(Optional::isPresent);
+            boolean hasBranchHistory = !history.isEmpty();
+            var errors = new ArrayList<RuntimeException>();
             for (var ref : knownRefs) {
                 if (!hasBranchHistory) {
-                    log.warning("No previous history found for any branch - resetting mark for '" + ref.name() + "'");
-                    history.setBranchHash(new Branch(ref.name()), ref.hash());
+                    log.warning("No previous history found for any branch - resetting mark for '" + ref.name());
+                    for (var updater : updaters) {
+                        log.info("Resetting mark for branch '" + ref.name() + "' for updater '" + updater.name() + "'");
+                        history.setBranchHash(new Branch(ref.name()), updater.name(), ref.hash());
+                    }
                 } else {
-                    handleRef(localRepo, history, ref, knownRefs);
+                    errors.addAll(handleRef(localRepo, history, ref, knownRefs));
                 }
             }
+            if (!errors.isEmpty()) {
+                errors.forEach(error -> log.throwing("RepositoryWorkItem", "run", error));
+                throw new RuntimeException("Errors detected during ref updating");
+            }
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
 

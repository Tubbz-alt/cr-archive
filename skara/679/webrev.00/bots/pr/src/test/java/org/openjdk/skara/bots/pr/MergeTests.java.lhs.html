<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.bots.pr;
  24 
  25 import org.openjdk.skara.forge.Review;
  26 import org.openjdk.skara.issuetracker.Comment;
  27 import org.openjdk.skara.process.Process;
  28 import org.openjdk.skara.test.*;
  29 import org.openjdk.skara.vcs.*;
  30 
  31 import org.junit.jupiter.api.*;
  32 
  33 import java.io.IOException;
  34 import java.nio.charset.StandardCharsets;
  35 import java.nio.file.*;
  36 import java.util.Set;
  37 import java.util.stream.Collectors;
  38 
  39 import static org.junit.jupiter.api.Assertions.*;
  40 import static org.junit.jupiter.api.Assumptions.assumeTrue;
<a name="1" id="anc1"></a>
  41 
  42 class MergeTests {
  43     @Test
  44     void branchMerge(TestInfo testInfo) throws IOException {
  45         try (var credentials = new HostCredentials(testInfo);
  46              var tempFolder = new TemporaryDirectory()) {
  47 
  48             var author = credentials.getHostedRepository();
  49             var integrator = credentials.getHostedRepository();
  50             var censusBuilder = credentials.getCensusBuilder()
  51                                            .addCommitter(author.forge().currentUser().id())
  52                                            .addReviewer(integrator.forge().currentUser().id());
  53             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
  54 
  55             // Populate the projects repository
  56             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
  57             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
  58             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
  59             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
  60             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
  61 
  62             // Make more changes in another branch
  63             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
  64                                                                 &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
  65             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
  66             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
  67                                                                 &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
  68             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
  69 
  70             // Go back to the original master
  71             localRepo.checkout(masterHash, true);
  72 
  73             // Make a change with a corresponding PR
  74             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
  75             localRepo.add(unrelated);
  76             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
  77             localRepo.merge(otherHash2);
  78             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
  79 
  80             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
  81             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
  82             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
  83 
  84             // Approve it as another user
  85             var approvalPr = integrator.pullRequest(pr.id());
  86             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
  87 
  88             // Let the bot check the status
  89             TestBotRunner.runPeriodicItems(mergeBot);
  90 
  91             // Push it
  92             pr.addComment(&quot;/integrate&quot;);
  93             TestBotRunner.runPeriodicItems(mergeBot);
  94 
  95             // The bot should reply with an ok message
  96             var pushed = pr.comments().stream()
  97                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
  98                            .count();
  99             assertEquals(1, pushed);
 100 
 101             // The change should now be present on the master branch
 102             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 103             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 104             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 105 
 106             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 107             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 108             Set&lt;Hash&gt; commits;
 109             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 110                 commits = tempCommits.stream()
 111                         .map(Commit::hash)
 112                         .collect(Collectors.toSet());
 113             }
 114             assertTrue(commits.contains(otherHash1));
 115             assertTrue(commits.contains(otherHash2));
 116             assertFalse(commits.contains(mergeHash));
 117 
 118             // Author and committer should updated in the merge commit
 119             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 120             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 121             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 122             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 123             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 124         }
 125     }
 126 
 127     @Test
 128     void branchMergeShortName(TestInfo testInfo) throws IOException {
 129         try (var credentials = new HostCredentials(testInfo);
 130              var tempFolder = new TemporaryDirectory()) {
 131 
 132             var author = credentials.getHostedRepository();
 133             var integrator = credentials.getHostedRepository();
 134             var censusBuilder = credentials.getCensusBuilder()
 135                                            .addCommitter(author.forge().currentUser().id())
 136                                            .addReviewer(integrator.forge().currentUser().id());
 137             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 138 
 139             // Populate the projects repository
 140             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 141             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 142             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 143             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 144             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 145 
 146             // Make more changes in another branch
 147             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 148                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 149             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 150             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 151                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 152             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 153 
 154             // Go back to the original master
 155             localRepo.checkout(masterHash, true);
 156 
 157             // Make a change with a corresponding PR
 158             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 159             localRepo.add(unrelated);
 160             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 161             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 162 
 163             localRepo.merge(otherHash2);
 164             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 165             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 166             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge other&quot;);
 167 
 168             // Approve it as another user
 169             var approvalPr = integrator.pullRequest(pr.id());
 170             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 171 
 172             // Let the bot check the status
 173             TestBotRunner.runPeriodicItems(mergeBot);
 174 
 175             // Push it
 176             pr.addComment(&quot;/integrate&quot;);
 177             TestBotRunner.runPeriodicItems(mergeBot);
 178 
 179             // The bot should reply with an ok message
 180             var pushed = pr.comments().stream()
 181                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 182                            .count();
 183             assertEquals(1, pushed);
 184 
 185             // The change should now be present on the master branch
 186             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 187             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 188             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 189 
 190             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 191             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 192             Set&lt;Hash&gt; commits;
 193             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 194                 commits = tempCommits.stream()
 195                                      .map(Commit::hash)
 196                                      .collect(Collectors.toSet());
 197             }
 198             assertTrue(commits.contains(otherHash1));
 199             assertTrue(commits.contains(otherHash2));
 200             assertFalse(commits.contains(mergeHash));
 201 
 202             // Author and committer should updated in the merge commit
 203             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 204             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 205             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 206             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 207             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 208         }
 209     }
 210 
 211     @Test
 212     void tagMerge(TestInfo testInfo) throws IOException {
 213         try (var credentials = new HostCredentials(testInfo);
 214              var tempFolder = new TemporaryDirectory()) {
 215 
 216             var author = credentials.getHostedRepository();
 217             var integrator = credentials.getHostedRepository();
 218             var censusBuilder = credentials.getCensusBuilder()
 219                                            .addCommitter(author.forge().currentUser().id())
 220                                            .addReviewer(integrator.forge().currentUser().id());
 221             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 222 
 223             // Populate the projects repository
 224             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 225             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 226             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 227             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 228             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 229 
 230             // Make more changes in another branch
 231             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 232                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 233             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 234             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 235                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 236             var tag = localRepo.tag(otherHash2, &quot;othertag&quot;, &quot;Tagging other&quot;, &quot;tagger&quot;, &quot;tagger@one&quot;);
 237             var tagHash = localRepo.lookup(tag).orElseThrow().hash();
 238             localRepo.push(tagHash, author.url(), &quot;refs/tags/othertag&quot;);
 239 
 240             // Go back to the original master
 241             localRepo.checkout(masterHash, true);
 242 
 243             // Make a change with a corresponding PR
 244             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 245             localRepo.add(unrelated);
 246             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 247             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 248 
 249             localRepo.merge(otherHash2);
 250             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 251             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 252             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge othertag&quot;);
 253 
 254             // Approve it as another user
 255             var approvalPr = integrator.pullRequest(pr.id());
 256             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 257 
 258             // Let the bot check the status
 259             TestBotRunner.runPeriodicItems(mergeBot);
 260 
 261             // Push it
 262             pr.addComment(&quot;/integrate&quot;);
 263             TestBotRunner.runPeriodicItems(mergeBot);
 264 
 265             // The bot should reply with an ok message
 266             var pushed = pr.comments().stream()
 267                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 268                            .count();
 269             assertEquals(1, pushed);
 270 
 271             // The change should now be present on the master branch
 272             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 273             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 274             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 275 
 276             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 277             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 278             Set&lt;Hash&gt; commits;
 279             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 280                 commits = tempCommits.stream()
 281                                      .map(Commit::hash)
 282                                      .collect(Collectors.toSet());
 283             }
 284             assertTrue(commits.contains(otherHash1));
 285             assertTrue(commits.contains(otherHash2));
 286             assertFalse(commits.contains(mergeHash));
 287 
 288             // Author and committer should updated in the merge commit
 289             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 290             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 291             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 292             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 293             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 294         }
 295     }
 296 
 297     @Test
 298     void branchMergeRebase(TestInfo testInfo) throws IOException {
 299         try (var credentials = new HostCredentials(testInfo);
 300              var tempFolder = new TemporaryDirectory()) {
 301 
 302             var author = credentials.getHostedRepository();
 303             var integrator = credentials.getHostedRepository();
 304             var censusBuilder = credentials.getCensusBuilder()
 305                                            .addCommitter(author.forge().currentUser().id())
 306                                            .addReviewer(integrator.forge().currentUser().id());
 307             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 308 
 309             // Populate the projects repository
 310             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 311             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 312             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 313             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 314             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 315 
 316             // Make more changes in another branch
 317             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 318                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 319             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 320             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 321                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 322             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 323 
 324             // Go back to the original master
 325             localRepo.checkout(masterHash, true);
 326 
 327             // Make a change with a corresponding PR
 328             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 329             localRepo.add(unrelated);
 330             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 331             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 332 
 333             localRepo.merge(otherHash2);
 334             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 335             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 336             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 337 
 338             // Approve it as another user
 339             var approvalPr = integrator.pullRequest(pr.id());
 340             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 341 
 342             // Let the bot check the status
 343             TestBotRunner.runPeriodicItems(mergeBot);
 344 
 345             // Push something new to master
 346             localRepo.checkout(updatedMaster, true);
 347             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
 348             localRepo.add(newMaster);
 349             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
 350             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
 351 
 352             // Let the bot notice
 353             TestBotRunner.runPeriodicItems(mergeBot);
 354 
 355             // Push it
 356             pr.addComment(&quot;/integrate&quot;);
 357             TestBotRunner.runPeriodicItems(mergeBot);
 358 
 359             // The bot should reply with an ok message
 360             var pushed = pr.comments().stream()
 361                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 362                            .count();
 363             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 364 
 365             // The change should now be present on the master branch
 366             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 367             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 368             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 369 
 370             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 371             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 372             Set&lt;Hash&gt; commits;
 373             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 374                 commits = tempCommits.stream()
 375                         .map(Commit::hash)
 376                         .collect(Collectors.toSet());
 377             }
 378             assertTrue(commits.contains(otherHash1));
 379             assertTrue(commits.contains(otherHash2));
 380             assertFalse(commits.contains(mergeHash));
 381 
 382             // Author and committer should updated in the merge commit
 383             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 384             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 385             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 386             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 387             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 388         }
 389     }
 390 
 391     @Test
 392     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
 393         try (var credentials = new HostCredentials(testInfo);
 394              var tempFolder = new TemporaryDirectory()) {
 395 
 396             var author = credentials.getHostedRepository();
 397             var integrator = credentials.getHostedRepository();
 398             var censusBuilder = credentials.getCensusBuilder()
 399                                            .addCommitter(author.forge().currentUser().id())
 400                                            .addReviewer(integrator.forge().currentUser().id());
 401             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 402 
 403             // Populate the projects repository
 404             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 405             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 406             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 407             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 408             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 409 
 410             // Make more changes in another branch
 411             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 412                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 413             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 414             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 415                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 416             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 417 
 418             // Go back to the original master
 419             localRepo.checkout(masterHash, true);
 420 
 421             // Make a change with a corresponding PR
 422             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 423             localRepo.add(unrelated);
 424             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 425             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 426 
 427             localRepo.merge(otherHash2);
 428             var mergeHash = localRepo.commit(&quot;Our own merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 429             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 430             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 431 
 432             // Approve it as another user
 433             var approvalPr = integrator.pullRequest(pr.id());
 434             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 435 
 436             // Let the bot check the status
 437             TestBotRunner.runPeriodicItems(mergeBot);
 438 
 439             // Push something new to master
 440             localRepo.checkout(updatedMaster, true);
 441             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
 442             localRepo.add(newMaster);
 443             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
 444             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
 445 
 446             // Let the bot notice
 447             TestBotRunner.runPeriodicItems(mergeBot);
 448 
 449             // Add another commit on top of the merge commit
 450             localRepo.checkout(mergeHash, true);
 451             var extraHash = CheckableRepository.appendAndCommit(localRepo, &quot;Fixing up stuff after merge&quot;);
 452             localRepo.push(extraHash, author.url(), &quot;edit&quot;);
 453 
 454             // Let the bot notice again
 455             TestBotRunner.runPeriodicItems(mergeBot);
 456 
 457             // Merge the latest from master
 458             localRepo.merge(newMasterHash);
 459             var latestMergeHash = localRepo.commit(&quot;Our to be squashed merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 460             localRepo.push(latestMergeHash, author.url(), &quot;edit&quot;);
 461 
 462             // Let the bot notice again
 463             TestBotRunner.runPeriodicItems(mergeBot);
 464 
 465             // Push it
 466             pr.addComment(&quot;/integrate&quot;);
 467             TestBotRunner.runPeriodicItems(mergeBot);
 468 
 469             // The bot should reply with an ok message
 470             var pushed = pr.comments().stream()
 471                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 472                            .count();
 473             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 474 
 475             // The change should now be present on the master branch
 476             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 477             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 478             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 479 
 480             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
 481             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
 482             String commits;
 483             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
 484                 commits = tempCommits.stream()
 485                                      .map(c -&gt; c.hash().hex() + &quot;:&quot; + c.message().get(0))
 486                                      .collect(Collectors.joining(&quot;,&quot;));
 487             }
 488             assertTrue(commits.contains(otherHash1.hex() + &quot;:First other&quot;));
 489             assertTrue(commits.contains(otherHash2.hex() + &quot;:Second other&quot;));
 490             assertFalse(commits.contains(&quot;Our own merge commit&quot;));
 491 
 492             // Author and committer should updated in the merge commit
 493             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
 494             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
 495             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
 496             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
 497             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
 498 
 499             // The latest content from the source and the updated master should be present
 500             assertEquals(&quot;New on master&quot;, Files.readString(pushedRepoFolder.resolve(&quot;newmaster.txt&quot;)));
 501             assertEquals(&quot;Unrelated&quot;, Files.readString(pushedRepoFolder.resolve(&quot;unrelated.txt&quot;)));
 502         }
 503     }
 504 
 505     @Test
 506     void invalidMergeCommit(TestInfo testInfo) throws IOException {
 507         try (var credentials = new HostCredentials(testInfo);
 508              var tempFolder = new TemporaryDirectory()) {
 509 
 510             var author = credentials.getHostedRepository();
 511             var integrator = credentials.getHostedRepository();
 512             var censusBuilder = credentials.getCensusBuilder()
 513                                            .addCommitter(author.forge().currentUser().id())
 514                                            .addReviewer(integrator.forge().currentUser().id());
 515             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 516 
 517             // Populate the projects repository
 518             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 519             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 520             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 521             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 522             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 523 
 524             // Make a change in another branch
 525             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 526                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 527             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 528 
 529             // Go back to the original master
 530             localRepo.checkout(masterHash, true);
 531 
 532             // Make a change with a corresponding PR
 533             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 534             localRepo.add(unrelated);
 535             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 536             localRepo.merge(otherHash);
 537             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 538             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 539             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 540 
 541             // Approve it as another user
 542             var approvalPr = integrator.pullRequest(pr.id());
 543             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 544 
 545             // Let the bot check the status
 546             TestBotRunner.runPeriodicItems(mergeBot);
 547 
 548             // Push it
 549             pr.addComment(&quot;/integrate&quot;);
 550             TestBotRunner.runPeriodicItems(mergeBot);
 551 
 552             // The bot will create a proper merge commit
 553             var pushed = pr.comments().stream()
 554                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 555                            .count();
 556             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 557 
 558             // The change should now be present with correct parents on the master branch
 559             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
 560             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
 561             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
 562 
 563             var head = pushedRepo.commitMetadata(&quot;HEAD^!&quot;).get(0);
 564             assertEquals(2, head.parents().size());
 565             assertEquals(masterHash, head.parents().get(0));
 566             assertEquals(otherHash, head.parents().get(1));
 567         }
 568     }
 569 
 570     @Test
 571     void invalidSourceRepo(TestInfo testInfo) throws IOException {
 572         try (var credentials = new HostCredentials(testInfo);
 573              var tempFolder = new TemporaryDirectory()) {
 574 
 575             var author = credentials.getHostedRepository();
 576             var integrator = credentials.getHostedRepository();
 577             var censusBuilder = credentials.getCensusBuilder()
 578                                            .addCommitter(author.forge().currentUser().id())
 579                                            .addReviewer(integrator.forge().currentUser().id());
 580             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 581 
 582             // Populate the projects repository
 583             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 584             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 585             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 586             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 587             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 588 
 589             // Make a change in another branch
 590             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 591                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 592             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 593 
 594             // Go back to the original master
 595             localRepo.checkout(masterHash, true);
 596 
 597             // Make a change with a corresponding PR
 598             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 599             localRepo.add(unrelated);
 600             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 601             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 602 
 603             localRepo.merge(otherHash);
 604             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 605             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 606             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;xyz&quot; + &quot;:other&quot;);
 607 
 608             // Approve it as another user
 609             var approvalPr = integrator.pullRequest(pr.id());
 610             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 611 
 612             // Let the bot check the status
 613             TestBotRunner.runPeriodicItems(mergeBot);
 614 
 615             // Push it
 616             pr.addComment(&quot;/integrate&quot;);
 617             TestBotRunner.runPeriodicItems(mergeBot);
 618 
 619             // The bot should reply with a failure message
 620             var error = pr.comments().stream()
 621                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 622                           .count();
 623             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 624 
 625             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 626             assertEquals(&quot;- Could not find project `&quot; + author.name() + &quot;xyz` - check that it is correct.&quot;, check.summary().orElseThrow());
 627         }
 628     }
 629 
 630     @Test
 631     void invalidSourceBranch(TestInfo testInfo) throws IOException {
 632         try (var credentials = new HostCredentials(testInfo);
 633              var tempFolder = new TemporaryDirectory()) {
 634 
 635             var author = credentials.getHostedRepository();
 636             var integrator = credentials.getHostedRepository();
 637             var censusBuilder = credentials.getCensusBuilder()
 638                                            .addCommitter(author.forge().currentUser().id())
 639                                            .addReviewer(integrator.forge().currentUser().id());
 640             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 641 
 642             // Populate the projects repository
 643             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 644             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 645             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 646             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 647             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 648 
 649             // Make a change in another branch
 650             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 651                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 652             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 653 
 654             // Go back to the original master
 655             localRepo.checkout(masterHash, true);
 656 
 657             // Make a change with a corresponding PR
 658             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 659             localRepo.add(unrelated);
 660             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 661             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 662 
 663             localRepo.merge(otherHash);
 664             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 665             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 666             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:otherxyz&quot;);
 667 
 668             // Approve it as another user
 669             var approvalPr = integrator.pullRequest(pr.id());
 670             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 671 
 672             // Let the bot check the status
 673             TestBotRunner.runPeriodicItems(mergeBot);
 674 
 675             // Push it
 676             pr.addComment(&quot;/integrate&quot;);
 677             TestBotRunner.runPeriodicItems(mergeBot);
 678 
 679             // The bot should reply with a failure message
 680             var error = pr.comments().stream()
 681                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 682                           .count();
 683             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 684 
 685             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 686             assertEquals(&quot;- Could not find the branch or tag `otherxyz` in the project `&quot; + author.name() + &quot;` - check that it is correct.&quot;, check.summary().orElseThrow());
 687         }
 688     }
 689 
 690     @Test
 691     void inferredSourceProject(TestInfo testInfo) throws IOException {
 692         try (var credentials = new HostCredentials(testInfo);
 693              var tempFolder = new TemporaryDirectory()) {
 694 
 695             var author = credentials.getHostedRepository();
 696             var integrator = credentials.getHostedRepository();
 697             var censusBuilder = credentials.getCensusBuilder()
 698                                            .addCommitter(author.forge().currentUser().id())
 699                                            .addReviewer(integrator.forge().currentUser().id());
 700             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 701 
 702             // Populate the projects repository
 703             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 704             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 705             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 706             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 707             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 708 
 709             // Make a change in another branch
 710             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 711                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 712             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 713 
 714             // Go back to the original master
 715             localRepo.checkout(masterHash, true);
 716 
 717             // Make a change with a corresponding PR
 718             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 719             localRepo.add(unrelated);
 720             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 721             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 722 
 723             localRepo.merge(otherHash);
 724             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 725             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 726             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge otherxyz&quot;);
 727 
 728             // Approve it as another user
 729             var approvalPr = integrator.pullRequest(pr.id());
 730             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 731 
 732             // Let the bot check the status
 733             TestBotRunner.runPeriodicItems(mergeBot);
 734 
 735             // Push it
 736             pr.addComment(&quot;/integrate&quot;);
 737             TestBotRunner.runPeriodicItems(mergeBot);
 738 
 739             // The bot should reply with a failure message
 740             var error = pr.comments().stream()
 741                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 742                           .count();
 743             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 744 
 745             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 746             assertEquals(&quot;- Could not find project `otherxyz` - check that it is correct.&quot;, check.summary().orElseThrow());
 747         }
 748     }
 749 
 750     @Test
 751     void wrongSourceBranch(TestInfo testInfo) throws IOException {
 752         try (var credentials = new HostCredentials(testInfo);
 753              var tempFolder = new TemporaryDirectory()) {
 754 
 755             var author = credentials.getHostedRepository();
 756             var integrator = credentials.getHostedRepository();
 757             var censusBuilder = credentials.getCensusBuilder()
 758                                            .addCommitter(author.forge().currentUser().id())
 759                                            .addReviewer(integrator.forge().currentUser().id());
 760             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 761 
 762             // Populate the projects repository
 763             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 764             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 765             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 766             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 767             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 768 
 769             // Make a change in another branch
 770             var other1Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other1&quot;,
 771                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 772             localRepo.push(other1Hash, author.url(), &quot;other1&quot;, true);
 773 
 774             // Go back to the original master
 775             localRepo.checkout(masterHash, true);
 776 
 777             // Make yet another change in another branch
 778             var other2Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other2&quot;,
 779                                                                 &quot;Unrelated\n\nReviewed-by: integrationreviewer2&quot;);
 780             localRepo.push(other2Hash, author.url(), &quot;other2&quot;, true);
 781 
 782             // Make a change with a corresponding PR
 783             localRepo.checkout(masterHash, true);
 784             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 785             localRepo.add(unrelated);
 786             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 787             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 788 
 789             localRepo.merge(other1Hash, &quot;ours&quot;);
 790             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 791             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 792             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other2&quot;);
 793 
 794             // Approve it as another user
 795             var approvalPr = integrator.pullRequest(pr.id());
 796             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 797 
 798             // Let the bot check the status
 799             TestBotRunner.runPeriodicItems(mergeBot);
 800 
 801             // Push it
 802             pr.addComment(&quot;/integrate&quot;);
 803             TestBotRunner.runPeriodicItems(mergeBot);
 804 
 805             // The bot should reply with a failure message
 806             var error = pr.comments().stream()
 807                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 808                           .count();
 809             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 810 
 811             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 812             assertEquals(&quot;- A merge PR must contain at least one commit from the source branch that is not already present in the target.&quot;, check.summary().orElseThrow());
 813         }
 814     }
 815 
 816     @Test
 817     void invalidAuthor(TestInfo testInfo) throws IOException {
 818         try (var credentials = new HostCredentials(testInfo);
 819              var tempFolder = new TemporaryDirectory()) {
 820 
 821             var author = credentials.getHostedRepository();
 822             var integrator = credentials.getHostedRepository();
 823             var censusBuilder = credentials.getCensusBuilder()
 824                                            .addAuthor(author.forge().currentUser().id())
 825                                            .addReviewer(integrator.forge().currentUser().id());
 826             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 827 
 828             // Populate the projects repository
 829             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 830             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 831             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 832             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 833             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 834 
 835             // Make a change in another branch
 836             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 837                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 838             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 839 
 840             // Go back to the original master
 841             localRepo.checkout(masterHash, true);
 842 
 843             // Make a change with a corresponding PR
 844             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 845             localRepo.add(unrelated);
 846             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 847             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 848 
 849             localRepo.merge(otherHash);
 850             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 851             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 852             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 853 
 854             // Approve it as another user
 855             var approvalPr = integrator.pullRequest(pr.id());
 856             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 857 
 858             // Let the bot check the status
 859             TestBotRunner.runPeriodicItems(mergeBot);
 860 
 861             // Push it
 862             pr.addComment(&quot;/integrate&quot;);
 863             TestBotRunner.runPeriodicItems(mergeBot);
 864 
 865             // The bot should reply with a need for sponsor
 866             var error = pr.comments().stream()
 867                           .filter(comment -&gt; comment.body().contains(&quot;Afterwards, your sponsor types `/sponsor`&quot;))
 868                           .count();
 869             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 870         }
 871     }
 872 
 873     @Test
 874     void unrelatedHistory(TestInfo testInfo) throws IOException {
 875         try (var credentials = new HostCredentials(testInfo);
 876              var tempFolder = new TemporaryDirectory()) {
 877 
 878             var author = credentials.getHostedRepository();
 879             // Need to force merge unrelated histories
 880             assumeTrue(author.repositoryType().equals(VCS.GIT));
 881 
 882             var integrator = credentials.getHostedRepository();
 883             var censusBuilder = credentials.getCensusBuilder()
 884                                            .addCommitter(author.forge().currentUser().id())
 885                                            .addReviewer(integrator.forge().currentUser().id());
 886             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 887 
 888             // Populate the projects repository
 889             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 890             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 891             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 892 
 893             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 894             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 895 
 896             // Make an unrelated change in another branch
 897             var unrelatedRepoFolder = tempFolder.path().resolve(&quot;unrelated&quot;);
 898             var unrelatedRepo = CheckableRepository.init(unrelatedRepoFolder, author.repositoryType(), Path.of(&quot;anotherfile.txt&quot;));
 899             unrelatedRepo.amend(&quot;Unrelated initial commit\n\nReviewed-by: integrationreviewer2&quot;, &quot;some&quot;, &quot;one@mail&quot;);
 900             var otherHash = CheckableRepository.appendAndCommit(unrelatedRepo, &quot;Change in other&quot;,
 901                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 902             unrelatedRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 903             localRepo.fetch(author.url(), &quot;other&quot;);
 904 
 905             // Go back to the original master
 906             localRepo.checkout(masterHash, true);
 907 
 908             // Make a change with a corresponding PR
 909             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 910             localRepo.add(unrelated);
 911             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 912             var mergeCmd = Process.command(&quot;git&quot;, &quot;merge&quot;, &quot;--no-commit&quot;, &quot;--allow-unrelated-histories&quot;, &quot;-s&quot;, &quot;ours&quot;, otherHash.hex())
 913                                   .workdir(localRepo.root())
 914                                   .environ(&quot;GIT_AUTHOR_NAME&quot;, &quot;some&quot;)
 915                                   .environ(&quot;GIT_AUTHOR_EMAIL&quot;, &quot;some@one&quot;)
 916                                   .environ(&quot;GIT_COMMITTER_NAME&quot;, &quot;another&quot;)
 917                                   .environ(&quot;GIT_COMMITTER_EMAIL&quot;, &quot;another@one&quot;)
 918                                   .execute();
 919             mergeCmd.check();
 920 
 921             //localRepo.merge(otherHash);
 922             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 923             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 924             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 925 
 926             // Approve it as another user
 927             var approvalPr = integrator.pullRequest(pr.id());
 928             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 929 
 930             // Let the bot check the status
 931             TestBotRunner.runPeriodicItems(mergeBot);
 932 
 933             // Push it
 934             pr.addComment(&quot;/integrate&quot;);
 935             TestBotRunner.runPeriodicItems(mergeBot);
 936 
 937             // The bot should reply with a failure message
 938             var error = pr.comments().stream()
 939                     .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 940                     .count();
 941             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 942 
 943             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
 944             assertEquals(&quot;- The target and the source branches do not share common history - cannot merge them.&quot;, check.summary().orElseThrow());
 945         }
 946     }
 947 
 948     @Test
 949     void invalidSyntax(TestInfo testInfo) throws IOException {
 950         try (var credentials = new HostCredentials(testInfo);
 951              var tempFolder = new TemporaryDirectory()) {
 952 
 953             var author = credentials.getHostedRepository();
 954             var integrator = credentials.getHostedRepository();
 955             var censusBuilder = credentials.getCensusBuilder()
 956                                            .addCommitter(author.forge().currentUser().id())
 957                                            .addReviewer(integrator.forge().currentUser().id());
 958             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 959 
 960             // Populate the projects repository
 961             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 962             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(&quot;appendable.txt&quot;), Set.of(&quot;merge&quot;), &quot;1.0&quot;);
 963             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 964             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 965             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 966 
 967             // Make a change in another branch
 968             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
 969                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
 970             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
 971 
 972             // Go back to the original master
 973             localRepo.checkout(masterHash, true);
 974 
 975             // Make a change with a corresponding PR
 976             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 977             localRepo.add(unrelated);
 978             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 979             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 980 
 981             localRepo.merge(otherHash);
 982             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 983             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 984             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge this or that&quot;);
 985 
 986             // Let the bot check the status
 987             TestBotRunner.runPeriodicItems(mergeBot);
 988 
 989             // Push it
 990             pr.addComment(&quot;/integrate&quot;);
 991             TestBotRunner.runPeriodicItems(mergeBot);
 992 
 993             // The bot should reply with a failure message
 994             var error = pr.comments().stream()
 995                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
 996                           .count();
 997             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
 998 
 999             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
1000             assertEquals(&quot;- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.&quot;, check.summary().orElseThrow());
1001         }
1002     }
<a name="2" id="anc2"></a>

































































1003 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
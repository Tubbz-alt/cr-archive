diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
@@ -39,12 +39,11 @@
     }
 
     private static Optional<Commit> mergeCommit(PullRequest pr, Repository localRepo, Hash head) {
         try {
             var author = new Author("duke", "duke@openjdk.org");
-            var prUtils = new PullRequestUtils(pr);
-            var hash = prUtils.createCommit(localRepo, head, author, author, pr.title());
+            var hash = PullRequestUtils.createCommit(pr, localRepo, head, author, author, pr.title());
             return localRepo.lookup(hash);
         } catch (IOException | CommitFailure e) {
             return Optional.empty();
         }
     }
@@ -58,12 +57,11 @@
                                                                                               "PR-Thread-Prefix", threadPrefix),
                                () -> subjectPrefix + threadPrefix + (threadPrefix.isEmpty() ? "" : ": ") + pr.title(),
                                () -> "",
                                () -> ArchiveMessages.composeConversation(pr),
                                () -> {
-                                   var prUtils = new PullRequestUtils(pr);
-                                   if (prUtils.isMerge()) {
+                                   if (PullRequestUtils.isMerge(pr)) {
                                        //TODO: Try to merge in target - generate possible conflict webrev
                                        var mergeCommit = mergeCommit(pr, localRepo, head);
                                        var mergeWebrevs = new ArrayList<WebrevDescription>();
                                        if (mergeCommit.isPresent()) {
                                            for (int i = 0; i < mergeCommit.get().parentDiffs().size(); ++i) {
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
@@ -290,13 +290,12 @@
         // Materialize the PR's target ref
         try {
             // Materialize the PR's source and target ref
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
-            var localRepoPath = scratchPath.resolve("mlbridge-mergebase");
-            var localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(pr.repository().name()));
-            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":archiveworkitem", false);
+            var localRepoPath = scratchPath.resolve("mlbridge-mergebase").resolve(pr.repository().name());
+            var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, localRepoPath);
 
             var webrevPath = scratchPath.resolve("mlbridge-webrevs");
             var listServer = MailingListServerFactory.createMailmanServer(bot.listArchive(), bot.smtpServer(), bot.sendInterval());
             var list = listServer.getList(bot.listAddress().address());
 
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -91,12 +91,11 @@
                 lastHead = curHead;
             }
         }
 
         // Check if we're at a revision not previously reported
-        var prUtils = new PullRequestUtils(pr);
-        var baseHash = prUtils.baseHash(localRepo);
+        var baseHash = PullRequestUtils.baseHash(pr, localRepo);
         if (!baseHash.equals(lastBase) || !pr.headHash().equals(lastHead)) {
             if (generated.isEmpty()) {
                 var first = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), baseHash, pr.headHash(), subjectPrefix, threadPrefix);
                 generated.add(first);
             } else {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -69,12 +69,11 @@
         this.labels = new HashSet<>(labels);
         this.newLabels = new HashSet<>(labels);
         this.censusInstance = censusInstance;
         this.ignoreStaleReviews = ignoreStaleReviews;
 
-        var prUtils = new PullRequestUtils(pr);
-        baseHash = prUtils.baseHash(localRepo);
+        baseHash = PullRequestUtils.baseHash(pr, localRepo);
         checkablePullRequest = new CheckablePullRequest(pr, localRepo, ignoreStaleReviews);
     }
 
     static void execute(CheckWorkItem workItem, PullRequest pr, Repository localRepo, List<Comment> comments,
                         List<Review> allReviews, List<Review> activeReviews, Set<String> labels, CensusInstance censusInstance,
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
@@ -148,13 +148,12 @@
             }
 
             try {
                 var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
                 var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
-                var localRepoPath = scratchPath.resolve("pr").resolve("check");
-                var localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(pr.repository().name()));
-                localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":checkworkitem", false);
+                var localRepoPath = scratchPath.resolve("pr").resolve("check").resolve(pr.repository().name());
+                var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, localRepoPath);
 
                 CheckRun.execute(this, pr, localRepo, comments, allReviews, activeReviews, labels, census, bot.ignoreStaleReviews());
             } catch (IOException e) {
                 throw new UncheckedIOException(e);
             }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
@@ -92,14 +92,12 @@
     Hash commit(Hash finalHead, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
         Author committer;
         Author author;
         var contributor = namespace.get(pr.author().id());
 
-        var prUtils = new PullRequestUtils(pr);
-
         if (contributor == null) {
-            if (prUtils.isMerge()) {
+            if (PullRequestUtils.isMerge(pr)) {
                 throw new CommitFailure("Merges can only be performed by Committers.");
             }
 
             // Use the information contained in the head commit - jcheck has verified that it contains sane values
             var headCommit = localRepo.commitMetadata(pr.headHash().hex() + "^.." + pr.headHash().hex()).get(0);
@@ -115,11 +113,11 @@
             committer = author;
         }
 
         var activeReviews = filterActiveReviews(pr.reviews());
         var commitMessage = commitMessage(activeReviews, namespace);
-        return prUtils.createCommit(localRepo, finalHead, author, committer, commitMessage);
+        return PullRequestUtils.createCommit(pr, localRepo, finalHead, author, committer, commitMessage);
     }
 
     PullRequestCheckIssueVisitor createVisitor(Hash localHash, CensusInstance censusInstance) throws IOException {
         var checks = JCheck.checksFor(localRepo, censusInstance.census(), pr.targetHash());
         return new PullRequestCheckIssueVisitor(checks);
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
@@ -25,12 +25,10 @@
 import org.openjdk.skara.forge.*;
 import org.openjdk.skara.issuetracker.Comment;
 import org.openjdk.skara.vcs.Hash;
 
 import java.io.*;
-import java.net.URLEncoder;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
 import java.util.*;
 import java.util.logging.Logger;
 
 public class IntegrateCommand implements CommandHandler {
@@ -86,16 +84,14 @@
             }
         }
 
         // Run a final jcheck to ensure the change has been properly reviewed
         try {
-            var sanitizedUrl = URLEncoder.encode(pr.repository().webUrl().toString(), StandardCharsets.UTF_8);
-            var path = scratchPath.resolve("integrate").resolve(sanitizedUrl);
+            var path = scratchPath.resolve("integrate").resolve(pr.repository().name());
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
-            var localRepo = hostedRepositoryPool.checkout(pr, path);
-            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":integratecommand", false);
+            var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);
             var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews());
 
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
@@ -41,12 +41,11 @@
         return "LabelerWorkItem@" + pr.repository().name() + "#" + pr.id();
     }
 
     private Set<String> getLabels(Repository localRepo) throws IOException {
         var labels = new HashSet<String>();
-        var prUtils = new PullRequestUtils(pr);
-        var files = prUtils.changedFiles(localRepo);
+        var files = PullRequestUtils.changedFiles(pr, localRepo);
         for (var file : files) {
             for (var label : bot.labelPatterns().entrySet()) {
                 for (var pattern : label.getValue()) {
                     var matcher = pattern.matcher(file.toString());
                     if (matcher.find()) {
@@ -66,12 +65,11 @@
         }
         try {
             var path = scratchPath.resolve("pr").resolve("labeler").resolve(pr.repository().name());
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
-            var localRepo = hostedRepositoryPool.checkout(pr, path);
-            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":labelerworkitem", false);
+            var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);
             var newLabels = getLabels(localRepo);
             var currentLabels = pr.labels().stream()
                                   .filter(key -> bot.labelPatterns().containsKey(key))
                                   .collect(Collectors.toSet());
 
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
@@ -25,12 +25,10 @@
 import org.openjdk.skara.forge.*;
 import org.openjdk.skara.issuetracker.Comment;
 import org.openjdk.skara.vcs.Hash;
 
 import java.io.*;
-import java.net.URLEncoder;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
 import java.util.*;
 import java.util.logging.Logger;
 
 public class SponsorCommand implements CommandHandler {
@@ -71,16 +69,14 @@
         // Notify the author as well
         reply.print("@" + pr.author().userName() + " ");
 
         // Execute merge
         try {
-            var sanitizedUrl = URLEncoder.encode(pr.repository().webUrl().toString(), StandardCharsets.UTF_8);
-            var path = scratchPath.resolve("sponsor").resolve(sanitizedUrl);
+            var path = scratchPath.resolve("sponsor").resolve(pr.repository().name());
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
-            var localRepo = hostedRepositoryPool.checkout(pr, path);
-            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":sponsorcommand", false);
+            var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);
             var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews());
 
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
diff a/forge/src/main/java/org/openjdk/skara/forge/HostedRepositoryPool.java b/forge/src/main/java/org/openjdk/skara/forge/HostedRepositoryPool.java
--- a/forge/src/main/java/org/openjdk/skara/forge/HostedRepositoryPool.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/HostedRepositoryPool.java
@@ -169,10 +169,6 @@
             localRepo = clone.repository();
             localRepo.checkout(clone.fetchHead(), true);
         }
         return localRepo;
     }
-
-    public Repository checkout(PullRequest pr, Path path) throws IOException {
-        return checkout(pr.repository(), pr.headHash().hex(), path);
-    }
 }
diff a/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java b/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
--- a/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
@@ -29,17 +29,11 @@
 import java.time.ZonedDateTime;
 import java.util.*;
 import java.util.regex.Pattern;
 
 public class PullRequestUtils {
-    private final PullRequest pr;
-
-    public PullRequestUtils(PullRequest pr)  {
-        this.pr = pr;
-    }
-
-    private Hash commitSquashed(Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException {
+    private static Hash commitSquashed(PullRequest pr, Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException {
         return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
                                 committer.name(), committer.email(), ZonedDateTime.now(), List.of(pr.targetHash()), localRepo.tree(finalHead));
     }
 
     private static class MergeSource {
@@ -50,25 +44,25 @@
             this.repositoryName = repositoryName;
             this.branchName = branchName;
         }
     }
 
-    private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
-    private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
+    private final static Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
+    private final static Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
 
-    private Optional<MergeSource> mergeSource(Repository localRepo) {
+    private static Optional<MergeSource> mergeSource(PullRequest pr, Repository localRepo) {
         var repoMatcher = mergeSourceFullPattern.matcher(pr.title());
         if (!repoMatcher.matches()) {
             var branchMatcher = mergeSourceBranchOnlyPattern.matcher(pr.title());
             if (!branchMatcher.matches()) {
                 return Optional.empty();
             }
 
             // Verify that the branch exists
-            var isValidBranch = remoteBranches(localRepo).stream()
-                    .map(Reference::name)
-                    .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
+            var isValidBranch = remoteBranches(pr, localRepo).stream()
+                                                             .map(Reference::name)
+                                                             .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
             if (!isValidBranch) {
                 // Assume the name refers to a sibling repository
                 var repoName = Path.of(pr.repository().name()).resolveSibling(branchMatcher.group(1)).toString();
                 return Optional.of(new MergeSource(repoName, "master"));
             }
@@ -77,16 +71,16 @@
         }
 
         return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
     }
 
-    private CommitMetadata findSourceMergeCommit(Repository localRepo, List<CommitMetadata> commits) throws IOException, CommitFailure {
+    private static CommitMetadata findSourceMergeCommit(PullRequest pr, Repository localRepo, List<CommitMetadata> commits) throws IOException, CommitFailure {
         if (commits.size() < 2) {
             throw new CommitFailure("A merge PR must contain at least two commits that are not already present in the target.");
         }
 
-        var source = mergeSource(localRepo);
+        var source = mergeSource(pr, localRepo);
         if (source.isEmpty()) {
             throw new CommitFailure("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
                     "Merge `project`:`branch` to allow verification of the merge contents.");
         }
 
@@ -129,13 +123,13 @@
         }
 
         return commits.get(mergeCommitIndex);
     }
 
-    private Hash commitMerge(Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
-        var commits = localRepo.commitMetadata(baseHash(localRepo), finalHead);
-        var mergeCommit = findSourceMergeCommit(localRepo, commits);
+    private static Hash commitMerge(PullRequest pr, Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
+        var commits = localRepo.commitMetadata(baseHash(pr, localRepo), finalHead);
+        var mergeCommit = findSourceMergeCommit(pr, localRepo, commits);
 
         // Find the parent which is on the target branch - we will replace it with the target hash (if there were no merge conflicts)
         Hash firstParent = null;
         var finalParents = new ArrayList<Hash>();
         for (int i = 0; i < mergeCommit.parents().size(); ++i) {
@@ -154,40 +148,46 @@
 
         return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
                 committer.name(), committer.email(), ZonedDateTime.now(), finalParents, localRepo.tree(finalHead));
     }
 
-    public boolean isMerge() {
+    public static Repository materialize(HostedRepositoryPool hostedRepositoryPool, PullRequest pr, Path path) throws IOException {
+        var localRepo = hostedRepositoryPool.checkout(pr.repository(), pr.headHash().hex(), path);
+        localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":prutils_targetref", false);
+        return localRepo;
+    }
+
+    public static boolean isMerge(PullRequest pr) {
         return pr.title().startsWith("Merge");
     }
 
-    public Hash createCommit(Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
+    public static Hash createCommit(PullRequest pr, Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
         Hash commit;
-        if (!isMerge()) {
-            commit = commitSquashed(localRepo, finalHead, author, committer, commitMessage);
+        if (!isMerge(pr)) {
+            commit = commitSquashed(pr, localRepo, finalHead, author, committer, commitMessage);
         } else {
-            commit = commitMerge(localRepo, finalHead, author, committer, commitMessage);
+            commit = commitMerge(pr, localRepo, finalHead, author, committer, commitMessage);
         }
         localRepo.checkout(commit, true);
         return commit;
     }
 
-    public Hash baseHash(Repository localRepo) throws IOException {
+    public static Hash baseHash(PullRequest pr, Repository localRepo) throws IOException {
         return localRepo.mergeBase(pr.targetHash(), pr.headHash());
     }
 
-    public Set<Path> changedFiles(Repository localRepo) throws IOException {
+    public static Set<Path> changedFiles(PullRequest pr, Repository localRepo) throws IOException {
         var ret = new HashSet<Path>();
-        var changes = localRepo.diff(baseHash(localRepo), pr.headHash());
+        var changes = localRepo.diff(baseHash(pr, localRepo), pr.headHash());
         for (var patch : changes.patches()) {
             patch.target().path().ifPresent(ret::add);
             patch.source().path().ifPresent(ret::add);
         }
         return ret;
     }
 
-    private List<Reference> remoteBranches(Repository localRepo) {
+    private static List<Reference> remoteBranches(PullRequest pr, Repository localRepo) {
         try {
             return localRepo.remoteBranches(pr.repository().url().toString());
         } catch (IOException e) {
             return List.of();
         }

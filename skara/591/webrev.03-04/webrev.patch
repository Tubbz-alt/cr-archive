diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
@@ -461,18 +461,25 @@
 
             // Push it
             pr.addComment("/integrate");
             TestBotRunner.runPeriodicItems(mergeBot);
 
-            // The bot should reply with a failure message
-            var error = pr.comments().stream()
-                          .filter(comment -> comment.body().contains("did not complete successfully"))
-                          .count();
-            assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
+            // The bot will create a proper merge commit
+            var pushed = pr.comments().stream()
+                           .filter(comment -> comment.body().contains("Pushed as commit"))
+                           .count();
+            assertEquals(1, pushed, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
-            var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- The merge commit must have a commit on the target branch as one of its parents.", check.summary().orElseThrow());
+            // The change should now be present with correct parents on the master branch
+            var pushedRepoFolder = tempFolder.path().resolve("pushedrepo");
+            var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), "master");
+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
+
+            var head = pushedRepo.commitMetadata("HEAD^!").get(0);
+            assertEquals(2, head.parents().size());
+            assertEquals(masterHash, head.parents().get(0));
+            assertEquals(otherHash, head.parents().get(1));
         }
     }
 
     @Test
     void invalidSourceRepo(TestInfo testInfo) throws IOException {
@@ -714,11 +721,11 @@
                           .filter(comment -> comment.body().contains("did not complete successfully"))
                           .count();
             assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
             var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- A merge PR must contain a merge commit as well as at least one other commit from the merge source.", check.summary().orElseThrow());
+            assertEquals("- A merge PR must contain at least one commit from the source branch that is not already present in the target.", check.summary().orElseThrow());
         }
     }
 
     @Test
     void invalidAuthor(TestInfo testInfo) throws IOException {
@@ -846,11 +853,11 @@
                     .filter(comment -> comment.body().contains("did not complete successfully"))
                     .count();
             assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
             var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- The merge commit must have a commit on the target branch as one of its parents.", check.summary().orElseThrow());
+            assertEquals("- The target and the source branches do not share common history - cannot merge them.", check.summary().orElseThrow());
         }
     }
 
     @Test
     void invalidSyntax(TestInfo testInfo) throws IOException {
diff a/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java b/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
--- a/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
+++ b/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
@@ -27,10 +27,11 @@
 import java.io.*;
 import java.nio.file.Path;
 import java.time.ZonedDateTime;
 import java.util.*;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 public class PullRequestUtils {
     private static Hash commitSquashed(PullRequest pr, Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException {
         return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
                                 committer.name(), committer.email(), ZonedDateTime.now(), List.of(pr.targetHash()), localRepo.tree(finalHead));
@@ -71,85 +72,64 @@
         }
 
         return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
     }
 
-    private static CommitMetadata findSourceMergeCommit(PullRequest pr, Repository localRepo, List<CommitMetadata> commits) throws IOException, CommitFailure {
-        if (commits.size() < 2) {
-            throw new CommitFailure("A merge PR must contain at least two commits that are not already present in the target.");
+    private static Hash findSourceHash(PullRequest pr, Repository localRepo, List<CommitMetadata> commits) throws IOException, CommitFailure {
+        if (commits.size() < 1) {
+            throw new CommitFailure("A merge PR must contain at least one commit that is not already present in the target.");
         }
 
         var source = mergeSource(pr, localRepo);
         if (source.isEmpty()) {
             throw new CommitFailure("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
                     "Merge `project`:`branch` to allow verification of the merge contents.");
         }
 
         // Fetch the source
-        Hash sourceHash;
+        Hash sourceHead;
         try {
             var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() ->
                     new RuntimeException("Could not find repository " + source.get().repositoryName)
             );
             try {
-                sourceHash = localRepo.fetch(mergeSourceRepo.url(), source.get().branchName, false);
+                sourceHead = localRepo.fetch(mergeSourceRepo.url(), source.get().branchName, false);
             } catch (IOException e) {
                 throw new CommitFailure("Could not fetch branch `" + source.get().branchName + "` from project `" +
                         source.get().repositoryName + "` - check that they are correct.");
             }
         } catch (RuntimeException e) {
             throw new CommitFailure("Could not find project `" +
                     source.get().repositoryName + "` - check that it is correct.");
         }
 
-
-        // Find the first merge commit with a parent that is an ancestor of the source
-        int mergeCommitIndex = commits.size();
-        for (int i = 0; i < commits.size() - 1; ++i) {
-            if (commits.get(i).isMerge()) {
-                boolean isSourceMerge = false;
-                for (int j = 0; j < commits.get(i).parents().size(); ++j) {
-                    if (localRepo.isAncestor(commits.get(i).parents().get(j), sourceHash)) {
-                        isSourceMerge = true;
-                    }
-                }
-                if (isSourceMerge) {
-                    mergeCommitIndex = i;
-                    break;
-                }
-            }
+        // Ensure that the source and the target are related
+        try {
+            localRepo.mergeBase(pr.targetHash(), sourceHead);
+        } catch (IOException e) {
+            throw new CommitFailure("The target and the source branches do not share common history - cannot merge them.");
         }
-        if (mergeCommitIndex >= commits.size() - 1) {
-            throw new CommitFailure("A merge PR must contain a merge commit as well as at least one other commit from the merge source.");
+
+        // Find the most recent commit from the merge source not present in the target
+        var sourceHash = localRepo.mergeBase(pr.headHash(), sourceHead);
+        var commitHashes = commits.stream()
+                                  .map(CommitMetadata::hash)
+                                  .collect(Collectors.toSet());
+        if (!commitHashes.contains(sourceHash)) {
+            throw new CommitFailure("A merge PR must contain at least one commit from the source branch that is not already present in the target.");
         }
 
-        return commits.get(mergeCommitIndex);
+        return sourceHash;
     }
 
     private static Hash commitMerge(PullRequest pr, Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
         var commits = localRepo.commitMetadata(baseHash(pr, localRepo), finalHead);
-        var mergeCommit = findSourceMergeCommit(pr, localRepo, commits);
-
-        // Find the parent which is on the target branch - we will replace it with the target hash (if there were no merge conflicts)
-        Hash firstParent = null;
-        var finalParents = new ArrayList<Hash>();
-        for (int i = 0; i < mergeCommit.parents().size(); ++i) {
-            if (localRepo.isAncestor(mergeCommit.parents().get(i), pr.targetHash())) {
-                if (firstParent == null) {
-                    firstParent = localRepo.mergeBase(pr.targetHash(), finalHead);
-                    continue;
-                }
-            }
-            finalParents.add(mergeCommit.parents().get(i));
-        }
-        if (firstParent == null) {
-            throw new CommitFailure("The merge commit must have a commit on the target branch as one of its parents.");
-        }
-        finalParents.add(0, firstParent);
+        var sourceHash = findSourceHash(pr, localRepo, commits);
+        var parents = List.of(localRepo.mergeBase(pr.targetHash(), finalHead), sourceHash);
 
         return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
-                committer.name(), committer.email(), ZonedDateTime.now(), finalParents, localRepo.tree(finalHead));
+                committer.name(), committer.email(), ZonedDateTime.now(), parents, localRepo.tree(finalHead));
     }
 
     public static Repository materialize(HostedRepositoryPool hostedRepositoryPool, PullRequest pr, Path path) throws IOException {
         var localRepo = hostedRepositoryPool.checkout(pr.repository(), pr.headHash().hex(), path);
         localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":prutils_targetref", false);

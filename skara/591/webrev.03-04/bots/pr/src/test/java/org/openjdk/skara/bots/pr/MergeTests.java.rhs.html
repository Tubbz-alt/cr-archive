<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.bots.pr;
 24 
 25 import org.openjdk.skara.forge.Review;
 26 import org.openjdk.skara.issuetracker.Comment;
 27 import org.openjdk.skara.process.Process;
 28 import org.openjdk.skara.test.*;
 29 import org.openjdk.skara.vcs.*;
 30 
 31 import org.junit.jupiter.api.*;
 32 
 33 import java.io.IOException;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.*;
 36 import java.util.Set;
 37 import java.util.stream.Collectors;
 38 
 39 import static org.junit.jupiter.api.Assertions.*;
 40 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 41 
 42 class MergeTests {
 43     @Test
 44     void branchMerge(TestInfo testInfo) throws IOException {
 45         try (var credentials = new HostCredentials(testInfo);
 46              var tempFolder = new TemporaryDirectory()) {
 47 
 48             var author = credentials.getHostedRepository();
 49             var integrator = credentials.getHostedRepository();
 50             var censusBuilder = credentials.getCensusBuilder()
 51                                            .addCommitter(author.forge().currentUser().id())
 52                                            .addReviewer(integrator.forge().currentUser().id());
 53             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 54 
 55             // Populate the projects repository
 56             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 57             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 58             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 59             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 60             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 61 
 62             // Make more changes in another branch
 63             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 64                                                                 &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 65             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 66             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 67                                                                 &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 68             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 69 
 70             // Go back to the original master
 71             localRepo.checkout(masterHash, true);
 72 
 73             // Make a change with a corresponding PR
 74             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 75             localRepo.add(unrelated);
 76             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 77             localRepo.merge(otherHash2);
 78             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 79 
 80             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 81             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 82             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 83 
 84             // Approve it as another user
 85             var approvalPr = integrator.pullRequest(pr.id());
 86             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 87 
 88             // Let the bot check the status
 89             TestBotRunner.runPeriodicItems(mergeBot);
 90 
 91             // Push it
 92             pr.addComment(&quot;/integrate&quot;);
 93             TestBotRunner.runPeriodicItems(mergeBot);
 94 
 95             // The bot should reply with an ok message
 96             var pushed = pr.comments().stream()
 97                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 98                            .count();
 99             assertEquals(1, pushed);
100 
101             // The change should now be present on the master branch
102             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
103             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
104             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
105 
106             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
107             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
108             Set&lt;Hash&gt; commits;
109             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
110                 commits = tempCommits.stream()
111                         .map(Commit::hash)
112                         .collect(Collectors.toSet());
113             }
114             assertTrue(commits.contains(otherHash1));
115             assertTrue(commits.contains(otherHash2));
116             assertFalse(commits.contains(mergeHash));
117 
118             // Author and committer should updated in the merge commit
119             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
120             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
121             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
122             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
123             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
124         }
125     }
126 
127     @Test
128     void branchMergeShortName(TestInfo testInfo) throws IOException {
129         try (var credentials = new HostCredentials(testInfo);
130              var tempFolder = new TemporaryDirectory()) {
131 
132             var author = credentials.getHostedRepository();
133             var integrator = credentials.getHostedRepository();
134             var censusBuilder = credentials.getCensusBuilder()
135                                            .addCommitter(author.forge().currentUser().id())
136                                            .addReviewer(integrator.forge().currentUser().id());
137             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
138 
139             // Populate the projects repository
140             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
141             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
142             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
143             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
144             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
145 
146             // Make more changes in another branch
147             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
148                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
149             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
150             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
151                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
152             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
153 
154             // Go back to the original master
155             localRepo.checkout(masterHash, true);
156 
157             // Make a change with a corresponding PR
158             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
159             localRepo.add(unrelated);
160             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
161             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
162 
163             localRepo.merge(otherHash2);
164             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
165             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
166             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge other&quot;);
167 
168             // Approve it as another user
169             var approvalPr = integrator.pullRequest(pr.id());
170             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
171 
172             // Let the bot check the status
173             TestBotRunner.runPeriodicItems(mergeBot);
174 
175             // Push it
176             pr.addComment(&quot;/integrate&quot;);
177             TestBotRunner.runPeriodicItems(mergeBot);
178 
179             // The bot should reply with an ok message
180             var pushed = pr.comments().stream()
181                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
182                            .count();
183             assertEquals(1, pushed);
184 
185             // The change should now be present on the master branch
186             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
187             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
188             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
189 
190             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
191             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
192             Set&lt;Hash&gt; commits;
193             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
194                 commits = tempCommits.stream()
195                                      .map(Commit::hash)
196                                      .collect(Collectors.toSet());
197             }
198             assertTrue(commits.contains(otherHash1));
199             assertTrue(commits.contains(otherHash2));
200             assertFalse(commits.contains(mergeHash));
201 
202             // Author and committer should updated in the merge commit
203             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
204             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
205             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
206             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
207             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
208         }
209     }
210 
211     @Test
212     void branchMergeRebase(TestInfo testInfo) throws IOException {
213         try (var credentials = new HostCredentials(testInfo);
214              var tempFolder = new TemporaryDirectory()) {
215 
216             var author = credentials.getHostedRepository();
217             var integrator = credentials.getHostedRepository();
218             var censusBuilder = credentials.getCensusBuilder()
219                                            .addCommitter(author.forge().currentUser().id())
220                                            .addReviewer(integrator.forge().currentUser().id());
221             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
222 
223             // Populate the projects repository
224             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
225             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
226             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
227             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
228             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
229 
230             // Make more changes in another branch
231             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
232                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
233             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
234             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
235                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
236             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
237 
238             // Go back to the original master
239             localRepo.checkout(masterHash, true);
240 
241             // Make a change with a corresponding PR
242             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
243             localRepo.add(unrelated);
244             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
245             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
246 
247             localRepo.merge(otherHash2);
248             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
249             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
250             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
251 
252             // Approve it as another user
253             var approvalPr = integrator.pullRequest(pr.id());
254             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
255 
256             // Let the bot check the status
257             TestBotRunner.runPeriodicItems(mergeBot);
258 
259             // Push something new to master
260             localRepo.checkout(updatedMaster, true);
261             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
262             localRepo.add(newMaster);
263             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
264             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
265 
266             // Let the bot notice
267             TestBotRunner.runPeriodicItems(mergeBot);
268 
269             // Push it
270             pr.addComment(&quot;/integrate&quot;);
271             TestBotRunner.runPeriodicItems(mergeBot);
272 
273             // The bot should reply with an ok message
274             var pushed = pr.comments().stream()
275                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
276                            .count();
277             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
278 
279             // The change should now be present on the master branch
280             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
281             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
282             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
283 
284             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
285             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
286             Set&lt;Hash&gt; commits;
287             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
288                 commits = tempCommits.stream()
289                         .map(Commit::hash)
290                         .collect(Collectors.toSet());
291             }
292             assertTrue(commits.contains(otherHash1));
293             assertTrue(commits.contains(otherHash2));
294             assertFalse(commits.contains(mergeHash));
295 
296             // Author and committer should updated in the merge commit
297             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
298             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
299             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
300             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
301             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
302         }
303     }
304 
305     @Test
306     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
307         try (var credentials = new HostCredentials(testInfo);
308              var tempFolder = new TemporaryDirectory()) {
309 
310             var author = credentials.getHostedRepository();
311             var integrator = credentials.getHostedRepository();
312             var censusBuilder = credentials.getCensusBuilder()
313                                            .addCommitter(author.forge().currentUser().id())
314                                            .addReviewer(integrator.forge().currentUser().id());
315             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
316 
317             // Populate the projects repository
318             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
319             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
320             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
321             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
322             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
323 
324             // Make more changes in another branch
325             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
326                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
327             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
328             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
329                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
330             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
331 
332             // Go back to the original master
333             localRepo.checkout(masterHash, true);
334 
335             // Make a change with a corresponding PR
336             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
337             localRepo.add(unrelated);
338             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
339             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
340 
341             localRepo.merge(otherHash2);
342             var mergeHash = localRepo.commit(&quot;Our own merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
343             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
344             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
345 
346             // Approve it as another user
347             var approvalPr = integrator.pullRequest(pr.id());
348             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
349 
350             // Let the bot check the status
351             TestBotRunner.runPeriodicItems(mergeBot);
352 
353             // Push something new to master
354             localRepo.checkout(updatedMaster, true);
355             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
356             localRepo.add(newMaster);
357             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
358             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
359 
360             // Let the bot notice
361             TestBotRunner.runPeriodicItems(mergeBot);
362 
363             // Add another commit on top of the merge commit
364             localRepo.checkout(mergeHash, true);
365             var extraHash = CheckableRepository.appendAndCommit(localRepo, &quot;Fixing up stuff after merge&quot;);
366             localRepo.push(extraHash, author.url(), &quot;edit&quot;);
367 
368             // Let the bot notice again
369             TestBotRunner.runPeriodicItems(mergeBot);
370 
371             // Merge the latest from master
372             localRepo.merge(newMasterHash);
373             var latestMergeHash = localRepo.commit(&quot;Our to be squashed merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
374             localRepo.push(latestMergeHash, author.url(), &quot;edit&quot;);
375 
376             // Let the bot notice again
377             TestBotRunner.runPeriodicItems(mergeBot);
378 
379             // Push it
380             pr.addComment(&quot;/integrate&quot;);
381             TestBotRunner.runPeriodicItems(mergeBot);
382 
383             // The bot should reply with an ok message
384             var pushed = pr.comments().stream()
385                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
386                            .count();
387             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
388 
389             // The change should now be present on the master branch
390             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
391             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
392             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
393 
394             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
395             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
396             String commits;
397             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
398                 commits = tempCommits.stream()
399                                      .map(c -&gt; c.hash().hex() + &quot;:&quot; + c.message().get(0))
400                                      .collect(Collectors.joining(&quot;,&quot;));
401             }
402             assertTrue(commits.contains(otherHash1.hex() + &quot;:First other&quot;));
403             assertTrue(commits.contains(otherHash2.hex() + &quot;:Second other&quot;));
404             assertFalse(commits.contains(&quot;Our own merge commit&quot;));
405 
406             // Author and committer should updated in the merge commit
407             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
408             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
409             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
410             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
411             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
412 
413             // The latest content from the source and the updated master should be present
414             assertEquals(&quot;New on master&quot;, Files.readString(pushedRepoFolder.resolve(&quot;newmaster.txt&quot;)));
415             assertEquals(&quot;Unrelated&quot;, Files.readString(pushedRepoFolder.resolve(&quot;unrelated.txt&quot;)));
416         }
417     }
418 
419     @Test
420     void invalidMergeCommit(TestInfo testInfo) throws IOException {
421         try (var credentials = new HostCredentials(testInfo);
422              var tempFolder = new TemporaryDirectory()) {
423 
424             var author = credentials.getHostedRepository();
425             var integrator = credentials.getHostedRepository();
426             var censusBuilder = credentials.getCensusBuilder()
427                                            .addCommitter(author.forge().currentUser().id())
428                                            .addReviewer(integrator.forge().currentUser().id());
429             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
430 
431             // Populate the projects repository
432             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
433             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
434             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
435             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
436             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
437 
438             // Make a change in another branch
439             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
440                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
441             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
442 
443             // Go back to the original master
444             localRepo.checkout(masterHash, true);
445 
446             // Make a change with a corresponding PR
447             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
448             localRepo.add(unrelated);
449             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
450             localRepo.merge(otherHash);
451             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
452             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
453             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
454 
455             // Approve it as another user
456             var approvalPr = integrator.pullRequest(pr.id());
457             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
458 
459             // Let the bot check the status
460             TestBotRunner.runPeriodicItems(mergeBot);
461 
462             // Push it
463             pr.addComment(&quot;/integrate&quot;);
464             TestBotRunner.runPeriodicItems(mergeBot);
465 
<a name="1" id="anc1"></a><span class="line-modified">466             // The bot will create a proper merge commit</span>
<span class="line-modified">467             var pushed = pr.comments().stream()</span>
<span class="line-modified">468                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))</span>
<span class="line-modified">469                            .count();</span>
<span class="line-modified">470             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));</span>
471 
<a name="2" id="anc2"></a><span class="line-modified">472             // The change should now be present with correct parents on the master branch</span>
<span class="line-modified">473             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);</span>
<span class="line-added">474             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);</span>
<span class="line-added">475             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));</span>
<span class="line-added">476 </span>
<span class="line-added">477             var head = pushedRepo.commitMetadata(&quot;HEAD^!&quot;).get(0);</span>
<span class="line-added">478             assertEquals(2, head.parents().size());</span>
<span class="line-added">479             assertEquals(masterHash, head.parents().get(0));</span>
<span class="line-added">480             assertEquals(otherHash, head.parents().get(1));</span>
481         }
482     }
483 
484     @Test
485     void invalidSourceRepo(TestInfo testInfo) throws IOException {
486         try (var credentials = new HostCredentials(testInfo);
487              var tempFolder = new TemporaryDirectory()) {
488 
489             var author = credentials.getHostedRepository();
490             var integrator = credentials.getHostedRepository();
491             var censusBuilder = credentials.getCensusBuilder()
492                                            .addCommitter(author.forge().currentUser().id())
493                                            .addReviewer(integrator.forge().currentUser().id());
494             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
495 
496             // Populate the projects repository
497             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
498             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
499             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
500             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
501             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
502 
503             // Make a change in another branch
504             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
505                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
506             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
507 
508             // Go back to the original master
509             localRepo.checkout(masterHash, true);
510 
511             // Make a change with a corresponding PR
512             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
513             localRepo.add(unrelated);
514             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
515             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
516 
517             localRepo.merge(otherHash);
518             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
519             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
520             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;xyz&quot; + &quot;:other&quot;);
521 
522             // Approve it as another user
523             var approvalPr = integrator.pullRequest(pr.id());
524             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
525 
526             // Let the bot check the status
527             TestBotRunner.runPeriodicItems(mergeBot);
528 
529             // Push it
530             pr.addComment(&quot;/integrate&quot;);
531             TestBotRunner.runPeriodicItems(mergeBot);
532 
533             // The bot should reply with a failure message
534             var error = pr.comments().stream()
535                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
536                           .count();
537             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
538 
539             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
540             assertEquals(&quot;- Could not find project `&quot; + author.name() + &quot;xyz` - check that it is correct.&quot;, check.summary().orElseThrow());
541         }
542     }
543 
544     @Test
545     void invalidSourceBranch(TestInfo testInfo) throws IOException {
546         try (var credentials = new HostCredentials(testInfo);
547              var tempFolder = new TemporaryDirectory()) {
548 
549             var author = credentials.getHostedRepository();
550             var integrator = credentials.getHostedRepository();
551             var censusBuilder = credentials.getCensusBuilder()
552                                            .addCommitter(author.forge().currentUser().id())
553                                            .addReviewer(integrator.forge().currentUser().id());
554             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
555 
556             // Populate the projects repository
557             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
558             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
559             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
560             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
561             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
562 
563             // Make a change in another branch
564             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
565                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
566             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
567 
568             // Go back to the original master
569             localRepo.checkout(masterHash, true);
570 
571             // Make a change with a corresponding PR
572             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
573             localRepo.add(unrelated);
574             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
575             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
576 
577             localRepo.merge(otherHash);
578             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
579             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
580             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:otherxyz&quot;);
581 
582             // Approve it as another user
583             var approvalPr = integrator.pullRequest(pr.id());
584             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
585 
586             // Let the bot check the status
587             TestBotRunner.runPeriodicItems(mergeBot);
588 
589             // Push it
590             pr.addComment(&quot;/integrate&quot;);
591             TestBotRunner.runPeriodicItems(mergeBot);
592 
593             // The bot should reply with a failure message
594             var error = pr.comments().stream()
595                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
596                           .count();
597             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
598 
599             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
600             assertEquals(&quot;- Could not fetch branch `otherxyz` from project `&quot; + author.name() + &quot;` - check that they are correct.&quot;, check.summary().orElseThrow());
601         }
602     }
603 
604     @Test
605     void inferredSourceProject(TestInfo testInfo) throws IOException {
606         try (var credentials = new HostCredentials(testInfo);
607              var tempFolder = new TemporaryDirectory()) {
608 
609             var author = credentials.getHostedRepository();
610             var integrator = credentials.getHostedRepository();
611             var censusBuilder = credentials.getCensusBuilder()
612                                            .addCommitter(author.forge().currentUser().id())
613                                            .addReviewer(integrator.forge().currentUser().id());
614             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
615 
616             // Populate the projects repository
617             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
618             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
619             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
620             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
621             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
622 
623             // Make a change in another branch
624             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
625                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
626             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
627 
628             // Go back to the original master
629             localRepo.checkout(masterHash, true);
630 
631             // Make a change with a corresponding PR
632             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
633             localRepo.add(unrelated);
634             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
635             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
636 
637             localRepo.merge(otherHash);
638             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
639             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
640             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge otherxyz&quot;);
641 
642             // Approve it as another user
643             var approvalPr = integrator.pullRequest(pr.id());
644             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
645 
646             // Let the bot check the status
647             TestBotRunner.runPeriodicItems(mergeBot);
648 
649             // Push it
650             pr.addComment(&quot;/integrate&quot;);
651             TestBotRunner.runPeriodicItems(mergeBot);
652 
653             // The bot should reply with a failure message
654             var error = pr.comments().stream()
655                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
656                           .count();
657             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
658 
659             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
660             assertEquals(&quot;- Could not find project `otherxyz` - check that it is correct.&quot;, check.summary().orElseThrow());
661         }
662     }
663 
664     @Test
665     void wrongSourceBranch(TestInfo testInfo) throws IOException {
666         try (var credentials = new HostCredentials(testInfo);
667              var tempFolder = new TemporaryDirectory()) {
668 
669             var author = credentials.getHostedRepository();
670             var integrator = credentials.getHostedRepository();
671             var censusBuilder = credentials.getCensusBuilder()
672                                            .addCommitter(author.forge().currentUser().id())
673                                            .addReviewer(integrator.forge().currentUser().id());
674             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
675 
676             // Populate the projects repository
677             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
678             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
679             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
680             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
681             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
682 
683             // Make a change in another branch
684             var other1Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other1&quot;,
685                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
686             localRepo.push(other1Hash, author.url(), &quot;other1&quot;, true);
687 
688             // Go back to the original master
689             localRepo.checkout(masterHash, true);
690 
691             // Make yet another change in another branch
692             var other2Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other2&quot;,
693                                                                 &quot;Unrelated\n\nReviewed-by: integrationreviewer2&quot;);
694             localRepo.push(other2Hash, author.url(), &quot;other2&quot;, true);
695 
696             // Make a change with a corresponding PR
697             localRepo.checkout(masterHash, true);
698             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
699             localRepo.add(unrelated);
700             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
701             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
702 
703             localRepo.merge(other1Hash, &quot;ours&quot;);
704             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
705             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
706             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other2&quot;);
707 
708             // Approve it as another user
709             var approvalPr = integrator.pullRequest(pr.id());
710             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
711 
712             // Let the bot check the status
713             TestBotRunner.runPeriodicItems(mergeBot);
714 
715             // Push it
716             pr.addComment(&quot;/integrate&quot;);
717             TestBotRunner.runPeriodicItems(mergeBot);
718 
719             // The bot should reply with a failure message
720             var error = pr.comments().stream()
721                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
722                           .count();
723             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
724 
725             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
<a name="3" id="anc3"></a><span class="line-modified">726             assertEquals(&quot;- A merge PR must contain at least one commit from the source branch that is not already present in the target.&quot;, check.summary().orElseThrow());</span>
727         }
728     }
729 
730     @Test
731     void invalidAuthor(TestInfo testInfo) throws IOException {
732         try (var credentials = new HostCredentials(testInfo);
733              var tempFolder = new TemporaryDirectory()) {
734 
735             var author = credentials.getHostedRepository();
736             var integrator = credentials.getHostedRepository();
737             var censusBuilder = credentials.getCensusBuilder()
738                                            .addAuthor(author.forge().currentUser().id())
739                                            .addReviewer(integrator.forge().currentUser().id());
740             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
741 
742             // Populate the projects repository
743             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
744             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
745             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
746             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
747             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
748 
749             // Make a change in another branch
750             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
751                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
752             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
753 
754             // Go back to the original master
755             localRepo.checkout(masterHash, true);
756 
757             // Make a change with a corresponding PR
758             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
759             localRepo.add(unrelated);
760             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
761             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
762 
763             localRepo.merge(otherHash);
764             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
765             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
766             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
767 
768             // Approve it as another user
769             var approvalPr = integrator.pullRequest(pr.id());
770             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
771 
772             // Let the bot check the status
773             TestBotRunner.runPeriodicItems(mergeBot);
774 
775             // Push it
776             pr.addComment(&quot;/integrate&quot;);
777             TestBotRunner.runPeriodicItems(mergeBot);
778 
779             // The bot should reply with a need for sponsor
780             var error = pr.comments().stream()
781                           .filter(comment -&gt; comment.body().contains(&quot;Afterwards, your sponsor types `/sponsor`&quot;))
782                           .count();
783             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
784         }
785     }
786 
787     @Test
788     void unrelatedHistory(TestInfo testInfo) throws IOException {
789         try (var credentials = new HostCredentials(testInfo);
790              var tempFolder = new TemporaryDirectory()) {
791 
792             var author = credentials.getHostedRepository();
793             // Need to force merge unrelated histories
794             assumeTrue(author.repositoryType().equals(VCS.GIT));
795 
796             var integrator = credentials.getHostedRepository();
797             var censusBuilder = credentials.getCensusBuilder()
798                                            .addCommitter(author.forge().currentUser().id())
799                                            .addReviewer(integrator.forge().currentUser().id());
800             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
801 
802             // Populate the projects repository
803             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
804             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
805             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
806 
807             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
808             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
809 
810             // Make an unrelated change in another branch
811             var unrelatedRepoFolder = tempFolder.path().resolve(&quot;unrelated&quot;);
812             var unrelatedRepo = CheckableRepository.init(unrelatedRepoFolder, author.repositoryType(), Path.of(&quot;anotherfile.txt&quot;));
813             unrelatedRepo.amend(&quot;Unrelated initial commit\n\nReviewed-by: integrationreviewer2&quot;, &quot;some&quot;, &quot;one@mail&quot;);
814             var otherHash = CheckableRepository.appendAndCommit(unrelatedRepo, &quot;Change in other&quot;,
815                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
816             unrelatedRepo.push(otherHash, author.url(), &quot;other&quot;, true);
817             localRepo.fetch(author.url(), &quot;other&quot;);
818 
819             // Go back to the original master
820             localRepo.checkout(masterHash, true);
821 
822             // Make a change with a corresponding PR
823             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
824             localRepo.add(unrelated);
825             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
826             var mergeCmd = Process.command(&quot;git&quot;, &quot;merge&quot;, &quot;--no-commit&quot;, &quot;--allow-unrelated-histories&quot;, &quot;-s&quot;, &quot;ours&quot;, otherHash.hex())
827                                   .workdir(localRepo.root())
828                                   .environ(&quot;GIT_AUTHOR_NAME&quot;, &quot;some&quot;)
829                                   .environ(&quot;GIT_AUTHOR_EMAIL&quot;, &quot;some@one&quot;)
830                                   .environ(&quot;GIT_COMMITTER_NAME&quot;, &quot;another&quot;)
831                                   .environ(&quot;GIT_COMMITTER_EMAIL&quot;, &quot;another@one&quot;)
832                                   .execute();
833             mergeCmd.check();
834 
835             //localRepo.merge(otherHash);
836             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
837             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
838             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
839 
840             // Approve it as another user
841             var approvalPr = integrator.pullRequest(pr.id());
842             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
843 
844             // Let the bot check the status
845             TestBotRunner.runPeriodicItems(mergeBot);
846 
847             // Push it
848             pr.addComment(&quot;/integrate&quot;);
849             TestBotRunner.runPeriodicItems(mergeBot);
850 
851             // The bot should reply with a failure message
852             var error = pr.comments().stream()
853                     .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
854                     .count();
855             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
856 
857             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
<a name="4" id="anc4"></a><span class="line-modified">858             assertEquals(&quot;- The target and the source branches do not share common history - cannot merge them.&quot;, check.summary().orElseThrow());</span>
859         }
860     }
861 
862     @Test
863     void invalidSyntax(TestInfo testInfo) throws IOException {
864         try (var credentials = new HostCredentials(testInfo);
865              var tempFolder = new TemporaryDirectory()) {
866 
867             var author = credentials.getHostedRepository();
868             var integrator = credentials.getHostedRepository();
869             var censusBuilder = credentials.getCensusBuilder()
870                                            .addCommitter(author.forge().currentUser().id())
871                                            .addReviewer(integrator.forge().currentUser().id());
872             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
873 
874             // Populate the projects repository
875             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
876             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(&quot;appendable.txt&quot;), Set.of(&quot;merge&quot;), &quot;1.0&quot;);
877             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
878             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
879             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
880 
881             // Make a change in another branch
882             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
883                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
884             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
885 
886             // Go back to the original master
887             localRepo.checkout(masterHash, true);
888 
889             // Make a change with a corresponding PR
890             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
891             localRepo.add(unrelated);
892             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
893             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
894 
895             localRepo.merge(otherHash);
896             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
897             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
898             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge this or that&quot;);
899 
900             // Let the bot check the status
901             TestBotRunner.runPeriodicItems(mergeBot);
902 
903             // Push it
904             pr.addComment(&quot;/integrate&quot;);
905             TestBotRunner.runPeriodicItems(mergeBot);
906 
907             // The bot should reply with a failure message
908             var error = pr.comments().stream()
909                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
910                           .count();
911             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
912 
913             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
914             assertEquals(&quot;- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.&quot;, check.summary().orElseThrow());
915         }
916     }
917 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
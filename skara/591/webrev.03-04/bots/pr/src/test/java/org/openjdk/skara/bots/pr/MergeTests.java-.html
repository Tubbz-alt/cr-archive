<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.bots.pr;
 24 
 25 import org.openjdk.skara.forge.Review;
 26 import org.openjdk.skara.issuetracker.Comment;
 27 import org.openjdk.skara.process.Process;
 28 import org.openjdk.skara.test.*;
 29 import org.openjdk.skara.vcs.*;
 30 
 31 import org.junit.jupiter.api.*;
 32 
 33 import java.io.IOException;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.*;
 36 import java.util.Set;
 37 import java.util.stream.Collectors;
 38 
 39 import static org.junit.jupiter.api.Assertions.*;
 40 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 41 
 42 class MergeTests {
 43     @Test
 44     void branchMerge(TestInfo testInfo) throws IOException {
 45         try (var credentials = new HostCredentials(testInfo);
 46              var tempFolder = new TemporaryDirectory()) {
 47 
 48             var author = credentials.getHostedRepository();
 49             var integrator = credentials.getHostedRepository();
 50             var censusBuilder = credentials.getCensusBuilder()
 51                                            .addCommitter(author.forge().currentUser().id())
 52                                            .addReviewer(integrator.forge().currentUser().id());
 53             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 54 
 55             // Populate the projects repository
 56             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 57             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 58             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 59             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 60             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 61 
 62             // Make more changes in another branch
 63             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 64                                                                 &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 65             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 66             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 67                                                                 &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 68             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 69 
 70             // Go back to the original master
 71             localRepo.checkout(masterHash, true);
 72 
 73             // Make a change with a corresponding PR
 74             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 75             localRepo.add(unrelated);
 76             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 77             localRepo.merge(otherHash2);
 78             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 79 
 80             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 81             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 82             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 83 
 84             // Approve it as another user
 85             var approvalPr = integrator.pullRequest(pr.id());
 86             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 87 
 88             // Let the bot check the status
 89             TestBotRunner.runPeriodicItems(mergeBot);
 90 
 91             // Push it
 92             pr.addComment(&quot;/integrate&quot;);
 93             TestBotRunner.runPeriodicItems(mergeBot);
 94 
 95             // The bot should reply with an ok message
 96             var pushed = pr.comments().stream()
 97                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 98                            .count();
 99             assertEquals(1, pushed);
100 
101             // The change should now be present on the master branch
102             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
103             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
104             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
105 
106             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
107             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
108             Set&lt;Hash&gt; commits;
109             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
110                 commits = tempCommits.stream()
111                         .map(Commit::hash)
112                         .collect(Collectors.toSet());
113             }
114             assertTrue(commits.contains(otherHash1));
115             assertTrue(commits.contains(otherHash2));
116             assertFalse(commits.contains(mergeHash));
117 
118             // Author and committer should updated in the merge commit
119             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
120             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
121             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
122             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
123             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
124         }
125     }
126 
127     @Test
128     void branchMergeShortName(TestInfo testInfo) throws IOException {
129         try (var credentials = new HostCredentials(testInfo);
130              var tempFolder = new TemporaryDirectory()) {
131 
132             var author = credentials.getHostedRepository();
133             var integrator = credentials.getHostedRepository();
134             var censusBuilder = credentials.getCensusBuilder()
135                                            .addCommitter(author.forge().currentUser().id())
136                                            .addReviewer(integrator.forge().currentUser().id());
137             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
138 
139             // Populate the projects repository
140             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
141             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
142             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
143             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
144             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
145 
146             // Make more changes in another branch
147             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
148                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
149             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
150             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
151                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
152             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
153 
154             // Go back to the original master
155             localRepo.checkout(masterHash, true);
156 
157             // Make a change with a corresponding PR
158             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
159             localRepo.add(unrelated);
160             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
161             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
162 
163             localRepo.merge(otherHash2);
164             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
165             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
166             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge other&quot;);
167 
168             // Approve it as another user
169             var approvalPr = integrator.pullRequest(pr.id());
170             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
171 
172             // Let the bot check the status
173             TestBotRunner.runPeriodicItems(mergeBot);
174 
175             // Push it
176             pr.addComment(&quot;/integrate&quot;);
177             TestBotRunner.runPeriodicItems(mergeBot);
178 
179             // The bot should reply with an ok message
180             var pushed = pr.comments().stream()
181                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
182                            .count();
183             assertEquals(1, pushed);
184 
185             // The change should now be present on the master branch
186             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
187             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
188             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
189 
190             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
191             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
192             Set&lt;Hash&gt; commits;
193             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
194                 commits = tempCommits.stream()
195                                      .map(Commit::hash)
196                                      .collect(Collectors.toSet());
197             }
198             assertTrue(commits.contains(otherHash1));
199             assertTrue(commits.contains(otherHash2));
200             assertFalse(commits.contains(mergeHash));
201 
202             // Author and committer should updated in the merge commit
203             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
204             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
205             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
206             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
207             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
208         }
209     }
210 
211     @Test
212     void branchMergeRebase(TestInfo testInfo) throws IOException {
213         try (var credentials = new HostCredentials(testInfo);
214              var tempFolder = new TemporaryDirectory()) {
215 
216             var author = credentials.getHostedRepository();
217             var integrator = credentials.getHostedRepository();
218             var censusBuilder = credentials.getCensusBuilder()
219                                            .addCommitter(author.forge().currentUser().id())
220                                            .addReviewer(integrator.forge().currentUser().id());
221             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
222 
223             // Populate the projects repository
224             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
225             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
226             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
227             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
228             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
229 
230             // Make more changes in another branch
231             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
232                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
233             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
234             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
235                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
236             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
237 
238             // Go back to the original master
239             localRepo.checkout(masterHash, true);
240 
241             // Make a change with a corresponding PR
242             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
243             localRepo.add(unrelated);
244             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
245             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
246 
247             localRepo.merge(otherHash2);
248             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
249             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
250             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
251 
252             // Approve it as another user
253             var approvalPr = integrator.pullRequest(pr.id());
254             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
255 
256             // Let the bot check the status
257             TestBotRunner.runPeriodicItems(mergeBot);
258 
259             // Push something new to master
260             localRepo.checkout(updatedMaster, true);
261             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
262             localRepo.add(newMaster);
263             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
264             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
265 
266             // Let the bot notice
267             TestBotRunner.runPeriodicItems(mergeBot);
268 
269             // Push it
270             pr.addComment(&quot;/integrate&quot;);
271             TestBotRunner.runPeriodicItems(mergeBot);
272 
273             // The bot should reply with an ok message
274             var pushed = pr.comments().stream()
275                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
276                            .count();
277             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
278 
279             // The change should now be present on the master branch
280             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
281             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
282             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
283 
284             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
285             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
286             Set&lt;Hash&gt; commits;
287             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
288                 commits = tempCommits.stream()
289                         .map(Commit::hash)
290                         .collect(Collectors.toSet());
291             }
292             assertTrue(commits.contains(otherHash1));
293             assertTrue(commits.contains(otherHash2));
294             assertFalse(commits.contains(mergeHash));
295 
296             // Author and committer should updated in the merge commit
297             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
298             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
299             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
300             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
301             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
302         }
303     }
304 
305     @Test
306     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
307         try (var credentials = new HostCredentials(testInfo);
308              var tempFolder = new TemporaryDirectory()) {
309 
310             var author = credentials.getHostedRepository();
311             var integrator = credentials.getHostedRepository();
312             var censusBuilder = credentials.getCensusBuilder()
313                                            .addCommitter(author.forge().currentUser().id())
314                                            .addReviewer(integrator.forge().currentUser().id());
315             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
316 
317             // Populate the projects repository
318             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
319             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
320             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
321             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
322             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
323 
324             // Make more changes in another branch
325             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
326                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
327             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
328             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
329                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
330             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
331 
332             // Go back to the original master
333             localRepo.checkout(masterHash, true);
334 
335             // Make a change with a corresponding PR
336             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
337             localRepo.add(unrelated);
338             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
339             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
340 
341             localRepo.merge(otherHash2);
342             var mergeHash = localRepo.commit(&quot;Our own merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
343             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
344             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
345 
346             // Approve it as another user
347             var approvalPr = integrator.pullRequest(pr.id());
348             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
349 
350             // Let the bot check the status
351             TestBotRunner.runPeriodicItems(mergeBot);
352 
353             // Push something new to master
354             localRepo.checkout(updatedMaster, true);
355             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
356             localRepo.add(newMaster);
357             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
358             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
359 
360             // Let the bot notice
361             TestBotRunner.runPeriodicItems(mergeBot);
362 
363             // Add another commit on top of the merge commit
364             localRepo.checkout(mergeHash, true);
365             var extraHash = CheckableRepository.appendAndCommit(localRepo, &quot;Fixing up stuff after merge&quot;);
366             localRepo.push(extraHash, author.url(), &quot;edit&quot;);
367 
368             // Let the bot notice again
369             TestBotRunner.runPeriodicItems(mergeBot);
370 
371             // Merge the latest from master
372             localRepo.merge(newMasterHash);
373             var latestMergeHash = localRepo.commit(&quot;Our to be squashed merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
374             localRepo.push(latestMergeHash, author.url(), &quot;edit&quot;);
375 
376             // Let the bot notice again
377             TestBotRunner.runPeriodicItems(mergeBot);
378 
379             // Push it
380             pr.addComment(&quot;/integrate&quot;);
381             TestBotRunner.runPeriodicItems(mergeBot);
382 
383             // The bot should reply with an ok message
384             var pushed = pr.comments().stream()
385                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
386                            .count();
387             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
388 
389             // The change should now be present on the master branch
390             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
391             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
392             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
393 
394             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
395             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
396             String commits;
397             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
398                 commits = tempCommits.stream()
399                                      .map(c -&gt; c.hash().hex() + &quot;:&quot; + c.message().get(0))
400                                      .collect(Collectors.joining(&quot;,&quot;));
401             }
402             assertTrue(commits.contains(otherHash1.hex() + &quot;:First other&quot;));
403             assertTrue(commits.contains(otherHash2.hex() + &quot;:Second other&quot;));
404             assertFalse(commits.contains(&quot;Our own merge commit&quot;));
405 
406             // Author and committer should updated in the merge commit
407             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
408             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
409             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
410             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
411             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
412 
413             // The latest content from the source and the updated master should be present
414             assertEquals(&quot;New on master&quot;, Files.readString(pushedRepoFolder.resolve(&quot;newmaster.txt&quot;)));
415             assertEquals(&quot;Unrelated&quot;, Files.readString(pushedRepoFolder.resolve(&quot;unrelated.txt&quot;)));
416         }
417     }
418 
419     @Test
420     void invalidMergeCommit(TestInfo testInfo) throws IOException {
421         try (var credentials = new HostCredentials(testInfo);
422              var tempFolder = new TemporaryDirectory()) {
423 
424             var author = credentials.getHostedRepository();
425             var integrator = credentials.getHostedRepository();
426             var censusBuilder = credentials.getCensusBuilder()
427                                            .addCommitter(author.forge().currentUser().id())
428                                            .addReviewer(integrator.forge().currentUser().id());
429             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
430 
431             // Populate the projects repository
432             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
433             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
434             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
435             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
436             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
437 
438             // Make a change in another branch
439             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
440                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
441             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
442 
443             // Go back to the original master
444             localRepo.checkout(masterHash, true);
445 
446             // Make a change with a corresponding PR
447             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
448             localRepo.add(unrelated);
449             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
450             localRepo.merge(otherHash);
451             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
452             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
453             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
454 
455             // Approve it as another user
456             var approvalPr = integrator.pullRequest(pr.id());
457             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
458 
459             // Let the bot check the status
460             TestBotRunner.runPeriodicItems(mergeBot);
461 
462             // Push it
463             pr.addComment(&quot;/integrate&quot;);
464             TestBotRunner.runPeriodicItems(mergeBot);
465 
466             // The bot should reply with a failure message
467             var error = pr.comments().stream()
468                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
469                           .count();
470             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
471 
472             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
473             assertEquals(&quot;- The merge commit must have a commit on the target branch as one of its parents.&quot;, check.summary().orElseThrow());
474         }
475     }
476 
477     @Test
478     void invalidSourceRepo(TestInfo testInfo) throws IOException {
479         try (var credentials = new HostCredentials(testInfo);
480              var tempFolder = new TemporaryDirectory()) {
481 
482             var author = credentials.getHostedRepository();
483             var integrator = credentials.getHostedRepository();
484             var censusBuilder = credentials.getCensusBuilder()
485                                            .addCommitter(author.forge().currentUser().id())
486                                            .addReviewer(integrator.forge().currentUser().id());
487             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
488 
489             // Populate the projects repository
490             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
491             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
492             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
493             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
494             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
495 
496             // Make a change in another branch
497             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
498                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
499             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
500 
501             // Go back to the original master
502             localRepo.checkout(masterHash, true);
503 
504             // Make a change with a corresponding PR
505             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
506             localRepo.add(unrelated);
507             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
508             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
509 
510             localRepo.merge(otherHash);
511             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
512             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
513             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;xyz&quot; + &quot;:other&quot;);
514 
515             // Approve it as another user
516             var approvalPr = integrator.pullRequest(pr.id());
517             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
518 
519             // Let the bot check the status
520             TestBotRunner.runPeriodicItems(mergeBot);
521 
522             // Push it
523             pr.addComment(&quot;/integrate&quot;);
524             TestBotRunner.runPeriodicItems(mergeBot);
525 
526             // The bot should reply with a failure message
527             var error = pr.comments().stream()
528                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
529                           .count();
530             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
531 
532             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
533             assertEquals(&quot;- Could not find project `&quot; + author.name() + &quot;xyz` - check that it is correct.&quot;, check.summary().orElseThrow());
534         }
535     }
536 
537     @Test
538     void invalidSourceBranch(TestInfo testInfo) throws IOException {
539         try (var credentials = new HostCredentials(testInfo);
540              var tempFolder = new TemporaryDirectory()) {
541 
542             var author = credentials.getHostedRepository();
543             var integrator = credentials.getHostedRepository();
544             var censusBuilder = credentials.getCensusBuilder()
545                                            .addCommitter(author.forge().currentUser().id())
546                                            .addReviewer(integrator.forge().currentUser().id());
547             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
548 
549             // Populate the projects repository
550             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
551             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
552             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
553             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
554             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
555 
556             // Make a change in another branch
557             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
558                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
559             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
560 
561             // Go back to the original master
562             localRepo.checkout(masterHash, true);
563 
564             // Make a change with a corresponding PR
565             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
566             localRepo.add(unrelated);
567             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
568             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
569 
570             localRepo.merge(otherHash);
571             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
572             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
573             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:otherxyz&quot;);
574 
575             // Approve it as another user
576             var approvalPr = integrator.pullRequest(pr.id());
577             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
578 
579             // Let the bot check the status
580             TestBotRunner.runPeriodicItems(mergeBot);
581 
582             // Push it
583             pr.addComment(&quot;/integrate&quot;);
584             TestBotRunner.runPeriodicItems(mergeBot);
585 
586             // The bot should reply with a failure message
587             var error = pr.comments().stream()
588                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
589                           .count();
590             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
591 
592             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
593             assertEquals(&quot;- Could not fetch branch `otherxyz` from project `&quot; + author.name() + &quot;` - check that they are correct.&quot;, check.summary().orElseThrow());
594         }
595     }
596 
597     @Test
598     void inferredSourceProject(TestInfo testInfo) throws IOException {
599         try (var credentials = new HostCredentials(testInfo);
600              var tempFolder = new TemporaryDirectory()) {
601 
602             var author = credentials.getHostedRepository();
603             var integrator = credentials.getHostedRepository();
604             var censusBuilder = credentials.getCensusBuilder()
605                                            .addCommitter(author.forge().currentUser().id())
606                                            .addReviewer(integrator.forge().currentUser().id());
607             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
608 
609             // Populate the projects repository
610             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
611             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
612             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
613             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
614             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
615 
616             // Make a change in another branch
617             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
618                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
619             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
620 
621             // Go back to the original master
622             localRepo.checkout(masterHash, true);
623 
624             // Make a change with a corresponding PR
625             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
626             localRepo.add(unrelated);
627             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
628             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
629 
630             localRepo.merge(otherHash);
631             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
632             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
633             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge otherxyz&quot;);
634 
635             // Approve it as another user
636             var approvalPr = integrator.pullRequest(pr.id());
637             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
638 
639             // Let the bot check the status
640             TestBotRunner.runPeriodicItems(mergeBot);
641 
642             // Push it
643             pr.addComment(&quot;/integrate&quot;);
644             TestBotRunner.runPeriodicItems(mergeBot);
645 
646             // The bot should reply with a failure message
647             var error = pr.comments().stream()
648                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
649                           .count();
650             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
651 
652             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
653             assertEquals(&quot;- Could not find project `otherxyz` - check that it is correct.&quot;, check.summary().orElseThrow());
654         }
655     }
656 
657     @Test
658     void wrongSourceBranch(TestInfo testInfo) throws IOException {
659         try (var credentials = new HostCredentials(testInfo);
660              var tempFolder = new TemporaryDirectory()) {
661 
662             var author = credentials.getHostedRepository();
663             var integrator = credentials.getHostedRepository();
664             var censusBuilder = credentials.getCensusBuilder()
665                                            .addCommitter(author.forge().currentUser().id())
666                                            .addReviewer(integrator.forge().currentUser().id());
667             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
668 
669             // Populate the projects repository
670             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
671             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
672             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
673             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
674             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
675 
676             // Make a change in another branch
677             var other1Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other1&quot;,
678                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
679             localRepo.push(other1Hash, author.url(), &quot;other1&quot;, true);
680 
681             // Go back to the original master
682             localRepo.checkout(masterHash, true);
683 
684             // Make yet another change in another branch
685             var other2Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other2&quot;,
686                                                                 &quot;Unrelated\n\nReviewed-by: integrationreviewer2&quot;);
687             localRepo.push(other2Hash, author.url(), &quot;other2&quot;, true);
688 
689             // Make a change with a corresponding PR
690             localRepo.checkout(masterHash, true);
691             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
692             localRepo.add(unrelated);
693             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
694             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
695 
696             localRepo.merge(other1Hash, &quot;ours&quot;);
697             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
698             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
699             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other2&quot;);
700 
701             // Approve it as another user
702             var approvalPr = integrator.pullRequest(pr.id());
703             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
704 
705             // Let the bot check the status
706             TestBotRunner.runPeriodicItems(mergeBot);
707 
708             // Push it
709             pr.addComment(&quot;/integrate&quot;);
710             TestBotRunner.runPeriodicItems(mergeBot);
711 
712             // The bot should reply with a failure message
713             var error = pr.comments().stream()
714                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
715                           .count();
716             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
717 
718             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
719             assertEquals(&quot;- A merge PR must contain a merge commit as well as at least one other commit from the merge source.&quot;, check.summary().orElseThrow());
720         }
721     }
722 
723     @Test
724     void invalidAuthor(TestInfo testInfo) throws IOException {
725         try (var credentials = new HostCredentials(testInfo);
726              var tempFolder = new TemporaryDirectory()) {
727 
728             var author = credentials.getHostedRepository();
729             var integrator = credentials.getHostedRepository();
730             var censusBuilder = credentials.getCensusBuilder()
731                                            .addAuthor(author.forge().currentUser().id())
732                                            .addReviewer(integrator.forge().currentUser().id());
733             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
734 
735             // Populate the projects repository
736             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
737             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
738             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
739             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
740             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
741 
742             // Make a change in another branch
743             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
744                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
745             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
746 
747             // Go back to the original master
748             localRepo.checkout(masterHash, true);
749 
750             // Make a change with a corresponding PR
751             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
752             localRepo.add(unrelated);
753             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
754             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
755 
756             localRepo.merge(otherHash);
757             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
758             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
759             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
760 
761             // Approve it as another user
762             var approvalPr = integrator.pullRequest(pr.id());
763             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
764 
765             // Let the bot check the status
766             TestBotRunner.runPeriodicItems(mergeBot);
767 
768             // Push it
769             pr.addComment(&quot;/integrate&quot;);
770             TestBotRunner.runPeriodicItems(mergeBot);
771 
772             // The bot should reply with a need for sponsor
773             var error = pr.comments().stream()
774                           .filter(comment -&gt; comment.body().contains(&quot;Afterwards, your sponsor types `/sponsor`&quot;))
775                           .count();
776             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
777         }
778     }
779 
780     @Test
781     void unrelatedHistory(TestInfo testInfo) throws IOException {
782         try (var credentials = new HostCredentials(testInfo);
783              var tempFolder = new TemporaryDirectory()) {
784 
785             var author = credentials.getHostedRepository();
786             // Need to force merge unrelated histories
787             assumeTrue(author.repositoryType().equals(VCS.GIT));
788 
789             var integrator = credentials.getHostedRepository();
790             var censusBuilder = credentials.getCensusBuilder()
791                                            .addCommitter(author.forge().currentUser().id())
792                                            .addReviewer(integrator.forge().currentUser().id());
793             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
794 
795             // Populate the projects repository
796             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
797             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
798             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
799 
800             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
801             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
802 
803             // Make an unrelated change in another branch
804             var unrelatedRepoFolder = tempFolder.path().resolve(&quot;unrelated&quot;);
805             var unrelatedRepo = CheckableRepository.init(unrelatedRepoFolder, author.repositoryType(), Path.of(&quot;anotherfile.txt&quot;));
806             unrelatedRepo.amend(&quot;Unrelated initial commit\n\nReviewed-by: integrationreviewer2&quot;, &quot;some&quot;, &quot;one@mail&quot;);
807             var otherHash = CheckableRepository.appendAndCommit(unrelatedRepo, &quot;Change in other&quot;,
808                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
809             unrelatedRepo.push(otherHash, author.url(), &quot;other&quot;, true);
810             localRepo.fetch(author.url(), &quot;other&quot;);
811 
812             // Go back to the original master
813             localRepo.checkout(masterHash, true);
814 
815             // Make a change with a corresponding PR
816             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
817             localRepo.add(unrelated);
818             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
819             var mergeCmd = Process.command(&quot;git&quot;, &quot;merge&quot;, &quot;--no-commit&quot;, &quot;--allow-unrelated-histories&quot;, &quot;-s&quot;, &quot;ours&quot;, otherHash.hex())
820                                   .workdir(localRepo.root())
821                                   .environ(&quot;GIT_AUTHOR_NAME&quot;, &quot;some&quot;)
822                                   .environ(&quot;GIT_AUTHOR_EMAIL&quot;, &quot;some@one&quot;)
823                                   .environ(&quot;GIT_COMMITTER_NAME&quot;, &quot;another&quot;)
824                                   .environ(&quot;GIT_COMMITTER_EMAIL&quot;, &quot;another@one&quot;)
825                                   .execute();
826             mergeCmd.check();
827 
828             //localRepo.merge(otherHash);
829             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
830             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
831             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
832 
833             // Approve it as another user
834             var approvalPr = integrator.pullRequest(pr.id());
835             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
836 
837             // Let the bot check the status
838             TestBotRunner.runPeriodicItems(mergeBot);
839 
840             // Push it
841             pr.addComment(&quot;/integrate&quot;);
842             TestBotRunner.runPeriodicItems(mergeBot);
843 
844             // The bot should reply with a failure message
845             var error = pr.comments().stream()
846                     .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
847                     .count();
848             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
849 
850             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
851             assertEquals(&quot;- The merge commit must have a commit on the target branch as one of its parents.&quot;, check.summary().orElseThrow());
852         }
853     }
854 
855     @Test
856     void invalidSyntax(TestInfo testInfo) throws IOException {
857         try (var credentials = new HostCredentials(testInfo);
858              var tempFolder = new TemporaryDirectory()) {
859 
860             var author = credentials.getHostedRepository();
861             var integrator = credentials.getHostedRepository();
862             var censusBuilder = credentials.getCensusBuilder()
863                                            .addCommitter(author.forge().currentUser().id())
864                                            .addReviewer(integrator.forge().currentUser().id());
865             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
866 
867             // Populate the projects repository
868             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
869             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(&quot;appendable.txt&quot;), Set.of(&quot;merge&quot;), &quot;1.0&quot;);
870             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
871             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
872             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
873 
874             // Make a change in another branch
875             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
876                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
877             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
878 
879             // Go back to the original master
880             localRepo.checkout(masterHash, true);
881 
882             // Make a change with a corresponding PR
883             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
884             localRepo.add(unrelated);
885             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
886             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
887 
888             localRepo.merge(otherHash);
889             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
890             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
891             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge this or that&quot;);
892 
893             // Let the bot check the status
894             TestBotRunner.runPeriodicItems(mergeBot);
895 
896             // Push it
897             pr.addComment(&quot;/integrate&quot;);
898             TestBotRunner.runPeriodicItems(mergeBot);
899 
900             // The bot should reply with a failure message
901             var error = pr.comments().stream()
902                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
903                           .count();
904             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
905 
906             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
907             assertEquals(&quot;- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.&quot;, check.summary().orElseThrow());
908         }
909     }
910 }
    </pre>
  </body>
</html>
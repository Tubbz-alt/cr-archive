diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
@@ -36,47 +36,49 @@
         this.header = header;
         this.body = body;
         this.footer = footer;
     }
 
-    private static Optional<Commit> mergeCommit(PullRequestInstance prInstance, Hash head) {
+    private static Optional<Commit> mergeCommit(PullRequest pr, Repository localRepo, Hash head) {
         try {
             var author = new Author("duke", "duke@openjdk.org");
-            var hash = prInstance.commit(head, author, author, prInstance.pr().title());
-            return prInstance.localRepo().lookup(hash);
+            var prUtils = new PullRequestUtils(pr);
+            var hash = prUtils.createCommit(localRepo, head, author, author, pr.title());
+            return localRepo.lookup(hash);
         } catch (IOException | CommitFailure e) {
             return Optional.empty();
         }
     }
 
-    static ArchiveItem from(PullRequestInstance prInstance, HostUserToEmailAuthor hostUserToEmailAuthor,
+    static ArchiveItem from(PullRequest pr, Repository localRepo, HostUserToEmailAuthor hostUserToEmailAuthor,
                             URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator,
                             WebrevNotification webrevNotification, ZonedDateTime created, ZonedDateTime updated,
                             Hash base, Hash head, String subjectPrefix, String threadPrefix) {
-        return new ArchiveItem(null, "fc", created, updated, prInstance.pr().author(), Map.of("PR-Head-Hash", head.hex(),
+        return new ArchiveItem(null, "fc", created, updated, pr.author(), Map.of("PR-Head-Hash", head.hex(),
                                                                                               "PR-Base-Hash", base.hex(),
                                                                                               "PR-Thread-Prefix", threadPrefix),
-                               () -> subjectPrefix + threadPrefix + (threadPrefix.isEmpty() ? "" : ": ") + prInstance.pr().title(),
+                               () -> subjectPrefix + threadPrefix + (threadPrefix.isEmpty() ? "" : ": ") + pr.title(),
                                () -> "",
-                               () -> ArchiveMessages.composeConversation(prInstance.pr()),
+                               () -> ArchiveMessages.composeConversation(pr),
                                () -> {
-                                   if (prInstance.isMerge()) {
+                                   var prUtils = new PullRequestUtils(pr);
+                                   if (prUtils.isMerge()) {
                                        //TODO: Try to merge in target - generate possible conflict webrev
-                                       var mergeCommit = mergeCommit(prInstance, head);
+                                       var mergeCommit = mergeCommit(pr, localRepo, head);
                                        var mergeWebrevs = new ArrayList<WebrevDescription>();
                                        if (mergeCommit.isPresent()) {
                                            for (int i = 0; i < mergeCommit.get().parentDiffs().size(); ++i) {
                                                var diff = mergeCommit.get().parentDiffs().get(i);
                                                if (diff.patches().size() == 0) {
                                                    continue;
                                                }
                                                switch (i) {
                                                    case 0:
-                                                       mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_TARGET, prInstance.pr().targetRef()));
+                                                       mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_TARGET, pr.targetRef()));
                                                        break;
                                                    case 1:
-                                                       var mergeSource = prInstance.pr().title().length() > 6 ? prInstance.pr().title().substring(6) : null;
+                                                       var mergeSource = pr.title().length() > 6 ? pr.title().substring(6) : null;
                                                        mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_SOURCE, mergeSource));
                                                        break;
                                                    default:
                                                        mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_SOURCE, null));
                                                        break;
@@ -84,15 +86,15 @@
                                            }
                                            if (!mergeWebrevs.isEmpty()) {
                                                webrevNotification.notify(0, mergeWebrevs);
                                            }
                                        }
-                                       return ArchiveMessages.composeMergeConversationFooter(prInstance.pr(), prInstance.localRepo(), mergeWebrevs, base, head);
+                                       return ArchiveMessages.composeMergeConversationFooter(pr, localRepo, mergeWebrevs, base, head);
                                    } else {
                                        var fullWebrev = webrevGenerator.generate(base, head, "00", WebrevDescription.Type.FULL);
                                        webrevNotification.notify(0, List.of(fullWebrev));
-                                       return ArchiveMessages.composeConversationFooter(prInstance.pr(), issueTracker, issuePrefix, prInstance.localRepo(), fullWebrev, base, head);
+                                       return ArchiveMessages.composeConversationFooter(pr, issueTracker, issuePrefix, localRepo, fullWebrev, base, head);
                                    }
                                });
     }
 
     private static Optional<Hash> rebasedLastHead(Repository localRepo, Hash newBase, Hash lastHead) {
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
@@ -291,17 +291,18 @@
         try {
             // Materialize the PR's source and target ref
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
             var localRepoPath = scratchPath.resolve("mlbridge-mergebase");
-            var prInstance = new PullRequestInstance(localRepoPath, hostedRepositoryPool, pr);
+            var localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(pr.repository().name()));
+            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":archiveworkitem", false);
 
             var webrevPath = scratchPath.resolve("mlbridge-webrevs");
             var listServer = MailingListServerFactory.createMailmanServer(bot.listArchive(), bot.smtpServer(), bot.sendInterval());
             var list = listServer.getList(bot.listAddress().address());
 
-            var archiver = new ReviewArchive(prInstance, bot.emailAddress());
+            var archiver = new ReviewArchive(pr, bot.emailAddress());
 
             // Regular comments
             for (var comment : comments) {
                 if (ignoreComment(comment.author(), comment.body())) {
                     continue;
@@ -325,12 +326,12 @@
                     continue;
                 }
                 archiver.addReviewComment(reviewComment);
             }
 
-            var webrevGenerator = bot.webrevStorage().generator(pr, prInstance.localRepo(), webrevPath);
-            var newMails = archiver.generateNewEmails(sentMails, bot.cooldown(), prInstance.localRepo(), bot.issueTracker(), jbs.toUpperCase(), webrevGenerator,
+            var webrevGenerator = bot.webrevStorage().generator(pr, localRepo, webrevPath);
+            var newMails = archiver.generateNewEmails(sentMails, bot.cooldown(), localRepo, bot.issueTracker(), jbs.toUpperCase(), webrevGenerator,
                                                       (index, webrevs) -> updateWebrevComment(comments, index, webrevs),
                                                       user -> getAuthorAddress(census, user),
                                                       user -> getAuthorUserName(census, user),
                                                       user -> getAuthorRole(census, user),
                                                       subjectPrefix(),
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -4,31 +4,32 @@
 import org.openjdk.skara.forge.*;
 import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.issuetracker.*;
 import org.openjdk.skara.vcs.*;
 
+import java.io.IOException;
 import java.net.URI;
 import java.nio.charset.StandardCharsets;
 import java.security.*;
 import java.time.*;
 import java.util.*;
 import java.util.function.Consumer;
 import java.util.logging.Logger;
 import java.util.stream.*;
 
 class ReviewArchive {
-    private final PullRequestInstance prInstance;
+    private final PullRequest pr;
     private final EmailAddress sender;
 
     private final List<Comment> comments = new ArrayList<>();
     private final List<Review> reviews = new ArrayList<>();
     private final List<ReviewComment> reviewComments = new ArrayList<>();
 
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.mlbridge");
 
-    ReviewArchive(PullRequestInstance prInstance, EmailAddress sender) {
-        this.prInstance = prInstance;
+    ReviewArchive(PullRequest pr, EmailAddress sender) {
+        this.pr = pr;
         this.sender = sender;
     }
 
     void addComment(Comment comment) {
         comments.add(comment);
@@ -49,11 +50,11 @@
                         .filter(item -> item.parent().isPresent())
                         .filter(item -> item.parent().get().equals(parent))
                         .findAny();
     }
 
-    private List<ArchiveItem> generateArchiveItems(List<Email> sentEmails, Repository localRepo, URI issueTracker, String issuePrefix, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, String subjectPrefix) {
+    private List<ArchiveItem> generateArchiveItems(List<Email> sentEmails, Repository localRepo, URI issueTracker, String issuePrefix, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, String subjectPrefix) throws IOException {
         var generated = new ArrayList<ArchiveItem>();
         Hash lastBase = null;
         Hash lastHead = null;
         int revisionIndex = 0;
         var threadPrefix = "RFR";
@@ -62,13 +63,13 @@
             var first = sentEmails.get(0);
             if (first.hasHeader("PR-Thread-Prefix")) {
                 threadPrefix = first.headerValue("PR-Thread-Prefix");
             }
         } else {
-            if (prInstance.pr().state() != Issue.State.OPEN) {
+            if (pr.state() != Issue.State.OPEN) {
                 threadPrefix = "FYI";
-            } else if (prInstance.pr().labels().contains("failed-auto-merge")) {
+            } else if (pr.labels().contains("failed-auto-merge")) {
                 threadPrefix = "";
             }
         }
 
         // Check existing generated mails to find which hashes have been previously reported
@@ -77,56 +78,58 @@
                 var curBase = new Hash(email.headerValue("PR-Base-Hash"));
                 var curHead = new Hash(email.headerValue("PR-Head-Hash"));
                 var created = email.date();
 
                 if (generated.isEmpty()) {
-                    var first = ArchiveItem.from(prInstance, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, prInstance.pr().createdAt(), prInstance.pr().updatedAt(), curBase, curHead, subjectPrefix, threadPrefix);
+                    var first = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), curBase, curHead, subjectPrefix, threadPrefix);
                     generated.add(first);
                 } else {
-                    var revision = ArchiveItem.from(prInstance.pr(), localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, created, created, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
+                    var revision = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, created, created, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
                     generated.add(revision);
                 }
 
                 lastBase = curBase;
                 lastHead = curHead;
             }
         }
 
         // Check if we're at a revision not previously reported
-        if (!prInstance.baseHash().equals(lastBase) || !prInstance.headHash().equals(lastHead)) {
+        var prUtils = new PullRequestUtils(pr);
+        var baseHash = prUtils.baseHash(localRepo);
+        if (!baseHash.equals(lastBase) || !pr.headHash().equals(lastHead)) {
             if (generated.isEmpty()) {
-                var first = ArchiveItem.from(prInstance, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, prInstance.pr().createdAt(), prInstance.pr().updatedAt(), prInstance.baseHash(), prInstance.headHash(), subjectPrefix, threadPrefix);
+                var first = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), baseHash, pr.headHash(), subjectPrefix, threadPrefix);
                 generated.add(first);
             } else {
-                var revision = ArchiveItem.from(prInstance.pr(), localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, prInstance.pr().updatedAt(), prInstance.pr().updatedAt(), lastBase, lastHead, prInstance.baseHash(), prInstance.headHash(), ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
+                var revision = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, pr.updatedAt(), pr.updatedAt(), lastBase, lastHead, baseHash, pr.headHash(), ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
                 generated.add(revision);
             }
         }
 
         // A review always have a revision mail as parent, so start with these
         for (var review : reviews) {
             var parent = ArchiveItem.findParent(generated, review);
-            var reply = ArchiveItem.from(prInstance.pr(), review, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, parent);
+            var reply = ArchiveItem.from(pr, review, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, parent);
             generated.add(reply);
         }
         // Comments have either a comment or a review as parent, the eligible ones have been generated at this point
         for (var comment : comments) {
             var parent = ArchiveItem.findParent(generated, comment);
-            var reply = ArchiveItem.from(prInstance.pr(), comment, hostUserToEmailAuthor, parent);
+            var reply = ArchiveItem.from(pr, comment, hostUserToEmailAuthor, parent);
             generated.add(reply);
         }
         // Finally, file specific comments should be seen after general review comments
         for (var reviewComment : reviewComments) {
             var parent = ArchiveItem.findParent(generated, reviewComments, reviewComment);
-            var reply = ArchiveItem.from(prInstance.pr(), reviewComment, hostUserToEmailAuthor, parent);
+            var reply = ArchiveItem.from(pr, reviewComment, hostUserToEmailAuthor, parent);
             generated.add(reply);
         }
 
         // Post a closed notice for regular RFR threads that weren't integrated
-        if ((prInstance.pr().state() != Issue.State.OPEN) && threadPrefix.equals("RFR") && !prInstance.pr().labels().contains("integrated")) {
+        if ((pr.state() != Issue.State.OPEN) && threadPrefix.equals("RFR") && !pr.labels().contains("integrated")) {
             var parent = generated.get(0);
-            var reply = ArchiveItem.closedNotice(prInstance.pr(), hostUserToEmailAuthor, parent, subjectPrefix, threadPrefix);
+            var reply = ArchiveItem.closedNotice(pr, hostUserToEmailAuthor, parent, subjectPrefix, threadPrefix);
             generated.add(reply);
         }
 
         return generated;
     }
@@ -208,27 +211,27 @@
                      .orElseThrow();
     }
 
     private EmailAddress getUniqueMessageId(String identifier) {
         try {
-            var prSpecific = prInstance.pr().repository().name().replace("/", ".") + "." + prInstance.pr().id();
+            var prSpecific = pr.repository().name().replace("/", ".") + "." + pr.id();
             var digest = MessageDigest.getInstance("SHA-256");
             digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
             digest.update(identifier.getBytes(StandardCharsets.UTF_8));
             var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
 
-            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + prInstance.pr().repository().url().getHost());
+            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + pr.repository().url().getHost());
         } catch (NoSuchAlgorithmException e) {
             throw new RuntimeException("Cannot find SHA-256");
         }
     }
 
     private String getStableMessageId(EmailAddress uniqueMessageId) {
         return uniqueMessageId.localPart().split("\\.")[0];
     }
 
-    List<Email> generateNewEmails(List<Email> sentEmails, Duration cooldown, Repository localRepo, URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole, String subjectPrefix, Consumer<Instant> retryConsumer) {
+    List<Email> generateNewEmails(List<Email> sentEmails, Duration cooldown, Repository localRepo, URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator, WebrevNotification webrevNotification, HostUserToEmailAuthor hostUserToEmailAuthor, HostUserToUserName hostUserToUserName, HostUserToRole hostUserToRole, String subjectPrefix, Consumer<Instant> retryConsumer) throws IOException {
         var ret = new ArrayList<Email>();
         var allItems = generateArchiveItems(sentEmails, localRepo, issueTracker, issuePrefix, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, webrevGenerator, webrevNotification, subjectPrefix);
         var sentItemIds = sentItemIds(sentEmails);
         var unsentItems = allItems.stream()
                                   .filter(item -> !sentItemIds.contains(getStableMessageId(getUniqueMessageId(item.id()))))
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -37,46 +37,51 @@
 import java.util.stream.*;
 
 class CheckRun {
     private final CheckWorkItem workItem;
     private final PullRequest pr;
-    private final PullRequestInstance prInstance;
-    private final CheckablePullRequest checkablePullRequest;
+    private final Repository localRepo;
     private final List<Comment> comments;
     private final List<Review> allReviews;
     private final List<Review> activeReviews;
     private final Set<String> labels;
     private final CensusInstance censusInstance;
     private final boolean ignoreStaleReviews;
 
+    private final Hash baseHash;
+    private final CheckablePullRequest checkablePullRequest;
+
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
     private final String progressMarker = "<!-- Anything below this marker will be automatically updated, please do not edit manually! -->";
     private final String mergeReadyMarker = "<!-- PullRequestBot merge is ready comment -->";
     private final String outdatedHelpMarker = "<!-- PullRequestBot outdated help comment -->";
     private final String sourceBranchWarningMarker = "<!-- PullRequestBot source branch warning comment -->";
     private final Set<String> newLabels;
 
-    private CheckRun(CheckWorkItem workItem, PullRequest pr, PullRequestInstance prInstance, List<Comment> comments,
+    private CheckRun(CheckWorkItem workItem, PullRequest pr, Repository localRepo, List<Comment> comments,
                      List<Review> allReviews, List<Review> activeReviews, Set<String> labels,
-                     CensusInstance censusInstance, boolean ignoreStaleReviews) {
+                     CensusInstance censusInstance, boolean ignoreStaleReviews) throws IOException {
         this.workItem = workItem;
         this.pr = pr;
-        this.prInstance = prInstance;
-        this.checkablePullRequest = new CheckablePullRequest(prInstance, ignoreStaleReviews);
+        this.localRepo = localRepo;
         this.comments = comments;
         this.allReviews = allReviews;
         this.activeReviews = activeReviews;
         this.labels = new HashSet<>(labels);
         this.newLabels = new HashSet<>(labels);
         this.censusInstance = censusInstance;
         this.ignoreStaleReviews = ignoreStaleReviews;
+
+        var prUtils = new PullRequestUtils(pr);
+        baseHash = prUtils.baseHash(localRepo);
+        checkablePullRequest = new CheckablePullRequest(pr, localRepo, ignoreStaleReviews);
     }
 
-    static void execute(CheckWorkItem workItem, PullRequest pr, PullRequestInstance prInstance, List<Comment> comments,
+    static void execute(CheckWorkItem workItem, PullRequest pr, Repository localRepo, List<Comment> comments,
                         List<Review> allReviews, List<Review> activeReviews, Set<String> labels, CensusInstance censusInstance,
-                        boolean ignoreStaleReviews) {
-        var run = new CheckRun(workItem, pr, prInstance, comments, allReviews, activeReviews, labels, censusInstance, ignoreStaleReviews);
+                        boolean ignoreStaleReviews) throws IOException {
+        var run = new CheckRun(workItem, pr, localRepo, comments, allReviews, activeReviews, labels, censusInstance, ignoreStaleReviews);
         run.checkStatus();
     }
 
     private boolean isTargetBranchAllowed() {
         var matcher = workItem.bot.allowedTargetBranches().matcher(pr.targetRef());
@@ -127,13 +132,12 @@
                     .map(name -> "   - " + name)
                     .collect(Collectors.joining("\n"));
             ret.add(error);
         }
 
-        var baseHash = prInstance.baseHash();
         var headHash = pr.headHash();
-        var originalCommits = prInstance.localRepo().commitMetadata(baseHash, headHash);
+        var originalCommits = localRepo.commitMetadata(baseHash, headHash);
 
         if (!checkCommitAuthor(originalCommits)) {
             var error = "For contributors who are not existing OpenJDK Authors, commit attribution will be taken from " +
                     "the commits in the PR. However, the commits in this PR have inconsistent user names and/or " +
                     "email addresses. Please amend the commits.";
@@ -401,11 +405,11 @@
         message.append(pr.author().userName());
         message.append(" This change now passes all automated pre-integration checks");
 
         try {
             var hasContributingFile =
-                !prInstance.localRepo().files(prInstance.targetHash(), Path.of("CONTRIBUTING.md")).isEmpty();
+                !localRepo.files(pr.targetHash(), Path.of("CONTRIBUTING.md")).isEmpty();
             if (hasContributingFile) {
                 message.append(". When the change also fulfills all ");
                 message.append("[project specific requirements](https://github.com/");
                 message.append(pr.repository().name());
                 message.append("/blob/");
@@ -444,11 +448,11 @@
                 message.append("As there are no conflicts, your changes will automatically be rebased on top of ");
                 message.append("these commits when integrating. If you prefer to avoid automatic rebasing, please merge `");
                 message.append(pr.targetRef());
                 message.append("` into your branch, and then specify the current head hash when integrating, like this: ");
                 message.append("`/integrate ");
-                message.append(prInstance.targetHash());
+                message.append(pr.targetHash());
                 message.append("`.\n");
             } else {
                 message.append("Your changes cannot be rebased automatically without conflicts, so you will need to ");
                 message.append("merge `");
                 message.append(pr.targetRef());
@@ -460,11 +464,11 @@
             message.append(pr.targetRef());
             message.append("` branch since the last update of the source branch of this PR. If another commit should be pushed before ");
             message.append("you perform the `/integrate` command, your PR will be automatically rebased. If you would like to avoid ");
             message.append("potential automatic rebasing, specify the current head hash when integrating, like this: ");
             message.append("`/integrate ");
-            message.append(prInstance.targetHash());
+            message.append(pr.targetHash());
             message.append("`.\n");
         }
 
         if (!ProjectPermissions.mayCommit(censusInstance, pr.author())) {
             message.append("\n");
@@ -522,11 +526,11 @@
         } else {
             existing.ifPresent(comment -> pr.updateComment(comment.id(), getMergeNoLongerReadyComment()));
         }
     }
 
-    private void addSourceBranchWarningComment(List<Comment> comments) {
+    private void addSourceBranchWarningComment(List<Comment> comments) throws IOException {
         var existing = findComment(comments, sourceBranchWarningMarker);
         if (existing.isPresent()) {
             // Only add the comment once per PR
             return;
         }
@@ -543,11 +547,11 @@
             "_Note_: you do *not* have to name the new branch `NEW-BRANCH-NAME`." +
             "\n" +
             "```" +
             "$ git checkout " + branch + "\n" +
             "$ git checkout -b NEW-BRANCH-NAME\n" +
-            "$ git branch -f " + branch + " " + prInstance.baseHash().hex() + "\n" +
+            "$ git branch -f " + branch + " " + baseHash.hex() + "\n" +
             "$ git push -f origin " + branch + "\n" +
             "```\n" +
             "\n" +
             "Then proceed to create a new pull request with `NEW-BRANCH-NAME` as the source branch and " +
             "close this one.\n" +
@@ -600,16 +604,16 @@
             Hash localHash;
             try {
                 localHash = checkablePullRequest.commit(commitHash, censusInstance.namespace(), censusDomain, null);
             } catch (CommitFailure e) {
                 additionalErrors = List.of(e.getMessage());
-                localHash = prInstance.baseHash();
+                localHash = baseHash;
             }
             PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(localHash, censusInstance);
-            if (!localHash.equals(prInstance.baseHash())) {
+            if (!localHash.equals(baseHash)) {
                 // Determine current status
-                var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), comments);
+                var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash, pr.repository().forge().currentUser(), comments);
                 checkablePullRequest.executeChecks(localHash, censusInstance, visitor, additionalConfiguration);
                 additionalErrors = botSpecificChecks(localHash);
             } else {
                 if (additionalErrors.isEmpty()) {
                     additionalErrors = List.of("This PR contains no changes");
@@ -625,11 +629,11 @@
             // Post / update approval messages (only needed if the review itself can't contain a body)
             if (!pr.repository().forge().supportsReviewBody()) {
                 updateReviewedMessages(comments, allReviews);
             }
 
-            var commit = prInstance.localRepo().lookup(localHash).orElseThrow();
+            var commit = localRepo.lookup(localHash).orElseThrow();
             var commitMessage = String.join("\n", commit.message());
             var readyForIntegration = visitor.getMessages().isEmpty() && additionalErrors.isEmpty();
             updateMergeReadyComment(readyForIntegration, commitMessage, comments, activeReviews, rebasePossible);
             if (readyForIntegration && rebasePossible) {
                 newLabels.add("ready");
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
@@ -147,16 +147,16 @@
                 return;
             }
 
             try {
                 var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
-                var prInstance = new PullRequestInstance(scratchPath.resolve("pr").resolve("check"),
-                                                         new HostedRepositoryPool(seedPath),
-                                                         pr);
-                var checkablePr = new CheckablePullRequest(prInstance,
-                                                         bot.ignoreStaleReviews());
-                CheckRun.execute(this, pr, prInstance, comments, allReviews, activeReviews, labels, census, bot.ignoreStaleReviews());
+                var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
+                var localRepoPath = scratchPath.resolve("pr").resolve("check");
+                var localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(pr.repository().name()));
+                localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":checkworkitem", false);
+
+                CheckRun.execute(this, pr, localRepo, comments, allReviews, activeReviews, labels, census, bot.ignoreStaleReviews());
             } catch (IOException e) {
                 throw new UncheckedIOException(e);
             }
         }
     }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
@@ -32,39 +32,41 @@
 import java.io.*;
 import java.util.*;
 import java.util.stream.Collectors;
 
 public class CheckablePullRequest {
-    private final PullRequestInstance prInstance;
+    private final PullRequest pr;
+    private final Repository localRepo;
     private final boolean ignoreStaleReviews;
 
-    CheckablePullRequest(PullRequestInstance prInstance, boolean ignoreStaleReviews) {
-        this.prInstance = prInstance;
+    CheckablePullRequest(PullRequest pr, Repository localRepo, boolean ignoreStaleReviews) {
+        this.pr = pr;
+        this.localRepo = localRepo;
         this.ignoreStaleReviews = ignoreStaleReviews;
     }
 
     private String commitMessage(List<Review> activeReviews, Namespace namespace) throws IOException {
         var reviewers = activeReviews.stream()
-                                     .filter(review -> !ignoreStaleReviews || review.hash().equals(prInstance.headHash()))
+                                     .filter(review -> !ignoreStaleReviews || review.hash().equals(pr.headHash()))
                                      .filter(review -> review.verdict() == Review.Verdict.APPROVED)
                                      .map(review -> review.reviewer().id())
                                      .map(namespace::get)
                                      .filter(Objects::nonNull)
                                      .map(Contributor::username)
                                      .collect(Collectors.toList());
 
-        var comments = prInstance.pr().comments();
-        var currentUser = prInstance.pr().repository().forge().currentUser();
+        var comments = pr.comments();
+        var currentUser = pr.repository().forge().currentUser();
         var additionalContributors = Contributors.contributors(currentUser,
                                                                comments).stream()
                                                  .map(email -> Author.fromString(email.toString()))
                                                  .collect(Collectors.toList());
 
         var additionalIssues = SolvesTracker.currentSolved(currentUser, comments);
         var summary = Summary.summary(currentUser, comments);
-        var issue = Issue.fromString(prInstance.pr().title());
-        var commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(prInstance.pr().title()));
+        var issue = Issue.fromString(pr.title());
+        var commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(pr.title()));
         if (issue.isPresent()) {
             commitMessageBuilder.issues(additionalIssues);
         }
         commitMessageBuilder.contributors(additionalContributors)
                             .reviewers(reviewers);
@@ -88,19 +90,21 @@
     }
 
     Hash commit(Hash finalHead, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
         Author committer;
         Author author;
-        var contributor = namespace.get(prInstance.pr().author().id());
+        var contributor = namespace.get(pr.author().id());
+
+        var prUtils = new PullRequestUtils(pr);
 
         if (contributor == null) {
-            if (prInstance.isMerge()) {
+            if (prUtils.isMerge()) {
                 throw new CommitFailure("Merges can only be performed by Committers.");
             }
 
             // Use the information contained in the head commit - jcheck has verified that it contains sane values
-            var headCommit = prInstance.localRepo().commitMetadata(prInstance.headHash().hex() + "^.." + prInstance.headHash().hex()).get(0);
+            var headCommit = localRepo.commitMetadata(pr.headHash().hex() + "^.." + pr.headHash().hex()).get(0);
             author = headCommit.author();
         } else {
             author = new Author(contributor.fullName().orElseThrow(), contributor.username() + "@" + censusDomain);
         }
 
@@ -109,66 +113,66 @@
             committer = new Author(sponsorContributor.fullName().orElseThrow(), sponsorContributor.username() + "@" + censusDomain);
         } else {
             committer = author;
         }
 
-        var activeReviews = filterActiveReviews(prInstance.pr().reviews());
+        var activeReviews = filterActiveReviews(pr.reviews());
         var commitMessage = commitMessage(activeReviews, namespace);
-        return prInstance.commit(finalHead, author, committer, commitMessage);
+        return prUtils.createCommit(localRepo, finalHead, author, committer, commitMessage);
     }
 
     PullRequestCheckIssueVisitor createVisitor(Hash localHash, CensusInstance censusInstance) throws IOException {
-        var checks = JCheck.checksFor(prInstance.localRepo(), censusInstance.census(), prInstance.targetHash());
+        var checks = JCheck.checksFor(localRepo, censusInstance.census(), pr.targetHash());
         return new PullRequestCheckIssueVisitor(checks);
     }
 
     void executeChecks(Hash localHash, CensusInstance censusInstance, PullRequestCheckIssueVisitor visitor, List<String> additionalConfiguration) throws Exception {
-        try (var issues = JCheck.check(prInstance.localRepo(), censusInstance.census(), CommitMessageParsers.v1, localHash,
-                                       prInstance.targetHash(), additionalConfiguration)) {
+        try (var issues = JCheck.check(localRepo, censusInstance.census(), CommitMessageParsers.v1, localHash,
+                                       pr.targetHash(), additionalConfiguration)) {
             for (var issue : issues) {
                 issue.accept(visitor);
             }
         }
     }
 
     List<CommitMetadata> divergingCommits() {
-        return divergingCommits(prInstance.headHash());
+        return divergingCommits(pr.headHash());
     }
 
     private List<CommitMetadata> divergingCommits(Hash commitHash) {
         try {
-            var updatedBase = prInstance.localRepo().mergeBase(prInstance.targetHash(), commitHash);
-            return prInstance.localRepo().commitMetadata(updatedBase, prInstance.targetHash());
+            var updatedBase = localRepo.mergeBase(pr.targetHash(), commitHash);
+            return localRepo.commitMetadata(updatedBase, pr.targetHash());
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
 
     Optional<Hash> mergeTarget(PrintWriter reply) {
-        var divergingCommits = divergingCommits(prInstance.headHash());
+        var divergingCommits = divergingCommits(pr.headHash());
         if (divergingCommits.size() > 0) {
             reply.print("The following commits have been pushed to ");
-            reply.print(prInstance.pr().targetRef());
+            reply.print(pr.targetRef());
             reply.println(" since your change was applied:");
             divergingCommits.forEach(c -> reply.println(" * " + c.hash().hex() + ": " + c.message().get(0)));
 
             try {
-                prInstance.localRepo().checkout(prInstance.headHash(), true);
-                prInstance.localRepo().merge(prInstance.targetHash());
-                var hash = prInstance.localRepo().commit("Automatic merge with latest target", "duke", "duke@openjdk.org");
+                localRepo.checkout(pr.headHash(), true);
+                localRepo.merge(pr.targetHash());
+                var hash = localRepo.commit("Automatic merge with latest target", "duke", "duke@openjdk.org");
                 reply.println();
                 reply.println("Your commit was automatically rebased without conflicts.");
                 return Optional.of(hash);
             } catch (IOException e) {
                 reply.println();
                 reply.print("It was not possible to rebase your changes automatically. Please merge `");
-                reply.print(prInstance.pr().targetRef());
+                reply.print(pr.targetRef());
                 reply.println("` into your branch and try again.");
                 return Optional.empty();
             }
         } else {
             // No merge needed
-            return Optional.of(prInstance.headHash());
+            return Optional.of(pr.headHash());
         }
     }
 
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
@@ -88,23 +88,23 @@
 
         // Run a final jcheck to ensure the change has been properly reviewed
         try {
             var sanitizedUrl = URLEncoder.encode(pr.repository().webUrl().toString(), StandardCharsets.UTF_8);
             var path = scratchPath.resolve("integrate").resolve(sanitizedUrl);
-
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
-            var prInstance = new PullRequestInstance(path,
-                                                     new HostedRepositoryPool(seedPath),
-                                                     pr);
-            var checkablePr = new CheckablePullRequest(prInstance, bot.ignoreStaleReviews());
+            var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
+            var localRepo = hostedRepositoryPool.checkout(pr, path);
+            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":integratecommand", false);
+            var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews());
+
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
                 var wantedHash = new Hash(args);
-                if (!prInstance.targetHash().equals(wantedHash)) {
+                if (!pr.targetHash().equals(wantedHash)) {
                     reply.print("The head of the target branch is no longer at the requested hash " + wantedHash);
-                    reply.println(" - it has moved to " + prInstance.targetHash() + ". Aborting integration.");
+                    reply.println(" - it has moved to " + pr.targetHash() + ". Aborting integration.");
                     return;
                 }
             };
 
             // Now merge the latest changes from the target
@@ -116,11 +116,11 @@
             }
 
             var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(), null);
 
             var issues = checkablePr.createVisitor(localHash, censusInstance);
-            var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), allComments);
+            var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash, pr.repository().forge().currentUser(), allComments);
             checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
             if (!issues.getMessages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
                 reply.println("your changes failed the final jcheck:");
                 issues.getMessages().stream()
@@ -142,11 +142,11 @@
 
             // Rebase and push it!
             if (!localHash.equals(pr.targetHash())) {
                 reply.println(rebaseMessage.toString());
                 reply.println("Pushed as commit " + localHash.hex() + ".");
-                prInstance.localRepo().push(localHash, pr.repository().url(), pr.targetRef());
+                localRepo.push(localHash, pr.repository().url(), pr.targetRef());
                 pr.setState(PullRequest.State.CLOSED);
                 pr.addLabel("integrated");
                 pr.removeLabel("ready");
                 pr.removeLabel("rfr");
             } else {
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
@@ -21,10 +21,11 @@
  * questions.
  */
 package org.openjdk.skara.bots.pr;
 
 import org.openjdk.skara.forge.*;
+import org.openjdk.skara.vcs.Repository;
 
 import java.io.*;
 import java.nio.file.Path;
 import java.util.*;
 import java.util.function.Consumer;
@@ -38,13 +39,14 @@
     @Override
     public String toString() {
         return "LabelerWorkItem@" + pr.repository().name() + "#" + pr.id();
     }
 
-    private Set<String> getLabels(PullRequestInstance prInstance) throws IOException {
+    private Set<String> getLabels(Repository localRepo) throws IOException {
         var labels = new HashSet<String>();
-        var files = prInstance.changedFiles();
+        var prUtils = new PullRequestUtils(pr);
+        var files = prUtils.changedFiles(localRepo);
         for (var file : files) {
             for (var label : bot.labelPatterns().entrySet()) {
                 for (var pattern : label.getValue()) {
                     var matcher = pattern.matcher(file.toString());
                     if (matcher.find()) {
@@ -61,15 +63,16 @@
     public void run(Path scratchPath) {
         if (bot.currentLabels().containsKey(pr.headHash())) {
             return;
         }
         try {
+            var path = scratchPath.resolve("pr").resolve("labeler").resolve(pr.repository().name());
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
-            var prInstance = new PullRequestInstance(scratchPath.resolve("pr").resolve("labeler"),
-                                                     new HostedRepositoryPool(seedPath),
-                                                     pr);
-            var newLabels = getLabels(prInstance);
+            var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
+            var localRepo = hostedRepositoryPool.checkout(pr, path);
+            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":labelerworkitem", false);
+            var newLabels = getLabels(localRepo);
             var currentLabels = pr.labels().stream()
                                   .filter(key -> bot.labelPatterns().containsKey(key))
                                   .collect(Collectors.toSet());
 
             // Add all labels not already set
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
@@ -73,23 +73,23 @@
 
         // Execute merge
         try {
             var sanitizedUrl = URLEncoder.encode(pr.repository().webUrl().toString(), StandardCharsets.UTF_8);
             var path = scratchPath.resolve("sponsor").resolve(sanitizedUrl);
-
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
-            var prInstance = new PullRequestInstance(path,
-                                                     new HostedRepositoryPool(seedPath),
-                                                     pr);
-            var checkablePr = new CheckablePullRequest(prInstance, bot.ignoreStaleReviews());
+            var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
+            var localRepo = hostedRepositoryPool.checkout(pr, path);
+            localRepo.fetch(pr.repository().url(), "+" + pr.targetRef() + ":sponsorcommand", false);
+            var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews());
+
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
                 var wantedHash = new Hash(args);
-                if (!prInstance.targetHash().equals(wantedHash)) {
+                if (!pr.targetHash().equals(wantedHash)) {
                     reply.print("The head of the target branch is no longer at the requested hash " + wantedHash);
-                    reply.println(" - it has moved to " + prInstance.targetHash() + ". Aborting integration.");
+                    reply.println(" - it has moved to " + pr.targetHash() + ". Aborting integration.");
                     return;
                 }
             }
 
             // Now rebase onto the target hash
@@ -102,11 +102,11 @@
 
             var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(),
                     comment.author().id());
 
             var issues = checkablePr.createVisitor(localHash, censusInstance);
-            var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), allComments);
+            var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash, pr.repository().forge().currentUser(), allComments);
             checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
             if (!issues.getMessages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
                 reply.println("your changes failed the final jcheck:");
                 issues.getMessages().stream()
@@ -116,11 +116,11 @@
             }
 
             if (!localHash.equals(pr.targetHash())) {
                 reply.println(rebaseMessage.toString());
                 reply.println("Pushed as commit " + localHash.hex() + ".");
-                prInstance.localRepo().push(localHash, pr.repository().url(), pr.targetRef());
+                localRepo.push(localHash, pr.repository().url(), pr.targetRef());
                 pr.setState(PullRequest.State.CLOSED);
                 pr.addLabel("integrated");
                 pr.removeLabel("sponsor");
                 pr.removeLabel("ready");
                 pr.removeLabel("rfr");
diff a/forge/src/main/java/org/openjdk/skara/forge/PullRequestInstance.java b/forge/src/main/java/org/openjdk/skara/forge/PullRequestInstance.java
--- a/forge/src/main/java/org/openjdk/skara/forge/PullRequestInstance.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.forge;
-
-import org.openjdk.skara.vcs.*;
-
-import java.io.*;
-import java.nio.file.Path;
-import java.time.ZonedDateTime;
-import java.util.*;
-import java.util.regex.Pattern;
-
-public class PullRequestInstance {
-    private final PullRequest pr;
-    private final Repository localRepo;
-    private final Hash targetHash;
-    private final Hash headHash;
-    private final Hash baseHash;
-
-    public PullRequestInstance(Path localRepoPath, HostedRepositoryPool hostedRepositoryPool, PullRequest pr) throws IOException {
-        this.pr = pr;
-
-        // Materialize the PR's source and target ref
-        var repository = pr.repository();
-        localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(repository.name()));
-        localRepo.fetch(repository.url(), "+" + pr.targetRef() + ":pr_prinstance", false);
-
-        targetHash = pr.targetHash();
-        headHash = pr.headHash();
-        baseHash = localRepo.mergeBase(targetHash, headHash);
-    }
-
-    private Hash commitSquashed(Hash finalHead, Author author, Author committer, String commitMessage) throws IOException {
-        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
-                                committer.name(), committer.email(), ZonedDateTime.now(), List.of(targetHash), localRepo.tree(finalHead));
-    }
-
-    private static class MergeSource {
-        private final String repositoryName;
-        private final String branchName;
-
-        private MergeSource(String repositoryName, String branchName) {
-            this.repositoryName = repositoryName;
-            this.branchName = branchName;
-        }
-    }
-
-    private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
-    private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
-
-    private Optional<MergeSource> mergeSource() {
-        var repoMatcher = mergeSourceFullPattern.matcher(pr.title());
-        if (!repoMatcher.matches()) {
-            var branchMatcher = mergeSourceBranchOnlyPattern.matcher(pr.title());
-            if (!branchMatcher.matches()) {
-                return Optional.empty();
-            }
-
-            // Verify that the branch exists
-            var isValidBranch = remoteBranches().stream()
-                    .map(Reference::name)
-                    .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
-            if (!isValidBranch) {
-                // Assume the name refers to a sibling repository
-                var repoName = Path.of(pr.repository().name()).resolveSibling(branchMatcher.group(1)).toString();
-                return Optional.of(new MergeSource(repoName, "master"));
-            }
-
-            return Optional.of(new MergeSource(pr.repository().name(), branchMatcher.group(1)));
-        }
-
-        return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
-    }
-
-    private CommitMetadata findSourceMergeCommit(List<CommitMetadata> commits) throws IOException, CommitFailure {
-        if (commits.size() < 2) {
-            throw new CommitFailure("A merge PR must contain at least two commits that are not already present in the target.");
-        }
-
-        var source = mergeSource();
-        if (source.isEmpty()) {
-            throw new CommitFailure("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
-                    "Merge `project`:`branch` to allow verification of the merge contents.");
-        }
-
-        // Fetch the source
-        Hash sourceHash;
-        try {
-            var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() ->
-                    new RuntimeException("Could not find repository " + source.get().repositoryName)
-            );
-            try {
-                sourceHash = localRepo.fetch(mergeSourceRepo.url(), source.get().branchName, false);
-            } catch (IOException e) {
-                throw new CommitFailure("Could not fetch branch `" + source.get().branchName + "` from project `" +
-                        source.get().repositoryName + "` - check that they are correct.");
-            }
-        } catch (RuntimeException e) {
-            throw new CommitFailure("Could not find project `" +
-                    source.get().repositoryName + "` - check that it is correct.");
-        }
-
-
-        // Find the first merge commit with a parent that is an ancestor of the source
-        int mergeCommitIndex = commits.size();
-        for (int i = 0; i < commits.size() - 1; ++i) {
-            if (commits.get(i).isMerge()) {
-                boolean isSourceMerge = false;
-                for (int j = 0; j < commits.get(i).parents().size(); ++j) {
-                    if (localRepo.isAncestor(commits.get(i).parents().get(j), sourceHash)) {
-                        isSourceMerge = true;
-                    }
-                }
-                if (isSourceMerge) {
-                    mergeCommitIndex = i;
-                    break;
-                }
-            }
-        }
-        if (mergeCommitIndex >= commits.size() - 1) {
-            throw new CommitFailure("A merge PR must contain a merge commit as well as at least one other commit from the merge source.");
-        }
-
-        return commits.get(mergeCommitIndex);
-    }
-
-    private Hash commitMerge(Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
-        var commits = localRepo.commitMetadata(baseHash, finalHead);
-        var mergeCommit = findSourceMergeCommit(commits);
-
-        // Find the parent which is on the target branch - we will replace it with the target hash (if there were no merge conflicts)
-        Hash firstParent = null;
-        var finalParents = new ArrayList<Hash>();
-        for (int i = 0; i < mergeCommit.parents().size(); ++i) {
-            if (localRepo.isAncestor(mergeCommit.parents().get(i), targetHash)) {
-                if (firstParent == null) {
-                    firstParent = localRepo.mergeBase(targetHash, finalHead);
-                    continue;
-                }
-            }
-            finalParents.add(mergeCommit.parents().get(i));
-        }
-        if (firstParent == null) {
-            throw new CommitFailure("The merge commit must have a commit on the target branch as one of its parents.");
-        }
-        finalParents.add(0, firstParent);
-
-        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
-                committer.name(), committer.email(), ZonedDateTime.now(), finalParents, localRepo.tree(finalHead));
-    }
-
-    public boolean isMerge() {
-        return pr.title().startsWith("Merge");
-    }
-
-    public Hash commit(Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
-        Hash commit;
-        if (!isMerge()) {
-            commit = commitSquashed(finalHead, author, committer, commitMessage);
-        } else {
-            commit = commitMerge(finalHead, author, committer, commitMessage);
-        }
-        localRepo.checkout(commit, true);
-        return commit;
-    }
-
-    public PullRequest pr() {
-        return pr;
-    }
-
-    public Repository localRepo() {
-        return localRepo;
-    }
-
-    public Hash baseHash() {
-        return baseHash;
-    }
-
-    public Hash targetHash() {
-        return targetHash;
-    }
-
-    public Hash headHash() {
-        return headHash;
-    }
-
-    public Set<Path> changedFiles() throws IOException {
-        var ret = new HashSet<Path>();
-        var changes = localRepo.diff(baseHash, headHash);
-        for (var patch : changes.patches()) {
-            patch.target().path().ifPresent(ret::add);
-            patch.source().path().ifPresent(ret::add);
-        }
-        return ret;
-    }
-
-    List<Reference> remoteBranches() {
-        try {
-            return localRepo.remoteBranches(pr.repository().url().toString());
-        } catch (IOException e) {
-            return List.of();
-        }
-    }
-}
diff a/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java b/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
--- /dev/null
+++ b/forge/src/main/java/org/openjdk/skara/forge/PullRequestUtils.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.forge;
+
+import org.openjdk.skara.vcs.*;
+
+import java.io.*;
+import java.nio.file.Path;
+import java.time.ZonedDateTime;
+import java.util.*;
+import java.util.regex.Pattern;
+
+public class PullRequestUtils {
+    private final PullRequest pr;
+
+    public PullRequestUtils(PullRequest pr)  {
+        this.pr = pr;
+    }
+
+    private Hash commitSquashed(Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException {
+        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
+                                committer.name(), committer.email(), ZonedDateTime.now(), List.of(pr.targetHash()), localRepo.tree(finalHead));
+    }
+
+    private static class MergeSource {
+        private final String repositoryName;
+        private final String branchName;
+
+        private MergeSource(String repositoryName, String branchName) {
+            this.repositoryName = repositoryName;
+            this.branchName = branchName;
+        }
+    }
+
+    private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
+    private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
+
+    private Optional<MergeSource> mergeSource(Repository localRepo) {
+        var repoMatcher = mergeSourceFullPattern.matcher(pr.title());
+        if (!repoMatcher.matches()) {
+            var branchMatcher = mergeSourceBranchOnlyPattern.matcher(pr.title());
+            if (!branchMatcher.matches()) {
+                return Optional.empty();
+            }
+
+            // Verify that the branch exists
+            var isValidBranch = remoteBranches(localRepo).stream()
+                    .map(Reference::name)
+                    .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
+            if (!isValidBranch) {
+                // Assume the name refers to a sibling repository
+                var repoName = Path.of(pr.repository().name()).resolveSibling(branchMatcher.group(1)).toString();
+                return Optional.of(new MergeSource(repoName, "master"));
+            }
+
+            return Optional.of(new MergeSource(pr.repository().name(), branchMatcher.group(1)));
+        }
+
+        return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
+    }
+
+    private CommitMetadata findSourceMergeCommit(Repository localRepo, List<CommitMetadata> commits) throws IOException, CommitFailure {
+        if (commits.size() < 2) {
+            throw new CommitFailure("A merge PR must contain at least two commits that are not already present in the target.");
+        }
+
+        var source = mergeSource(localRepo);
+        if (source.isEmpty()) {
+            throw new CommitFailure("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
+                    "Merge `project`:`branch` to allow verification of the merge contents.");
+        }
+
+        // Fetch the source
+        Hash sourceHash;
+        try {
+            var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() ->
+                    new RuntimeException("Could not find repository " + source.get().repositoryName)
+            );
+            try {
+                sourceHash = localRepo.fetch(mergeSourceRepo.url(), source.get().branchName, false);
+            } catch (IOException e) {
+                throw new CommitFailure("Could not fetch branch `" + source.get().branchName + "` from project `" +
+                        source.get().repositoryName + "` - check that they are correct.");
+            }
+        } catch (RuntimeException e) {
+            throw new CommitFailure("Could not find project `" +
+                    source.get().repositoryName + "` - check that it is correct.");
+        }
+
+
+        // Find the first merge commit with a parent that is an ancestor of the source
+        int mergeCommitIndex = commits.size();
+        for (int i = 0; i < commits.size() - 1; ++i) {
+            if (commits.get(i).isMerge()) {
+                boolean isSourceMerge = false;
+                for (int j = 0; j < commits.get(i).parents().size(); ++j) {
+                    if (localRepo.isAncestor(commits.get(i).parents().get(j), sourceHash)) {
+                        isSourceMerge = true;
+                    }
+                }
+                if (isSourceMerge) {
+                    mergeCommitIndex = i;
+                    break;
+                }
+            }
+        }
+        if (mergeCommitIndex >= commits.size() - 1) {
+            throw new CommitFailure("A merge PR must contain a merge commit as well as at least one other commit from the merge source.");
+        }
+
+        return commits.get(mergeCommitIndex);
+    }
+
+    private Hash commitMerge(Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
+        var commits = localRepo.commitMetadata(baseHash(localRepo), finalHead);
+        var mergeCommit = findSourceMergeCommit(localRepo, commits);
+
+        // Find the parent which is on the target branch - we will replace it with the target hash (if there were no merge conflicts)
+        Hash firstParent = null;
+        var finalParents = new ArrayList<Hash>();
+        for (int i = 0; i < mergeCommit.parents().size(); ++i) {
+            if (localRepo.isAncestor(mergeCommit.parents().get(i), pr.targetHash())) {
+                if (firstParent == null) {
+                    firstParent = localRepo.mergeBase(pr.targetHash(), finalHead);
+                    continue;
+                }
+            }
+            finalParents.add(mergeCommit.parents().get(i));
+        }
+        if (firstParent == null) {
+            throw new CommitFailure("The merge commit must have a commit on the target branch as one of its parents.");
+        }
+        finalParents.add(0, firstParent);
+
+        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
+                committer.name(), committer.email(), ZonedDateTime.now(), finalParents, localRepo.tree(finalHead));
+    }
+
+    public boolean isMerge() {
+        return pr.title().startsWith("Merge");
+    }
+
+    public Hash createCommit(Repository localRepo, Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
+        Hash commit;
+        if (!isMerge()) {
+            commit = commitSquashed(localRepo, finalHead, author, committer, commitMessage);
+        } else {
+            commit = commitMerge(localRepo, finalHead, author, committer, commitMessage);
+        }
+        localRepo.checkout(commit, true);
+        return commit;
+    }
+
+    public Hash baseHash(Repository localRepo) throws IOException {
+        return localRepo.mergeBase(pr.targetHash(), pr.headHash());
+    }
+
+    public Set<Path> changedFiles(Repository localRepo) throws IOException {
+        var ret = new HashSet<Path>();
+        var changes = localRepo.diff(baseHash(localRepo), pr.headHash());
+        for (var patch : changes.patches()) {
+            patch.target().path().ifPresent(ret::add);
+            patch.source().path().ifPresent(ret::add);
+        }
+        return ret;
+    }
+
+    private List<Reference> remoteBranches(Repository localRepo) {
+        try {
+            return localRepo.remoteBranches(pr.repository().url().toString());
+        } catch (IOException e) {
+            return List.of();
+        }
+    }
+}

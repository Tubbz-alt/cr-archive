diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveItem.java
@@ -3,11 +3,11 @@
 import org.openjdk.skara.forge.*;
 import org.openjdk.skara.host.HostUser;
 import org.openjdk.skara.issuetracker.Comment;
 import org.openjdk.skara.vcs.*;
 
-import java.io.IOException;
+import java.io.*;
 import java.net.URI;
 import java.time.ZonedDateTime;
 import java.util.*;
 import java.util.function.Supplier;
 import java.util.regex.Pattern;
@@ -36,56 +36,64 @@
         this.header = header;
         this.body = body;
         this.footer = footer;
     }
 
-    private static Optional<Commit> mergeCommit(Repository localRepo, Hash head) {
+    private static Optional<Commit> mergeCommit(PullRequestInstance prInstance, Hash head) {
         try {
-            return localRepo.lookup(head).filter(Commit::isMerge);
-        } catch (IOException e) {
+            var author = new Author("duke", "duke@openjdk.org");
+            var hash = prInstance.commit(head, author, author, prInstance.pr().title());
+            return prInstance.localRepo().lookup(hash);
+        } catch (IOException | CommitFailure e) {
             return Optional.empty();
         }
     }
 
-    static ArchiveItem from(PullRequest pr, Repository localRepo, HostUserToEmailAuthor hostUserToEmailAuthor,
+    static ArchiveItem from(PullRequestInstance prInstance, HostUserToEmailAuthor hostUserToEmailAuthor,
                             URI issueTracker, String issuePrefix, WebrevStorage.WebrevGenerator webrevGenerator,
                             WebrevNotification webrevNotification, ZonedDateTime created, ZonedDateTime updated,
                             Hash base, Hash head, String subjectPrefix, String threadPrefix) {
-        return new ArchiveItem(null, "fc", created, updated, pr.author(), Map.of("PR-Head-Hash", head.hex(),
-                                                                                 "PR-Base-Hash", base.hex(),
-                                                                                 "PR-Thread-Prefix", threadPrefix),
-                               () -> subjectPrefix + threadPrefix + (threadPrefix.isEmpty() ? "" : ": ") + pr.title(),
+        return new ArchiveItem(null, "fc", created, updated, prInstance.pr().author(), Map.of("PR-Head-Hash", head.hex(),
+                                                                                              "PR-Base-Hash", base.hex(),
+                                                                                              "PR-Thread-Prefix", threadPrefix),
+                               () -> subjectPrefix + threadPrefix + (threadPrefix.isEmpty() ? "" : ": ") + prInstance.pr().title(),
                                () -> "",
-                               () -> ArchiveMessages.composeConversation(pr, localRepo, base, head),
+                               () -> ArchiveMessages.composeConversation(prInstance.pr()),
                                () -> {
-                                   var fullWebrev = webrevGenerator.generate(base, head, "00", WebrevDescription.Type.FULL);
-                                   if (pr.title().startsWith("Merge")) {
-                                       var mergeCommit = mergeCommit(localRepo, head);
-                                        if (mergeCommit.isPresent()) {
-                                            var mergeWebrevs = new ArrayList<WebrevDescription>();
-                                            mergeWebrevs.add(fullWebrev);
-                                            for (int i = 0; i < mergeCommit.get().parentDiffs().size(); ++i) {
-                                                var diff = mergeCommit.get().parentDiffs().get(i);
-                                                switch (i) {
-                                                    case 0:
-                                                        mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_TARGET, pr.targetRef()));
-                                                        break;
-                                                    case 1:
-                                                        var mergeSource = pr.title().length() > 6 ? pr.title().substring(6) : null;
-                                                        mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_SOURCE, mergeSource));
-                                                        break;
-                                                    default:
-                                                        mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_SOURCE, null));
-                                                        break;
-                                                }
-                                            }
-                                            webrevNotification.notify(0, mergeWebrevs);
-                                            return ArchiveMessages.composeMergeConversationFooter(pr, localRepo, mergeWebrevs, base, head);
-                                        }
+                                   if (prInstance.isMerge()) {
+                                       //TODO: Try to merge in target - generate possible conflict webrev
+                                       var mergeCommit = mergeCommit(prInstance, head);
+                                       var mergeWebrevs = new ArrayList<WebrevDescription>();
+                                       if (mergeCommit.isPresent()) {
+                                           for (int i = 0; i < mergeCommit.get().parentDiffs().size(); ++i) {
+                                               var diff = mergeCommit.get().parentDiffs().get(i);
+                                               if (diff.patches().size() == 0) {
+                                                   continue;
+                                               }
+                                               switch (i) {
+                                                   case 0:
+                                                       mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_TARGET, prInstance.pr().targetRef()));
+                                                       break;
+                                                   case 1:
+                                                       var mergeSource = prInstance.pr().title().length() > 6 ? prInstance.pr().title().substring(6) : null;
+                                                       mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_SOURCE, mergeSource));
+                                                       break;
+                                                   default:
+                                                       mergeWebrevs.add(webrevGenerator.generate(diff, String.format("00.%d", i), WebrevDescription.Type.MERGE_SOURCE, null));
+                                                       break;
+                                               }
+                                           }
+                                           if (!mergeWebrevs.isEmpty()) {
+                                               webrevNotification.notify(0, mergeWebrevs);
+                                           }
+                                       }
+                                       return ArchiveMessages.composeMergeConversationFooter(prInstance.pr(), prInstance.localRepo(), mergeWebrevs, base, head);
+                                   } else {
+                                       var fullWebrev = webrevGenerator.generate(base, head, "00", WebrevDescription.Type.FULL);
+                                       webrevNotification.notify(0, List.of(fullWebrev));
+                                       return ArchiveMessages.composeConversationFooter(prInstance.pr(), issueTracker, issuePrefix, prInstance.localRepo(), fullWebrev, base, head);
                                    }
-                                   webrevNotification.notify(0, List.of(fullWebrev));
-                                   return ArchiveMessages.composeConversationFooter(pr, issueTracker, issuePrefix, localRepo, fullWebrev, base, head);
                                });
     }
 
     private static Optional<Hash> rebasedLastHead(Repository localRepo, Hash newBase, Hash lastHead) {
         try {
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveMessages.java
@@ -109,16 +109,25 @@
                                       .collect(Collectors.joining("\n")));
         }
     }
 
     private static Optional<String> formatCommitMessagesBrief(List<CommitMetadata> commits) {
+        return formatCommitMessagesBrief(commits, 100);
+    }
+
+    private static Optional<String> formatCommitMessagesBrief(List<CommitMetadata> commits, int maxEntries) {
         if (commits.size() == 0) {
             return Optional.empty();
         } else {
-            return Optional.of(commits.stream()
-                                      .map(ArchiveMessages::formatCommitBrief)
-                                      .collect(Collectors.joining("\n")));
+            var commitSummary = commits.stream()
+                                       .limit(maxEntries)
+                                       .map(ArchiveMessages::formatCommitBrief)
+                                       .collect(Collectors.joining("\n"));
+            if (commits.size() > maxEntries) {
+                commitSummary += "\n - ...omitting " + (commits.size() - maxEntries) + " further commits.";
+            }
+            return Optional.of(commitSummary);
         }
     }
 
     private static Optional<String> issueUrl(PullRequest pr, URI issueTracker, String projectPrefix) {
         var issue = Issue.fromString(pr.title());
@@ -149,11 +158,11 @@
     private static String fetchCommand(PullRequest pr) {
         var repoUrl = pr.repository().webUrl();
         return "git fetch " + repoUrl + " " + pr.fetchRef() + ":pull/" + pr.id();
     }
 
-    static String composeConversation(PullRequest pr, Repository localRepo, Hash base, Hash head) {
+    static String composeConversation(PullRequest pr) {
         var filteredBody = filterComments(pr.body());
         if (filteredBody.isEmpty()) {
             filteredBody = pr.title().strip();
         }
 
@@ -252,26 +261,24 @@
                 composeReplyFooter(pr);
     }
 
     static String composeMergeConversationFooter(PullRequest pr, Repository localRepo, List<WebrevDescription> webrevs, Hash base, Hash head) {
         var commits = commits(localRepo, base, head);
-        var webrevLinks = "";
-        if (webrevs.size() > 1) {
-            webrevLinks = " Webrev: " + webrevs.get(0).uri() + "\n\n" +
-                    "The following webrevs contain only the adjustments done while merging with regards to each parent branch:\n" +
+        String webrevLinks;
+        if (webrevs.size() > 0) {
+            webrevLinks = "The webrev" + (webrevs.size() > 1 ? "s" : "") + " contain" + (webrevs.size() == 1 ? "s" : "") +
+                    " only the adjustments done while merging with regards to each parent branch:\n" +
                     webrevs.stream()
-                           .skip(1)
                            .map(d -> String.format(" - %s: %s", d.shortLabel(), d.uri()))
                            .collect(Collectors.joining("\n")) + "\n\n";
         } else {
-            webrevLinks = " Webrev: " + webrevs.get(0).uri() + "\n\n" +
-                    "The merge commit only contains trivial merges, so no merge-specific webrevs have been generated.\n\n";
+            webrevLinks = "The merge commit only contains trivial merges, so no merge-specific webrevs have been generated.\n\n";
         }
         return "Commit messages:\n" +
-                formatCommitMessagesBrief(commits).orElse("") + "\n\n" +
-                "Changes: " + pr.changeUrl() + "\n" +
+                formatCommitMessagesBrief(commits, 10).orElse("") + "\n\n" +
                 webrevLinks +
+                "Changes: " + pr.changeUrl() + "\n" +
                 "  Stats: " + stats(localRepo, base, head) + "\n" +
                 "  Patch: " + pr.diffUrl().toString() + "\n" +
                 "  Fetch: " + fetchCommand(pr) + "\n\n" +
                 composeReplyFooter(pr);
     }
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ArchiveWorkItem.java
@@ -290,24 +290,18 @@
         // Materialize the PR's target ref
         try {
             // Materialize the PR's source and target ref
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var hostedRepositoryPool = new HostedRepositoryPool(seedPath);
-            var repository = pr.repository();
             var localRepoPath = scratchPath.resolve("mlbridge-mergebase");
-            var localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(repository.name()));
-            localRepo.fetch(repository.url(), "+" + pr.targetRef() + ":mlbridge_prinstance", false);
-
-            var targetHash = pr.targetHash();
-            var headHash = pr.headHash();
-            var baseHash = localRepo.mergeBase(targetHash, headHash);
+            var prInstance = new PullRequestInstance(localRepoPath, hostedRepositoryPool, pr);
 
             var webrevPath = scratchPath.resolve("mlbridge-webrevs");
             var listServer = MailingListServerFactory.createMailmanServer(bot.listArchive(), bot.smtpServer(), bot.sendInterval());
             var list = listServer.getList(bot.listAddress().address());
 
-            var archiver = new ReviewArchive(pr, bot.emailAddress(), baseHash, headHash);
+            var archiver = new ReviewArchive(prInstance, bot.emailAddress());
 
             // Regular comments
             for (var comment : comments) {
                 if (ignoreComment(comment.author(), comment.body())) {
                     continue;
@@ -331,12 +325,12 @@
                     continue;
                 }
                 archiver.addReviewComment(reviewComment);
             }
 
-            var webrevGenerator = bot.webrevStorage().generator(pr, localRepo, webrevPath);
-            var newMails = archiver.generateNewEmails(sentMails, bot.cooldown(), localRepo, bot.issueTracker(), jbs.toUpperCase(), webrevGenerator,
+            var webrevGenerator = bot.webrevStorage().generator(pr, prInstance.localRepo(), webrevPath);
+            var newMails = archiver.generateNewEmails(sentMails, bot.cooldown(), prInstance.localRepo(), bot.issueTracker(), jbs.toUpperCase(), webrevGenerator,
                                                       (index, webrevs) -> updateWebrevComment(comments, index, webrevs),
                                                       user -> getAuthorAddress(census, user),
                                                       user -> getAuthorUserName(census, user),
                                                       user -> getAuthorRole(census, user),
                                                       subjectPrefix(),
diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -14,26 +14,22 @@
 import java.util.function.Consumer;
 import java.util.logging.Logger;
 import java.util.stream.*;
 
 class ReviewArchive {
-    private final PullRequest pr;
+    private final PullRequestInstance prInstance;
     private final EmailAddress sender;
-    private final Hash base;
-    private final Hash head;
 
     private final List<Comment> comments = new ArrayList<>();
     private final List<Review> reviews = new ArrayList<>();
     private final List<ReviewComment> reviewComments = new ArrayList<>();
 
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.mlbridge");
 
-    ReviewArchive(PullRequest pr, EmailAddress sender, Hash base, Hash head) {
-        this.pr = pr;
+    ReviewArchive(PullRequestInstance prInstance, EmailAddress sender) {
+        this.prInstance = prInstance;
         this.sender = sender;
-        this.base = base;
-        this.head = head;
     }
 
     void addComment(Comment comment) {
         comments.add(comment);
     }
@@ -66,13 +62,13 @@
             var first = sentEmails.get(0);
             if (first.hasHeader("PR-Thread-Prefix")) {
                 threadPrefix = first.headerValue("PR-Thread-Prefix");
             }
         } else {
-            if (pr.state() != Issue.State.OPEN) {
+            if (prInstance.pr().state() != Issue.State.OPEN) {
                 threadPrefix = "FYI";
-            } else if (pr.labels().contains("failed-auto-merge")) {
+            } else if (prInstance.pr().labels().contains("failed-auto-merge")) {
                 threadPrefix = "";
             }
         }
 
         // Check existing generated mails to find which hashes have been previously reported
@@ -81,56 +77,56 @@
                 var curBase = new Hash(email.headerValue("PR-Base-Hash"));
                 var curHead = new Hash(email.headerValue("PR-Head-Hash"));
                 var created = email.date();
 
                 if (generated.isEmpty()) {
-                    var first = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), curBase, curHead, subjectPrefix, threadPrefix);
+                    var first = ArchiveItem.from(prInstance, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, prInstance.pr().createdAt(), prInstance.pr().updatedAt(), curBase, curHead, subjectPrefix, threadPrefix);
                     generated.add(first);
                 } else {
-                    var revision = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, created, created, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
+                    var revision = ArchiveItem.from(prInstance.pr(), localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, created, created, lastBase, lastHead, curBase, curHead, ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
                     generated.add(revision);
                 }
 
                 lastBase = curBase;
                 lastHead = curHead;
             }
         }
 
         // Check if we're at a revision not previously reported
-        if (!base.equals(lastBase) || !head.equals(lastHead)) {
+        if (!prInstance.baseHash().equals(lastBase) || !prInstance.headHash().equals(lastHead)) {
             if (generated.isEmpty()) {
-                var first = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, pr.createdAt(), pr.updatedAt(), base, head, subjectPrefix, threadPrefix);
+                var first = ArchiveItem.from(prInstance, hostUserToEmailAuthor, issueTracker, issuePrefix, webrevGenerator, webrevNotification, prInstance.pr().createdAt(), prInstance.pr().updatedAt(), prInstance.baseHash(), prInstance.headHash(), subjectPrefix, threadPrefix);
                 generated.add(first);
             } else {
-                var revision = ArchiveItem.from(pr, localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, pr.updatedAt(), pr.updatedAt(), lastBase, lastHead, base, head, ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
+                var revision = ArchiveItem.from(prInstance.pr(), localRepo, hostUserToEmailAuthor, webrevGenerator, webrevNotification, prInstance.pr().updatedAt(), prInstance.pr().updatedAt(), lastBase, lastHead, prInstance.baseHash(), prInstance.headHash(), ++revisionIndex, generated.get(0), subjectPrefix, threadPrefix);
                 generated.add(revision);
             }
         }
 
         // A review always have a revision mail as parent, so start with these
         for (var review : reviews) {
             var parent = ArchiveItem.findParent(generated, review);
-            var reply = ArchiveItem.from(pr, review, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, parent);
+            var reply = ArchiveItem.from(prInstance.pr(), review, hostUserToEmailAuthor, hostUserToUserName, hostUserToRole, parent);
             generated.add(reply);
         }
         // Comments have either a comment or a review as parent, the eligible ones have been generated at this point
         for (var comment : comments) {
             var parent = ArchiveItem.findParent(generated, comment);
-            var reply = ArchiveItem.from(pr, comment, hostUserToEmailAuthor, parent);
+            var reply = ArchiveItem.from(prInstance.pr(), comment, hostUserToEmailAuthor, parent);
             generated.add(reply);
         }
         // Finally, file specific comments should be seen after general review comments
         for (var reviewComment : reviewComments) {
             var parent = ArchiveItem.findParent(generated, reviewComments, reviewComment);
-            var reply = ArchiveItem.from(pr, reviewComment, hostUserToEmailAuthor, parent);
+            var reply = ArchiveItem.from(prInstance.pr(), reviewComment, hostUserToEmailAuthor, parent);
             generated.add(reply);
         }
 
         // Post a closed notice for regular RFR threads that weren't integrated
-        if ((pr.state() != Issue.State.OPEN) && threadPrefix.equals("RFR") && !pr.labels().contains("integrated")) {
+        if ((prInstance.pr().state() != Issue.State.OPEN) && threadPrefix.equals("RFR") && !prInstance.pr().labels().contains("integrated")) {
             var parent = generated.get(0);
-            var reply = ArchiveItem.closedNotice(pr, hostUserToEmailAuthor, parent, subjectPrefix, threadPrefix);
+            var reply = ArchiveItem.closedNotice(prInstance.pr(), hostUserToEmailAuthor, parent, subjectPrefix, threadPrefix);
             generated.add(reply);
         }
 
         return generated;
     }
@@ -212,17 +208,17 @@
                      .orElseThrow();
     }
 
     private EmailAddress getUniqueMessageId(String identifier) {
         try {
-            var prSpecific = pr.repository().name().replace("/", ".") + "." + pr.id();
+            var prSpecific = prInstance.pr().repository().name().replace("/", ".") + "." + prInstance.pr().id();
             var digest = MessageDigest.getInstance("SHA-256");
             digest.update(prSpecific.getBytes(StandardCharsets.UTF_8));
             digest.update(identifier.getBytes(StandardCharsets.UTF_8));
             var encodedCommon = Base64.getUrlEncoder().encodeToString(digest.digest());
 
-            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + pr.repository().url().getHost());
+            return EmailAddress.from(encodedCommon + "." + UUID.randomUUID() + "@" + prInstance.pr().repository().url().getHost());
         } catch (NoSuchAlgorithmException e) {
             throw new RuntimeException("Cannot find SHA-256");
         }
     }
 
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
@@ -1729,10 +1729,148 @@
             assertTrue(webrevComment.body().contains("Merge target"));
             assertTrue(webrevComment.body().contains("Merge source"));
         }
     }
 
+    @Test
+    void mergeWebrevNoConflict(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var archiveFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer();
+             var webrevServer = new TestWebrevServer()) {
+            var author = credentials.getHostedRepository();
+            var archive = credentials.getHostedRepository();
+            var commenter = credentials.getHostedRepository();
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var from = EmailAddress.from("test", "test@test.mail");
+            var mlBot = MailingListBridgeBot.newBuilder()
+                                            .from(from)
+                                            .repo(author)
+                                            .archive(archive)
+                                            .archiveRef("archive")
+                                            .censusRepo(censusBuilder.build())
+                                            .list(listAddress)
+                                            .listArchive(listServer.getArchive())
+                                            .smtpServer(listServer.getSMTP())
+                                            .webrevStorageRepository(archive)
+                                            .webrevStorageRef("webrev")
+                                            .webrevStorageBase(Path.of("test"))
+                                            .webrevStorageBaseUri(webrevServer.uri())
+                                            .issueTracker(URIBuilder.base("http://issues.test/browse/").build())
+                                            .build();
+
+            // Populate the projects repository
+            var reviewFile = Path.of("reviewfile.txt");
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType(), reviewFile);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.push(masterHash, author.url(), "master", true);
+            localRepo.push(masterHash, archive.url(), "archive", true);
+            localRepo.push(masterHash, archive.url(), "webrev", true);
+
+            // Create a merge
+            var editOnlyFile = Path.of("editonly.txt");
+            Files.writeString(localRepo.root().resolve(editOnlyFile), "Only added in the edit");
+            localRepo.add(editOnlyFile);
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Edited", "Commit in edit branch");
+            localRepo.checkout(masterHash, true);
+            var masterOnlyFile = Path.of("masteronly.txt");
+            Files.writeString(localRepo.root().resolve(masterOnlyFile), "Only added in master");
+            localRepo.add(masterOnlyFile);
+            var updatedMasterHash = localRepo.commit("Only added in master", "duke", "duke@openjdk.java.net");
+            localRepo.push(updatedMasterHash, author.url(), "master");
+            localRepo.merge(editHash);
+            var mergeCommit = localRepo.commit("Merged edit", "duke", "duke@openjdk.java.net");
+            localRepo.push(mergeCommit, author.url(), "edit", true);
+
+            // Make a merge PR
+            var pr = credentials.createPullRequest(archive, "master", "edit", "Merge edit");
+            pr.setBody("This is now ready");
+
+            // Run an archive pass
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+
+            // The archive should contain a merge style webrev
+            Repository.materialize(archiveFolder.path(), archive.url(), "archive");
+            assertTrue(archiveContains(archiveFolder.path(), "so no merge-specific webrevs have been generated"));
+
+            // The PR should not contain a webrev comment
+            assertEquals(0, pr.comments().size());
+        }
+    }
+
+    @Test
+    void mergeWebrevNoMerge(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var archiveFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer();
+             var webrevServer = new TestWebrevServer()) {
+            var author = credentials.getHostedRepository();
+            var archive = credentials.getHostedRepository();
+            var commenter = credentials.getHostedRepository();
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id());
+            var from = EmailAddress.from("test", "test@test.mail");
+            var mlBot = MailingListBridgeBot.newBuilder()
+                                            .from(from)
+                                            .repo(author)
+                                            .archive(archive)
+                                            .archiveRef("archive")
+                                            .censusRepo(censusBuilder.build())
+                                            .list(listAddress)
+                                            .listArchive(listServer.getArchive())
+                                            .smtpServer(listServer.getSMTP())
+                                            .webrevStorageRepository(archive)
+                                            .webrevStorageRef("webrev")
+                                            .webrevStorageBase(Path.of("test"))
+                                            .webrevStorageBaseUri(webrevServer.uri())
+                                            .issueTracker(URIBuilder.base("http://issues.test/browse/").build())
+                                            .build();
+
+            // Populate the projects repository
+            var reviewFile = Path.of("reviewfile.txt");
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType(), reviewFile);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.push(masterHash, author.url(), "master", true);
+            localRepo.push(masterHash, archive.url(), "archive", true);
+            localRepo.push(masterHash, archive.url(), "webrev", true);
+
+            // Create a merge
+            var editOnlyFile = Path.of("editonly.txt");
+            Files.writeString(localRepo.root().resolve(editOnlyFile), "Only added in the edit");
+            localRepo.add(editOnlyFile);
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Edited", "Commit in edit branch");
+            localRepo.checkout(masterHash, true);
+            var masterOnlyFile = Path.of("masteronly.txt");
+            Files.writeString(localRepo.root().resolve(masterOnlyFile), "Only added in master");
+            localRepo.add(masterOnlyFile);
+            var updatedMasterHash = CheckableRepository.appendAndCommit(localRepo, "Master change", "Commit in master branch");
+            localRepo.push(updatedMasterHash, author.url(), "master");
+            localRepo.push(editHash, author.url(), "edit", true);
+
+            // Make a merge PR
+            var pr = credentials.createPullRequest(archive, "master", "edit", "Merge edit");
+            pr.setBody("This is now ready");
+
+            // Run an archive pass
+            TestBotRunner.runPeriodicItems(mlBot);
+            listServer.processIncoming();
+
+            // The archive should not include any merge-specific webrevs
+            Repository.materialize(archiveFolder.path(), archive.url(), "archive");
+            assertTrue(archiveContains(archiveFolder.path(), "so no merge-specific webrevs have been generated"));
+
+            // The PR should not contain a webrev comment
+            assertEquals(0, pr.comments().size());
+        }
+    }
+
     @Test
     void skipAddingExistingWebrev(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory();
              var archiveFolder = new TemporaryDirectory();
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -38,10 +38,11 @@
 
 class CheckRun {
     private final CheckWorkItem workItem;
     private final PullRequest pr;
     private final PullRequestInstance prInstance;
+    private final CheckablePullRequest checkablePullRequest;
     private final List<Comment> comments;
     private final List<Review> allReviews;
     private final List<Review> activeReviews;
     private final Set<String> labels;
     private final CensusInstance censusInstance;
@@ -58,10 +59,11 @@
                      List<Review> allReviews, List<Review> activeReviews, Set<String> labels,
                      CensusInstance censusInstance, boolean ignoreStaleReviews) {
         this.workItem = workItem;
         this.pr = pr;
         this.prInstance = prInstance;
+        this.checkablePullRequest = new CheckablePullRequest(prInstance, ignoreStaleReviews);
         this.comments = comments;
         this.allReviews = allReviews;
         this.activeReviews = activeReviews;
         this.labels = new HashSet<>(labels);
         this.newLabels = new HashSet<>(labels);
@@ -422,11 +424,11 @@
 
         message.append("- If you would like to add a summary, use the `/summary` command.\n");
         message.append("- To credit additional contributors, use the `/contributor` command.\n");
         message.append("- To add additional solved issues, use the `/solves` command.\n");
 
-        var divergingCommits = prInstance.divergingCommits();
+        var divergingCommits = checkablePullRequest.divergingCommits();
         if (divergingCommits.size() > 0) {
             message.append("\n");
             message.append("Since the source branch of this PR was last updated there ");
             if (divergingCommits.size() == 1) {
                 message.append("has been 1 commit ");
@@ -585,30 +587,30 @@
             pr.createCheck(checkBuilder.build());
 
             var ignored = new PrintWriter(new StringWriter());
             var rebasePossible = true;
             var commitHash = pr.headHash();
-            var mergedHash = prInstance.mergeTarget(ignored);
+            var mergedHash = checkablePullRequest.mergeTarget(ignored);
             if (mergedHash.isPresent()) {
                 commitHash = mergedHash.get();
             } else {
                 rebasePossible = false;
             }
 
             List<String> additionalErrors = List.of();
             Hash localHash;
             try {
-                localHash = prInstance.commit(commitHash, censusInstance.namespace(), censusDomain, null);
+                localHash = checkablePullRequest.commit(commitHash, censusInstance.namespace(), censusDomain, null);
             } catch (CommitFailure e) {
                 additionalErrors = List.of(e.getMessage());
                 localHash = prInstance.baseHash();
             }
-            PullRequestCheckIssueVisitor visitor = prInstance.createVisitor(localHash, censusInstance);
+            PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(localHash, censusInstance);
             if (!localHash.equals(prInstance.baseHash())) {
                 // Determine current status
                 var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), comments);
-                prInstance.executeChecks(localHash, censusInstance, visitor, additionalConfiguration);
+                checkablePullRequest.executeChecks(localHash, censusInstance, visitor, additionalConfiguration);
                 additionalErrors = botSpecificChecks(localHash);
             } else {
                 if (additionalErrors.isEmpty()) {
                     additionalErrors = List.of("This PR contains no changes");
                 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckWorkItem.java
@@ -138,22 +138,23 @@
         var comments = pr.comments();
         var allReviews = pr.reviews();
         var labels = new HashSet<>(pr.labels());
 
         // Filter out the active reviews
-        var activeReviews = PullRequestInstance.filterActiveReviews(allReviews);
+        var activeReviews = CheckablePullRequest.filterActiveReviews(allReviews);
         if (!currentCheckValid(census, comments, activeReviews, labels)) {
             if (labels.contains("integrated")) {
                 log.info("Skipping check of integrated PR");
                 return;
             }
 
             try {
                 var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
                 var prInstance = new PullRequestInstance(scratchPath.resolve("pr").resolve("check"),
                                                          new HostedRepositoryPool(seedPath),
-                                                         pr,
+                                                         pr);
+                var checkablePr = new CheckablePullRequest(prInstance,
                                                          bot.ignoreStaleReviews());
                 CheckRun.execute(this, pr, prInstance, comments, allReviews, activeReviews, labels, census, bot.ignoreStaleReviews());
             } catch (IOException e) {
                 throw new UncheckedIOException(e);
             }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
--- /dev/null
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckablePullRequest.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.pr;
+
+import org.openjdk.skara.census.*;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.host.HostUser;
+import org.openjdk.skara.jcheck.JCheck;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.*;
+
+import java.io.*;
+import java.util.*;
+import java.util.stream.Collectors;
+
+public class CheckablePullRequest {
+    private final PullRequestInstance prInstance;
+    private final boolean ignoreStaleReviews;
+
+    CheckablePullRequest(PullRequestInstance prInstance, boolean ignoreStaleReviews) {
+        this.prInstance = prInstance;
+        this.ignoreStaleReviews = ignoreStaleReviews;
+    }
+
+    private String commitMessage(List<Review> activeReviews, Namespace namespace) throws IOException {
+        var reviewers = activeReviews.stream()
+                                     .filter(review -> !ignoreStaleReviews || review.hash().equals(prInstance.headHash()))
+                                     .filter(review -> review.verdict() == Review.Verdict.APPROVED)
+                                     .map(review -> review.reviewer().id())
+                                     .map(namespace::get)
+                                     .filter(Objects::nonNull)
+                                     .map(Contributor::username)
+                                     .collect(Collectors.toList());
+
+        var comments = prInstance.pr().comments();
+        var currentUser = prInstance.pr().repository().forge().currentUser();
+        var additionalContributors = Contributors.contributors(currentUser,
+                                                               comments).stream()
+                                                 .map(email -> Author.fromString(email.toString()))
+                                                 .collect(Collectors.toList());
+
+        var additionalIssues = SolvesTracker.currentSolved(currentUser, comments);
+        var summary = Summary.summary(currentUser, comments);
+        var issue = Issue.fromString(prInstance.pr().title());
+        var commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(prInstance.pr().title()));
+        if (issue.isPresent()) {
+            commitMessageBuilder.issues(additionalIssues);
+        }
+        commitMessageBuilder.contributors(additionalContributors)
+                            .reviewers(reviewers);
+        summary.ifPresent(commitMessageBuilder::summary);
+
+        return String.join("\n", commitMessageBuilder.format(CommitMessageFormatters.v1));
+    }
+
+    /**
+     * The Review list is in chronological order, the latest one from a particular reviewer is the
+     * one that is "active".
+     * @param allReviews
+     * @return
+     */
+    static List<Review> filterActiveReviews(List<Review> allReviews) {
+        var reviewPerUser = new LinkedHashMap<HostUser, Review>();
+        for (var review : allReviews) {
+            reviewPerUser.put(review.reviewer(), review);
+        }
+        return new ArrayList<>(reviewPerUser.values());
+    }
+
+    Hash commit(Hash finalHead, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
+        Author committer;
+        Author author;
+        var contributor = namespace.get(prInstance.pr().author().id());
+
+        if (contributor == null) {
+            if (prInstance.isMerge()) {
+                throw new CommitFailure("Merges can only be performed by Committers.");
+            }
+
+            // Use the information contained in the head commit - jcheck has verified that it contains sane values
+            var headCommit = prInstance.localRepo().commitMetadata(prInstance.headHash().hex() + "^.." + prInstance.headHash().hex()).get(0);
+            author = headCommit.author();
+        } else {
+            author = new Author(contributor.fullName().orElseThrow(), contributor.username() + "@" + censusDomain);
+        }
+
+        if (sponsorId != null) {
+            var sponsorContributor = namespace.get(sponsorId);
+            committer = new Author(sponsorContributor.fullName().orElseThrow(), sponsorContributor.username() + "@" + censusDomain);
+        } else {
+            committer = author;
+        }
+
+        var activeReviews = filterActiveReviews(prInstance.pr().reviews());
+        var commitMessage = commitMessage(activeReviews, namespace);
+        return prInstance.commit(finalHead, author, committer, commitMessage);
+    }
+
+    PullRequestCheckIssueVisitor createVisitor(Hash localHash, CensusInstance censusInstance) throws IOException {
+        var checks = JCheck.checksFor(prInstance.localRepo(), censusInstance.census(), prInstance.targetHash());
+        return new PullRequestCheckIssueVisitor(checks);
+    }
+
+    void executeChecks(Hash localHash, CensusInstance censusInstance, PullRequestCheckIssueVisitor visitor, List<String> additionalConfiguration) throws Exception {
+        try (var issues = JCheck.check(prInstance.localRepo(), censusInstance.census(), CommitMessageParsers.v1, localHash,
+                                       prInstance.targetHash(), additionalConfiguration)) {
+            for (var issue : issues) {
+                issue.accept(visitor);
+            }
+        }
+    }
+
+    List<CommitMetadata> divergingCommits() {
+        return divergingCommits(prInstance.headHash());
+    }
+
+    private List<CommitMetadata> divergingCommits(Hash commitHash) {
+        try {
+            var updatedBase = prInstance.localRepo().mergeBase(prInstance.targetHash(), commitHash);
+            return prInstance.localRepo().commitMetadata(updatedBase, prInstance.targetHash());
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    Optional<Hash> mergeTarget(PrintWriter reply) {
+        var divergingCommits = divergingCommits(prInstance.headHash());
+        if (divergingCommits.size() > 0) {
+            reply.print("The following commits have been pushed to ");
+            reply.print(prInstance.pr().targetRef());
+            reply.println(" since your change was applied:");
+            divergingCommits.forEach(c -> reply.println(" * " + c.hash().hex() + ": " + c.message().get(0)));
+
+            try {
+                prInstance.localRepo().checkout(prInstance.headHash(), true);
+                prInstance.localRepo().merge(prInstance.targetHash());
+                var hash = prInstance.localRepo().commit("Automatic merge with latest target", "duke", "duke@openjdk.org");
+                reply.println();
+                reply.println("Your commit was automatically rebased without conflicts.");
+                return Optional.of(hash);
+            } catch (IOException e) {
+                reply.println();
+                reply.print("It was not possible to rebase your changes automatically. Please merge `");
+                reply.print(prInstance.pr().targetRef());
+                reply.println("` into your branch and try again.");
+                return Optional.empty();
+            }
+        } else {
+            // No merge needed
+            return Optional.of(prInstance.headHash());
+        }
+    }
+
+}
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
@@ -92,12 +92,12 @@
             var path = scratchPath.resolve("integrate").resolve(sanitizedUrl);
 
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var prInstance = new PullRequestInstance(path,
                                                      new HostedRepositoryPool(seedPath),
-                                                     pr,
-                                                     bot.ignoreStaleReviews());
+                                                     pr);
+            var checkablePr = new CheckablePullRequest(prInstance, bot.ignoreStaleReviews());
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
                 var wantedHash = new Hash(args);
                 if (!prInstance.targetHash().equals(wantedHash)) {
@@ -107,21 +107,21 @@
                 }
             };
 
             // Now merge the latest changes from the target
             var rebaseWriter = new PrintWriter(rebaseMessage);
-            var rebasedHash = prInstance.mergeTarget(rebaseWriter);
+            var rebasedHash = checkablePr.mergeTarget(rebaseWriter);
             if (rebasedHash.isEmpty()) {
                 reply.println(rebaseMessage.toString());
                 return;
             }
 
-            var localHash = prInstance.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(), null);
+            var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(), null);
 
-            var issues = prInstance.createVisitor(localHash, censusInstance);
+            var issues = checkablePr.createVisitor(localHash, censusInstance);
             var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), allComments);
-            prInstance.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
+            checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
             if (!issues.getMessages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
                 reply.println("your changes failed the final jcheck:");
                 issues.getMessages().stream()
                       .map(line -> " * " + line)
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/LabelerWorkItem.java
@@ -64,12 +64,11 @@
         }
         try {
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var prInstance = new PullRequestInstance(scratchPath.resolve("pr").resolve("labeler"),
                                                      new HostedRepositoryPool(seedPath),
-                                                     pr,
-                                                     bot.ignoreStaleReviews());
+                                                     pr);
             var newLabels = getLabels(prInstance);
             var currentLabels = pr.labels().stream()
                                   .filter(key -> bot.labelPatterns().containsKey(key))
                                   .collect(Collectors.toSet());
 
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
+++ /dev/null
@@ -1,370 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.pr;
-
-import org.openjdk.skara.census.*;
-import org.openjdk.skara.forge.*;
-import org.openjdk.skara.host.HostUser;
-import org.openjdk.skara.jcheck.JCheck;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.*;
-
-import java.io.*;
-import java.nio.file.Path;
-import java.time.ZonedDateTime;
-import java.util.*;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-
-class CommitFailure extends Exception {
-    CommitFailure(String reason) {
-        super(reason);
-    }
-}
-
-class PullRequestInstance {
-    private final PullRequest pr;
-    private final Repository localRepo;
-    private final Hash targetHash;
-    private final Hash headHash;
-    private final Hash baseHash;
-    private final boolean ignoreStaleReviews;
-
-    PullRequestInstance(Path localRepoPath, HostedRepositoryPool hostedRepositoryPool, PullRequest pr, boolean ignoreStaleReviews) throws IOException  {
-        this.pr = pr;
-        this.ignoreStaleReviews = ignoreStaleReviews;
-
-        // Materialize the PR's source and target ref
-        var repository = pr.repository();
-        localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(repository.name()));
-        localRepo.fetch(repository.url(), "+" + pr.targetRef() + ":pr_prinstance", false);
-
-        targetHash = pr.targetHash();
-        headHash = pr.headHash();
-        baseHash = localRepo.mergeBase(targetHash, headHash);
-    }
-
-    /**
-     * The Review list is in chronological order, the latest one from a particular reviewer is the
-     * one that is "active".
-     * @param allReviews
-     * @return
-     */
-    static List<Review> filterActiveReviews(List<Review> allReviews) {
-        var reviewPerUser = new LinkedHashMap<HostUser, Review>();
-        for (var review : allReviews) {
-            reviewPerUser.put(review.reviewer(), review);
-        }
-        return new ArrayList<>(reviewPerUser.values());
-    }
-
-    private String commitMessage(List<Review> activeReviews, Namespace namespace) throws IOException {
-        var reviewers = activeReviews.stream()
-                                     .filter(review -> !ignoreStaleReviews || review.hash().equals(headHash))
-                                     .filter(review -> review.verdict() == Review.Verdict.APPROVED)
-                                     .map(review -> review.reviewer().id())
-                                     .map(namespace::get)
-                                     .filter(Objects::nonNull)
-                                     .map(Contributor::username)
-                                     .collect(Collectors.toList());
-
-        var comments = pr.comments();
-        var additionalContributors = Contributors.contributors(pr.repository().forge().currentUser(),
-                                                               comments).stream()
-                                                 .map(email -> Author.fromString(email.toString()))
-                                                 .collect(Collectors.toList());
-
-        var additionalIssues = SolvesTracker.currentSolved(pr.repository().forge().currentUser(), comments);
-        var summary = Summary.summary(pr.repository().forge().currentUser(), comments);
-        var issue = Issue.fromString(pr.title());
-        var commitMessageBuilder = issue.map(CommitMessage::title).orElseGet(() -> CommitMessage.title(pr.title()));
-        if (issue.isPresent()) {
-            commitMessageBuilder.issues(additionalIssues);
-        }
-        commitMessageBuilder.contributors(additionalContributors)
-                            .reviewers(reviewers);
-        summary.ifPresent(commitMessageBuilder::summary);
-
-        return String.join("\n", commitMessageBuilder.format(CommitMessageFormatters.v1));
-    }
-
-    private Hash commitSquashed(Hash finalHead, List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException {
-        Author committer;
-        Author author;
-        var contributor = namespace.get(pr.author().id());
-
-        if (contributor == null) {
-            // Use the information contained in the head commit - jcheck has verified that it contains sane values
-            var headCommit = localRepo.commitMetadata(headHash.hex() + "^.." + headHash.hex()).get(0);
-            author = headCommit.author();
-        } else {
-            author = new Author(contributor.fullName().orElseThrow(), contributor.username() + "@" + censusDomain);
-        }
-
-        if (sponsorId != null) {
-            var sponsorContributor = namespace.get(sponsorId);
-            committer = new Author(sponsorContributor.fullName().orElseThrow(), sponsorContributor.username() + "@" + censusDomain);
-        } else {
-            committer = author;
-        }
-
-        var commitMessage = commitMessage(activeReviews, namespace);
-        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
-                committer.name(), committer.email(), ZonedDateTime.now(), List.of(targetHash), localRepo.tree(finalHead));
-    }
-
-    private static class MergeSource {
-        private final String repositoryName;
-        private final String branchName;
-
-        private MergeSource(String repositoryName, String branchName) {
-            this.repositoryName = repositoryName;
-            this.branchName = branchName;
-        }
-    }
-
-    private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
-    private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
-
-    private Optional<MergeSource> mergeSource() {
-        var repoMatcher = mergeSourceFullPattern.matcher(pr.title());
-        if (!repoMatcher.matches()) {
-            var branchMatcher = mergeSourceBranchOnlyPattern.matcher(pr.title());
-            if (!branchMatcher.matches()) {
-                return Optional.empty();
-            }
-
-            // Verify that the branch exists
-            var isValidBranch = remoteBranches().stream()
-                    .map(Reference::name)
-                    .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
-            if (!isValidBranch) {
-                // Assume the name refers to a sibling repository
-                var repoName = Path.of(pr.repository().name()).resolveSibling(branchMatcher.group(1)).toString();
-                return Optional.of(new MergeSource(repoName, "master"));
-            }
-
-            return Optional.of(new MergeSource(pr.repository().name(), branchMatcher.group(1)));
-        }
-
-        return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
-    }
-
-    private CommitMetadata findSourceMergeCommit(List<CommitMetadata> commits) throws IOException, CommitFailure {
-        if (commits.size() < 2) {
-            throw new CommitFailure("A merge PR must contain at least two commits that are not already present in the target.");
-        }
-
-        var source = mergeSource();
-        if (source.isEmpty()) {
-            throw new CommitFailure("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
-                    "Merge `project`:`branch` to allow verification of the merge contents.");
-        }
-
-        // Fetch the source
-        Hash sourceHash;
-        try {
-            var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() ->
-                    new RuntimeException("Could not find repository " + source.get().repositoryName)
-            );
-            try {
-                sourceHash = localRepo.fetch(mergeSourceRepo.url(), source.get().branchName, false);
-            } catch (IOException e) {
-                throw new CommitFailure("Could not fetch branch `" + source.get().branchName + "` from project `" +
-                        source.get().repositoryName + "` - check that they are correct.");
-            }
-        } catch (RuntimeException e) {
-            throw new CommitFailure("Could not find project `" +
-                    source.get().repositoryName + "` - check that it is correct.");
-        }
-
-
-        // Find the first merge commit with a parent that is an ancestor of the source
-        int mergeCommitIndex = commits.size();
-        for (int i = 0; i < commits.size() - 1; ++i) {
-            if (commits.get(i).isMerge()) {
-                boolean isSourceMerge = false;
-                for (int j = 0; j < commits.get(i).parents().size(); ++j) {
-                    if (localRepo.isAncestor(commits.get(i).parents().get(j), sourceHash)) {
-                        isSourceMerge = true;
-                    }
-                }
-                if (isSourceMerge) {
-                    mergeCommitIndex = i;
-                    break;
-                }
-            }
-        }
-        if (mergeCommitIndex >= commits.size() - 1) {
-            throw new CommitFailure("A merge PR must contain a merge commit as well as at least one other commit from the merge source.");
-        }
-
-        return commits.get(mergeCommitIndex);
-    }
-
-    private Hash commitMerge(Hash finalHead, List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
-        var commits = localRepo.commitMetadata(baseHash, finalHead);
-        var mergeCommit = findSourceMergeCommit(commits);
-
-        // Find the parent which is on the target branch - we will replace it with the target hash (if there were no merge conflicts)
-        Hash firstParent = null;
-        var finalParents = new ArrayList<Hash>();
-        for (int i = 0; i < mergeCommit.parents().size(); ++i) {
-            if (localRepo.isAncestor(mergeCommit.parents().get(i), targetHash)) {
-                if (firstParent == null) {
-                    firstParent = localRepo.mergeBase(targetHash, finalHead);
-                    continue;
-                }
-            }
-            finalParents.add(mergeCommit.parents().get(i));
-        }
-        if (firstParent == null) {
-            throw new CommitFailure("The merge commit must have a commit on the target branch as one of its parents.");
-        }
-        finalParents.add(0, firstParent);
-
-        var contributor = namespace.get(pr.author().id());
-        if (contributor == null) {
-            throw new CommitFailure("Merges can only be performed by Committers.");
-        }
-
-        var author = new Author(contributor.fullName().orElseThrow(), contributor.username() + "@" + censusDomain);
-        Author committer;
-        if (sponsorId != null) {
-            var sponsorContributor = namespace.get(sponsorId);
-            committer = new Author(sponsorContributor.fullName().orElseThrow(), sponsorContributor.username() + "@" + censusDomain);
-        } else {
-            committer = author;
-        }
-        var commitMessage = commitMessage(activeReviews, namespace);
-
-        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
-                committer.name(), committer.email(), ZonedDateTime.now(), finalParents, localRepo.tree(finalHead));
-    }
-
-    private boolean isMergeCommit() {
-        return pr.title().startsWith("Merge");
-    }
-
-    Hash commit(Hash finalHead, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
-        var activeReviews = filterActiveReviews(pr.reviews());
-        Hash commit;
-        if (!isMergeCommit()) {
-            commit = commitSquashed(finalHead, activeReviews, namespace, censusDomain, sponsorId);
-        } else {
-            commit = commitMerge(finalHead, activeReviews, namespace, censusDomain, sponsorId);
-        }
-        localRepo.checkout(commit, true);
-        return commit;
-    }
-
-    List<CommitMetadata> divergingCommits() {
-        return divergingCommits(headHash);
-    }
-
-    private List<CommitMetadata> divergingCommits(Hash commitHash) {
-        try {
-            var updatedBase = localRepo.mergeBase(targetHash, commitHash);
-            return localRepo.commitMetadata(updatedBase, targetHash);
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    Optional<Hash> mergeTarget(PrintWriter reply) {
-        var divergingCommits = divergingCommits(headHash);
-        if (divergingCommits.size() > 0) {
-            reply.print("The following commits have been pushed to ");
-            reply.print(pr.targetRef());
-            reply.println(" since your change was applied:");
-            divergingCommits.forEach(c -> reply.println(" * " + c.hash().hex() + ": " + c.message().get(0)));
-
-            try {
-                localRepo.checkout(headHash, true);
-                localRepo.merge(targetHash);
-                var hash = localRepo.commit("Automatic merge with latest target", "duke", "duke@openjdk.org");
-                reply.println();
-                reply.println("Your commit was automatically rebased without conflicts.");
-                return Optional.of(hash);
-            } catch (IOException e) {
-                reply.println();
-                reply.print("It was not possible to rebase your changes automatically. Please merge `");
-                reply.print(pr.targetRef());
-                reply.println("` into your branch and try again.");
-                try {
-                    localRepo.checkout(headHash, true);
-                } catch (IOException e2) {
-                    throw new UncheckedIOException(e2);
-                }
-                return Optional.empty();
-            }
-        } else {
-            // No merge needed
-            return Optional.of(headHash);
-        }
-    }
-
-    Repository localRepo() {
-        return localRepo;
-    }
-
-    Hash baseHash() {
-        return baseHash;
-    }
-
-    Hash targetHash() {
-        return targetHash;
-    }
-
-    Set<Path> changedFiles() throws IOException {
-        var ret = new HashSet<Path>();
-        var changes = localRepo.diff(baseHash, headHash);
-        for (var patch : changes.patches()) {
-            patch.target().path().ifPresent(ret::add);
-            patch.source().path().ifPresent(ret::add);
-        }
-        return ret;
-    }
-
-    PullRequestCheckIssueVisitor createVisitor(Hash localHash, CensusInstance censusInstance) throws IOException {
-        var checks = JCheck.checksFor(localRepo(), censusInstance.census(), targetHash);
-        return new PullRequestCheckIssueVisitor(checks);
-    }
-
-    void executeChecks(Hash localHash, CensusInstance censusInstance, PullRequestCheckIssueVisitor visitor, List<String> additionalConfiguration) throws Exception {
-        try (var issues = JCheck.check(localRepo(), censusInstance.census(), CommitMessageParsers.v1, localHash,
-                                       targetHash, additionalConfiguration)) {
-            for (var issue : issues) {
-                issue.accept(visitor);
-            }
-        }
-    }
-
-    List<Reference> remoteBranches() {
-        try {
-            return localRepo.remoteBranches(pr.repository().url().toString());
-        } catch (IOException e) {
-            return List.of();
-        }
-    }
-}
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
@@ -77,12 +77,12 @@
             var path = scratchPath.resolve("sponsor").resolve(sanitizedUrl);
 
             var seedPath = bot.seedStorage().orElse(scratchPath.resolve("seeds"));
             var prInstance = new PullRequestInstance(path,
                                                      new HostedRepositoryPool(seedPath),
-                                                     pr,
-                                                     bot.ignoreStaleReviews());
+                                                     pr);
+            var checkablePr = new CheckablePullRequest(prInstance, bot.ignoreStaleReviews());
             // Validate the target hash if requested
             var rebaseMessage = new StringWriter();
             if (!args.isBlank()) {
                 var wantedHash = new Hash(args);
                 if (!prInstance.targetHash().equals(wantedHash)) {
@@ -92,22 +92,22 @@
                 }
             }
 
             // Now rebase onto the target hash
             var rebaseWriter = new PrintWriter(rebaseMessage);
-            var rebasedHash = prInstance.mergeTarget(rebaseWriter);
+            var rebasedHash = checkablePr.mergeTarget(rebaseWriter);
             if (rebasedHash.isEmpty()) {
                 reply.println(rebaseMessage.toString());
                 return;
             }
 
-            var localHash = prInstance.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(),
+            var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(),
                     comment.author().id());
 
-            var issues = prInstance.createVisitor(localHash, censusInstance);
+            var issues = checkablePr.createVisitor(localHash, censusInstance);
             var additionalConfiguration = AdditionalConfiguration.get(prInstance.localRepo(), localHash, pr.repository().forge().currentUser(), allComments);
-            prInstance.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
+            checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
             if (!issues.getMessages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
                 reply.println("your changes failed the final jcheck:");
                 issues.getMessages().stream()
                       .map(line -> " * " + line)
diff a/forge/src/main/java/org/openjdk/skara/forge/CommitFailure.java b/forge/src/main/java/org/openjdk/skara/forge/CommitFailure.java
--- /dev/null
+++ b/forge/src/main/java/org/openjdk/skara/forge/CommitFailure.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.forge;
+
+public class CommitFailure extends Exception {
+    public CommitFailure(String reason) {
+        super(reason);
+    }
+}
diff a/forge/src/main/java/org/openjdk/skara/forge/PullRequestInstance.java b/forge/src/main/java/org/openjdk/skara/forge/PullRequestInstance.java
--- /dev/null
+++ b/forge/src/main/java/org/openjdk/skara/forge/PullRequestInstance.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.forge;
+
+import org.openjdk.skara.vcs.*;
+
+import java.io.*;
+import java.nio.file.Path;
+import java.time.ZonedDateTime;
+import java.util.*;
+import java.util.regex.Pattern;
+
+public class PullRequestInstance {
+    private final PullRequest pr;
+    private final Repository localRepo;
+    private final Hash targetHash;
+    private final Hash headHash;
+    private final Hash baseHash;
+
+    public PullRequestInstance(Path localRepoPath, HostedRepositoryPool hostedRepositoryPool, PullRequest pr) throws IOException {
+        this.pr = pr;
+
+        // Materialize the PR's source and target ref
+        var repository = pr.repository();
+        localRepo = hostedRepositoryPool.checkout(pr, localRepoPath.resolve(repository.name()));
+        localRepo.fetch(repository.url(), "+" + pr.targetRef() + ":pr_prinstance", false);
+
+        targetHash = pr.targetHash();
+        headHash = pr.headHash();
+        baseHash = localRepo.mergeBase(targetHash, headHash);
+    }
+
+    private Hash commitSquashed(Hash finalHead, Author author, Author committer, String commitMessage) throws IOException {
+        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
+                                committer.name(), committer.email(), ZonedDateTime.now(), List.of(targetHash), localRepo.tree(finalHead));
+    }
+
+    private static class MergeSource {
+        private final String repositoryName;
+        private final String branchName;
+
+        private MergeSource(String repositoryName, String branchName) {
+            this.repositoryName = repositoryName;
+            this.branchName = branchName;
+        }
+    }
+
+    private final Pattern mergeSourceFullPattern = Pattern.compile("^Merge ([-/\\w]+):([-\\w]+)$");
+    private final Pattern mergeSourceBranchOnlyPattern = Pattern.compile("^Merge ([-\\w]+)$");
+
+    private Optional<MergeSource> mergeSource() {
+        var repoMatcher = mergeSourceFullPattern.matcher(pr.title());
+        if (!repoMatcher.matches()) {
+            var branchMatcher = mergeSourceBranchOnlyPattern.matcher(pr.title());
+            if (!branchMatcher.matches()) {
+                return Optional.empty();
+            }
+
+            // Verify that the branch exists
+            var isValidBranch = remoteBranches().stream()
+                    .map(Reference::name)
+                    .anyMatch(branch -> branch.equals(branchMatcher.group(1)));
+            if (!isValidBranch) {
+                // Assume the name refers to a sibling repository
+                var repoName = Path.of(pr.repository().name()).resolveSibling(branchMatcher.group(1)).toString();
+                return Optional.of(new MergeSource(repoName, "master"));
+            }
+
+            return Optional.of(new MergeSource(pr.repository().name(), branchMatcher.group(1)));
+        }
+
+        return Optional.of(new MergeSource(repoMatcher.group(1), repoMatcher.group(2)));
+    }
+
+    private CommitMetadata findSourceMergeCommit(List<CommitMetadata> commits) throws IOException, CommitFailure {
+        if (commits.size() < 2) {
+            throw new CommitFailure("A merge PR must contain at least two commits that are not already present in the target.");
+        }
+
+        var source = mergeSource();
+        if (source.isEmpty()) {
+            throw new CommitFailure("Could not determine the source for this merge. A Merge PR title must be specified on the format: " +
+                    "Merge `project`:`branch` to allow verification of the merge contents.");
+        }
+
+        // Fetch the source
+        Hash sourceHash;
+        try {
+            var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() ->
+                    new RuntimeException("Could not find repository " + source.get().repositoryName)
+            );
+            try {
+                sourceHash = localRepo.fetch(mergeSourceRepo.url(), source.get().branchName, false);
+            } catch (IOException e) {
+                throw new CommitFailure("Could not fetch branch `" + source.get().branchName + "` from project `" +
+                        source.get().repositoryName + "` - check that they are correct.");
+            }
+        } catch (RuntimeException e) {
+            throw new CommitFailure("Could not find project `" +
+                    source.get().repositoryName + "` - check that it is correct.");
+        }
+
+
+        // Find the first merge commit with a parent that is an ancestor of the source
+        int mergeCommitIndex = commits.size();
+        for (int i = 0; i < commits.size() - 1; ++i) {
+            if (commits.get(i).isMerge()) {
+                boolean isSourceMerge = false;
+                for (int j = 0; j < commits.get(i).parents().size(); ++j) {
+                    if (localRepo.isAncestor(commits.get(i).parents().get(j), sourceHash)) {
+                        isSourceMerge = true;
+                    }
+                }
+                if (isSourceMerge) {
+                    mergeCommitIndex = i;
+                    break;
+                }
+            }
+        }
+        if (mergeCommitIndex >= commits.size() - 1) {
+            throw new CommitFailure("A merge PR must contain a merge commit as well as at least one other commit from the merge source.");
+        }
+
+        return commits.get(mergeCommitIndex);
+    }
+
+    private Hash commitMerge(Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
+        var commits = localRepo.commitMetadata(baseHash, finalHead);
+        var mergeCommit = findSourceMergeCommit(commits);
+
+        // Find the parent which is on the target branch - we will replace it with the target hash (if there were no merge conflicts)
+        Hash firstParent = null;
+        var finalParents = new ArrayList<Hash>();
+        for (int i = 0; i < mergeCommit.parents().size(); ++i) {
+            if (localRepo.isAncestor(mergeCommit.parents().get(i), targetHash)) {
+                if (firstParent == null) {
+                    firstParent = localRepo.mergeBase(targetHash, finalHead);
+                    continue;
+                }
+            }
+            finalParents.add(mergeCommit.parents().get(i));
+        }
+        if (firstParent == null) {
+            throw new CommitFailure("The merge commit must have a commit on the target branch as one of its parents.");
+        }
+        finalParents.add(0, firstParent);
+
+        return localRepo.commit(commitMessage, author.name(), author.email(), ZonedDateTime.now(),
+                committer.name(), committer.email(), ZonedDateTime.now(), finalParents, localRepo.tree(finalHead));
+    }
+
+    public boolean isMerge() {
+        return pr.title().startsWith("Merge");
+    }
+
+    public Hash commit(Hash finalHead, Author author, Author committer, String commitMessage) throws IOException, CommitFailure {
+        Hash commit;
+        if (!isMerge()) {
+            commit = commitSquashed(finalHead, author, committer, commitMessage);
+        } else {
+            commit = commitMerge(finalHead, author, committer, commitMessage);
+        }
+        localRepo.checkout(commit, true);
+        return commit;
+    }
+
+    public PullRequest pr() {
+        return pr;
+    }
+
+    public Repository localRepo() {
+        return localRepo;
+    }
+
+    public Hash baseHash() {
+        return baseHash;
+    }
+
+    public Hash targetHash() {
+        return targetHash;
+    }
+
+    public Hash headHash() {
+        return headHash;
+    }
+
+    public Set<Path> changedFiles() throws IOException {
+        var ret = new HashSet<Path>();
+        var changes = localRepo.diff(baseHash, headHash);
+        for (var patch : changes.patches()) {
+            patch.target().path().ifPresent(ret::add);
+            patch.source().path().ifPresent(ret::add);
+        }
+        return ret;
+    }
+
+    List<Reference> remoteBranches() {
+        try {
+            return localRepo.remoteBranches(pr.repository().url().toString());
+        } catch (IOException e) {
+            return List.of();
+        }
+    }
+}

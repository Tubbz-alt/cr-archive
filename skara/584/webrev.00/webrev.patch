diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java
@@ -137,31 +137,37 @@
         var commitMessage = commitMessage(activeReviews, namespace);
         return localRepo.commit(commitMessage, author.name(), author.email(), committer.name(), committer.email());
     }
 
     private Hash commitMerge(List<Review> activeReviews, Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
-        // Find the first merge commit with an incoming parent outside of the merge target
+        // Find the single merge commit with an incoming parent outside of the merge target
         // The very last commit is not eligible (as the merge needs a parent)
         var commits = localRepo.commitMetadata(baseHash, headHash);
         int mergeCommitIndex = commits.size();
         for (int i = 0; i < commits.size() - 1; ++i) {
             if (commits.get(i).isMerge()) {
                 boolean isSourceMerge = false;
-                for (int j = 1; j < commits.get(i).parents().size(); ++j) {
+                for (int j = 0; j < commits.get(i).parents().size(); ++j) {
                     if (!localRepo.isAncestor(baseHash, commits.get(i).parents().get(j))) {
                         isSourceMerge = true;
                     }
                 }
                 if (isSourceMerge) {
+                    if (mergeCommitIndex != commits.size()) {
+                        // TODO: We could allow this
+                        throw new CommitFailure("A merge PR is only allowed to contain a single merge commit with incoming changes. Please amend!");
+                    }
                     mergeCommitIndex = i;
-                    break;
+                } else {
+                    // TODO: We can solve this with retroactive rerere
+                    throw new CommitFailure("A merge PR is only allowed to contain a single merge commit. You will need to amend your commits.");
                 }
             }
         }
 
         if (mergeCommitIndex == commits.size()) {
-            throw new CommitFailure("No merge commit containing commits from another branch than the target was found");
+            throw new CommitFailure("No merge commit containing incoming commits from another branch than the target was found");
         }
 
         var contributor = namespace.get(pr.author().id());
         if (contributor == null) {
             throw new CommitFailure("Merges can only be performed by Committers");
@@ -181,13 +187,17 @@
         localRepo.squash(headHash);
 
         return localRepo.amend(commitMessage, author.name(), author.email(), committer.name(), committer.email());
     }
 
+    private boolean isMergeCommit() {
+        return pr.title().startsWith("Merge");
+    }
+
     Hash commit(Namespace namespace, String censusDomain, String sponsorId) throws IOException, CommitFailure {
         var activeReviews = filterActiveReviews(pr.reviews());
-        if (!pr.title().startsWith("Merge")) {
+        if (!isMergeCommit()) {
             return commitSquashed(activeReviews, namespace, censusDomain, sponsorId);
         } else {
             return commitMerge(activeReviews, namespace, censusDomain, sponsorId);
         }
     }
@@ -213,10 +223,16 @@
             reply.println(" since your change was applied:");
             divergingCommits.forEach(c -> reply.println(" * " + c.hash().hex() + ": " + c.message().get(0)));
 
             try {
                 var commit = localRepo.lookup(commitHash).orElseThrow();
+                if (isMergeCommit()) {
+                    // TODO: We can solve this with retroactive rerere
+                    reply.println("Merge PRs cannot currently be automatically rebased. You will need to rebase it manually.");
+                    return Optional.empty();
+                }
+
                 localRepo.rebase(targetHash, commit.committer().name(), commit.committer().email());
                 reply.println();
                 reply.println("Your commit was automatically rebased without conflicts.");
                 var hash = localRepo.head();
                 return Optional.of(hash);
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java
@@ -207,10 +207,11 @@
             assertEquals("integrationcommitter1@openjdk.java.net", headCommit.committer().email());
         }
     }
 
     @Test
+    @Disabled
     void branchMergeRebase(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory()) {
 
             var author = credentials.getHostedRepository();
@@ -301,10 +302,11 @@
             assertEquals("integrationcommitter1@openjdk.java.net", headCommit.committer().email());
         }
     }
 
     @Test
+    @Disabled
     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory()) {
 
             var author = credentials.getHostedRepository();
@@ -464,11 +466,11 @@
                           .filter(comment -> comment.body().contains("did not complete successfully"))
                           .count();
             assertEquals(1, error, () -> pr.comments().stream().map(Comment::body).collect(Collectors.joining("\n\n")));
 
             var check = pr.checks(mergeHash).get("jcheck");
-            assertEquals("- It was not possible to create a commit for the changes in this PR: No merge commit containing commits from another branch than the target was found", check.summary().orElseThrow());
+            assertEquals("- It was not possible to create a commit for the changes in this PR: A merge PR is only allowed to contain a single merge commit. You will need to amend your commits.", check.summary().orElseThrow());
         }
     }
 
     @Test
     void invalidSourceRepo(TestInfo testInfo) throws IOException {
diff a/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java b/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java
--- a/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java
+++ b/vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java
@@ -725,11 +725,11 @@
         }
     }
 
     @Override
     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
-        try (var p = Process.capture("git", "rebase", "--onto", hash.hex(), "--root", "--rebase-merges")
+        try (var p = Process.capture("git", "rebase", "--onto", hash.hex(), "--root")
                             .environ("GIT_COMMITTER_NAME", committerName)
                             .environ("GIT_COMMITTER_EMAIL", committerEmail)
                             .workdir(dir)
                             .execute()) {
             await(p);

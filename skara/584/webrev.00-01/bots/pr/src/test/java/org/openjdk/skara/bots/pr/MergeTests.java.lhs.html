<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames bots/pr/src/test/java/org/openjdk/skara/bots/pr/MergeTests.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package org.openjdk.skara.bots.pr;
 24 
 25 import org.openjdk.skara.forge.Review;
 26 import org.openjdk.skara.issuetracker.Comment;
 27 import org.openjdk.skara.process.Process;
 28 import org.openjdk.skara.test.*;
 29 import org.openjdk.skara.vcs.*;
 30 
 31 import org.junit.jupiter.api.*;
 32 
 33 import java.io.IOException;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.*;
 36 import java.util.Set;
 37 import java.util.stream.Collectors;
 38 
 39 import static org.junit.jupiter.api.Assertions.*;
 40 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 41 
 42 class MergeTests {
 43     @Test
 44     void branchMerge(TestInfo testInfo) throws IOException {
 45         try (var credentials = new HostCredentials(testInfo);
 46              var tempFolder = new TemporaryDirectory()) {
 47 
 48             var author = credentials.getHostedRepository();
 49             var integrator = credentials.getHostedRepository();
 50             var censusBuilder = credentials.getCensusBuilder()
 51                                            .addCommitter(author.forge().currentUser().id())
 52                                            .addReviewer(integrator.forge().currentUser().id());
 53             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
 54 
 55             // Populate the projects repository
 56             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
 57             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
 58             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
 59             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
 60             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
 61 
 62             // Make more changes in another branch
 63             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
 64                                                                 &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
 65             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
 66             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
 67                                                                 &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
 68             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
 69 
 70             // Go back to the original master
 71             localRepo.checkout(masterHash, true);
 72 
 73             // Make a change with a corresponding PR
 74             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
 75             localRepo.add(unrelated);
 76             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
 77             localRepo.merge(otherHash2);
 78             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
 79 
 80             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
 81             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
 82             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
 83 
 84             // Approve it as another user
 85             var approvalPr = integrator.pullRequest(pr.id());
 86             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
 87 
 88             // Let the bot check the status
 89             TestBotRunner.runPeriodicItems(mergeBot);
 90 
 91             // Push it
 92             pr.addComment(&quot;/integrate&quot;);
 93             TestBotRunner.runPeriodicItems(mergeBot);
 94 
 95             // The bot should reply with an ok message
 96             var pushed = pr.comments().stream()
 97                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
 98                            .count();
 99             assertEquals(1, pushed);
100 
101             // The change should now be present on the master branch
102             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
103             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
104             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
105 
106             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
107             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
108             Set&lt;Hash&gt; commits;
109             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
110                 commits = tempCommits.stream()
111                         .map(Commit::hash)
112                         .collect(Collectors.toSet());
113             }
114             assertTrue(commits.contains(otherHash1));
115             assertTrue(commits.contains(otherHash2));
116             assertFalse(commits.contains(mergeHash));
117 
118             // Author and committer should updated in the merge commit
119             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
120             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
121             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
122             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
123             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
124         }
125     }
126 
127     @Test
128     void branchMergeShortName(TestInfo testInfo) throws IOException {
129         try (var credentials = new HostCredentials(testInfo);
130              var tempFolder = new TemporaryDirectory()) {
131 
132             var author = credentials.getHostedRepository();
133             var integrator = credentials.getHostedRepository();
134             var censusBuilder = credentials.getCensusBuilder()
135                                            .addCommitter(author.forge().currentUser().id())
136                                            .addReviewer(integrator.forge().currentUser().id());
137             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
138 
139             // Populate the projects repository
140             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
141             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
142             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
143             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
144             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
145 
146             // Make more changes in another branch
147             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
148                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
149             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
150             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
151                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
152             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
153 
154             // Go back to the original master
155             localRepo.checkout(masterHash, true);
156 
157             // Make a change with a corresponding PR
158             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
159             localRepo.add(unrelated);
160             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
161             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
162 
163             localRepo.merge(otherHash2);
164             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
165             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
166             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge other&quot;);
167 
168             // Approve it as another user
169             var approvalPr = integrator.pullRequest(pr.id());
170             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
171 
172             // Let the bot check the status
173             TestBotRunner.runPeriodicItems(mergeBot);
174 
175             // Push it
176             pr.addComment(&quot;/integrate&quot;);
177             TestBotRunner.runPeriodicItems(mergeBot);
178 
179             // The bot should reply with an ok message
180             var pushed = pr.comments().stream()
181                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
182                            .count();
183             assertEquals(1, pushed);
184 
185             // The change should now be present on the master branch
186             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
187             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
188             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
189 
190             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
191             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
192             Set&lt;Hash&gt; commits;
193             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
194                 commits = tempCommits.stream()
195                                      .map(Commit::hash)
196                                      .collect(Collectors.toSet());
197             }
198             assertTrue(commits.contains(otherHash1));
199             assertTrue(commits.contains(otherHash2));
200             assertFalse(commits.contains(mergeHash));
201 
202             // Author and committer should updated in the merge commit
203             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
204             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
205             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
206             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
207             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
208         }
209     }
210 
211     @Test
212     @Disabled
213     void branchMergeRebase(TestInfo testInfo) throws IOException {
214         try (var credentials = new HostCredentials(testInfo);
215              var tempFolder = new TemporaryDirectory()) {
216 
217             var author = credentials.getHostedRepository();
218             var integrator = credentials.getHostedRepository();
219             var censusBuilder = credentials.getCensusBuilder()
220                                            .addCommitter(author.forge().currentUser().id())
221                                            .addReviewer(integrator.forge().currentUser().id());
222             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
223 
224             // Populate the projects repository
225             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
226             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
227             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
228             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
229             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
230 
231             // Make more changes in another branch
232             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
233                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
234             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
235             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
236                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
237             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
238 
239             // Go back to the original master
240             localRepo.checkout(masterHash, true);
241 
242             // Make a change with a corresponding PR
243             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
244             localRepo.add(unrelated);
245             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
246             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
247 
248             localRepo.merge(otherHash2);
249             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
250             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
251             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
252 
253             // Approve it as another user
254             var approvalPr = integrator.pullRequest(pr.id());
255             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
256 
257             // Let the bot check the status
258             TestBotRunner.runPeriodicItems(mergeBot);
259 
260             // Push something new to master
261             localRepo.checkout(updatedMaster, true);
262             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
263             localRepo.add(newMaster);
264             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
265             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
266 
267             // Let the bot notice
268             TestBotRunner.runPeriodicItems(mergeBot);
269 
270             // Push it
271             pr.addComment(&quot;/integrate&quot;);
272             TestBotRunner.runPeriodicItems(mergeBot);
273 
274             // The bot should reply with an ok message
275             var pushed = pr.comments().stream()
276                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
277                            .count();
278             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
279 
280             // The change should now be present on the master branch
281             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
282             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
283             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
284 
285             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
286             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
287             Set&lt;Hash&gt; commits;
288             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
289                 commits = tempCommits.stream()
290                         .map(Commit::hash)
291                         .collect(Collectors.toSet());
292             }
293             assertTrue(commits.contains(otherHash1));
294             assertTrue(commits.contains(otherHash2));
295             assertFalse(commits.contains(mergeHash));
296 
297             // Author and committer should updated in the merge commit
298             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
299             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
300             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
301             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
302             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
303         }
304     }
305 
306     @Test
307     @Disabled
308     void branchMergeAdditionalCommits(TestInfo testInfo) throws IOException {
309         try (var credentials = new HostCredentials(testInfo);
310              var tempFolder = new TemporaryDirectory()) {
311 
312             var author = credentials.getHostedRepository();
313             var integrator = credentials.getHostedRepository();
314             var censusBuilder = credentials.getCensusBuilder()
315                                            .addCommitter(author.forge().currentUser().id())
316                                            .addReviewer(integrator.forge().currentUser().id());
317             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
318 
319             // Populate the projects repository
320             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
321             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
322             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
323             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
324             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
325 
326             // Make more changes in another branch
327             var otherHash1 = CheckableRepository.appendAndCommit(localRepo, &quot;First change in other&quot;,
328                                                                  &quot;First other\n\nReviewed-by: integrationreviewer2&quot;);
329             localRepo.push(otherHash1, author.url(), &quot;other&quot;, true);
330             var otherHash2 = CheckableRepository.appendAndCommit(localRepo, &quot;Second change in other&quot;,
331                                                                  &quot;Second other\n\nReviewed-by: integrationreviewer2&quot;);
332             localRepo.push(otherHash2, author.url(), &quot;other&quot;);
333 
334             // Go back to the original master
335             localRepo.checkout(masterHash, true);
336 
337             // Make a change with a corresponding PR
338             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
339             localRepo.add(unrelated);
340             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
341             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
342 
343             localRepo.merge(otherHash2);
344             var mergeHash = localRepo.commit(&quot;Our own merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
345             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
346             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
347 
348             // Approve it as another user
349             var approvalPr = integrator.pullRequest(pr.id());
350             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
351 
352             // Let the bot check the status
353             TestBotRunner.runPeriodicItems(mergeBot);
354 
355             // Push something new to master
356             localRepo.checkout(updatedMaster, true);
357             var newMaster = Files.writeString(localRepo.root().resolve(&quot;newmaster.txt&quot;), &quot;New on master&quot;, StandardCharsets.UTF_8);
358             localRepo.add(newMaster);
359             var newMasterHash = localRepo.commit(&quot;New commit on master&quot;, &quot;some&quot;, &quot;some@one&quot;);
360             localRepo.push(newMasterHash, author.url(), &quot;master&quot;);
361 
362             // Let the bot notice
363             TestBotRunner.runPeriodicItems(mergeBot);
364 
365             // Add another commit on top of the merge commit
366             localRepo.checkout(mergeHash, true);
367             var extraHash = CheckableRepository.appendAndCommit(localRepo, &quot;Fixing up stuff after merge&quot;);
368             localRepo.push(extraHash, author.url(), &quot;edit&quot;);
369 
370             // Let the bot notice again
371             TestBotRunner.runPeriodicItems(mergeBot);
372 
373             // Merge the latest from master
374             localRepo.merge(newMasterHash);
375             var latestMergeHash = localRepo.commit(&quot;Our to be squashed merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
376             localRepo.push(latestMergeHash, author.url(), &quot;edit&quot;);
377 
378             // Let the bot notice again
379             TestBotRunner.runPeriodicItems(mergeBot);
380 
381             // Push it
382             pr.addComment(&quot;/integrate&quot;);
383             TestBotRunner.runPeriodicItems(mergeBot);
384 
385             // The bot should reply with an ok message
386             var pushed = pr.comments().stream()
387                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))
388                            .count();
389             assertEquals(1, pushed, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
390 
391             // The change should now be present on the master branch
392             var pushedRepoFolder = tempFolder.path().resolve(&quot;pushedrepo&quot;);
393             var pushedRepo = Repository.materialize(pushedRepoFolder, author.url(), &quot;master&quot;);
394             assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));
395 
396             // The commits from the &quot;other&quot; branch should be preserved and not squashed (but not the merge commit)
397             var headHash = pushedRepo.resolve(&quot;HEAD&quot;).orElseThrow();
398             String commits;
399             try (var tempCommits = pushedRepo.commits(masterHash.hex() + &quot;..&quot; + headHash.hex())) {
400                 commits = tempCommits.stream()
401                                      .map(c -&gt; c.hash().hex() + &quot;:&quot; + c.message().get(0))
402                                      .collect(Collectors.joining(&quot;,&quot;));
403             }
404             assertTrue(commits.contains(otherHash1.hex() + &quot;:First other&quot;));
405             assertTrue(commits.contains(otherHash2.hex() + &quot;:Second other&quot;));
406             assertFalse(commits.contains(&quot;Our own merge commit&quot;));
407 
408             // Author and committer should updated in the merge commit
409             var headCommit = pushedRepo.commits(headHash.hex() + &quot;^..&quot; + headHash.hex()).asList().get(0);
410             assertEquals(&quot;Generated Committer 1&quot;, headCommit.author().name());
411             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.author().email());
412             assertEquals(&quot;Generated Committer 1&quot;, headCommit.committer().name());
413             assertEquals(&quot;integrationcommitter1@openjdk.java.net&quot;, headCommit.committer().email());
414         }
415     }
416 
417     @Test
418     void invalidMergeCommit(TestInfo testInfo) throws IOException {
419         try (var credentials = new HostCredentials(testInfo);
420              var tempFolder = new TemporaryDirectory()) {
421 
422             var author = credentials.getHostedRepository();
423             var integrator = credentials.getHostedRepository();
424             var censusBuilder = credentials.getCensusBuilder()
425                                            .addCommitter(author.forge().currentUser().id())
426                                            .addReviewer(integrator.forge().currentUser().id());
427             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
428 
429             // Populate the projects repository
430             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
431             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
432             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
433             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
434             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
435 
436             // Make a change in another branch
437             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
438                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
439             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
440 
441             // Go back to the original master
442             localRepo.checkout(masterHash, true);
443 
444             // Make a change with a corresponding PR
445             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
446             localRepo.add(unrelated);
447             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
448             localRepo.merge(otherHash);
449             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
450             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
451             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
452 
453             // Approve it as another user
454             var approvalPr = integrator.pullRequest(pr.id());
455             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
456 
457             // Let the bot check the status
458             TestBotRunner.runPeriodicItems(mergeBot);
459 
460             // Push it
461             pr.addComment(&quot;/integrate&quot;);
462             TestBotRunner.runPeriodicItems(mergeBot);
463 
464             // The bot should reply with a failure message
465             var error = pr.comments().stream()
466                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
467                           .count();
468             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
469 
470             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
471             assertEquals(&quot;- It was not possible to create a commit for the changes in this PR: A merge PR is only allowed to contain a single merge commit. You will need to amend your commits.&quot;, check.summary().orElseThrow());
472         }
473     }
474 
475     @Test
476     void invalidSourceRepo(TestInfo testInfo) throws IOException {
477         try (var credentials = new HostCredentials(testInfo);
478              var tempFolder = new TemporaryDirectory()) {
479 
480             var author = credentials.getHostedRepository();
481             var integrator = credentials.getHostedRepository();
482             var censusBuilder = credentials.getCensusBuilder()
483                                            .addCommitter(author.forge().currentUser().id())
484                                            .addReviewer(integrator.forge().currentUser().id());
485             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
486 
487             // Populate the projects repository
488             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
489             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
490             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
491             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
492             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
493 
494             // Make a change in another branch
495             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
496                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
497             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
498 
499             // Go back to the original master
500             localRepo.checkout(masterHash, true);
501 
502             // Make a change with a corresponding PR
503             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
504             localRepo.add(unrelated);
505             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
506             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
507 
508             localRepo.merge(otherHash);
509             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
510             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
511             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;xyz&quot; + &quot;:other&quot;);
512 
513             // Approve it as another user
514             var approvalPr = integrator.pullRequest(pr.id());
515             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
516 
517             // Let the bot check the status
518             TestBotRunner.runPeriodicItems(mergeBot);
519 
520             // Push it
521             pr.addComment(&quot;/integrate&quot;);
522             TestBotRunner.runPeriodicItems(mergeBot);
523 
524             // The bot should reply with a failure message
525             var error = pr.comments().stream()
526                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
527                           .count();
528             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
529 
530             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
531             assertEquals(&quot;- Could not find project `&quot; + author.name() + &quot;xyz` - check that it is correct.&quot;, check.summary().orElseThrow());
532         }
533     }
534 
535     @Test
536     void invalidSourceBranch(TestInfo testInfo) throws IOException {
537         try (var credentials = new HostCredentials(testInfo);
538              var tempFolder = new TemporaryDirectory()) {
539 
540             var author = credentials.getHostedRepository();
541             var integrator = credentials.getHostedRepository();
542             var censusBuilder = credentials.getCensusBuilder()
543                                            .addCommitter(author.forge().currentUser().id())
544                                            .addReviewer(integrator.forge().currentUser().id());
545             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
546 
547             // Populate the projects repository
548             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
549             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
550             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
551             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
552             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
553 
554             // Make a change in another branch
555             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
556                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
557             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
558 
559             // Go back to the original master
560             localRepo.checkout(masterHash, true);
561 
562             // Make a change with a corresponding PR
563             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
564             localRepo.add(unrelated);
565             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
566             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
567 
568             localRepo.merge(otherHash);
569             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
570             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
571             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:otherxyz&quot;);
572 
573             // Approve it as another user
574             var approvalPr = integrator.pullRequest(pr.id());
575             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
576 
577             // Let the bot check the status
578             TestBotRunner.runPeriodicItems(mergeBot);
579 
580             // Push it
581             pr.addComment(&quot;/integrate&quot;);
582             TestBotRunner.runPeriodicItems(mergeBot);
583 
584             // The bot should reply with a failure message
585             var error = pr.comments().stream()
586                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
587                           .count();
588             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
589 
590             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
591             assertEquals(&quot;- Could not fetch branch `otherxyz` from project `&quot; + author.name() + &quot;` - check that they are correct.&quot;, check.summary().orElseThrow());
592         }
593     }
594 
595     @Test
596     void inferredSourceProject(TestInfo testInfo) throws IOException {
597         try (var credentials = new HostCredentials(testInfo);
598              var tempFolder = new TemporaryDirectory()) {
599 
600             var author = credentials.getHostedRepository();
601             var integrator = credentials.getHostedRepository();
602             var censusBuilder = credentials.getCensusBuilder()
603                                            .addCommitter(author.forge().currentUser().id())
604                                            .addReviewer(integrator.forge().currentUser().id());
605             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
606 
607             // Populate the projects repository
608             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
609             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
610             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
611             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
612             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
613 
614             // Make a change in another branch
615             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
616                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
617             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
618 
619             // Go back to the original master
620             localRepo.checkout(masterHash, true);
621 
622             // Make a change with a corresponding PR
623             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
624             localRepo.add(unrelated);
625             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
626             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
627 
628             localRepo.merge(otherHash);
629             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
630             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
631             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge otherxyz&quot;);
632 
633             // Approve it as another user
634             var approvalPr = integrator.pullRequest(pr.id());
635             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
636 
637             // Let the bot check the status
638             TestBotRunner.runPeriodicItems(mergeBot);
639 
640             // Push it
641             pr.addComment(&quot;/integrate&quot;);
642             TestBotRunner.runPeriodicItems(mergeBot);
643 
644             // The bot should reply with a failure message
645             var error = pr.comments().stream()
646                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
647                           .count();
648             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
649 
650             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
651             assertEquals(&quot;- Could not find project `otherxyz` - check that it is correct.&quot;, check.summary().orElseThrow());
652         }
653     }
654 
655     @Test
656     void wrongSourceBranch(TestInfo testInfo) throws IOException {
657         try (var credentials = new HostCredentials(testInfo);
658              var tempFolder = new TemporaryDirectory()) {
659 
660             var author = credentials.getHostedRepository();
661             var integrator = credentials.getHostedRepository();
662             var censusBuilder = credentials.getCensusBuilder()
663                                            .addCommitter(author.forge().currentUser().id())
664                                            .addReviewer(integrator.forge().currentUser().id());
665             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
666 
667             // Populate the projects repository
668             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
669             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
670             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
671             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
672             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
673 
674             // Make a change in another branch
675             var other1Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other1&quot;,
676                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
677             localRepo.push(other1Hash, author.url(), &quot;other1&quot;, true);
678 
679             // Go back to the original master
680             localRepo.checkout(masterHash, true);
681 
682             // Make yet another change in another branch
683             var other2Hash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other2&quot;,
684                                                                 &quot;Unrelated\n\nReviewed-by: integrationreviewer2&quot;);
685             localRepo.push(other2Hash, author.url(), &quot;other2&quot;, true);
686 
687             // Make a change with a corresponding PR
<a name="1" id="anc1"></a>
688             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
689             localRepo.add(unrelated);
690             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
691             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
692 
693             localRepo.merge(other1Hash, &quot;ours&quot;);
694             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
695             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
696             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other2&quot;);
697 
698             // Approve it as another user
699             var approvalPr = integrator.pullRequest(pr.id());
700             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
701 
702             // Let the bot check the status
703             TestBotRunner.runPeriodicItems(mergeBot);
704 
705             // Push it
706             pr.addComment(&quot;/integrate&quot;);
707             TestBotRunner.runPeriodicItems(mergeBot);
708 
709             // The bot should reply with a failure message
710             var error = pr.comments().stream()
711                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
712                           .count();
713             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
714 
715             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
<a name="2" id="anc2"></a><span class="line-modified">716             assertEquals(&quot;- The merge contains commits that are not ancestors of the source.&quot;, check.summary().orElseThrow());</span>
717         }
718     }
719 
720     @Test
721     void invalidAuthor(TestInfo testInfo) throws IOException {
722         try (var credentials = new HostCredentials(testInfo);
723              var tempFolder = new TemporaryDirectory()) {
724 
725             var author = credentials.getHostedRepository();
726             var integrator = credentials.getHostedRepository();
727             var censusBuilder = credentials.getCensusBuilder()
728                                            .addAuthor(author.forge().currentUser().id())
729                                            .addReviewer(integrator.forge().currentUser().id());
730             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
731 
732             // Populate the projects repository
733             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
734             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
735             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
736             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
737             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
738 
739             // Make a change in another branch
740             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
741                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
742             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
743 
744             // Go back to the original master
745             localRepo.checkout(masterHash, true);
746 
747             // Make a change with a corresponding PR
748             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
749             localRepo.add(unrelated);
750             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
751             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
752 
753             localRepo.merge(otherHash);
754             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
755             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
756             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
757 
758             // Approve it as another user
759             var approvalPr = integrator.pullRequest(pr.id());
760             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
761 
762             // Let the bot check the status
763             TestBotRunner.runPeriodicItems(mergeBot);
764 
765             // Push it
766             pr.addComment(&quot;/integrate&quot;);
767             TestBotRunner.runPeriodicItems(mergeBot);
768 
769             // The bot should reply with a need for sponsor
770             var error = pr.comments().stream()
771                           .filter(comment -&gt; comment.body().contains(&quot;Afterwards, your sponsor types `/sponsor`&quot;))
772                           .count();
773             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
774         }
775     }
776 
777     @Test
778     void unrelatedHistory(TestInfo testInfo) throws IOException {
779         try (var credentials = new HostCredentials(testInfo);
780              var tempFolder = new TemporaryDirectory()) {
781 
782             var author = credentials.getHostedRepository();
783             // Need to force merge unrelated histories
784             assumeTrue(author.repositoryType().equals(VCS.GIT));
785 
786             var integrator = credentials.getHostedRepository();
787             var censusBuilder = credentials.getCensusBuilder()
788                                            .addCommitter(author.forge().currentUser().id())
789                                            .addReviewer(integrator.forge().currentUser().id());
790             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
791 
792             // Populate the projects repository
793             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
794             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType());
795             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
796 
797             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
798             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
799 
800             // Make an unrelated change in another branch
801             var unrelatedRepoFolder = tempFolder.path().resolve(&quot;unrelated&quot;);
802             var unrelatedRepo = CheckableRepository.init(unrelatedRepoFolder, author.repositoryType(), Path.of(&quot;anotherfile.txt&quot;));
803             unrelatedRepo.amend(&quot;Unrelated initial commit\n\nReviewed-by: integrationreviewer2&quot;, &quot;some&quot;, &quot;one@mail&quot;);
804             var otherHash = CheckableRepository.appendAndCommit(unrelatedRepo, &quot;Change in other&quot;,
805                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
806             unrelatedRepo.push(otherHash, author.url(), &quot;other&quot;, true);
807             localRepo.fetch(author.url(), &quot;other&quot;);
808 
809             // Go back to the original master
810             localRepo.checkout(masterHash, true);
811 
812             // Make a change with a corresponding PR
813             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
814             localRepo.add(unrelated);
815             localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
816             var mergeCmd = Process.command(&quot;git&quot;, &quot;merge&quot;, &quot;--no-commit&quot;, &quot;--allow-unrelated-histories&quot;, &quot;-s&quot;, &quot;ours&quot;, otherHash.hex())
817                                   .workdir(localRepo.root())
818                                   .environ(&quot;GIT_AUTHOR_NAME&quot;, &quot;some&quot;)
819                                   .environ(&quot;GIT_AUTHOR_EMAIL&quot;, &quot;some@one&quot;)
820                                   .environ(&quot;GIT_COMMITTER_NAME&quot;, &quot;another&quot;)
821                                   .environ(&quot;GIT_COMMITTER_EMAIL&quot;, &quot;another@one&quot;)
822                                   .execute();
823             mergeCmd.check();
824 
825             //localRepo.merge(otherHash);
826             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
827             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
828             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge &quot; + author.name() + &quot;:other&quot;);
829 
830             // Approve it as another user
831             var approvalPr = integrator.pullRequest(pr.id());
832             approvalPr.addReview(Review.Verdict.APPROVED, &quot;Approved&quot;);
833 
834             // Let the bot check the status
835             TestBotRunner.runPeriodicItems(mergeBot);
836 
837             // Push it
838             pr.addComment(&quot;/integrate&quot;);
839             TestBotRunner.runPeriodicItems(mergeBot);
840 
<a name="3" id="anc3"></a><span class="line-modified">841             // The bot should reply with an ok message as we currently allow this</span>
<span class="line-modified">842             var pushed = pr.comments().stream()</span>
<span class="line-modified">843                            .filter(comment -&gt; comment.body().contains(&quot;Pushed as commit&quot;))</span>
<span class="line-modified">844                            .count();</span>
<span class="line-modified">845             assertEquals(1, pushed);</span>



846         }
847     }
848 
849     @Test
850     void invalidSyntax(TestInfo testInfo) throws IOException {
851         try (var credentials = new HostCredentials(testInfo);
852              var tempFolder = new TemporaryDirectory()) {
853 
854             var author = credentials.getHostedRepository();
855             var integrator = credentials.getHostedRepository();
856             var censusBuilder = credentials.getCensusBuilder()
857                                            .addCommitter(author.forge().currentUser().id())
858                                            .addReviewer(integrator.forge().currentUser().id());
859             var mergeBot = PullRequestBot.newBuilder().repo(integrator).censusRepo(censusBuilder.build()).build();
860 
861             // Populate the projects repository
862             var localRepoFolder = tempFolder.path().resolve(&quot;localrepo&quot;);
863             var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(&quot;appendable.txt&quot;), Set.of(&quot;merge&quot;), &quot;1.0&quot;);
864             var masterHash = localRepo.resolve(&quot;master&quot;).orElseThrow();
865             assertFalse(CheckableRepository.hasBeenEdited(localRepo));
866             localRepo.push(masterHash, author.url(), &quot;master&quot;, true);
867 
868             // Make a change in another branch
869             var otherHash = CheckableRepository.appendAndCommit(localRepo, &quot;Change in other&quot;,
870                                                                 &quot;Other\n\nReviewed-by: integrationreviewer2&quot;);
871             localRepo.push(otherHash, author.url(), &quot;other&quot;, true);
872 
873             // Go back to the original master
874             localRepo.checkout(masterHash, true);
875 
876             // Make a change with a corresponding PR
877             var unrelated = Files.writeString(localRepo.root().resolve(&quot;unrelated.txt&quot;), &quot;Unrelated&quot;, StandardCharsets.UTF_8);
878             localRepo.add(unrelated);
879             var updatedMaster = localRepo.commit(&quot;Unrelated&quot;, &quot;some&quot;, &quot;some@one&quot;);
880             localRepo.push(updatedMaster, author.url(), &quot;master&quot;);
881 
882             localRepo.merge(otherHash);
883             var mergeHash = localRepo.commit(&quot;Merge commit&quot;, &quot;some&quot;, &quot;some@one&quot;);
884             localRepo.push(mergeHash, author.url(), &quot;edit&quot;, true);
885             var pr = credentials.createPullRequest(author, &quot;master&quot;, &quot;edit&quot;, &quot;Merge this or that&quot;);
886 
887             // Let the bot check the status
888             TestBotRunner.runPeriodicItems(mergeBot);
889 
890             // Push it
891             pr.addComment(&quot;/integrate&quot;);
892             TestBotRunner.runPeriodicItems(mergeBot);
893 
894             // The bot should reply with a failure message
895             var error = pr.comments().stream()
896                           .filter(comment -&gt; comment.body().contains(&quot;did not complete successfully&quot;))
897                           .count();
898             assertEquals(1, error, () -&gt; pr.comments().stream().map(Comment::body).collect(Collectors.joining(&quot;\n\n&quot;)));
899 
900             var check = pr.checks(mergeHash).get(&quot;jcheck&quot;);
901             assertEquals(&quot;- Could not determine the source for this merge. A Merge PR title must be specified on the format: Merge `project`:`branch` to allow verification of the merge contents.\n&quot; +
902                                  &quot;- Merge commit message is not Merge, but: Merge this or that&quot;, check.summary().orElseThrow());
903         }
904     }
905 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PullRequestInstance.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
161                     .map(name -&gt; &quot;   - &quot; + name)
162                     .collect(Collectors.joining(&quot;\n&quot;));
163             ret.add(error);
164         }
165 
166         var baseHash = prInstance.baseHash();
167         var headHash = pr.headHash();
168         var commits = prInstance.localRepo().commitMetadata(baseHash, headHash);
169 
170         if (!checkCommitAuthor(commits)) {
171             var error = &quot;For contributors who are not existing OpenJDK Authors, commit attribution will be taken from &quot; +
172                     &quot;the commits in the PR. However, the commits in this PR have inconsistent user names and/or &quot; +
173                     &quot;email addresses. Please amend the commits.&quot;;
174             ret.add(error);
175         }
176 
177         if (pr.title().startsWith(&quot;Merge&quot;)) {
178             if (commits.size() &lt; 2) {
179                 ret.add(&quot;A Merge PR must contain at least two commits that are not already present in the target.&quot;);
180             } else {
<span class="line-modified">181                 // Find the last merge commit - the very last commit is not eligible (as the merge needs a parent)</span>
182                 int mergeCommitIndex = commits.size();
183                 for (int i = 0; i &lt; commits.size() - 1; ++i) {
184                     if (commits.get(i).isMerge()) {
185                         mergeCommitIndex = i;

186                     }
187                 }
188                 if (mergeCommitIndex &gt;= commits.size() - 1) {
189                     ret.add(&quot;A Merge PR must contain a merge commit as well as at least one other commit from the merge source.&quot;);
190                 }
191 
192                 var source = mergeSource();
193                 if (source.isPresent()) {
194                     try {
195                         var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() -&gt;
196                                 new RuntimeException(&quot;Could not find repository &quot; + source.get().repositoryName)
197                         );
198                         try {
199                             var sourceHash = prInstance.localRepo().fetch(mergeSourceRepo.url(), source.get().branchName);
200                             var mergeCommit = commits.get(mergeCommitIndex);
<span class="line-modified">201                             for (int i = 1; i &lt; mergeCommit.parents().size(); ++i) {</span>
202                                 if (!prInstance.localRepo().isAncestor(mergeCommit.parents().get(i), sourceHash)) {
<span class="line-modified">203                                     ret.add(&quot;The merge contains commits that are not ancestors of the source.&quot;);</span>
<span class="line-modified">204                                     break;</span>


205                                 }
206                             }
207                         } catch (IOException e) {
208                             ret.add(&quot;Could not fetch branch `&quot; + source.get().branchName + &quot;` from project `&quot; +
209                                             source.get().repositoryName + &quot;` - check that they are correct.&quot;);
210                         }
211                     } catch (RuntimeException e) {
212                         ret.add(&quot;Could not find project `&quot; +
213                                         source.get().repositoryName + &quot;` - check that it is correct.&quot;);
214                     }
215                 } else {
216                     ret.add(&quot;Could not determine the source for this merge. A Merge PR title must be specified on the format: &quot; +
217                             &quot;Merge `project`:`branch` to allow verification of the merge contents.&quot;);
218                 }
219             }
220         }
221 
222         for (var blocker : workItem.bot.blockingCheckLabels().entrySet()) {
223             if (labels.contains(blocker.getKey())) {
224                 ret.add(blocker.getValue());
</pre>
</td>
<td>
<hr />
<pre>
161                     .map(name -&gt; &quot;   - &quot; + name)
162                     .collect(Collectors.joining(&quot;\n&quot;));
163             ret.add(error);
164         }
165 
166         var baseHash = prInstance.baseHash();
167         var headHash = pr.headHash();
168         var commits = prInstance.localRepo().commitMetadata(baseHash, headHash);
169 
170         if (!checkCommitAuthor(commits)) {
171             var error = &quot;For contributors who are not existing OpenJDK Authors, commit attribution will be taken from &quot; +
172                     &quot;the commits in the PR. However, the commits in this PR have inconsistent user names and/or &quot; +
173                     &quot;email addresses. Please amend the commits.&quot;;
174             ret.add(error);
175         }
176 
177         if (pr.title().startsWith(&quot;Merge&quot;)) {
178             if (commits.size() &lt; 2) {
179                 ret.add(&quot;A Merge PR must contain at least two commits that are not already present in the target.&quot;);
180             } else {
<span class="line-modified">181                 // Find the first merge commit - the very last commit is not eligible (as the merge needs a parent)</span>
182                 int mergeCommitIndex = commits.size();
183                 for (int i = 0; i &lt; commits.size() - 1; ++i) {
184                     if (commits.get(i).isMerge()) {
185                         mergeCommitIndex = i;
<span class="line-added">186                         break;</span>
187                     }
188                 }
189                 if (mergeCommitIndex &gt;= commits.size() - 1) {
190                     ret.add(&quot;A Merge PR must contain a merge commit as well as at least one other commit from the merge source.&quot;);
191                 }
192 
193                 var source = mergeSource();
194                 if (source.isPresent()) {
195                     try {
196                         var mergeSourceRepo = pr.repository().forge().repository(source.get().repositoryName).orElseThrow(() -&gt;
197                                 new RuntimeException(&quot;Could not find repository &quot; + source.get().repositoryName)
198                         );
199                         try {
200                             var sourceHash = prInstance.localRepo().fetch(mergeSourceRepo.url(), source.get().branchName);
201                             var mergeCommit = commits.get(mergeCommitIndex);
<span class="line-modified">202                             for (int i = 0; i &lt; mergeCommit.parents().size(); ++i) {</span>
203                                 if (!prInstance.localRepo().isAncestor(mergeCommit.parents().get(i), sourceHash)) {
<span class="line-modified">204                                     if (!mergeCommit.parents().get(i).equals(prInstance.targetHash())) {</span>
<span class="line-modified">205                                         ret.add(&quot;The merge contains commits that are neither ancestors of the source nor the target.&quot;);</span>
<span class="line-added">206                                         break;</span>
<span class="line-added">207                                     }</span>
208                                 }
209                             }
210                         } catch (IOException e) {
211                             ret.add(&quot;Could not fetch branch `&quot; + source.get().branchName + &quot;` from project `&quot; +
212                                             source.get().repositoryName + &quot;` - check that they are correct.&quot;);
213                         }
214                     } catch (RuntimeException e) {
215                         ret.add(&quot;Could not find project `&quot; +
216                                         source.get().repositoryName + &quot;` - check that it is correct.&quot;);
217                     }
218                 } else {
219                     ret.add(&quot;Could not determine the source for this merge. A Merge PR title must be specified on the format: &quot; +
220                             &quot;Merge `project`:`branch` to allow verification of the merge contents.&quot;);
221                 }
222             }
223         }
224 
225         for (var blocker : workItem.bot.blockingCheckLabels().entrySet()) {
226             if (labels.contains(blocker.getKey())) {
227                 ret.add(blocker.getValue());
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PullRequestInstance.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
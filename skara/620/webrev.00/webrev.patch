diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/CheckRun.java
@@ -155,11 +155,11 @@
     private void updateCheckBuilder(CheckBuilder checkBuilder, PullRequestCheckIssueVisitor visitor, List<String> additionalErrors) {
         if (visitor.isReadyForReview() && additionalErrors.isEmpty()) {
             checkBuilder.complete(true);
         } else {
             checkBuilder.title("Required");
-            var summary = Stream.concat(visitor.getMessages().stream(), additionalErrors.stream())
+            var summary = Stream.concat(visitor.messages().stream(), additionalErrors.stream())
                                 .sorted()
                                 .map(m -> "- " + m)
                                 .collect(Collectors.joining("\n"));
             checkBuilder.summary(summary);
             for (var annotation : visitor.getAnnotations()) {
@@ -272,17 +272,20 @@
         var progressBody = new StringBuilder();
         progressBody.append("---------\n");
         progressBody.append("### Progress\n");
         progressBody.append(getChecksList(visitor));
 
-        if (!additionalErrors.isEmpty()) {
+        var allAdditionalErrors = Stream.concat(visitor.hiddenMessages().stream(), additionalErrors.stream())
+                                        .sorted()
+                                        .collect(Collectors.toList());
+        if (!allAdditionalErrors.isEmpty()) {
             progressBody.append("\n\n### Error");
-            if (additionalErrors.size() > 1) {
+            if (allAdditionalErrors.size() > 1) {
                 progressBody.append("s");
             }
             progressBody.append("\n");
-            progressBody.append(getAdditionalErrorsList(additionalErrors));
+            progressBody.append(getAdditionalErrorsList(allAdditionalErrors));
         }
 
         var issue = Issue.fromString(pr.title());
         var issueProject = workItem.bot.issueProject();
         if (issueProject != null && issue.isPresent()) {
@@ -630,11 +633,11 @@
                 updateReviewedMessages(comments, allReviews);
             }
 
             var commit = localRepo.lookup(localHash).orElseThrow();
             var commitMessage = String.join("\n", commit.message());
-            var readyForIntegration = visitor.getMessages().isEmpty() && additionalErrors.isEmpty();
+            var readyForIntegration = visitor.messages().isEmpty() && additionalErrors.isEmpty();
             updateMergeReadyComment(readyForIntegration, commitMessage, comments, activeReviews, rebasePossible);
             if (readyForIntegration && rebasePossible) {
                 newLabels.add("ready");
             } else {
                 newLabels.remove("ready");
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/IntegrateCommand.java
@@ -114,14 +114,14 @@
             var localHash = checkablePr.commit(rebasedHash.get(), censusInstance.namespace(), censusInstance.configuration().census().domain(), null);
 
             var issues = checkablePr.createVisitor(localHash, censusInstance);
             var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash, pr.repository().forge().currentUser(), allComments);
             checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
-            if (!issues.getMessages().isEmpty()) {
+            if (!issues.messages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
                 reply.println("your changes failed the final jcheck:");
-                issues.getMessages().stream()
+                issues.messages().stream()
                       .map(line -> " * " + line)
                       .forEach(reply::println);
                 return;
             }
 
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestCheckIssueVisitor.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestCheckIssueVisitor.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestCheckIssueVisitor.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestCheckIssueVisitor.java
@@ -30,14 +30,13 @@
 import java.util.*;
 import java.util.logging.Logger;
 import java.util.stream.Collectors;
 
 class PullRequestCheckIssueVisitor implements IssueVisitor {
-    private final Set<String> messages = new HashSet<>();
     private final List<CheckAnnotation> annotations = new LinkedList<>();
     private final Set<Check> enabledChecks;
-    private final Set<Class<? extends Check>> failedChecks = new HashSet<>();
+    private final Map<Class<? extends Check>, String> failedChecks = new HashMap<>();
 
     private boolean readyForReview;
 
     private final Logger log = Logger.getLogger("org.openjdk.skara.bots.pr");
 
@@ -51,21 +50,34 @@
     PullRequestCheckIssueVisitor(Set<Check> enabledChecks) {
         this.enabledChecks = enabledChecks;
         readyForReview = true;
     }
 
-    List<String> getMessages() {
-        return new ArrayList<>(messages);
+    private void addFailureMessage(Check check, String message) {
+        failedChecks.put(check.getClass(), message);
+    }
+
+    List<String> messages() {
+        return new ArrayList<>(failedChecks.values());
+    }
+
+    List<String> hiddenMessages() {
+        return failedChecks.entrySet().stream()
+                           .filter(entry -> !displayedChecks.contains(entry.getKey()))
+                           .map(Map.Entry::getValue)
+                           .sorted()
+                           .collect(Collectors.toList());
     }
 
     Map<String, Boolean> getChecks() {
         return enabledChecks.stream()
                             .filter(check -> displayedChecks.contains(check.getClass()))
                             .collect(Collectors.toMap(Check::description,
-                                                      check -> !failedChecks.contains(check.getClass())));
+                                                      check -> !failedChecks.containsKey(check.getClass())));
     }
 
+
     List<CheckAnnotation> getAnnotations() { return annotations; }
 
     boolean isReadyForReview() {
         return readyForReview;
     }
@@ -79,12 +91,11 @@
                      .collect(Collectors.toList());
 
         var output = new StringBuilder();
         output.append("Issue id ").append(id).append(" is already used in these commits:\n");
         other.forEach(h -> output.append(" * ").append(h).append("\n"));
-        messages.add(output.toString());
-        failedChecks.add(e.check().getClass());
+        addFailureMessage(e.check(), output.toString());
         readyForReview = false;
     }
 
     @Override
     public void visit(TagIssue e) {
@@ -97,19 +108,17 @@
     }
 
     @Override
     public void visit(SelfReviewIssue e)
     {
-        messages.add("Self-reviews are not allowed");
-        failedChecks.add(e.check().getClass());
+        addFailureMessage(e.check(), "Self-reviews are not allowed");
         readyForReview = false;
     }
 
     @Override
     public void visit(TooFewReviewersIssue e) {
-        messages.add(String.format("Too few reviewers with at least role %s found (have %d, need at least %d)", e.role(), e.numActual(), e.numRequired()));
-        failedChecks.add(e.check().getClass());
+        addFailureMessage(e.check(), String.format("Too few reviewers with at least role %s found (have %d, need at least %d)", e.role(), e.numActual(), e.numRequired()));
     }
 
     @Override
     public void visit(InvalidReviewersIssue e) {
         var invalid = String.join(", ", e.invalid());
@@ -117,12 +126,11 @@
     }
 
     @Override
     public void visit(MergeMessageIssue e) {
         var message = String.join("\n", e.commit().message());
-        messages.add("Merge commit message is not " + e.expected() + ", but: " + message);
-        failedChecks.add(e.check().getClass());
+        addFailureMessage(e.check(), "Merge commit message is not " + e.expected() + ", but: " + message);
     }
 
     @Override
     public void visit(HgTagCommitIssue e) {
         throw new IllegalStateException("Hg tag commit issue - should not happen");
@@ -179,12 +187,11 @@
         }
 
         var annotation = annotationBuilder.title("Whitespace error").build();
         annotations.add(annotation);
 
-        messages.add("Whitespace errors");
-        failedChecks.add(e.check().getClass());
+        addFailureMessage(e.check(), "Whitespace errors");
         readyForReview = false;
     }
 
     @Override
     public void visit(MessageIssue issue) {
@@ -198,27 +205,24 @@
         throw new IllegalStateException("Commit message contains bad whitespace: " + message);
     }
 
     @Override
     public void visit(IssuesIssue issue) {
-        messages.add("The commit message does not reference any issue. To add an issue reference to this PR, " +
+        addFailureMessage(issue.check(), "The commit message does not reference any issue. To add an issue reference to this PR, " +
                 "edit the title to be of the format `issue number`: `message`.");
-        failedChecks.add(issue.check().getClass());
         readyForReview = false;
     }
 
     @Override
     public void visit(ExecutableIssue issue) {
-        messages.add(String.format("Executable files are not allowed (file: %s)", issue.path()));
-        failedChecks.add(issue.check().getClass());
+        addFailureMessage(issue.check(), String.format("Executable files are not allowed (file: %s)", issue.path()));
         readyForReview = false;
     }
 
     @Override
     public void visit(SymlinkIssue issue) {
-        messages.add(String.format("Symbolic links are not allowed (file: %s)", issue.path()));
-        failedChecks.add(issue.check().getClass());
+        addFailureMessage(issue.check(), String.format("Symbolic links are not allowed (file: %s)", issue.path()));
         readyForReview = false;
     }
 
     @Override
     public void visit(BlacklistIssue issue) {
@@ -230,10 +234,9 @@
         log.fine("ignored: binary file");
     }
 
     @Override
     public void visit(ProblemListsIssue issue) {
-        failedChecks.add(issue.check().getClass());
-        messages.add(issue.issue() + " is used in problem lists: " + issue.files());
+        addFailureMessage(issue.check(), issue.issue() + " is used in problem lists: " + issue.files());
         readyForReview = false;
     }
 }
diff a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
--- a/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
+++ b/bots/pr/src/main/java/org/openjdk/skara/bots/pr/SponsorCommand.java
@@ -100,14 +100,14 @@
                     comment.author().id());
 
             var issues = checkablePr.createVisitor(localHash, censusInstance);
             var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash, pr.repository().forge().currentUser(), allComments);
             checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration);
-            if (!issues.getMessages().isEmpty()) {
+            if (!issues.messages().isEmpty()) {
                 reply.print("Your merge request cannot be fulfilled at this time, as ");
                 reply.println("your changes failed the final jcheck:");
-                issues.getMessages().stream()
+                issues.messages().stream()
                       .map(line -> " * " + line)
                       .forEach(reply::println);
                 return;
             }
 
diff a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
--- a/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
+++ b/bots/pr/src/test/java/org/openjdk/skara/bots/pr/CheckTests.java
@@ -20,18 +20,18 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.skara.bots.pr;
 
+import org.junit.jupiter.api.*;
 import org.openjdk.skara.forge.*;
 import org.openjdk.skara.test.*;
 
-import org.junit.jupiter.api.*;
-
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.*;
+import java.nio.file.attribute.PosixFilePermission;
 import java.util.*;
 import java.util.regex.Pattern;
 
 import static org.junit.jupiter.api.Assertions.*;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
@@ -721,10 +721,77 @@
             assertFalse(updatedPr.body().contains("## Error"));
             assertFalse(updatedPr.body().contains("The pull request body must not be empty."));
         }
     }
 
+    @Test
+    void executableFile(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var author = credentials.getHostedRepository();
+            var reviewer = credentials.getHostedRepository();
+
+            var censusBuilder = credentials.getCensusBuilder()
+                                           .addAuthor(author.forge().currentUser().id())
+                                           .addReviewer(reviewer.forge().currentUser().id());
+            var checkBot = PullRequestBot.newBuilder()
+                                         .repo(author)
+                                         .censusRepo(censusBuilder.build())
+                                         .build();
+
+            // Populate the projects repository
+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType(),
+                    Path.of("executable.exe"), Set.of("reviewers", "executable"), "0.1");
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.push(masterHash, author.url(), "master", true);
+
+            // Make a change with a corresponding PR
+            Files.writeString(tempFolder.path().resolve("executable.exe"), "Executable file contents", StandardCharsets.UTF_8);
+            Files.setPosixFilePermissions(tempFolder.path().resolve("executable.exe"), Set.of(PosixFilePermission.OWNER_EXECUTE, PosixFilePermission.OWNER_READ));
+            localRepo.add(Path.of("executable.exe"));
+            var editHash = localRepo.commit("Make it executable", "duke", "duke@openjdk.org");
+            localRepo.push(editHash, author.url(), "edit", true);
+            var pr = credentials.createPullRequest(author, "master", "edit", "Another PR");
+            pr.setBody("This should now be ready");
+
+            // Check the status
+            TestBotRunner.runPeriodicItems(checkBot);
+
+            // Verify that the check failed
+            var checks = pr.checks(editHash);
+            assertEquals(1, checks.size());
+            var check = checks.get("jcheck");
+            assertEquals(CheckStatus.FAILURE, check.status());
+            assertTrue(check.summary().orElseThrow().contains("Executable files are not allowed (file: executable.exe)"));
+
+            // Additional errors should be displayed in the body
+            var updatedPr = author.pullRequest(pr.id());
+            assertTrue(updatedPr.body().contains("## Error"));
+            assertTrue(updatedPr.body().contains("Executable files are not allowed (file: executable.exe)"));
+
+            // The PR should not yet be ready for review
+            assertFalse(pr.labels().contains("rfr"));
+            assertFalse(pr.labels().contains("ready"));
+
+            // Drop that error
+            Files.setPosixFilePermissions(tempFolder.path().resolve("executable.exe"), Set.of(PosixFilePermission.OWNER_READ));
+            localRepo.add(Path.of("executable.exe"));
+            var updatedHash = localRepo.commit("Make it unexecutable", "duke", "duke@openjdk.org");
+            localRepo.push(updatedHash, author.url(), "edit");
+            TestBotRunner.runPeriodicItems(checkBot);
+
+            // The PR should now be ready for review
+            assertTrue(pr.labels().contains("rfr"));
+            assertFalse(pr.labels().contains("ready"));
+
+            // The additional errors should be gone
+            updatedPr = author.pullRequest(pr.id());
+            assertFalse(updatedPr.body().contains("## Error"));
+            assertFalse(updatedPr.body().contains("Executable files are not allowed"));
+        }
+    }
+
     @Test
     void missingReadyLabel(TestInfo testInfo) throws IOException {
         try (var credentials = new HostCredentials(testInfo);
              var tempFolder = new TemporaryDirectory()) {
             var author = credentials.getHostedRepository();

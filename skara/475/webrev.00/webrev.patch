diff a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
--- a/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
+++ b/bots/mlbridge/src/main/java/org/openjdk/skara/bots/mlbridge/ReviewArchive.java
@@ -122,34 +122,57 @@
                                   .flatMap(email -> Stream.of(email.headerValue("PR-Collapsed-IDs").split(" ")));
         return Stream.concat(primary, collapsed)
                      .collect(Collectors.toSet());
     }
 
+    private String parentAuthorPath(ArchiveItem item) {
+        var ret = new StringBuilder();
+        ret.append(item.author().id());
+        while (item.parent().isPresent()) {
+            item = item.parent().get();
+            ret.append(".");
+            ret.append(item.author().id());
+        }
+        return ret.toString();
+    }
+
     // Group items that has the same author and the same parent
     private List<List<ArchiveItem>> collapsableItems(List<ArchiveItem> items) {
         var grouped = items.stream()
-                           .collect(Collectors.groupingBy(item -> item.author().id() + "." + (item.parent().isPresent() ? item.parent().get() : "xxx"),
+                           .collect(Collectors.groupingBy(this::parentAuthorPath,
                                                           LinkedHashMap::new, Collectors.toList()));
         return new ArrayList<>(grouped.values());
     }
 
     private String quoteBody(String body) {
         return Arrays.stream(body.strip().split("\\R"))
                      .map(line -> line.length() > 0 ? line.charAt(0) == '>' ? ">" + line : "> " + line : "> ")
                      .collect(Collectors.joining("\n"));
     }
 
-    private String quotedParent(ArchiveItem item, int quoteLevel) {
-        if (item.parent().isPresent() && quoteLevel > 0) {
-            var quotedParentBody = quotedParent(item.parent().get(), quoteLevel - 1);
-            if (!quotedParentBody.isBlank()) {
-                return quoteBody(quotedParentBody) + "\n> \n" + quoteBody(item.parent().get().body());
+    private List<ArchiveItem> parentsToQuote(ArchiveItem item, int quoteLevel, Set<ArchiveItem> alreadyQuoted) {
+        var ret = new ArrayList<ArchiveItem>();
+
+        if (item.parent().isPresent() && quoteLevel > 0 && !alreadyQuoted.contains(item.parent().get())) {
+            ret.add(item.parent().get());
+            ret.addAll(parentsToQuote(item.parent().get(), quoteLevel - 1, alreadyQuoted));
+        }
+
+        return ret;
+    }
+
+    private String quoteSelectedParents(List<ArchiveItem> parentsToQuote) {
+        Collections.reverse(parentsToQuote);
+        var ret = "";
+        for (var parent : parentsToQuote) {
+            if (!ret.isBlank()) {
+                ret = quoteBody(ret) + "\n>\n" + quoteBody(parent.body());
             } else {
-                return quoteBody(item.parent().get().body());
+                ret = quoteBody(parent.body());
             }
         }
-        return "";
+        return ret;
     }
 
     private Email findArchiveItemEmail(ArchiveItem item, List<Email> sentEmails, List<Email> newEmails) {
         var uniqueItemId = getUniqueMessageId(item.id());
         var stableItemId = getStableMessageId(uniqueItemId);
@@ -199,16 +222,25 @@
             return ret;
         }
 
         var combinedItems = collapsableItems(unsentItems);
         for (var itemList : combinedItems) {
-            // Simply combine all message bodies
+            var quotedParents = new HashSet<ArchiveItem>();
+
+            // Simply combine all message bodies together with unique quotes
             var body = new StringBuilder();
             for (var item : itemList) {
                 if (body.length() > 0) {
                     body.append("\n\n");
                 }
+                var newQuotes = parentsToQuote(item, 2, quotedParents);
+                var quote = quoteSelectedParents(newQuotes);
+                if (!quote.isBlank()) {
+                    body.append(quote);
+                    body.append("\n\n");
+                }
+                quotedParents.addAll(newQuotes);
                 body.append(item.body());
             }
 
             // For footers, we want to combine all unique fragments
             var footer = new StringBuilder();
@@ -219,19 +251,15 @@
                                                .collect(Collectors.toList());
                 footer.append(String.join("\n\n", newFooterFragments));
                 includedFooterFragments.addAll(newFooterFragments);
             }
 
-            // All items have the same parent and author after collapsing -> should have the same header
+            // All items have parents from the same author after collapsing -> should have the same header
             var firstItem = itemList.get(0);
             var header = firstItem.header();
-            var quote = quotedParent(firstItem, 2);
-            if (!quote.isBlank()) {
-                quote = quote + "\n\n";
-            }
 
-            var combined = (header.isBlank() ? "" : header +  "\n\n") + quote + body.toString() + (footer.length() == 0 ? "" : "\n\n-------------\n\n" + footer.toString());
+            var combined = (header.isBlank() ? "" : header +  "\n\n") + body.toString() + (footer.length() == 0 ? "" : "\n\n-------------\n\n" + footer.toString());
 
             var emailBuilder = Email.create(firstItem.subject(), combined);
             if (firstItem.parent().isPresent()) {
                 emailBuilder.reply(findArchiveItemEmail(firstItem.parent().get(), sentEmails, ret));
             }
diff a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
--- a/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
+++ b/bots/mlbridge/src/test/java/org/openjdk/skara/bots/mlbridge/MailingListBridgeBotTests.java
@@ -411,11 +411,11 @@
             listServer.processIncoming();
             listServer.processIncoming();
 
             // Make several file specific comments
             var first = pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Review comment");
-            pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Another review comment");
+            var second = pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Another review comment");
             pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Further review comment");
             pr.addReviewComment(masterHash, editHash, reviewFile.toString(), 2, "Final review comment");
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
@@ -441,12 +441,13 @@
             assertEquals(2, reviewReply.body().split("> This is now ready").length, reviewReply.body());
             assertEquals("RFR: This is a pull request", reviewReply.subject());
             assertTrue(reviewReply.body().contains("Review comment\n\n"), reviewReply.body());
             assertTrue(reviewReply.body().contains("Another review comment"), reviewReply.body());
 
-            // Now reply to the first (collapsed) comment
+            // Now reply to the first and second (collapsed) comment
             pr.addReviewCommentReply(first, "I agree");
+            pr.addReviewCommentReply(second, "Not with this one though");
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // The archive should contain a new entry
             Repository.materialize(archiveFolder.path(), archive.url(), "master");
@@ -643,11 +644,11 @@
             TestBotRunner.runPeriodicItems(mlBot);
             listServer.processIncoming();
 
             // Sanity check the archive
             Repository.materialize(archiveFolder.path(), archive.url(), "master");
-            assertEquals(3, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
+            assertEquals(2, archiveContainsCount(archiveFolder.path(), "^On.*wrote:"));
         }
     }
 
     @Test
     void reviewContext(TestInfo testInfo) throws IOException {

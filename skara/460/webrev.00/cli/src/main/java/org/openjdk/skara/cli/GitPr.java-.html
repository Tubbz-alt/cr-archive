<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 import org.openjdk.skara.version.Version;
  35 
  36 import java.io.IOException;
  37 import java.net.URI;
  38 import java.nio.charset.StandardCharsets;
  39 import java.nio.file.*;
  40 import java.util.*;
  41 import java.util.regex.Pattern;
  42 import java.util.concurrent.TimeUnit;
  43 import java.util.logging.Level;
  44 import java.util.regex.Matcher;
  45 import java.util.stream.Collectors;
  46 
  47 public class GitPr {
  48     private static final Pattern ISSUE_ID_PATTERN = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
  49     private static final Pattern ISSUE_MARKDOWN_PATTERN =
  50         Pattern.compile(&quot;^(?: \\* )?\\[([A-Z]+-[0-9]+)\\]\\(https:\\/\\/bugs.openjdk.java.net\\/browse\\/[A-Z]+-[0-9]+\\): .*$&quot;);
  51 
  52     private static void exit(String fmt, Object...args) {
  53         System.err.println(String.format(fmt, args));
  54         System.exit(1);
  55     }
  56 
  57     private static String gitConfig(String key) {
  58         try {
  59             var pb = new ProcessBuilder(&quot;git&quot;, &quot;config&quot;, key);
  60             pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
  61             pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  62             var p = pb.start();
  63 
  64             var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
  65             var res = p.waitFor();
  66             if (res != 0) {
  67                 return null;
  68             }
  69 
  70             return output == null ? null : output.replace(&quot;\n&quot;, &quot;&quot;);
  71         } catch (InterruptedException e) {
  72             return null;
  73         } catch (IOException e) {
  74             return null;
  75         }
  76     }
  77 
  78     private static String getOption(String name, Arguments arguments) {
  79         return getOption(name, null, arguments);
  80     }
  81 
  82     private static String getOption(String name, String subsection, Arguments arguments) {
  83         if (arguments.contains(name)) {
  84             return arguments.get(name).asString();
  85         }
  86 
  87         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
  88             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
  89             if (subsectionSpecific != null) {
  90                 return subsectionSpecific;
  91             }
  92         }
  93 
  94         return gitConfig(&quot;fork.&quot; + name);
  95     }
  96 
  97     private static boolean getSwitch(String name, Arguments arguments) {
  98         return getSwitch(name, null, arguments);
  99     }
 100 
 101     private static boolean getSwitch(String name, String subsection, Arguments arguments) {
 102         if (arguments.contains(name)) {
 103             return true;
 104         }
 105 
 106         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
 107             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
 108             if (subsectionSpecific != null) {
 109                 return subsectionSpecific.toLowerCase().equals(&quot;true&quot;);
 110             }
 111         }
 112 
 113         var sectionSpecific = gitConfig(&quot;fork.&quot; + name);
 114         return sectionSpecific != null &amp;&amp; sectionSpecific.toLowerCase().equals(&quot;true&quot;);
 115     }
 116 
 117     private static String rightPad(String s, int length) {
 118         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
 119     }
 120 
 121     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
 122         var end = &quot; --&gt;&quot;;
 123         var pad = 79 - end.length();
 124         var newLine = &quot;\n&quot;;
 125         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
 126     }
 127 
 128     private static String format(Issue issue) {
 129         var parts = issue.id().split(&quot;-&quot;);
 130         var id = parts.length == 2 ? parts[1] : issue.id();
 131         return id + &quot;: &quot; + issue.title();
 132     }
 133 
 134 
 135     private static String pullRequestIdArgument(ReadOnlyRepository repo, Arguments arguments) throws IOException {
 136         if (arguments.at(0).isPresent()) {
 137             return arguments.at(0).asString();
 138         }
 139 
 140         var currentBranch = repo.currentBranch();
 141         if (currentBranch.isPresent()) {
 142             var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 143             if (lines.size() == 1) {
 144                 return lines.get(0);
 145             }
 146         }
 147 
 148         exit(&quot;error: you must provide a pull request id&quot;);
 149         return null;
 150     }
 151 
 152     private static String statusForPullRequest(PullRequest pr) {
 153         var labels = pr.labels();
 154         if (pr.isDraft()) {
 155             return &quot;DRAFT&quot;;
 156         } else if (labels.contains(&quot;integrated&quot;)) {
 157             return &quot;INTEGRATED&quot;;
 158         } else if (labels.contains(&quot;ready&quot;)) {
 159             return &quot;READY&quot;;
 160         } else if (labels.contains(&quot;rfr&quot;)) {
 161             return &quot;RFR&quot;;
 162         } else if (labels.contains(&quot;outdated&quot;)) {
 163             return &quot;OUTDATED&quot;;
 164         } else if (labels.contains(&quot;oca&quot;)) {
 165             return &quot;OCA&quot;;
 166         } else {
 167             var checks = pr.checks(pr.headHash());
 168             var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
 169             if (jcheck.isPresent()) {
 170                 var checkStatus = jcheck.get().status();
 171                 if (checkStatus == CheckStatus.IN_PROGRESS) {
 172                     return &quot;CHECKING&quot;;
 173                 } else if (checkStatus == CheckStatus.SUCCESS) {
 174                     return &quot;RFR&quot;;
 175                 } else if (checkStatus == CheckStatus.FAILURE) {
 176                     return &quot;FAILURE&quot;;
 177                 }
 178             } else {
 179                 return &quot;CHECKING&quot;;
 180             }
 181         }
 182 
 183         return &quot;UNKNOWN&quot;;
 184     }
 185 
 186     private static String statusForCheck(Check check) {
 187         var checkStatus = check.status();
 188         if (checkStatus == CheckStatus.IN_PROGRESS) {
 189             return &quot;RUNNING&quot;;
 190         } else if (checkStatus == CheckStatus.SUCCESS) {
 191             return &quot;OK&quot;;
 192         } else if (checkStatus == CheckStatus.FAILURE) {
 193             return &quot;FAILED&quot;;
 194         } else if (checkStatus == CheckStatus.CANCELLED) {
 195             return &quot;CANCELLED&quot;;
 196         }
 197 
 198         return &quot;UNKNOWN&quot;;
 199     }
 200 
 201     private static List&lt;String&gt; issuesFromPullRequest(PullRequest pr) {
 202         var issueTitleIndex = -1;
 203         var lines = pr.body().split(&quot;\n&quot;);
 204         for (var i = 0; i &lt; lines.length; i++) {
 205             if (lines[i].startsWith(&quot;### Issue&quot;)) {
 206                 issueTitleIndex = i;
 207                 break;
 208             }
 209         }
 210 
 211         if (issueTitleIndex == -1) {
 212             return List.of();
 213         }
 214 
 215         var issues = new ArrayList&lt;String&gt;();
 216         for (var i = issueTitleIndex + 1; i &lt; lines.length; i++) {
 217             var m = ISSUE_MARKDOWN_PATTERN.matcher(lines[i]);
 218             if (m.matches()) {
 219                 issues.add(m.group(1));
 220             } else {
 221                 break;
 222             }
 223         }
 224 
 225         return issues;
 226     }
 227 
 228     private static String jbsProjectFromJcheckConf(Repository repo, String targetBranch) throws IOException {
 229         var conf = JCheckConfiguration.from(repo, repo.resolve(targetBranch).orElseThrow(() -&gt;
 230             new IOException(&quot;Could not resolve &#39;&quot; + targetBranch + &quot;&#39; branch&quot;)
 231         ));
 232 
 233         return conf.general().jbs();
 234     }
 235 
 236     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 237         var message = CommitMessageParsers.v1.parse(commit.message());
 238         var issues = message.issues();
 239         if (issues.isEmpty()) {
 240             return getIssue(message.title(), project);
 241         } else if (issues.size() == 1) {
 242             var issue = issues.get(0);
 243             return getIssue(issue.id(), project);
 244         }
 245         return Optional.empty();
 246     }
 247 
 248     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 249         return getIssue(b.name(), project);
 250     }
 251 
 252     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 253         var m = ISSUE_ID_PATTERN.matcher(s);
 254         if (m.matches()) {
 255             var id = m.group(2);
 256             if (project == null) {
 257                 project = m.group(1);
 258             }
 259             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 260             return issueTracker.project(project).issue(id);
 261         }
 262 
 263         return Optional.empty();
 264     }
 265 
 266     private static void await(Process p, Integer... allowedExitCodes) throws IOException {
 267         var allowed = new HashSet&lt;&gt;(Arrays.asList(allowedExitCodes));
 268         allowed.add(0);
 269         try {
 270             var res = p.waitFor();
 271 
 272             if (!allowed.contains(res)) {
 273                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 274             }
 275         } catch (InterruptedException e) {
 276             throw new IOException(e);
 277         }
 278     }
 279 
 280     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 281         String editor = null;
 282         var lines = repo.config(&quot;core.editor&quot;);
 283         if (lines.size() == 1) {
 284             editor = lines.get(0);
 285         }
 286         if (editor == null) {
 287             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 288         }
 289         if (editor == null) {
 290             editor = System.getenv(&quot;EDITOR&quot;);
 291         }
 292         if (editor == null) {
 293             editor = System.getenv(&quot;VISUAL&quot;);
 294         }
 295         if (editor == null) {
 296             editor = &quot;vi&quot;;
 297         }
 298 
 299         // As an editor command may have multiple arguments, we need to add each single one
 300         // to the ProcessBuilder. Arguments are split by whitespace and can be quoted.
 301         // e.g. I found core.editor =
 302         // \&quot;C:\\\\Program Files\\\\Notepad++\\\\notepad++.exe\&quot; -multiInst -notabbar -nosession -noPlugin
 303         List&lt;String&gt; editorParts = new ArrayList&lt;&gt;();
 304         Matcher em = Pattern.compile(&quot;\\s*([^\&quot;]\\S*|\&quot;.+?\&quot;)\\s*&quot;).matcher(editor);
 305         while (em.find()) {
 306             editorParts.add(em.group(1));
 307         }
 308         editorParts.add(file.toString());
 309         var pb = new ProcessBuilder(editorParts);
 310         pb.inheritIO();
 311         var p = pb.start();
 312         try {
 313             return p.waitFor() == 0;
 314         } catch (InterruptedException e) {
 315             throw new IOException(e);
 316         }
 317     }
 318 
 319     private static String projectName(URI uri) {
 320         var name = uri.getPath().toString().substring(1);
 321         if (name.endsWith(&quot;.git&quot;)) {
 322             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 323         }
 324         return name;
 325     }
 326 
 327     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 328         HostedRepository targetRepo = null;
 329 
 330         try {
 331             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 332             targetRepo = host.repository(projectName(upstream)).orElse(null);
 333         } catch (IOException e) {
 334             // do nothing
 335         }
 336 
 337         if (targetRepo == null) {
 338             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 339                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 340             );
 341             var parentRepo = remoteRepo.parent();
 342             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 343         }
 344 
 345         return targetRepo;
 346     }
 347 
 348     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 349         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 350         if (pr == null) {
 351             exit(&quot;error: could not fetch PR information&quot;);
 352         }
 353 
 354         return pr;
 355     }
 356 
 357     private static void show(String ref, Hash hash) throws IOException {
 358         show(ref, hash, null);
 359     }
 360     private static void show(String ref, Hash hash, Path dir) throws IOException {
 361         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 362                                                    &quot;--patch&quot;,
 363                                                    &quot;--find-renames=50%&quot;,
 364                                                    &quot;--find-copies=50%&quot;,
 365                                                    &quot;--find-copies-harder&quot;,
 366                                                    &quot;--abbrev&quot;,
 367                                                    ref + &quot;...&quot; + hash.hex());
 368         if (dir != null) {
 369             pb.directory(dir.toFile());
 370         }
 371         pb.inheritIO();
 372 
 373         // git will return 141 (128 + 13) when it receive SIGPIPE (signal 13) from
 374         // e.g. less when a user exits less when looking at a large diff. Therefore
 375         // must allow 141 as a valid exit code.
 376         await(pb.start(), 141);
 377     }
 378 
 379     private static Path diff(String ref, Hash hash) throws IOException {
 380         return diff(ref, hash, null);
 381     }
 382 
 383     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 384         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 385         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 386                                                    &quot;--patch&quot;,
 387                                                    &quot;--find-renames=50%&quot;,
 388                                                    &quot;--find-copies=50%&quot;,
 389                                                    &quot;--find-copies-harder&quot;,
 390                                                    &quot;--abbrev&quot;,
 391                                                    ref + &quot;...&quot; + hash.hex());
 392         if (dir != null) {
 393             pb.directory(dir.toFile());
 394         }
 395         pb.redirectOutput(patch.toFile());
 396         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 397         await(pb.start());
 398         return patch;
 399     }
 400 
 401     private static void apply(Path patch) throws IOException {
 402         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 403         pb.inheritIO();
 404         await(pb.start());
 405     }
 406 
 407     private static int longest(List&lt;String&gt; strings) {
 408         return strings.stream().mapToInt(String::length).max().orElse(0);
 409     }
 410 
 411     private static String removeTrailing(String s, String trail) {
 412         return s.endsWith(trail) ?
 413             s.substring(0, s.length() - trail.length()) :
 414             s;
 415     }
 416 
 417     private static Repository getRepo() throws IOException {
 418         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 419         return Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 420     }
 421 
 422     private static Arguments parse(ArgumentParser parser, String[] args) {
 423         var arguments = parser.parse(args);
 424         if (arguments.contains(&quot;version&quot;)) {
 425             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 426             System.exit(0);
 427         }
 428         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 429             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 430             Logging.setup(level);
 431         }
 432         return arguments;
 433     }
 434 
 435     private static String getRemote(ReadOnlyRepository repo, Arguments arguments) throws IOException {
 436         var remote = getOption(&quot;remote&quot;, arguments);
 437         return remote == null ? &quot;origin&quot; : remote;
 438     }
 439 
 440     private static URI getURI(ReadOnlyRepository repo, Arguments arguments) throws IOException {
 441         var remotePullPath = repo.pullPath(getRemote(repo, arguments));
 442         return Remote.toWebURI(remotePullPath);
 443     }
 444 
 445     private static Forge getForge(URI uri, ReadOnlyRepository repo, Arguments arguments) throws IOException {
 446         var username = getOption(&quot;username&quot;, arguments);
 447         var token = System.getenv(&quot;GIT_TOKEN&quot;);
 448         var shouldUseToken = !getSwitch(&quot;no-token&quot;, arguments);
 449         var credentials = !shouldUseToken ?
 450             null :
 451             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 452         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 453         var forge = credentials == null ?
 454             Forge.from(forgeURI) :
 455             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 456         if (forge.isEmpty()) {
 457             if (!shouldUseToken) {
 458                 if (arguments.contains(&quot;verbose&quot;)) {
 459                     System.err.println(&quot;&quot;);
 460                 }
 461                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 462                 if (!arguments.contains(&quot;verbose&quot;)) {
 463                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 464                     System.err.println(&quot;&quot;);
 465                 }
 466             }
 467             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 468         }
 469         return forge.get();
 470     }
 471 
 472     private static void create(String[] args) throws IOException, InterruptedException {
 473         var flags = List.of(
 474             Option.shortcut(&quot;u&quot;)
 475                   .fullname(&quot;username&quot;)
 476                   .describe(&quot;NAME&quot;)
 477                   .helptext(&quot;Username on host&quot;)
 478                   .optional(),
 479             Option.shortcut(&quot;r&quot;)
 480                   .fullname(&quot;remote&quot;)
 481                   .describe(&quot;NAME&quot;)
 482                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 483                   .optional(),
 484             Option.shortcut(&quot;b&quot;)
 485                   .fullname(&quot;branch&quot;)
 486                   .describe(&quot;NAME&quot;)
 487                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 488                   .optional(),
 489             Switch.shortcut(&quot;&quot;)
 490                   .fullname(&quot;ignore-workspace&quot;)
 491                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 492                   .optional(),
 493             Switch.shortcut(&quot;&quot;)
 494                   .fullname(&quot;ignore-local-commits&quot;)
 495                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 496                   .optional(),
 497             Switch.shortcut(&quot;&quot;)
 498                   .fullname(&quot;publish&quot;)
 499                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 500                   .optional(),
 501             Switch.shortcut(&quot;&quot;)
 502                   .fullname(&quot;jcheck&quot;)
 503                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 504                   .optional(),
 505             Switch.shortcut(&quot;&quot;)
 506                   .fullname(&quot;verbose&quot;)
 507                   .helptext(&quot;Turn on verbose output&quot;)
 508                   .optional(),
 509             Switch.shortcut(&quot;&quot;)
 510                   .fullname(&quot;debug&quot;)
 511                   .helptext(&quot;Turn on debugging output&quot;)
 512                   .optional(),
 513             Switch.shortcut(&quot;&quot;)
 514                   .fullname(&quot;version&quot;)
 515                   .helptext(&quot;Print the version of this tool&quot;)
 516                   .optional()
 517         );
 518 
 519         var inputs = List.of(
 520             Input.position(0)
 521                  .describe(&quot;ID&quot;)
 522                  .singular()
 523                  .optional()
 524         );
 525 
 526         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 527         var arguments = parse(parser, args);
 528         var repo = getRepo();
 529         var uri = getURI(repo, arguments);
 530         var host = getForge(uri, repo, arguments);
 531         var remote = getRemote(repo, arguments);
 532         var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 533                 System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 534                 System.exit(1);
 535                 return null;
 536         });
 537         if (currentBranch.equals(repo.defaultBranch())) {
 538             System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 539             System.err.println(&quot;&quot;);
 540             System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 541             System.err.println(&quot;&quot;);
 542             System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 543             System.err.println(&quot;    git branch --force master origin/master&quot;);
 544             System.err.println(&quot;&quot;);
 545             System.exit(1);
 546         }
 547 
 548         var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
 549         if (!ignoreWorkspace) {
 550             var diff = repo.diff(repo.head());
 551             if (!diff.patches().isEmpty()) {
 552                 System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 553                 System.err.println(&quot;&quot;);
 554                 for (var patch : diff.patches()) {
 555                     var path = patch.target().path().isPresent() ?
 556                         patch.target().path().get() : patch.source().path().get();
 557                     System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 558                 }
 559                 System.err.println(&quot;&quot;);
 560                 System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 561                 System.err.println(&quot;&quot;);
 562                 System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 563                 System.err.println(&quot;&quot;);
 564                 System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 565                 System.err.println(&quot;&quot;);
 566                 System.err.println(&quot;    git stash&quot;);
 567                 System.err.println(&quot;&quot;);
 568                 System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 569                 System.exit(1);
 570             }
 571         }
 572 
 573         var upstream = repo.upstreamFor(currentBranch);
 574         if (upstream.isEmpty()) {
 575             var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);
 576             if (shouldPublish) {
 577                 GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 578                 upstream = repo.upstreamFor(currentBranch);
 579             } else {
 580                 System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 581                 System.err.println(&quot;&quot;);
 582                 System.err.println(&quot;A remote branch must be present at &quot; + uri + &quot; to create a pull request&quot;);
 583                 System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 584                 System.err.println(&quot;&quot;);
 585                 System.err.println(&quot;    git publish&quot;);
 586                 System.err.println(&quot;&quot;);
 587                 System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 588                 System.err.println(&quot;To update remote information for this repository, run:&quot;);
 589                 System.err.println(&quot;&quot;);
 590                 System.err.println(&quot;    git fetch &quot; + remote);
 591                 System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 592                 System.err.println(&quot;&quot;);
 593                 System.exit(1);
 594             }
 595         }
 596 
 597         var upstreamRefName = upstream.get().substring(remote.length() + 1);
 598         repo.fetch(uri, upstreamRefName);
 599 
 600         var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
 601         if (!shouldIgnoreLocalCommits) {
 602             var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 603             if (!branchCommits.isEmpty()) {
 604                 System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + uri);
 605                 System.err.println(&quot;&quot;);
 606                 System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 607                 System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 608                 System.err.println(&quot;&quot;);
 609                 for (var commit : branchCommits) {
 610                     System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 611                 }
 612                 System.err.println(&quot;&quot;);
 613                 System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 614                 System.err.println(&quot;&quot;);
 615                 System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 616                 System.err.println(&quot;&quot;);
 617                 System.exit(1);
 618             }
 619         }
 620 
 621         var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 622                 new IOException(&quot;Could not find repository at &quot; + uri.toString())
 623         );
 624         var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 625                 new IOException(&quot;error: remote repository &quot; + uri + &quot; is not a fork of any repository&quot;)
 626         );
 627 
 628         var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
 629         if (targetBranch == null) {
 630             var upstreamBranchNames = repo.remoteBranches(parentRepo.webUrl().toString())
 631                                           .stream()
 632                                           .map(r -&gt; r.name())
 633                                           .collect(Collectors.toSet());
 634             var remoteBranches = repo.branches(remote);
 635             var candidates = new ArrayList&lt;Branch&gt;();
 636             for (var b : remoteBranches) {
 637                 var withoutRemotePrefix = b.name().substring(remote.length() + 1);
 638                 if (upstreamBranchNames.contains(withoutRemotePrefix)) {
 639                     candidates.add(b);
 640                 }
 641             }
 642 
 643             var localBranches = repo.branches();
 644             Branch closest = null;
 645             var shortestDistance = Integer.MAX_VALUE;
 646             for (var b : candidates) {
 647                 var from = b.name();
 648                 for (var localBranch : localBranches) {
 649                     var trackingBranch = repo.upstreamFor(localBranch);
 650                     if (trackingBranch.isPresent() &amp;&amp;
 651                         trackingBranch.get().equals(b.name())) {
 652                         from = localBranch.name();
 653                     }
 654                 }
 655                 var distance = repo.commitMetadata(from + &quot;...&quot; + currentBranch.name()).size();
 656                 if (distance &lt; shortestDistance) {
 657                     closest = b;
 658                     shortestDistance = distance;
 659                 }
 660             }
 661 
 662             if (closest != null) {
 663                 targetBranch = closest.name().substring(remote.length() + 1);
 664             } else {
 665                 System.err.println(&quot;error: cannot automatically infer target branch&quot;);
 666                 System.err.println(&quot;       use --branch to specify target branch&quot;);
 667                 System.exit(1);
 668             }
 669         }
 670         var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 671         if (commits.isEmpty()) {
 672             System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 673             System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 674             System.exit(1);
 675         }
 676 
 677         var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
 678         if (shouldRunJCheck) {
 679             var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 680             var err = GitJCheck.run(jcheckArgs);
 681             if (err != 0) {
 682                 System.exit(err);
 683             }
 684         }
 685 
 686         var project = jbsProjectFromJcheckConf(repo, targetBranch);
 687         var issue = getIssue(currentBranch, project);
 688         var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 689         if (issue.isPresent()) {
 690             Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 691         } else if (commits.size() == 1) {
 692             var commit = commits.get(0);
 693             issue = getIssue(commit, project);
 694             if (issue.isPresent()) {
 695                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 696             } else {
 697                 var message = CommitMessageParsers.v1.parse(commit.message());
 698                 Files.writeString(file, message.title() + &quot;\n&quot;);
 699                 if (!message.summaries().isEmpty()) {
 700                     Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 701                 }
 702                 if (!message.additional().isEmpty()) {
 703                     Files.write(file, message.additional(), StandardOpenOption.APPEND);
 704                 }
 705             }
 706         } else {
 707             Files.write(file, List.of(&quot;&quot;));
 708         }
 709 
 710         appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
 711         appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
 712         appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
 713         appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
 714         appendPaddedHTMLComment(file, &quot;&quot;);
 715         appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
 716         for (var commit : commits) {
 717             var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 718             appendPaddedHTMLComment(file, &quot;- &quot; + desc);
 719             if (!commit.isMerge()) {
 720                 var diff = commit.parentDiffs().get(0);
 721                 for (var patch : diff.patches()) {
 722                     var status = patch.status();
 723                     if (status.isModified()) {
 724                         appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
 725                     } else if (status.isAdded()) {
 726                         appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
 727                     } else if (status.isDeleted()) {
 728                         appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
 729                     } else if (status.isRenamed()) {
 730                         appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
 731                         appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 732                     } else if (status.isCopied()) {
 733                         appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
 734                         appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 735                     }
 736                 }
 737             }
 738         }
 739         appendPaddedHTMLComment(file, &quot;&quot;);
 740         if (issue.isPresent()) {
 741             appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
 742         }
 743         appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
 744         appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
 745 
 746         var success = spawnEditor(repo, file);
 747         if (!success) {
 748             System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 749             System.exit(1);
 750         }
 751         var lines = Files.readAllLines(file)
 752                          .stream()
 753                          .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
 754                          .collect(Collectors.toList());
 755         var isEmpty = lines.stream().allMatch(String::isEmpty);
 756         if (isEmpty) {
 757             System.err.println(&quot;error: no message present, aborting&quot;);
 758             System.exit(1);
 759         }
 760 
 761         var title = lines.get(0);
 762         List&lt;String&gt; body = null;
 763         if (lines.size() &gt; 1) {
 764             body = lines.subList(1, lines.size())
 765                         .stream()
 766                         .dropWhile(String::isEmpty)
 767                         .collect(Collectors.toList());
 768         } else {
 769             body = Collections.emptyList();
 770         }
 771 
 772         var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
 773         var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
 774         if (assigneesOption != null) {
 775             var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
 776             var assignees = usernames.stream()
 777                                      .map(u -&gt; host.user(u))
 778                                      .filter(Optional::isPresent)
 779                                      .map(Optional::get)
 780                                      .collect(Collectors.toList());
 781             pr.setAssignees(assignees);
 782         }
 783         System.out.println(pr.webUrl().toString());
 784         Files.deleteIfExists(file);
 785 
 786         repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
 787     }
 788 
 789     private static void integrate(String[] args) throws IOException, InterruptedException {
 790         var flags = List.of(
 791             Option.shortcut(&quot;u&quot;)
 792                   .fullname(&quot;username&quot;)
 793                   .describe(&quot;NAME&quot;)
 794                   .helptext(&quot;Username on host&quot;)
 795                   .optional(),
 796             Option.shortcut(&quot;r&quot;)
 797                   .fullname(&quot;remote&quot;)
 798                   .describe(&quot;NAME&quot;)
 799                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 800                   .optional(),
 801             Switch.shortcut(&quot;&quot;)
 802                   .fullname(&quot;atomic&quot;)
 803                   .helptext(&quot;Integrate the pull request atomically&quot;)
 804                   .optional(),
 805             Switch.shortcut(&quot;&quot;)
 806                   .fullname(&quot;verbose&quot;)
 807                   .helptext(&quot;Turn on verbose output&quot;)
 808                   .optional(),
 809             Switch.shortcut(&quot;&quot;)
 810                   .fullname(&quot;debug&quot;)
 811                   .helptext(&quot;Turn on debugging output&quot;)
 812                   .optional(),
 813             Switch.shortcut(&quot;&quot;)
 814                   .fullname(&quot;version&quot;)
 815                   .helptext(&quot;Print the version of this tool&quot;)
 816                   .optional()
 817         );
 818 
 819         var inputs = List.of(
 820             Input.position(0)
 821                  .describe(&quot;ID&quot;)
 822                  .singular()
 823                  .optional()
 824         );
 825 
 826         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 827         var arguments = parse(parser, args);
 828         var repo = getRepo();
 829         var uri = getURI(repo, arguments);
 830         var host = getForge(uri, repo, arguments);
 831         var id = pullRequestIdArgument(repo, arguments);
 832         var pr = getPullRequest(uri, repo, host, id);
 833         var isAtomic = getSwitch(&quot;atomic&quot;, &quot;integrate&quot;, arguments);
 834 
 835         var message = &quot;/integrate&quot;;
 836         if (isAtomic) {
 837             var targetHash = repo.resolve(pr.targetRef());
 838             if (!targetHash.isPresent()) {
 839                 exit(&quot;error: cannot resolve target branch &quot; + pr.targetRef());
 840             }
 841             var sourceHash = repo.fetch(pr.repository().webUrl(), pr.fetchRef());
 842             var mergeBase = repo.mergeBase(sourceHash, targetHash.get());
 843             message += &quot; &quot; + mergeBase.hex();
 844         }
 845 
 846         var integrateComment = pr.addComment(message);
 847 
 848         var seenIntegrateComment = false;
 849         var expected = &quot;&lt;!-- Jmerge command reply message (&quot; + integrateComment.id() + &quot;) --&gt;&quot;;
 850         for (var i = 0; i &lt; 90; i++) {
 851             var comments = pr.comments();
 852             for (var comment : comments) {
 853                 if (!seenIntegrateComment) {
 854                     if (comment.id().equals(integrateComment.id())) {
 855                         seenIntegrateComment = true;
 856                     }
 857                     continue;
 858                 }
 859                 var lines = comment.body().split(&quot;\n&quot;);
 860                 if (lines.length &gt; 0 &amp;&amp; lines[0].equals(expected)) {
 861                     for (var line : lines) {
 862                         if (line.startsWith(&quot;Pushed as commit&quot;)) {
 863                             var output = removeTrailing(line, &quot;.&quot;);
 864                             System.out.println(output);
 865                             System.exit(0);
 866                         }
 867                     }
 868                 }
 869             }
 870 
 871             Thread.sleep(2000);
 872         }
 873 
 874         System.err.println(&quot;error: timed out waiting for response to /integrate command&quot;);
 875         System.exit(1);
 876     }
 877 
 878     private static void test(String[] args) throws IOException, InterruptedException {
 879         var flags = List.of(
 880             Option.shortcut(&quot;u&quot;)
 881                   .fullname(&quot;username&quot;)
 882                   .describe(&quot;NAME&quot;)
 883                   .helptext(&quot;Username on host&quot;)
 884                   .optional(),
 885             Option.shortcut(&quot;r&quot;)
 886                   .fullname(&quot;remote&quot;)
 887                   .describe(&quot;NAME&quot;)
 888                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 889                   .optional(),
 890             Switch.shortcut(&quot;&quot;)
 891                   .fullname(&quot;verbose&quot;)
 892                   .helptext(&quot;Turn on verbose output&quot;)
 893                   .optional(),
 894             Switch.shortcut(&quot;&quot;)
 895                   .fullname(&quot;debug&quot;)
 896                   .helptext(&quot;Turn on debugging output&quot;)
 897                   .optional(),
 898             Switch.shortcut(&quot;&quot;)
 899                   .fullname(&quot;version&quot;)
 900                   .helptext(&quot;Print the version of this tool&quot;)
 901                   .optional()
 902         );
 903 
 904         var inputs = List.of(
 905             Input.position(0)
 906                  .describe(&quot;ID&quot;)
 907                  .singular()
 908                  .optional()
 909         );
 910         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 911         var arguments = parse(parser, args);
 912         var repo = getRepo();
 913         var uri = getURI(repo, arguments);
 914         var host = getForge(uri, repo, arguments);
 915         var id = pullRequestIdArgument(repo, arguments);
 916         var pr = getPullRequest(uri, repo, host, id);
 917         var head = pr.headHash();
 918         var testComment = pr.addComment(&quot;/test&quot;);
 919 
 920         var seenTestComment = false;
 921         for (var i = 0; i &lt; 90; i++) {
 922             var comments = pr.comments();
 923             for (var comment : comments) {
 924                 if (!seenTestComment) {
 925                     if (comment.id().equals(testComment.id())) {
 926                         seenTestComment = true;
 927                     }
 928                     continue;
 929                 }
 930                 var lines = comment.body().split(&quot;\n&quot;);
 931                 var n = lines.length;
 932                 if (n &gt; 0) {
 933                     if (n == 4 &amp;&amp;
 934                         lines[0].equals(&quot;&lt;!-- TEST STARTED --&gt;&quot;) &amp;&amp;
 935                         lines[1].startsWith(&quot;&lt;!-- github.com-&quot;) &amp;&amp;
 936                         lines[2].equals(&quot;&lt;!-- &quot; + head.hex() + &quot; --&gt;&quot;)) {
 937                         var output = removeTrailing(lines[3], &quot;.&quot;);
 938                         System.out.println(output);
 939                         System.exit(0);
 940                     } else if (n == 2 &amp;&amp;
 941                                lines[0].equals(&quot;&lt;!-- TEST ERROR --&gt;&quot;)) {
 942                         var output = removeTrailing(lines[1], &quot;.&quot;);
 943                         System.out.println(output);
 944                         System.exit(1);
 945                     } else if (n == 4 &amp;&amp;
 946                                lines[0].equals(&quot;&lt;!-- TEST PENDING --&gt;&quot;) &amp;&amp;
 947                                lines[1].equals(&quot;&lt;!--- &quot; + head.hex() + &quot; --&gt;&quot;)) {
 948                         var output = removeTrailing(lines[3], &quot;.&quot;);
 949                         System.out.println(output);
 950                         System.exit(0);
 951                     }
 952                 }
 953             }
 954 
 955             Thread.sleep(2000);
 956         }
 957     }
 958 
 959     private static void approve(String[] args) throws IOException, InterruptedException {
 960         var flags = List.of(
 961             Option.shortcut(&quot;u&quot;)
 962                   .fullname(&quot;username&quot;)
 963                   .describe(&quot;NAME&quot;)
 964                   .helptext(&quot;Username on host&quot;)
 965                   .optional(),
 966             Option.shortcut(&quot;r&quot;)
 967                   .fullname(&quot;remote&quot;)
 968                   .describe(&quot;NAME&quot;)
 969                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 970                   .optional(),
 971             Switch.shortcut(&quot;&quot;)
 972                   .fullname(&quot;verbose&quot;)
 973                   .helptext(&quot;Turn on verbose output&quot;)
 974                   .optional(),
 975             Switch.shortcut(&quot;&quot;)
 976                   .fullname(&quot;debug&quot;)
 977                   .helptext(&quot;Turn on debugging output&quot;)
 978                   .optional(),
 979             Switch.shortcut(&quot;&quot;)
 980                   .fullname(&quot;version&quot;)
 981                   .helptext(&quot;Print the version of this tool&quot;)
 982                   .optional()
 983         );
 984 
 985         var inputs = List.of(
 986             Input.position(0)
 987                  .describe(&quot;ID&quot;)
 988                  .singular()
 989                  .optional()
 990         );
 991         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 992         var arguments = parse(parser, args);
 993         var repo = getRepo();
 994         var uri = getURI(repo, arguments);
 995         var host = getForge(uri, repo, arguments);
 996         var id = pullRequestIdArgument(repo, arguments);
 997         var pr = getPullRequest(uri, repo, host, id);
 998         pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
 999     }
1000 
1001     private static void list(String[] args) throws IOException, InterruptedException {
1002         var flags = List.of(
1003             Option.shortcut(&quot;u&quot;)
1004                   .fullname(&quot;username&quot;)
1005                   .describe(&quot;NAME&quot;)
1006                   .helptext(&quot;Username on host&quot;)
1007                   .optional(),
1008             Option.shortcut(&quot;r&quot;)
1009                   .fullname(&quot;remote&quot;)
1010                   .describe(&quot;NAME&quot;)
1011                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1012                   .optional(),
1013             Option.shortcut(&quot;&quot;)
1014                   .fullname(&quot;authors&quot;)
1015                   .describe(&quot;LIST&quot;)
1016                   .helptext(&quot;Comma separated list of authors&quot;)
1017                   .optional(),
1018             Option.shortcut(&quot;&quot;)
1019                   .fullname(&quot;assignees&quot;)
1020                   .describe(&quot;LIST&quot;)
1021                   .helptext(&quot;Comma separated list of assignees&quot;)
1022                   .optional(),
1023             Option.shortcut(&quot;&quot;)
1024                   .fullname(&quot;labels&quot;)
1025                   .describe(&quot;LIST&quot;)
1026                   .helptext(&quot;Comma separated list of labels&quot;)
1027                   .optional(),
1028             Option.shortcut(&quot;&quot;)
1029                   .fullname(&quot;issues&quot;)
1030                   .describe(&quot;LIST&quot;)
1031                   .helptext(&quot;Comma separated list of issues&quot;)
1032                   .optional(),
1033             Option.shortcut(&quot;&quot;)
1034                   .fullname(&quot;columns&quot;)
1035                   .describe(&quot;id,title,author,assignees,labels&quot;)
1036                   .helptext(&quot;Comma separated list of columns to show&quot;)
1037                   .optional(),
1038             Switch.shortcut(&quot;&quot;)
1039                   .fullname(&quot;no-decoration&quot;)
1040                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
1041                   .optional(),
1042             Switch.shortcut(&quot;&quot;)
1043                   .fullname(&quot;no-draft&quot;)
1044                   .helptext(&quot;Hide all pull requests in draft state&quot;)
1045                   .optional(),
1046             Switch.shortcut(&quot;&quot;)
1047                   .fullname(&quot;no-token&quot;)
1048                   .helptext(&quot;Do not use a personal access token (PAT)&quot;)
1049                   .optional(),
1050             Switch.shortcut(&quot;&quot;)
1051                   .fullname(&quot;verbose&quot;)
1052                   .helptext(&quot;Turn on verbose output&quot;)
1053                   .optional(),
1054             Switch.shortcut(&quot;&quot;)
1055                   .fullname(&quot;debug&quot;)
1056                   .helptext(&quot;Turn on debugging output&quot;)
1057                   .optional(),
1058             Switch.shortcut(&quot;&quot;)
1059                   .fullname(&quot;version&quot;)
1060                   .helptext(&quot;Print the version of this tool&quot;)
1061                   .optional());
1062 
1063         var inputs = List.of(
1064             Input.position(0)
1065                  .describe(&quot;ID&quot;)
1066                  .singular()
1067                  .optional()
1068         );
1069 
1070         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1071         var arguments = parse(parser, args);
1072         var repo = getRepo();
1073         var uri = getURI(repo, arguments);
1074         var host = getForge(uri, repo, arguments);
1075         var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1076 
1077         var prs = remoteRepo.pullRequests();
1078         var ids = new ArrayList&lt;String&gt;();
1079         var titles = new ArrayList&lt;String&gt;();
1080         var authors = new ArrayList&lt;String&gt;();
1081         var assignees = new ArrayList&lt;String&gt;();
1082         var labels = new ArrayList&lt;String&gt;();
1083         var issues = new ArrayList&lt;String&gt;();
1084         var branches = new ArrayList&lt;String&gt;();
1085         var statuses = new ArrayList&lt;String&gt;();
1086         var noDraft = getSwitch(&quot;no-draft&quot;, &quot;list&quot;, arguments);
1087 
1088         var authorsOption = getOption(&quot;authors&quot;, &quot;list&quot;, arguments);
1089         var filterAuthors = authorsOption == null ?
1090             Set.of() :
1091             new HashSet&lt;&gt;(Arrays.asList(authorsOption.split(&quot;,&quot;)));
1092 
1093         var assigneesOption = getOption(&quot;assignees&quot;, &quot;list&quot;, arguments);
1094         var filterAssignees = assigneesOption == null ?
1095             Set.of() :
1096             Arrays.asList(assigneesOption.split(&quot;,&quot;));
1097 
1098         var labelsOption = getOption(&quot;labels&quot;, &quot;list&quot;, arguments);
1099         var filterLabels = labelsOption == null ?
1100             Set.of() :
1101             Arrays.asList(labelsOption.split(&quot;,&quot;));
1102 
1103         var issuesOption = getOption(&quot;issues&quot;, &quot;list&quot;, arguments);
1104         var filterIssues = issuesOption == null ?
1105             Set.of() :
1106             Arrays.asList(issuesOption.split(&quot;,&quot;));
1107 
1108         var columnTitles = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;, &quot;issues&quot;, &quot;branch&quot;, &quot;status&quot;);
1109         var columnValues = Map.of(columnTitles.get(0), ids,
1110                                   columnTitles.get(1), titles,
1111                                   columnTitles.get(2), authors,
1112                                   columnTitles.get(3), assignees,
1113                                   columnTitles.get(4), labels,
1114                                   columnTitles.get(5), issues,
1115                                   columnTitles.get(6), branches,
1116                                   columnTitles.get(7), statuses);
1117         var columnsOption = getOption(&quot;columns&quot;, &quot;list&quot;, arguments);
1118         var columns = columnsOption == null ?
1119             List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;status&quot;) :
1120             Arrays.asList(columnsOption.split(&quot;,&quot;));
1121 
1122         for (var column : columns) {
1123             if (!columnTitles.contains(column)) {
1124                 System.err.println(&quot;error: unknown column: &quot; + column);
1125                 System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, columnTitles));
1126                 System.exit(1);
1127             }
1128         }
1129 
1130         for (var pr : prs) {
1131             if (pr.isDraft() &amp;&amp; noDraft) {
1132                 continue;
1133             }
1134 
1135             var prAuthor = pr.author().userName();
1136             if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
1137                 continue;
1138             }
1139 
1140             var prAssignees = pr.assignees().stream()
1141                                 .map(HostUser::userName)
1142                                 .collect(Collectors.toSet());
1143             if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
1144                 continue;
1145             }
1146 
1147             var prLabels = new HashSet&lt;&gt;(pr.labels());
1148             if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
1149                 continue;
1150             }
1151 
1152             var prIssues = new HashSet&lt;&gt;(issuesFromPullRequest(pr));
1153             if (!filterIssues.isEmpty() &amp;&amp; !filterIssues.stream().anyMatch(prIssues::contains)) {
1154                 continue;
1155             }
1156 
1157 
1158             ids.add(pr.id());
1159             titles.add(pr.title());
1160             authors.add(prAuthor);
1161             assignees.add(String.join(&quot;,&quot;, prAssignees));
1162             labels.add(String.join(&quot;,&quot;, prLabels));
1163             issues.add(String.join(&quot;,&quot;, prIssues));
1164 
1165             if (pr.sourceRepository().webUrl().equals(uri)) {
1166                 branches.add(pr.sourceRef());
1167             } else {
1168                 branches.add(&quot;&quot;);
1169             }
1170 
1171             if (columns.contains(&quot;status&quot;)) {
1172                 statuses.add(statusForPullRequest(pr).toLowerCase());
1173             } else {
1174                 statuses.add(&quot;&quot;);
1175             }
1176         }
1177 
1178 
1179         String fmt = &quot;&quot;;
1180         for (var column : columns.subList(0, columns.size() - 1)) {
1181             var values = columnValues.get(column);
1182             var n = Math.max(column.length(), longest(values));
1183             fmt += &quot;%-&quot; + n + &quot;s    &quot;;
1184         }
1185         fmt += &quot;%s\n&quot;;
1186 
1187         var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;list&quot;, arguments);
1188         if (!ids.isEmpty() &amp;&amp; !noDecoration) {
1189             var upperCase = columns.stream()
1190                                    .map(String::toUpperCase)
1191                                    .collect(Collectors.toList());
1192             System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
1193         }
1194         for (var i = 0; i &lt; ids.size(); i++) {
1195             final int n = i;
1196             var row = columns.stream()
1197                              .map(columnValues::get)
1198                              .map(values -&gt; values.get(n))
1199                              .collect(Collectors.toList());
1200             System.out.format(fmt, (Object[]) row.toArray(new String[0]));
1201         }
1202     }
1203 
1204     private static void close(String[] args) throws IOException, InterruptedException {
1205         var flags = List.of(
1206             Option.shortcut(&quot;u&quot;)
1207                   .fullname(&quot;username&quot;)
1208                   .describe(&quot;NAME&quot;)
1209                   .helptext(&quot;Username on host&quot;)
1210                   .optional(),
1211             Option.shortcut(&quot;r&quot;)
1212                   .fullname(&quot;remote&quot;)
1213                   .describe(&quot;NAME&quot;)
1214                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1215                   .optional(),
1216             Switch.shortcut(&quot;&quot;)
1217                   .fullname(&quot;verbose&quot;)
1218                   .helptext(&quot;Turn on verbose output&quot;)
1219                   .optional(),
1220             Switch.shortcut(&quot;&quot;)
1221                   .fullname(&quot;debug&quot;)
1222                   .helptext(&quot;Turn on debugging output&quot;)
1223                   .optional(),
1224             Switch.shortcut(&quot;&quot;)
1225                   .fullname(&quot;version&quot;)
1226                   .helptext(&quot;Print the version of this tool&quot;)
1227                   .optional()
1228         );
1229 
1230         var inputs = List.of(
1231             Input.position(0)
1232                  .describe(&quot;ID&quot;)
1233                  .singular()
1234                  .optional()
1235         );
1236 
1237         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1238         var arguments = parse(parser, args);
1239         var repo = getRepo();
1240         var uri = getURI(repo, arguments);
1241         var host = getForge(uri, repo, arguments);
1242         var id = pullRequestIdArgument(repo, arguments);
1243         var pr = getPullRequest(uri, repo, host, id);
1244 
1245         pr.setState(PullRequest.State.CLOSED);
1246     }
1247 
1248     private static void set(String[] args) throws IOException, InterruptedException {
1249         var flags = List.of(
1250             Option.shortcut(&quot;u&quot;)
1251                   .fullname(&quot;username&quot;)
1252                   .describe(&quot;NAME&quot;)
1253                   .helptext(&quot;Username on host&quot;)
1254                   .optional(),
1255             Option.shortcut(&quot;r&quot;)
1256                   .fullname(&quot;remote&quot;)
1257                   .describe(&quot;NAME&quot;)
1258                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1259                   .optional(),
1260             Option.shortcut(&quot;&quot;)
1261                   .fullname(&quot;assignees&quot;)
1262                   .describe(&quot;LIST&quot;)
1263                   .helptext(&quot;Comma separated list of assignees&quot;)
1264                   .optional(),
1265             Switch.shortcut(&quot;&quot;)
1266                   .fullname(&quot;verbose&quot;)
1267                   .helptext(&quot;Turn on verbose output&quot;)
1268                   .optional(),
1269             Switch.shortcut(&quot;&quot;)
1270                   .fullname(&quot;debug&quot;)
1271                   .helptext(&quot;Turn on debugging output&quot;)
1272                   .optional(),
1273             Switch.shortcut(&quot;&quot;)
1274                   .fullname(&quot;version&quot;)
1275                   .helptext(&quot;Print the version of this tool&quot;)
1276                   .optional()
1277         );
1278 
1279         var inputs = List.of(
1280             Input.position(0)
1281                  .describe(&quot;ID&quot;)
1282                  .singular()
1283                  .optional()
1284         );
1285 
1286         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1287         var arguments = parse(parser, args);
1288         var repo = getRepo();
1289         var uri = getURI(repo, arguments);
1290         var host = getForge(uri, repo, arguments);
1291         var id = pullRequestIdArgument(repo, arguments);
1292         var pr = getPullRequest(uri, repo, host, id);
1293 
1294         var assigneesOption = getOption(&quot;assignees&quot;, &quot;set&quot;, arguments);
1295         if (assigneesOption != null) {
1296             var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1297             var assignees = usernames.stream()
1298                 .map(u -&gt; host.user(u))
1299                 .filter(Optional::isPresent)
1300                 .map(Optional::get)
1301                 .collect(Collectors.toList());
1302             pr.setAssignees(assignees);
1303         }
1304     }
1305 
1306     private static void status(String[] args) throws IOException, InterruptedException {
1307         var flags = List.of(
1308             Option.shortcut(&quot;u&quot;)
1309                   .fullname(&quot;username&quot;)
1310                   .describe(&quot;NAME&quot;)
1311                   .helptext(&quot;Username on host&quot;)
1312                   .optional(),
1313             Option.shortcut(&quot;r&quot;)
1314                   .fullname(&quot;remote&quot;)
1315                   .describe(&quot;NAME&quot;)
1316                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1317                   .optional(),
1318             Switch.shortcut(&quot;&quot;)
1319                   .fullname(&quot;no-decoration&quot;)
1320                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
1321                   .optional(),
1322             Switch.shortcut(&quot;&quot;)
1323                   .fullname(&quot;no-token&quot;)
1324                   .helptext(&quot;Do not use a personal access token (PAT)&quot;)
1325                   .optional(),
1326             Switch.shortcut(&quot;&quot;)
1327                   .fullname(&quot;no-checks&quot;)
1328                   .helptext(&quot;Do not show check status as part of the &#39;git pr status&#39; output&quot;)
1329                   .optional(),
1330             Switch.shortcut(&quot;&quot;)
1331                   .fullname(&quot;verbose&quot;)
1332                   .helptext(&quot;Turn on verbose output&quot;)
1333                   .optional(),
1334             Switch.shortcut(&quot;&quot;)
1335                   .fullname(&quot;debug&quot;)
1336                   .helptext(&quot;Turn on debugging output&quot;)
1337                   .optional(),
1338             Switch.shortcut(&quot;&quot;)
1339                   .fullname(&quot;version&quot;)
1340                   .helptext(&quot;Print the version of this tool&quot;)
1341                   .optional()
1342         );
1343 
1344         var inputs = List.of(
1345             Input.position(0)
1346                  .describe(&quot;ID&quot;)
1347                  .singular()
1348                  .optional()
1349         );
1350 
1351         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1352         var arguments = parse(parser, args);
1353         var repo = getRepo();
1354         var uri = getURI(repo, arguments);
1355         var host = getForge(uri, repo, arguments);
1356         var id = pullRequestIdArgument(repo, arguments);
1357         var pr = getPullRequest(uri, repo, host, id);
1358 
1359         var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;status&quot;, arguments);
1360         var decoration = noDecoration ? &quot;&quot; : &quot;Status: &quot;;
1361         System.out.println(decoration + statusForPullRequest(pr));
1362 
1363         var noChecks = getSwitch(&quot;no-checks&quot;, &quot;status&quot;, arguments);
1364         if (!noChecks) {
1365             var checks = pr.checks(pr.headHash());
1366             var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
1367             var submit = Optional.ofNullable(checks.get(&quot;submit&quot;));
1368             var showChecks = jcheck.isPresent() || submit.isPresent();
1369             if (showChecks) {
1370                 System.out.println(&quot;Checks:&quot;);
1371                 if (jcheck.isPresent()) {
1372                     System.out.println(&quot;- jcheck: &quot; + statusForCheck(jcheck.get()));
1373                 }
1374                 if (submit.isPresent()) {
1375                     System.out.println(&quot;- submit: &quot; + statusForCheck(submit.get()));
1376                 }
1377             }
1378         }
1379     }
1380 
1381     private static void fetch(String[] args) throws IOException, InterruptedException {
1382         var flags = List.of(
1383             Option.shortcut(&quot;u&quot;)
1384                   .fullname(&quot;username&quot;)
1385                   .describe(&quot;NAME&quot;)
1386                   .helptext(&quot;Username on host&quot;)
1387                   .optional(),
1388             Option.shortcut(&quot;r&quot;)
1389                   .fullname(&quot;remote&quot;)
1390                   .describe(&quot;NAME&quot;)
1391                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1392                   .optional(),
1393             Option.shortcut(&quot;b&quot;)
1394                   .fullname(&quot;branch&quot;)
1395                   .describe(&quot;NAME&quot;)
1396                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
1397                   .optional(),
1398             Switch.shortcut(&quot;&quot;)
1399                   .fullname(&quot;no-token&quot;)
1400                   .helptext(&quot;Do not use a personal access token (PAT)&quot;)
1401                   .optional(),
1402             Switch.shortcut(&quot;&quot;)
1403                   .fullname(&quot;verbose&quot;)
1404                   .helptext(&quot;Turn on verbose output&quot;)
1405                   .optional(),
1406             Switch.shortcut(&quot;&quot;)
1407                   .fullname(&quot;debug&quot;)
1408                   .helptext(&quot;Turn on debugging output&quot;)
1409                   .optional(),
1410             Switch.shortcut(&quot;&quot;)
1411                   .fullname(&quot;version&quot;)
1412                   .helptext(&quot;Print the version of this tool&quot;)
1413                   .optional()
1414         );
1415 
1416         var inputs = List.of(
1417             Input.position(0)
1418                  .describe(&quot;ID&quot;)
1419                  .singular()
1420                  .optional()
1421         );
1422 
1423         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1424         var arguments = parse(parser, args);
1425         var repo = getRepo();
1426         var uri = getURI(repo, arguments);
1427         var host = getForge(uri, repo, arguments);
1428         var id = pullRequestIdArgument(repo, arguments);
1429         var pr = getPullRequest(uri, repo, host, id);
1430 
1431         var fetchHead = repo.fetch(pr.repository().webUrl(), pr.fetchRef());
1432         var branchName = getOption(&quot;branch&quot;, &quot;fetch&quot;, arguments);
1433         if (branchName != null) {
1434             repo.branch(fetchHead, branchName);
1435         } else {
1436             System.out.println(fetchHead.hex());
1437         }
1438     }
1439 
1440     private static void show(String[] args) throws IOException, InterruptedException {
1441         var flags = List.of(
1442             Option.shortcut(&quot;u&quot;)
1443                   .fullname(&quot;username&quot;)
1444                   .describe(&quot;NAME&quot;)
1445                   .helptext(&quot;Username on host&quot;)
1446                   .optional(),
1447             Option.shortcut(&quot;r&quot;)
1448                   .fullname(&quot;remote&quot;)
1449                   .describe(&quot;NAME&quot;)
1450                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1451                   .optional(),
1452             Switch.shortcut(&quot;&quot;)
1453                   .fullname(&quot;no-token&quot;)
1454                   .helptext(&quot;Do not use a personal access token (PAT)&quot;)
1455                   .optional(),
1456             Switch.shortcut(&quot;&quot;)
1457                   .fullname(&quot;verbose&quot;)
1458                   .helptext(&quot;Turn on verbose output&quot;)
1459                   .optional(),
1460             Switch.shortcut(&quot;&quot;)
1461                   .fullname(&quot;debug&quot;)
1462                   .helptext(&quot;Turn on debugging output&quot;)
1463                   .optional(),
1464             Switch.shortcut(&quot;&quot;)
1465                   .fullname(&quot;version&quot;)
1466                   .helptext(&quot;Print the version of this tool&quot;)
1467                   .optional()
1468         );
1469 
1470         var inputs = List.of(
1471             Input.position(0)
1472                  .describe(&quot;ID&quot;)
1473                  .singular()
1474                  .optional()
1475         );
1476 
1477         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1478         var arguments = parse(parser, args);
1479         var repo = getRepo();
1480         var uri = getURI(repo, arguments);
1481         var host = getForge(uri, repo, arguments);
1482         var id = pullRequestIdArgument(repo, arguments);
1483         var pr = getPullRequest(uri, repo, host, id);
1484 
1485         var fetchHead = repo.fetch(pr.repository().webUrl(), pr.fetchRef());
1486         show(pr.targetRef(), fetchHead);
1487     }
1488 
1489     private static void checkout(String[] args) throws IOException, InterruptedException {
1490         var flags = List.of(
1491             Option.shortcut(&quot;u&quot;)
1492                   .fullname(&quot;username&quot;)
1493                   .describe(&quot;NAME&quot;)
1494                   .helptext(&quot;Username on host&quot;)
1495                   .optional(),
1496             Option.shortcut(&quot;r&quot;)
1497                   .fullname(&quot;remote&quot;)
1498                   .describe(&quot;NAME&quot;)
1499                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1500                   .optional(),
1501             Option.shortcut(&quot;b&quot;)
1502                   .fullname(&quot;branch&quot;)
1503                   .describe(&quot;NAME&quot;)
1504                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
1505                   .optional(),
1506             Switch.shortcut(&quot;&quot;)
1507                   .fullname(&quot;no-token&quot;)
1508                   .helptext(&quot;Do not use a personal access token (PAT)&quot;)
1509                   .optional(),
1510             Switch.shortcut(&quot;&quot;)
1511                   .fullname(&quot;verbose&quot;)
1512                   .helptext(&quot;Turn on verbose output&quot;)
1513                   .optional(),
1514             Switch.shortcut(&quot;&quot;)
1515                   .fullname(&quot;debug&quot;)
1516                   .helptext(&quot;Turn on debugging output&quot;)
1517                   .optional(),
1518             Switch.shortcut(&quot;&quot;)
1519                   .fullname(&quot;version&quot;)
1520                   .helptext(&quot;Print the version of this tool&quot;)
1521                   .optional()
1522         );
1523 
1524         var inputs = List.of(
1525             Input.position(0)
1526                  .describe(&quot;ID&quot;)
1527                  .singular()
1528                  .optional()
1529         );
1530 
1531         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1532         var arguments = parse(parser, args);
1533         var repo = getRepo();
1534         var uri = getURI(repo, arguments);
1535         var host = getForge(uri, repo, arguments);
1536         var id = pullRequestIdArgument(repo, arguments);
1537         var pr = getPullRequest(uri, repo, host, id);
1538 
1539         var fetchHead = repo.fetch(pr.repository().webUrl(), pr.fetchRef());
1540         var branchName = getOption(&quot;branch&quot;, &quot;checkout&quot;, arguments);
1541         if (branchName != null) {
1542             var branch = repo.branch(fetchHead, branchName);
1543             repo.checkout(branch, false);
1544         } else {
1545             repo.checkout(fetchHead, false);
1546         }
1547     }
1548 
1549     private static void apply(String[] args) throws IOException, InterruptedException {
1550         var flags = List.of(
1551             Option.shortcut(&quot;u&quot;)
1552                   .fullname(&quot;username&quot;)
1553                   .describe(&quot;NAME&quot;)
1554                   .helptext(&quot;Username on host&quot;)
1555                   .optional(),
1556             Option.shortcut(&quot;r&quot;)
1557                   .fullname(&quot;remote&quot;)
1558                   .describe(&quot;NAME&quot;)
1559                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
1560                   .optional(),
1561             Switch.shortcut(&quot;&quot;)
1562                   .fullname(&quot;no-token&quot;)
1563                   .helptext(&quot;Do not use a personal access token (PAT)&quot;)
1564                   .optional(),
1565             Switch.shortcut(&quot;&quot;)
1566                   .fullname(&quot;verbose&quot;)
1567                   .helptext(&quot;Turn on verbose output&quot;)
1568                   .optional(),
1569             Switch.shortcut(&quot;&quot;)
1570                   .fullname(&quot;debug&quot;)
1571                   .helptext(&quot;Turn on debugging output&quot;)
1572                   .optional(),
1573             Switch.shortcut(&quot;&quot;)
1574                   .fullname(&quot;version&quot;)
1575                   .helptext(&quot;Print the version of this tool&quot;)
1576                   .optional()
1577         );
1578 
1579         var inputs = List.of(
1580             Input.position(0)
1581                  .describe(&quot;ID&quot;)
1582                  .singular()
1583                  .optional()
1584         );
1585 
1586         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
1587         var arguments = parse(parser, args);
1588         var repo = getRepo();
1589         var uri = getURI(repo, arguments);
1590         var host = getForge(uri, repo, arguments);
1591         var id = pullRequestIdArgument(repo, arguments);
1592         var pr = getPullRequest(uri, repo, host, id);
1593 
1594         var fetchHead = repo.fetch(pr.repository().webUrl(), pr.fetchRef());
1595         var patch = diff(pr.targetRef(), fetchHead);
1596         apply(patch);
1597         Files.deleteIfExists(patch);
1598     }
1599 
1600     public static void main(String[] args) throws Exception {
1601         var commands = List.of(
1602                     Default.name(&quot;list&quot;)
1603                            .helptext(&quot;list open pull requests&quot;)
1604                            .main(GitPr::list),
1605                     Command.name(&quot;fetch&quot;)
1606                            .helptext(&quot;fetch a pull request&quot;)
1607                            .main(GitPr::fetch),
1608                     Command.name(&quot;show&quot;)
1609                            .helptext(&quot;show a pull request&quot;)
1610                            .main(GitPr::show),
1611                     Command.name(&quot;checkout&quot;)
1612                            .helptext(&quot;checkout a pull request&quot;)
1613                            .main(GitPr::checkout),
1614                     Command.name(&quot;apply&quot;)
1615                            .helptext(&quot;apply a pull request&quot;)
1616                            .main(GitPr::apply),
1617                     Command.name(&quot;integrate&quot;)
1618                            .helptext(&quot;integrate a pull request&quot;)
1619                            .main(GitPr::integrate),
1620                     Command.name(&quot;approve&quot;)
1621                            .helptext(&quot;approve a pull request&quot;)
1622                            .main(GitPr::approve),
1623                     Command.name(&quot;create&quot;)
1624                            .helptext(&quot;create a pull request&quot;)
1625                            .main(GitPr::create),
1626                     Command.name(&quot;close&quot;)
1627                            .helptext(&quot;close a pull request&quot;)
1628                            .main(GitPr::close),
1629                     Command.name(&quot;set&quot;)
1630                            .helptext(&quot;set properties of a pull request&quot;)
1631                            .main(GitPr::set),
1632                     Command.name(&quot;test&quot;)
1633                            .helptext(&quot;test a pull request&quot;)
1634                            .main(GitPr::test),
1635                     Command.name(&quot;status&quot;)
1636                            .helptext(&quot;show status of a pull request&quot;)
1637                            .main(GitPr::status)
1638         );
1639 
1640         HttpProxy.setup();
1641 
1642         var parser = new MultiCommandParser(&quot;git pr&quot;, commands);
1643         var command = parser.parse(args);
1644         command.execute();
1645     }
1646 }
    </pre>
  </body>
</html>
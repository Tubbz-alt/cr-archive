<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/java/org/openjdk/skara/jcheck/JCheckTests.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>jcheck/src/main/java/org/openjdk/skara/jcheck/JCheck.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 import org.openjdk.skara.vcs.*;
 28 import org.openjdk.skara.vcs.openjdk.CommitMessageParser;
 29 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 30 
 31 import java.io.*;
 32 import java.nio.file.Paths;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.*;
 36 import java.util.logging.Logger;
 37 
 38 public class JCheck {
 39     private final ReadOnlyRepository repository;
 40     private final Census census;
 41     private final CommitMessageParser parser;
 42     private final String revisionRange;
 43     private final Map&lt;String, Set&lt;Hash&gt;&gt; whitelist;
 44     private final List&lt;CommitCheck&gt; commitChecks;
 45     private final List&lt;RepositoryCheck&gt; repositoryChecks;
 46     private final List&lt;String&gt; additionalConfiguration;

 47     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.jcheck&quot;);
 48 
 49     private JCheckConfiguration cachedConfiguration = null;
 50 
 51     JCheck(ReadOnlyRepository repository,
 52            Census census,
 53            CommitMessageParser parser,
 54            String revisionRange,
 55            Pattern allowedBranches,
 56            Pattern allowedTags,
 57            Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
 58            Set&lt;Hash&gt; blacklist,
<span class="line-modified"> 59            List&lt;String&gt; additionalConfiguration) throws IOException {</span>

 60         this.repository = repository;
 61         this.census = census;
 62         this.parser = parser;
 63         this.revisionRange = revisionRange;
 64         this.whitelist = whitelist;
 65         this.additionalConfiguration = additionalConfiguration;

 66 
 67         var utils = new Utilities();
 68         commitChecks = List.of(
 69             new AuthorCheck(),
 70             new CommitterCheck(census),
 71             new WhitespaceCheck(),
 72             new MergeMessageCheck(),
 73             new HgTagCommitCheck(utils),
 74             new DuplicateIssuesCheck(repository),
 75             new ReviewersCheck(census, utils),
 76             new MessageCheck(utils),
 77             new IssuesCheck(utils),
 78             new ExecutableCheck(),
 79             new BlacklistCheck(blacklist)
 80         );
 81         repositoryChecks = List.of(
 82             new BranchesCheck(allowedBranches),
 83             new TagsCheck(allowedTags)
 84         );
 85     }
 86 
 87     private static Optional&lt;JCheckConfiguration&gt; parseConfiguration(ReadOnlyRepository r, Hash h, List&lt;String&gt; additionalConfiguration) {
 88         try {
 89             var content = new ArrayList&lt;&gt;(r.lines(Paths.get(&quot;.jcheck/conf&quot;), h).orElse(Collections.emptyList()));
 90             content.addAll(additionalConfiguration);
 91             if (content.size() == 0) {
 92                 return Optional.empty();
 93             }
 94             return Optional.of(JCheckConfiguration.parse(content));
 95         } catch (IOException e) {
 96             throw new UncheckedIOException(e);
 97         }
 98     }
 99 
100     private Optional&lt;JCheckConfiguration&gt; getConfigurationFor(Commit c) {



101         var confPath = Paths.get(&quot;.jcheck/conf&quot;);
102         var changesConfiguration = c.parentDiffs()
103                                     .stream()
104                                     .map(Diff::patches)
105                                     .flatMap(List::stream)
106                                     .anyMatch(p -&gt; p.source().path().isPresent() &amp;&amp; p.source().path().get().equals(confPath) ||
107                                                    p.target().path().isPresent() &amp;&amp; p.target().path().get().equals(confPath));
108 
109 
110         if (changesConfiguration || cachedConfiguration == null) {
111             var confAtCommit = parseConfiguration(repository, c.hash(), additionalConfiguration);
112             confAtCommit.ifPresent(jCheckConfiguration -&gt; cachedConfiguration = jCheckConfiguration);
113             return confAtCommit;
114         } else {
115             return Optional.of(cachedConfiguration);
116         }
117     }
118 
119     private Iterator&lt;Issue&gt; checkCommit(Commit commit) {
120         log.fine(&quot;Checking: &quot; + commit.hash().hex());
</pre>
<hr />
<pre>
206     }
207 
208     private Issues issues() throws IOException {
209         var commits = repository.commits(revisionRange);
210 
211         var repositoryIssues = repositoryIssues();
212         var commitIssues = commitIssues(commits);
213 
214         var errors = new ConcatIterator&lt;Issue&gt;(repositoryIssues, commitIssues);
215         return new Issues(errors, commits);
216     }
217 
218     private static Issues check(ReadOnlyRepository repository,
219                                 Census census,
220                                 CommitMessageParser parser,
221                                 String branchRegex,
222                                 String tagRegex,
223                                 String revisionRange,
224                                 Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
225                                 Set&lt;Hash&gt; blacklist,
<span class="line-modified">226                                 List&lt;String&gt; additionalConfiguration) throws IOException {</span>

227 
228         var defaultBranchRegex = &quot;|&quot; + repository.defaultBranch().name();
229         var allowedBranches = Pattern.compile(&quot;^(?:&quot; + branchRegex + defaultBranchRegex + &quot;)$&quot;);
230 
231         var defaultTag = repository.defaultTag();
232         var defaultTagRegex = defaultTag.isPresent() ? &quot;|&quot; + defaultTag.get().name() : &quot;&quot;;
233         var allowedTags = Pattern.compile(&quot;^(?:&quot; + tagRegex + defaultTagRegex + &quot;)$&quot;);
234 
<span class="line-modified">235         var jcheck = new JCheck(repository, census, parser, revisionRange, allowedBranches, allowedTags, whitelist, blacklist, additionalConfiguration);</span>
236         return jcheck.issues();
237     }
238 
239     public static Issues check(ReadOnlyRepository repository,
240                                Census census,
241                                CommitMessageParser parser,
<span class="line-modified">242                                String revisionRange,</span>
243                                Hash configuration,
<span class="line-removed">244                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,</span>
<span class="line-removed">245                                Set&lt;Hash&gt; blacklist,</span>
246                                List&lt;String&gt; additionalConfiguration) throws IOException {
247         if (repository.isEmpty()) {
248             return new Issues(new ArrayList&lt;Issue&gt;().iterator(), null);
249         }
250 
<span class="line-modified">251         var conf = parseConfiguration(repository, configuration, additionalConfiguration);</span>


252 
<span class="line-modified">253         var branchRegex = conf.isPresent() ?  conf.get().repository().branches() : &quot;.*&quot;;</span>
<span class="line-modified">254         var tagRegex =  conf.isPresent() ?  conf.get().repository().tags() : &quot;.*&quot;;</span>
255 
<span class="line-modified">256         return check(repository, census, parser, branchRegex, tagRegex, revisionRange, whitelist, blacklist, additionalConfiguration);</span>
257     }
258 
259     public static Issues check(ReadOnlyRepository repository,
260                                Census census,
261                                CommitMessageParser parser,
262                                String revisionRange,
<span class="line-removed">263                                Hash configuration,</span>
264                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
265                                Set&lt;Hash&gt; blacklist) throws IOException {
<span class="line-modified">266         return check(repository, census, parser, revisionRange, configuration, whitelist, blacklist, List.of());</span>
<span class="line-modified">267     }</span>

268 
<span class="line-removed">269     public static Issues check(ReadOnlyRepository repository,</span>
<span class="line-removed">270                                Census census,</span>
<span class="line-removed">271                                CommitMessageParser parser,</span>
<span class="line-removed">272                                String revisionRange) throws IOException {</span>
273         var master = repository.resolve(repository.defaultBranch().name())
274                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));
<span class="line-removed">275         var whitelist = new HashMap&lt;String, Set&lt;Hash&gt;&gt;();</span>
<span class="line-removed">276         var blacklist = new HashSet&lt;Hash&gt;();</span>
<span class="line-removed">277         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);</span>
<span class="line-removed">278     }</span>
279 
<span class="line-modified">280     public static Issues check(ReadOnlyRepository repository,</span>
<span class="line-modified">281                                Census census,</span>
<span class="line-modified">282                                CommitMessageParser parser,</span>
<span class="line-modified">283                                String revisionRange,</span>
<span class="line-modified">284                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,</span>
<span class="line-removed">285                                Set&lt;Hash&gt; blacklist) throws IOException {</span>
<span class="line-removed">286         var master = repository.resolve(repository.defaultBranch().name())</span>
<span class="line-removed">287                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));</span>
<span class="line-removed">288         return check(repository, census, parser, revisionRange, master, whitelist, blacklist);</span>
289     }
290 
291     public static Set&lt;Check&gt; checks(ReadOnlyRepository repository, Census census, Hash hash) throws IOException {
292         var jcheck = new JCheck(repository,
293                                 census,
294                                 CommitMessageParsers.v1,
295                                 hash.hex() + &quot;^..&quot; + hash.hex(),
296                                 Pattern.compile(&quot;.*&quot;),
297                                 Pattern.compile(&quot;.*&quot;),
298                                 new HashMap&lt;String, Set&lt;Hash&gt;&gt;(),
299                                 new HashSet&lt;Hash&gt;(),
<span class="line-modified">300                                 List.of());</span>

301         return jcheck.checksForCommits();
302     }
303 }
</pre>
</td>
<td>
<hr />
<pre>
 27 import org.openjdk.skara.vcs.*;
 28 import org.openjdk.skara.vcs.openjdk.CommitMessageParser;
 29 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
 30 
 31 import java.io.*;
 32 import java.nio.file.Paths;
 33 import java.util.*;
 34 import java.util.regex.Pattern;
 35 import java.util.stream.*;
 36 import java.util.logging.Logger;
 37 
 38 public class JCheck {
 39     private final ReadOnlyRepository repository;
 40     private final Census census;
 41     private final CommitMessageParser parser;
 42     private final String revisionRange;
 43     private final Map&lt;String, Set&lt;Hash&gt;&gt; whitelist;
 44     private final List&lt;CommitCheck&gt; commitChecks;
 45     private final List&lt;RepositoryCheck&gt; repositoryChecks;
 46     private final List&lt;String&gt; additionalConfiguration;
<span class="line-added"> 47     private final JCheckConfiguration overridingConfiguration;</span>
 48     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.jcheck&quot;);
 49 
 50     private JCheckConfiguration cachedConfiguration = null;
 51 
 52     JCheck(ReadOnlyRepository repository,
 53            Census census,
 54            CommitMessageParser parser,
 55            String revisionRange,
 56            Pattern allowedBranches,
 57            Pattern allowedTags,
 58            Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
 59            Set&lt;Hash&gt; blacklist,
<span class="line-modified"> 60            List&lt;String&gt; additionalConfiguration,</span>
<span class="line-added"> 61            JCheckConfiguration overridingConfiguration) throws IOException {</span>
 62         this.repository = repository;
 63         this.census = census;
 64         this.parser = parser;
 65         this.revisionRange = revisionRange;
 66         this.whitelist = whitelist;
 67         this.additionalConfiguration = additionalConfiguration;
<span class="line-added"> 68         this.overridingConfiguration = overridingConfiguration;</span>
 69 
 70         var utils = new Utilities();
 71         commitChecks = List.of(
 72             new AuthorCheck(),
 73             new CommitterCheck(census),
 74             new WhitespaceCheck(),
 75             new MergeMessageCheck(),
 76             new HgTagCommitCheck(utils),
 77             new DuplicateIssuesCheck(repository),
 78             new ReviewersCheck(census, utils),
 79             new MessageCheck(utils),
 80             new IssuesCheck(utils),
 81             new ExecutableCheck(),
 82             new BlacklistCheck(blacklist)
 83         );
 84         repositoryChecks = List.of(
 85             new BranchesCheck(allowedBranches),
 86             new TagsCheck(allowedTags)
 87         );
 88     }
 89 
 90     private static Optional&lt;JCheckConfiguration&gt; parseConfiguration(ReadOnlyRepository r, Hash h, List&lt;String&gt; additionalConfiguration) {
 91         try {
 92             var content = new ArrayList&lt;&gt;(r.lines(Paths.get(&quot;.jcheck/conf&quot;), h).orElse(Collections.emptyList()));
 93             content.addAll(additionalConfiguration);
 94             if (content.size() == 0) {
 95                 return Optional.empty();
 96             }
 97             return Optional.of(JCheckConfiguration.parse(content));
 98         } catch (IOException e) {
 99             throw new UncheckedIOException(e);
100         }
101     }
102 
103     private Optional&lt;JCheckConfiguration&gt; getConfigurationFor(Commit c) {
<span class="line-added">104         if (overridingConfiguration != null) {</span>
<span class="line-added">105             return Optional.of(overridingConfiguration);</span>
<span class="line-added">106         }</span>
107         var confPath = Paths.get(&quot;.jcheck/conf&quot;);
108         var changesConfiguration = c.parentDiffs()
109                                     .stream()
110                                     .map(Diff::patches)
111                                     .flatMap(List::stream)
112                                     .anyMatch(p -&gt; p.source().path().isPresent() &amp;&amp; p.source().path().get().equals(confPath) ||
113                                                    p.target().path().isPresent() &amp;&amp; p.target().path().get().equals(confPath));
114 
115 
116         if (changesConfiguration || cachedConfiguration == null) {
117             var confAtCommit = parseConfiguration(repository, c.hash(), additionalConfiguration);
118             confAtCommit.ifPresent(jCheckConfiguration -&gt; cachedConfiguration = jCheckConfiguration);
119             return confAtCommit;
120         } else {
121             return Optional.of(cachedConfiguration);
122         }
123     }
124 
125     private Iterator&lt;Issue&gt; checkCommit(Commit commit) {
126         log.fine(&quot;Checking: &quot; + commit.hash().hex());
</pre>
<hr />
<pre>
212     }
213 
214     private Issues issues() throws IOException {
215         var commits = repository.commits(revisionRange);
216 
217         var repositoryIssues = repositoryIssues();
218         var commitIssues = commitIssues(commits);
219 
220         var errors = new ConcatIterator&lt;Issue&gt;(repositoryIssues, commitIssues);
221         return new Issues(errors, commits);
222     }
223 
224     private static Issues check(ReadOnlyRepository repository,
225                                 Census census,
226                                 CommitMessageParser parser,
227                                 String branchRegex,
228                                 String tagRegex,
229                                 String revisionRange,
230                                 Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
231                                 Set&lt;Hash&gt; blacklist,
<span class="line-modified">232                                 List&lt;String&gt; additionalConfiguration,</span>
<span class="line-added">233                                 JCheckConfiguration configuration) throws IOException {</span>
234 
235         var defaultBranchRegex = &quot;|&quot; + repository.defaultBranch().name();
236         var allowedBranches = Pattern.compile(&quot;^(?:&quot; + branchRegex + defaultBranchRegex + &quot;)$&quot;);
237 
238         var defaultTag = repository.defaultTag();
239         var defaultTagRegex = defaultTag.isPresent() ? &quot;|&quot; + defaultTag.get().name() : &quot;&quot;;
240         var allowedTags = Pattern.compile(&quot;^(?:&quot; + tagRegex + defaultTagRegex + &quot;)$&quot;);
241 
<span class="line-modified">242         var jcheck = new JCheck(repository, census, parser, revisionRange, allowedBranches, allowedTags, whitelist, blacklist, additionalConfiguration, configuration);</span>
243         return jcheck.issues();
244     }
245 
246     public static Issues check(ReadOnlyRepository repository,
247                                Census census,
248                                CommitMessageParser parser,
<span class="line-modified">249                                Hash toCheck,</span>
250                                Hash configuration,


251                                List&lt;String&gt; additionalConfiguration) throws IOException {
252         if (repository.isEmpty()) {
253             return new Issues(new ArrayList&lt;Issue&gt;().iterator(), null);
254         }
255 
<span class="line-modified">256         var conf = parseConfiguration(repository, configuration, additionalConfiguration).orElseThrow(() -&gt;</span>
<span class="line-added">257             new IllegalArgumentException(&quot;No .jcheck/conf present at hash &quot; + configuration.hex())</span>
<span class="line-added">258         );</span>
259 
<span class="line-modified">260         var branchRegex = conf.repository().branches();</span>
<span class="line-modified">261         var tagRegex = conf.repository().tags();</span>
262 
<span class="line-modified">263         return check(repository, census, parser, branchRegex, tagRegex, repository.range(toCheck), Map.of(), Set.of(), List.of(), conf);</span>
264     }
265 
266     public static Issues check(ReadOnlyRepository repository,
267                                Census census,
268                                CommitMessageParser parser,
269                                String revisionRange,

270                                Map&lt;String, Set&lt;Hash&gt;&gt; whitelist,
271                                Set&lt;Hash&gt; blacklist) throws IOException {
<span class="line-modified">272         if (repository.isEmpty()) {</span>
<span class="line-modified">273             return new Issues(new ArrayList&lt;Issue&gt;().iterator(), null);</span>
<span class="line-added">274         }</span>
275 




276         var master = repository.resolve(repository.defaultBranch().name())
277                                .orElseThrow(() -&gt; new IllegalStateException(&quot;Default branch not found&quot;));




278 
<span class="line-modified">279         var conf = parseConfiguration(repository, master, List.of());</span>
<span class="line-modified">280         var branchRegex = conf.isPresent() ? conf.get().repository().branches() : &quot;.*&quot;;</span>
<span class="line-modified">281         var tagRegex = conf.isPresent() ? conf.get().repository().tags() : &quot;.*&quot;;</span>
<span class="line-modified">282 </span>
<span class="line-modified">283         return check(repository, census, parser, branchRegex, tagRegex, revisionRange, whitelist, blacklist, List.of(), null);</span>




284     }
285 
286     public static Set&lt;Check&gt; checks(ReadOnlyRepository repository, Census census, Hash hash) throws IOException {
287         var jcheck = new JCheck(repository,
288                                 census,
289                                 CommitMessageParsers.v1,
290                                 hash.hex() + &quot;^..&quot; + hash.hex(),
291                                 Pattern.compile(&quot;.*&quot;),
292                                 Pattern.compile(&quot;.*&quot;),
293                                 new HashMap&lt;String, Set&lt;Hash&gt;&gt;(),
294                                 new HashSet&lt;Hash&gt;(),
<span class="line-modified">295                                 List.of(),</span>
<span class="line-added">296                                 null);</span>
297         return jcheck.checksForCommits();
298     }
299 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../bots/pr/src/main/java/org/openjdk/skara/bots/pr/PullRequestInstance.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/java/org/openjdk/skara/jcheck/JCheckTests.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
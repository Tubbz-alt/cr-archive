diff a/bots/notify/build.gradle b/bots/notify/build.gradle
--- a/bots/notify/build.gradle
+++ b/bots/notify/build.gradle
@@ -25,10 +25,11 @@
     name = 'org.openjdk.skara.bots.notify'
     test {
         requires 'org.junit.jupiter.api'
         requires 'org.openjdk.skara.test'
         opens 'org.openjdk.skara.bots.notify' to 'org.junit.platform.commons'
+        opens 'org.openjdk.skara.bots.notify.mailinglist' to 'org.junit.platform.commons'
     }
 }
 
 dependencies {
     implementation project(':ci')
diff a/bots/notify/src/main/java/module-info.java b/bots/notify/src/main/java/module-info.java
--- a/bots/notify/src/main/java/module-info.java
+++ b/bots/notify/src/main/java/module-info.java
@@ -36,8 +36,8 @@
 
     uses org.openjdk.skara.bots.notify.NotifierFactory;
     provides org.openjdk.skara.bots.notify.NotifierFactory with
             org.openjdk.skara.bots.notify.issue.IssueUpdaterFactory,
             org.openjdk.skara.bots.notify.json.JsonUpdaterFactory,
-            org.openjdk.skara.bots.notify.mailinglist.MailingListUpdaterFactory,
+            org.openjdk.skara.bots.notify.mailinglist.MailingListNotifierFactory,
             org.openjdk.skara.bots.notify.slack.SlackUpdaterFactory;
 }
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifier.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifier.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifier.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.mailinglist;
+
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.email.*;
+import org.openjdk.skara.forge.*;
+import org.openjdk.skara.mailinglist.MailingList;
+import org.openjdk.skara.vcs.*;
+import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
+
+import java.io.*;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+import java.util.logging.Logger;
+import java.util.regex.Pattern;
+
+class MailingListNotifier implements RepositoryUpdateConsumer {
+    private final MailingList list;
+    private final EmailAddress recipient;
+    private final EmailAddress sender;
+    private final EmailAddress author;
+    private final boolean includeBranch;
+    private final boolean reportNewTags;
+    private final boolean reportNewBranches;
+    private final boolean reportNewBuilds;
+    private final Mode mode;
+    private final Map<String, String> headers;
+    private final Pattern allowedAuthorDomains;
+    private final Logger log = Logger.getLogger("org.openjdk.skara.bots.notify");
+
+    public enum Mode {
+        ALL,
+        PR
+    }
+
+    MailingListNotifier(MailingList list, EmailAddress recipient, EmailAddress sender, EmailAddress author,
+                       boolean includeBranch, boolean reportNewTags, boolean reportNewBranches, boolean reportNewBuilds,
+                       Mode mode, Map<String, String> headers, Pattern allowedAuthorDomains) {
+        this.list = list;
+        this.recipient = recipient;
+        this.sender = sender;
+        this.author = author;
+        this.includeBranch = includeBranch;
+        this.reportNewTags = reportNewTags;
+        this.reportNewBranches = reportNewBranches;
+        this.reportNewBuilds = reportNewBuilds;
+        this.mode = mode;
+        this.headers = headers;
+        this.allowedAuthorDomains = allowedAuthorDomains;
+    }
+
+    public static MailingListNotifierBuilder newBuilder() {
+        return new MailingListNotifierBuilder();
+    }
+
+    private String tagAnnotationToText(HostedRepository repository, Tag.Annotated annotation) {
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        printer.println("Tagged by: " + annotation.author().name() + " <" + annotation.author().email() + ">");
+        printer.println("Date:      " + annotation.date().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss +0000")));
+        printer.println();
+        printer.print(String.join("\n", annotation.message()));
+
+        return writer.toString();
+    }
+
+    private EmailAddress filteredAuthor(EmailAddress commitAddress) {
+        if (author != null) {
+            return author;
+        }
+        var allowedAuthorMatcher = allowedAuthorDomains.matcher(commitAddress.domain());
+        if (!allowedAuthorMatcher.matches()) {
+            return sender;
+        } else {
+            return commitAddress;
+        }
+    }
+
+    private EmailAddress commitToAuthor(Commit commit) {
+        return filteredAuthor(EmailAddress.from(commit.committer().name(), commit.committer().email()));
+    }
+
+    private EmailAddress annotationToAuthor(Tag.Annotated annotation) {
+        return filteredAuthor(EmailAddress.from(annotation.author().name(), annotation.author().email()));
+    }
+
+    private String commitsToSubject(HostedRepository repository, List<Commit> commits, Branch branch) {
+        var subject = new StringBuilder();
+        subject.append(repository.repositoryType().shortName());
+        subject.append(": ");
+        subject.append(repository.name());
+        subject.append(": ");
+        if (includeBranch) {
+            subject.append(branch.name());
+            subject.append(": ");
+        }
+        if (commits.size() > 1) {
+            subject.append(commits.size());
+            subject.append(" new changesets");
+        } else {
+            subject.append(commits.get(0).message().get(0));
+        }
+        return subject.toString();
+    }
+
+    private String tagToSubject(HostedRepository repository, Hash hash, Tag tag) {
+        return repository.repositoryType().shortName() +
+                ": " +
+                repository.name() +
+                ": Added tag " +
+                tag +
+                " for changeset " +
+                hash.abbreviate();
+    }
+
+    private List<Commit> filterPrCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
+        var ret = new ArrayList<Commit>();
+        var mergedHashes = new HashSet<Hash>();
+
+        for (var commit : commits) {
+            if (mergedHashes.contains(commit.hash())) {
+                log.info("Commit " + commit.hash() + " belongs to a merge PR - skipping");
+                continue;
+            }
+
+            var candidates = repository.findPullRequestsWithComment(null, "Pushed as commit " + commit.hash() + ".");
+            if (candidates.size() != 1) {
+                log.warning("Commit " + commit.hash() + " matches " + candidates.size() + " pull requests - expected 1");
+                ret.add(commit);
+                continue;
+            }
+
+            var candidate = candidates.get(0);
+            var prLink = candidate.webUrl();
+            if (!candidate.targetRef().equals(branch.name())) {
+                log.info("Pull request " + prLink + " targets " + candidate.targetRef() + " - commit is on " + branch.toString() + " - skipping");
+                ret.add(commit);
+                continue;
+            }
+
+            // For a merge PR, many other of these commits could belong here as well
+            try {
+                localRepository.fetch(repository.url(), candidate.fetchRef());
+                var baseHash = PullRequestUtils.baseHash(candidate, localRepository);
+                var prCommits = localRepository.commitMetadata(baseHash, candidate.headHash());
+                prCommits.forEach(prCommit -> mergedHashes.add(prCommit.hash()));
+            } catch (IOException e) {
+                log.warning("Could not fetch commits from " + prLink + " - cannot see if the belong to the PR");
+            }
+        }
+
+        return ret;
+    }
+
+    private void sendCombinedCommits(HostedRepository repository, List<Commit> commits, Branch branch) throws NonRetriableException {
+        if (commits.size() == 0) {
+            return;
+        }
+
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        for (var commit : commits) {
+            printer.println(CommitFormatters.toText(repository, commit));
+        }
+
+        var subject = commitsToSubject(repository, commits, branch);
+        var lastCommit = commits.get(commits.size() - 1);
+        var commitAddress = filteredAuthor(EmailAddress.from(lastCommit.committer().name(), lastCommit.committer().email()));
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .author(commitAddress)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, commits))
+                         .build();
+
+        try {
+            list.post(email);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    private Map<String, String> commitHeaders(HostedRepository repository, List<Commit> commits) {
+        var ret = new HashMap<String, String>();
+        ret.put("X-Git-URL", repository.webUrl().toString());
+        if (!commits.isEmpty()) {
+            ret.put("X-Git-Changeset", commits.get(0).hash().hex());
+        }
+        return ret;
+    }
+
+    @Override
+    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
+        if (mode == Mode.PR) {
+            commits = filterPrCommits(repository, localRepository, commits, branch);
+        }
+        sendCombinedCommits(repository, commits, branch);
+    }
+
+    @Override
+    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
+        if (!reportNewTags) {
+            return;
+        }
+        if (!reportNewBuilds) {
+            handleTagCommit(repository, localRepository, commits.get(commits.size() - 1), tag.tag(), annotation);
+            return;
+        }
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        var taggedCommit = commits.get(commits.size() - 1);
+        if (annotation != null) {
+            printer.println(tagAnnotationToText(repository, annotation));
+        }
+        printer.println(CommitFormatters.toTextBrief(repository, taggedCommit));
+
+        printer.println("The following commits are included in " + tag.tag());
+        printer.println("========================================================");
+        for (var commit : commits) {
+            printer.print(commit.hash().abbreviate());
+            if (commit.message().size() > 0) {
+                printer.print(": " + commit.message().get(0));
+            }
+            printer.println();
+        }
+
+        var subject = tagToSubject(repository, taggedCommit.hash(), tag.tag());
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, commits));
+
+        if (annotation != null) {
+            email.author(annotationToAuthor(annotation));
+        } else {
+            email.author(commitToAuthor(taggedCommit));
+        }
+
+        try {
+            list.post(email.build());
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    @Override
+    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) throws NonRetriableException {
+        if (!reportNewTags) {
+            return;
+        }
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        if (annotation != null) {
+            printer.println(tagAnnotationToText(repository, annotation));
+        }
+        printer.println(CommitFormatters.toTextBrief(repository, commit));
+
+        var subject = tagToSubject(repository, commit.hash(), tag);
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, List.of(commit)));
+
+        if (annotation != null) {
+            email.author(annotationToAuthor(annotation));
+        } else {
+            email.author(commitToAuthor(commit));
+        }
+
+        try {
+            list.post(email.build());
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    private String newBranchSubject(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
+        var subject = new StringBuilder();
+        subject.append(repository.repositoryType().shortName());
+        subject.append(": ");
+        subject.append(repository.name());
+        subject.append(": created branch ");
+        subject.append(branch);
+        subject.append(" based on the branch ");
+        subject.append(parent);
+        subject.append(" containing ");
+        subject.append(commits.size());
+        subject.append(" unique commit");
+        if (commits.size() != 1) {
+            subject.append("s");
+        }
+
+        return subject.toString();
+    }
+
+    @Override
+    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) throws NonRetriableException {
+        if (!reportNewBranches) {
+            return;
+        }
+        var writer = new StringWriter();
+        var printer = new PrintWriter(writer);
+
+        if (commits.size() > 0) {
+            printer.println("The following commits are unique to the " + branch.name() + " branch:");
+            printer.println("========================================================");
+            for (var commit : commits) {
+                printer.print(commit.hash().abbreviate());
+                if (commit.message().size() > 0) {
+                    printer.print(": " + commit.message().get(0));
+                }
+                printer.println();
+            }
+        } else {
+            printer.println("The new branch " + branch.name() + " is currently identical to the " + parent.name() + " branch.");
+        }
+
+        var subject = newBranchSubject(repository, localRepository, commits, parent, branch);
+        var finalAuthor = commits.size() > 0 ? commitToAuthor(commits.get(commits.size() - 1)) : sender;
+
+        var email = Email.create(subject, writer.toString())
+                         .sender(sender)
+                         .author(finalAuthor)
+                         .recipient(recipient)
+                         .headers(headers)
+                         .headers(commitHeaders(repository, commits))
+                         .build();
+        try {
+            list.post(email);
+        } catch (RuntimeException e) {
+            throw new NonRetriableException(e);
+        }
+    }
+
+    @Override
+    public String name() {
+        return "ml";
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierBuilder.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierBuilder.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierBuilder.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.mailinglist;
+
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.mailinglist.MailingList;
+
+import java.util.Map;
+import java.util.regex.Pattern;
+
+class MailingListNotifierBuilder {
+    private MailingList list;
+    private EmailAddress recipient;
+    private EmailAddress sender;
+    private EmailAddress author = null;
+    private boolean includeBranch = false;
+    private boolean reportNewTags = true;
+    private boolean reportNewBranches = true;
+    private boolean reportNewBuilds = true;
+    private MailingListNotifier.Mode mode = MailingListNotifier.Mode.ALL;
+    private Map<String, String> headers = Map.of();
+    private Pattern allowedAuthorDomains = Pattern.compile(".*");
+    private boolean repoInSubject = false;
+    private Pattern branchInSubject = Pattern.compile("a^"); // Does not match anything
+
+    public MailingListNotifierBuilder list(MailingList list) {
+        this.list = list;
+        return this;
+    }
+
+    public MailingListNotifierBuilder recipient(EmailAddress recipient) {
+        this.recipient = recipient;
+        return this;
+    }
+
+    public MailingListNotifierBuilder sender(EmailAddress sender) {
+        this.sender = sender;
+        return this;
+    }
+
+    public MailingListNotifierBuilder author(EmailAddress author) {
+        this.author = author;
+        return this;
+    }
+
+    public MailingListNotifierBuilder includeBranch(boolean includeBranch) {
+        this.includeBranch = includeBranch;
+        return this;
+    }
+
+    public MailingListNotifierBuilder reportNewTags(boolean reportNewTags) {
+        this.reportNewTags = reportNewTags;
+        return this;
+    }
+
+    public MailingListNotifierBuilder reportNewBranches(boolean reportNewBranches) {
+        this.reportNewBranches = reportNewBranches;
+        return this;
+    }
+
+    public MailingListNotifierBuilder reportNewBuilds(boolean reportNewBuilds) {
+        this.reportNewBuilds = reportNewBuilds;
+        return this;
+    }
+
+    public MailingListNotifierBuilder mode(MailingListNotifier.Mode mode) {
+        this.mode = mode;
+        return this;
+    }
+
+    public MailingListNotifierBuilder headers(Map<String, String> headers) {
+        this.headers = headers;
+        return this;
+    }
+
+    public MailingListNotifierBuilder allowedAuthorDomains(Pattern allowedAuthorDomains) {
+        this.allowedAuthorDomains = allowedAuthorDomains;
+        return this;
+    }
+
+    public MailingListNotifier build() {
+        return new MailingListNotifier(list, recipient, sender, author, includeBranch, reportNewTags, reportNewBranches,
+                                      reportNewBuilds, mode, headers, allowedAuthorDomains);
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierFactory.java
--- /dev/null
+++ b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierFactory.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.mailinglist;
+
+import org.openjdk.skara.bot.BotConfiguration;
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.email.EmailAddress;
+import org.openjdk.skara.json.JSONObject;
+import org.openjdk.skara.mailinglist.MailingListServerFactory;
+import org.openjdk.skara.network.URIBuilder;
+
+import java.time.Duration;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public class MailingListNotifierFactory implements NotifierFactory {
+    @Override
+    public String name() {
+        return "mailinglist";
+    }
+
+    @Override
+    public Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration) {
+        var smtp = notifierConfiguration.get("smtp").asString();
+        var sender = EmailAddress.parse(notifierConfiguration.get("sender").asString());
+        var archive = URIBuilder.base(notifierConfiguration.get("archive").asString()).build();
+        var interval = notifierConfiguration.contains("interval") ? Duration.parse(notifierConfiguration.get("interval").asString()) : Duration.ofSeconds(1);
+        var listServer = MailingListServerFactory.createMailmanServer(archive, smtp, interval);
+
+        var recipient = notifierConfiguration.get("recipient").asString();
+        var recipientAddress = EmailAddress.parse(recipient);
+
+        var author = notifierConfiguration.contains("author") ? EmailAddress.parse(notifierConfiguration.get("author").asString()) : null;
+        var allowedDomains = author == null ? Pattern.compile(notifierConfiguration.get("domains").asString()) : null;
+
+        var builder = MailingListNotifier.newBuilder()
+                                         .list(listServer.getList(recipient))
+                                         .recipient(recipientAddress)
+                                         .sender(sender)
+                                         .author(author)
+                                         .allowedAuthorDomains(allowedDomains);
+
+        if (notifierConfiguration.contains("mode")) {
+            MailingListNotifier.Mode mode;
+            switch (notifierConfiguration.get("mode").asString()) {
+                case "all":
+                    mode = MailingListNotifier.Mode.ALL;
+                    break;
+                case "pr":
+                    mode = MailingListNotifier.Mode.PR;
+                    break;
+                default:
+                    throw new RuntimeException("Unknown mode");
+            }
+            builder.mode(mode);
+        }
+        if (notifierConfiguration.contains("headers")) {
+            builder.headers(notifierConfiguration.get("headers")
+                                                 .fields()
+                                                 .stream()
+                                                 .collect(Collectors.toMap(JSONObject.Field::name,
+                                                                           field -> field.value().asString())));
+        }
+        if (notifierConfiguration.contains("branchnames")) {
+            builder.includeBranch(notifierConfiguration.get("branchnames").asBoolean());
+        }
+        if (notifierConfiguration.contains("tags")) {
+            builder.reportNewTags(notifierConfiguration.get("tags").asBoolean());
+        }
+        if (notifierConfiguration.contains("branches")) {
+            builder.reportNewBranches(notifierConfiguration.get("branches").asBoolean());
+        }
+        if (notifierConfiguration.contains("builds")) {
+            builder.reportNewBuilds(notifierConfiguration.get("builds").asBoolean());
+        }
+
+        return builder.build();
+    }
+}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdater.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdater.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdater.java
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify.mailinglist;
-
-import org.openjdk.skara.bots.notify.*;
-import org.openjdk.skara.email.*;
-import org.openjdk.skara.forge.*;
-import org.openjdk.skara.mailinglist.MailingList;
-import org.openjdk.skara.vcs.*;
-import org.openjdk.skara.vcs.openjdk.OpenJDKTag;
-
-import java.io.*;
-import java.time.format.DateTimeFormatter;
-import java.util.*;
-import java.util.logging.Logger;
-import java.util.regex.Pattern;
-
-public class MailingListUpdater implements RepositoryUpdateConsumer {
-    private final MailingList list;
-    private final EmailAddress recipient;
-    private final EmailAddress sender;
-    private final EmailAddress author;
-    private final boolean includeBranch;
-    private final boolean reportNewTags;
-    private final boolean reportNewBranches;
-    private final boolean reportNewBuilds;
-    private final Mode mode;
-    private final Map<String, String> headers;
-    private final Pattern allowedAuthorDomains;
-    private final Logger log = Logger.getLogger("org.openjdk.skara.bots.notify");
-
-    public enum Mode {
-        ALL,
-        PR
-    }
-
-    MailingListUpdater(MailingList list, EmailAddress recipient, EmailAddress sender, EmailAddress author,
-                       boolean includeBranch, boolean reportNewTags, boolean reportNewBranches, boolean reportNewBuilds,
-                       Mode mode, Map<String, String> headers, Pattern allowedAuthorDomains) {
-        this.list = list;
-        this.recipient = recipient;
-        this.sender = sender;
-        this.author = author;
-        this.includeBranch = includeBranch;
-        this.reportNewTags = reportNewTags;
-        this.reportNewBranches = reportNewBranches;
-        this.reportNewBuilds = reportNewBuilds;
-        this.mode = mode;
-        this.headers = headers;
-        this.allowedAuthorDomains = allowedAuthorDomains;
-    }
-
-    public static MailingListUpdaterBuilder newBuilder() {
-        return new MailingListUpdaterBuilder();
-    }
-
-    private String tagAnnotationToText(HostedRepository repository, Tag.Annotated annotation) {
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        printer.println("Tagged by: " + annotation.author().name() + " <" + annotation.author().email() + ">");
-        printer.println("Date:      " + annotation.date().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss +0000")));
-        printer.println();
-        printer.print(String.join("\n", annotation.message()));
-
-        return writer.toString();
-    }
-
-    private EmailAddress filteredAuthor(EmailAddress commitAddress) {
-        if (author != null) {
-            return author;
-        }
-        var allowedAuthorMatcher = allowedAuthorDomains.matcher(commitAddress.domain());
-        if (!allowedAuthorMatcher.matches()) {
-            return sender;
-        } else {
-            return commitAddress;
-        }
-    }
-
-    private EmailAddress commitToAuthor(Commit commit) {
-        return filteredAuthor(EmailAddress.from(commit.committer().name(), commit.committer().email()));
-    }
-
-    private EmailAddress annotationToAuthor(Tag.Annotated annotation) {
-        return filteredAuthor(EmailAddress.from(annotation.author().name(), annotation.author().email()));
-    }
-
-    private String commitsToSubject(HostedRepository repository, List<Commit> commits, Branch branch) {
-        var subject = new StringBuilder();
-        subject.append(repository.repositoryType().shortName());
-        subject.append(": ");
-        subject.append(repository.name());
-        subject.append(": ");
-        if (includeBranch) {
-            subject.append(branch.name());
-            subject.append(": ");
-        }
-        if (commits.size() > 1) {
-            subject.append(commits.size());
-            subject.append(" new changesets");
-        } else {
-            subject.append(commits.get(0).message().get(0));
-        }
-        return subject.toString();
-    }
-
-    private String tagToSubject(HostedRepository repository, Hash hash, Tag tag) {
-        return repository.repositoryType().shortName() +
-                ": " +
-                repository.name() +
-                ": Added tag " +
-                tag +
-                " for changeset " +
-                hash.abbreviate();
-    }
-
-    private List<Commit> filterPrCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        var ret = new ArrayList<Commit>();
-        var mergedHashes = new HashSet<Hash>();
-
-        for (var commit : commits) {
-            if (mergedHashes.contains(commit.hash())) {
-                log.info("Commit " + commit.hash() + " belongs to a merge PR - skipping");
-                continue;
-            }
-
-            var candidates = repository.findPullRequestsWithComment(null, "Pushed as commit " + commit.hash() + ".");
-            if (candidates.size() != 1) {
-                log.warning("Commit " + commit.hash() + " matches " + candidates.size() + " pull requests - expected 1");
-                ret.add(commit);
-                continue;
-            }
-
-            var candidate = candidates.get(0);
-            var prLink = candidate.webUrl();
-            if (!candidate.targetRef().equals(branch.name())) {
-                log.info("Pull request " + prLink + " targets " + candidate.targetRef() + " - commit is on " + branch.toString() + " - skipping");
-                ret.add(commit);
-                continue;
-            }
-
-            // For a merge PR, many other of these commits could belong here as well
-            try {
-                localRepository.fetch(repository.url(), candidate.fetchRef());
-                var baseHash = PullRequestUtils.baseHash(candidate, localRepository);
-                var prCommits = localRepository.commitMetadata(baseHash, candidate.headHash());
-                prCommits.forEach(prCommit -> mergedHashes.add(prCommit.hash()));
-            } catch (IOException e) {
-                log.warning("Could not fetch commits from " + prLink + " - cannot see if the belong to the PR");
-            }
-        }
-
-        return ret;
-    }
-
-    private void sendCombinedCommits(HostedRepository repository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        if (commits.size() == 0) {
-            return;
-        }
-
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        for (var commit : commits) {
-            printer.println(CommitFormatters.toText(repository, commit));
-        }
-
-        var subject = commitsToSubject(repository, commits, branch);
-        var lastCommit = commits.get(commits.size() - 1);
-        var commitAddress = filteredAuthor(EmailAddress.from(lastCommit.committer().name(), lastCommit.committer().email()));
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .author(commitAddress)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, commits))
-                         .build();
-
-        try {
-            list.post(email);
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    private Map<String, String> commitHeaders(HostedRepository repository, List<Commit> commits) {
-        var ret = new HashMap<String, String>();
-        ret.put("X-Git-URL", repository.webUrl().toString());
-        if (!commits.isEmpty()) {
-            ret.put("X-Git-Changeset", commits.get(0).hash().hex());
-        }
-        return ret;
-    }
-
-    @Override
-    public void handleCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch branch) throws NonRetriableException {
-        if (mode == Mode.PR) {
-            commits = filterPrCommits(repository, localRepository, commits, branch);
-        }
-        sendCombinedCommits(repository, commits, branch);
-    }
-
-    @Override
-    public void handleOpenJDKTagCommits(HostedRepository repository, Repository localRepository, List<Commit> commits, OpenJDKTag tag, Tag.Annotated annotation) throws NonRetriableException {
-        if (!reportNewTags) {
-            return;
-        }
-        if (!reportNewBuilds) {
-            handleTagCommit(repository, localRepository, commits.get(commits.size() - 1), tag.tag(), annotation);
-            return;
-        }
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        var taggedCommit = commits.get(commits.size() - 1);
-        if (annotation != null) {
-            printer.println(tagAnnotationToText(repository, annotation));
-        }
-        printer.println(CommitFormatters.toTextBrief(repository, taggedCommit));
-
-        printer.println("The following commits are included in " + tag.tag());
-        printer.println("========================================================");
-        for (var commit : commits) {
-            printer.print(commit.hash().abbreviate());
-            if (commit.message().size() > 0) {
-                printer.print(": " + commit.message().get(0));
-            }
-            printer.println();
-        }
-
-        var subject = tagToSubject(repository, taggedCommit.hash(), tag.tag());
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, commits));
-
-        if (annotation != null) {
-            email.author(annotationToAuthor(annotation));
-        } else {
-            email.author(commitToAuthor(taggedCommit));
-        }
-
-        try {
-            list.post(email.build());
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    @Override
-    public void handleTagCommit(HostedRepository repository, Repository localRepository, Commit commit, Tag tag, Tag.Annotated annotation) throws NonRetriableException {
-        if (!reportNewTags) {
-            return;
-        }
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        if (annotation != null) {
-            printer.println(tagAnnotationToText(repository, annotation));
-        }
-        printer.println(CommitFormatters.toTextBrief(repository, commit));
-
-        var subject = tagToSubject(repository, commit.hash(), tag);
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, List.of(commit)));
-
-        if (annotation != null) {
-            email.author(annotationToAuthor(annotation));
-        } else {
-            email.author(commitToAuthor(commit));
-        }
-
-        try {
-            list.post(email.build());
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    private String newBranchSubject(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) {
-        var subject = new StringBuilder();
-        subject.append(repository.repositoryType().shortName());
-        subject.append(": ");
-        subject.append(repository.name());
-        subject.append(": created branch ");
-        subject.append(branch);
-        subject.append(" based on the branch ");
-        subject.append(parent);
-        subject.append(" containing ");
-        subject.append(commits.size());
-        subject.append(" unique commit");
-        if (commits.size() != 1) {
-            subject.append("s");
-        }
-
-        return subject.toString();
-    }
-
-    @Override
-    public void handleNewBranch(HostedRepository repository, Repository localRepository, List<Commit> commits, Branch parent, Branch branch) throws NonRetriableException {
-        if (!reportNewBranches) {
-            return;
-        }
-        var writer = new StringWriter();
-        var printer = new PrintWriter(writer);
-
-        if (commits.size() > 0) {
-            printer.println("The following commits are unique to the " + branch.name() + " branch:");
-            printer.println("========================================================");
-            for (var commit : commits) {
-                printer.print(commit.hash().abbreviate());
-                if (commit.message().size() > 0) {
-                    printer.print(": " + commit.message().get(0));
-                }
-                printer.println();
-            }
-        } else {
-            printer.println("The new branch " + branch.name() + " is currently identical to the " + parent.name() + " branch.");
-        }
-
-        var subject = newBranchSubject(repository, localRepository, commits, parent, branch);
-        var finalAuthor = commits.size() > 0 ? commitToAuthor(commits.get(commits.size() - 1)) : sender;
-
-        var email = Email.create(subject, writer.toString())
-                         .sender(sender)
-                         .author(finalAuthor)
-                         .recipient(recipient)
-                         .headers(headers)
-                         .headers(commitHeaders(repository, commits))
-                         .build();
-        try {
-            list.post(email);
-        } catch (RuntimeException e) {
-            throw new NonRetriableException(e);
-        }
-    }
-
-    @Override
-    public String name() {
-        return "ml";
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterBuilder.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterBuilder.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterBuilder.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify.mailinglist;
-
-import org.openjdk.skara.email.EmailAddress;
-import org.openjdk.skara.mailinglist.MailingList;
-
-import java.util.Map;
-import java.util.regex.Pattern;
-
-public class MailingListUpdaterBuilder {
-    private MailingList list;
-    private EmailAddress recipient;
-    private EmailAddress sender;
-    private EmailAddress author = null;
-    private boolean includeBranch = false;
-    private boolean reportNewTags = true;
-    private boolean reportNewBranches = true;
-    private boolean reportNewBuilds = true;
-    private MailingListUpdater.Mode mode = MailingListUpdater.Mode.ALL;
-    private Map<String, String> headers = Map.of();
-    private Pattern allowedAuthorDomains = Pattern.compile(".*");
-    private boolean repoInSubject = false;
-    private Pattern branchInSubject = Pattern.compile("a^"); // Does not match anything
-
-    public MailingListUpdaterBuilder list(MailingList list) {
-        this.list = list;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder recipient(EmailAddress recipient) {
-        this.recipient = recipient;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder sender(EmailAddress sender) {
-        this.sender = sender;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder author(EmailAddress author) {
-        this.author = author;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder includeBranch(boolean includeBranch) {
-        this.includeBranch = includeBranch;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder reportNewTags(boolean reportNewTags) {
-        this.reportNewTags = reportNewTags;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder reportNewBranches(boolean reportNewBranches) {
-        this.reportNewBranches = reportNewBranches;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder reportNewBuilds(boolean reportNewBuilds) {
-        this.reportNewBuilds = reportNewBuilds;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder mode(MailingListUpdater.Mode mode) {
-        this.mode = mode;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder headers(Map<String, String> headers) {
-        this.headers = headers;
-        return this;
-    }
-
-    public MailingListUpdaterBuilder allowedAuthorDomains(Pattern allowedAuthorDomains) {
-        this.allowedAuthorDomains = allowedAuthorDomains;
-        return this;
-    }
-
-    public MailingListUpdater build() {
-        return new MailingListUpdater(list, recipient, sender, author, includeBranch, reportNewTags, reportNewBranches,
-                                      reportNewBuilds, mode, headers, allowedAuthorDomains);
-    }
-}
diff a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterFactory.java b/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterFactory.java
--- a/bots/notify/src/main/java/org/openjdk/skara/bots/notify/mailinglist/MailingListUpdaterFactory.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify.mailinglist;
-
-import org.openjdk.skara.bot.BotConfiguration;
-import org.openjdk.skara.bots.notify.*;
-import org.openjdk.skara.email.EmailAddress;
-import org.openjdk.skara.json.JSONObject;
-import org.openjdk.skara.mailinglist.MailingListServerFactory;
-import org.openjdk.skara.network.URIBuilder;
-
-import java.time.Duration;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-
-public class MailingListUpdaterFactory implements NotifierFactory {
-    @Override
-    public String name() {
-        return "mailinglist";
-    }
-
-    @Override
-    public Notifier create(BotConfiguration botConfiguration, JSONObject notifierConfiguration) {
-        var smtp = notifierConfiguration.get("smtp").asString();
-        var sender = EmailAddress.parse(notifierConfiguration.get("sender").asString());
-        var archive = URIBuilder.base(notifierConfiguration.get("archive").asString()).build();
-        var interval = notifierConfiguration.contains("interval") ? Duration.parse(notifierConfiguration.get("interval").asString()) : Duration.ofSeconds(1);
-        var listServer = MailingListServerFactory.createMailmanServer(archive, smtp, interval);
-
-        var recipient = notifierConfiguration.get("recipient").asString();
-        var recipientAddress = EmailAddress.parse(recipient);
-
-        var author = notifierConfiguration.contains("author") ? EmailAddress.parse(notifierConfiguration.get("author").asString()) : null;
-        var allowedDomains = author == null ? Pattern.compile(notifierConfiguration.get("domains").asString()) : null;
-
-        var mailingListUpdaterBuilder = MailingListUpdater.newBuilder()
-                                                          .list(listServer.getList(recipient))
-                                                          .recipient(recipientAddress)
-                                                          .sender(sender)
-                                                          .author(author)
-                                                          .allowedAuthorDomains(allowedDomains);
-
-        if (notifierConfiguration.contains("mode")) {
-            MailingListUpdater.Mode mode;
-            switch (notifierConfiguration.get("mode").asString()) {
-                case "all":
-                    mode = MailingListUpdater.Mode.ALL;
-                    break;
-                case "pr":
-                    mode = MailingListUpdater.Mode.PR;
-                    break;
-                default:
-                    throw new RuntimeException("Unknown mode");
-            }
-            mailingListUpdaterBuilder.mode(mode);
-        }
-        if (notifierConfiguration.contains("headers")) {
-            mailingListUpdaterBuilder.headers(notifierConfiguration.get("headers").fields().stream()
-                                                                   .collect(Collectors.toMap(JSONObject.Field::name,
-                                                                           field -> field.value().asString())));
-        }
-        if (notifierConfiguration.contains("branchnames")) {
-            mailingListUpdaterBuilder.includeBranch(notifierConfiguration.get("branchnames").asBoolean());
-        }
-        if (notifierConfiguration.contains("tags")) {
-            mailingListUpdaterBuilder.reportNewTags(notifierConfiguration.get("tags").asBoolean());
-        }
-        if (notifierConfiguration.contains("branches")) {
-            mailingListUpdaterBuilder.reportNewBranches(notifierConfiguration.get("branches").asBoolean());
-        }
-        if (notifierConfiguration.contains("builds")) {
-            mailingListUpdaterBuilder.reportNewBuilds(notifierConfiguration.get("builds").asBoolean());
-        }
-
-        return mailingListUpdaterBuilder.build();
-    }
-}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/MailingListUpdaterTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/MailingListUpdaterTests.java
--- a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/MailingListUpdaterTests.java
+++ /dev/null
@@ -1,975 +0,0 @@
-/*
- * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package org.openjdk.skara.bots.notify;
-
-import org.junit.jupiter.api.*;
-import org.openjdk.skara.bots.notify.mailinglist.MailingListUpdater;
-import org.openjdk.skara.email.*;
-import org.openjdk.skara.mailinglist.MailingListServerFactory;
-import org.openjdk.skara.test.*;
-
-import java.io.IOException;
-import java.time.Duration;
-import java.util.*;
-import java.util.regex.Pattern;
-
-import static org.junit.jupiter.api.Assertions.*;
-import static org.openjdk.skara.bots.notify.UpdaterTests.*;
-
-public class MailingListUpdaterTests {
-    @Test
-    void testMailingList(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .allowedAuthorDomains(Pattern.compile("none"))
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(sender, email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.subject().contains(": 23456789: More fixes"));
-            assertFalse(email.subject().contains("master"));
-            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertFalse(email.body().contains("Committer"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-            assertTrue(email.hasHeader("extra1"));
-            assertEquals("value1", email.headerValue("extra1"));
-            assertTrue(email.hasHeader("extra2"));
-            assertEquals("value2", email.headerValue("extra2"));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash.hex(), email.headerValue("X-Git-Changeset"));
-        }
-    }
-
-    @Test
-    void testMailingListMultiple(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
-                    "first_author", "first@author.example.com");
-            localRepo.push(editHash1, repo.url(), "master");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes",
-                    "another_author", "another@author.example.com");
-            localRepo.push(editHash2, repo.url(), "master");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(EmailAddress.from("another_author", "another@author.example.com"), email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.subject().contains(": 2 new changesets"));
-            assertFalse(email.subject().contains("master"));
-            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
-            assertTrue(email.body().contains("3456789A: Even more fixes"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
-        }
-    }
-
-    @Test
-    void testMailingListSponsored(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
-                    "author", "author@test.test",
-                    "committer", "committer@test.test");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(EmailAddress.from("committer", "committer@test.test"), email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertTrue(email.body().contains("Author:    author <author@test.test>"));
-            assertTrue(email.body().contains("Committer: committer <committer@test.test>"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-        }
-    }
-
-    @Test
-    void testMailingListMultipleBranches(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            var branch = localRepo.branch(masterHash, "another");
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var author = EmailAddress.from("author", "author@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .author(author)
-                                            .includeBranch(true)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|another"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash1, repo.url(), "master");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes");
-            localRepo.push(editHash2, repo.url(), "master");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(author, email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertFalse(email.subject().contains("another"));
-            assertTrue(email.subject().contains(": master: 2 new changesets"));
-            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
-            assertTrue(email.body().contains("23456789: More fixes"));
-            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
-            assertTrue(email.body().contains("3456789A: Even more fixes"));
-            assertFalse(email.body().contains(masterHash.abbreviate()));
-            assertFalse(email.body().contains("456789AB: Yet more fixes"));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
-
-            localRepo.checkout(branch, true);
-            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another branch", "456789AB: Yet more fixes");
-            localRepo.push(editHash3, repo.url(), "another");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            conversations = mailmanList.conversations(Duration.ofDays(1));
-            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
-            email = conversations.get(0).first();
-            assertEquals(author, email.author());
-            assertEquals(listAddress, email.sender());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertTrue(email.subject().contains(": another: 456789AB: Yet more fixes"));
-            assertFalse(email.subject().contains("master"));
-            assertTrue(email.body().contains("Changeset: " + editHash3.abbreviate()));
-            assertTrue(email.body().contains("456789AB: Yet more fixes"));
-            assertFalse(email.body().contains("Changeset: " + editHash2.abbreviate()));
-            assertFalse(email.body().contains("3456789A: Even more fixes"));
-            assertTrue(email.hasHeader("X-Git-URL"));
-            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
-            assertTrue(email.hasHeader("X-Git-Changeset"));
-            assertEquals(editHash3.hex(), email.headerValue("X-Git-Changeset"));
-        }
-    }
-
-    @Test
-    void testMailingListPROnlyMultipleBranches(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var author = EmailAddress.from("author", "author@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .author(author)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .includeBranch(true)
-                                            .mode(MailingListUpdater.Mode.PR)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|other"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // Populate our known branches
-            localRepo.push(masterHash, repo.url(), "master", true);
-            localRepo.push(masterHash, repo.url(), "other", true);
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            localRepo.checkout(masterHash, true);
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "edit");
-            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
-
-            // PR hasn't been integrated yet, so there should be no mail
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Simulate an RFR email
-            var rfr = Email.create(sender, "RFR: My PR", "PR: " + pr.webUrl().toString())
-                           .recipient(listAddress)
-                           .build();
-            mailmanList.post(rfr);
-            listServer.processIncoming();
-
-            // And an integration (but it hasn't reached master just yet)
-            pr.addComment("Pushed as commit " + editHash.hex() + ".");
-
-            // Now push the same commit to another branch
-            localRepo.push(editHash, repo.url(), "other");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            // This one should generate a plain integration mail
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(2, conversations.size());
-            var secondEmail = conversations.get(0).first();
-            if (secondEmail.subject().contains("RFR")) {
-                secondEmail = conversations.get(1).first();
-            }
-            assertEquals("git: test: other: 23456789: More fixes", secondEmail.subject());
-        }
-    }
-
-    @Test
-    void testMailingListPR(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .mode(MailingListUpdater.Mode.PR)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "edit");
-            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
-
-            // Create a potentially conflicting one
-            var otherHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(otherHash, repo.url(), "other");
-            var otherPr = credentials.createPullRequest(repo, "master", "other", "RFR: My other PR");
-
-            // PR hasn't been integrated yet, so there should be no mail
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Simulate an RFR email
-            var rfr = Email.create("[repo/branch] RFR: My PR", "PR:\n" + pr.webUrl().toString())
-                           .author(EmailAddress.from("duke", "duke@duke.duke"))
-                           .recipient(listAddress)
-                           .build();
-            mailmanList.post(rfr);
-            listServer.processIncoming();
-
-            // And an integration
-            pr.addComment("Pushed as commit " + editHash.hex() + ".");
-            localRepo.push(editHash, repo.url(), "master");
-
-            // Push the other one without a matching PR
-            localRepo.push(otherHash, repo.url(), "master");
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
-            assertEquals(2, conversations.size());
-
-            var prConversation = conversations.get(0);
-            var pushConversation = conversations.get(1);
-            assertEquals(1, prConversation.allMessages().size());
-
-            var pushEmail = pushConversation.first();
-            assertEquals(listAddress, pushEmail.sender());
-            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
-            assertEquals(pushEmail.recipients(), List.of(listAddress));
-            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
-        }
-    }
-
-    @Test
-    void testMailingListPROnce(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            localRepo.branch(masterHash, "other");
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .author(null)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .mode(MailingListUpdater.Mode.PR)
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|other"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            localRepo.checkout(masterHash, true);
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "edit");
-            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
-
-            // PR hasn't been integrated yet, so there should be no mail
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Simulate an RFR email
-            var rfr = Email.create("RFR: My PR", "PR:\n" + pr.webUrl().toString())
-                           .author(EmailAddress.from("duke", "duke@duke.duke"))
-                           .recipient(listAddress)
-                           .build();
-            mailmanList.post(rfr);
-            listServer.processIncoming();
-
-            // And an integration
-            pr.addComment("Pushed as commit " + editHash.hex() + ".");
-            localRepo.push(editHash, repo.url(), "master", true);
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(1, conversations.size());
-
-            var prConversation = conversations.get(0);
-            assertEquals(1, prConversation.allMessages().size());
-
-            // Now push the change to another monitored branch
-            localRepo.push(editHash, repo.url(), "other", true);
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            // The change should now end up as a separate notification thread
-            conversations = mailmanList.conversations(Duration.ofDays(1));
-            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
-            assertEquals(2, conversations.size());
-
-            var pushConversation = conversations.get(1);
-            var pushEmail = pushConversation.first();
-            assertEquals(listAddress, pushEmail.sender());
-            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
-            assertEquals(pushEmail.recipients(), List.of(listAddress));
-            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
-        }
-    }
-
-    @Test
-    void testMailinglistTag(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory();
-             var listServer = new TestMailmanServer()) {
-            var repo = credentials.getHostedRepository();
-            var localRepoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewBranches(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .build();
-            var noTagsUpdater = MailingListUpdater.newBuilder()
-                                                  .list(mailmanList)
-                                                  .recipient(listAddress)
-                                                  .sender(sender)
-                                                  .reportNewTags(false)
-                                                  .reportNewBranches(false)
-                                                  .reportNewBuilds(false)
-                                                  .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater, noTagsUpdater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.fetch(repo.url(), "history:history");
-            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
-            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
-            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
-            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(4, conversations.size());
-
-            for (var conversation : conversations) {
-                var email = conversation.first();
-                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
-                    assertTrue(email.body().contains("23456789: More fixes"));
-                    assertFalse(email.body().contains("34567890: Even more fixes"));
-                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
-                    assertFalse(email.body().contains("56789012: Still even more fixes"));
-                    assertFalse(email.body().contains("67890123: Brand new fixes"));
-                    assertFalse(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
-                    assertFalse(email.body().contains("23456789: More fixes"));
-                    assertTrue(email.body().contains("34567890: Even more fixes"));
-                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
-                    assertTrue(email.body().contains("56789012: Still even more fixes"));
-                    assertFalse(email.body().contains("67890123: Brand new fixes"));
-                    assertFalse(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
-                    assertFalse(email.body().contains("23456789: More fixes"));
-                    assertFalse(email.body().contains("34567890: Even more fixes"));
-                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
-                    assertFalse(email.body().contains("56789012: Still even more fixes"));
-                    assertFalse(email.body().contains("67890123: Brand new fixes"));
-                    assertTrue(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: 6 new changesets")) {
-                    assertTrue(email.body().contains("23456789: More fixes"));
-                    assertTrue(email.body().contains("34567890: Even more fixes"));
-                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
-                    assertTrue(email.body().contains("56789012: Still even more fixes"));
-                    assertTrue(email.body().contains("67890123: Brand new fixes"));
-                    assertTrue(email.body().contains("78901234: More brand new fixes"));
-                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
-                } else {
-                    fail("Mismatched subject: " + email.subject());
-                }
-                assertTrue(email.hasHeader("extra1"));
-                assertEquals("value1", email.headerValue("extra1"));
-                assertTrue(email.hasHeader("extra2"));
-                assertEquals("value2", email.headerValue("extra2"));
-            }
-        }
-    }
-
-    @Test
-    void testMailinglistPlainTags(TestInfo testInfo) throws IOException {
-        try (var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory();
-             var listServer = new TestMailmanServer()) {
-            var repo = credentials.getHostedRepository();
-            var localRepoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
-            credentials.commitLock(localRepo);
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .build();
-            var noTagsUpdater = MailingListUpdater.newBuilder()
-                                                  .list(mailmanList)
-                                                  .recipient(listAddress)
-                                                  .sender(sender)
-                                                  .reportNewTags(false)
-                                                  .reportNewBranches(false)
-                                                  .reportNewBuilds(false)
-                                                  .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater, noTagsUpdater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.fetch(repo.url(), "history:history");
-            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
-            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
-            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
-            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
-            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
-            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
-            localRepo.pushAll(repo.url());
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(4, conversations.size());
-
-            for (var conversation : conversations) {
-                var email = conversation.first();
-                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
-                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
-                } else if (email.subject().equals("git: test: 6 new changesets")) {
-                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
-                } else {
-                    fail("Mismatched subject: " + email.subject());
-                }
-                assertTrue(email.hasHeader("extra1"));
-                assertEquals("value1", email.headerValue("extra1"));
-                assertTrue(email.hasHeader("extra2"));
-                assertEquals("value2", email.headerValue("extra2"));
-            }
-        }
-    }
-
-    @Test
-    void testMailingListBranch(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master|newbranch."))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            CheckableRepository.appendAndCommit(localRepo, "Another line", "12345678: Some fixes");
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "newbranch1");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            var email = conversations.get(0).first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertEquals("git: test: created branch newbranch1 based on the branch master containing 2 unique commits", email.subject());
-            assertTrue(email.body().contains("12345678: Some fixes"));
-            assertTrue(email.hasHeader("extra1"));
-            assertEquals("value1", email.headerValue("extra1"));
-            assertTrue(email.hasHeader("extra2"));
-            assertEquals("value2", email.headerValue("extra2"));
-
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            localRepo.push(editHash, repo.url(), "newbranch2");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var newConversation = mailmanList.conversations(Duration.ofDays(1)).stream()
-                                             .filter(c -> !c.equals(conversations.get(0)))
-                                             .findFirst().orElseThrow();
-            email = newConversation.first();
-            assertEquals(listAddress, email.sender());
-            assertEquals(sender, email.author());
-            assertEquals(email.recipients(), List.of(listAddress));
-            assertEquals("git: test: created branch newbranch2 based on the branch newbranch1 containing 0 unique commits", email.subject());
-            assertEquals("The new branch newbranch2 is currently identical to the newbranch1 branch.", email.body());
-        }
-    }
-
-    @Test
-    void testMailingListNoIdempotence(TestInfo testInfo) throws IOException {
-        try (var listServer = new TestMailmanServer();
-             var credentials = new HostCredentials(testInfo);
-             var tempFolder = new TemporaryDirectory()) {
-            var repo = credentials.getHostedRepository();
-            var repoFolder = tempFolder.path().resolve("repo");
-            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
-            var masterHash = localRepo.resolve("master").orElseThrow();
-            credentials.commitLock(localRepo);
-            localRepo.pushAll(repo.url());
-
-            var listAddress = EmailAddress.parse(listServer.createList("test"));
-            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
-            var mailmanList = mailmanServer.getList(listAddress.address());
-            var tagStorage = createTagStorage(repo);
-            var branchStorage = createBranchStorage(repo);
-            var prStateStorage = createPullRequestStateStorage(repo);
-            var storageFolder = tempFolder.path().resolve("storage");
-
-            var sender = EmailAddress.from("duke", "duke@duke.duke");
-            var updater = MailingListUpdater.newBuilder()
-                                            .list(mailmanList)
-                                            .recipient(listAddress)
-                                            .sender(sender)
-                                            .reportNewTags(false)
-                                            .reportNewBranches(false)
-                                            .reportNewBuilds(false)
-                                            .headers(Map.of("extra1", "value1", "extra2", "value2"))
-                                            .allowedAuthorDomains(Pattern.compile("none"))
-                                            .build();
-            var notifyBot = NotifyBot.newBuilder()
-                                     .repository(repo)
-                                     .storagePath(storageFolder)
-                                     .branches(Pattern.compile("master"))
-                                     .tagStorageBuilder(tagStorage)
-                                     .branchStorageBuilder(branchStorage)
-                                     .prStateStorageBuilder(prStateStorage)
-                                     .updaters(List.of(updater))
-                                     .build();
-
-            // No mail should be sent on the first run as there is no history
-            TestBotRunner.runPeriodicItems(notifyBot);
-            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
-
-            // Save history state
-            var historyHash = localRepo.fetch(repo.url(), "history");
-
-            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
-            localRepo.push(editHash, repo.url(), "master");
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            var conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(1, conversations.size());
-
-            // Reset the history
-            localRepo.push(historyHash, repo.url(), "history", true);
-            TestBotRunner.runPeriodicItems(notifyBot);
-            listServer.processIncoming();
-
-            // There should now be a duplicate mail
-            conversations = mailmanList.conversations(Duration.ofDays(1));
-            assertEquals(2, conversations.size());
-        }
-    }
-}
diff a/bots/notify/src/test/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierTests.java b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierTests.java
--- /dev/null
+++ b/bots/notify/src/test/java/org/openjdk/skara/bots/notify/mailinglist/MailingListNotifierTests.java
@@ -0,0 +1,975 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package org.openjdk.skara.bots.notify.mailinglist;
+
+import org.junit.jupiter.api.*;
+import org.openjdk.skara.email.*;
+import org.openjdk.skara.bots.notify.*;
+import org.openjdk.skara.mailinglist.MailingListServerFactory;
+import org.openjdk.skara.test.*;
+
+import java.io.IOException;
+import java.time.Duration;
+import java.util.*;
+import java.util.regex.Pattern;
+
+import static org.junit.jupiter.api.Assertions.*;
+import static org.openjdk.skara.bots.notify.UpdaterTests.*;
+
+public class MailingListNotifierTests {
+    @Test
+    void testMailingList(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                             .allowedAuthorDomains(Pattern.compile("none"))
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(sender, email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.subject().contains(": 23456789: More fixes"));
+            assertFalse(email.subject().contains("master"));
+            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertFalse(email.body().contains("Committer"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+            assertTrue(email.hasHeader("extra1"));
+            assertEquals("value1", email.headerValue("extra1"));
+            assertTrue(email.hasHeader("extra2"));
+            assertEquals("value2", email.headerValue("extra2"));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash.hex(), email.headerValue("X-Git-Changeset"));
+        }
+    }
+
+    @Test
+    void testMailingListMultiple(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
+                    "first_author", "first@author.example.com");
+            localRepo.push(editHash1, repo.url(), "master");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes",
+                    "another_author", "another@author.example.com");
+            localRepo.push(editHash2, repo.url(), "master");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(EmailAddress.from("another_author", "another@author.example.com"), email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.subject().contains(": 2 new changesets"));
+            assertFalse(email.subject().contains("master"));
+            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
+            assertTrue(email.body().contains("3456789A: Even more fixes"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
+        }
+    }
+
+    @Test
+    void testMailingListSponsored(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes",
+                    "author", "author@test.test",
+                    "committer", "committer@test.test");
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(EmailAddress.from("committer", "committer@test.test"), email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.body().contains("Changeset: " + editHash.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertTrue(email.body().contains("Author:    author <author@test.test>"));
+            assertTrue(email.body().contains("Committer: committer <committer@test.test>"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+        }
+    }
+
+    @Test
+    void testMailingListMultipleBranches(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            var branch = localRepo.branch(masterHash, "another");
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var author = EmailAddress.from("author", "author@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .author(author)
+                                             .includeBranch(true)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|another"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash1 = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash1, repo.url(), "master");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Yet another line", "3456789A: Even more fixes");
+            localRepo.push(editHash2, repo.url(), "master");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(author, email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertFalse(email.subject().contains("another"));
+            assertTrue(email.subject().contains(": master: 2 new changesets"));
+            assertTrue(email.body().contains("Changeset: " + editHash1.abbreviate()));
+            assertTrue(email.body().contains("23456789: More fixes"));
+            assertTrue(email.body().contains("Changeset: " + editHash2.abbreviate()));
+            assertTrue(email.body().contains("3456789A: Even more fixes"));
+            assertFalse(email.body().contains(masterHash.abbreviate()));
+            assertFalse(email.body().contains("456789AB: Yet more fixes"));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash1.hex(), email.headerValue("X-Git-Changeset"));
+
+            localRepo.checkout(branch, true);
+            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another branch", "456789AB: Yet more fixes");
+            localRepo.push(editHash3, repo.url(), "another");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            conversations = mailmanList.conversations(Duration.ofDays(1));
+            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
+            email = conversations.get(0).first();
+            assertEquals(author, email.author());
+            assertEquals(listAddress, email.sender());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertTrue(email.subject().contains(": another: 456789AB: Yet more fixes"));
+            assertFalse(email.subject().contains("master"));
+            assertTrue(email.body().contains("Changeset: " + editHash3.abbreviate()));
+            assertTrue(email.body().contains("456789AB: Yet more fixes"));
+            assertFalse(email.body().contains("Changeset: " + editHash2.abbreviate()));
+            assertFalse(email.body().contains("3456789A: Even more fixes"));
+            assertTrue(email.hasHeader("X-Git-URL"));
+            assertEquals(repo.webUrl().toString(), email.headerValue("X-Git-URL"));
+            assertTrue(email.hasHeader("X-Git-Changeset"));
+            assertEquals(editHash3.hex(), email.headerValue("X-Git-Changeset"));
+        }
+    }
+
+    @Test
+    void testMailingListPROnlyMultipleBranches(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var author = EmailAddress.from("author", "author@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .author(author)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .includeBranch(true)
+                                             .mode(MailingListNotifier.Mode.PR)
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|other"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // Populate our known branches
+            localRepo.push(masterHash, repo.url(), "master", true);
+            localRepo.push(masterHash, repo.url(), "other", true);
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            localRepo.checkout(masterHash, true);
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "edit");
+            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
+
+            // PR hasn't been integrated yet, so there should be no mail
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Simulate an RFR email
+            var rfr = Email.create(sender, "RFR: My PR", "PR: " + pr.webUrl().toString())
+                           .recipient(listAddress)
+                           .build();
+            mailmanList.post(rfr);
+            listServer.processIncoming();
+
+            // And an integration (but it hasn't reached master just yet)
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+
+            // Now push the same commit to another branch
+            localRepo.push(editHash, repo.url(), "other");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            // This one should generate a plain integration mail
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(2, conversations.size());
+            var secondEmail = conversations.get(0).first();
+            if (secondEmail.subject().contains("RFR")) {
+                secondEmail = conversations.get(1).first();
+            }
+            assertEquals("git: test: other: 23456789: More fixes", secondEmail.subject());
+        }
+    }
+
+    @Test
+    void testMailingListPR(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .mode(MailingListNotifier.Mode.PR)
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "edit");
+            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
+
+            // Create a potentially conflicting one
+            var otherHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(otherHash, repo.url(), "other");
+            var otherPr = credentials.createPullRequest(repo, "master", "other", "RFR: My other PR");
+
+            // PR hasn't been integrated yet, so there should be no mail
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Simulate an RFR email
+            var rfr = Email.create("[repo/branch] RFR: My PR", "PR:\n" + pr.webUrl().toString())
+                           .author(EmailAddress.from("duke", "duke@duke.duke"))
+                           .recipient(listAddress)
+                           .build();
+            mailmanList.post(rfr);
+            listServer.processIncoming();
+
+            // And an integration
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+            localRepo.push(editHash, repo.url(), "master");
+
+            // Push the other one without a matching PR
+            localRepo.push(otherHash, repo.url(), "master");
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
+            assertEquals(2, conversations.size());
+
+            var prConversation = conversations.get(0);
+            var pushConversation = conversations.get(1);
+            assertEquals(1, prConversation.allMessages().size());
+
+            var pushEmail = pushConversation.first();
+            assertEquals(listAddress, pushEmail.sender());
+            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
+            assertEquals(pushEmail.recipients(), List.of(listAddress));
+            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
+        }
+    }
+
+    @Test
+    void testMailingListPROnce(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.branch(masterHash, "other");
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .author(null)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .mode(MailingListNotifier.Mode.PR)
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|other"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            localRepo.checkout(masterHash, true);
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "edit");
+            var pr = credentials.createPullRequest(repo, "master", "edit", "RFR: My PR");
+
+            // PR hasn't been integrated yet, so there should be no mail
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Simulate an RFR email
+            var rfr = Email.create("RFR: My PR", "PR:\n" + pr.webUrl().toString())
+                           .author(EmailAddress.from("duke", "duke@duke.duke"))
+                           .recipient(listAddress)
+                           .build();
+            mailmanList.post(rfr);
+            listServer.processIncoming();
+
+            // And an integration
+            pr.addComment("Pushed as commit " + editHash.hex() + ".");
+            localRepo.push(editHash, repo.url(), "master", true);
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(1, conversations.size());
+
+            var prConversation = conversations.get(0);
+            assertEquals(1, prConversation.allMessages().size());
+
+            // Now push the change to another monitored branch
+            localRepo.push(editHash, repo.url(), "other", true);
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            // The change should now end up as a separate notification thread
+            conversations = mailmanList.conversations(Duration.ofDays(1));
+            conversations.sort(Comparator.comparing(conversation -> conversation.first().subject()));
+            assertEquals(2, conversations.size());
+
+            var pushConversation = conversations.get(1);
+            var pushEmail = pushConversation.first();
+            assertEquals(listAddress, pushEmail.sender());
+            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), pushEmail.author());
+            assertEquals(pushEmail.recipients(), List.of(listAddress));
+            assertTrue(pushEmail.subject().contains("23456789: More fixes"));
+        }
+    }
+
+    @Test
+    void testMailinglistTag(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer()) {
+            var repo = credentials.getHostedRepository();
+            var localRepoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewBranches(false)
+                                             .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                             .build();
+            var noTagsUpdater = MailingListNotifier.newBuilder()
+                                                   .list(mailmanList)
+                                                   .recipient(listAddress)
+                                                   .sender(sender)
+                                                   .reportNewTags(false)
+                                                   .reportNewBranches(false)
+                                                   .reportNewBuilds(false)
+                                                   .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater, noTagsUpdater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.fetch(repo.url(), "history:history");
+            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
+            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
+            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
+            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(4, conversations.size());
+
+            for (var conversation : conversations) {
+                var email = conversation.first();
+                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
+                    assertTrue(email.body().contains("23456789: More fixes"));
+                    assertFalse(email.body().contains("34567890: Even more fixes"));
+                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
+                    assertFalse(email.body().contains("56789012: Still even more fixes"));
+                    assertFalse(email.body().contains("67890123: Brand new fixes"));
+                    assertFalse(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
+                    assertFalse(email.body().contains("23456789: More fixes"));
+                    assertTrue(email.body().contains("34567890: Even more fixes"));
+                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
+                    assertTrue(email.body().contains("56789012: Still even more fixes"));
+                    assertFalse(email.body().contains("67890123: Brand new fixes"));
+                    assertFalse(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
+                    assertFalse(email.body().contains("23456789: More fixes"));
+                    assertFalse(email.body().contains("34567890: Even more fixes"));
+                    assertFalse(email.body().contains("45678901: Yet even more fixes"));
+                    assertFalse(email.body().contains("56789012: Still even more fixes"));
+                    assertFalse(email.body().contains("67890123: Brand new fixes"));
+                    assertTrue(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: 6 new changesets")) {
+                    assertTrue(email.body().contains("23456789: More fixes"));
+                    assertTrue(email.body().contains("34567890: Even more fixes"));
+                    assertTrue(email.body().contains("45678901: Yet even more fixes"));
+                    assertTrue(email.body().contains("56789012: Still even more fixes"));
+                    assertTrue(email.body().contains("67890123: Brand new fixes"));
+                    assertTrue(email.body().contains("78901234: More brand new fixes"));
+                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
+                } else {
+                    fail("Mismatched subject: " + email.subject());
+                }
+                assertTrue(email.hasHeader("extra1"));
+                assertEquals("value1", email.headerValue("extra1"));
+                assertTrue(email.hasHeader("extra2"));
+                assertEquals("value2", email.headerValue("extra2"));
+            }
+        }
+    }
+
+    @Test
+    void testMailinglistPlainTags(TestInfo testInfo) throws IOException {
+        try (var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory();
+             var listServer = new TestMailmanServer()) {
+            var repo = credentials.getHostedRepository();
+            var localRepoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(localRepoFolder, repo.repositoryType());
+            credentials.commitLock(localRepo);
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            localRepo.tag(masterHash, "jdk-12+1", "Added tag 1", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                             .build();
+            var noTagsUpdater = MailingListNotifier.newBuilder()
+                                                   .list(mailmanList)
+                                                   .recipient(listAddress)
+                                                   .sender(sender)
+                                                   .reportNewTags(false)
+                                                   .reportNewBranches(false)
+                                                   .reportNewBuilds(false)
+                                                   .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater, noTagsUpdater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.fetch(repo.url(), "history:history");
+            localRepo.tag(editHash, "jdk-12+2", "Added tag 2", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 1", "34567890: Even more fixes");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 2", "45678901: Yet even more fixes");
+            var editHash2 = CheckableRepository.appendAndCommit(localRepo, "Another line 3", "56789012: Still even more fixes");
+            localRepo.tag(editHash2, "jdk-12+4", "Added tag 3", "Duke Tagger", "tagger@openjdk.java.net");
+            CheckableRepository.appendAndCommit(localRepo, "Another line 4", "67890123: Brand new fixes");
+            var editHash3 = CheckableRepository.appendAndCommit(localRepo, "Another line 5", "78901234: More brand new fixes");
+            localRepo.tag(editHash3, "jdk-13+0", "Added tag 4", "Duke Tagger", "tagger@openjdk.java.net");
+            localRepo.pushAll(repo.url());
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(4, conversations.size());
+
+            for (var conversation : conversations) {
+                var email = conversation.first();
+                if (email.subject().equals("git: test: Added tag jdk-12+2 for changeset " + editHash.abbreviate())) {
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-12+4 for changeset " + editHash2.abbreviate())) {
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: Added tag jdk-13+0 for changeset " + editHash3.abbreviate())) {
+                    assertEquals(EmailAddress.from("Duke Tagger", "tagger@openjdk.java.net"), email.author());
+                } else if (email.subject().equals("git: test: 6 new changesets")) {
+                    assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
+                } else {
+                    fail("Mismatched subject: " + email.subject());
+                }
+                assertTrue(email.hasHeader("extra1"));
+                assertEquals("value1", email.headerValue("extra1"));
+                assertTrue(email.hasHeader("extra2"));
+                assertEquals("value2", email.headerValue("extra2"));
+            }
+        }
+    }
+
+    @Test
+    void testMailingListBranch(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewTags(false)
+                                             .reportNewBuilds(false)
+                                             .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master|newbranch."))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            CheckableRepository.appendAndCommit(localRepo, "Another line", "12345678: Some fixes");
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "newbranch1");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            var email = conversations.get(0).first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(EmailAddress.from("testauthor", "ta@none.none"), email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertEquals("git: test: created branch newbranch1 based on the branch master containing 2 unique commits", email.subject());
+            assertTrue(email.body().contains("12345678: Some fixes"));
+            assertTrue(email.hasHeader("extra1"));
+            assertEquals("value1", email.headerValue("extra1"));
+            assertTrue(email.hasHeader("extra2"));
+            assertEquals("value2", email.headerValue("extra2"));
+
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            localRepo.push(editHash, repo.url(), "newbranch2");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var newConversation = mailmanList.conversations(Duration.ofDays(1)).stream()
+                                             .filter(c -> !c.equals(conversations.get(0)))
+                                             .findFirst().orElseThrow();
+            email = newConversation.first();
+            assertEquals(listAddress, email.sender());
+            assertEquals(sender, email.author());
+            assertEquals(email.recipients(), List.of(listAddress));
+            assertEquals("git: test: created branch newbranch2 based on the branch newbranch1 containing 0 unique commits", email.subject());
+            assertEquals("The new branch newbranch2 is currently identical to the newbranch1 branch.", email.body());
+        }
+    }
+
+    @Test
+    void testMailingListNoIdempotence(TestInfo testInfo) throws IOException {
+        try (var listServer = new TestMailmanServer();
+             var credentials = new HostCredentials(testInfo);
+             var tempFolder = new TemporaryDirectory()) {
+            var repo = credentials.getHostedRepository();
+            var repoFolder = tempFolder.path().resolve("repo");
+            var localRepo = CheckableRepository.init(repoFolder, repo.repositoryType());
+            var masterHash = localRepo.resolve("master").orElseThrow();
+            credentials.commitLock(localRepo);
+            localRepo.pushAll(repo.url());
+
+            var listAddress = EmailAddress.parse(listServer.createList("test"));
+            var mailmanServer = MailingListServerFactory.createMailmanServer(listServer.getArchive(), listServer.getSMTP(), Duration.ZERO);
+            var mailmanList = mailmanServer.getList(listAddress.address());
+            var tagStorage = createTagStorage(repo);
+            var branchStorage = createBranchStorage(repo);
+            var prStateStorage = createPullRequestStateStorage(repo);
+            var storageFolder = tempFolder.path().resolve("storage");
+
+            var sender = EmailAddress.from("duke", "duke@duke.duke");
+            var updater = MailingListNotifier.newBuilder()
+                                             .list(mailmanList)
+                                             .recipient(listAddress)
+                                             .sender(sender)
+                                             .reportNewTags(false)
+                                             .reportNewBranches(false)
+                                             .reportNewBuilds(false)
+                                             .headers(Map.of("extra1", "value1", "extra2", "value2"))
+                                             .allowedAuthorDomains(Pattern.compile("none"))
+                                             .build();
+            var notifyBot = NotifyBot.newBuilder()
+                                     .repository(repo)
+                                     .storagePath(storageFolder)
+                                     .branches(Pattern.compile("master"))
+                                     .tagStorageBuilder(tagStorage)
+                                     .branchStorageBuilder(branchStorage)
+                                     .prStateStorageBuilder(prStateStorage)
+                                     .updaters(List.of(updater))
+                                     .build();
+
+            // No mail should be sent on the first run as there is no history
+            TestBotRunner.runPeriodicItems(notifyBot);
+            assertThrows(RuntimeException.class, () -> listServer.processIncoming(Duration.ofMillis(1)));
+
+            // Save history state
+            var historyHash = localRepo.fetch(repo.url(), "history");
+
+            var editHash = CheckableRepository.appendAndCommit(localRepo, "Another line", "23456789: More fixes");
+            localRepo.push(editHash, repo.url(), "master");
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            var conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(1, conversations.size());
+
+            // Reset the history
+            localRepo.push(historyHash, repo.url(), "history", true);
+            TestBotRunner.runPeriodicItems(notifyBot);
+            listServer.processIncoming();
+
+            // There should now be a duplicate mail
+            conversations = mailmanList.conversations(Duration.ofDays(1));
+            assertEquals(2, conversations.size());
+        }
+    }
+}

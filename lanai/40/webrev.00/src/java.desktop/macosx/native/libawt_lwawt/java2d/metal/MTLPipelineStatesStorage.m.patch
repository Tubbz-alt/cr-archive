diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
@@ -165,12 +165,10 @@
 
     if (isAA) {
         subIndex |= 1 << 5;
     }
 
-    // FIXME: the FLT_LT macro doesn't do what the name implies.
-    // When the macro is fixed this usage should be double-checked (although it might be OK)
     if ((composite != nil && FLT_LT([composite getExtraAlpha], 1.0f))) {
         subIndex |= 1 << 6;
     }
     int index = compositeRule*64 + subIndex;
 
@@ -195,14 +193,11 @@
                 pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationColor;
                 pipelineDesc.colorAttachments[0].destinationRGBBlendFactor =  MTLBlendFactorOneMinusSourceColor;
 
             } else if (useComposite ||
                        (composite != nil  &&
-                        // FIXME: the FLT_GE macro doesn't do what the name implies.
-                        // When the macro is fixed this usage should be double-checked, since
-                        // it looks backwards to me.
-                        FLT_GE([composite getExtraAlpha], 1.0f)))
+                        FLT_LT([composite getExtraAlpha], 1.0f)))
             {
                 setBlendingFactors(
                         pipelineDesc.colorAttachments[0],
                         compositeRule,
                         composite,
@@ -268,12 +263,10 @@
         int compositeRule,
         MTLComposite* composite,
         const SurfaceRasterFlags * srcFlags,
         const SurfaceRasterFlags * dstFlags
 ) {
-    // FIXME: the FLT_GE macro doesn't do what the name implies.
-    // When the macro is fixed this usage should be double-checked (although it might be OK)
     if (compositeRule == RULE_Src &&
         (composite == nil || FLT_GE([composite getExtraAlpha], 1.0f))) {
         J2dTraceLn(J2D_TRACE_VERBOSE, "set RULE_Src but blending is disabled because src is opaque");
         return;
     }
@@ -295,12 +288,10 @@
 
     switch (compositeRule) {
         case RULE_SrcOver: {
             // Ar = As + Ad*(1-As)
             // Cr = Cs + Cd*(1-As)
-            // FIXME: the FLT_GE macro doesn't do what the name implies.
-            // When the macro is fixed this usage should be double-checked (although it might be OK)
             if (srcFlags->isOpaque &&
                 (composite == nil ||
                  FLT_GE([composite getExtraAlpha], 1.0f)))
             {
                 J2dTraceLn(J2D_TRACE_VERBOSE, "rule=RULE_SrcOver, but blending is disabled because src is opaque");
@@ -316,12 +307,10 @@
                 cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
             }
             if (!srcFlags->isPremultiplied) {
                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
             }
-            // FIXME: the FLT_LT macro doesn't do what the name implies.
-            // When the macro is fixed this usage should be double-checked (although it might be OK)
             if (composite != nil && FLT_LT([composite getExtraAlpha], 1.0f)) {
                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
             }
             cad.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 

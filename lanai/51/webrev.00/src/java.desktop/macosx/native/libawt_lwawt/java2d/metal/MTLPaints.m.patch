diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
@@ -32,19 +32,28 @@
 #include "common.h"
 
 #include "sun_java2d_SunGraphics2D.h"
 #include "sun_java2d_pipe_BufferedPaints.h"
 #import "MTLComposite.h"
+#import "MTLBufImgOps.h"
 
 #define RGBA_TO_V4(c)              \
 {                                  \
     (((c) >> 16) & (0xFF))/255.0f, \
     (((c) >> 8) & 0xFF)/255.0f,    \
     ((c) & 0xFF)/255.0f,           \
     (((c) >> 24) & 0xFF)/255.0f    \
 }
 
+#define FLOAT_ARR_TO_V4(p) \
+{                      \
+    p[0], \
+    p[1], \
+    p[2], \
+    p[3]  \
+}
+
 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 
 static void initTemplatePipelineDescriptors() {
@@ -319,220 +328,210 @@
     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
 }
 
-static void setTxtUniforms(
-        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
-        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
-) {
-    struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags->isOpaque, dstFlags->isOpaque, extraAlpha};
-    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
-
+static void setSampler(id<MTLRenderCommandEncoder> encoder, int interpolation, bool repeat) {
     id<MTLSamplerState> sampler;
     if (repeat) {
         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
     } else {
         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
     }
     [encoder setFragmentSamplerState:sampler atIndex:0];
 }
 
-// TODO: need support hints for all shaders
+static void setTxtUniforms(
+        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
+        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
+) {
+    struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags->isOpaque, dstFlags->isOpaque, extraAlpha};
+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+
+    setSampler(encoder, interpolation, repeat);
+}
 
 // For the current paint mode:
 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
 // 2. Set vertex and fragment buffers
 - (void)setPipelineState:(id<MTLRenderCommandEncoder>)encoder
-               composite:(MTLComposite *)composite
-           isStencilUsed:(jboolean)isStencilUsed
-               isTexture:(jboolean)isTexture
-           interpolation:(int)interpolation
-                    isAA:(jboolean)isAA
-                srcFlags:(const SurfaceRasterFlags *)srcFlags
-                dstFlags:(const SurfaceRasterFlags *)dstFlags
+                 context:(MTLContext *)mtlc
+           renderOptions:(const RenderOptions *)renderOptions
     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
 {
     initTemplatePipelineDescriptors();
 
-    const bool stencil = isStencilUsed == JNI_TRUE;
-
-    id<MTLRenderPipelineState> pipelineState = nil;
-    if (isTexture) {
-
-      if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
-        pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
-                                                vertexShaderId:@"vert_txt_tp"
-                                              fragmentShaderId:@"frag_txt_tp"
-                                                 compositeRule:[composite getRule]
-                                                          isAA:JNI_FALSE
-                                                      srcFlags:srcFlags
-                                                      dstFlags:dstFlags
-                                                 stencilNeeded:stencil];
-        [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
-        [encoder setFragmentTexture:_paintTexture atIndex: 1];
-
-        setTxtUniforms(encoder, 0, 0, interpolation, YES, [composite getExtraAlpha], srcFlags, dstFlags);
-      } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
-        pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
-                                                vertexShaderId:@"vert_txt_grad"
-                                              fragmentShaderId:@"frag_txt_grad"
-                                                 compositeRule:[composite getRule]
-                                                          isAA:JNI_FALSE
-                                                      srcFlags:srcFlags
-                                                      dstFlags:dstFlags
-                                                 stencilNeeded:stencil];
-        struct GradFrameUniforms uf = {
-            {_p0, _p1, _p3},
-            RGBA_TO_V4(_pixel1),
-            RGBA_TO_V4(_pixel2)};
-        [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];
-
-      } else {
-        if (isAA) {
-          pipelineState = [pipelineStateStorage
-              getPipelineState:templateAATexturePipelineDesc
-                vertexShaderId:@"vert_txt"
-              fragmentShaderId:@"aa_frag_txt"
-                 compositeRule:[composite getRule]
-                          isAA:JNI_FALSE
-                      srcFlags:srcFlags
-                      dstFlags:dstFlags
-                 stencilNeeded:stencil];
+    NSString * vertShader = @"vert_txt";
+    NSString * fragShader = @"frag_txt";
+    MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
+
+    if (renderOptions->isTexture) {
+        NSObject *bufImgOp = [mtlc getBufImgOp];
+        if (bufImgOp != nil) {
+            if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {
+                MTLRescaleOp *rescaleOp = bufImgOp;
+                vertShader = @"vert_txt";
+                fragShader = @"frag_txt_op_rescale";
+
+                struct TxtFrameOpRescaleUniforms uf = {
+                        RGBA_TO_V4(0), [mtlc.composite getExtraAlpha], renderOptions->srcFlags.isOpaque,
+                        rescaleOp.isNonPremult,
+                        FLOAT_ARR_TO_V4([rescaleOp getScaleFactors]), FLOAT_ARR_TO_V4([rescaleOp getOffsets])
+                };
+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+                setSampler(encoder, renderOptions->interpolation, NO);
+            } else if ([bufImgOp isKindOfClass:[MTLConvolveOp class]]) {
+                MTLConvolveOp * convolveOp = bufImgOp;
+                vertShader = @"vert_txt";
+                fragShader = @"frag_txt_op_convolve";
+
+                struct TxtFrameOpConvolveUniforms uf = {
+                        [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([convolveOp getImgEdge]),
+                        convolveOp.kernelSize, convolveOp.isEdgeZeroFill,
+                };
+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+                setSampler(encoder, renderOptions->interpolation, NO);
+
+                [encoder setFragmentBuffer:[convolveOp getBuffer] offset:0 atIndex:2];
+            } else if ([bufImgOp isKindOfClass:[MTLLookupOp class]]) {
+                MTLLookupOp * lookupOp = bufImgOp;
+                vertShader = @"vert_txt";
+                fragShader = @"frag_txt_op_lookup";
+
+                struct TxtFrameOpLookupUniforms uf = {
+                        [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([lookupOp getOffset]),
+                        lookupOp.isUseSrcAlpha, lookupOp.isNonPremult,
+                };
+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+                setSampler(encoder, renderOptions->interpolation, NO);
+                [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex: 1];
+            }
+        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
+            vertShader = @"vert_txt_tp";
+            fragShader = @"frag_txt_tp";
+            [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
+            [encoder setFragmentTexture:_paintTexture atIndex:1];
+
+            setTxtUniforms(encoder, 0, 0, renderOptions->interpolation, YES, [mtlc.composite getExtraAlpha],
+                           &renderOptions->srcFlags, &renderOptions->dstFlags);
+        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
+            vertShader = @"vert_txt_grad";
+            fragShader = @"frag_txt_grad";
+            struct GradFrameUniforms uf = {
+                    {_p0, _p1, _p3},
+                    RGBA_TO_V4(_pixel1),
+                    RGBA_TO_V4(_pixel2)};
+            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];
 
         } else {
-          pipelineState =
-              [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
-                                      vertexShaderId:@"vert_txt"
-                                    fragmentShaderId:@"frag_txt"
-                                       compositeRule:[composite getRule]
-                                           composite:composite
-                                                isAA:JNI_FALSE
-                                            srcFlags:srcFlags
-                                            dstFlags:dstFlags
-                                       stencilNeeded:stencil];
-        }
+            vertShader = @"vert_txt";
+            fragShader = @"frag_txt";
+            if (renderOptions->isAA) {
+                fragShader = @"aa_frag_txt";
+                rpDesc = templateAATexturePipelineDesc;
+            }
 
-        setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);
-      }
+            setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
+                           renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha], &renderOptions->srcFlags,
+                           &renderOptions->dstFlags);
+        }
     } else {
+        rpDesc = templateRenderPipelineDesc;
+
         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
-            pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
-                                                    vertexShaderId:@"vert_col"
-                                                  fragmentShaderId:@"frag_col"
-                                                     compositeRule:[composite getRule]
-                                                              isAA:isAA
-                                                          srcFlags:srcFlags
-                                                          dstFlags:dstFlags
-                                                     stencilNeeded:stencil];
+            vertShader = @"vert_col";
+            fragShader = @"frag_col";
 
             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
             [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
-            pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
-                                                    vertexShaderId:@"vert_grad"
-                                                  fragmentShaderId:@"frag_grad"
-                                                     compositeRule:[composite getRule]
-                                                              isAA:isAA
-                                                          srcFlags:srcFlags
-                                                          dstFlags:dstFlags
-                                                     stencilNeeded:stencil];
+            vertShader = @"vert_grad";
+            fragShader = @"frag_grad";
 
             struct GradFrameUniforms uf = {
                     {_p0, _p1, _p3},
                     RGBA_TO_V4(_pixel1),
                     RGBA_TO_V4(_pixel2)};
-            [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];
+            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];
         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
-            pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
-                                        vertexShaderId:@"vert_tp"
-                                      fragmentShaderId:@"frag_tp"
-                                         compositeRule:[composite getRule]
-                                                  isAA:isAA
-                                              srcFlags:srcFlags
-                                              dstFlags:dstFlags
-                                         stencilNeeded:stencil];
+            vertShader = @"vert_tp";
+            fragShader = @"frag_tp";
 
             [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
-            [encoder setFragmentTexture:_paintTexture atIndex: 0];
+            [encoder setFragmentTexture:_paintTexture atIndex:0];
         }
     }
 
+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc
+                                                                        vertexShaderId:vertShader
+                                                                      fragmentShaderId:fragShader
+                                                                             composite:mtlc.composite
+                                                                         renderOptions:renderOptions
+                                                                         stencilNeeded:[mtlc.clip isShape]];
     [encoder setRenderPipelineState:pipelineState];
 }
 
 
 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
 // 2. Set vertex and fragment buffers
 - (void)setXorModePipelineState:(id<MTLRenderCommandEncoder>)encoder
-               composite:(MTLComposite *)composite
-           isStencilUsed:(jboolean)isStencilUsed
-               isTexture:(jboolean)isTexture
-           interpolation:(int)interpolation
-                srcFlags:(const SurfaceRasterFlags *)srcFlags
-                dstFlags:(const SurfaceRasterFlags *)dstFlags
-    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage {
+                        context:(MTLContext *)mtlc
+                  renderOptions:(const RenderOptions *)renderOptions
+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
+{
     initTemplatePipelineDescriptors();
 
-    const bool stencil = isStencilUsed == JNI_TRUE;
-    jint xorColor = (jint) [composite getXorColor];
-
-    id<MTLRenderPipelineState> pipelineState = nil;
-    if (isTexture) {
-          pipelineState = [pipelineStateStorage getXorModePipelineState:templateTexturePipelineDesc
-                                          vertexShaderId:@"vert_txt"
-                                        fragmentShaderId:@"frag_txt"
-                                                srcFlags:srcFlags
-                                                dstFlags:dstFlags
-                                           stencilNeeded:stencil];
+    jint xorColor = (jint) [mtlc.composite getXorColor];
+
+    NSString * vertShader = @"vert_txt";
+    NSString * fragShader = @"frag_txt";
+    MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
+
+    if (renderOptions->isTexture) {
         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
-        setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);
+        setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha], &renderOptions->srcFlags, &renderOptions->dstFlags);
         [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];
     } else {
         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
-
-            pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
-                                        vertexShaderId:@"vert_col"
-                                      fragmentShaderId:@"frag_col"
-                                              srcFlags:srcFlags
-                                              dstFlags:dstFlags
-                                         stencilNeeded:stencil];
+            vertShader = @"vert_col";
+            fragShader = @"frag_col";
+            rpDesc = templateRenderPipelineDesc;
 
             // Calculate _color ^ xorColor for RGB components
             // This color gets XORed with destination framebuffer pixel color
             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
             [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 
         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
-
-            pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
-                                        vertexShaderId:@"vert_grad"
-                                      fragmentShaderId:@"frag_grad"
-                                              srcFlags:srcFlags
-                                              dstFlags:dstFlags
-                                         stencilNeeded:stencil];
+            vertShader = @"vert_grad";
+            fragShader = @"frag_grad";
+            rpDesc = templateRenderPipelineDesc;
 
                 struct GradFrameUniforms uf = {
                         {_p0, _p1, _p3},
                         RGBA_TO_V4(_pixel1 ^ xorColor),
                         RGBA_TO_V4(_pixel2 ^ xorColor)};
                 [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];
             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
+            vertShader = @"vert_tp";
+            fragShader = @"frag_tp_xorMode";
+            rpDesc = templateRenderPipelineDesc;
 
-                pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
-                                            vertexShaderId:@"vert_tp"
-                                          fragmentShaderId:@"frag_tp_xorMode"
-                                                  srcFlags:srcFlags
-                                                  dstFlags:dstFlags
-                                             stencilNeeded:stencil];
 
                 [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
                 [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];
             }
         }
+
+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc
+                                                                        vertexShaderId:vertShader
+                                                                      fragmentShaderId:fragShader
+                                                                             composite:mtlc.composite
+                                                                         renderOptions:renderOptions
+                                                                         stencilNeeded:[mtlc.clip isShape]];
     [encoder setRenderPipelineState:pipelineState];
 }
 
 @end
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="EncoderManager.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLBufImgOps.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  4 #import &quot;common.h&quot;
  5 
  6 // NOTE: uncomment to disable comparing cached encoder states with requested (for debugging)
  7 // #define ALWAYS_UPDATE_ENCODER_STATES
  8 
  9 const SurfaceRasterFlags defaultRasterFlags = { JNI_FALSE, JNI_TRUE };
 10 
 11 // Internal utility class that represents the set of &#39;mutable&#39; encoder properties
 12 @interface EncoderStates : NSObject
 13 @property (readonly) MTLClip * clip;
 14 
 15 - (id)init;
 16 - (void)dealloc;
 17 
 18 - (void)reset:(id&lt;MTLTexture&gt;)destination
 19            isDstOpaque:(jboolean)isDstOpaque
 20     isDstPremultiplied:(jboolean)isDstPremultiplied
 21                   isAA:(jboolean)isAA;
 22 
 23 - (void)updateEncoder:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified"> 24                 paint:(MTLPaint *)paint</span>
<span class="line-modified"> 25             composite:(MTLComposite *)composite</span>
<span class="line-removed"> 26             isTexture:(jboolean)isTexture</span>
<span class="line-removed"> 27                  isAA:(jboolean)isAA</span>
<span class="line-removed"> 28              srcFlags:(const SurfaceRasterFlags * _Nullable)srcFlags</span>
<span class="line-removed"> 29                  clip:(MTLClip *)clip</span>
<span class="line-removed"> 30             transform:(MTLTransform *)transform</span>
 31           forceUpdate:(jboolean)forceUpdate;
 32 @property jboolean aa;
 33 @end
 34 
 35 @implementation EncoderStates {
 36     MTLPipelineStatesStorage * _pipelineStateStorage;
 37     id&lt;MTLDevice&gt; _device;
 38 
 39     // Persistent encoder properties
 40     id&lt;MTLTexture&gt; _destination;
 41     SurfaceRasterFlags _dstFlags;
 42 
 43     jboolean _isAA;
 44 
 45     //
 46     // Cached &#39;mutable&#39; states of encoder
 47     //
 48 
 49     // Composite rule and source raster flags (it affects the CAD-multipliers (of pipelineState))
 50     MTLComposite * _composite;
</pre>
<hr />
<pre>
 84     [super dealloc];
 85 }
 86 
 87 - (void)setContext:(MTLContext * _Nonnull)mtlc {
 88     self-&gt;_pipelineStateStorage = mtlc.pipelineStateStorage;
 89     self-&gt;_device = mtlc.device;
 90 }
 91 
 92 - (void)reset:(id&lt;MTLTexture&gt;)destination
 93            isDstOpaque:(jboolean)isDstOpaque
 94     isDstPremultiplied:(jboolean)isDstPremultiplied
 95                   isAA:(jboolean)isAA {
 96     _destination = destination;
 97     _dstFlags.isOpaque = isDstOpaque;
 98     _dstFlags.isPremultiplied = isDstPremultiplied;
 99     _isAA = isAA;
100     // NOTE: probably it&#39;s better to invalidate/reset all cached states now
101 }
102 
103 - (void)updateEncoder:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified">104                 paint:(MTLPaint *)paint</span>
<span class="line-modified">105             composite:(MTLComposite *)composite</span>
<span class="line-removed">106             isTexture:(jboolean)isTexture</span>
<span class="line-removed">107         interpolation:(int)interpolation</span>
<span class="line-removed">108                  isAA:(jboolean)isAA</span>
<span class="line-removed">109              srcFlags:(const SurfaceRasterFlags * _Nullable)srcFlags</span>
<span class="line-removed">110                  clip:(MTLClip *)clip</span>
<span class="line-removed">111             transform:(MTLTransform *)transform</span>
112           forceUpdate:(jboolean)forceUpdate
113 {
114     // 1. Process special case for stencil mask generation
<span class="line-modified">115     if (clip.stencilMaskGenerationInProgress == JNI_TRUE) {</span>
116         // use separate pipeline state for stencil generation
117         if (forceUpdate || (_clip.stencilMaskGenerationInProgress != JNI_TRUE)) {
<span class="line-modified">118             [_clip copyFrom:clip];</span>
119             [_clip setMaskGenerationPipelineState:encoder
120                                         destWidth:_destination.width
121                                        destHeight:_destination.height
122                              pipelineStateStorage:_pipelineStateStorage];
123         }
124 
<span class="line-modified">125         [self updateTransform:encoder transform:transform forceUpdate:forceUpdate];</span>
126         return;
127     }
128 
129     // 2. Otherwise update all &#39;mutable&#39; properties of encoder
130     [self updatePipelineState:encoder
<span class="line-modified">131                         paint:paint</span>
<span class="line-modified">132                     composite:composite</span>
<span class="line-removed">133                 isStencilUsed:[clip isShape]</span>
<span class="line-removed">134                     isTexture:isTexture</span>
<span class="line-removed">135                 interpolation:interpolation</span>
<span class="line-removed">136                          isAA:isAA</span>
<span class="line-removed">137                      srcFlags:srcFlags</span>
138                   forceUpdate:forceUpdate];
<span class="line-modified">139     [self updateTransform:encoder transform:transform forceUpdate:forceUpdate];</span>
<span class="line-modified">140     [self updateClip:encoder clip:clip forceUpdate:forceUpdate];</span>
141 }
142 
143 //
144 // Internal methods that update states when necessary (compare with cached states)
145 //
146 
147 // Updates pipelineState (and corresponding buffers) with use of paint+composite+flags
148 - (void)updatePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified">149                       paint:(MTLPaint *)paint</span>
<span class="line-modified">150                   composite:(MTLComposite *)composite</span>
<span class="line-removed">151               isStencilUsed:(jboolean)isStencilUsed</span>
<span class="line-removed">152                   isTexture:(jboolean)isTexture</span>
<span class="line-removed">153               interpolation:(int)interpolation</span>
<span class="line-removed">154                        isAA:(jboolean)isAA</span>
<span class="line-removed">155                    srcFlags:(const SurfaceRasterFlags * _Nullable)srcFlags</span>
156                 forceUpdate:(jboolean)forceUpdate
157 {
<span class="line-removed">158     if (srcFlags == NULL)</span>
<span class="line-removed">159         srcFlags = &amp;defaultRasterFlags;</span>
<span class="line-removed">160 </span>
161     if (!forceUpdate
<span class="line-modified">162         &amp;&amp; [_paint isEqual:paint]</span>
<span class="line-modified">163         &amp;&amp; [_composite isEqual:composite]</span>
<span class="line-modified">164         &amp;&amp; (_isTexture == isTexture &amp;&amp; (!isTexture || _interpolationMode == interpolation)) // interpolation is used only in texture mode</span>
<span class="line-modified">165         &amp;&amp; _isAA == isAA</span>
<span class="line-modified">166         &amp;&amp; _srcFlags.isOpaque == srcFlags-&gt;isOpaque &amp;&amp; _srcFlags.isPremultiplied == srcFlags-&gt;isPremultiplied)</span>
167         return;
168 
<span class="line-modified">169     [_paint copyFrom:paint];</span>
<span class="line-modified">170     [_composite copyFrom:composite];</span>
<span class="line-modified">171     _isTexture = isTexture;</span>
<span class="line-modified">172     _interpolationMode = interpolation;</span>
<span class="line-modified">173     _isAA = isAA;</span>
<span class="line-modified">174     _srcFlags = *srcFlags;</span>
<span class="line-modified">175 </span>
<span class="line-modified">176     if ((jint)[composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR) {</span>
<span class="line-modified">177         [paint setXorModePipelineState:encoder</span>
<span class="line-modified">178                       composite:_composite</span>
<span class="line-modified">179                   isStencilUsed:isStencilUsed</span>
<span class="line-modified">180                       isTexture:_isTexture</span>
<span class="line-removed">181                   interpolation:interpolation</span>
<span class="line-removed">182                        srcFlags:&amp;_srcFlags</span>
<span class="line-removed">183                        dstFlags:&amp;_dstFlags</span>
<span class="line-removed">184            pipelineStateStorage:_pipelineStateStorage];</span>
185     } else {
<span class="line-modified">186         [paint setPipelineState:encoder</span>
<span class="line-modified">187                       composite:_composite</span>
<span class="line-modified">188                   isStencilUsed:isStencilUsed</span>
<span class="line-removed">189                       isTexture:_isTexture</span>
<span class="line-removed">190                   interpolation:interpolation</span>
<span class="line-removed">191                            isAA:isAA</span>
<span class="line-removed">192                        srcFlags:&amp;_srcFlags</span>
<span class="line-removed">193                        dstFlags:&amp;_dstFlags</span>
194            pipelineStateStorage:_pipelineStateStorage];
195     }
196 }
197 
198 - (void) updateClip:(id&lt;MTLRenderCommandEncoder&gt;)encoder clip:(MTLClip *)clip forceUpdate:(jboolean)forceUpdate
199 {
200     if (clip.stencilMaskGenerationInProgress == JNI_TRUE) {
201         // don&#39;t set setScissorOrStencil when generateion in progress
202         return;
203     }
204 
205     if (!forceUpdate &amp;&amp; [_clip isEqual:clip])
206         return;
207 
208     [_clip copyFrom:clip];
209     [_clip setScissorOrStencil:encoder
210                      destWidth:_destination.width
211                     destHeight:_destination.height
212                         device:_device];
213 }
</pre>
<hr />
<pre>
255     return self;
256 }
257 
258 - (void)dealloc {
259     [_encoderStates release];
260     [super dealloc];
261 }
262 
263 - (void)setContext:(MTLContex * _Nonnull)mtlc {
264     self-&gt;_mtlc = mtlc;
265     [self-&gt;_encoderStates setContext:mtlc];
266 }
267 
268 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getRenderEncoder:(const BMTLSDOps * _Nonnull)dstOps
269 {
270     return [self getRenderEncoder:dstOps-&gt;pTexture isDstOpaque:dstOps-&gt;isOpaque];
271 }
272 
273 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull)getAARenderEncoder:(const BMTLSDOps * _Nonnull)dstOps {
274   id&lt;MTLTexture&gt; dstTxt = dstOps-&gt;pTexture;
<span class="line-modified">275   return [self getEncoder:dstTxt</span>
<span class="line-modified">276                  isOpaque:dstOps-&gt;isOpaque</span>
<span class="line-removed">277                 isTexture:JNI_FALSE</span>
<span class="line-removed">278            interpolation:INTERPOLATION_NEAREST_NEIGHBOR</span>
<span class="line-removed">279                      isAA:JNI_TRUE</span>
<span class="line-removed">280                  srcFlags:NULL];</span>
281 }
282 
283 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull)getRenderEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
284                                              isDstOpaque:(bool)isOpaque
285 {
<span class="line-modified">286     return [self getEncoder:dest</span>
<span class="line-modified">287                  isOpaque:isOpaque</span>
<span class="line-removed">288                 isTexture:JNI_FALSE</span>
<span class="line-removed">289             interpolation:INTERPOLATION_NEAREST_NEIGHBOR</span>
<span class="line-removed">290                      isAA:JNI_FALSE</span>
<span class="line-removed">291                  srcFlags:NULL];</span>
292 }
293 
294 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(const BMTLSDOps * _Nonnull)dstOps
295                                       isSrcOpaque:(bool)isSrcOpaque
296 {
297     return [self getTextureEncoder:dstOps-&gt;pTexture
298                        isSrcOpaque:isSrcOpaque
299                        isDstOpaque:dstOps-&gt;isOpaque
300                      interpolation:INTERPOLATION_NEAREST_NEIGHBOR];
301 }
302 
303 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
304                                                isSrcOpaque:(bool)isSrcOpaque
305                                                isDstOpaque:(bool)isDstOpaque
306 {
307     return [self getTextureEncoder:dest
308                        isSrcOpaque:isSrcOpaque
309                        isDstOpaque:isDstOpaque
310                      interpolation:INTERPOLATION_NEAREST_NEIGHBOR
311                               isAA:JNI_FALSE];
312 }
313 
314 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
315                                       isSrcOpaque:(bool)isSrcOpaque
316                                       isDstOpaque:(bool)isDstOpaque
317                                     interpolation:(int)interpolation
318                                              isAA:(jboolean)isAA
319 {
<span class="line-modified">320     SurfaceRasterFlags srcFlags = { isSrcOpaque, JNI_TRUE };</span>
<span class="line-modified">321     return [self getEncoder:dest</span>
<span class="line-removed">322                    isOpaque:isDstOpaque</span>
<span class="line-removed">323                   isTexture:JNI_TRUE</span>
<span class="line-removed">324               interpolation:interpolation</span>
<span class="line-removed">325                        isAA:isAA</span>
<span class="line-removed">326                    srcFlags:&amp;srcFlags];</span>
327 }
328 
329 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
330                                                isSrcOpaque:(bool)isSrcOpaque
331                                                isDstOpaque:(bool)isDstOpaque
332                                              interpolation:(int)interpolation
333 {
334     return [self getTextureEncoder:dest isSrcOpaque:isSrcOpaque isDstOpaque:isDstOpaque interpolation:interpolation isAA:JNI_FALSE];
335 }
336 
<span class="line-modified">337 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull)</span>
<span class="line-modified">338     getEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest</span>
<span class="line-modified">339       isOpaque:(jboolean)isOpaque</span>
<span class="line-removed">340      isTexture:(jboolean)isTexture</span>
<span class="line-removed">341  interpolation:(int)interpolation</span>
<span class="line-removed">342           isAA:(jboolean)isAA</span>
<span class="line-removed">343       srcFlags:(const SurfaceRasterFlags *_Nullable)srcFlags {</span>
344   //
345   // 1. check whether it&#39;s necessary to call endEncoder
346   //
347   jboolean needEnd = JNI_FALSE;
348   if (_encoder != nil) {
<span class="line-modified">349     if (_destination != dest || isAA != _encoderStates.aa) {</span>
350       J2dTraceLn2(J2D_TRACE_VERBOSE,
351                   &quot;end common encoder because of dest change: %p -&gt; %p&quot;,
352                   _destination, dest);
353       needEnd = JNI_TRUE;
354     } else if ((_useStencil == NO) != ([_mtlc.clip isShape] == NO)) {
355       // 1. When mode changes RECT -&gt; SHAPE we must recreate encoder with
356       // stencilAttachment (todo: consider the case when current encoder already
357       // has stencil)
358       //
359       // 2. When mode changes SHAPE -&gt; RECT it seems that we can use the same
360       // encoder with disabled stencil test, but [encoder
361       // setDepthStencilState:nil] causes crash, so we have to recreate encoder
362       // in such case
363       J2dTraceLn2(J2D_TRACE_VERBOSE,
364                   &quot;end common encoder because toggle stencil: %d -&gt; %d&quot;,
365                   (int)_useStencil, (int)[_mtlc.clip isShape]);
366       needEnd = JNI_TRUE;
367     }
368   }
369   if (needEnd)
370     [self endEncoder];
371 
372   //
373   // 2. recreate encoder if necessary
374   //
375   jboolean forceUpdate = JNI_FALSE;
376 #ifdef ALWAYS_UPDATE_ENCODER_STATES
377   forceUpdate = JNI_TRUE;
378 #endif // ALWAYS_UPDATE_ENCODER_STATES
379 
380   if (_encoder == nil) {
381     _destination = dest;
382     _useStencil = [_mtlc.clip isShape];
383     forceUpdate = JNI_TRUE;
384 
385     MTLCommandBufferWrapper *cbw = [_mtlc getCommandBufferWrapper];
386     MTLRenderPassDescriptor *rpd =
387         [MTLRenderPassDescriptor renderPassDescriptor];
388     MTLRenderPassColorAttachmentDescriptor *ca = rpd.colorAttachments[0];
<span class="line-modified">389     if (isAA &amp;&amp; !isTexture) {</span>
390       MTLTexturePoolItem *tiBuf = [_mtlc.texturePool getTexture:dest.width
391                                                       height:dest.height
392                                                       format:MTLPixelFormatBGRA8Unorm];
393       [cbw registerPooledTexture:tiBuf];
394       [tiBuf release];
395       _aaDestination = tiBuf.texture;
396 
397       MTLTexturePoolItem *ti = [_mtlc.texturePool getTexture:dest.width
398                                                       height:dest.height
399                                                       format:_aaDestination.pixelFormat
400                                                isMultiSample:YES];
401       [cbw registerPooledTexture:ti];
402       [ti release];
403       ca.texture = ti.texture;
404       ca.resolveTexture = _aaDestination;
405       ca.clearColor = MTLClearColorMake(0.0f, 0.0f, 0.0f, 0.0f);
406       ca.loadAction = MTLLoadActionClear;
407       ca.storeAction = MTLStoreActionMultisampleResolve;
408     } else {
409       ca.texture = dest;
410       ca.loadAction = MTLLoadActionLoad;
411       ca.storeAction = MTLStoreActionStore;
412     }
413 
<span class="line-modified">414     if (_useStencil &amp;&amp; !isAA) {</span>
415         // If you enable stencil testing or stencil writing, the
416         // MTLRenderPassDescriptor must include a stencil attachment.
417         rpd.stencilAttachment.loadAction = MTLLoadActionLoad;
418         rpd.stencilAttachment.storeAction = MTLStoreActionStore;
419         rpd.stencilAttachment.texture = _mtlc.clip.stencilTextureRef;
420     }
421 
422     // J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;created render encoder to draw on
423     // tex=%p&quot;, dest);
424     _encoder = [[cbw getCommandBuffer] renderCommandEncoderWithDescriptor:rpd];
425     [rpd release];
426 
427     [_encoderStates reset:dest
<span class="line-modified">428                isDstOpaque:isOpaque</span>
429         isDstPremultiplied:YES
<span class="line-modified">430                       isAA:isAA];</span>
431   }
432 
433   //
434   // 3. update encoder states
435   //
436   [_encoderStates updateEncoder:_encoder
<span class="line-modified">437                           paint:_mtlc.paint</span>
<span class="line-modified">438                       composite:_mtlc.composite</span>
<span class="line-removed">439                       isTexture:isTexture</span>
<span class="line-removed">440                   interpolation:interpolation</span>
<span class="line-removed">441                            isAA:isAA</span>
<span class="line-removed">442                        srcFlags:srcFlags</span>
<span class="line-removed">443                            clip:_mtlc.clip</span>
<span class="line-removed">444                       transform:_mtlc.transform</span>
445                     forceUpdate:forceUpdate];
446 
447   return _encoder;
448 }
449 
450 - (id&lt;MTLBlitCommandEncoder&gt; _Nonnull) createBlitEncoder {
451     [self endEncoder];
452     return [[[_mtlc getCommandBufferWrapper] getCommandBuffer] blitCommandEncoder];
453 }
454 
455 - (void) endEncoder {
456     if (_encoder != nil) {
457       [_encoder endEncoding];
458       [_encoder release];
459       _encoder = nil;
460         if (_aaDestination != nil) {
461           id&lt;MTLTexture&gt; aaDest = _aaDestination;
462           _aaDestination = nil;
463           NSUInteger _w = _destination.width;
464           NSUInteger _h = _destination.height;
</pre>
</td>
<td>
<hr />
<pre>
  4 #import &quot;common.h&quot;
  5 
  6 // NOTE: uncomment to disable comparing cached encoder states with requested (for debugging)
  7 // #define ALWAYS_UPDATE_ENCODER_STATES
  8 
  9 const SurfaceRasterFlags defaultRasterFlags = { JNI_FALSE, JNI_TRUE };
 10 
 11 // Internal utility class that represents the set of &#39;mutable&#39; encoder properties
 12 @interface EncoderStates : NSObject
 13 @property (readonly) MTLClip * clip;
 14 
 15 - (id)init;
 16 - (void)dealloc;
 17 
 18 - (void)reset:(id&lt;MTLTexture&gt;)destination
 19            isDstOpaque:(jboolean)isDstOpaque
 20     isDstPremultiplied:(jboolean)isDstPremultiplied
 21                   isAA:(jboolean)isAA;
 22 
 23 - (void)updateEncoder:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified"> 24               context:(MTLContext *)mtlc</span>
<span class="line-modified"> 25         renderOptions:(const RenderOptions *)renderOptions</span>





 26           forceUpdate:(jboolean)forceUpdate;
 27 @property jboolean aa;
 28 @end
 29 
 30 @implementation EncoderStates {
 31     MTLPipelineStatesStorage * _pipelineStateStorage;
 32     id&lt;MTLDevice&gt; _device;
 33 
 34     // Persistent encoder properties
 35     id&lt;MTLTexture&gt; _destination;
 36     SurfaceRasterFlags _dstFlags;
 37 
 38     jboolean _isAA;
 39 
 40     //
 41     // Cached &#39;mutable&#39; states of encoder
 42     //
 43 
 44     // Composite rule and source raster flags (it affects the CAD-multipliers (of pipelineState))
 45     MTLComposite * _composite;
</pre>
<hr />
<pre>
 79     [super dealloc];
 80 }
 81 
 82 - (void)setContext:(MTLContext * _Nonnull)mtlc {
 83     self-&gt;_pipelineStateStorage = mtlc.pipelineStateStorage;
 84     self-&gt;_device = mtlc.device;
 85 }
 86 
 87 - (void)reset:(id&lt;MTLTexture&gt;)destination
 88            isDstOpaque:(jboolean)isDstOpaque
 89     isDstPremultiplied:(jboolean)isDstPremultiplied
 90                   isAA:(jboolean)isAA {
 91     _destination = destination;
 92     _dstFlags.isOpaque = isDstOpaque;
 93     _dstFlags.isPremultiplied = isDstPremultiplied;
 94     _isAA = isAA;
 95     // NOTE: probably it&#39;s better to invalidate/reset all cached states now
 96 }
 97 
 98 - (void)updateEncoder:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified"> 99               context:(MTLContext *)mtlc</span>
<span class="line-modified">100         renderOptions:(const RenderOptions *)renderOptions</span>






101           forceUpdate:(jboolean)forceUpdate
102 {
103     // 1. Process special case for stencil mask generation
<span class="line-modified">104     if (mtlc.clip.stencilMaskGenerationInProgress == JNI_TRUE) {</span>
105         // use separate pipeline state for stencil generation
106         if (forceUpdate || (_clip.stencilMaskGenerationInProgress != JNI_TRUE)) {
<span class="line-modified">107             [_clip copyFrom:mtlc.clip];</span>
108             [_clip setMaskGenerationPipelineState:encoder
109                                         destWidth:_destination.width
110                                        destHeight:_destination.height
111                              pipelineStateStorage:_pipelineStateStorage];
112         }
113 
<span class="line-modified">114         [self updateTransform:encoder transform:mtlc.transform forceUpdate:forceUpdate];</span>
115         return;
116     }
117 
118     // 2. Otherwise update all &#39;mutable&#39; properties of encoder
119     [self updatePipelineState:encoder
<span class="line-modified">120                       context:mtlc</span>
<span class="line-modified">121                 renderOptions:renderOptions</span>





122                   forceUpdate:forceUpdate];
<span class="line-modified">123     [self updateTransform:encoder transform:mtlc.transform forceUpdate:forceUpdate];</span>
<span class="line-modified">124     [self updateClip:encoder clip:mtlc.clip forceUpdate:forceUpdate];</span>
125 }
126 
127 //
128 // Internal methods that update states when necessary (compare with cached states)
129 //
130 
131 // Updates pipelineState (and corresponding buffers) with use of paint+composite+flags
132 - (void)updatePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified">133                     context:(MTLContext *)mtlc</span>
<span class="line-modified">134               renderOptions:(const RenderOptions *)renderOptions</span>





135                 forceUpdate:(jboolean)forceUpdate
136 {



137     if (!forceUpdate
<span class="line-modified">138         &amp;&amp; [_paint isEqual:mtlc.paint]</span>
<span class="line-modified">139         &amp;&amp; [_composite isEqual:mtlc.composite]</span>
<span class="line-modified">140         &amp;&amp; (_isTexture == renderOptions-&gt;isTexture &amp;&amp; (!renderOptions-&gt;isTexture || _interpolationMode == renderOptions-&gt;interpolation)) // interpolation is used only in texture mode</span>
<span class="line-modified">141         &amp;&amp; _isAA == renderOptions-&gt;isAA</span>
<span class="line-modified">142         &amp;&amp; _srcFlags.isOpaque == renderOptions-&gt;srcFlags.isOpaque &amp;&amp; _srcFlags.isPremultiplied == renderOptions-&gt;srcFlags.isPremultiplied)</span>
143         return;
144 
<span class="line-modified">145     [_paint copyFrom:mtlc.paint];</span>
<span class="line-modified">146     [_composite copyFrom:mtlc.composite];</span>
<span class="line-modified">147     _isTexture = renderOptions-&gt;isTexture;</span>
<span class="line-modified">148     _interpolationMode = renderOptions-&gt;interpolation;</span>
<span class="line-modified">149     _isAA = renderOptions-&gt;isAA;</span>
<span class="line-modified">150     _srcFlags = renderOptions-&gt;srcFlags;</span>
<span class="line-modified">151 </span>
<span class="line-modified">152     if ((jint)[mtlc.composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR) {</span>
<span class="line-modified">153         [mtlc.paint setXorModePipelineState:encoder</span>
<span class="line-modified">154                                context:mtlc</span>
<span class="line-modified">155                          renderOptions:renderOptions</span>
<span class="line-modified">156                   pipelineStateStorage:_pipelineStateStorage];</span>




157     } else {
<span class="line-modified">158         [mtlc.paint setPipelineState:encoder</span>
<span class="line-modified">159                         context:mtlc</span>
<span class="line-modified">160                   renderOptions:renderOptions</span>





161            pipelineStateStorage:_pipelineStateStorage];
162     }
163 }
164 
165 - (void) updateClip:(id&lt;MTLRenderCommandEncoder&gt;)encoder clip:(MTLClip *)clip forceUpdate:(jboolean)forceUpdate
166 {
167     if (clip.stencilMaskGenerationInProgress == JNI_TRUE) {
168         // don&#39;t set setScissorOrStencil when generateion in progress
169         return;
170     }
171 
172     if (!forceUpdate &amp;&amp; [_clip isEqual:clip])
173         return;
174 
175     [_clip copyFrom:clip];
176     [_clip setScissorOrStencil:encoder
177                      destWidth:_destination.width
178                     destHeight:_destination.height
179                         device:_device];
180 }
</pre>
<hr />
<pre>
222     return self;
223 }
224 
225 - (void)dealloc {
226     [_encoderStates release];
227     [super dealloc];
228 }
229 
230 - (void)setContext:(MTLContex * _Nonnull)mtlc {
231     self-&gt;_mtlc = mtlc;
232     [self-&gt;_encoderStates setContext:mtlc];
233 }
234 
235 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getRenderEncoder:(const BMTLSDOps * _Nonnull)dstOps
236 {
237     return [self getRenderEncoder:dstOps-&gt;pTexture isDstOpaque:dstOps-&gt;isOpaque];
238 }
239 
240 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull)getAARenderEncoder:(const BMTLSDOps * _Nonnull)dstOps {
241   id&lt;MTLTexture&gt; dstTxt = dstOps-&gt;pTexture;
<span class="line-modified">242   RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps-&gt;isOpaque, JNI_TRUE}};</span>
<span class="line-modified">243   return [self getEncoder:dstTxt renderOptions:&amp;roptions];</span>




244 }
245 
246 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull)getRenderEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
247                                              isDstOpaque:(bool)isOpaque
248 {
<span class="line-modified">249     RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}};</span>
<span class="line-modified">250     return [self getEncoder:dest renderOptions:&amp;roptions];</span>




251 }
252 
253 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(const BMTLSDOps * _Nonnull)dstOps
254                                       isSrcOpaque:(bool)isSrcOpaque
255 {
256     return [self getTextureEncoder:dstOps-&gt;pTexture
257                        isSrcOpaque:isSrcOpaque
258                        isDstOpaque:dstOps-&gt;isOpaque
259                      interpolation:INTERPOLATION_NEAREST_NEIGHBOR];
260 }
261 
262 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
263                                                isSrcOpaque:(bool)isSrcOpaque
264                                                isDstOpaque:(bool)isDstOpaque
265 {
266     return [self getTextureEncoder:dest
267                        isSrcOpaque:isSrcOpaque
268                        isDstOpaque:isDstOpaque
269                      interpolation:INTERPOLATION_NEAREST_NEIGHBOR
270                               isAA:JNI_FALSE];
271 }
272 
273 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
274                                       isSrcOpaque:(bool)isSrcOpaque
275                                       isDstOpaque:(bool)isDstOpaque
276                                     interpolation:(int)interpolation
277                                              isAA:(jboolean)isAA
278 {
<span class="line-modified">279     RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}};</span>
<span class="line-modified">280     return [self getEncoder:dest renderOptions:&amp;roptions];</span>





281 }
282 
283 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getTextureEncoder:(id&lt;MTLTexture&gt; _Nonnull)dest
284                                                isSrcOpaque:(bool)isSrcOpaque
285                                                isDstOpaque:(bool)isDstOpaque
286                                              interpolation:(int)interpolation
287 {
288     return [self getTextureEncoder:dest isSrcOpaque:isSrcOpaque isDstOpaque:isDstOpaque interpolation:interpolation isAA:JNI_FALSE];
289 }
290 
<span class="line-modified">291 - (id&lt;MTLRenderCommandEncoder&gt; _Nonnull) getEncoder:(id &lt;MTLTexture&gt; _Nonnull)dest</span>
<span class="line-modified">292                                       renderOptions:(const RenderOptions * _Nonnull)renderOptions</span>
<span class="line-modified">293 {</span>




294   //
295   // 1. check whether it&#39;s necessary to call endEncoder
296   //
297   jboolean needEnd = JNI_FALSE;
298   if (_encoder != nil) {
<span class="line-modified">299     if (_destination != dest || renderOptions-&gt;isAA != _encoderStates.aa) {</span>
300       J2dTraceLn2(J2D_TRACE_VERBOSE,
301                   &quot;end common encoder because of dest change: %p -&gt; %p&quot;,
302                   _destination, dest);
303       needEnd = JNI_TRUE;
304     } else if ((_useStencil == NO) != ([_mtlc.clip isShape] == NO)) {
305       // 1. When mode changes RECT -&gt; SHAPE we must recreate encoder with
306       // stencilAttachment (todo: consider the case when current encoder already
307       // has stencil)
308       //
309       // 2. When mode changes SHAPE -&gt; RECT it seems that we can use the same
310       // encoder with disabled stencil test, but [encoder
311       // setDepthStencilState:nil] causes crash, so we have to recreate encoder
312       // in such case
313       J2dTraceLn2(J2D_TRACE_VERBOSE,
314                   &quot;end common encoder because toggle stencil: %d -&gt; %d&quot;,
315                   (int)_useStencil, (int)[_mtlc.clip isShape]);
316       needEnd = JNI_TRUE;
317     }
318   }
319   if (needEnd)
320     [self endEncoder];
321 
322   //
323   // 2. recreate encoder if necessary
324   //
325   jboolean forceUpdate = JNI_FALSE;
326 #ifdef ALWAYS_UPDATE_ENCODER_STATES
327   forceUpdate = JNI_TRUE;
328 #endif // ALWAYS_UPDATE_ENCODER_STATES
329 
330   if (_encoder == nil) {
331     _destination = dest;
332     _useStencil = [_mtlc.clip isShape];
333     forceUpdate = JNI_TRUE;
334 
335     MTLCommandBufferWrapper *cbw = [_mtlc getCommandBufferWrapper];
336     MTLRenderPassDescriptor *rpd =
337         [MTLRenderPassDescriptor renderPassDescriptor];
338     MTLRenderPassColorAttachmentDescriptor *ca = rpd.colorAttachments[0];
<span class="line-modified">339     if (renderOptions-&gt;isAA &amp;&amp; !renderOptions-&gt;isTexture) {</span>
340       MTLTexturePoolItem *tiBuf = [_mtlc.texturePool getTexture:dest.width
341                                                       height:dest.height
342                                                       format:MTLPixelFormatBGRA8Unorm];
343       [cbw registerPooledTexture:tiBuf];
344       [tiBuf release];
345       _aaDestination = tiBuf.texture;
346 
347       MTLTexturePoolItem *ti = [_mtlc.texturePool getTexture:dest.width
348                                                       height:dest.height
349                                                       format:_aaDestination.pixelFormat
350                                                isMultiSample:YES];
351       [cbw registerPooledTexture:ti];
352       [ti release];
353       ca.texture = ti.texture;
354       ca.resolveTexture = _aaDestination;
355       ca.clearColor = MTLClearColorMake(0.0f, 0.0f, 0.0f, 0.0f);
356       ca.loadAction = MTLLoadActionClear;
357       ca.storeAction = MTLStoreActionMultisampleResolve;
358     } else {
359       ca.texture = dest;
360       ca.loadAction = MTLLoadActionLoad;
361       ca.storeAction = MTLStoreActionStore;
362     }
363 
<span class="line-modified">364     if (_useStencil &amp;&amp; !renderOptions-&gt;isAA) {</span>
365         // If you enable stencil testing or stencil writing, the
366         // MTLRenderPassDescriptor must include a stencil attachment.
367         rpd.stencilAttachment.loadAction = MTLLoadActionLoad;
368         rpd.stencilAttachment.storeAction = MTLStoreActionStore;
369         rpd.stencilAttachment.texture = _mtlc.clip.stencilTextureRef;
370     }
371 
372     // J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;created render encoder to draw on
373     // tex=%p&quot;, dest);
374     _encoder = [[cbw getCommandBuffer] renderCommandEncoderWithDescriptor:rpd];
375     [rpd release];
376 
377     [_encoderStates reset:dest
<span class="line-modified">378                isDstOpaque:renderOptions-&gt;dstFlags.isOpaque</span>
379         isDstPremultiplied:YES
<span class="line-modified">380                       isAA:renderOptions-&gt;isAA];</span>
381   }
382 
383   //
384   // 3. update encoder states
385   //
386   [_encoderStates updateEncoder:_encoder
<span class="line-modified">387                         context:_mtlc</span>
<span class="line-modified">388                   renderOptions:renderOptions</span>






389                     forceUpdate:forceUpdate];
390 
391   return _encoder;
392 }
393 
394 - (id&lt;MTLBlitCommandEncoder&gt; _Nonnull) createBlitEncoder {
395     [self endEncoder];
396     return [[[_mtlc getCommandBufferWrapper] getCommandBuffer] blitCommandEncoder];
397 }
398 
399 - (void) endEncoder {
400     if (_encoder != nil) {
401       [_encoder endEncoding];
402       [_encoder release];
403       _encoder = nil;
404         if (_aaDestination != nil) {
405           id&lt;MTLTexture&gt; aaDest = _aaDestination;
406           _aaDestination = nil;
407           NSUInteger _w = _destination.width;
408           NSUInteger _h = _destination.height;
</pre>
</td>
</tr>
</table>
<center><a href="EncoderManager.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLBufImgOps.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
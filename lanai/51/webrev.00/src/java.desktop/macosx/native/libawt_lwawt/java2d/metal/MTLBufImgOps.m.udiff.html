<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLBufImgOps.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,347 +31,197 @@</span>
  #include &quot;MTLContext.h&quot;
  #include &quot;MTLRenderQueue.h&quot;
  #include &quot;MTLSurfaceDataBase.h&quot;
  #include &quot;GraphicsPrimitiveMgr.h&quot;
  
<span class="udiff-line-modified-removed">- /** Evaluates to true if the given bit is set on the local flags variable. */</span>
<span class="udiff-line-modified-removed">- #define IS_SET(flagbit) \</span>
<span class="udiff-line-modified-removed">-     (((flags) &amp; (flagbit)) != 0)</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- /**************************** ConvolveOp support ****************************/</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * The ConvolveOp shader is fairly straightforward.  For each texel in</span>
<span class="udiff-line-removed">-  * the source texture, the shader samples the MxN texels in the surrounding</span>
<span class="udiff-line-removed">-  * area, multiplies each by its corresponding kernel value, and then sums</span>
<span class="udiff-line-removed">-  * them all together to produce a single color result.  Finally, the</span>
<span class="udiff-line-removed">-  * resulting value is multiplied by the current OpenGL color, which contains</span>
<span class="udiff-line-removed">-  * the extra alpha value.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.</span>
<span class="udiff-line-removed">-  * This allows us to build different shader programs (e.g. one for</span>
<span class="udiff-line-removed">-  * 3x3, one for 5x5, and so on) simply by filling in these &quot;holes&quot; with</span>
<span class="udiff-line-removed">-  * a call to sprintf().  See the MTLBufImgOps_CreateConvolveProgram() method</span>
<span class="udiff-line-removed">-  * for more details.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * REMIND: Currently this shader (and the supporting code in the</span>
<span class="udiff-line-removed">-  *         EnableConvolveOp() method) only supports 3x3 and 5x5 filters.</span>
<span class="udiff-line-removed">-  *         Early shader-level hardware did not support non-constant sized</span>
<span class="udiff-line-removed">-  *         arrays but modern hardware should support them (although I</span>
<span class="udiff-line-removed">-  *         don&#39;t know of any simple way to find out, other than to compile</span>
<span class="udiff-line-removed">-  *         the shader at runtime and see if the drivers complain).</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static const char *convolveShaderSource =</span>
<span class="udiff-line-removed">-     // maximum size supported by this shader</span>
<span class="udiff-line-removed">-     &quot;const int MAX_KERNEL_SIZE = %s;&quot;</span>
<span class="udiff-line-removed">-     // image to be convolved</span>
<span class="udiff-line-removed">-     &quot;uniform sampler%s baseImage;&quot;</span>
<span class="udiff-line-removed">-     // image edge limits:</span>
<span class="udiff-line-removed">-     //   imgEdge.xy = imgMin.xy (anything &lt; will be treated as edge case)</span>
<span class="udiff-line-removed">-     //   imgEdge.zw = imgMax.xy (anything &gt; will be treated as edge case)</span>
<span class="udiff-line-removed">-     &quot;uniform vec4 imgEdge;&quot;</span>
<span class="udiff-line-removed">-     // value for each location in the convolution kernel:</span>
<span class="udiff-line-removed">-     //   kernelVals[i].x = offsetX[i]</span>
<span class="udiff-line-removed">-     //   kernelVals[i].y = offsetY[i]</span>
<span class="udiff-line-removed">-     //   kernelVals[i].z = kernel[i]</span>
<span class="udiff-line-removed">-     &quot;uniform vec3 kernelVals[MAX_KERNEL_SIZE];&quot;</span>
<span class="udiff-line-removed">-     &quot;&quot;</span>
<span class="udiff-line-removed">-     &quot;void main(void)&quot;</span>
<span class="udiff-line-removed">-     &quot;{&quot;</span>
<span class="udiff-line-removed">-     &quot;    int i;&quot;</span>
<span class="udiff-line-removed">-     &quot;    vec4 sum;&quot;</span>
<span class="udiff-line-removed">-     &quot;&quot;</span>
<span class="udiff-line-removed">-     &quot;    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||&quot;</span>
<span class="udiff-line-removed">-     &quot;        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))&quot;</span>
<span class="udiff-line-removed">-     &quot;    {&quot;</span>
<span class="udiff-line-removed">-              // (placeholder for edge condition code)</span>
<span class="udiff-line-removed">-     &quot;        %s&quot;</span>
<span class="udiff-line-removed">-     &quot;    } else {&quot;</span>
<span class="udiff-line-removed">-     &quot;        sum = vec4(0.0);&quot;</span>
<span class="udiff-line-removed">-     &quot;        for (i = 0; i &lt; MAX_KERNEL_SIZE; i++) {&quot;</span>
<span class="udiff-line-removed">-     &quot;            sum +=&quot;</span>
<span class="udiff-line-removed">-     &quot;                kernelVals[i].z *&quot;</span>
<span class="udiff-line-removed">-     &quot;                texture%s(baseImage,&quot;</span>
<span class="udiff-line-removed">-     &quot;                          gl_TexCoord[0].st + kernelVals[i].xy);&quot;</span>
<span class="udiff-line-removed">-     &quot;        }&quot;</span>
<span class="udiff-line-removed">-     &quot;    }&quot;</span>
<span class="udiff-line-removed">-     &quot;&quot;</span>
<span class="udiff-line-removed">-          // modulate with gl_Color in order to apply extra alpha</span>
<span class="udiff-line-removed">-     &quot;    gl_FragColor = sum * gl_Color;&quot;</span>
<span class="udiff-line-removed">-     &quot;}&quot;;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * Flags that can be bitwise-or&#39;ed together to control how the shader</span>
<span class="udiff-line-removed">-  * source code is generated.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- #define CONVOLVE_RECT            (1 &lt;&lt; 0)</span>
<span class="udiff-line-removed">- #define CONVOLVE_EDGE_ZERO_FILL  (1 &lt;&lt; 1)</span>
<span class="udiff-line-removed">- #define CONVOLVE_5X5             (1 &lt;&lt; 2)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * The handles to the ConvolveOp fragment program objects.  The index to</span>
<span class="udiff-line-removed">-  * the array should be a bitwise-or&#39;ing of the CONVOLVE_* flags defined</span>
<span class="udiff-line-removed">-  * above.  Note that most applications will likely need to initialize one</span>
<span class="udiff-line-removed">-  * or two of these elements, so the array is usually sparsely populated.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static GLhandleARB convolvePrograms[8];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * The maximum kernel size supported by the ConvolveOp shader.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- #define MAX_KERNEL_SIZE 25</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * Compiles and links the ConvolveOp shader program.  If successful, this</span>
<span class="udiff-line-removed">-  * function returns a handle to the newly created shader program; otherwise</span>
<span class="udiff-line-removed">-  * returns 0.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static GLhandleARB</span>
<span class="udiff-line-removed">- MTLBufImgOps_CreateConvolveProgram(jint flags)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateConvolveProgram -- :TODO&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-modified-added">+ @implementation MTLRescaleOp {</span>
<span class="udiff-line-modified-added">+     jboolean _isNonPremult;</span>
<span class="udiff-line-modified-added">+     jfloat _normScaleFactors[4];</span>
<span class="udiff-line-modified-added">+     jfloat _normOffsets[4];</span>
  }
  
<span class="udiff-line-modified-removed">- void</span>
<span class="udiff-line-modified-removed">- MTLBufImgOps_EnableConvolveOp(MTLContext *mtlc, jlong pSrcOps,</span>
<span class="udiff-line-modified-removed">-                               jboolean edgeZeroFill,</span>
<span class="udiff-line-modified-removed">-                               jint kernelWidth, jint kernelHeight,</span>
<span class="udiff-line-modified-removed">-                               unsigned char *kernel)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableConvolveOp -- :TODO&quot;);</span>
<span class="udiff-line-modified-added">+ -(jfloat *) getScaleFactors {</span>
<span class="udiff-line-modified-added">+     return _normScaleFactors;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ -(jfloat *) getOffsets {</span>
<span class="udiff-line-modified-added">+     return _normOffsets;</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-added">+ - (id)init:(jboolean)isNonPremult factors:(unsigned char *)factors offsets:(unsigned char *)offsets {</span>
<span class="udiff-line-added">+     self = [super init];</span>
<span class="udiff-line-added">+     if (self) {</span>
<span class="udiff-line-added">+         J2dTraceLn1(J2D_TRACE_INFO,&quot;Created MTLRescaleOp: isNonPremult=%d&quot;, isNonPremult);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         _isNonPremult = isNonPremult;</span>
<span class="udiff-line-added">+         _normScaleFactors[0] = NEXT_FLOAT(factors);</span>
<span class="udiff-line-added">+         _normScaleFactors[1] = NEXT_FLOAT(factors);</span>
<span class="udiff-line-added">+         _normScaleFactors[2] = NEXT_FLOAT(factors);</span>
<span class="udiff-line-added">+         _normScaleFactors[3] = NEXT_FLOAT(factors);</span>
<span class="udiff-line-added">+         _normOffsets[0] = NEXT_FLOAT(offsets);</span>
<span class="udiff-line-added">+         _normOffsets[1] = NEXT_FLOAT(offsets);</span>
<span class="udiff-line-added">+         _normOffsets[2] = NEXT_FLOAT(offsets);</span>
<span class="udiff-line-added">+         _normOffsets[3] = NEXT_FLOAT(offsets);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return self;</span>
  }
  
<span class="udiff-line-modified-removed">- void</span>
<span class="udiff-line-modified-removed">- MTLBufImgOps_DisableConvolveOp(MTLContext *mtlc)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableConvolveOp -- :TODO&quot;);</span>
<span class="udiff-line-modified-added">+ - (NSString *)getDescription {</span>
<span class="udiff-line-modified-added">+     return [NSString stringWithFormat:@&quot;rescale: nonPremult=%d&quot;, _isNonPremult];</span>
  }
<span class="udiff-line-added">+ @end</span>
  
<span class="udiff-line-modified-removed">- /**************************** RescaleOp support *****************************/</span>
<span class="udiff-line-modified-added">+ @implementation MTLConvolveOp {</span>
<span class="udiff-line-added">+     id&lt;MTLBuffer&gt; _buffer;</span>
<span class="udiff-line-added">+     float _imgEdge[4];</span>
<span class="udiff-line-added">+     int _kernelSize;</span>
<span class="udiff-line-added">+     jboolean _isEdgeZeroFill;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- /**</span>
<span class="udiff-line-modified-removed">-  * The RescaleOp shader is one of the simplest possible.  Each fragment</span>
<span class="udiff-line-modified-removed">-  * from the source image is multiplied by the user&#39;s scale factor and added</span>
<span class="udiff-line-modified-removed">-  * to the user&#39;s offset value (these are component-wise operations).</span>
<span class="udiff-line-modified-removed">-  * Finally, the resulting value is multiplied by the current OpenGL color,</span>
<span class="udiff-line-modified-removed">-  * which contains the extra alpha value.</span>
<span class="udiff-line-modified-removed">-  *</span>
<span class="udiff-line-modified-removed">-  * The RescaleOp spec says that the operation is performed regardless of</span>
<span class="udiff-line-modified-removed">-  * whether the source data is premultiplied or non-premultiplied.  This is</span>
<span class="udiff-line-modified-removed">-  * a problem for the OpenGL pipeline in that a non-premultiplied</span>
<span class="udiff-line-modified-removed">-  * BufferedImage will have already been converted into premultiplied</span>
<span class="udiff-line-modified-removed">-  * when uploaded to an OpenGL texture.  Therefore, we have a special mode</span>
<span class="udiff-line-modified-removed">-  * called RESCALE_NON_PREMULT (used only for source images that were</span>
<span class="udiff-line-modified-removed">-  * originally non-premultiplied) that un-premultiplies the source color</span>
<span class="udiff-line-modified-removed">-  * prior to the rescale operation, then re-premultiplies the resulting</span>
<span class="udiff-line-modified-removed">-  * color before returning from the fragment shader.</span>
<span class="udiff-line-modified-removed">-  *</span>
<span class="udiff-line-modified-removed">-  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.</span>
<span class="udiff-line-modified-removed">-  * This allows us to build different shader programs (e.g. one for</span>
<span class="udiff-line-modified-removed">-  * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)</span>
<span class="udiff-line-modified-removed">-  * simply by filling in these &quot;holes&quot; with a call to sprintf().  See the</span>
<span class="udiff-line-modified-removed">-  * MTLBufImgOps_CreateRescaleProgram() method for more details.</span>
<span class="udiff-line-modified-removed">-  */</span>
<span class="udiff-line-modified-removed">- static const char *rescaleShaderSource =</span>
<span class="udiff-line-modified-removed">-     // image to be rescaled</span>
<span class="udiff-line-modified-removed">-     &quot;uniform sampler%s baseImage;&quot;</span>
<span class="udiff-line-modified-removed">-     // vector containing scale factors</span>
<span class="udiff-line-modified-removed">-     &quot;uniform vec4 scaleFactors;&quot;</span>
<span class="udiff-line-modified-removed">-     // vector containing offsets</span>
<span class="udiff-line-modified-removed">-     &quot;uniform vec4 offsets;&quot;</span>
<span class="udiff-line-modified-removed">-     &quot;&quot;</span>
<span class="udiff-line-modified-removed">-     &quot;void main(void)&quot;</span>
<span class="udiff-line-removed">-     &quot;{&quot;</span>
<span class="udiff-line-removed">-     &quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;</span>
<span class="udiff-line-removed">-          // (placeholder for un-premult code)</span>
<span class="udiff-line-removed">-     &quot;    %s&quot;</span>
<span class="udiff-line-removed">-          // rescale source value</span>
<span class="udiff-line-removed">-     &quot;    vec4 result = (srcColor * scaleFactors) + offsets;&quot;</span>
<span class="udiff-line-removed">-          // (placeholder for re-premult code)</span>
<span class="udiff-line-removed">-     &quot;    %s&quot;</span>
<span class="udiff-line-removed">-          // modulate with gl_Color in order to apply extra alpha</span>
<span class="udiff-line-removed">-     &quot;    gl_FragColor = result * gl_Color;&quot;</span>
<span class="udiff-line-removed">-     &quot;}&quot;;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * Flags that can be bitwise-or&#39;ed together to control how the shader</span>
<span class="udiff-line-removed">-  * source code is generated.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- #define RESCALE_RECT        (1 &lt;&lt; 0)</span>
<span class="udiff-line-removed">- #define RESCALE_NON_PREMULT (1 &lt;&lt; 1)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * The handles to the RescaleOp fragment program objects.  The index to</span>
<span class="udiff-line-removed">-  * the array should be a bitwise-or&#39;ing of the RESCALE_* flags defined</span>
<span class="udiff-line-removed">-  * above.  Note that most applications will likely need to initialize one</span>
<span class="udiff-line-removed">-  * or two of these elements, so the array is usually sparsely populated.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static GLhandleARB rescalePrograms[4];</span>
<span class="udiff-line-modified-added">+ - (id)init:(jboolean)edgeZeroFill kernelWidth:(jint)kernelWidth</span>
<span class="udiff-line-modified-added">+                                  kernelHeight:(jint)kernelHeight</span>
<span class="udiff-line-modified-added">+                                      srcWidth:(jint)srcWidth</span>
<span class="udiff-line-modified-added">+                                     srcHeight:(jint)srcHeight</span>
<span class="udiff-line-modified-added">+                                        kernel:(unsigned char *)kernel</span>
<span class="udiff-line-modified-added">+                                        device:(id&lt;MTLDevice&gt;)device {</span>
<span class="udiff-line-modified-added">+     self = [super init];</span>
<span class="udiff-line-modified-added">+     if (self) {</span>
<span class="udiff-line-modified-added">+         J2dTraceLn2(J2D_TRACE_INFO,&quot;Created MTLConvolveOp: kernelW=%d kernelH=%d&quot;, kernelWidth, kernelHeight);</span>
<span class="udiff-line-modified-added">+         _isEdgeZeroFill = edgeZeroFill;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         _kernelSize = kernelWidth * kernelHeight;</span>
<span class="udiff-line-modified-added">+         _buffer = [device newBufferWithLength:_kernelSize*sizeof(vector_float3) options:MTLResourceStorageModeShared];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         float * kernelVals = [_buffer contents];</span>
<span class="udiff-line-modified-added">+         int kIndex = 0;</span>
<span class="udiff-line-modified-added">+         for (int i = -kernelHeight/2; i &lt; kernelHeight/2+1; i++) {</span>
<span class="udiff-line-modified-added">+             for (int j = -kernelWidth/2; j &lt; kernelWidth/2+1; j++) {</span>
<span class="udiff-line-modified-added">+                 kernelVals[kIndex+0] = j/(float)srcWidth;</span>
<span class="udiff-line-modified-added">+                 kernelVals[kIndex+1] = i/(float)srcHeight;</span>
<span class="udiff-line-modified-added">+                 kernelVals[kIndex+2] = NEXT_FLOAT(kernel);</span>
<span class="udiff-line-modified-added">+                 kIndex += 3;</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         _imgEdge[0] = (kernelWidth/2)/(float)srcWidth;</span>
<span class="udiff-line-modified-added">+         _imgEdge[1] = (kernelHeight/2)/(float)srcHeight;</span>
<span class="udiff-line-modified-added">+         _imgEdge[2] = 1 - _imgEdge[0];</span>
<span class="udiff-line-modified-added">+         _imgEdge[3] = 1 - _imgEdge[1];</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     return self;</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">- /**</span>
<span class="udiff-line-modified-removed">-  * Compiles and links the RescaleOp shader program.  If successful, this</span>
<span class="udiff-line-modified-removed">-  * function returns a handle to the newly created shader program; otherwise</span>
<span class="udiff-line-modified-removed">-  * returns 0.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static GLhandleARB</span>
<span class="udiff-line-removed">- MTLBufImgOps_CreateRescaleProgram(jint flags)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateRescaleProgram -- :TODO&quot;);</span>
<span class="udiff-line-modified-added">+ - (void) dealloc {</span>
<span class="udiff-line-modified-added">+     [_buffer release];</span>
<span class="udiff-line-modified-added">+     [super dealloc];</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     return NULL;</span>
<span class="udiff-line-modified-added">+ - (id&lt;MTLBuffer&gt;) getBuffer {</span>
<span class="udiff-line-added">+     return _buffer;</span>
  }
  
<span class="udiff-line-modified-removed">- void</span>
<span class="udiff-line-modified-removed">- MTLBufImgOps_EnableRescaleOp(MTLContext *mtlc, jlong pSrcOps,</span>
<span class="udiff-line-removed">-                              jboolean nonPremult,</span>
<span class="udiff-line-removed">-                              unsigned char *scaleFactors,</span>
<span class="udiff-line-removed">-                              unsigned char *offsets)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableRescaleOp -- :TODO&quot;);</span>
<span class="udiff-line-modified-added">+ - (const float *) getImgEdge {</span>
<span class="udiff-line-modified-added">+     return _imgEdge;</span>
  }
  
<span class="udiff-line-modified-removed">- void</span>
<span class="udiff-line-modified-removed">- MTLBufImgOps_DisableRescaleOp(MTLContext *mtlc)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableRescaleOp -- :TODO&quot;);</span>
<span class="udiff-line-removed">-     RETURN_IF_NULL(mtlc);</span>
<span class="udiff-line-modified-added">+ - (NSString *)getDescription {</span>
<span class="udiff-line-modified-added">+     return [NSString stringWithFormat:@&quot;convolve: isEdgeZeroFill=%d&quot;, _isEdgeZeroFill];</span>
  }
<span class="udiff-line-added">+ @end</span>
  
<span class="udiff-line-removed">- /**************************** LookupOp support ******************************/</span>
  
<span class="udiff-line-modified-removed">- /**</span>
<span class="udiff-line-modified-removed">-  * The LookupOp shader takes a fragment color (from the source texture) as</span>
<span class="udiff-line-modified-removed">-  * input, subtracts the optional user offset value, and then uses the</span>
<span class="udiff-line-modified-removed">-  * resulting value to index into the lookup table texture to provide</span>
<span class="udiff-line-removed">-  * a new color result.  Finally, the resulting value is multiplied by</span>
<span class="udiff-line-removed">-  * the current OpenGL color, which contains the extra alpha value.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * The lookup step requires 3 texture accesses (or 4, when alpha is included),</span>
<span class="udiff-line-removed">-  * which is somewhat unfortunate because it&#39;s not ideal from a performance</span>
<span class="udiff-line-removed">-  * standpoint, but that sort of thing is getting faster with newer hardware.</span>
<span class="udiff-line-removed">-  * In the 3-band case, we could consider using a three-dimensional texture</span>
<span class="udiff-line-removed">-  * and performing the lookup with a single texture access step.  We already</span>
<span class="udiff-line-removed">-  * use this approach in the LCD text shader, and it works well, but for the</span>
<span class="udiff-line-removed">-  * purposes of this LookupOp shader, it&#39;s probably overkill.  Also, there&#39;s</span>
<span class="udiff-line-removed">-  * a difference in that the LCD text shader only needs to populate the 3D LUT</span>
<span class="udiff-line-removed">-  * once, but here we would need to populate it on every invocation, which</span>
<span class="udiff-line-removed">-  * would likely be a waste of VRAM and CPU/GPU cycles.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * The LUT texture is currently hardcoded as 4 rows/bands, each containing</span>
<span class="udiff-line-removed">-  * 256 elements.  This means that we currently only support user-provided</span>
<span class="udiff-line-removed">-  * tables with no more than 256 elements in each band (this is checked at</span>
<span class="udiff-line-removed">-  * at the Java level).  If the user provides a table with less than 256</span>
<span class="udiff-line-removed">-  * elements per band, our shader will still work fine, but if elements are</span>
<span class="udiff-line-removed">-  * accessed with an index &gt;= the size of the LUT, then the shader will simply</span>
<span class="udiff-line-removed">-  * produce undefined values.  Typically the user would provide an offset</span>
<span class="udiff-line-removed">-  * value that would prevent this from happening, but it&#39;s worth pointing out</span>
<span class="udiff-line-removed">-  * this fact because the software LookupOp implementation would usually</span>
<span class="udiff-line-removed">-  * throw an ArrayIndexOutOfBoundsException in this scenario (although it is</span>
<span class="udiff-line-removed">-  * not something demanded by the spec).</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * The LookupOp spec says that the operation is performed regardless of</span>
<span class="udiff-line-removed">-  * whether the source data is premultiplied or non-premultiplied.  This is</span>
<span class="udiff-line-removed">-  * a problem for the OpenGL pipeline in that a non-premultiplied</span>
<span class="udiff-line-removed">-  * BufferedImage will have already been converted into premultiplied</span>
<span class="udiff-line-removed">-  * when uploaded to an OpenGL texture.  Therefore, we have a special mode</span>
<span class="udiff-line-removed">-  * called LOOKUP_NON_PREMULT (used only for source images that were</span>
<span class="udiff-line-removed">-  * originally non-premultiplied) that un-premultiplies the source color</span>
<span class="udiff-line-removed">-  * prior to the lookup operation, then re-premultiplies the resulting</span>
<span class="udiff-line-removed">-  * color before returning from the fragment shader.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.</span>
<span class="udiff-line-removed">-  * This allows us to build different shader programs (e.g. one for</span>
<span class="udiff-line-removed">-  * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)</span>
<span class="udiff-line-removed">-  * simply by filling in these &quot;holes&quot; with a call to sprintf().  See the</span>
<span class="udiff-line-removed">-  * MTLBufImgOps_CreateLookupProgram() method for more details.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static const char *lookupShaderSource =</span>
<span class="udiff-line-removed">-     // source image (bound to texture unit 0)</span>
<span class="udiff-line-removed">-     &quot;uniform sampler%s baseImage;&quot;</span>
<span class="udiff-line-removed">-     // lookup table (bound to texture unit 1)</span>
<span class="udiff-line-removed">-     &quot;uniform sampler2D lookupTable;&quot;</span>
<span class="udiff-line-removed">-     // offset subtracted from source index prior to lookup step</span>
<span class="udiff-line-removed">-     &quot;uniform vec4 offset;&quot;</span>
<span class="udiff-line-removed">-     &quot;&quot;</span>
<span class="udiff-line-removed">-     &quot;void main(void)&quot;</span>
<span class="udiff-line-removed">-     &quot;{&quot;</span>
<span class="udiff-line-removed">-     &quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;</span>
<span class="udiff-line-removed">-          // (placeholder for un-premult code)</span>
<span class="udiff-line-removed">-     &quot;    %s&quot;</span>
<span class="udiff-line-removed">-          // subtract offset from original index</span>
<span class="udiff-line-removed">-     &quot;    vec4 srcIndex = srcColor - offset;&quot;</span>
<span class="udiff-line-removed">-          // use source value as input to lookup table (note that</span>
<span class="udiff-line-removed">-          // &quot;v&quot; texcoords are hardcoded to hit texel centers of</span>
<span class="udiff-line-removed">-          // each row/band in texture)</span>
<span class="udiff-line-removed">-     &quot;    vec4 result;&quot;</span>
<span class="udiff-line-removed">-     &quot;    result.r = texture2D(lookupTable, vec2(srcIndex.r, 0.125)).r;&quot;</span>
<span class="udiff-line-removed">-     &quot;    result.g = texture2D(lookupTable, vec2(srcIndex.g, 0.375)).r;&quot;</span>
<span class="udiff-line-removed">-     &quot;    result.b = texture2D(lookupTable, vec2(srcIndex.b, 0.625)).r;&quot;</span>
<span class="udiff-line-removed">-          // (placeholder for alpha store code)</span>
<span class="udiff-line-removed">-     &quot;    %s&quot;</span>
<span class="udiff-line-removed">-          // (placeholder for re-premult code)</span>
<span class="udiff-line-removed">-     &quot;    %s&quot;</span>
<span class="udiff-line-removed">-          // modulate with gl_Color in order to apply extra alpha</span>
<span class="udiff-line-removed">-     &quot;    gl_FragColor = result * gl_Color;&quot;</span>
<span class="udiff-line-removed">-     &quot;}&quot;;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * Flags that can be bitwise-or&#39;ed together to control how the shader</span>
<span class="udiff-line-removed">-  * source code is generated.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- #define LOOKUP_RECT          (1 &lt;&lt; 0)</span>
<span class="udiff-line-removed">- #define LOOKUP_USE_SRC_ALPHA (1 &lt;&lt; 1)</span>
<span class="udiff-line-removed">- #define LOOKUP_NON_PREMULT   (1 &lt;&lt; 2)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /**</span>
<span class="udiff-line-removed">-  * The handles to the LookupOp fragment program objects.  The index to</span>
<span class="udiff-line-removed">-  * the array should be a bitwise-or&#39;ing of the LOOKUP_* flags defined</span>
<span class="udiff-line-removed">-  * above.  Note that most applications will likely need to initialize one</span>
<span class="udiff-line-removed">-  * or two of these elements, so the array is usually sparsely populated.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static GLhandleARB lookupPrograms[8];</span>
<span class="udiff-line-modified-added">+ @implementation MTLLookupOp {</span>
<span class="udiff-line-modified-added">+     float _offset[4];</span>
<span class="udiff-line-modified-added">+     jboolean _isUseSrcAlpha;</span>
<span class="udiff-line-modified-added">+     jboolean _isNonPremult;</span>
  
<span class="udiff-line-modified-removed">- /**</span>
<span class="udiff-line-modified-removed">-  * The handle to the lookup table texture object used by the shader.</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- static GLuint lutTextureID = 0;</span>
<span class="udiff-line-modified-added">+     id&lt;MTLTexture&gt; _lookupTex;</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">- /**</span>
<span class="udiff-line-modified-removed">-  * Compiles and links the LookupOp shader program.  If successful, this</span>
<span class="udiff-line-modified-removed">-  * function returns a handle to the newly created shader program; otherwise</span>
<span class="udiff-line-modified-removed">-  * returns 0.</span>
<span class="udiff-line-modified-removed">-  */</span>
<span class="udiff-line-modified-removed">- static GLhandleARB</span>
<span class="udiff-line-modified-removed">- MTLBufImgOps_CreateLookupProgram(jint flags)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-     //TODO</span>
<span class="udiff-line-modified-removed">-     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateLookupProgram -- :TODO&quot;);</span>
<span class="udiff-line-modified-removed">-     return NULL;</span>
<span class="udiff-line-modified-added">+ - (id)init:(jboolean)nonPremult shortData:(jboolean)shortData</span>
<span class="udiff-line-modified-added">+                                  numBands:(jint)numBands</span>
<span class="udiff-line-modified-added">+                                bandLength:(jint)bandLength</span>
<span class="udiff-line-modified-added">+                                    offset:(jint)offset</span>
<span class="udiff-line-modified-added">+                               tableValues:(void *)tableValues</span>
<span class="udiff-line-modified-added">+                                    device:(id&lt;MTLDevice&gt;)device {</span>
<span class="udiff-line-modified-added">+     self = [super init];</span>
<span class="udiff-line-modified-added">+     if (self) {</span>
<span class="udiff-line-modified-added">+         J2dTraceLn4(J2D_TRACE_INFO,&quot;Created MTLLookupOp: short=%d num=%d len=%d off=%d&quot;,</span>
<span class="udiff-line-modified-added">+                     shortData, numBands, bandLength, offset);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         _isUseSrcAlpha = numBands != 4;</span>
<span class="udiff-line-added">+         _isNonPremult = nonPremult;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         _offset[0] = offset / 255.0f;</span>
<span class="udiff-line-added">+         _offset[1] = _offset[0];</span>
<span class="udiff-line-added">+         _offset[2] = _offset[0];</span>
<span class="udiff-line-added">+         _offset[3] = _offset[0];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         MTLTextureDescriptor *textureDescriptor =</span>
<span class="udiff-line-added">+                 [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatA8Unorm</span>
<span class="udiff-line-added">+                                                                    width:(NSUInteger)256</span>
<span class="udiff-line-added">+                                                                   height:(NSUInteger)4</span>
<span class="udiff-line-added">+                                                                mipmapped:NO];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         _lookupTex = [device newTextureWithDescriptor:textureDescriptor];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void *bands[4];</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+             bands[i] = NULL;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         int bytesPerElem = (shortData ? 2 : 1);</span>
<span class="udiff-line-added">+         if (numBands == 1) {</span>
<span class="udiff-line-added">+             // replicate the single band for R/G/B; alpha band is unused</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; 3; i++) {</span>
<span class="udiff-line-added">+                 bands[i] = tableValues;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             bands[3] = NULL;</span>
<span class="udiff-line-added">+         } else if (numBands == 3) {</span>
<span class="udiff-line-added">+             // user supplied band for each of R/G/B; alpha band is unused</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; 3; i++) {</span>
<span class="udiff-line-added">+                 bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             bands[3] = NULL;</span>
<span class="udiff-line-added">+         } else if (numBands == 4) {</span>
<span class="udiff-line-added">+             // user supplied band for each of R/G/B/A</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+                 bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+             if (bands[i] == NULL)</span>
<span class="udiff-line-added">+                 continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             MTLRegion region = {</span>
<span class="udiff-line-added">+                     {0, i, 0},</span>
<span class="udiff-line-added">+                     {bandLength, 1,1}</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             [_lookupTex replaceRegion:region</span>
<span class="udiff-line-added">+                                     mipmapLevel:0</span>
<span class="udiff-line-added">+                                       withBytes:bands[i]</span>
<span class="udiff-line-added">+                                     bytesPerRow:bandLength*bytesPerElem];</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return self;</span>
  }
  
<span class="udiff-line-modified-removed">- void</span>
<span class="udiff-line-modified-removed">- MTLBufImgOps_EnableLookupOp(MTLContext *mtlc, jlong pSrcOps,</span>
<span class="udiff-line-modified-removed">-                             jboolean nonPremult, jboolean shortData,</span>
<span class="udiff-line-removed">-                             jint numBands, jint bandLength, jint offset,</span>
<span class="udiff-line-removed">-                             void *tableValues)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableLookupOp -- :TODO&quot;);</span>
<span class="udiff-line-modified-added">+ - (void) dealloc {</span>
<span class="udiff-line-modified-added">+     [_lookupTex release];</span>
<span class="udiff-line-modified-added">+     [super dealloc];</span>
  }
  
<span class="udiff-line-modified-removed">- void</span>
<span class="udiff-line-modified-removed">- MTLBufImgOps_DisableLookupOp(MTLContext *mtlc)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     //TODO</span>
<span class="udiff-line-removed">-     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableLookupOp -- :TODO&quot;);</span>
<span class="udiff-line-modified-added">+ - (jfloat *) getOffset {</span>
<span class="udiff-line-modified-added">+     return _offset;</span>
  }
  
<span class="udiff-line-added">+ - (id&lt;MTLTexture&gt;) getLookupTexture {</span>
<span class="udiff-line-added">+     return _lookupTex;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ - (NSString *)getDescription {</span>
<span class="udiff-line-added">+     return [NSString stringWithFormat:@&quot;lookup: offset=%f&quot;, _offset[0]];</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ @end</span>
<span class="udiff-line-added">+ </span>
  #endif /* !HEADLESS */
</pre>
<center><a href="MTLBufImgOps.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jlong.h&gt;
 29 
 30 #include &quot;MTLBufImgOps.h&quot;
 31 #include &quot;MTLContext.h&quot;
 32 #include &quot;MTLRenderQueue.h&quot;
 33 #include &quot;MTLSurfaceDataBase.h&quot;
 34 #include &quot;GraphicsPrimitiveMgr.h&quot;
 35 
 36 @implementation MTLRescaleOp {
 37     jboolean _isNonPremult;
 38     jfloat _normScaleFactors[4];
 39     jfloat _normOffsets[4];
 40 }
 41 
 42 -(jfloat *) getScaleFactors {
 43     return _normScaleFactors;
 44 }
 45 -(jfloat *) getOffsets {
 46     return _normOffsets;
 47 }
 48 
 49 - (id)init:(jboolean)isNonPremult factors:(unsigned char *)factors offsets:(unsigned char *)offsets {
 50     self = [super init];
 51     if (self) {
 52         J2dTraceLn1(J2D_TRACE_INFO,&quot;Created MTLRescaleOp: isNonPremult=%d&quot;, isNonPremult);
 53 
 54         _isNonPremult = isNonPremult;
 55         _normScaleFactors[0] = NEXT_FLOAT(factors);
 56         _normScaleFactors[1] = NEXT_FLOAT(factors);
 57         _normScaleFactors[2] = NEXT_FLOAT(factors);
 58         _normScaleFactors[3] = NEXT_FLOAT(factors);
 59         _normOffsets[0] = NEXT_FLOAT(offsets);
 60         _normOffsets[1] = NEXT_FLOAT(offsets);
 61         _normOffsets[2] = NEXT_FLOAT(offsets);
 62         _normOffsets[3] = NEXT_FLOAT(offsets);
 63     }
 64     return self;
 65 }
 66 
 67 - (NSString *)getDescription {
 68     return [NSString stringWithFormat:@&quot;rescale: nonPremult=%d&quot;, _isNonPremult];
 69 }
 70 @end
 71 
 72 @implementation MTLConvolveOp {
 73     id&lt;MTLBuffer&gt; _buffer;
 74     float _imgEdge[4];
 75     int _kernelSize;
 76     jboolean _isEdgeZeroFill;
 77 }
 78 
 79 - (id)init:(jboolean)edgeZeroFill kernelWidth:(jint)kernelWidth
 80                                  kernelHeight:(jint)kernelHeight
 81                                      srcWidth:(jint)srcWidth
 82                                     srcHeight:(jint)srcHeight
 83                                        kernel:(unsigned char *)kernel
 84                                        device:(id&lt;MTLDevice&gt;)device {
 85     self = [super init];
 86     if (self) {
 87         J2dTraceLn2(J2D_TRACE_INFO,&quot;Created MTLConvolveOp: kernelW=%d kernelH=%d&quot;, kernelWidth, kernelHeight);
 88         _isEdgeZeroFill = edgeZeroFill;
 89 
 90         _kernelSize = kernelWidth * kernelHeight;
 91         _buffer = [device newBufferWithLength:_kernelSize*sizeof(vector_float3) options:MTLResourceStorageModeShared];
 92 
 93         float * kernelVals = [_buffer contents];
 94         int kIndex = 0;
 95         for (int i = -kernelHeight/2; i &lt; kernelHeight/2+1; i++) {
 96             for (int j = -kernelWidth/2; j &lt; kernelWidth/2+1; j++) {
 97                 kernelVals[kIndex+0] = j/(float)srcWidth;
 98                 kernelVals[kIndex+1] = i/(float)srcHeight;
 99                 kernelVals[kIndex+2] = NEXT_FLOAT(kernel);
100                 kIndex += 3;
101             }
102         }
103 
104         _imgEdge[0] = (kernelWidth/2)/(float)srcWidth;
105         _imgEdge[1] = (kernelHeight/2)/(float)srcHeight;
106         _imgEdge[2] = 1 - _imgEdge[0];
107         _imgEdge[3] = 1 - _imgEdge[1];
108     }
109     return self;
110 }
111 
112 - (void) dealloc {
113     [_buffer release];
114     [super dealloc];
115 }
116 
117 - (id&lt;MTLBuffer&gt;) getBuffer {
118     return _buffer;
119 }
120 
121 - (const float *) getImgEdge {
122     return _imgEdge;
123 }
124 
125 - (NSString *)getDescription {
126     return [NSString stringWithFormat:@&quot;convolve: isEdgeZeroFill=%d&quot;, _isEdgeZeroFill];
127 }
128 @end
129 
130 
131 @implementation MTLLookupOp {
132     float _offset[4];
133     jboolean _isUseSrcAlpha;
134     jboolean _isNonPremult;
135 
136     id&lt;MTLTexture&gt; _lookupTex;
137 }
138 
139 - (id)init:(jboolean)nonPremult shortData:(jboolean)shortData
140                                  numBands:(jint)numBands
141                                bandLength:(jint)bandLength
142                                    offset:(jint)offset
143                               tableValues:(void *)tableValues
144                                    device:(id&lt;MTLDevice&gt;)device {
145     self = [super init];
146     if (self) {
147         J2dTraceLn4(J2D_TRACE_INFO,&quot;Created MTLLookupOp: short=%d num=%d len=%d off=%d&quot;,
148                     shortData, numBands, bandLength, offset);
149 
150         _isUseSrcAlpha = numBands != 4;
151         _isNonPremult = nonPremult;
152 
153         _offset[0] = offset / 255.0f;
154         _offset[1] = _offset[0];
155         _offset[2] = _offset[0];
156         _offset[3] = _offset[0];
157 
158         MTLTextureDescriptor *textureDescriptor =
159                 [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatA8Unorm
160                                                                    width:(NSUInteger)256
161                                                                   height:(NSUInteger)4
162                                                                mipmapped:NO];
163 
164         _lookupTex = [device newTextureWithDescriptor:textureDescriptor];
165 
166         void *bands[4];
167         for (int i = 0; i &lt; 4; i++) {
168             bands[i] = NULL;
169         }
170         int bytesPerElem = (shortData ? 2 : 1);
171         if (numBands == 1) {
172             // replicate the single band for R/G/B; alpha band is unused
173             for (int i = 0; i &lt; 3; i++) {
174                 bands[i] = tableValues;
175             }
176             bands[3] = NULL;
177         } else if (numBands == 3) {
178             // user supplied band for each of R/G/B; alpha band is unused
179             for (int i = 0; i &lt; 3; i++) {
180                 bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);
181             }
182             bands[3] = NULL;
183         } else if (numBands == 4) {
184             // user supplied band for each of R/G/B/A
185             for (int i = 0; i &lt; 4; i++) {
186                 bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);
187             }
188         }
189 
190         for (int i = 0; i &lt; 4; i++) {
191             if (bands[i] == NULL)
192                 continue;
193 
194             MTLRegion region = {
195                     {0, i, 0},
196                     {bandLength, 1,1}
197             };
198 
199             [_lookupTex replaceRegion:region
200                                     mipmapLevel:0
201                                       withBytes:bands[i]
202                                     bytesPerRow:bandLength*bytesPerElem];
203         }
204     }
205     return self;
206 }
207 
208 - (void) dealloc {
209     [_lookupTex release];
210     [super dealloc];
211 }
212 
213 - (jfloat *) getOffset {
214     return _offset;
215 }
216 
217 - (id&lt;MTLTexture&gt;) getLookupTexture {
218     return _lookupTex;
219 }
220 
221 - (NSString *)getDescription {
222     return [NSString stringWithFormat:@&quot;lookup: offset=%f&quot;, _offset[0]];
223 }
224 
225 @end
226 
227 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
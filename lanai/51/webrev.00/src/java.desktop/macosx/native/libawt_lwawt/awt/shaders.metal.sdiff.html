<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="common.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../java2d/metal/EncoderManager.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
184                  renderColor.a);
185 }
186 
187 fragment half4 aa_frag_txt(
188         TxtShaderInOut vert [[stage_in]],
189         texture2d&lt;float, access::sample&gt; renderTexture [[texture(0)]],
190         texture2d&lt;float, access::sample&gt; stencilTexture [[texture(1)]],
191         constant TxtFrameUniforms&amp; uniforms [[buffer(1)]],
192         sampler textureSampler [[sampler(0)]]
193 ) {
194     float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);
195     if (!is_null_texture(stencilTexture)) {
196         float4 stencil = stencilTexture.sample(textureSampler, vert.texCoords);
197         if (stencil.r ==  0.0) {
198             discard_fragment();
199         }
200     }
201     return half4(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a);
202 }
203 






















































































































204 fragment half4 frag_grad(GradShaderInOut in [[stage_in]],
205                          constant GradFrameUniforms&amp; uniforms [[buffer(0)]]) {
206     float3 v = float3(in.position.x, in.position.y, 1);
207     float  a = (dot(v,uniforms.params)-0.25)*2.0;
208     float4 c = mix(uniforms.color1, uniforms.color2, a);
209     return half4(c);
210 }
211 
212 
213 vertex TxtShaderInOut vert_tp(VertexInput in [[stage_in]],
214        constant AnchorData&amp; anchorData [[buffer(FrameUniformBuffer)]],
215        constant TransformMatrix&amp; transform [[buffer(MatrixBuffer)]])
216 {
217     TxtShaderInOut out;
218     float4 pos4 = float4(in.position, 0.0, 1.0);
219     out.position = transform.transformMatrix * pos4;
220 
221     // Compute texture coordinates here w.r.t. anchor rect of texture paint
222     out.texCoords.x = (anchorData.xParams[0] * in.position.x) +
223                       (anchorData.xParams[1] * in.position.y) +
</pre>
</td>
<td>
<hr />
<pre>
184                  renderColor.a);
185 }
186 
187 fragment half4 aa_frag_txt(
188         TxtShaderInOut vert [[stage_in]],
189         texture2d&lt;float, access::sample&gt; renderTexture [[texture(0)]],
190         texture2d&lt;float, access::sample&gt; stencilTexture [[texture(1)]],
191         constant TxtFrameUniforms&amp; uniforms [[buffer(1)]],
192         sampler textureSampler [[sampler(0)]]
193 ) {
194     float4 pixelColor = renderTexture.sample(textureSampler, vert.texCoords);
195     if (!is_null_texture(stencilTexture)) {
196         float4 stencil = stencilTexture.sample(textureSampler, vert.texCoords);
197         if (stencil.r ==  0.0) {
198             discard_fragment();
199         }
200     }
201     return half4(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a);
202 }
203 
<span class="line-added">204 fragment half4 frag_txt_op_rescale(</span>
<span class="line-added">205         TxtShaderInOut vert [[stage_in]],</span>
<span class="line-added">206         texture2d&lt;float, access::sample&gt; srcTex [[texture(0)]],</span>
<span class="line-added">207         constant TxtFrameOpRescaleUniforms&amp; uniforms [[buffer(1)]],</span>
<span class="line-added">208         sampler textureSampler [[sampler(0)]]</span>
<span class="line-added">209 ) {</span>
<span class="line-added">210     float4 srcColor = srcTex.sample(textureSampler, vert.texCoords);</span>
<span class="line-added">211     const float srcA = uniforms.isSrcOpaque ? 1 : srcColor.a;</span>
<span class="line-added">212 </span>
<span class="line-added">213     // TODO: check uniforms.isNonPremult and pre-multiply if necessary</span>
<span class="line-added">214     return half4(srcColor.r*uniforms.normScaleFactors.r + uniforms.normOffsets.r,</span>
<span class="line-added">215                  srcColor.g*uniforms.normScaleFactors.g + uniforms.normOffsets.g,</span>
<span class="line-added">216                  srcColor.b*uniforms.normScaleFactors.b + uniforms.normOffsets.b, srcA*uniforms.extraAlpha);</span>
<span class="line-added">217 </span>
<span class="line-added">218     // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it&#39;s better to do the</span>
<span class="line-added">219     // same here.</span>
<span class="line-added">220     //</span>
<span class="line-added">221     // GL-shader impl:</span>
<span class="line-added">222     //&quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;</span>
<span class="line-added">223     //&quot;    %s&quot;                                                      // (placeholder for un-premult code: srcColor.rgb /= srcColor.a;)</span>
<span class="line-added">224     //&quot;    vec4 result = (srcColor * scaleFactors) + offsets;&quot;      // rescale source value</span>
<span class="line-added">225     //&quot;    %s&quot;                                                      // (placeholder for re-premult code: result.rgb *= result.a;)</span>
<span class="line-added">226     //&quot;    gl_FragColor = result * gl_Color;&quot;                       // modulate with gl_Color in order to apply extra alpha</span>
<span class="line-added">227 }</span>
<span class="line-added">228 </span>
<span class="line-added">229 fragment half4 frag_txt_op_convolve(</span>
<span class="line-added">230         TxtShaderInOut vert [[stage_in]],</span>
<span class="line-added">231         texture2d&lt;float, access::sample&gt; srcTex [[texture(0)]],</span>
<span class="line-added">232         constant TxtFrameOpConvolveUniforms&amp; uniforms [[buffer(1)]],</span>
<span class="line-added">233         const device float3 * kernelVals [[buffer(2)]],</span>
<span class="line-added">234         sampler textureSampler [[sampler(0)]]</span>
<span class="line-added">235 ) {</span>
<span class="line-added">236     float4 sum = float4(0, 0, 0, 0);</span>
<span class="line-added">237     if (vert.texCoords[0] &lt; uniforms.imgEdge[0]</span>
<span class="line-added">238         || vert.texCoords[1] &lt; uniforms.imgEdge[1]</span>
<span class="line-added">239         || vert.texCoords[0] &gt; uniforms.imgEdge[2]</span>
<span class="line-added">240         || vert.texCoords[1] &gt; uniforms.imgEdge[3]</span>
<span class="line-added">241     ) {</span>
<span class="line-added">242         if (!uniforms.isEdgeZeroFill) {</span>
<span class="line-added">243             sum = srcTex.sample(textureSampler, vert.texCoords);</span>
<span class="line-added">244         }</span>
<span class="line-added">245     }</span>
<span class="line-added">246 </span>
<span class="line-added">247     for (int i = 0; i &lt; uniforms.kernelSize; i++) {</span>
<span class="line-added">248         float3 kern = kernelVals[i];</span>
<span class="line-added">249         float2 pos = float2(vert.texCoords.x + kern.x, vert.texCoords.y + kern.y);</span>
<span class="line-added">250         float4 pixCol = srcTex.sample(textureSampler, pos);</span>
<span class="line-added">251         sum.r += kern.z * pixCol.r;</span>
<span class="line-added">252         sum.g += kern.z * pixCol.g;</span>
<span class="line-added">253         sum.b += kern.z * pixCol.b;</span>
<span class="line-added">254         sum.a += kern.z * pixCol.a;</span>
<span class="line-added">255     }</span>
<span class="line-added">256 </span>
<span class="line-added">257     return half4(sum.r, sum.g, sum.b, sum.a*uniforms.extraAlpha);</span>
<span class="line-added">258 </span>
<span class="line-added">259     // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it&#39;s better to do the</span>
<span class="line-added">260     // same here.</span>
<span class="line-added">261     //</span>
<span class="line-added">262     // GL-shader impl:</span>
<span class="line-added">263     //&quot;    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||&quot;</span>
<span class="line-added">264     //&quot;        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))&quot;</span>
<span class="line-added">265     //&quot;    {&quot;</span>
<span class="line-added">266     //&quot;        %s&quot;      // (placeholder for edge condition code)</span>
<span class="line-added">267     //&quot;    } else {&quot;</span>
<span class="line-added">268     //&quot;        sum = vec4(0.0);&quot;</span>
<span class="line-added">269     //&quot;        for (i = 0; i &lt; MAX_KERNEL_SIZE; i++) {&quot;</span>
<span class="line-added">270     //&quot;            sum +=&quot;</span>
<span class="line-added">271     //&quot;                kernelVals[i].z *&quot;</span>
<span class="line-added">272     //&quot;                texture%s(baseImage,&quot;</span>
<span class="line-added">273     //&quot;                          gl_TexCoord[0].st + kernelVals[i].xy);&quot;</span>
<span class="line-added">274     //&quot;        }&quot;</span>
<span class="line-added">275     //&quot;    }&quot;</span>
<span class="line-added">276     //&quot;&quot;</span>
<span class="line-added">277     //&quot;    gl_FragColor = sum * gl_Color;&quot; // modulate with gl_Color in order to apply extra alpha</span>
<span class="line-added">278 }</span>
<span class="line-added">279 </span>
<span class="line-added">280 fragment half4 frag_txt_op_lookup(</span>
<span class="line-added">281         TxtShaderInOut vert [[stage_in]],</span>
<span class="line-added">282         texture2d&lt;float, access::sample&gt; srcTex [[texture(0)]],</span>
<span class="line-added">283         texture2d&lt;float, access::sample&gt; lookupTex [[texture(1)]],</span>
<span class="line-added">284         constant TxtFrameOpLookupUniforms&amp; uniforms [[buffer(1)]],</span>
<span class="line-added">285         sampler textureSampler [[sampler(0)]]</span>
<span class="line-added">286 ) {</span>
<span class="line-added">287     float4 srcColor = srcTex.sample(textureSampler, vert.texCoords);</span>
<span class="line-added">288     float4 srcIndex = srcColor - uniforms.offset;</span>
<span class="line-added">289     const float2 posR = float2(srcIndex.r, 0.125);</span>
<span class="line-added">290     const float2 posG = float2(srcIndex.g, 0.375);</span>
<span class="line-added">291     const float2 posB = float2(srcIndex.b, 0.625);</span>
<span class="line-added">292 </span>
<span class="line-added">293     float4 lookupR = lookupTex.sample(textureSampler, posR);</span>
<span class="line-added">294     float4 lookupG = lookupTex.sample(textureSampler, posG);</span>
<span class="line-added">295     float4 lookupB = lookupTex.sample(textureSampler, posB);</span>
<span class="line-added">296 </span>
<span class="line-added">297     const float a = uniforms.isUseSrcAlpha ? srcColor.a : lookupTex.sample(textureSampler, float2(srcIndex.a, 0.875)).a;</span>
<span class="line-added">298 </span>
<span class="line-added">299     // TODO: check uniforms.isNonPremult and pre-multiply if necessary</span>
<span class="line-added">300     return half4(lookupR.a, lookupG.a, lookupB.a, a*uniforms.extraAlpha);</span>
<span class="line-added">301 </span>
<span class="line-added">302     // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it&#39;s better to do the</span>
<span class="line-added">303     // same here.</span>
<span class="line-added">304     //</span>
<span class="line-added">305     // GL-shader impl:</span>
<span class="line-added">306     //&quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;</span>
<span class="line-added">307     //&quot;    %s&quot;                                  // (placeholder for un-premult code)</span>
<span class="line-added">308     //&quot;    vec4 srcIndex = srcColor - offset;&quot;  // subtract offset from original index</span>
<span class="line-added">309     //</span>
<span class="line-added">310     //      // use source value as input to lookup table (note that</span>
<span class="line-added">311     //      // &quot;v&quot; texcoords are hardcoded to hit texel centers of</span>
<span class="line-added">312     //      // each row/band in texture)</span>
<span class="line-added">313     //&quot;    vec4 result;&quot;</span>
<span class="line-added">314     //&quot;    result.r = texture2D(lookupTable, vec2(srcIndex.r, 0.125)).r;&quot;</span>
<span class="line-added">315     //&quot;    result.g = texture2D(lookupTable, vec2(srcIndex.g, 0.375)).r;&quot;</span>
<span class="line-added">316     //&quot;    result.b = texture2D(lookupTable, vec2(srcIndex.b, 0.625)).r;&quot;</span>
<span class="line-added">317     //&quot;    %s&quot;                                  // (placeholder for alpha store code)</span>
<span class="line-added">318     //&quot;    %s&quot;                                  // (placeholder for re-premult code)</span>
<span class="line-added">319     //&quot;    gl_FragColor = result * gl_Color;&quot;   // modulate with gl_Color in order to apply extra alpha</span>
<span class="line-added">320 }</span>
<span class="line-added">321 </span>
322 fragment half4 frag_grad(GradShaderInOut in [[stage_in]],
323                          constant GradFrameUniforms&amp; uniforms [[buffer(0)]]) {
324     float3 v = float3(in.position.x, in.position.y, 1);
325     float  a = (dot(v,uniforms.params)-0.25)*2.0;
326     float4 c = mix(uniforms.color1, uniforms.color2, a);
327     return half4(c);
328 }
329 
330 
331 vertex TxtShaderInOut vert_tp(VertexInput in [[stage_in]],
332        constant AnchorData&amp; anchorData [[buffer(FrameUniformBuffer)]],
333        constant TransformMatrix&amp; transform [[buffer(MatrixBuffer)]])
334 {
335     TxtShaderInOut out;
336     float4 pos4 = float4(in.position, 0.0, 1.0);
337     out.position = transform.transformMatrix * pos4;
338 
339     // Compute texture coordinates here w.r.t. anchor rect of texture paint
340     out.texCoords.x = (anchorData.xParams[0] * in.position.x) +
341                       (anchorData.xParams[1] * in.position.y) +
</pre>
</td>
</tr>
</table>
<center><a href="common.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../java2d/metal/EncoderManager.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
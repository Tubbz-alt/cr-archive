<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLBufImgOps.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jlong.h&gt;
 29 
 30 #include &quot;MTLBufImgOps.h&quot;
 31 #include &quot;MTLContext.h&quot;
 32 #include &quot;MTLRenderQueue.h&quot;
 33 #include &quot;MTLSurfaceDataBase.h&quot;
 34 #include &quot;GraphicsPrimitiveMgr.h&quot;
 35 
<span class="line-modified"> 36 /** Evaluates to true if the given bit is set on the local flags variable. */</span>
<span class="line-modified"> 37 #define IS_SET(flagbit) \</span>
<span class="line-modified"> 38     (((flags) &amp; (flagbit)) != 0)</span>
<span class="line-modified"> 39 </span>
<span class="line-removed"> 40 /**************************** ConvolveOp support ****************************/</span>
<span class="line-removed"> 41 </span>
<span class="line-removed"> 42 /**</span>
<span class="line-removed"> 43  * The ConvolveOp shader is fairly straightforward.  For each texel in</span>
<span class="line-removed"> 44  * the source texture, the shader samples the MxN texels in the surrounding</span>
<span class="line-removed"> 45  * area, multiplies each by its corresponding kernel value, and then sums</span>
<span class="line-removed"> 46  * them all together to produce a single color result.  Finally, the</span>
<span class="line-removed"> 47  * resulting value is multiplied by the current OpenGL color, which contains</span>
<span class="line-removed"> 48  * the extra alpha value.</span>
<span class="line-removed"> 49  *</span>
<span class="line-removed"> 50  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.</span>
<span class="line-removed"> 51  * This allows us to build different shader programs (e.g. one for</span>
<span class="line-removed"> 52  * 3x3, one for 5x5, and so on) simply by filling in these &quot;holes&quot; with</span>
<span class="line-removed"> 53  * a call to sprintf().  See the MTLBufImgOps_CreateConvolveProgram() method</span>
<span class="line-removed"> 54  * for more details.</span>
<span class="line-removed"> 55  *</span>
<span class="line-removed"> 56  * REMIND: Currently this shader (and the supporting code in the</span>
<span class="line-removed"> 57  *         EnableConvolveOp() method) only supports 3x3 and 5x5 filters.</span>
<span class="line-removed"> 58  *         Early shader-level hardware did not support non-constant sized</span>
<span class="line-removed"> 59  *         arrays but modern hardware should support them (although I</span>
<span class="line-removed"> 60  *         don&#39;t know of any simple way to find out, other than to compile</span>
<span class="line-removed"> 61  *         the shader at runtime and see if the drivers complain).</span>
<span class="line-removed"> 62  */</span>
<span class="line-removed"> 63 static const char *convolveShaderSource =</span>
<span class="line-removed"> 64     // maximum size supported by this shader</span>
<span class="line-removed"> 65     &quot;const int MAX_KERNEL_SIZE = %s;&quot;</span>
<span class="line-removed"> 66     // image to be convolved</span>
<span class="line-removed"> 67     &quot;uniform sampler%s baseImage;&quot;</span>
<span class="line-removed"> 68     // image edge limits:</span>
<span class="line-removed"> 69     //   imgEdge.xy = imgMin.xy (anything &lt; will be treated as edge case)</span>
<span class="line-removed"> 70     //   imgEdge.zw = imgMax.xy (anything &gt; will be treated as edge case)</span>
<span class="line-removed"> 71     &quot;uniform vec4 imgEdge;&quot;</span>
<span class="line-removed"> 72     // value for each location in the convolution kernel:</span>
<span class="line-removed"> 73     //   kernelVals[i].x = offsetX[i]</span>
<span class="line-removed"> 74     //   kernelVals[i].y = offsetY[i]</span>
<span class="line-removed"> 75     //   kernelVals[i].z = kernel[i]</span>
<span class="line-removed"> 76     &quot;uniform vec3 kernelVals[MAX_KERNEL_SIZE];&quot;</span>
<span class="line-removed"> 77     &quot;&quot;</span>
<span class="line-removed"> 78     &quot;void main(void)&quot;</span>
<span class="line-removed"> 79     &quot;{&quot;</span>
<span class="line-removed"> 80     &quot;    int i;&quot;</span>
<span class="line-removed"> 81     &quot;    vec4 sum;&quot;</span>
<span class="line-removed"> 82     &quot;&quot;</span>
<span class="line-removed"> 83     &quot;    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||&quot;</span>
<span class="line-removed"> 84     &quot;        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))&quot;</span>
<span class="line-removed"> 85     &quot;    {&quot;</span>
<span class="line-removed"> 86              // (placeholder for edge condition code)</span>
<span class="line-removed"> 87     &quot;        %s&quot;</span>
<span class="line-removed"> 88     &quot;    } else {&quot;</span>
<span class="line-removed"> 89     &quot;        sum = vec4(0.0);&quot;</span>
<span class="line-removed"> 90     &quot;        for (i = 0; i &lt; MAX_KERNEL_SIZE; i++) {&quot;</span>
<span class="line-removed"> 91     &quot;            sum +=&quot;</span>
<span class="line-removed"> 92     &quot;                kernelVals[i].z *&quot;</span>
<span class="line-removed"> 93     &quot;                texture%s(baseImage,&quot;</span>
<span class="line-removed"> 94     &quot;                          gl_TexCoord[0].st + kernelVals[i].xy);&quot;</span>
<span class="line-removed"> 95     &quot;        }&quot;</span>
<span class="line-removed"> 96     &quot;    }&quot;</span>
<span class="line-removed"> 97     &quot;&quot;</span>
<span class="line-removed"> 98          // modulate with gl_Color in order to apply extra alpha</span>
<span class="line-removed"> 99     &quot;    gl_FragColor = sum * gl_Color;&quot;</span>
<span class="line-removed">100     &quot;}&quot;;</span>
<span class="line-removed">101 </span>
<span class="line-removed">102 /**</span>
<span class="line-removed">103  * Flags that can be bitwise-or&#39;ed together to control how the shader</span>
<span class="line-removed">104  * source code is generated.</span>
<span class="line-removed">105  */</span>
<span class="line-removed">106 #define CONVOLVE_RECT            (1 &lt;&lt; 0)</span>
<span class="line-removed">107 #define CONVOLVE_EDGE_ZERO_FILL  (1 &lt;&lt; 1)</span>
<span class="line-removed">108 #define CONVOLVE_5X5             (1 &lt;&lt; 2)</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 /**</span>
<span class="line-removed">111  * The handles to the ConvolveOp fragment program objects.  The index to</span>
<span class="line-removed">112  * the array should be a bitwise-or&#39;ing of the CONVOLVE_* flags defined</span>
<span class="line-removed">113  * above.  Note that most applications will likely need to initialize one</span>
<span class="line-removed">114  * or two of these elements, so the array is usually sparsely populated.</span>
<span class="line-removed">115  */</span>
<span class="line-removed">116 static GLhandleARB convolvePrograms[8];</span>
<span class="line-removed">117 </span>
<span class="line-removed">118 /**</span>
<span class="line-removed">119  * The maximum kernel size supported by the ConvolveOp shader.</span>
<span class="line-removed">120  */</span>
<span class="line-removed">121 #define MAX_KERNEL_SIZE 25</span>
<span class="line-removed">122 </span>
<span class="line-removed">123 /**</span>
<span class="line-removed">124  * Compiles and links the ConvolveOp shader program.  If successful, this</span>
<span class="line-removed">125  * function returns a handle to the newly created shader program; otherwise</span>
<span class="line-removed">126  * returns 0.</span>
<span class="line-removed">127  */</span>
<span class="line-removed">128 static GLhandleARB</span>
<span class="line-removed">129 MTLBufImgOps_CreateConvolveProgram(jint flags)</span>
<span class="line-removed">130 {</span>
<span class="line-removed">131     //TODO</span>
<span class="line-removed">132     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateConvolveProgram -- :TODO&quot;);</span>
<span class="line-removed">133 </span>
<span class="line-removed">134     return NULL;</span>
135 }
136 
<span class="line-modified">137 void</span>
<span class="line-modified">138 MTLBufImgOps_EnableConvolveOp(MTLContext *mtlc, jlong pSrcOps,</span>
<span class="line-modified">139                               jboolean edgeZeroFill,</span>
<span class="line-modified">140                               jint kernelWidth, jint kernelHeight,</span>
<span class="line-modified">141                               unsigned char *kernel)</span>
<span class="line-modified">142 {</span>
<span class="line-removed">143     //TODO</span>
<span class="line-removed">144     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableConvolveOp -- :TODO&quot;);</span>
145 
















146 }
147 
<span class="line-modified">148 void</span>
<span class="line-modified">149 MTLBufImgOps_DisableConvolveOp(MTLContext *mtlc)</span>
<span class="line-removed">150 {</span>
<span class="line-removed">151     //TODO</span>
<span class="line-removed">152     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableConvolveOp -- :TODO&quot;);</span>
153 }

154 
<span class="line-modified">155 /**************************** RescaleOp support *****************************/</span>





156 
<span class="line-modified">157 /**</span>
<span class="line-modified">158  * The RescaleOp shader is one of the simplest possible.  Each fragment</span>
<span class="line-modified">159  * from the source image is multiplied by the user&#39;s scale factor and added</span>
<span class="line-modified">160  * to the user&#39;s offset value (these are component-wise operations).</span>
<span class="line-modified">161  * Finally, the resulting value is multiplied by the current OpenGL color,</span>
<span class="line-modified">162  * which contains the extra alpha value.</span>
<span class="line-modified">163  *</span>
<span class="line-modified">164  * The RescaleOp spec says that the operation is performed regardless of</span>
<span class="line-modified">165  * whether the source data is premultiplied or non-premultiplied.  This is</span>
<span class="line-modified">166  * a problem for the OpenGL pipeline in that a non-premultiplied</span>
<span class="line-modified">167  * BufferedImage will have already been converted into premultiplied</span>
<span class="line-modified">168  * when uploaded to an OpenGL texture.  Therefore, we have a special mode</span>
<span class="line-modified">169  * called RESCALE_NON_PREMULT (used only for source images that were</span>
<span class="line-modified">170  * originally non-premultiplied) that un-premultiplies the source color</span>
<span class="line-modified">171  * prior to the rescale operation, then re-premultiplies the resulting</span>
<span class="line-modified">172  * color before returning from the fragment shader.</span>
<span class="line-modified">173  *</span>
<span class="line-modified">174  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.</span>
<span class="line-modified">175  * This allows us to build different shader programs (e.g. one for</span>
<span class="line-modified">176  * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)</span>
<span class="line-modified">177  * simply by filling in these &quot;holes&quot; with a call to sprintf().  See the</span>
<span class="line-modified">178  * MTLBufImgOps_CreateRescaleProgram() method for more details.</span>
<span class="line-modified">179  */</span>
<span class="line-modified">180 static const char *rescaleShaderSource =</span>
<span class="line-modified">181     // image to be rescaled</span>
<span class="line-modified">182     &quot;uniform sampler%s baseImage;&quot;</span>
<span class="line-modified">183     // vector containing scale factors</span>
<span class="line-modified">184     &quot;uniform vec4 scaleFactors;&quot;</span>
<span class="line-modified">185     // vector containing offsets</span>
<span class="line-modified">186     &quot;uniform vec4 offsets;&quot;</span>
<span class="line-modified">187     &quot;&quot;</span>
<span class="line-modified">188     &quot;void main(void)&quot;</span>
<span class="line-removed">189     &quot;{&quot;</span>
<span class="line-removed">190     &quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;</span>
<span class="line-removed">191          // (placeholder for un-premult code)</span>
<span class="line-removed">192     &quot;    %s&quot;</span>
<span class="line-removed">193          // rescale source value</span>
<span class="line-removed">194     &quot;    vec4 result = (srcColor * scaleFactors) + offsets;&quot;</span>
<span class="line-removed">195          // (placeholder for re-premult code)</span>
<span class="line-removed">196     &quot;    %s&quot;</span>
<span class="line-removed">197          // modulate with gl_Color in order to apply extra alpha</span>
<span class="line-removed">198     &quot;    gl_FragColor = result * gl_Color;&quot;</span>
<span class="line-removed">199     &quot;}&quot;;</span>
<span class="line-removed">200 </span>
<span class="line-removed">201 /**</span>
<span class="line-removed">202  * Flags that can be bitwise-or&#39;ed together to control how the shader</span>
<span class="line-removed">203  * source code is generated.</span>
<span class="line-removed">204  */</span>
<span class="line-removed">205 #define RESCALE_RECT        (1 &lt;&lt; 0)</span>
<span class="line-removed">206 #define RESCALE_NON_PREMULT (1 &lt;&lt; 1)</span>
<span class="line-removed">207 </span>
<span class="line-removed">208 /**</span>
<span class="line-removed">209  * The handles to the RescaleOp fragment program objects.  The index to</span>
<span class="line-removed">210  * the array should be a bitwise-or&#39;ing of the RESCALE_* flags defined</span>
<span class="line-removed">211  * above.  Note that most applications will likely need to initialize one</span>
<span class="line-removed">212  * or two of these elements, so the array is usually sparsely populated.</span>
<span class="line-removed">213  */</span>
<span class="line-removed">214 static GLhandleARB rescalePrograms[4];</span>
215 
<span class="line-modified">216 /**</span>
<span class="line-modified">217  * Compiles and links the RescaleOp shader program.  If successful, this</span>
<span class="line-modified">218  * function returns a handle to the newly created shader program; otherwise</span>
<span class="line-modified">219  * returns 0.</span>
<span class="line-removed">220  */</span>
<span class="line-removed">221 static GLhandleARB</span>
<span class="line-removed">222 MTLBufImgOps_CreateRescaleProgram(jint flags)</span>
<span class="line-removed">223 {</span>
<span class="line-removed">224     //TODO</span>
<span class="line-removed">225     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateRescaleProgram -- :TODO&quot;);</span>
226 
<span class="line-modified">227     return NULL;</span>

228 }
229 
<span class="line-modified">230 void</span>
<span class="line-modified">231 MTLBufImgOps_EnableRescaleOp(MTLContext *mtlc, jlong pSrcOps,</span>
<span class="line-removed">232                              jboolean nonPremult,</span>
<span class="line-removed">233                              unsigned char *scaleFactors,</span>
<span class="line-removed">234                              unsigned char *offsets)</span>
<span class="line-removed">235 {</span>
<span class="line-removed">236     //TODO</span>
<span class="line-removed">237     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableRescaleOp -- :TODO&quot;);</span>
238 }
239 
<span class="line-modified">240 void</span>
<span class="line-modified">241 MTLBufImgOps_DisableRescaleOp(MTLContext *mtlc)</span>
<span class="line-removed">242 {</span>
<span class="line-removed">243     //TODO</span>
<span class="line-removed">244     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableRescaleOp -- :TODO&quot;);</span>
<span class="line-removed">245     RETURN_IF_NULL(mtlc);</span>
246 }

247 
<span class="line-removed">248 /**************************** LookupOp support ******************************/</span>
249 
<span class="line-modified">250 /**</span>
<span class="line-modified">251  * The LookupOp shader takes a fragment color (from the source texture) as</span>
<span class="line-modified">252  * input, subtracts the optional user offset value, and then uses the</span>
<span class="line-modified">253  * resulting value to index into the lookup table texture to provide</span>
<span class="line-removed">254  * a new color result.  Finally, the resulting value is multiplied by</span>
<span class="line-removed">255  * the current OpenGL color, which contains the extra alpha value.</span>
<span class="line-removed">256  *</span>
<span class="line-removed">257  * The lookup step requires 3 texture accesses (or 4, when alpha is included),</span>
<span class="line-removed">258  * which is somewhat unfortunate because it&#39;s not ideal from a performance</span>
<span class="line-removed">259  * standpoint, but that sort of thing is getting faster with newer hardware.</span>
<span class="line-removed">260  * In the 3-band case, we could consider using a three-dimensional texture</span>
<span class="line-removed">261  * and performing the lookup with a single texture access step.  We already</span>
<span class="line-removed">262  * use this approach in the LCD text shader, and it works well, but for the</span>
<span class="line-removed">263  * purposes of this LookupOp shader, it&#39;s probably overkill.  Also, there&#39;s</span>
<span class="line-removed">264  * a difference in that the LCD text shader only needs to populate the 3D LUT</span>
<span class="line-removed">265  * once, but here we would need to populate it on every invocation, which</span>
<span class="line-removed">266  * would likely be a waste of VRAM and CPU/GPU cycles.</span>
<span class="line-removed">267  *</span>
<span class="line-removed">268  * The LUT texture is currently hardcoded as 4 rows/bands, each containing</span>
<span class="line-removed">269  * 256 elements.  This means that we currently only support user-provided</span>
<span class="line-removed">270  * tables with no more than 256 elements in each band (this is checked at</span>
<span class="line-removed">271  * at the Java level).  If the user provides a table with less than 256</span>
<span class="line-removed">272  * elements per band, our shader will still work fine, but if elements are</span>
<span class="line-removed">273  * accessed with an index &gt;= the size of the LUT, then the shader will simply</span>
<span class="line-removed">274  * produce undefined values.  Typically the user would provide an offset</span>
<span class="line-removed">275  * value that would prevent this from happening, but it&#39;s worth pointing out</span>
<span class="line-removed">276  * this fact because the software LookupOp implementation would usually</span>
<span class="line-removed">277  * throw an ArrayIndexOutOfBoundsException in this scenario (although it is</span>
<span class="line-removed">278  * not something demanded by the spec).</span>
<span class="line-removed">279  *</span>
<span class="line-removed">280  * The LookupOp spec says that the operation is performed regardless of</span>
<span class="line-removed">281  * whether the source data is premultiplied or non-premultiplied.  This is</span>
<span class="line-removed">282  * a problem for the OpenGL pipeline in that a non-premultiplied</span>
<span class="line-removed">283  * BufferedImage will have already been converted into premultiplied</span>
<span class="line-removed">284  * when uploaded to an OpenGL texture.  Therefore, we have a special mode</span>
<span class="line-removed">285  * called LOOKUP_NON_PREMULT (used only for source images that were</span>
<span class="line-removed">286  * originally non-premultiplied) that un-premultiplies the source color</span>
<span class="line-removed">287  * prior to the lookup operation, then re-premultiplies the resulting</span>
<span class="line-removed">288  * color before returning from the fragment shader.</span>
<span class="line-removed">289  *</span>
<span class="line-removed">290  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.</span>
<span class="line-removed">291  * This allows us to build different shader programs (e.g. one for</span>
<span class="line-removed">292  * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)</span>
<span class="line-removed">293  * simply by filling in these &quot;holes&quot; with a call to sprintf().  See the</span>
<span class="line-removed">294  * MTLBufImgOps_CreateLookupProgram() method for more details.</span>
<span class="line-removed">295  */</span>
<span class="line-removed">296 static const char *lookupShaderSource =</span>
<span class="line-removed">297     // source image (bound to texture unit 0)</span>
<span class="line-removed">298     &quot;uniform sampler%s baseImage;&quot;</span>
<span class="line-removed">299     // lookup table (bound to texture unit 1)</span>
<span class="line-removed">300     &quot;uniform sampler2D lookupTable;&quot;</span>
<span class="line-removed">301     // offset subtracted from source index prior to lookup step</span>
<span class="line-removed">302     &quot;uniform vec4 offset;&quot;</span>
<span class="line-removed">303     &quot;&quot;</span>
<span class="line-removed">304     &quot;void main(void)&quot;</span>
<span class="line-removed">305     &quot;{&quot;</span>
<span class="line-removed">306     &quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;</span>
<span class="line-removed">307          // (placeholder for un-premult code)</span>
<span class="line-removed">308     &quot;    %s&quot;</span>
<span class="line-removed">309          // subtract offset from original index</span>
<span class="line-removed">310     &quot;    vec4 srcIndex = srcColor - offset;&quot;</span>
<span class="line-removed">311          // use source value as input to lookup table (note that</span>
<span class="line-removed">312          // &quot;v&quot; texcoords are hardcoded to hit texel centers of</span>
<span class="line-removed">313          // each row/band in texture)</span>
<span class="line-removed">314     &quot;    vec4 result;&quot;</span>
<span class="line-removed">315     &quot;    result.r = texture2D(lookupTable, vec2(srcIndex.r, 0.125)).r;&quot;</span>
<span class="line-removed">316     &quot;    result.g = texture2D(lookupTable, vec2(srcIndex.g, 0.375)).r;&quot;</span>
<span class="line-removed">317     &quot;    result.b = texture2D(lookupTable, vec2(srcIndex.b, 0.625)).r;&quot;</span>
<span class="line-removed">318          // (placeholder for alpha store code)</span>
<span class="line-removed">319     &quot;    %s&quot;</span>
<span class="line-removed">320          // (placeholder for re-premult code)</span>
<span class="line-removed">321     &quot;    %s&quot;</span>
<span class="line-removed">322          // modulate with gl_Color in order to apply extra alpha</span>
<span class="line-removed">323     &quot;    gl_FragColor = result * gl_Color;&quot;</span>
<span class="line-removed">324     &quot;}&quot;;</span>
<span class="line-removed">325 </span>
<span class="line-removed">326 /**</span>
<span class="line-removed">327  * Flags that can be bitwise-or&#39;ed together to control how the shader</span>
<span class="line-removed">328  * source code is generated.</span>
<span class="line-removed">329  */</span>
<span class="line-removed">330 #define LOOKUP_RECT          (1 &lt;&lt; 0)</span>
<span class="line-removed">331 #define LOOKUP_USE_SRC_ALPHA (1 &lt;&lt; 1)</span>
<span class="line-removed">332 #define LOOKUP_NON_PREMULT   (1 &lt;&lt; 2)</span>
<span class="line-removed">333 </span>
<span class="line-removed">334 /**</span>
<span class="line-removed">335  * The handles to the LookupOp fragment program objects.  The index to</span>
<span class="line-removed">336  * the array should be a bitwise-or&#39;ing of the LOOKUP_* flags defined</span>
<span class="line-removed">337  * above.  Note that most applications will likely need to initialize one</span>
<span class="line-removed">338  * or two of these elements, so the array is usually sparsely populated.</span>
<span class="line-removed">339  */</span>
<span class="line-removed">340 static GLhandleARB lookupPrograms[8];</span>
341 
<span class="line-modified">342 /**</span>
<span class="line-modified">343  * The handle to the lookup table texture object used by the shader.</span>
<span class="line-removed">344  */</span>
<span class="line-removed">345 static GLuint lutTextureID = 0;</span>
346 
<span class="line-modified">347 /**</span>
<span class="line-modified">348  * Compiles and links the LookupOp shader program.  If successful, this</span>
<span class="line-modified">349  * function returns a handle to the newly created shader program; otherwise</span>
<span class="line-modified">350  * returns 0.</span>
<span class="line-modified">351  */</span>
<span class="line-modified">352 static GLhandleARB</span>
<span class="line-modified">353 MTLBufImgOps_CreateLookupProgram(jint flags)</span>
<span class="line-modified">354 {</span>
<span class="line-modified">355     //TODO</span>
<span class="line-modified">356     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateLookupProgram -- :TODO&quot;);</span>
<span class="line-modified">357     return NULL;</span>
























































358 }
359 
<span class="line-modified">360 void</span>
<span class="line-modified">361 MTLBufImgOps_EnableLookupOp(MTLContext *mtlc, jlong pSrcOps,</span>
<span class="line-modified">362                             jboolean nonPremult, jboolean shortData,</span>
<span class="line-removed">363                             jint numBands, jint bandLength, jint offset,</span>
<span class="line-removed">364                             void *tableValues)</span>
<span class="line-removed">365 {</span>
<span class="line-removed">366     //TODO</span>
<span class="line-removed">367     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableLookupOp -- :TODO&quot;);</span>
368 }
369 
<span class="line-modified">370 void</span>
<span class="line-modified">371 MTLBufImgOps_DisableLookupOp(MTLContext *mtlc)</span>
<span class="line-removed">372 {</span>
<span class="line-removed">373     //TODO</span>
<span class="line-removed">374     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableLookupOp -- :TODO&quot;);</span>
375 }
376 










377 #endif /* !HEADLESS */
</pre>
</td>
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jlong.h&gt;
 29 
 30 #include &quot;MTLBufImgOps.h&quot;
 31 #include &quot;MTLContext.h&quot;
 32 #include &quot;MTLRenderQueue.h&quot;
 33 #include &quot;MTLSurfaceDataBase.h&quot;
 34 #include &quot;GraphicsPrimitiveMgr.h&quot;
 35 
<span class="line-modified"> 36 @implementation MTLRescaleOp {</span>
<span class="line-modified"> 37     jboolean _isNonPremult;</span>
<span class="line-modified"> 38     jfloat _normScaleFactors[4];</span>
<span class="line-modified"> 39     jfloat _normOffsets[4];</span>































































































 40 }
 41 
<span class="line-modified"> 42 -(jfloat *) getScaleFactors {</span>
<span class="line-modified"> 43     return _normScaleFactors;</span>
<span class="line-modified"> 44 }</span>
<span class="line-modified"> 45 -(jfloat *) getOffsets {</span>
<span class="line-modified"> 46     return _normOffsets;</span>
<span class="line-modified"> 47 }</span>


 48 
<span class="line-added"> 49 - (id)init:(jboolean)isNonPremult factors:(unsigned char *)factors offsets:(unsigned char *)offsets {</span>
<span class="line-added"> 50     self = [super init];</span>
<span class="line-added"> 51     if (self) {</span>
<span class="line-added"> 52         J2dTraceLn1(J2D_TRACE_INFO,&quot;Created MTLRescaleOp: isNonPremult=%d&quot;, isNonPremult);</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54         _isNonPremult = isNonPremult;</span>
<span class="line-added"> 55         _normScaleFactors[0] = NEXT_FLOAT(factors);</span>
<span class="line-added"> 56         _normScaleFactors[1] = NEXT_FLOAT(factors);</span>
<span class="line-added"> 57         _normScaleFactors[2] = NEXT_FLOAT(factors);</span>
<span class="line-added"> 58         _normScaleFactors[3] = NEXT_FLOAT(factors);</span>
<span class="line-added"> 59         _normOffsets[0] = NEXT_FLOAT(offsets);</span>
<span class="line-added"> 60         _normOffsets[1] = NEXT_FLOAT(offsets);</span>
<span class="line-added"> 61         _normOffsets[2] = NEXT_FLOAT(offsets);</span>
<span class="line-added"> 62         _normOffsets[3] = NEXT_FLOAT(offsets);</span>
<span class="line-added"> 63     }</span>
<span class="line-added"> 64     return self;</span>
 65 }
 66 
<span class="line-modified"> 67 - (NSString *)getDescription {</span>
<span class="line-modified"> 68     return [NSString stringWithFormat:@&quot;rescale: nonPremult=%d&quot;, _isNonPremult];</span>



 69 }
<span class="line-added"> 70 @end</span>
 71 
<span class="line-modified"> 72 @implementation MTLConvolveOp {</span>
<span class="line-added"> 73     id&lt;MTLBuffer&gt; _buffer;</span>
<span class="line-added"> 74     float _imgEdge[4];</span>
<span class="line-added"> 75     int _kernelSize;</span>
<span class="line-added"> 76     jboolean _isEdgeZeroFill;</span>
<span class="line-added"> 77 }</span>
 78 
<span class="line-modified"> 79 - (id)init:(jboolean)edgeZeroFill kernelWidth:(jint)kernelWidth</span>
<span class="line-modified"> 80                                  kernelHeight:(jint)kernelHeight</span>
<span class="line-modified"> 81                                      srcWidth:(jint)srcWidth</span>
<span class="line-modified"> 82                                     srcHeight:(jint)srcHeight</span>
<span class="line-modified"> 83                                        kernel:(unsigned char *)kernel</span>
<span class="line-modified"> 84                                        device:(id&lt;MTLDevice&gt;)device {</span>
<span class="line-modified"> 85     self = [super init];</span>
<span class="line-modified"> 86     if (self) {</span>
<span class="line-modified"> 87         J2dTraceLn2(J2D_TRACE_INFO,&quot;Created MTLConvolveOp: kernelW=%d kernelH=%d&quot;, kernelWidth, kernelHeight);</span>
<span class="line-modified"> 88         _isEdgeZeroFill = edgeZeroFill;</span>
<span class="line-modified"> 89 </span>
<span class="line-modified"> 90         _kernelSize = kernelWidth * kernelHeight;</span>
<span class="line-modified"> 91         _buffer = [device newBufferWithLength:_kernelSize*sizeof(vector_float3) options:MTLResourceStorageModeShared];</span>
<span class="line-modified"> 92 </span>
<span class="line-modified"> 93         float * kernelVals = [_buffer contents];</span>
<span class="line-modified"> 94         int kIndex = 0;</span>
<span class="line-modified"> 95         for (int i = -kernelHeight/2; i &lt; kernelHeight/2+1; i++) {</span>
<span class="line-modified"> 96             for (int j = -kernelWidth/2; j &lt; kernelWidth/2+1; j++) {</span>
<span class="line-modified"> 97                 kernelVals[kIndex+0] = j/(float)srcWidth;</span>
<span class="line-modified"> 98                 kernelVals[kIndex+1] = i/(float)srcHeight;</span>
<span class="line-modified"> 99                 kernelVals[kIndex+2] = NEXT_FLOAT(kernel);</span>
<span class="line-modified">100                 kIndex += 3;</span>
<span class="line-modified">101             }</span>
<span class="line-modified">102         }</span>
<span class="line-modified">103 </span>
<span class="line-modified">104         _imgEdge[0] = (kernelWidth/2)/(float)srcWidth;</span>
<span class="line-modified">105         _imgEdge[1] = (kernelHeight/2)/(float)srcHeight;</span>
<span class="line-modified">106         _imgEdge[2] = 1 - _imgEdge[0];</span>
<span class="line-modified">107         _imgEdge[3] = 1 - _imgEdge[1];</span>
<span class="line-modified">108     }</span>
<span class="line-modified">109     return self;</span>
<span class="line-modified">110 }</span>


























111 
<span class="line-modified">112 - (void) dealloc {</span>
<span class="line-modified">113     [_buffer release];</span>
<span class="line-modified">114     [super dealloc];</span>
<span class="line-modified">115 }</span>






116 
<span class="line-modified">117 - (id&lt;MTLBuffer&gt;) getBuffer {</span>
<span class="line-added">118     return _buffer;</span>
119 }
120 
<span class="line-modified">121 - (const float *) getImgEdge {</span>
<span class="line-modified">122     return _imgEdge;</span>






123 }
124 
<span class="line-modified">125 - (NSString *)getDescription {</span>
<span class="line-modified">126     return [NSString stringWithFormat:@&quot;convolve: isEdgeZeroFill=%d&quot;, _isEdgeZeroFill];</span>




127 }
<span class="line-added">128 @end</span>
129 

130 
<span class="line-modified">131 @implementation MTLLookupOp {</span>
<span class="line-modified">132     float _offset[4];</span>
<span class="line-modified">133     jboolean _isUseSrcAlpha;</span>
<span class="line-modified">134     jboolean _isNonPremult;</span>























































































135 
<span class="line-modified">136     id&lt;MTLTexture&gt; _lookupTex;</span>
<span class="line-modified">137 }</span>


138 
<span class="line-modified">139 - (id)init:(jboolean)nonPremult shortData:(jboolean)shortData</span>
<span class="line-modified">140                                  numBands:(jint)numBands</span>
<span class="line-modified">141                                bandLength:(jint)bandLength</span>
<span class="line-modified">142                                    offset:(jint)offset</span>
<span class="line-modified">143                               tableValues:(void *)tableValues</span>
<span class="line-modified">144                                    device:(id&lt;MTLDevice&gt;)device {</span>
<span class="line-modified">145     self = [super init];</span>
<span class="line-modified">146     if (self) {</span>
<span class="line-modified">147         J2dTraceLn4(J2D_TRACE_INFO,&quot;Created MTLLookupOp: short=%d num=%d len=%d off=%d&quot;,</span>
<span class="line-modified">148                     shortData, numBands, bandLength, offset);</span>
<span class="line-modified">149 </span>
<span class="line-added">150         _isUseSrcAlpha = numBands != 4;</span>
<span class="line-added">151         _isNonPremult = nonPremult;</span>
<span class="line-added">152 </span>
<span class="line-added">153         _offset[0] = offset / 255.0f;</span>
<span class="line-added">154         _offset[1] = _offset[0];</span>
<span class="line-added">155         _offset[2] = _offset[0];</span>
<span class="line-added">156         _offset[3] = _offset[0];</span>
<span class="line-added">157 </span>
<span class="line-added">158         MTLTextureDescriptor *textureDescriptor =</span>
<span class="line-added">159                 [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatA8Unorm</span>
<span class="line-added">160                                                                    width:(NSUInteger)256</span>
<span class="line-added">161                                                                   height:(NSUInteger)4</span>
<span class="line-added">162                                                                mipmapped:NO];</span>
<span class="line-added">163 </span>
<span class="line-added">164         _lookupTex = [device newTextureWithDescriptor:textureDescriptor];</span>
<span class="line-added">165 </span>
<span class="line-added">166         void *bands[4];</span>
<span class="line-added">167         for (int i = 0; i &lt; 4; i++) {</span>
<span class="line-added">168             bands[i] = NULL;</span>
<span class="line-added">169         }</span>
<span class="line-added">170         int bytesPerElem = (shortData ? 2 : 1);</span>
<span class="line-added">171         if (numBands == 1) {</span>
<span class="line-added">172             // replicate the single band for R/G/B; alpha band is unused</span>
<span class="line-added">173             for (int i = 0; i &lt; 3; i++) {</span>
<span class="line-added">174                 bands[i] = tableValues;</span>
<span class="line-added">175             }</span>
<span class="line-added">176             bands[3] = NULL;</span>
<span class="line-added">177         } else if (numBands == 3) {</span>
<span class="line-added">178             // user supplied band for each of R/G/B; alpha band is unused</span>
<span class="line-added">179             for (int i = 0; i &lt; 3; i++) {</span>
<span class="line-added">180                 bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);</span>
<span class="line-added">181             }</span>
<span class="line-added">182             bands[3] = NULL;</span>
<span class="line-added">183         } else if (numBands == 4) {</span>
<span class="line-added">184             // user supplied band for each of R/G/B/A</span>
<span class="line-added">185             for (int i = 0; i &lt; 4; i++) {</span>
<span class="line-added">186                 bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);</span>
<span class="line-added">187             }</span>
<span class="line-added">188         }</span>
<span class="line-added">189 </span>
<span class="line-added">190         for (int i = 0; i &lt; 4; i++) {</span>
<span class="line-added">191             if (bands[i] == NULL)</span>
<span class="line-added">192                 continue;</span>
<span class="line-added">193 </span>
<span class="line-added">194             MTLRegion region = {</span>
<span class="line-added">195                     {0, i, 0},</span>
<span class="line-added">196                     {bandLength, 1,1}</span>
<span class="line-added">197             };</span>
<span class="line-added">198 </span>
<span class="line-added">199             [_lookupTex replaceRegion:region</span>
<span class="line-added">200                                     mipmapLevel:0</span>
<span class="line-added">201                                       withBytes:bands[i]</span>
<span class="line-added">202                                     bytesPerRow:bandLength*bytesPerElem];</span>
<span class="line-added">203         }</span>
<span class="line-added">204     }</span>
<span class="line-added">205     return self;</span>
206 }
207 
<span class="line-modified">208 - (void) dealloc {</span>
<span class="line-modified">209     [_lookupTex release];</span>
<span class="line-modified">210     [super dealloc];</span>





211 }
212 
<span class="line-modified">213 - (jfloat *) getOffset {</span>
<span class="line-modified">214     return _offset;</span>



215 }
216 
<span class="line-added">217 - (id&lt;MTLTexture&gt;) getLookupTexture {</span>
<span class="line-added">218     return _lookupTex;</span>
<span class="line-added">219 }</span>
<span class="line-added">220 </span>
<span class="line-added">221 - (NSString *)getDescription {</span>
<span class="line-added">222     return [NSString stringWithFormat:@&quot;lookup: offset=%f&quot;, _offset[0]];</span>
<span class="line-added">223 }</span>
<span class="line-added">224 </span>
<span class="line-added">225 @end</span>
<span class="line-added">226 </span>
227 #endif /* !HEADLESS */
</pre>
</td>
</tr>
</table>
<center><a href="MTLBufImgOps.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 #import &quot;MTLComposite.h&quot;
 37 #import &quot;MTLBufImgOps.h&quot;
 38 
 39 #define RGBA_TO_V4(c)              \
 40 {                                  \
 41     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 42     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 43     ((c) &amp; 0xFF)/255.0f,           \
 44     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 45 }
 46 
 47 #define FLOAT_ARR_TO_V4(p) \
 48 {                      \
 49     p[0], \
 50     p[1], \
 51     p[2], \
 52     p[3]  \
 53 }
 54 
 55 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 56 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 57 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 58 
 59 static void initTemplatePipelineDescriptors() {
 60     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 61         return;
 62 
 63     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 64     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 65     vertDesc.attributes[VertexAttributePosition].offset = 0;
 66     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 67     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 68     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 69     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 70 
 71     templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 72     templateRenderPipelineDesc.sampleCount = 1;
 73     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 74     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 75     templateRenderPipelineDesc.label = @&quot;template_render&quot;;
 76 
 77     templateTexturePipelineDesc = [[templateRenderPipelineDesc copy] autorelease];
 78     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 79     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 80     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 81     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 82     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 83     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 84     templateTexturePipelineDesc.label = @&quot;template_texture&quot;;
 85 
 86     templateAATexturePipelineDesc = [[templateTexturePipelineDesc copy] autorelease];
 87     templateAATexturePipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;
 88     templateAATexturePipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
 89     templateAATexturePipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 90     templateAATexturePipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 91     templateAATexturePipelineDesc.label = @&quot;template_aa_texture&quot;;
 92 
 93 }
 94 
 95 @implementation MTLPaint {
 96     // TODO: remove paintState, split into heirarchy of Paint-objects (i.e. PaintColor, PaintGrad, e.t.c)
 97     jint          _paintState;
 98 
 99     // color-mode
100     jint          _color;
101 
102     // lin-grad-mode
103     jdouble       _p0;
104     jdouble       _p1;
105     jdouble       _p3;
106     jboolean      _cyclic;
107     jint          _pixel1;
108     jint          _pixel2;
109     jboolean      _useMask;
110 
111     // texture paint
112     id&lt;MTLTexture&gt; _paintTexture;
113     struct AnchorData _anchor;
114 }
115 
116 - (id)init {
117     self = [super init];
118     if (self) {
119         _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
120     }
121     return self;
122 }
123 
124 - (BOOL)isEqual:(MTLPaint *)other {
125     if (self == other)
126         return YES;
127     if (_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
128         return _paintState == other-&gt;_paintState;
129     if (_paintState != other-&gt;_paintState)
130         return NO;
131     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
132         return _p0 == other-&gt;_p0
133                &amp;&amp; _p1 == other-&gt;_p1
134                &amp;&amp; _p3 == other-&gt;_p3
135                &amp;&amp; _pixel1 == other-&gt;_pixel1
136                &amp;&amp; _pixel2 == other-&gt;_pixel2;
137     }
138     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
139         return _color == other-&gt;_color;
140     }
141     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
142         return _paintTexture == other-&gt;_paintTexture
143                &amp;&amp; _anchor.xParams[0] == other-&gt;_anchor.xParams[0]
144                &amp;&amp; _anchor.xParams[1] == other-&gt;_anchor.xParams[1]
145                &amp;&amp; _anchor.xParams[2] == other-&gt;_anchor.xParams[2]
146                &amp;&amp; _anchor.yParams[0] == other-&gt;_anchor.yParams[0]
147                &amp;&amp; _anchor.yParams[1] == other-&gt;_anchor.yParams[1]
148                &amp;&amp; _anchor.yParams[2] == other-&gt;_anchor.yParams[2];
149     }
150 
151     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unimplemented paint mode %d&quot;, _paintState);
152     return NO;
153 }
154 
155 - (void)copyFrom:(MTLPaint *)other {
156     _paintState = other-&gt;_paintState;
157     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
158         return;
159 
160     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
161         _p0 = other-&gt;_p0;
162         _p1 = other-&gt;_p1;
163         _p3 = other-&gt;_p3;
164         _pixel1 = other-&gt;_pixel1;
165         _pixel2 = other-&gt;_pixel2;
166         return;
167     }
168     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
169         _color = other-&gt;_color;
170         return;
171     }
172 
173     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
174         _color = other-&gt;_color;
175         _paintTexture = other-&gt;_paintTexture;
176         _anchor = other-&gt;_anchor;
177         return;
178     }
179 
180     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unsupported paint mode %d&quot;, _paintState);
181 }
182 
183 - (NSString *)getDescription {
184     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
185         return [NSString stringWithFormat:@&quot;[r=%d g=%d b=%d a=%d]&quot;, (_color &gt;&gt; 16) &amp; (0xFF), (_color &gt;&gt; 8) &amp; 0xFF, (_color) &amp; 0xFF, (_color &gt;&gt; 24) &amp; 0xFF];
186     }
187     
188     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
189         return [NSString stringWithFormat:@&quot;gradient&quot;];
190     }
191 
192     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
193         return [NSString stringWithFormat:@&quot;texture_paint&quot;];
194     }
195 
196     return @&quot;unknown-paint&quot;;
197 }
198 
199 - (jint)getColor {
200     return _color;
201 }
202 
203 - (void)reset {
204     _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
205     _paintTexture = nil;
206     _anchor.xParams[0] = _anchor.xParams[1] = _anchor.xParams[2] = 0.0f;
207     _anchor.yParams[0] = _anchor.yParams[1] = _anchor.yParams[2] = 0.0f; 
208 }
209 
210 - (void)setColor:(jint)pixelColor {
211     _paintState = sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR;
212     _color = pixelColor;
213 }
214 
215 - (void)setGradientUseMask:(jboolean)useMask
216                     cyclic:(jboolean)cyclic
217                         p0:(jdouble)p0
218                         p1:(jdouble)p1
219                         p3:(jdouble)p3
220                     pixel1:(jint)pixel1
221                     pixel2:(jint)pixel2
222 {
223     //TODO Resolve gradient distribution problem
224     //TODO Implement useMask
225     //TODO Implement cyclic
226     //fprintf(stderr,
227     //        &quot;MTLPaints_SetGradientPaint useMask=%d cyclic=%d &quot;
228     //        &quot;p0=%f p1=%f p3=%f pix1=%d pix2=%d\n&quot;, useMask, cyclic,
229     //        p0, p1, p3, pixel1, pixel2);
230 
231     _paintState = sun_java2d_SunGraphics2D_PAINT_GRADIENT;
232     _useMask = useMask;
233     _pixel1 = pixel1;
234     _pixel2 = pixel2;
235     _p0 = p0;
236     _p1 = p1;
237     _p3 = p3;
238     _cyclic = cyclic;
239 }
240 
241 - (void)setLinearGradient:(jboolean)useMask
242                    linear:(jboolean)linear
243               cycleMethod:(jboolean)cycleMethod
244                  numStops:(jint)numStops
245                        p0:(jfloat)p0
246                        p1:(jfloat)p1
247                        p3:(jfloat)p3
248                 fractions:(void *)fractions
249                    pixels:(void *)pixels
250 {
251     J2dTraceLn(J2D_TRACE_ERROR, &quot;setLinearGradient: UNIMPLEMENTED&quot;);
252     [self setColor:0];
253 }
254 
255 - (void)setRadialGradient:(jboolean)useMask
256                    linear:(jboolean)linear
257               cycleMethod:(jboolean)cycleMethod
258                  numStops:(jint)numStops
259                       m00:(jfloat)m00
260                       m01:(jfloat)m01
261                       m02:(jfloat)m02
262                       m10:(jfloat)m10
263                       m11:(jfloat)m11
264                       m12:(jfloat)m12
265                    focusX:(jfloat)focusX
266                 fractions:(void *)fractions
267                    pixels:(void *)pixels
268 {
269     J2dTraceLn(J2D_TRACE_ERROR, &quot;setRadialGradient: UNIMPLEMENTED&quot;);
270     [self setColor:0];
271 }
272 
273 - (void)setTexture:(jboolean)useMask
274            textureID:(id&lt;MTLTexture&gt;)textureID
275             filter:(jboolean)filter
276                xp0:(jdouble)xp0
277                xp1:(jdouble)xp1
278                xp3:(jdouble)xp3
279                yp0:(jdouble)yp0
280                yp1:(jdouble)yp1
281                yp3:(jdouble)yp3
282 {
283     _paintState = sun_java2d_SunGraphics2D_PAINT_TEXTURE;
284     _paintTexture = textureID;
285     
286     _anchor.xParams[0] = xp0;
287     _anchor.xParams[1] = xp1;
288     _anchor.xParams[2] = xp3;
289 
290     _anchor.yParams[0] = yp0;
291     _anchor.yParams[1] = yp1;
292     _anchor.yParams[2] = yp3;
293 }
294 
295 static id&lt;MTLSamplerState&gt; samplerNearestClamp = nil;
296 static id&lt;MTLSamplerState&gt; samplerLinearClamp = nil;
297 static id&lt;MTLSamplerState&gt; samplerNearestRepeat = nil;
298 static id&lt;MTLSamplerState&gt; samplerLinearRepeat = nil;
299 
300 void initSamplers(id&lt;MTLDevice&gt; device) {
301     // TODO: move this code into SamplerManager (need implement)
302 
303     if (samplerNearestClamp != nil)
304         return;
305 
306     MTLSamplerDescriptor *samplerDescriptor = [MTLSamplerDescriptor new];
307 
308     samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;
309     samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;
310     samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;
311 
312     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
313     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
314     samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
315 
316     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
317     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
318     samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
319 
320     samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;
321     samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;
322     samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;
323 
324     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
325     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
326     samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
327 
328     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
329     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
330     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
331 }
332 
333 static void setSampler(id&lt;MTLRenderCommandEncoder&gt; encoder, int interpolation, bool repeat) {
334     id&lt;MTLSamplerState&gt; sampler;
335     if (repeat) {
336         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
337     } else {
338         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
339     }
340     [encoder setFragmentSamplerState:sampler atIndex:0];
341 }
342 
343 static void setTxtUniforms(
344         id&lt;MTLRenderCommandEncoder&gt; encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
345         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
346 ) {
347     struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque, extraAlpha};
348     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
349 
350     setSampler(encoder, interpolation, repeat);
351 }
352 
353 // For the current paint mode:
354 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
355 // 2. Set vertex and fragment buffers
356 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
357                  context:(MTLContext *)mtlc
358            renderOptions:(const RenderOptions *)renderOptions
359     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
360 {
361     initTemplatePipelineDescriptors();
362 
363     NSString * vertShader = @&quot;vert_txt&quot;;
364     NSString * fragShader = @&quot;frag_txt&quot;;
365     MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
366 
367     if (renderOptions-&gt;isTexture) {
368         NSObject *bufImgOp = [mtlc getBufImgOp];
369         if (bufImgOp != nil) {
370             if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {
371                 MTLRescaleOp *rescaleOp = bufImgOp;
372                 vertShader = @&quot;vert_txt&quot;;
373                 fragShader = @&quot;frag_txt_op_rescale&quot;;
374 
375                 struct TxtFrameOpRescaleUniforms uf = {
376                         RGBA_TO_V4(0), [mtlc.composite getExtraAlpha], renderOptions-&gt;srcFlags.isOpaque,
377                         rescaleOp.isNonPremult,
378                         FLOAT_ARR_TO_V4([rescaleOp getScaleFactors]), FLOAT_ARR_TO_V4([rescaleOp getOffsets])
379                 };
380                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
381                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
382             } else if ([bufImgOp isKindOfClass:[MTLConvolveOp class]]) {
383                 MTLConvolveOp * convolveOp = bufImgOp;
384                 vertShader = @&quot;vert_txt&quot;;
385                 fragShader = @&quot;frag_txt_op_convolve&quot;;
386 
387                 struct TxtFrameOpConvolveUniforms uf = {
388                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([convolveOp getImgEdge]),
389                         convolveOp.kernelSize, convolveOp.isEdgeZeroFill,
390                 };
391                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
392                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
393 
394                 [encoder setFragmentBuffer:[convolveOp getBuffer] offset:0 atIndex:2];
395             } else if ([bufImgOp isKindOfClass:[MTLLookupOp class]]) {
396                 MTLLookupOp * lookupOp = bufImgOp;
397                 vertShader = @&quot;vert_txt&quot;;
398                 fragShader = @&quot;frag_txt_op_lookup&quot;;
399 
400                 struct TxtFrameOpLookupUniforms uf = {
401                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([lookupOp getOffset]),
402                         lookupOp.isUseSrcAlpha, lookupOp.isNonPremult,
403                 };
404                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
405                 setSampler(encoder, renderOptions-&gt;interpolation, NO);
406                 [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex: 1];
407             }
408         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
409             vertShader = @&quot;vert_txt_tp&quot;;
410             fragShader = @&quot;frag_txt_tp&quot;;
411             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
412             [encoder setFragmentTexture:_paintTexture atIndex:1];
413 
414             setTxtUniforms(encoder, 0, 0, renderOptions-&gt;interpolation, YES, [mtlc.composite getExtraAlpha],
415                            &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);
416         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
417             vertShader = @&quot;vert_txt_grad&quot;;
418             fragShader = @&quot;frag_txt_grad&quot;;
419             struct GradFrameUniforms uf = {
420                     {_p0, _p1, _p3},
421                     RGBA_TO_V4(_pixel1),
422                     RGBA_TO_V4(_pixel2)};
423             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];
424 
425         } else {
426             vertShader = @&quot;vert_txt&quot;;
427             fragShader = @&quot;frag_txt&quot;;
428             if (renderOptions-&gt;isAA) {
429                 fragShader = @&quot;aa_frag_txt&quot;;
430                 rpDesc = templateAATexturePipelineDesc;
431             }
432 
433             setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
434                            renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha], &amp;renderOptions-&gt;srcFlags,
435                            &amp;renderOptions-&gt;dstFlags);
436         }
437     } else {
438         rpDesc = templateRenderPipelineDesc;
439 
440         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
441             vertShader = @&quot;vert_col&quot;;
442             fragShader = @&quot;frag_col&quot;;
443 
444             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
445             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
446         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
447             vertShader = @&quot;vert_grad&quot;;
448             fragShader = @&quot;frag_grad&quot;;
449 
450             struct GradFrameUniforms uf = {
451                     {_p0, _p1, _p3},
452                     RGBA_TO_V4(_pixel1),
453                     RGBA_TO_V4(_pixel2)};
454             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];
455         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
456             vertShader = @&quot;vert_tp&quot;;
457             fragShader = @&quot;frag_tp&quot;;
458 
459             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
460             [encoder setFragmentTexture:_paintTexture atIndex:0];
461         }
462     }
463 
464     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc
465                                                                         vertexShaderId:vertShader
466                                                                       fragmentShaderId:fragShader
467                                                                              composite:mtlc.composite
468                                                                          renderOptions:renderOptions
469                                                                          stencilNeeded:[mtlc.clip isShape]];
470     [encoder setRenderPipelineState:pipelineState];
471 }
472 
473 
474 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
475 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
476 // 2. Set vertex and fragment buffers
477 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
478                         context:(MTLContext *)mtlc
479                   renderOptions:(const RenderOptions *)renderOptions
480            pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
481 {
482     initTemplatePipelineDescriptors();
483 
484     jint xorColor = (jint) [mtlc.composite getXorColor];
485 
486     NSString * vertShader = @&quot;vert_txt&quot;;
487     NSString * fragShader = @&quot;frag_txt&quot;;
488     MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
489 
490     if (renderOptions-&gt;isTexture) {
491         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
492         setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha], &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);
493         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
494     } else {
495         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
496             vertShader = @&quot;vert_col&quot;;
497             fragShader = @&quot;frag_col&quot;;
498             rpDesc = templateRenderPipelineDesc;
499 
500             // Calculate _color ^ xorColor for RGB components
501             // This color gets XORed with destination framebuffer pixel color
502             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
503             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
504 
505         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
506             vertShader = @&quot;vert_grad&quot;;
507             fragShader = @&quot;frag_grad&quot;;
508             rpDesc = templateRenderPipelineDesc;
509 
510                 struct GradFrameUniforms uf = {
511                         {_p0, _p1, _p3},
512                         RGBA_TO_V4(_pixel1 ^ xorColor),
513                         RGBA_TO_V4(_pixel2 ^ xorColor)};
514                 [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
515             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
516             vertShader = @&quot;vert_tp&quot;;
517             fragShader = @&quot;frag_tp_xorMode&quot;;
518             rpDesc = templateRenderPipelineDesc;
519 
520 
521                 [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
522                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
523                 [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
524             }
525         }
526 
527     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc
528                                                                         vertexShaderId:vertShader
529                                                                       fragmentShaderId:fragShader
530                                                                              composite:mtlc.composite
531                                                                          renderOptions:renderOptions
532                                                                          stencilNeeded:[mtlc.clip isShape]];
533     [encoder setRenderPipelineState:pipelineState];
534 }
535 
536 @end
537 
538 /************************* GradientPaint support ****************************/
539 
540 static void
541 MTLPaints_InitGradientTexture()
542 {
543     //TODO
544     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
545 }
546 
547 /****************** Shared MultipleGradientPaint support ********************/
548 
549 /**
550  * These constants are identical to those defined in the
551  * MultipleGradientPaint.CycleMethod enum; they are copied here for
552  * convenience (ideally we would pull them directly from the Java level,
553  * but that entails more hassle than it is worth).
554  */
555 #define CYCLE_NONE    0
556 #define CYCLE_REFLECT 1
557 #define CYCLE_REPEAT  2
558 
559 /**
560  * The following constants are flags that can be bitwise-or&#39;ed together
561  * to control how the MultipleGradientPaint shader source code is generated:
562  *
563  *   MULTI_CYCLE_METHOD
564  *     Placeholder for the CycleMethod enum constant.
565  *
566  *   MULTI_LARGE
567  *     If set, use the (slower) shader that supports a larger number of
568  *     gradient colors; otherwise, use the optimized codepath.  See
569  *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
570  *
571  *   MULTI_USE_MASK
572  *     If set, apply the alpha mask value from texture unit 0 to the
573  *     final color result (only used in the MaskFill case).
574  *
575  *   MULTI_LINEAR_RGB
576  *     If set, convert the linear RGB result back into the sRGB color space.
577  */
578 #define MULTI_CYCLE_METHOD (3 &lt;&lt; 0)
579 #define MULTI_LARGE        (1 &lt;&lt; 2)
580 #define MULTI_USE_MASK     (1 &lt;&lt; 3)
581 #define MULTI_LINEAR_RGB   (1 &lt;&lt; 4)
582 
583 /**
584  * This value determines the size of the array of programs for each
585  * MultipleGradientPaint type.  This value reflects the maximum value that
586  * can be represented by performing a bitwise-or of all the MULTI_*
587  * constants defined above.
588  */
589 #define MAX_PROGRAMS 32
590 
591 /** Evaluates to true if the given bit is set on the local flags variable. */
592 #define IS_SET(flagbit) \
593     (((flags) &amp; (flagbit)) != 0)
594 
595 /** Composes the given parameters as flags into the given flags variable.*/
596 #define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \
597     do {                                                   \
598         flags |= ((cycleMethod) &amp; MULTI_CYCLE_METHOD);     \
599         if (large)   flags |= MULTI_LARGE;                 \
600         if (useMask) flags |= MULTI_USE_MASK;              \
601         if (linear)  flags |= MULTI_LINEAR_RGB;            \
602     } while (0)
603 
604 /** Extracts the CycleMethod enum value from the given flags variable. */
605 #define EXTRACT_CYCLE_METHOD(flags) \
606     ((flags) &amp; MULTI_CYCLE_METHOD)
607 
608 /**
609  * The maximum number of gradient &quot;stops&quot; supported by the fragment shader
610  * and related code.  When the MULTI_LARGE flag is set, we will use
611  * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
612  * two separate values, we can have one highly optimized shader (SMALL) that
613  * supports only a few fractions/colors, and then another, less optimal
614  * shader that supports more stops.
615  */
616 #define MAX_FRACTIONS sun_java2d_pipe_BufferedPaints_MULTI_MAX_FRACTIONS
617 #define MAX_FRACTIONS_LARGE MAX_FRACTIONS
618 #define MAX_FRACTIONS_SMALL 4
619 
620 /**
621  * The maximum number of gradient colors supported by all of the gradient
622  * fragment shaders.  Note that this value must be a power of two, as it
623  * determines the size of the 1D texture created below.  It also must be
624  * greater than or equal to MAX_FRACTIONS (there is no strict requirement
625  * that the two values be equal).
626  */
627 #define MAX_COLORS 16
628 
629 /**
630  * The handle to the gradient color table texture object used by the shaders.
631  */
632 static jint multiGradientTexID = 0;
633 
634 /**
635  * This is essentially a template of the shader source code that can be used
636  * for either LinearGradientPaint or RadialGradientPaint.  It includes the
637  * structure and some variables that are common to each; the remaining
638  * code snippets (for CycleMethod, ColorSpaceType, and mask modulation)
639  * are filled in prior to compiling the shader at runtime depending on the
640  * paint parameters.  See MTLPaints_CreateMultiGradProgram() for more details.
641  */
642 static const char *multiGradientShaderSource =
643     // gradient texture size (in texels)
644     &quot;const int TEXTURE_SIZE = %d;&quot;
645     // maximum number of fractions/colors supported by this shader
646     &quot;const int MAX_FRACTIONS = %d;&quot;
647     // size of a single texel
648     &quot;const float FULL_TEXEL = (1.0 / float(TEXTURE_SIZE));&quot;
649     // size of half of a single texel
650     &quot;const float HALF_TEXEL = (FULL_TEXEL / 2.0);&quot;
651     // texture containing the gradient colors
652     &quot;uniform sampler1D colors;&quot;
653     // array of gradient stops/fractions
654     &quot;uniform float fractions[MAX_FRACTIONS];&quot;
655     // array of scale factors (one for each interval)
656     &quot;uniform float scaleFactors[MAX_FRACTIONS-1];&quot;
657     // (placeholder for mask variable)
658     &quot;%s&quot;
659     // (placeholder for Linear/RadialGP-specific variables)
660     &quot;%s&quot;
661     &quot;&quot;
662     &quot;void main(void)&quot;
663     &quot;{&quot;
664     &quot;    float dist;&quot;
665          // (placeholder for Linear/RadialGradientPaint-specific code)
666     &quot;    %s&quot;
667     &quot;&quot;
668     &quot;    float tc;&quot;
669          // (placeholder for CycleMethod-specific code)
670     &quot;    %s&quot;
671     &quot;&quot;
672          // calculate interpolated color
673     &quot;    vec4 result = texture1D(colors, tc);&quot;
674     &quot;&quot;
675          // (placeholder for ColorSpace conversion code)
676     &quot;    %s&quot;
677     &quot;&quot;
678          // (placeholder for mask modulation code)
679     &quot;    %s&quot;
680     &quot;&quot;
681          // modulate with gl_Color in order to apply extra alpha
682     &quot;    gl_FragColor = result * gl_Color;&quot;
683     &quot;}&quot;;
684 
685 /**
686  * This code takes a &quot;dist&quot; value as input (as calculated earlier by the
687  * LGP/RGP-specific code) in the range [0,1] and produces a texture
688  * coordinate value &quot;tc&quot; that represents the position of the chosen color
689  * in the one-dimensional gradient texture (also in the range [0,1]).
690  *
691  * One naive way to implement this would be to iterate through the fractions
692  * to figure out in which interval &quot;dist&quot; falls, and then compute the
693  * relative distance between the two nearest stops.  This approach would
694  * require an &quot;if&quot; check on every iteration, and it is best to avoid
695  * conditionals in fragment shaders for performance reasons.  Also, one might
696  * be tempted to use a break statement to jump out of the loop once the
697  * interval was found, but break statements (and non-constant loop bounds)
698  * are not natively available on most graphics hardware today, so that is
699  * a non-starter.
700  *
701  * The more optimal approach used here avoids these issues entirely by using
702  * an accumulation function that is equivalent to the process described above.
703  * The scaleFactors array is pre-initialized at enable time as follows:
704  *     scaleFactors[i] = 1.0 / (fractions[i+1] - fractions[i]);
705  *
706  * For each iteration, we subtract fractions[i] from dist and then multiply
707  * that value by scaleFactors[i].  If we are within the target interval,
708  * this value will be a fraction in the range [0,1] indicating the relative
709  * distance between fraction[i] and fraction[i+1].  If we are below the
710  * target interval, this value will be negative, so we clamp it to zero
711  * to avoid accumulating any value.  If we are above the target interval,
712  * the value will be greater than one, so we clamp it to one.  Upon exiting
713  * the loop, we will have accumulated zero or more 1.0&#39;s and a single
714  * fractional value.  This accumulated value tells us the position of the
715  * fragment color in the one-dimensional gradient texture, i.e., the
716  * texcoord called &quot;tc&quot;.
717  */
718 static const char *texCoordCalcCode =
719     &quot;int i;&quot;
720     &quot;float relFraction = 0.0;&quot;
721     &quot;for (i = 0; i &lt; MAX_FRACTIONS-1; i++) {&quot;
722     &quot;    relFraction +=&quot;
723     &quot;        clamp((dist - fractions[i]) * scaleFactors[i], 0.0, 1.0);&quot;
724     &quot;}&quot;
725     // we offset by half a texel so that we find the linearly interpolated
726     // color between the two texel centers of interest
727     &quot;tc = HALF_TEXEL + (FULL_TEXEL * relFraction);&quot;;
728 
729 /** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. */
730 static const char *noCycleCode =
731     &quot;if (dist &lt;= 0.0) {&quot;
732     &quot;    tc = 0.0;&quot;
733     &quot;} else if (dist &gt;= 1.0) {&quot;
734     &quot;    tc = 1.0;&quot;
735     &quot;} else {&quot;
736          // (placeholder for texcoord calculation)
737     &quot;    %s&quot;
738     &quot;}&quot;;
739 
740 /** Code for REFLECT that gets plugged into the CycleMethod placeholder. */
741 static const char *reflectCode =
742     &quot;dist = 1.0 - (abs(fract(dist * 0.5) - 0.5) * 2.0);&quot;
743     // (placeholder for texcoord calculation)
744     &quot;%s&quot;;
745 
746 /** Code for REPEAT that gets plugged into the CycleMethod placeholder. */
747 static const char *repeatCode =
748     &quot;dist = fract(dist);&quot;
749     // (placeholder for texcoord calculation)
750     &quot;%s&quot;;
751 
752 static void
753 MTLPaints_InitMultiGradientTexture()
754 {
755     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitMultiGradientTexture -- :TODO&quot;);
756 }
757 
758 /**
759  * Compiles and links the MultipleGradientPaint shader program.  If
760  * successful, this function returns a handle to the newly created
761  * shader program; otherwise returns 0.
762  */
763 static void*
764 MTLPaints_CreateMultiGradProgram(jint flags,
765                                  char *paintVars, char *distCode)
766 {
767 
768     //TODO
769     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_CreateMultiGradProgram -- :TODO&quot;);
770 
771     return NULL;
772 }
773 
774 /**
775  * Called from the MTLPaints_SetLinear/RadialGradientPaint() methods
776  * in order to setup the fraction/color values that are common to both.
777  */
778 static void
779 MTLPaints_SetMultiGradientPaint(void* multiGradProgram,
780                                 jint numStops,
781                                 void *pFractions, void *pPixels)
782 {
783     //TODO
784     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_SetMultiGradientPaint -- :TODO&quot;);
785 
786 }
787 
788 /********************** LinearGradientPaint support *************************/
789 
790 /**
791  * The handles to the LinearGradientPaint fragment program objects.  The
792  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
793  * above.  Note that most applications will likely need to initialize one
794  * or two of these elements, so the array is usually sparsely populated.
795  */
796 static void* linearGradPrograms[MAX_PROGRAMS];
797 
798 /**
799  * Compiles and links the LinearGradientPaint shader program.  If successful,
800  * this function returns a handle to the newly created shader program;
801  * otherwise returns 0.
802  */
803 static void*
804 MTLPaints_CreateLinearGradProgram(jint flags)
805 {
806     char *paintVars;
807     char *distCode;
808 
809     J2dTraceLn1(J2D_TRACE_INFO,
810                 &quot;MTLPaints_CreateLinearGradProgram&quot;,
811                 flags);
812 
813     /*
814      * To simplify the code and to make it easier to upload a number of
815      * uniform values at once, we pack a bunch of scalar (float) values
816      * into vec3 values below.  Here&#39;s how the values are related:
817      *
818      *   params.x = p0
819      *   params.y = p1
820      *   params.z = p3
821      *
822      *   yoff = dstOps-&gt;yOffset + dstOps-&gt;height
823      */
824     paintVars =
825         &quot;uniform vec3 params;&quot;
826         &quot;uniform float yoff;&quot;;
827     distCode =
828         // note that gl_FragCoord is in window space relative to the
829         // lower-left corner, so we have to flip the y-coordinate here
830         &quot;vec3 fragCoord = vec3(gl_FragCoord.x, yoff-gl_FragCoord.y, 1.0);&quot;
831         &quot;dist = dot(params, fragCoord);&quot;;
832 
833     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
834 }
835 
836 /********************** RadialGradientPaint support *************************/
837 
838 /**
839  * The handles to the RadialGradientPaint fragment program objects.  The
840  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
841  * above.  Note that most applications will likely need to initialize one
842  * or two of these elements, so the array is usually sparsely populated.
843  */
844 static void* radialGradPrograms[MAX_PROGRAMS];
845 
846 /**
847  * Compiles and links the RadialGradientPaint shader program.  If successful,
848  * this function returns a handle to the newly created shader program;
849  * otherwise returns 0.
850  */
851 static void*
852 MTLPaints_CreateRadialGradProgram(jint flags)
853 {
854     char *paintVars;
855     char *distCode;
856 
857     J2dTraceLn1(J2D_TRACE_INFO,
858                 &quot;MTLPaints_CreateRadialGradProgram&quot;,
859                 flags);
860 
861     /*
862      * To simplify the code and to make it easier to upload a number of
863      * uniform values at once, we pack a bunch of scalar (float) values
864      * into vec3 and vec4 values below.  Here&#39;s how the values are related:
865      *
866      *   m0.x = m00
867      *   m0.y = m01
868      *   m0.z = m02
869      *
870      *   m1.x = m10
871      *   m1.y = m11
872      *   m1.z = m12
873      *
874      *   precalc.x = focusX
875      *   precalc.y = yoff = dstOps-&gt;yOffset + dstOps-&gt;height
876      *   precalc.z = 1.0 - (focusX * focusX)
877      *   precalc.w = 1.0 / precalc.z
878      */
879     paintVars =
880         &quot;uniform vec3 m0;&quot;
881         &quot;uniform vec3 m1;&quot;
882         &quot;uniform vec4 precalc;&quot;;
883 
884     /*
885      * The following code is derived from Daniel Rice&#39;s whitepaper on
886      * radial gradient performance (attached to the bug report for 6521533).
887      * Refer to that document as well as the setup code in the Java-level
888      * BufferedPaints.setRadialGradientPaint() method for more details.
889      */
890     distCode =
891         // note that gl_FragCoord is in window space relative to the
892         // lower-left corner, so we have to flip the y-coordinate here
893         &quot;vec3 fragCoord =&quot;
894         &quot;    vec3(gl_FragCoord.x, precalc.y - gl_FragCoord.y, 1.0);&quot;
895         &quot;float x = dot(fragCoord, m0);&quot;
896         &quot;float y = dot(fragCoord, m1);&quot;
897         &quot;float xfx = x - precalc.x;&quot;
898         &quot;dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.z))*precalc.w;&quot;;
899 
900     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
901 }
902 
903 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
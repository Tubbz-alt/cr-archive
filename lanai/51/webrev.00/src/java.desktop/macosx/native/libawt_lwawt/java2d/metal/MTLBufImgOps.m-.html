<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jlong.h&gt;
 29 
 30 #include &quot;MTLBufImgOps.h&quot;
 31 #include &quot;MTLContext.h&quot;
 32 #include &quot;MTLRenderQueue.h&quot;
 33 #include &quot;MTLSurfaceDataBase.h&quot;
 34 #include &quot;GraphicsPrimitiveMgr.h&quot;
 35 
 36 /** Evaluates to true if the given bit is set on the local flags variable. */
 37 #define IS_SET(flagbit) \
 38     (((flags) &amp; (flagbit)) != 0)
 39 
 40 /**************************** ConvolveOp support ****************************/
 41 
 42 /**
 43  * The ConvolveOp shader is fairly straightforward.  For each texel in
 44  * the source texture, the shader samples the MxN texels in the surrounding
 45  * area, multiplies each by its corresponding kernel value, and then sums
 46  * them all together to produce a single color result.  Finally, the
 47  * resulting value is multiplied by the current OpenGL color, which contains
 48  * the extra alpha value.
 49  *
 50  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.
 51  * This allows us to build different shader programs (e.g. one for
 52  * 3x3, one for 5x5, and so on) simply by filling in these &quot;holes&quot; with
 53  * a call to sprintf().  See the MTLBufImgOps_CreateConvolveProgram() method
 54  * for more details.
 55  *
 56  * REMIND: Currently this shader (and the supporting code in the
 57  *         EnableConvolveOp() method) only supports 3x3 and 5x5 filters.
 58  *         Early shader-level hardware did not support non-constant sized
 59  *         arrays but modern hardware should support them (although I
 60  *         don&#39;t know of any simple way to find out, other than to compile
 61  *         the shader at runtime and see if the drivers complain).
 62  */
 63 static const char *convolveShaderSource =
 64     // maximum size supported by this shader
 65     &quot;const int MAX_KERNEL_SIZE = %s;&quot;
 66     // image to be convolved
 67     &quot;uniform sampler%s baseImage;&quot;
 68     // image edge limits:
 69     //   imgEdge.xy = imgMin.xy (anything &lt; will be treated as edge case)
 70     //   imgEdge.zw = imgMax.xy (anything &gt; will be treated as edge case)
 71     &quot;uniform vec4 imgEdge;&quot;
 72     // value for each location in the convolution kernel:
 73     //   kernelVals[i].x = offsetX[i]
 74     //   kernelVals[i].y = offsetY[i]
 75     //   kernelVals[i].z = kernel[i]
 76     &quot;uniform vec3 kernelVals[MAX_KERNEL_SIZE];&quot;
 77     &quot;&quot;
 78     &quot;void main(void)&quot;
 79     &quot;{&quot;
 80     &quot;    int i;&quot;
 81     &quot;    vec4 sum;&quot;
 82     &quot;&quot;
 83     &quot;    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||&quot;
 84     &quot;        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))&quot;
 85     &quot;    {&quot;
 86              // (placeholder for edge condition code)
 87     &quot;        %s&quot;
 88     &quot;    } else {&quot;
 89     &quot;        sum = vec4(0.0);&quot;
 90     &quot;        for (i = 0; i &lt; MAX_KERNEL_SIZE; i++) {&quot;
 91     &quot;            sum +=&quot;
 92     &quot;                kernelVals[i].z *&quot;
 93     &quot;                texture%s(baseImage,&quot;
 94     &quot;                          gl_TexCoord[0].st + kernelVals[i].xy);&quot;
 95     &quot;        }&quot;
 96     &quot;    }&quot;
 97     &quot;&quot;
 98          // modulate with gl_Color in order to apply extra alpha
 99     &quot;    gl_FragColor = sum * gl_Color;&quot;
100     &quot;}&quot;;
101 
102 /**
103  * Flags that can be bitwise-or&#39;ed together to control how the shader
104  * source code is generated.
105  */
106 #define CONVOLVE_RECT            (1 &lt;&lt; 0)
107 #define CONVOLVE_EDGE_ZERO_FILL  (1 &lt;&lt; 1)
108 #define CONVOLVE_5X5             (1 &lt;&lt; 2)
109 
110 /**
111  * The handles to the ConvolveOp fragment program objects.  The index to
112  * the array should be a bitwise-or&#39;ing of the CONVOLVE_* flags defined
113  * above.  Note that most applications will likely need to initialize one
114  * or two of these elements, so the array is usually sparsely populated.
115  */
116 static GLhandleARB convolvePrograms[8];
117 
118 /**
119  * The maximum kernel size supported by the ConvolveOp shader.
120  */
121 #define MAX_KERNEL_SIZE 25
122 
123 /**
124  * Compiles and links the ConvolveOp shader program.  If successful, this
125  * function returns a handle to the newly created shader program; otherwise
126  * returns 0.
127  */
128 static GLhandleARB
129 MTLBufImgOps_CreateConvolveProgram(jint flags)
130 {
131     //TODO
132     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateConvolveProgram -- :TODO&quot;);
133 
134     return NULL;
135 }
136 
137 void
138 MTLBufImgOps_EnableConvolveOp(MTLContext *mtlc, jlong pSrcOps,
139                               jboolean edgeZeroFill,
140                               jint kernelWidth, jint kernelHeight,
141                               unsigned char *kernel)
142 {
143     //TODO
144     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableConvolveOp -- :TODO&quot;);
145 
146 }
147 
148 void
149 MTLBufImgOps_DisableConvolveOp(MTLContext *mtlc)
150 {
151     //TODO
152     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableConvolveOp -- :TODO&quot;);
153 }
154 
155 /**************************** RescaleOp support *****************************/
156 
157 /**
158  * The RescaleOp shader is one of the simplest possible.  Each fragment
159  * from the source image is multiplied by the user&#39;s scale factor and added
160  * to the user&#39;s offset value (these are component-wise operations).
161  * Finally, the resulting value is multiplied by the current OpenGL color,
162  * which contains the extra alpha value.
163  *
164  * The RescaleOp spec says that the operation is performed regardless of
165  * whether the source data is premultiplied or non-premultiplied.  This is
166  * a problem for the OpenGL pipeline in that a non-premultiplied
167  * BufferedImage will have already been converted into premultiplied
168  * when uploaded to an OpenGL texture.  Therefore, we have a special mode
169  * called RESCALE_NON_PREMULT (used only for source images that were
170  * originally non-premultiplied) that un-premultiplies the source color
171  * prior to the rescale operation, then re-premultiplies the resulting
172  * color before returning from the fragment shader.
173  *
174  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.
175  * This allows us to build different shader programs (e.g. one for
176  * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)
177  * simply by filling in these &quot;holes&quot; with a call to sprintf().  See the
178  * MTLBufImgOps_CreateRescaleProgram() method for more details.
179  */
180 static const char *rescaleShaderSource =
181     // image to be rescaled
182     &quot;uniform sampler%s baseImage;&quot;
183     // vector containing scale factors
184     &quot;uniform vec4 scaleFactors;&quot;
185     // vector containing offsets
186     &quot;uniform vec4 offsets;&quot;
187     &quot;&quot;
188     &quot;void main(void)&quot;
189     &quot;{&quot;
190     &quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;
191          // (placeholder for un-premult code)
192     &quot;    %s&quot;
193          // rescale source value
194     &quot;    vec4 result = (srcColor * scaleFactors) + offsets;&quot;
195          // (placeholder for re-premult code)
196     &quot;    %s&quot;
197          // modulate with gl_Color in order to apply extra alpha
198     &quot;    gl_FragColor = result * gl_Color;&quot;
199     &quot;}&quot;;
200 
201 /**
202  * Flags that can be bitwise-or&#39;ed together to control how the shader
203  * source code is generated.
204  */
205 #define RESCALE_RECT        (1 &lt;&lt; 0)
206 #define RESCALE_NON_PREMULT (1 &lt;&lt; 1)
207 
208 /**
209  * The handles to the RescaleOp fragment program objects.  The index to
210  * the array should be a bitwise-or&#39;ing of the RESCALE_* flags defined
211  * above.  Note that most applications will likely need to initialize one
212  * or two of these elements, so the array is usually sparsely populated.
213  */
214 static GLhandleARB rescalePrograms[4];
215 
216 /**
217  * Compiles and links the RescaleOp shader program.  If successful, this
218  * function returns a handle to the newly created shader program; otherwise
219  * returns 0.
220  */
221 static GLhandleARB
222 MTLBufImgOps_CreateRescaleProgram(jint flags)
223 {
224     //TODO
225     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateRescaleProgram -- :TODO&quot;);
226 
227     return NULL;
228 }
229 
230 void
231 MTLBufImgOps_EnableRescaleOp(MTLContext *mtlc, jlong pSrcOps,
232                              jboolean nonPremult,
233                              unsigned char *scaleFactors,
234                              unsigned char *offsets)
235 {
236     //TODO
237     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableRescaleOp -- :TODO&quot;);
238 }
239 
240 void
241 MTLBufImgOps_DisableRescaleOp(MTLContext *mtlc)
242 {
243     //TODO
244     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableRescaleOp -- :TODO&quot;);
245     RETURN_IF_NULL(mtlc);
246 }
247 
248 /**************************** LookupOp support ******************************/
249 
250 /**
251  * The LookupOp shader takes a fragment color (from the source texture) as
252  * input, subtracts the optional user offset value, and then uses the
253  * resulting value to index into the lookup table texture to provide
254  * a new color result.  Finally, the resulting value is multiplied by
255  * the current OpenGL color, which contains the extra alpha value.
256  *
257  * The lookup step requires 3 texture accesses (or 4, when alpha is included),
258  * which is somewhat unfortunate because it&#39;s not ideal from a performance
259  * standpoint, but that sort of thing is getting faster with newer hardware.
260  * In the 3-band case, we could consider using a three-dimensional texture
261  * and performing the lookup with a single texture access step.  We already
262  * use this approach in the LCD text shader, and it works well, but for the
263  * purposes of this LookupOp shader, it&#39;s probably overkill.  Also, there&#39;s
264  * a difference in that the LCD text shader only needs to populate the 3D LUT
265  * once, but here we would need to populate it on every invocation, which
266  * would likely be a waste of VRAM and CPU/GPU cycles.
267  *
268  * The LUT texture is currently hardcoded as 4 rows/bands, each containing
269  * 256 elements.  This means that we currently only support user-provided
270  * tables with no more than 256 elements in each band (this is checked at
271  * at the Java level).  If the user provides a table with less than 256
272  * elements per band, our shader will still work fine, but if elements are
273  * accessed with an index &gt;= the size of the LUT, then the shader will simply
274  * produce undefined values.  Typically the user would provide an offset
275  * value that would prevent this from happening, but it&#39;s worth pointing out
276  * this fact because the software LookupOp implementation would usually
277  * throw an ArrayIndexOutOfBoundsException in this scenario (although it is
278  * not something demanded by the spec).
279  *
280  * The LookupOp spec says that the operation is performed regardless of
281  * whether the source data is premultiplied or non-premultiplied.  This is
282  * a problem for the OpenGL pipeline in that a non-premultiplied
283  * BufferedImage will have already been converted into premultiplied
284  * when uploaded to an OpenGL texture.  Therefore, we have a special mode
285  * called LOOKUP_NON_PREMULT (used only for source images that were
286  * originally non-premultiplied) that un-premultiplies the source color
287  * prior to the lookup operation, then re-premultiplies the resulting
288  * color before returning from the fragment shader.
289  *
290  * Note that this shader source code includes some &quot;holes&quot; marked by &quot;%s&quot;.
291  * This allows us to build different shader programs (e.g. one for
292  * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)
293  * simply by filling in these &quot;holes&quot; with a call to sprintf().  See the
294  * MTLBufImgOps_CreateLookupProgram() method for more details.
295  */
296 static const char *lookupShaderSource =
297     // source image (bound to texture unit 0)
298     &quot;uniform sampler%s baseImage;&quot;
299     // lookup table (bound to texture unit 1)
300     &quot;uniform sampler2D lookupTable;&quot;
301     // offset subtracted from source index prior to lookup step
302     &quot;uniform vec4 offset;&quot;
303     &quot;&quot;
304     &quot;void main(void)&quot;
305     &quot;{&quot;
306     &quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;
307          // (placeholder for un-premult code)
308     &quot;    %s&quot;
309          // subtract offset from original index
310     &quot;    vec4 srcIndex = srcColor - offset;&quot;
311          // use source value as input to lookup table (note that
312          // &quot;v&quot; texcoords are hardcoded to hit texel centers of
313          // each row/band in texture)
314     &quot;    vec4 result;&quot;
315     &quot;    result.r = texture2D(lookupTable, vec2(srcIndex.r, 0.125)).r;&quot;
316     &quot;    result.g = texture2D(lookupTable, vec2(srcIndex.g, 0.375)).r;&quot;
317     &quot;    result.b = texture2D(lookupTable, vec2(srcIndex.b, 0.625)).r;&quot;
318          // (placeholder for alpha store code)
319     &quot;    %s&quot;
320          // (placeholder for re-premult code)
321     &quot;    %s&quot;
322          // modulate with gl_Color in order to apply extra alpha
323     &quot;    gl_FragColor = result * gl_Color;&quot;
324     &quot;}&quot;;
325 
326 /**
327  * Flags that can be bitwise-or&#39;ed together to control how the shader
328  * source code is generated.
329  */
330 #define LOOKUP_RECT          (1 &lt;&lt; 0)
331 #define LOOKUP_USE_SRC_ALPHA (1 &lt;&lt; 1)
332 #define LOOKUP_NON_PREMULT   (1 &lt;&lt; 2)
333 
334 /**
335  * The handles to the LookupOp fragment program objects.  The index to
336  * the array should be a bitwise-or&#39;ing of the LOOKUP_* flags defined
337  * above.  Note that most applications will likely need to initialize one
338  * or two of these elements, so the array is usually sparsely populated.
339  */
340 static GLhandleARB lookupPrograms[8];
341 
342 /**
343  * The handle to the lookup table texture object used by the shader.
344  */
345 static GLuint lutTextureID = 0;
346 
347 /**
348  * Compiles and links the LookupOp shader program.  If successful, this
349  * function returns a handle to the newly created shader program; otherwise
350  * returns 0.
351  */
352 static GLhandleARB
353 MTLBufImgOps_CreateLookupProgram(jint flags)
354 {
355     //TODO
356     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLBufImgOps_CreateLookupProgram -- :TODO&quot;);
357     return NULL;
358 }
359 
360 void
361 MTLBufImgOps_EnableLookupOp(MTLContext *mtlc, jlong pSrcOps,
362                             jboolean nonPremult, jboolean shortData,
363                             jint numBands, jint bandLength, jint offset,
364                             void *tableValues)
365 {
366     //TODO
367     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_EnableLookupOp -- :TODO&quot;);
368 }
369 
370 void
371 MTLBufImgOps_DisableLookupOp(MTLContext *mtlc)
372 {
373     //TODO
374     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBufImgOps_DisableLookupOp -- :TODO&quot;);
375 }
376 
377 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
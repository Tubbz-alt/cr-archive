<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLPaints.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLPipelineStatesStorage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 #import &quot;MTLComposite.h&quot;

 37 
 38 #define RGBA_TO_V4(c)              \
 39 {                                  \
 40     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 41     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 42     ((c) &amp; 0xFF)/255.0f,           \
 43     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 44 }
 45 








 46 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 47 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 48 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 49 
 50 static void initTemplatePipelineDescriptors() {
 51     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 52         return;
 53 
 54     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 55     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 56     vertDesc.attributes[VertexAttributePosition].offset = 0;
 57     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 58     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 59     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 60     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 61 
 62     templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 63     templateRenderPipelineDesc.sampleCount = 1;
 64     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 65     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
</pre>
<hr />
<pre>
304     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
305     samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
306 
307     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
308     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
309     samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
310 
311     samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;
312     samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;
313     samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;
314 
315     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
316     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
317     samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
318 
319     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
320     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
321     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
322 }
323 
<span class="line-modified">324 static void setTxtUniforms(</span>
<span class="line-removed">325         id&lt;MTLRenderCommandEncoder&gt; encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,</span>
<span class="line-removed">326         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags</span>
<span class="line-removed">327 ) {</span>
<span class="line-removed">328     struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque, extraAlpha};</span>
<span class="line-removed">329     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];</span>
<span class="line-removed">330 </span>
331     id&lt;MTLSamplerState&gt; sampler;
332     if (repeat) {
333         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
334     } else {
335         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
336     }
337     [encoder setFragmentSamplerState:sampler atIndex:0];
338 }
339 
<span class="line-modified">340 // TODO: need support hints for all shaders</span>








341 
342 // For the current paint mode:
343 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
344 // 2. Set vertex and fragment buffers
345 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified">346                composite:(MTLComposite *)composite</span>
<span class="line-modified">347            isStencilUsed:(jboolean)isStencilUsed</span>
<span class="line-removed">348                isTexture:(jboolean)isTexture</span>
<span class="line-removed">349            interpolation:(int)interpolation</span>
<span class="line-removed">350                     isAA:(jboolean)isAA</span>
<span class="line-removed">351                 srcFlags:(const SurfaceRasterFlags *)srcFlags</span>
<span class="line-removed">352                 dstFlags:(const SurfaceRasterFlags *)dstFlags</span>
353     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
354 {
355     initTemplatePipelineDescriptors();
356 
<span class="line-modified">357     const bool stencil = isStencilUsed == JNI_TRUE;</span>
<span class="line-modified">358 </span>
<span class="line-modified">359     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;</span>
<span class="line-modified">360     if (isTexture) {</span>
<span class="line-modified">361 </span>
<span class="line-modified">362       if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {</span>
<span class="line-modified">363         pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc</span>
<span class="line-modified">364                                                 vertexShaderId:@&quot;vert_txt_tp&quot;</span>
<span class="line-modified">365                                               fragmentShaderId:@&quot;frag_txt_tp&quot;</span>
<span class="line-modified">366                                                  compositeRule:[composite getRule]</span>
<span class="line-modified">367                                                           isAA:JNI_FALSE</span>
<span class="line-modified">368                                                       srcFlags:srcFlags</span>
<span class="line-modified">369                                                       dstFlags:dstFlags</span>
<span class="line-modified">370                                                  stencilNeeded:stencil];</span>
<span class="line-modified">371         [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];</span>
<span class="line-modified">372         [encoder setFragmentTexture:_paintTexture atIndex: 1];</span>
<span class="line-modified">373 </span>
<span class="line-modified">374         setTxtUniforms(encoder, 0, 0, interpolation, YES, [composite getExtraAlpha], srcFlags, dstFlags);</span>
<span class="line-modified">375       } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {</span>
<span class="line-modified">376         pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc</span>
<span class="line-modified">377                                                 vertexShaderId:@&quot;vert_txt_grad&quot;</span>
<span class="line-modified">378                                               fragmentShaderId:@&quot;frag_txt_grad&quot;</span>
<span class="line-modified">379                                                  compositeRule:[composite getRule]</span>
<span class="line-modified">380                                                           isAA:JNI_FALSE</span>
<span class="line-modified">381                                                       srcFlags:srcFlags</span>
<span class="line-modified">382                                                       dstFlags:dstFlags</span>
<span class="line-modified">383                                                  stencilNeeded:stencil];</span>
<span class="line-modified">384         struct GradFrameUniforms uf = {</span>
<span class="line-modified">385             {_p0, _p1, _p3},</span>
<span class="line-modified">386             RGBA_TO_V4(_pixel1),</span>
<span class="line-modified">387             RGBA_TO_V4(_pixel2)};</span>
<span class="line-modified">388         [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];</span>
<span class="line-modified">389 </span>
<span class="line-modified">390       } else {</span>
<span class="line-modified">391         if (isAA) {</span>
<span class="line-modified">392           pipelineState = [pipelineStateStorage</span>
<span class="line-modified">393               getPipelineState:templateAATexturePipelineDesc</span>
<span class="line-modified">394                 vertexShaderId:@&quot;vert_txt&quot;</span>
<span class="line-modified">395               fragmentShaderId:@&quot;aa_frag_txt&quot;</span>
<span class="line-modified">396                  compositeRule:[composite getRule]</span>
<span class="line-modified">397                           isAA:JNI_FALSE</span>
<span class="line-modified">398                       srcFlags:srcFlags</span>
<span class="line-modified">399                       dstFlags:dstFlags</span>
<span class="line-modified">400                  stencilNeeded:stencil];</span>

















401 
402         } else {
<span class="line-modified">403           pipelineState =</span>
<span class="line-modified">404               [pipelineStateStorage getPipelineState:templateTexturePipelineDesc</span>
<span class="line-modified">405                                       vertexShaderId:@&quot;vert_txt&quot;</span>
<span class="line-modified">406                                     fragmentShaderId:@&quot;frag_txt&quot;</span>
<span class="line-modified">407                                        compositeRule:[composite getRule]</span>
<span class="line-modified">408                                            composite:composite</span>
<span class="line-removed">409                                                 isAA:JNI_FALSE</span>
<span class="line-removed">410                                             srcFlags:srcFlags</span>
<span class="line-removed">411                                             dstFlags:dstFlags</span>
<span class="line-removed">412                                        stencilNeeded:stencil];</span>
<span class="line-removed">413         }</span>
414 
<span class="line-modified">415         setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);</span>
<span class="line-modified">416       }</span>


417     } else {


418         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
<span class="line-modified">419             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc</span>
<span class="line-modified">420                                                     vertexShaderId:@&quot;vert_col&quot;</span>
<span class="line-removed">421                                                   fragmentShaderId:@&quot;frag_col&quot;</span>
<span class="line-removed">422                                                      compositeRule:[composite getRule]</span>
<span class="line-removed">423                                                               isAA:isAA</span>
<span class="line-removed">424                                                           srcFlags:srcFlags</span>
<span class="line-removed">425                                                           dstFlags:dstFlags</span>
<span class="line-removed">426                                                      stencilNeeded:stencil];</span>
427 
428             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
429             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
430         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
<span class="line-modified">431             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc</span>
<span class="line-modified">432                                                     vertexShaderId:@&quot;vert_grad&quot;</span>
<span class="line-removed">433                                                   fragmentShaderId:@&quot;frag_grad&quot;</span>
<span class="line-removed">434                                                      compositeRule:[composite getRule]</span>
<span class="line-removed">435                                                               isAA:isAA</span>
<span class="line-removed">436                                                           srcFlags:srcFlags</span>
<span class="line-removed">437                                                           dstFlags:dstFlags</span>
<span class="line-removed">438                                                      stencilNeeded:stencil];</span>
439 
440             struct GradFrameUniforms uf = {
441                     {_p0, _p1, _p3},
442                     RGBA_TO_V4(_pixel1),
443                     RGBA_TO_V4(_pixel2)};
<span class="line-modified">444             [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];</span>
445         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
<span class="line-modified">446             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc</span>
<span class="line-modified">447                                         vertexShaderId:@&quot;vert_tp&quot;</span>
<span class="line-removed">448                                       fragmentShaderId:@&quot;frag_tp&quot;</span>
<span class="line-removed">449                                          compositeRule:[composite getRule]</span>
<span class="line-removed">450                                                   isAA:isAA</span>
<span class="line-removed">451                                               srcFlags:srcFlags</span>
<span class="line-removed">452                                               dstFlags:dstFlags</span>
<span class="line-removed">453                                          stencilNeeded:stencil];</span>
454 
455             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
<span class="line-modified">456             [encoder setFragmentTexture:_paintTexture atIndex: 0];</span>
457         }
458     }
459 






460     [encoder setRenderPipelineState:pipelineState];
461 }
462 
463 
464 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
465 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
466 // 2. Set vertex and fragment buffers
467 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified">468                composite:(MTLComposite *)composite</span>
<span class="line-modified">469            isStencilUsed:(jboolean)isStencilUsed</span>
<span class="line-modified">470                isTexture:(jboolean)isTexture</span>
<span class="line-modified">471            interpolation:(int)interpolation</span>
<span class="line-removed">472                 srcFlags:(const SurfaceRasterFlags *)srcFlags</span>
<span class="line-removed">473                 dstFlags:(const SurfaceRasterFlags *)dstFlags</span>
<span class="line-removed">474     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage {</span>
475     initTemplatePipelineDescriptors();
476 
<span class="line-modified">477     const bool stencil = isStencilUsed == JNI_TRUE;</span>
<span class="line-modified">478     jint xorColor = (jint) [composite getXorColor];</span>
<span class="line-modified">479 </span>
<span class="line-modified">480     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;</span>
<span class="line-modified">481     if (isTexture) {</span>
<span class="line-modified">482           pipelineState = [pipelineStateStorage getXorModePipelineState:templateTexturePipelineDesc</span>
<span class="line-modified">483                                           vertexShaderId:@&quot;vert_txt&quot;</span>
<span class="line-removed">484                                         fragmentShaderId:@&quot;frag_txt&quot;</span>
<span class="line-removed">485                                                 srcFlags:srcFlags</span>
<span class="line-removed">486                                                 dstFlags:dstFlags</span>
<span class="line-removed">487                                            stencilNeeded:stencil];</span>
488         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
<span class="line-modified">489         setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);</span>
490         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
491     } else {
492         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
<span class="line-modified">493 </span>
<span class="line-modified">494             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc</span>
<span class="line-modified">495                                         vertexShaderId:@&quot;vert_col&quot;</span>
<span class="line-removed">496                                       fragmentShaderId:@&quot;frag_col&quot;</span>
<span class="line-removed">497                                               srcFlags:srcFlags</span>
<span class="line-removed">498                                               dstFlags:dstFlags</span>
<span class="line-removed">499                                          stencilNeeded:stencil];</span>
500 
501             // Calculate _color ^ xorColor for RGB components
502             // This color gets XORed with destination framebuffer pixel color
503             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
504             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
505 
506         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
<span class="line-modified">507 </span>
<span class="line-modified">508             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc</span>
<span class="line-modified">509                                         vertexShaderId:@&quot;vert_grad&quot;</span>
<span class="line-removed">510                                       fragmentShaderId:@&quot;frag_grad&quot;</span>
<span class="line-removed">511                                               srcFlags:srcFlags</span>
<span class="line-removed">512                                               dstFlags:dstFlags</span>
<span class="line-removed">513                                          stencilNeeded:stencil];</span>
514 
515                 struct GradFrameUniforms uf = {
516                         {_p0, _p1, _p3},
517                         RGBA_TO_V4(_pixel1 ^ xorColor),
518                         RGBA_TO_V4(_pixel2 ^ xorColor)};
519                 [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
520             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {



521 
<span class="line-removed">522                 pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc</span>
<span class="line-removed">523                                             vertexShaderId:@&quot;vert_tp&quot;</span>
<span class="line-removed">524                                           fragmentShaderId:@&quot;frag_tp_xorMode&quot;</span>
<span class="line-removed">525                                                   srcFlags:srcFlags</span>
<span class="line-removed">526                                                   dstFlags:dstFlags</span>
<span class="line-removed">527                                              stencilNeeded:stencil];</span>
528 
529                 [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
530                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
531                 [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
532             }
533         }







534     [encoder setRenderPipelineState:pipelineState];
535 }
536 
537 @end
538 
539 /************************* GradientPaint support ****************************/
540 
541 static void
542 MTLPaints_InitGradientTexture()
543 {
544     //TODO
545     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
546 }
547 
548 /****************** Shared MultipleGradientPaint support ********************/
549 
550 /**
551  * These constants are identical to those defined in the
552  * MultipleGradientPaint.CycleMethod enum; they are copied here for
553  * convenience (ideally we would pull them directly from the Java level,
</pre>
</td>
<td>
<hr />
<pre>
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 #import &quot;MTLComposite.h&quot;
<span class="line-added"> 37 #import &quot;MTLBufImgOps.h&quot;</span>
 38 
 39 #define RGBA_TO_V4(c)              \
 40 {                                  \
 41     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 42     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 43     ((c) &amp; 0xFF)/255.0f,           \
 44     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 45 }
 46 
<span class="line-added"> 47 #define FLOAT_ARR_TO_V4(p) \</span>
<span class="line-added"> 48 {                      \</span>
<span class="line-added"> 49     p[0], \</span>
<span class="line-added"> 50     p[1], \</span>
<span class="line-added"> 51     p[2], \</span>
<span class="line-added"> 52     p[3]  \</span>
<span class="line-added"> 53 }</span>
<span class="line-added"> 54 </span>
 55 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 56 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 57 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 58 
 59 static void initTemplatePipelineDescriptors() {
 60     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 61         return;
 62 
 63     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 64     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 65     vertDesc.attributes[VertexAttributePosition].offset = 0;
 66     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 67     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 68     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 69     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 70 
 71     templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 72     templateRenderPipelineDesc.sampleCount = 1;
 73     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 74     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
</pre>
<hr />
<pre>
313     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
314     samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
315 
316     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
317     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
318     samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
319 
320     samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;
321     samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;
322     samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;
323 
324     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
325     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
326     samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
327 
328     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
329     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
330     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
331 }
332 
<span class="line-modified">333 static void setSampler(id&lt;MTLRenderCommandEncoder&gt; encoder, int interpolation, bool repeat) {</span>






334     id&lt;MTLSamplerState&gt; sampler;
335     if (repeat) {
336         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
337     } else {
338         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
339     }
340     [encoder setFragmentSamplerState:sampler atIndex:0];
341 }
342 
<span class="line-modified">343 static void setTxtUniforms(</span>
<span class="line-added">344         id&lt;MTLRenderCommandEncoder&gt; encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,</span>
<span class="line-added">345         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags</span>
<span class="line-added">346 ) {</span>
<span class="line-added">347     struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque, extraAlpha};</span>
<span class="line-added">348     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];</span>
<span class="line-added">349 </span>
<span class="line-added">350     setSampler(encoder, interpolation, repeat);</span>
<span class="line-added">351 }</span>
352 
353 // For the current paint mode:
354 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
355 // 2. Set vertex and fragment buffers
356 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified">357                  context:(MTLContext *)mtlc</span>
<span class="line-modified">358            renderOptions:(const RenderOptions *)renderOptions</span>





359     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
360 {
361     initTemplatePipelineDescriptors();
362 
<span class="line-modified">363     NSString * vertShader = @&quot;vert_txt&quot;;</span>
<span class="line-modified">364     NSString * fragShader = @&quot;frag_txt&quot;;</span>
<span class="line-modified">365     MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;</span>
<span class="line-modified">366 </span>
<span class="line-modified">367     if (renderOptions-&gt;isTexture) {</span>
<span class="line-modified">368         NSObject *bufImgOp = [mtlc getBufImgOp];</span>
<span class="line-modified">369         if (bufImgOp != nil) {</span>
<span class="line-modified">370             if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {</span>
<span class="line-modified">371                 MTLRescaleOp *rescaleOp = bufImgOp;</span>
<span class="line-modified">372                 vertShader = @&quot;vert_txt&quot;;</span>
<span class="line-modified">373                 fragShader = @&quot;frag_txt_op_rescale&quot;;</span>
<span class="line-modified">374 </span>
<span class="line-modified">375                 struct TxtFrameOpRescaleUniforms uf = {</span>
<span class="line-modified">376                         RGBA_TO_V4(0), [mtlc.composite getExtraAlpha], renderOptions-&gt;srcFlags.isOpaque,</span>
<span class="line-modified">377                         rescaleOp.isNonPremult,</span>
<span class="line-modified">378                         FLOAT_ARR_TO_V4([rescaleOp getScaleFactors]), FLOAT_ARR_TO_V4([rescaleOp getOffsets])</span>
<span class="line-modified">379                 };</span>
<span class="line-modified">380                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];</span>
<span class="line-modified">381                 setSampler(encoder, renderOptions-&gt;interpolation, NO);</span>
<span class="line-modified">382             } else if ([bufImgOp isKindOfClass:[MTLConvolveOp class]]) {</span>
<span class="line-modified">383                 MTLConvolveOp * convolveOp = bufImgOp;</span>
<span class="line-modified">384                 vertShader = @&quot;vert_txt&quot;;</span>
<span class="line-modified">385                 fragShader = @&quot;frag_txt_op_convolve&quot;;</span>
<span class="line-modified">386 </span>
<span class="line-modified">387                 struct TxtFrameOpConvolveUniforms uf = {</span>
<span class="line-modified">388                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([convolveOp getImgEdge]),</span>
<span class="line-modified">389                         convolveOp.kernelSize, convolveOp.isEdgeZeroFill,</span>
<span class="line-modified">390                 };</span>
<span class="line-modified">391                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];</span>
<span class="line-modified">392                 setSampler(encoder, renderOptions-&gt;interpolation, NO);</span>
<span class="line-modified">393 </span>
<span class="line-modified">394                 [encoder setFragmentBuffer:[convolveOp getBuffer] offset:0 atIndex:2];</span>
<span class="line-modified">395             } else if ([bufImgOp isKindOfClass:[MTLLookupOp class]]) {</span>
<span class="line-modified">396                 MTLLookupOp * lookupOp = bufImgOp;</span>
<span class="line-modified">397                 vertShader = @&quot;vert_txt&quot;;</span>
<span class="line-modified">398                 fragShader = @&quot;frag_txt_op_lookup&quot;;</span>
<span class="line-modified">399 </span>
<span class="line-modified">400                 struct TxtFrameOpLookupUniforms uf = {</span>
<span class="line-modified">401                         [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([lookupOp getOffset]),</span>
<span class="line-modified">402                         lookupOp.isUseSrcAlpha, lookupOp.isNonPremult,</span>
<span class="line-modified">403                 };</span>
<span class="line-modified">404                 [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];</span>
<span class="line-modified">405                 setSampler(encoder, renderOptions-&gt;interpolation, NO);</span>
<span class="line-modified">406                 [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex: 1];</span>
<span class="line-added">407             }</span>
<span class="line-added">408         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {</span>
<span class="line-added">409             vertShader = @&quot;vert_txt_tp&quot;;</span>
<span class="line-added">410             fragShader = @&quot;frag_txt_tp&quot;;</span>
<span class="line-added">411             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];</span>
<span class="line-added">412             [encoder setFragmentTexture:_paintTexture atIndex:1];</span>
<span class="line-added">413 </span>
<span class="line-added">414             setTxtUniforms(encoder, 0, 0, renderOptions-&gt;interpolation, YES, [mtlc.composite getExtraAlpha],</span>
<span class="line-added">415                            &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);</span>
<span class="line-added">416         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {</span>
<span class="line-added">417             vertShader = @&quot;vert_txt_grad&quot;;</span>
<span class="line-added">418             fragShader = @&quot;frag_txt_grad&quot;;</span>
<span class="line-added">419             struct GradFrameUniforms uf = {</span>
<span class="line-added">420                     {_p0, _p1, _p3},</span>
<span class="line-added">421                     RGBA_TO_V4(_pixel1),</span>
<span class="line-added">422                     RGBA_TO_V4(_pixel2)};</span>
<span class="line-added">423             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];</span>
424 
425         } else {
<span class="line-modified">426             vertShader = @&quot;vert_txt&quot;;</span>
<span class="line-modified">427             fragShader = @&quot;frag_txt&quot;;</span>
<span class="line-modified">428             if (renderOptions-&gt;isAA) {</span>
<span class="line-modified">429                 fragShader = @&quot;aa_frag_txt&quot;;</span>
<span class="line-modified">430                 rpDesc = templateAATexturePipelineDesc;</span>
<span class="line-modified">431             }</span>





432 
<span class="line-modified">433             setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,</span>
<span class="line-modified">434                            renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha], &amp;renderOptions-&gt;srcFlags,</span>
<span class="line-added">435                            &amp;renderOptions-&gt;dstFlags);</span>
<span class="line-added">436         }</span>
437     } else {
<span class="line-added">438         rpDesc = templateRenderPipelineDesc;</span>
<span class="line-added">439 </span>
440         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
<span class="line-modified">441             vertShader = @&quot;vert_col&quot;;</span>
<span class="line-modified">442             fragShader = @&quot;frag_col&quot;;</span>






443 
444             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
445             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
446         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
<span class="line-modified">447             vertShader = @&quot;vert_grad&quot;;</span>
<span class="line-modified">448             fragShader = @&quot;frag_grad&quot;;</span>






449 
450             struct GradFrameUniforms uf = {
451                     {_p0, _p1, _p3},
452                     RGBA_TO_V4(_pixel1),
453                     RGBA_TO_V4(_pixel2)};
<span class="line-modified">454             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:0];</span>
455         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
<span class="line-modified">456             vertShader = @&quot;vert_tp&quot;;</span>
<span class="line-modified">457             fragShader = @&quot;frag_tp&quot;;</span>






458 
459             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
<span class="line-modified">460             [encoder setFragmentTexture:_paintTexture atIndex:0];</span>
461         }
462     }
463 
<span class="line-added">464     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc</span>
<span class="line-added">465                                                                         vertexShaderId:vertShader</span>
<span class="line-added">466                                                                       fragmentShaderId:fragShader</span>
<span class="line-added">467                                                                              composite:mtlc.composite</span>
<span class="line-added">468                                                                          renderOptions:renderOptions</span>
<span class="line-added">469                                                                          stencilNeeded:[mtlc.clip isShape]];</span>
470     [encoder setRenderPipelineState:pipelineState];
471 }
472 
473 
474 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
475 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
476 // 2. Set vertex and fragment buffers
477 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
<span class="line-modified">478                         context:(MTLContext *)mtlc</span>
<span class="line-modified">479                   renderOptions:(const RenderOptions *)renderOptions</span>
<span class="line-modified">480            pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage</span>
<span class="line-modified">481 {</span>



482     initTemplatePipelineDescriptors();
483 
<span class="line-modified">484     jint xorColor = (jint) [mtlc.composite getXorColor];</span>
<span class="line-modified">485 </span>
<span class="line-modified">486     NSString * vertShader = @&quot;vert_txt&quot;;</span>
<span class="line-modified">487     NSString * fragShader = @&quot;frag_txt&quot;;</span>
<span class="line-modified">488     MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;</span>
<span class="line-modified">489 </span>
<span class="line-modified">490     if (renderOptions-&gt;isTexture) {</span>




491         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
<span class="line-modified">492         setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, renderOptions-&gt;interpolation, NO, [mtlc.composite getExtraAlpha], &amp;renderOptions-&gt;srcFlags, &amp;renderOptions-&gt;dstFlags);</span>
493         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
494     } else {
495         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
<span class="line-modified">496             vertShader = @&quot;vert_col&quot;;</span>
<span class="line-modified">497             fragShader = @&quot;frag_col&quot;;</span>
<span class="line-modified">498             rpDesc = templateRenderPipelineDesc;</span>




499 
500             // Calculate _color ^ xorColor for RGB components
501             // This color gets XORed with destination framebuffer pixel color
502             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
503             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
504 
505         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
<span class="line-modified">506             vertShader = @&quot;vert_grad&quot;;</span>
<span class="line-modified">507             fragShader = @&quot;frag_grad&quot;;</span>
<span class="line-modified">508             rpDesc = templateRenderPipelineDesc;</span>




509 
510                 struct GradFrameUniforms uf = {
511                         {_p0, _p1, _p3},
512                         RGBA_TO_V4(_pixel1 ^ xorColor),
513                         RGBA_TO_V4(_pixel2 ^ xorColor)};
514                 [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
515             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
<span class="line-added">516             vertShader = @&quot;vert_tp&quot;;</span>
<span class="line-added">517             fragShader = @&quot;frag_tp_xorMode&quot;;</span>
<span class="line-added">518             rpDesc = templateRenderPipelineDesc;</span>
519 






520 
521                 [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
522                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
523                 [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
524             }
525         }
<span class="line-added">526 </span>
<span class="line-added">527     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:rpDesc</span>
<span class="line-added">528                                                                         vertexShaderId:vertShader</span>
<span class="line-added">529                                                                       fragmentShaderId:fragShader</span>
<span class="line-added">530                                                                              composite:mtlc.composite</span>
<span class="line-added">531                                                                          renderOptions:renderOptions</span>
<span class="line-added">532                                                                          stencilNeeded:[mtlc.clip isShape]];</span>
533     [encoder setRenderPipelineState:pipelineState];
534 }
535 
536 @end
537 
538 /************************* GradientPaint support ****************************/
539 
540 static void
541 MTLPaints_InitGradientTexture()
542 {
543     //TODO
544     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
545 }
546 
547 /****************** Shared MultipleGradientPaint support ********************/
548 
549 /**
550  * These constants are identical to those defined in the
551  * MultipleGradientPaint.CycleMethod enum; they are copied here for
552  * convenience (ideally we would pull them directly from the Java level,
</pre>
</td>
</tr>
</table>
<center><a href="MTLPaints.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLPipelineStatesStorage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
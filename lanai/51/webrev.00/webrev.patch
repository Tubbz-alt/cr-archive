diff a/src/java.desktop/macosx/classes/sun/java2d/metal/MTLContext.java b/src/java.desktop/macosx/classes/sun/java2d/metal/MTLContext.java
--- a/src/java.desktop/macosx/classes/sun/java2d/metal/MTLContext.java
+++ b/src/java.desktop/macosx/classes/sun/java2d/metal/MTLContext.java
@@ -132,11 +132,11 @@
         /**
          * This cap will only be set if the biopshader system property has been
          * enabled and the hardware meets our minimum requirements.
          */
         @Native
-        static final int CAPS_EXT_BIOP_SHADER  = (FIRST_PRIVATE_CAP << 2);
+        public static final int CAPS_EXT_BIOP_SHADER  = (FIRST_PRIVATE_CAP << 2);
         /**
          * This cap will only be set if the gradshader system property has been
          * enabled and the hardware meets our minimum requirements.
          */
         @Native
diff a/src/java.desktop/macosx/classes/sun/java2d/metal/MTLGraphicsConfig.java b/src/java.desktop/macosx/classes/sun/java2d/metal/MTLGraphicsConfig.java
--- a/src/java.desktop/macosx/classes/sun/java2d/metal/MTLGraphicsConfig.java
+++ b/src/java.desktop/macosx/classes/sun/java2d/metal/MTLGraphicsConfig.java
@@ -50,10 +50,12 @@
 
 import static sun.java2d.opengl.OGLSurfaceData.TEXTURE;
 import static sun.java2d.pipe.hw.AccelSurface.RT_TEXTURE;
 import static sun.java2d.pipe.hw.ContextCapabilities.*;
 
+import static sun.java2d.metal.MTLContext.MTLContextCaps.CAPS_EXT_BIOP_SHADER;
+
 public final class MTLGraphicsConfig extends CGraphicsConfig
         implements AccelGraphicsConfig, SurfaceManager.ProxiedGraphicsConfig
 {
     //private static final int kOpenGLSwapInterval =
     // RuntimeOptions.getCurrentOptions().OpenGLSwapInterval;
@@ -155,11 +157,11 @@
         }
 
         ContextCapabilities caps = new MTLContext.MTLContextCaps(
                 CAPS_PS30 | CAPS_PS20 | CAPS_RT_PLAIN_ALPHA |
                         CAPS_RT_TEXTURE_ALPHA | CAPS_RT_TEXTURE_OPAQUE |
-                        CAPS_MULTITEXTURE | CAPS_TEXNONPOW2 | CAPS_TEXNONSQUARE,
+                        CAPS_MULTITEXTURE | CAPS_TEXNONPOW2 | CAPS_TEXNONSQUARE | CAPS_EXT_BIOP_SHADER,
                 ids[0]);
         return new MTLGraphicsConfig(device, pixfmt, cfginfo, textureSize, caps);
     }
 
     /**
diff a/src/java.desktop/macosx/native/libawt_lwawt/awt/common.h b/src/java.desktop/macosx/native/libawt_lwawt/awt/common.h
--- a/src/java.desktop/macosx/native/libawt_lwawt/awt/common.h
+++ b/src/java.desktop/macosx/native/libawt_lwawt/awt/common.h
@@ -79,10 +79,35 @@
     int isSrcOpaque;
     int isDstOpaque;
     float extraAlpha;
 };
 
+struct TxtFrameOpRescaleUniforms {
+    vector_float4 color;
+    float extraAlpha;
+
+    int isSrcOpaque;
+    int isNonPremult;
+
+    vector_float4 normScaleFactors;
+    vector_float4 normOffsets;
+};
+
+struct TxtFrameOpConvolveUniforms {
+    float extraAlpha;
+    vector_float4 imgEdge;
+    int kernelSize;
+    int isEdgeZeroFill;
+};
+
+struct TxtFrameOpLookupUniforms {
+    float extraAlpha;
+    vector_float4 offset;
+    int isUseSrcAlpha;
+    int isNonPremult;
+};
+
 struct AnchorData
 {
     vector_float3 xParams;
     vector_float3 yParams;
 };
diff a/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal b/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal
--- a/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal
+++ b/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal
@@ -199,10 +199,128 @@
         }
     }
     return half4(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a);
 }
 
+fragment half4 frag_txt_op_rescale(
+        TxtShaderInOut vert [[stage_in]],
+        texture2d<float, access::sample> srcTex [[texture(0)]],
+        constant TxtFrameOpRescaleUniforms& uniforms [[buffer(1)]],
+        sampler textureSampler [[sampler(0)]]
+) {
+    float4 srcColor = srcTex.sample(textureSampler, vert.texCoords);
+    const float srcA = uniforms.isSrcOpaque ? 1 : srcColor.a;
+
+    // TODO: check uniforms.isNonPremult and pre-multiply if necessary
+    return half4(srcColor.r*uniforms.normScaleFactors.r + uniforms.normOffsets.r,
+                 srcColor.g*uniforms.normScaleFactors.g + uniforms.normOffsets.g,
+                 srcColor.b*uniforms.normScaleFactors.b + uniforms.normOffsets.b, srcA*uniforms.extraAlpha);
+
+    // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it's better to do the
+    // same here.
+    //
+    // GL-shader impl:
+    //"    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);"
+    //"    %s"                                                      // (placeholder for un-premult code: srcColor.rgb /= srcColor.a;)
+    //"    vec4 result = (srcColor * scaleFactors) + offsets;"      // rescale source value
+    //"    %s"                                                      // (placeholder for re-premult code: result.rgb *= result.a;)
+    //"    gl_FragColor = result * gl_Color;"                       // modulate with gl_Color in order to apply extra alpha
+}
+
+fragment half4 frag_txt_op_convolve(
+        TxtShaderInOut vert [[stage_in]],
+        texture2d<float, access::sample> srcTex [[texture(0)]],
+        constant TxtFrameOpConvolveUniforms& uniforms [[buffer(1)]],
+        const device float3 * kernelVals [[buffer(2)]],
+        sampler textureSampler [[sampler(0)]]
+) {
+    float4 sum = float4(0, 0, 0, 0);
+    if (vert.texCoords[0] < uniforms.imgEdge[0]
+        || vert.texCoords[1] < uniforms.imgEdge[1]
+        || vert.texCoords[0] > uniforms.imgEdge[2]
+        || vert.texCoords[1] > uniforms.imgEdge[3]
+    ) {
+        if (!uniforms.isEdgeZeroFill) {
+            sum = srcTex.sample(textureSampler, vert.texCoords);
+        }
+    }
+
+    for (int i = 0; i < uniforms.kernelSize; i++) {
+        float3 kern = kernelVals[i];
+        float2 pos = float2(vert.texCoords.x + kern.x, vert.texCoords.y + kern.y);
+        float4 pixCol = srcTex.sample(textureSampler, pos);
+        sum.r += kern.z * pixCol.r;
+        sum.g += kern.z * pixCol.g;
+        sum.b += kern.z * pixCol.b;
+        sum.a += kern.z * pixCol.a;
+    }
+
+    return half4(sum.r, sum.g, sum.b, sum.a*uniforms.extraAlpha);
+
+    // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it's better to do the
+    // same here.
+    //
+    // GL-shader impl:
+    //"    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||"
+    //"        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))"
+    //"    {"
+    //"        %s"      // (placeholder for edge condition code)
+    //"    } else {"
+    //"        sum = vec4(0.0);"
+    //"        for (i = 0; i < MAX_KERNEL_SIZE; i++) {"
+    //"            sum +="
+    //"                kernelVals[i].z *"
+    //"                texture%s(baseImage,"
+    //"                          gl_TexCoord[0].st + kernelVals[i].xy);"
+    //"        }"
+    //"    }"
+    //""
+    //"    gl_FragColor = sum * gl_Color;" // modulate with gl_Color in order to apply extra alpha
+}
+
+fragment half4 frag_txt_op_lookup(
+        TxtShaderInOut vert [[stage_in]],
+        texture2d<float, access::sample> srcTex [[texture(0)]],
+        texture2d<float, access::sample> lookupTex [[texture(1)]],
+        constant TxtFrameOpLookupUniforms& uniforms [[buffer(1)]],
+        sampler textureSampler [[sampler(0)]]
+) {
+    float4 srcColor = srcTex.sample(textureSampler, vert.texCoords);
+    float4 srcIndex = srcColor - uniforms.offset;
+    const float2 posR = float2(srcIndex.r, 0.125);
+    const float2 posG = float2(srcIndex.g, 0.375);
+    const float2 posB = float2(srcIndex.b, 0.625);
+
+    float4 lookupR = lookupTex.sample(textureSampler, posR);
+    float4 lookupG = lookupTex.sample(textureSampler, posG);
+    float4 lookupB = lookupTex.sample(textureSampler, posB);
+
+    const float a = uniforms.isUseSrcAlpha ? srcColor.a : lookupTex.sample(textureSampler, float2(srcIndex.a, 0.875)).a;
+
+    // TODO: check uniforms.isNonPremult and pre-multiply if necessary
+    return half4(lookupR.a, lookupG.a, lookupB.a, a*uniforms.extraAlpha);
+
+    // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it's better to do the
+    // same here.
+    //
+    // GL-shader impl:
+    //"    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);"
+    //"    %s"                                  // (placeholder for un-premult code)
+    //"    vec4 srcIndex = srcColor - offset;"  // subtract offset from original index
+    //
+    //      // use source value as input to lookup table (note that
+    //      // "v" texcoords are hardcoded to hit texel centers of
+    //      // each row/band in texture)
+    //"    vec4 result;"
+    //"    result.r = texture2D(lookupTable, vec2(srcIndex.r, 0.125)).r;"
+    //"    result.g = texture2D(lookupTable, vec2(srcIndex.g, 0.375)).r;"
+    //"    result.b = texture2D(lookupTable, vec2(srcIndex.b, 0.625)).r;"
+    //"    %s"                                  // (placeholder for alpha store code)
+    //"    %s"                                  // (placeholder for re-premult code)
+    //"    gl_FragColor = result * gl_Color;"   // modulate with gl_Color in order to apply extra alpha
+}
+
 fragment half4 frag_grad(GradShaderInOut in [[stage_in]],
                          constant GradFrameUniforms& uniforms [[buffer(0)]]) {
     float3 v = float3(in.position.x, in.position.y, 1);
     float  a = (dot(v,uniforms.params)-0.25)*2.0;
     float4 c = mix(uniforms.color1, uniforms.color2, a);
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.h b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.h
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.h
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.h
@@ -1,12 +1,11 @@
 #ifndef EncoderManager_h_Included
 #define EncoderManager_h_Included
 
 #import <Metal/Metal.h>
 
-#include <jni.h>
-#include "MTLSurfaceDataBase.h"
+#include "RenderOptions.h"
 
 @class MTLContex;
 
 /**
  * The EncoderManager class used to obtain MTLRenderCommandEncoder (or MTLBlitCommandEncoder) corresponding
@@ -54,17 +53,13 @@
                                               isDstOpaque:(bool)isDstOpaque
                                             interpolation:(int)interpolation
                                                      isAA:(jboolean)isAA;
 
 // Base method to obtain any MTLRenderCommandEncoder
-- (id<MTLRenderCommandEncoder> _Nonnull)
-    getEncoder:(id<MTLTexture> _Nonnull)dest
-      isOpaque:(jboolean)isOpaque
-     isTexture:(jboolean)isTexture
- interpolation:(int)interpolation
-          isAA:(jboolean)isAA
-      srcFlags:(const SurfaceRasterFlags *_Nullable)srcFlags;
+- (id<MTLRenderCommandEncoder> _Nonnull) getEncoder:(id<MTLTexture> _Nonnull)dest
+                                       isDestOpaque:(jboolean)isDestOpaque
+                                      renderOptions:(const RenderOptions * _Nonnull)renderOptions;
 
 - (id<MTLBlitCommandEncoder> _Nonnull)createBlitEncoder;
 
 - (void)endEncoder;
 @end
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/EncoderManager.m
@@ -19,17 +19,12 @@
            isDstOpaque:(jboolean)isDstOpaque
     isDstPremultiplied:(jboolean)isDstPremultiplied
                   isAA:(jboolean)isAA;
 
 - (void)updateEncoder:(id<MTLRenderCommandEncoder>)encoder
-                paint:(MTLPaint *)paint
-            composite:(MTLComposite *)composite
-            isTexture:(jboolean)isTexture
-                 isAA:(jboolean)isAA
-             srcFlags:(const SurfaceRasterFlags * _Nullable)srcFlags
-                 clip:(MTLClip *)clip
-            transform:(MTLTransform *)transform
+              context:(MTLContext *)mtlc
+        renderOptions:(const RenderOptions *)renderOptions
           forceUpdate:(jboolean)forceUpdate;
 @property jboolean aa;
 @end
 
 @implementation EncoderStates {
@@ -99,100 +94,72 @@
     _isAA = isAA;
     // NOTE: probably it's better to invalidate/reset all cached states now
 }
 
 - (void)updateEncoder:(id<MTLRenderCommandEncoder>)encoder
-                paint:(MTLPaint *)paint
-            composite:(MTLComposite *)composite
-            isTexture:(jboolean)isTexture
-        interpolation:(int)interpolation
-                 isAA:(jboolean)isAA
-             srcFlags:(const SurfaceRasterFlags * _Nullable)srcFlags
-                 clip:(MTLClip *)clip
-            transform:(MTLTransform *)transform
+              context:(MTLContext *)mtlc
+        renderOptions:(const RenderOptions *)renderOptions
           forceUpdate:(jboolean)forceUpdate
 {
     // 1. Process special case for stencil mask generation
-    if (clip.stencilMaskGenerationInProgress == JNI_TRUE) {
+    if (mtlc.clip.stencilMaskGenerationInProgress == JNI_TRUE) {
         // use separate pipeline state for stencil generation
         if (forceUpdate || (_clip.stencilMaskGenerationInProgress != JNI_TRUE)) {
-            [_clip copyFrom:clip];
+            [_clip copyFrom:mtlc.clip];
             [_clip setMaskGenerationPipelineState:encoder
                                         destWidth:_destination.width
                                        destHeight:_destination.height
                              pipelineStateStorage:_pipelineStateStorage];
         }
 
-        [self updateTransform:encoder transform:transform forceUpdate:forceUpdate];
+        [self updateTransform:encoder transform:mtlc.transform forceUpdate:forceUpdate];
         return;
     }
 
     // 2. Otherwise update all 'mutable' properties of encoder
     [self updatePipelineState:encoder
-                        paint:paint
-                    composite:composite
-                isStencilUsed:[clip isShape]
-                    isTexture:isTexture
-                interpolation:interpolation
-                         isAA:isAA
-                     srcFlags:srcFlags
+                      context:mtlc
+                renderOptions:renderOptions
                   forceUpdate:forceUpdate];
-    [self updateTransform:encoder transform:transform forceUpdate:forceUpdate];
-    [self updateClip:encoder clip:clip forceUpdate:forceUpdate];
+    [self updateTransform:encoder transform:mtlc.transform forceUpdate:forceUpdate];
+    [self updateClip:encoder clip:mtlc.clip forceUpdate:forceUpdate];
 }
 
 //
 // Internal methods that update states when necessary (compare with cached states)
 //
 
 // Updates pipelineState (and corresponding buffers) with use of paint+composite+flags
 - (void)updatePipelineState:(id<MTLRenderCommandEncoder>)encoder
-                      paint:(MTLPaint *)paint
-                  composite:(MTLComposite *)composite
-              isStencilUsed:(jboolean)isStencilUsed
-                  isTexture:(jboolean)isTexture
-              interpolation:(int)interpolation
-                       isAA:(jboolean)isAA
-                   srcFlags:(const SurfaceRasterFlags * _Nullable)srcFlags
+                    context:(MTLContext *)mtlc
+              renderOptions:(const RenderOptions *)renderOptions
                 forceUpdate:(jboolean)forceUpdate
 {
-    if (srcFlags == NULL)
-        srcFlags = &defaultRasterFlags;
-
     if (!forceUpdate
-        && [_paint isEqual:paint]
-        && [_composite isEqual:composite]
-        && (_isTexture == isTexture && (!isTexture || _interpolationMode == interpolation)) // interpolation is used only in texture mode
-        && _isAA == isAA
-        && _srcFlags.isOpaque == srcFlags->isOpaque && _srcFlags.isPremultiplied == srcFlags->isPremultiplied)
+        && [_paint isEqual:mtlc.paint]
+        && [_composite isEqual:mtlc.composite]
+        && (_isTexture == renderOptions->isTexture && (!renderOptions->isTexture || _interpolationMode == renderOptions->interpolation)) // interpolation is used only in texture mode
+        && _isAA == renderOptions->isAA
+        && _srcFlags.isOpaque == renderOptions->srcFlags.isOpaque && _srcFlags.isPremultiplied == renderOptions->srcFlags.isPremultiplied)
         return;
 
-    [_paint copyFrom:paint];
-    [_composite copyFrom:composite];
-    _isTexture = isTexture;
-    _interpolationMode = interpolation;
-    _isAA = isAA;
-    _srcFlags = *srcFlags;
-
-    if ((jint)[composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR) {
-        [paint setXorModePipelineState:encoder
-                      composite:_composite
-                  isStencilUsed:isStencilUsed
-                      isTexture:_isTexture
-                  interpolation:interpolation
-                       srcFlags:&_srcFlags
-                       dstFlags:&_dstFlags
-           pipelineStateStorage:_pipelineStateStorage];
+    [_paint copyFrom:mtlc.paint];
+    [_composite copyFrom:mtlc.composite];
+    _isTexture = renderOptions->isTexture;
+    _interpolationMode = renderOptions->interpolation;
+    _isAA = renderOptions->isAA;
+    _srcFlags = renderOptions->srcFlags;
+
+    if ((jint)[mtlc.composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR) {
+        [mtlc.paint setXorModePipelineState:encoder
+                               context:mtlc
+                         renderOptions:renderOptions
+                  pipelineStateStorage:_pipelineStateStorage];
     } else {
-        [paint setPipelineState:encoder
-                      composite:_composite
-                  isStencilUsed:isStencilUsed
-                      isTexture:_isTexture
-                  interpolation:interpolation
-                           isAA:isAA
-                       srcFlags:&_srcFlags
-                       dstFlags:&_dstFlags
+        [mtlc.paint setPipelineState:encoder
+                        context:mtlc
+                  renderOptions:renderOptions
            pipelineStateStorage:_pipelineStateStorage];
     }
 }
 
 - (void) updateClip:(id<MTLRenderCommandEncoder>)encoder clip:(MTLClip *)clip forceUpdate:(jboolean)forceUpdate
@@ -270,27 +237,19 @@
     return [self getRenderEncoder:dstOps->pTexture isDstOpaque:dstOps->isOpaque];
 }
 
 - (id<MTLRenderCommandEncoder> _Nonnull)getAARenderEncoder:(const BMTLSDOps * _Nonnull)dstOps {
   id<MTLTexture> dstTxt = dstOps->pTexture;
-  return [self getEncoder:dstTxt
-                 isOpaque:dstOps->isOpaque
-                isTexture:JNI_FALSE
-           interpolation:INTERPOLATION_NEAREST_NEIGHBOR
-                     isAA:JNI_TRUE
-                 srcFlags:NULL];
+  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}};
+  return [self getEncoder:dstTxt renderOptions:&roptions];
 }
 
 - (id<MTLRenderCommandEncoder> _Nonnull)getRenderEncoder:(id<MTLTexture> _Nonnull)dest
                                              isDstOpaque:(bool)isOpaque
 {
-    return [self getEncoder:dest
-                 isOpaque:isOpaque
-                isTexture:JNI_FALSE
-            interpolation:INTERPOLATION_NEAREST_NEIGHBOR
-                     isAA:JNI_FALSE
-                 srcFlags:NULL];
+    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}};
+    return [self getEncoder:dest renderOptions:&roptions];
 }
 
 - (id<MTLRenderCommandEncoder> _Nonnull) getTextureEncoder:(const BMTLSDOps * _Nonnull)dstOps
                                       isSrcOpaque:(bool)isSrcOpaque
 {
@@ -315,40 +274,31 @@
                                       isSrcOpaque:(bool)isSrcOpaque
                                       isDstOpaque:(bool)isDstOpaque
                                     interpolation:(int)interpolation
                                              isAA:(jboolean)isAA
 {
-    SurfaceRasterFlags srcFlags = { isSrcOpaque, JNI_TRUE };
-    return [self getEncoder:dest
-                   isOpaque:isDstOpaque
-                  isTexture:JNI_TRUE
-              interpolation:interpolation
-                       isAA:isAA
-                   srcFlags:&srcFlags];
+    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}};
+    return [self getEncoder:dest renderOptions:&roptions];
 }
 
 - (id<MTLRenderCommandEncoder> _Nonnull) getTextureEncoder:(id<MTLTexture> _Nonnull)dest
                                                isSrcOpaque:(bool)isSrcOpaque
                                                isDstOpaque:(bool)isDstOpaque
                                              interpolation:(int)interpolation
 {
     return [self getTextureEncoder:dest isSrcOpaque:isSrcOpaque isDstOpaque:isDstOpaque interpolation:interpolation isAA:JNI_FALSE];
 }
 
-- (id<MTLRenderCommandEncoder> _Nonnull)
-    getEncoder:(id<MTLTexture> _Nonnull)dest
-      isOpaque:(jboolean)isOpaque
-     isTexture:(jboolean)isTexture
- interpolation:(int)interpolation
-          isAA:(jboolean)isAA
-      srcFlags:(const SurfaceRasterFlags *_Nullable)srcFlags {
+- (id<MTLRenderCommandEncoder> _Nonnull) getEncoder:(id <MTLTexture> _Nonnull)dest
+                                      renderOptions:(const RenderOptions * _Nonnull)renderOptions
+{
   //
   // 1. check whether it's necessary to call endEncoder
   //
   jboolean needEnd = JNI_FALSE;
   if (_encoder != nil) {
-    if (_destination != dest || isAA != _encoderStates.aa) {
+    if (_destination != dest || renderOptions->isAA != _encoderStates.aa) {
       J2dTraceLn2(J2D_TRACE_VERBOSE,
                   "end common encoder because of dest change: %p -> %p",
                   _destination, dest);
       needEnd = JNI_TRUE;
     } else if ((_useStencil == NO) != ([_mtlc.clip isShape] == NO)) {
@@ -384,11 +334,11 @@
 
     MTLCommandBufferWrapper *cbw = [_mtlc getCommandBufferWrapper];
     MTLRenderPassDescriptor *rpd =
         [MTLRenderPassDescriptor renderPassDescriptor];
     MTLRenderPassColorAttachmentDescriptor *ca = rpd.colorAttachments[0];
-    if (isAA && !isTexture) {
+    if (renderOptions->isAA && !renderOptions->isTexture) {
       MTLTexturePoolItem *tiBuf = [_mtlc.texturePool getTexture:dest.width
                                                       height:dest.height
                                                       format:MTLPixelFormatBGRA8Unorm];
       [cbw registerPooledTexture:tiBuf];
       [tiBuf release];
@@ -409,11 +359,11 @@
       ca.texture = dest;
       ca.loadAction = MTLLoadActionLoad;
       ca.storeAction = MTLStoreActionStore;
     }
 
-    if (_useStencil && !isAA) {
+    if (_useStencil && !renderOptions->isAA) {
         // If you enable stencil testing or stencil writing, the
         // MTLRenderPassDescriptor must include a stencil attachment.
         rpd.stencilAttachment.loadAction = MTLLoadActionLoad;
         rpd.stencilAttachment.storeAction = MTLStoreActionStore;
         rpd.stencilAttachment.texture = _mtlc.clip.stencilTextureRef;
@@ -423,27 +373,21 @@
     // tex=%p", dest);
     _encoder = [[cbw getCommandBuffer] renderCommandEncoderWithDescriptor:rpd];
     [rpd release];
 
     [_encoderStates reset:dest
-               isDstOpaque:isOpaque
+               isDstOpaque:renderOptions->dstFlags.isOpaque
         isDstPremultiplied:YES
-                      isAA:isAA];
+                      isAA:renderOptions->isAA];
   }
 
   //
   // 3. update encoder states
   //
   [_encoderStates updateEncoder:_encoder
-                          paint:_mtlc.paint
-                      composite:_mtlc.composite
-                      isTexture:isTexture
-                  interpolation:interpolation
-                           isAA:isAA
-                       srcFlags:srcFlags
-                           clip:_mtlc.clip
-                      transform:_mtlc.transform
+                        context:_mtlc
+                  renderOptions:renderOptions
                     forceUpdate:forceUpdate];
 
   return _encoder;
 }
 
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.h b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.h
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.h
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.h
@@ -26,22 +26,49 @@
 #ifndef MTLBufImgOps_h_Included
 #define MTLBufImgOps_h_Included
 
 #include "MTLContext.h"
 
-void MTLBufImgOps_EnableConvolveOp(MTLContext *mtlc, jlong pSrcOps,
-                                   jboolean edgeZeroFill,
-                                   jint kernelWidth, jint KernelHeight,
-                                   unsigned char *kernelVals);
-void MTLBufImgOps_DisableConvolveOp(MTLContext *mtlc);
-void MTLBufImgOps_EnableRescaleOp(MTLContext *mtlc, jlong pSrcOps,
-                                  jboolean nonPremult,
-                                  unsigned char *scaleFactors,
-                                  unsigned char *offsets);
-void MTLBufImgOps_DisableRescaleOp(MTLContext *mtlc);
-void MTLBufImgOps_EnableLookupOp(MTLContext *mtlc, jlong pSrcOps,
-                                 jboolean nonPremult, jboolean shortData,
-                                 jint numBands, jint bandLength, jint offset,
-                                 void *tableValues);
-void MTLBufImgOps_DisableLookupOp(MTLContext *mtlc);
+@interface MTLRescaleOp : NSObject
+- (id)init:(jboolean)isNonPremult factors:(unsigned char *)factors offsets:(unsigned char *)offsets;
+- (jfloat *)getScaleFactors;
+- (jfloat *)getOffsets;
+- (NSString *)getDescription; // creates autorelease string
+
+@property (readonly) jboolean isNonPremult;
+@end
+
+@interface MTLConvolveOp : NSObject
+- (id)init:(jboolean)edgeZeroFill kernelWidth:(jint)kernelWidth
+                                 kernelHeight:(jint)kernelHeight
+                                     srcWidth:(jint)srcWidth
+                                    srcHeight:(jint)srcHeight
+                                       kernel:(unsigned char *)kernel
+                                       device:(id<MTLDevice>)device;
+- (void) dealloc;
+
+- (id<MTLBuffer>) getBuffer;
+- (const float *) getImgEdge;
+- (NSString *)getDescription; // creates autorelease string
+
+@property (readonly) jboolean isEdgeZeroFill;
+@property (readonly) int kernelSize;
+@end
+
+@interface MTLLookupOp : NSObject
+- (id)init:(jboolean)nonPremult shortData:(jboolean)shortData
+                                 numBands:(jint)numBands
+                               bandLength:(jint)bandLength
+                                   offset:(jint)offset
+                              tableValues:(void *)tableValues
+                                   device:(id<MTLDevice>)device;
+- (void) dealloc;
+
+- (jfloat *)getOffset;
+- (id<MTLTexture>) getLookupTexture;
+- (NSString *)getDescription; // creates autorelease string
+
+@property (readonly) jboolean isUseSrcAlpha;
+@property (readonly) jboolean isNonPremult;
+@end
 
 #endif /* MTLBufImgOps_h_Included */
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBufImgOps.m
@@ -31,347 +31,197 @@
 #include "MTLContext.h"
 #include "MTLRenderQueue.h"
 #include "MTLSurfaceDataBase.h"
 #include "GraphicsPrimitiveMgr.h"
 
-/** Evaluates to true if the given bit is set on the local flags variable. */
-#define IS_SET(flagbit) \
-    (((flags) & (flagbit)) != 0)
-
-/**************************** ConvolveOp support ****************************/
-
-/**
- * The ConvolveOp shader is fairly straightforward.  For each texel in
- * the source texture, the shader samples the MxN texels in the surrounding
- * area, multiplies each by its corresponding kernel value, and then sums
- * them all together to produce a single color result.  Finally, the
- * resulting value is multiplied by the current OpenGL color, which contains
- * the extra alpha value.
- *
- * Note that this shader source code includes some "holes" marked by "%s".
- * This allows us to build different shader programs (e.g. one for
- * 3x3, one for 5x5, and so on) simply by filling in these "holes" with
- * a call to sprintf().  See the MTLBufImgOps_CreateConvolveProgram() method
- * for more details.
- *
- * REMIND: Currently this shader (and the supporting code in the
- *         EnableConvolveOp() method) only supports 3x3 and 5x5 filters.
- *         Early shader-level hardware did not support non-constant sized
- *         arrays but modern hardware should support them (although I
- *         don't know of any simple way to find out, other than to compile
- *         the shader at runtime and see if the drivers complain).
- */
-static const char *convolveShaderSource =
-    // maximum size supported by this shader
-    "const int MAX_KERNEL_SIZE = %s;"
-    // image to be convolved
-    "uniform sampler%s baseImage;"
-    // image edge limits:
-    //   imgEdge.xy = imgMin.xy (anything < will be treated as edge case)
-    //   imgEdge.zw = imgMax.xy (anything > will be treated as edge case)
-    "uniform vec4 imgEdge;"
-    // value for each location in the convolution kernel:
-    //   kernelVals[i].x = offsetX[i]
-    //   kernelVals[i].y = offsetY[i]
-    //   kernelVals[i].z = kernel[i]
-    "uniform vec3 kernelVals[MAX_KERNEL_SIZE];"
-    ""
-    "void main(void)"
-    "{"
-    "    int i;"
-    "    vec4 sum;"
-    ""
-    "    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||"
-    "        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))"
-    "    {"
-             // (placeholder for edge condition code)
-    "        %s"
-    "    } else {"
-    "        sum = vec4(0.0);"
-    "        for (i = 0; i < MAX_KERNEL_SIZE; i++) {"
-    "            sum +="
-    "                kernelVals[i].z *"
-    "                texture%s(baseImage,"
-    "                          gl_TexCoord[0].st + kernelVals[i].xy);"
-    "        }"
-    "    }"
-    ""
-         // modulate with gl_Color in order to apply extra alpha
-    "    gl_FragColor = sum * gl_Color;"
-    "}";
-
-/**
- * Flags that can be bitwise-or'ed together to control how the shader
- * source code is generated.
- */
-#define CONVOLVE_RECT            (1 << 0)
-#define CONVOLVE_EDGE_ZERO_FILL  (1 << 1)
-#define CONVOLVE_5X5             (1 << 2)
-
-/**
- * The handles to the ConvolveOp fragment program objects.  The index to
- * the array should be a bitwise-or'ing of the CONVOLVE_* flags defined
- * above.  Note that most applications will likely need to initialize one
- * or two of these elements, so the array is usually sparsely populated.
- */
-static GLhandleARB convolvePrograms[8];
-
-/**
- * The maximum kernel size supported by the ConvolveOp shader.
- */
-#define MAX_KERNEL_SIZE 25
-
-/**
- * Compiles and links the ConvolveOp shader program.  If successful, this
- * function returns a handle to the newly created shader program; otherwise
- * returns 0.
- */
-static GLhandleARB
-MTLBufImgOps_CreateConvolveProgram(jint flags)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_INFO, "MTLBufImgOps_CreateConvolveProgram -- :TODO");
-
-    return NULL;
+@implementation MTLRescaleOp {
+    jboolean _isNonPremult;
+    jfloat _normScaleFactors[4];
+    jfloat _normOffsets[4];
 }
 
-void
-MTLBufImgOps_EnableConvolveOp(MTLContext *mtlc, jlong pSrcOps,
-                              jboolean edgeZeroFill,
-                              jint kernelWidth, jint kernelHeight,
-                              unsigned char *kernel)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_ERROR, "MTLBufImgOps_EnableConvolveOp -- :TODO");
+-(jfloat *) getScaleFactors {
+    return _normScaleFactors;
+}
+-(jfloat *) getOffsets {
+    return _normOffsets;
+}
 
+- (id)init:(jboolean)isNonPremult factors:(unsigned char *)factors offsets:(unsigned char *)offsets {
+    self = [super init];
+    if (self) {
+        J2dTraceLn1(J2D_TRACE_INFO,"Created MTLRescaleOp: isNonPremult=%d", isNonPremult);
+
+        _isNonPremult = isNonPremult;
+        _normScaleFactors[0] = NEXT_FLOAT(factors);
+        _normScaleFactors[1] = NEXT_FLOAT(factors);
+        _normScaleFactors[2] = NEXT_FLOAT(factors);
+        _normScaleFactors[3] = NEXT_FLOAT(factors);
+        _normOffsets[0] = NEXT_FLOAT(offsets);
+        _normOffsets[1] = NEXT_FLOAT(offsets);
+        _normOffsets[2] = NEXT_FLOAT(offsets);
+        _normOffsets[3] = NEXT_FLOAT(offsets);
+    }
+    return self;
 }
 
-void
-MTLBufImgOps_DisableConvolveOp(MTLContext *mtlc)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_ERROR, "MTLBufImgOps_DisableConvolveOp -- :TODO");
+- (NSString *)getDescription {
+    return [NSString stringWithFormat:@"rescale: nonPremult=%d", _isNonPremult];
 }
+@end
 
-/**************************** RescaleOp support *****************************/
+@implementation MTLConvolveOp {
+    id<MTLBuffer> _buffer;
+    float _imgEdge[4];
+    int _kernelSize;
+    jboolean _isEdgeZeroFill;
+}
 
-/**
- * The RescaleOp shader is one of the simplest possible.  Each fragment
- * from the source image is multiplied by the user's scale factor and added
- * to the user's offset value (these are component-wise operations).
- * Finally, the resulting value is multiplied by the current OpenGL color,
- * which contains the extra alpha value.
- *
- * The RescaleOp spec says that the operation is performed regardless of
- * whether the source data is premultiplied or non-premultiplied.  This is
- * a problem for the OpenGL pipeline in that a non-premultiplied
- * BufferedImage will have already been converted into premultiplied
- * when uploaded to an OpenGL texture.  Therefore, we have a special mode
- * called RESCALE_NON_PREMULT (used only for source images that were
- * originally non-premultiplied) that un-premultiplies the source color
- * prior to the rescale operation, then re-premultiplies the resulting
- * color before returning from the fragment shader.
- *
- * Note that this shader source code includes some "holes" marked by "%s".
- * This allows us to build different shader programs (e.g. one for
- * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)
- * simply by filling in these "holes" with a call to sprintf().  See the
- * MTLBufImgOps_CreateRescaleProgram() method for more details.
- */
-static const char *rescaleShaderSource =
-    // image to be rescaled
-    "uniform sampler%s baseImage;"
-    // vector containing scale factors
-    "uniform vec4 scaleFactors;"
-    // vector containing offsets
-    "uniform vec4 offsets;"
-    ""
-    "void main(void)"
-    "{"
-    "    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);"
-         // (placeholder for un-premult code)
-    "    %s"
-         // rescale source value
-    "    vec4 result = (srcColor * scaleFactors) + offsets;"
-         // (placeholder for re-premult code)
-    "    %s"
-         // modulate with gl_Color in order to apply extra alpha
-    "    gl_FragColor = result * gl_Color;"
-    "}";
-
-/**
- * Flags that can be bitwise-or'ed together to control how the shader
- * source code is generated.
- */
-#define RESCALE_RECT        (1 << 0)
-#define RESCALE_NON_PREMULT (1 << 1)
-
-/**
- * The handles to the RescaleOp fragment program objects.  The index to
- * the array should be a bitwise-or'ing of the RESCALE_* flags defined
- * above.  Note that most applications will likely need to initialize one
- * or two of these elements, so the array is usually sparsely populated.
- */
-static GLhandleARB rescalePrograms[4];
+- (id)init:(jboolean)edgeZeroFill kernelWidth:(jint)kernelWidth
+                                 kernelHeight:(jint)kernelHeight
+                                     srcWidth:(jint)srcWidth
+                                    srcHeight:(jint)srcHeight
+                                       kernel:(unsigned char *)kernel
+                                       device:(id<MTLDevice>)device {
+    self = [super init];
+    if (self) {
+        J2dTraceLn2(J2D_TRACE_INFO,"Created MTLConvolveOp: kernelW=%d kernelH=%d", kernelWidth, kernelHeight);
+        _isEdgeZeroFill = edgeZeroFill;
+
+        _kernelSize = kernelWidth * kernelHeight;
+        _buffer = [device newBufferWithLength:_kernelSize*sizeof(vector_float3) options:MTLResourceStorageModeShared];
+
+        float * kernelVals = [_buffer contents];
+        int kIndex = 0;
+        for (int i = -kernelHeight/2; i < kernelHeight/2+1; i++) {
+            for (int j = -kernelWidth/2; j < kernelWidth/2+1; j++) {
+                kernelVals[kIndex+0] = j/(float)srcWidth;
+                kernelVals[kIndex+1] = i/(float)srcHeight;
+                kernelVals[kIndex+2] = NEXT_FLOAT(kernel);
+                kIndex += 3;
+            }
+        }
+
+        _imgEdge[0] = (kernelWidth/2)/(float)srcWidth;
+        _imgEdge[1] = (kernelHeight/2)/(float)srcHeight;
+        _imgEdge[2] = 1 - _imgEdge[0];
+        _imgEdge[3] = 1 - _imgEdge[1];
+    }
+    return self;
+}
 
-/**
- * Compiles and links the RescaleOp shader program.  If successful, this
- * function returns a handle to the newly created shader program; otherwise
- * returns 0.
- */
-static GLhandleARB
-MTLBufImgOps_CreateRescaleProgram(jint flags)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_INFO, "MTLBufImgOps_CreateRescaleProgram -- :TODO");
+- (void) dealloc {
+    [_buffer release];
+    [super dealloc];
+}
 
-    return NULL;
+- (id<MTLBuffer>) getBuffer {
+    return _buffer;
 }
 
-void
-MTLBufImgOps_EnableRescaleOp(MTLContext *mtlc, jlong pSrcOps,
-                             jboolean nonPremult,
-                             unsigned char *scaleFactors,
-                             unsigned char *offsets)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_ERROR, "MTLBufImgOps_EnableRescaleOp -- :TODO");
+- (const float *) getImgEdge {
+    return _imgEdge;
 }
 
-void
-MTLBufImgOps_DisableRescaleOp(MTLContext *mtlc)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_ERROR, "MTLBufImgOps_DisableRescaleOp -- :TODO");
-    RETURN_IF_NULL(mtlc);
+- (NSString *)getDescription {
+    return [NSString stringWithFormat:@"convolve: isEdgeZeroFill=%d", _isEdgeZeroFill];
 }
+@end
 
-/**************************** LookupOp support ******************************/
 
-/**
- * The LookupOp shader takes a fragment color (from the source texture) as
- * input, subtracts the optional user offset value, and then uses the
- * resulting value to index into the lookup table texture to provide
- * a new color result.  Finally, the resulting value is multiplied by
- * the current OpenGL color, which contains the extra alpha value.
- *
- * The lookup step requires 3 texture accesses (or 4, when alpha is included),
- * which is somewhat unfortunate because it's not ideal from a performance
- * standpoint, but that sort of thing is getting faster with newer hardware.
- * In the 3-band case, we could consider using a three-dimensional texture
- * and performing the lookup with a single texture access step.  We already
- * use this approach in the LCD text shader, and it works well, but for the
- * purposes of this LookupOp shader, it's probably overkill.  Also, there's
- * a difference in that the LCD text shader only needs to populate the 3D LUT
- * once, but here we would need to populate it on every invocation, which
- * would likely be a waste of VRAM and CPU/GPU cycles.
- *
- * The LUT texture is currently hardcoded as 4 rows/bands, each containing
- * 256 elements.  This means that we currently only support user-provided
- * tables with no more than 256 elements in each band (this is checked at
- * at the Java level).  If the user provides a table with less than 256
- * elements per band, our shader will still work fine, but if elements are
- * accessed with an index >= the size of the LUT, then the shader will simply
- * produce undefined values.  Typically the user would provide an offset
- * value that would prevent this from happening, but it's worth pointing out
- * this fact because the software LookupOp implementation would usually
- * throw an ArrayIndexOutOfBoundsException in this scenario (although it is
- * not something demanded by the spec).
- *
- * The LookupOp spec says that the operation is performed regardless of
- * whether the source data is premultiplied or non-premultiplied.  This is
- * a problem for the OpenGL pipeline in that a non-premultiplied
- * BufferedImage will have already been converted into premultiplied
- * when uploaded to an OpenGL texture.  Therefore, we have a special mode
- * called LOOKUP_NON_PREMULT (used only for source images that were
- * originally non-premultiplied) that un-premultiplies the source color
- * prior to the lookup operation, then re-premultiplies the resulting
- * color before returning from the fragment shader.
- *
- * Note that this shader source code includes some "holes" marked by "%s".
- * This allows us to build different shader programs (e.g. one for
- * GL_TEXTURE_2D targets, one for GL_TEXTURE_RECTANGLE_ARB targets, and so on)
- * simply by filling in these "holes" with a call to sprintf().  See the
- * MTLBufImgOps_CreateLookupProgram() method for more details.
- */
-static const char *lookupShaderSource =
-    // source image (bound to texture unit 0)
-    "uniform sampler%s baseImage;"
-    // lookup table (bound to texture unit 1)
-    "uniform sampler2D lookupTable;"
-    // offset subtracted from source index prior to lookup step
-    "uniform vec4 offset;"
-    ""
-    "void main(void)"
-    "{"
-    "    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);"
-         // (placeholder for un-premult code)
-    "    %s"
-         // subtract offset from original index
-    "    vec4 srcIndex = srcColor - offset;"
-         // use source value as input to lookup table (note that
-         // "v" texcoords are hardcoded to hit texel centers of
-         // each row/band in texture)
-    "    vec4 result;"
-    "    result.r = texture2D(lookupTable, vec2(srcIndex.r, 0.125)).r;"
-    "    result.g = texture2D(lookupTable, vec2(srcIndex.g, 0.375)).r;"
-    "    result.b = texture2D(lookupTable, vec2(srcIndex.b, 0.625)).r;"
-         // (placeholder for alpha store code)
-    "    %s"
-         // (placeholder for re-premult code)
-    "    %s"
-         // modulate with gl_Color in order to apply extra alpha
-    "    gl_FragColor = result * gl_Color;"
-    "}";
-
-/**
- * Flags that can be bitwise-or'ed together to control how the shader
- * source code is generated.
- */
-#define LOOKUP_RECT          (1 << 0)
-#define LOOKUP_USE_SRC_ALPHA (1 << 1)
-#define LOOKUP_NON_PREMULT   (1 << 2)
-
-/**
- * The handles to the LookupOp fragment program objects.  The index to
- * the array should be a bitwise-or'ing of the LOOKUP_* flags defined
- * above.  Note that most applications will likely need to initialize one
- * or two of these elements, so the array is usually sparsely populated.
- */
-static GLhandleARB lookupPrograms[8];
+@implementation MTLLookupOp {
+    float _offset[4];
+    jboolean _isUseSrcAlpha;
+    jboolean _isNonPremult;
 
-/**
- * The handle to the lookup table texture object used by the shader.
- */
-static GLuint lutTextureID = 0;
+    id<MTLTexture> _lookupTex;
+}
 
-/**
- * Compiles and links the LookupOp shader program.  If successful, this
- * function returns a handle to the newly created shader program; otherwise
- * returns 0.
- */
-static GLhandleARB
-MTLBufImgOps_CreateLookupProgram(jint flags)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_INFO, "MTLBufImgOps_CreateLookupProgram -- :TODO");
-    return NULL;
+- (id)init:(jboolean)nonPremult shortData:(jboolean)shortData
+                                 numBands:(jint)numBands
+                               bandLength:(jint)bandLength
+                                   offset:(jint)offset
+                              tableValues:(void *)tableValues
+                                   device:(id<MTLDevice>)device {
+    self = [super init];
+    if (self) {
+        J2dTraceLn4(J2D_TRACE_INFO,"Created MTLLookupOp: short=%d num=%d len=%d off=%d",
+                    shortData, numBands, bandLength, offset);
+
+        _isUseSrcAlpha = numBands != 4;
+        _isNonPremult = nonPremult;
+
+        _offset[0] = offset / 255.0f;
+        _offset[1] = _offset[0];
+        _offset[2] = _offset[0];
+        _offset[3] = _offset[0];
+
+        MTLTextureDescriptor *textureDescriptor =
+                [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatA8Unorm
+                                                                   width:(NSUInteger)256
+                                                                  height:(NSUInteger)4
+                                                               mipmapped:NO];
+
+        _lookupTex = [device newTextureWithDescriptor:textureDescriptor];
+
+        void *bands[4];
+        for (int i = 0; i < 4; i++) {
+            bands[i] = NULL;
+        }
+        int bytesPerElem = (shortData ? 2 : 1);
+        if (numBands == 1) {
+            // replicate the single band for R/G/B; alpha band is unused
+            for (int i = 0; i < 3; i++) {
+                bands[i] = tableValues;
+            }
+            bands[3] = NULL;
+        } else if (numBands == 3) {
+            // user supplied band for each of R/G/B; alpha band is unused
+            for (int i = 0; i < 3; i++) {
+                bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);
+            }
+            bands[3] = NULL;
+        } else if (numBands == 4) {
+            // user supplied band for each of R/G/B/A
+            for (int i = 0; i < 4; i++) {
+                bands[i] = PtrAddBytes(tableValues, i*bandLength*bytesPerElem);
+            }
+        }
+
+        for (int i = 0; i < 4; i++) {
+            if (bands[i] == NULL)
+                continue;
+
+            MTLRegion region = {
+                    {0, i, 0},
+                    {bandLength, 1,1}
+            };
+
+            [_lookupTex replaceRegion:region
+                                    mipmapLevel:0
+                                      withBytes:bands[i]
+                                    bytesPerRow:bandLength*bytesPerElem];
+        }
+    }
+    return self;
 }
 
-void
-MTLBufImgOps_EnableLookupOp(MTLContext *mtlc, jlong pSrcOps,
-                            jboolean nonPremult, jboolean shortData,
-                            jint numBands, jint bandLength, jint offset,
-                            void *tableValues)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_ERROR, "MTLBufImgOps_EnableLookupOp -- :TODO");
+- (void) dealloc {
+    [_lookupTex release];
+    [super dealloc];
 }
 
-void
-MTLBufImgOps_DisableLookupOp(MTLContext *mtlc)
-{
-    //TODO
-    J2dTraceLn(J2D_TRACE_ERROR, "MTLBufImgOps_DisableLookupOp -- :TODO");
+- (jfloat *) getOffset {
+    return _offset;
 }
 
+- (id<MTLTexture>) getLookupTexture {
+    return _lookupTex;
+}
+
+- (NSString *)getDescription {
+    return [NSString stringWithFormat:@"lookup: offset=%f", _offset[0]];
+}
+
+@end
+
 #endif /* !HEADLESS */
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.h b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.h
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.h
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.h
@@ -243,10 +243,18 @@
                xp3:(jdouble)xp3
                yp0:(jdouble)yp0
                yp1:(jdouble)yp1
                yp3:(jdouble)yp3;
 
+// Sets current image conversion operation (instance of MTLConvolveOp, MTLRescaleOp, MTLLookupOp).
+// Used only in MTLIsoBlit (to blit image with some conversion). Pattern of usage: enableOp -> IsoBlit -> disableOp.
+// TODO: Need to remove it from MTLContext and pass it as an argument for IsoBlit (because it's more
+// simple and clear)
+-(void)setBufImgOp:(NSObject*)bufImgOp;
+
+-(NSObject*)getBufImgOp;
+
 - (id<MTLCommandBuffer>)createBlitCommandBuffer;
 @end
 
 /**
  * See BufferedContext.java for more on these flags...
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.m
@@ -87,11 +87,12 @@
     MTLCommandBufferWrapper * _commandBufferWrapper;
 
     MTLComposite *     _composite;
     MTLPaint *         _paint;
     MTLTransform *     _transform;
-    MTLClip *           _clip;
+    MTLClip *          _clip;
+    NSObject*          _bufImgOp; // TODO: pass as parameter of IsoBlit
 
     EncoderManager * _encoderManager;
 }
 
 @synthesize textureFunction,
@@ -126,10 +127,11 @@
         [_encoderManager setContext:self];
         _composite = [[MTLComposite alloc] init];
         _paint = [[MTLPaint alloc] init];
         _transform = [[MTLTransform alloc] init];
         _clip = [[MTLClip alloc] init];
+        _bufImgOp = nil;
 
         _commandBufferWrapper = nil;
 
         // Create command queue
         commandQueue = [device newCommandQueue];
@@ -412,10 +414,21 @@
 
 - (id<MTLCommandBuffer>)createBlitCommandBuffer {
     return [self.commandQueue commandBuffer];
 }
 
+-(void)setBufImgOp:(NSObject*)bufImgOp {
+    if (_bufImgOp != nil) {
+        [_bufImgOp release]; // context owns bufImgOp object
+    }
+    _bufImgOp = bufImgOp;
+}
+
+-(NSObject*)getBufImgOp {
+    return _bufImgOp;
+}
+
 @end
 
 /*
  * Class:     sun_java2d_metal_MTLContext
  * Method:    getMTLIdString
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.h b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.h
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.h
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.h
@@ -25,15 +25,15 @@
 
 #ifndef MTLPaints_h_Included
 #define MTLPaints_h_Included
 
 #import <Metal/Metal.h>
-
-#include "MTLSurfaceDataBase.h"
+#include "RenderOptions.h"
 
 #define sun_java2d_SunGraphics2D_PAINT_UNDEFINED -1
 
+@class MTLContext;
 @class MTLComposite;
 @class MTLClip;
 @class MTLPipelineStatesStorage;
 
 /**
@@ -92,25 +92,17 @@
                yp3:(jdouble)yp3;
 
 // For the current paint mode and passed composite (and flags):
 // 1. Selects vertex+fragment shader (and corresponding pipelineDesc) and set pipelineState
 // 2. Prepares corresponding buffers of vertex and fragment shaders
-- (void)setPipelineState:(id<MTLRenderCommandEncoder>)encoder
-               composite:(MTLComposite *)composite
-           isStencilUsed:(jboolean)isStencilUsed
-               isTexture:(jboolean)isTexture
-           interpolation:(int)interpolation
-                srcFlags:(const SurfaceRasterFlags *)srcFlags
-                dstFlags:(const SurfaceRasterFlags *)dstFlags
+- (void)setPipelineState:(id <MTLRenderCommandEncoder>)encoder
+                 context:(MTLContext *)mtlc
+           renderOptions:(const RenderOptions *)renderOptions
     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage;
 
-- (void)setXorModePipelineState:(id<MTLRenderCommandEncoder>)encoder
-               composite:(MTLComposite *)composite
-           isStencilUsed:(jboolean)isStencilUsed
-               isTexture:(jboolean)isTexture
-           interpolation:(int)interpolation
-                srcFlags:(const SurfaceRasterFlags *)srcFlags
-                dstFlags:(const SurfaceRasterFlags *)dstFlags
-    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage;
+- (void)setXorModePipelineState:(id <MTLRenderCommandEncoder>)encoder
+                        context:(MTLContext *)mtlc
+                  renderOptions:(const RenderOptions *)renderOptions
+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage;
 @end
 
 #endif /* MTLPaints_h_Included */
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
@@ -32,19 +32,28 @@
 #include "common.h"
 
 #include "sun_java2d_SunGraphics2D.h"
 #include "sun_java2d_pipe_BufferedPaints.h"
 #import "MTLComposite.h"
+#import "MTLBufImgOps.h"
 
 #define RGBA_TO_V4(c)              \
 {                                  \
     (((c) >> 16) & (0xFF))/255.0f, \
     (((c) >> 8) & 0xFF)/255.0f,    \
     ((c) & 0xFF)/255.0f,           \
     (((c) >> 24) & 0xFF)/255.0f    \
 }
 
+#define FLOAT_ARR_TO_V4(p) \
+{                      \
+    p[0], \
+    p[1], \
+    p[2], \
+    p[3]  \
+}
+
 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 
 static void initTemplatePipelineDescriptors() {
@@ -319,220 +328,210 @@
     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
 }
 
-static void setTxtUniforms(
-        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
-        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
-) {
-    struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags->isOpaque, dstFlags->isOpaque, extraAlpha};
-    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
-
+static void setSampler(id<MTLRenderCommandEncoder> encoder, int interpolation, bool repeat) {
     id<MTLSamplerState> sampler;
     if (repeat) {
         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
     } else {
         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
     }
     [encoder setFragmentSamplerState:sampler atIndex:0];
 }
 
-// TODO: need support hints for all shaders
+static void setTxtUniforms(
+        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
+        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
+) {
+    struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags->isOpaque, dstFlags->isOpaque, extraAlpha};
+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+
+    setSampler(encoder, interpolation, repeat);
+}
 
 // For the current paint mode:
 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
 // 2. Set vertex and fragment buffers
 - (void)setPipelineState:(id<MTLRenderCommandEncoder>)encoder
-               composite:(MTLComposite *)composite
-           isStencilUsed:(jboolean)isStencilUsed
-               isTexture:(jboolean)isTexture
-           interpolation:(int)interpolation
-                    isAA:(jboolean)isAA
-                srcFlags:(const SurfaceRasterFlags *)srcFlags
-                dstFlags:(const SurfaceRasterFlags *)dstFlags
+                 context:(MTLContext *)mtlc
+           renderOptions:(const RenderOptions *)renderOptions
     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
 {
     initTemplatePipelineDescriptors();
 
-    const bool stencil = isStencilUsed == JNI_TRUE;
-
-    id<MTLRenderPipelineState> pipelineState = nil;
-    if (isTexture) {
-
-      if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
-        pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
-                                                vertexShaderId:@"vert_txt_tp"
-                                              fragmentShaderId:@"frag_txt_tp"
-                                                 compositeRule:[composite getRule]
-                                                          isAA:JNI_FALSE
-                                                      srcFlags:srcFlags
-                                                      dstFlags:dstFlags
-                                                 stencilNeeded:stencil];
-        [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
-        [encoder setFragmentTexture:_paintTexture atIndex: 1];
-
-        setTxtUniforms(encoder, 0, 0, interpolation, YES, [composite getExtraAlpha], srcFlags, dstFlags);
-      } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
-        pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
-                                                vertexShaderId:@"vert_txt_grad"
-                                              fragmentShaderId:@"frag_txt_grad"
-                                                 compositeRule:[composite getRule]
-                                                          isAA:JNI_FALSE
-                                                      srcFlags:srcFlags
-                                                      dstFlags:dstFlags
-                                                 stencilNeeded:stencil];
-        struct GradFrameUniforms uf = {
-            {_p0, _p1, _p3},
-            RGBA_TO_V4(_pixel1),
-            RGBA_TO_V4(_pixel2)};
-        [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];
-
-      } else {
-        if (isAA) {
-          pipelineState = [pipelineStateStorage
-              getPipelineState:templateAATexturePipelineDesc
-                vertexShaderId:@"vert_txt"
-              fragmentShaderId:@"aa_frag_txt"
-                 compositeRule:[composite getRule]
-                          isAA:JNI_FALSE
-                      srcFlags:srcFlags
-                      dstFlags:dstFlags
-                 stencilNeeded:stencil];
+    NSString * vertShader = @"vert_txt";
+    NSString * fragShader = @"frag_txt";
+    MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
+
+    if (renderOptions->isTexture) {
+        NSObject *bufImgOp = [mtlc getBufImgOp];
+        if (bufImgOp != nil) {
+            if ([bufImgOp isKindOfClass:[MTLRescaleOp class]]) {
+                MTLRescaleOp *rescaleOp = bufImgOp;
+                vertShader = @"vert_txt";
+                fragShader = @"frag_txt_op_rescale";
+
+                struct TxtFrameOpRescaleUniforms uf = {
+                        RGBA_TO_V4(0), [mtlc.composite getExtraAlpha], renderOptions->srcFlags.isOpaque,
+                        rescaleOp.isNonPremult,
+                        FLOAT_ARR_TO_V4([rescaleOp getScaleFactors]), FLOAT_ARR_TO_V4([rescaleOp getOffsets])
+                };
+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+                setSampler(encoder, renderOptions->interpolation, NO);
+            } else if ([bufImgOp isKindOfClass:[MTLConvolveOp class]]) {
+                MTLConvolveOp * convolveOp = bufImgOp;
+                vertShader = @"vert_txt";
+                fragShader = @"frag_txt_op_convolve";
+
+                struct TxtFrameOpConvolveUniforms uf = {
+                        [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([convolveOp getImgEdge]),
+                        convolveOp.kernelSize, convolveOp.isEdgeZeroFill,
+                };
+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+                setSampler(encoder, renderOptions->interpolation, NO);
+
+                [encoder setFragmentBuffer:[convolveOp getBuffer] offset:0 atIndex:2];
+            } else if ([bufImgOp isKindOfClass:[MTLLookupOp class]]) {
+                MTLLookupOp * lookupOp = bufImgOp;
+                vertShader = @"vert_txt";
+                fragShader = @"frag_txt_op_lookup";
+
+                struct TxtFrameOpLookupUniforms uf = {
+                        [mtlc.composite getExtraAlpha], FLOAT_ARR_TO_V4([lookupOp getOffset]),
+                        lookupOp.isUseSrcAlpha, lookupOp.isNonPremult,
+                };
+                [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
+                setSampler(encoder, renderOptions->interpolation, NO);
+                [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex: 1];
+            }
+        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
+            vertShader = @"vert_txt_tp";
+            fragShader = @"frag_txt_tp";
+            [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
+            [encoder setFragmentTexture:_paintTexture atIndex:1];
+
+            setTxtUniforms(encoder, 0, 0, renderOptions->interpolation, YES, [mtlc.composite getExtraAlpha],
+                           &renderOptions->srcFlags, &renderOptions->dstFlags);
+        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
+            vertShader = @"vert_txt_grad";
+            fragShader = @"frag_txt_grad";
+            struct GradFrameUniforms uf = {
+                    {_p0, _p1, _p3},
+                    RGBA_TO_V4(_pixel1),
+                    RGBA_TO_V4(_pixel2)};
+            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];
 
         } else {
-          pipelineState =
-              [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
-                                      vertexShaderId:@"vert_txt"
-                                    fragmentShaderId:@"frag_txt"
-                                       compositeRule:[composite getRule]
-                                           composite:composite
-                                                isAA:JNI_FALSE
-                                            srcFlags:srcFlags
-                                            dstFlags:dstFlags
-                                       stencilNeeded:stencil];
-        }
+            vertShader = @"vert_txt";
+            fragShader = @"frag_txt";
+            if (renderOptions->isAA) {
+                fragShader = @"aa_frag_txt";
+                rpDesc = templateAATexturePipelineDesc;
+            }
 
-        setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);
-      }
+            setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,
+                           renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha], &renderOptions->srcFlags,
+                           &renderOptions->dstFlags);
+        }
     } else {
+        rpDesc = templateRenderPipelineDesc;
+
         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
-            pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
-                                                    vertexShaderId:@"vert_col"
-                                                  fragmentShaderId:@"frag_col"
-                                                     compositeRule:[composite getRule]
-                                                              isAA:isAA
-                                                          srcFlags:srcFlags
-                                                          dstFlags:dstFlags
-                                                     stencilNeeded:stencil];
+            vertShader = @"vert_col";
+            fragShader = @"frag_col";
 
             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
             [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
-            pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
-                                                    vertexShaderId:@"vert_grad"
-                                                  fragmentShaderId:@"frag_grad"
-                                                     compositeRule:[composite getRule]
-                                                              isAA:isAA
-                                                          srcFlags:srcFlags
-                                                          dstFlags:dstFlags
-                                                     stencilNeeded:stencil];
+            vertShader = @"vert_grad";
+            fragShader = @"frag_grad";
 
             struct GradFrameUniforms uf = {
                     {_p0, _p1, _p3},
                     RGBA_TO_V4(_pixel1),
                     RGBA_TO_V4(_pixel2)};
-            [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];
+            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];
         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
-            pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
-                                        vertexShaderId:@"vert_tp"
-                                      fragmentShaderId:@"frag_tp"
-                                         compositeRule:[composite getRule]
-                                                  isAA:isAA
-                                              srcFlags:srcFlags
-                                              dstFlags:dstFlags
-                                         stencilNeeded:stencil];
+            vertShader = @"vert_tp";
+            fragShader = @"frag_tp";
 
             [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
-            [encoder setFragmentTexture:_paintTexture atIndex: 0];
+            [encoder setFragmentTexture:_paintTexture atIndex:0];
         }
     }
 
+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc
+                                                                        vertexShaderId:vertShader
+                                                                      fragmentShaderId:fragShader
+                                                                             composite:mtlc.composite
+                                                                         renderOptions:renderOptions
+                                                                         stencilNeeded:[mtlc.clip isShape]];
     [encoder setRenderPipelineState:pipelineState];
 }
 
 
 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
 // 2. Set vertex and fragment buffers
 - (void)setXorModePipelineState:(id<MTLRenderCommandEncoder>)encoder
-               composite:(MTLComposite *)composite
-           isStencilUsed:(jboolean)isStencilUsed
-               isTexture:(jboolean)isTexture
-           interpolation:(int)interpolation
-                srcFlags:(const SurfaceRasterFlags *)srcFlags
-                dstFlags:(const SurfaceRasterFlags *)dstFlags
-    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage {
+                        context:(MTLContext *)mtlc
+                  renderOptions:(const RenderOptions *)renderOptions
+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
+{
     initTemplatePipelineDescriptors();
 
-    const bool stencil = isStencilUsed == JNI_TRUE;
-    jint xorColor = (jint) [composite getXorColor];
-
-    id<MTLRenderPipelineState> pipelineState = nil;
-    if (isTexture) {
-          pipelineState = [pipelineStateStorage getXorModePipelineState:templateTexturePipelineDesc
-                                          vertexShaderId:@"vert_txt"
-                                        fragmentShaderId:@"frag_txt"
-                                                srcFlags:srcFlags
-                                                dstFlags:dstFlags
-                                           stencilNeeded:stencil];
+    jint xorColor = (jint) [mtlc.composite getXorColor];
+
+    NSString * vertShader = @"vert_txt";
+    NSString * fragShader = @"frag_txt";
+    MTLRenderPipelineDescriptor * rpDesc = templateTexturePipelineDesc;
+
+    if (renderOptions->isTexture) {
         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
-        setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);
+        setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha], &renderOptions->srcFlags, &renderOptions->dstFlags);
         [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];
     } else {
         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
-
-            pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
-                                        vertexShaderId:@"vert_col"
-                                      fragmentShaderId:@"frag_col"
-                                              srcFlags:srcFlags
-                                              dstFlags:dstFlags
-                                         stencilNeeded:stencil];
+            vertShader = @"vert_col";
+            fragShader = @"frag_col";
+            rpDesc = templateRenderPipelineDesc;
 
             // Calculate _color ^ xorColor for RGB components
             // This color gets XORed with destination framebuffer pixel color
             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
             [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 
         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
-
-            pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
-                                        vertexShaderId:@"vert_grad"
-                                      fragmentShaderId:@"frag_grad"
-                                              srcFlags:srcFlags
-                                              dstFlags:dstFlags
-                                         stencilNeeded:stencil];
+            vertShader = @"vert_grad";
+            fragShader = @"frag_grad";
+            rpDesc = templateRenderPipelineDesc;
 
                 struct GradFrameUniforms uf = {
                         {_p0, _p1, _p3},
                         RGBA_TO_V4(_pixel1 ^ xorColor),
                         RGBA_TO_V4(_pixel2 ^ xorColor)};
                 [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];
             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
+            vertShader = @"vert_tp";
+            fragShader = @"frag_tp_xorMode";
+            rpDesc = templateRenderPipelineDesc;
 
-                pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
-                                            vertexShaderId:@"vert_tp"
-                                          fragmentShaderId:@"frag_tp_xorMode"
-                                                  srcFlags:srcFlags
-                                                  dstFlags:dstFlags
-                                             stencilNeeded:stencil];
 
                 [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
                 [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];
             }
         }
+
+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc
+                                                                        vertexShaderId:vertShader
+                                                                      fragmentShaderId:fragShader
+                                                                             composite:mtlc.composite
+                                                                         renderOptions:renderOptions
+                                                                         stencilNeeded:[mtlc.clip isShape]];
     [encoder setRenderPipelineState:pipelineState];
 }
 
 @end
 
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h
@@ -1,10 +1,10 @@
 #ifndef MTLPipelineStatesStorage_h_Included
 #define MTLPipelineStatesStorage_h_Included
 
 #import "MTLUtils.h"
-#include "MTLSurfaceDataBase.h"
+#include "RenderOptions.h"
 
 @class MTLComposite;
 
 /**
  * The MTLPipelineStatesStorage class used to obtain MTLRenderPipelineState
@@ -24,56 +24,21 @@
 @property (readwrite, retain) NSMutableDictionary<NSString*, id<MTLFunction>> * shaders;
 @property (readwrite, retain) NSMutableDictionary<NSString*, NSMutableDictionary *> * states;
 
 - (id) initWithDevice:(id<MTLDevice>)device shaderLibPath:(NSString *)shadersLib;
 
-// returns pipelineState with disabled blending and stencil
 - (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
                                  vertexShaderId:(NSString *)vertexShaderId
                                fragmentShaderId:(NSString *)fragmentShaderId;
 
-// returns pipelineState with composite for default SurfaceRasterFlags
 - (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
                                  vertexShaderId:(NSString *)vertexShaderId
                                fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
-                                  stencilNeeded:(bool)stencilNeeded;
-
-// base method to obtain MTLRenderPipelineState
-- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
-                                       srcFlags:(const SurfaceRasterFlags * )srcFlags
-                                       dstFlags:(const SurfaceRasterFlags * )dstFlags
-                                  stencilNeeded:(bool)stencilNeeded;
-
-- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
-                                           isAA:(jboolean)isAA
-                                       srcFlags:(const SurfaceRasterFlags *)srcFlags
-                                       dstFlags:(const SurfaceRasterFlags *)dstFlags
-                                  stencilNeeded:(bool)stencilNeeded;
-
-- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
                                       composite:(MTLComposite*)composite
-                                           isAA:(jboolean)isAA
-                                       srcFlags:(const SurfaceRasterFlags *)srcFlags
-                                       dstFlags:(const SurfaceRasterFlags *)dstFlags
+                                  renderOptions:(const RenderOptions *)renderOptions
                                   stencilNeeded:(bool)stencilNeeded;
 
-- (id<MTLRenderPipelineState>) getXorModePipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                       srcFlags:(const SurfaceRasterFlags * )srcFlags
-                                       dstFlags:(const SurfaceRasterFlags * )dstFlags
-                                  stencilNeeded:(bool)stencilNeeded;
 - (id<MTLFunction>) getShader:(NSString *)name;
 @end
 
 
 #endif // MTLPipelineStatesStorage_h_Included
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
@@ -1,20 +1,18 @@
 #import "MTLPipelineStatesStorage.h"
 
 #include "GraphicsPrimitiveMgr.h"
 #import "MTLComposite.h"
 
-// A special value for xor composite
-const int XOR_COMPOSITE_RULE = 20;
+#include "sun_java2d_SunGraphics2D.h"
 
 extern const SurfaceRasterFlags defaultRasterFlags;
 
 static void setBlendingFactors(
         MTLRenderPipelineColorAttachmentDescriptor * cad,
-        int compositeRule,
         MTLComposite* composite,
-        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags);
+        const RenderOptions * renderOptions);
 
 @implementation MTLPipelineStatesStorage
 
 @synthesize device;
 @synthesize library;
@@ -58,114 +56,58 @@
 
 - (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
                                  vertexShaderId:(NSString *)vertexShaderId
                                fragmentShaderId:(NSString *)fragmentShaderId
 {
+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0/*unused*/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}};
     return [self getPipelineState:pipelineDescriptor
                    vertexShaderId:vertexShaderId
                  fragmentShaderId:fragmentShaderId
-                    compositeRule:RULE_Src
-                         srcFlags:NULL
-                         dstFlags:NULL
-                    stencilNeeded:NO];
-}
-
-- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
-                                  stencilNeeded:(bool)stencilNeeded;
-{
-    return [self getPipelineState:pipelineDescriptor
-                   vertexShaderId:vertexShaderId
-                 fragmentShaderId:fragmentShaderId
-                    compositeRule:compositeRule
-                         srcFlags:&defaultRasterFlags
-                         dstFlags:&defaultRasterFlags
-                    stencilNeeded:stencilNeeded];
-}
-
-- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
-                                       srcFlags:(const SurfaceRasterFlags *)srcFlags
-                                       dstFlags:(const SurfaceRasterFlags *)dstFlags
-                                  stencilNeeded:(bool)stencilNeeded;
-{
-    return [self getPipelineState:pipelineDescriptor
-                   vertexShaderId:vertexShaderId
-                 fragmentShaderId:fragmentShaderId
-                    compositeRule:compositeRule
-                             isAA:JNI_FALSE
-                         srcFlags:srcFlags
-                         dstFlags:dstFlags
-            stencilNeeded:stencilNeeded];
-}
-
-- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
-                                           isAA:(jboolean)isAA
-                                       srcFlags:(const SurfaceRasterFlags *)srcFlags
-                                       dstFlags:(const SurfaceRasterFlags *)dstFlags
-                                  stencilNeeded:(bool)stencilNeeded;
-{
-    return [self getPipelineState:pipelineDescriptor
-                   vertexShaderId:vertexShaderId
-                 fragmentShaderId:fragmentShaderId
-                    compositeRule:compositeRule
                         composite:nil
-                             isAA:isAA
-                         srcFlags:srcFlags
-                         dstFlags:dstFlags
-                    stencilNeeded:stencilNeeded];
+                    renderOptions:&defaultOptions
+                    stencilNeeded:NO];
 }
 
 // Base method to obtain MTLRenderPipelineState.
 // NOTE: parameters compositeRule, srcFlags, dstFlags are used to set MTLRenderPipelineColorAttachmentDescriptor multipliers
 - (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
                                  vertexShaderId:(NSString *)vertexShaderId
                                fragmentShaderId:(NSString *)fragmentShaderId
-                                  compositeRule:(jint)compositeRule
                                       composite:(MTLComposite*) composite
-                                           isAA:(jboolean)isAA
-                                       srcFlags:(const SurfaceRasterFlags *)srcFlags
-                                       dstFlags:(const SurfaceRasterFlags *)dstFlags
+                                  renderOptions:(const RenderOptions *)renderOptions
                                   stencilNeeded:(bool)stencilNeeded;
 {
-    const jboolean useXorComposite = (compositeRule == XOR_COMPOSITE_RULE);
-    const jboolean useComposite = compositeRule >= 0
-        && compositeRule < java_awt_AlphaComposite_MAX_RULE
-        && srcFlags != NULL && dstFlags != NULL;
+    jint compositeRule = composite != nil ? [composite getRule] : RULE_Src;
+    const jboolean useXorComposite = composite != nil && [composite getCompositeState] == sun_java2d_SunGraphics2D_COMP_XOR;
+    const jboolean useComposite = composite != nil && compositeRule >= 0
+        && compositeRule < java_awt_AlphaComposite_MAX_RULE;
 
     // Calculate index by flags and compositeRule
     // TODO: reimplement, use map with convenient key (calculated by all arguments)
     int subIndex = 0;
     if (useXorComposite) {
         // compositeRule value is already XOR_COMPOSITE_RULE
     }
     else {
         if (useComposite) {
-            if (!srcFlags->isPremultiplied)
+            if (!renderOptions->srcFlags.isPremultiplied)
                 subIndex |= 1;
-            if (srcFlags->isOpaque)
+            if (renderOptions->srcFlags.isOpaque)
                 subIndex |= 1 << 1;
-            if (!dstFlags->isPremultiplied)
+            if (!renderOptions->dstFlags.isPremultiplied)
                 subIndex |= 1 << 2;
-            if (dstFlags->isOpaque)
+            if (renderOptions->dstFlags.isOpaque)
                 subIndex |= 1 << 3;
         } else
             compositeRule = RULE_Src;
     }
 
     if (stencilNeeded) {
         subIndex |= 1 << 4;
     }
 
-    if (isAA) {
+    if (renderOptions->isAA) {
         subIndex |= 1 << 5;
     }
 
     if ((composite != nil && FLT_LT([composite getExtraAlpha], 1.0f))) {
         subIndex |= 1 << 6;
@@ -197,20 +139,19 @@
                        (composite != nil  &&
                         FLT_LT([composite getExtraAlpha], 1.0f)))
             {
                 setBlendingFactors(
                         pipelineDesc.colorAttachments[0],
-                        compositeRule,
                         composite,
-                        srcFlags, dstFlags
+                        renderOptions
                 );
             }
             if (stencilNeeded) {
                 pipelineDesc.stencilAttachmentPixelFormat = MTLPixelFormatStencil8;
             }
 
-            if (isAA) {
+            if (renderOptions->isAA) {
                 pipelineDesc.sampleCount = MTLAASampleCount;
                 pipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;
                 pipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;
                 pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
                 pipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorSourceAlpha;
@@ -239,34 +180,18 @@
         result = [[self.library newFunctionWithName:name] autorelease];
         [self.shaders setValue:result forKey:name];
     }
     return result;
 }
-
-- (id<MTLRenderPipelineState>) getXorModePipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
-                                 vertexShaderId:(NSString *)vertexShaderId
-                               fragmentShaderId:(NSString *)fragmentShaderId
-                                                  srcFlags:(const SurfaceRasterFlags * )srcFlags
-                                                  dstFlags:(const SurfaceRasterFlags * )dstFlags
-                                             stencilNeeded:(bool)stencilNeeded {
-            return [self getPipelineState:pipelineDescriptor
-                   vertexShaderId:vertexShaderId
-                 fragmentShaderId:fragmentShaderId
-                    compositeRule:XOR_COMPOSITE_RULE
-                         srcFlags:NULL
-                         dstFlags:NULL
-                    stencilNeeded:stencilNeeded];
-} 
 @end
 
 static void setBlendingFactors(
         MTLRenderPipelineColorAttachmentDescriptor * cad,
-        int compositeRule,
         MTLComposite* composite,
-        const SurfaceRasterFlags * srcFlags,
-        const SurfaceRasterFlags * dstFlags
+        const RenderOptions * renderOptions
 ) {
+    const jint compositeRule = composite != nil ? [composite getRule] : RULE_Src;
     if (compositeRule == RULE_Src &&
         (composite == nil || FLT_GE([composite getExtraAlpha], 1.0f))) {
         J2dTraceLn(J2D_TRACE_VERBOSE, "set RULE_Src but blending is disabled because src is opaque");
         return;
     }
@@ -288,27 +213,27 @@
 
     switch (compositeRule) {
         case RULE_SrcOver: {
             // Ar = As + Ad*(1-As)
             // Cr = Cs + Cd*(1-As)
-            if (srcFlags->isOpaque &&
+            if (renderOptions->srcFlags.isOpaque &&
                 (composite == nil ||
                  FLT_GE([composite getExtraAlpha], 1.0f)))
             {
                 J2dTraceLn(J2D_TRACE_VERBOSE, "rule=RULE_SrcOver, but blending is disabled because src is opaque");
                 cad.blendingEnabled = NO;
                 return;
             }
-            if (dstFlags->isOpaque) {
+            if (renderOptions->dstFlags.isOpaque) {
                 // Ar = 1, can be ignored, so
                 // Cr = Cs + Cd*(1-As)
                 // TODO: select any multiplier with best performance
                 // for example: cad.destinationAlphaBlendFactor = MTLBlendFactorZero;
             } else {
                 cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
             }
-            if (!srcFlags->isPremultiplied) {
+            if (!renderOptions->srcFlags.isPremultiplied) {
                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
             }
             if (composite != nil && FLT_LT([composite getExtraAlpha], 1.0f)) {
                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
             }
@@ -318,17 +243,17 @@
             break;
         }
         case RULE_DstOver: {
             // Ar = As*(1-Ad) + Ad
             // Cr = Cs*(1-Ad) + Cd
-            if (srcFlags->isOpaque) {
+            if (renderOptions->srcFlags.isOpaque) {
                 J2dTraceLn(J2D_TRACE_ERROR, "Composite rule RULE_DstOver with opaque src isn't implemented (src alpha won't be ignored)");
             }
-            if (dstFlags->isOpaque) {
+            if (renderOptions->dstFlags.isOpaque) {
                 J2dTraceLn(J2D_TRACE_ERROR, "Composite rule RULE_DstOver with opaque dest hasn't any sense");
             }
-            if (!srcFlags->isPremultiplied) {
+            if (!renderOptions->srcFlags.isPremultiplied) {
                 J2dTrace(J2D_TRACE_ERROR, "Composite rule RULE_DstOver with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)");
             }
             cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
             cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
             cad.destinationAlphaBlendFactor = MTLBlendFactorOne;
@@ -337,19 +262,19 @@
             break;
         }
         case RULE_SrcIn: {
             // Ar = As*Ad
             // Cr = Cs*Ad
-            if (srcFlags->isOpaque) {
+            if (renderOptions->srcFlags.isOpaque) {
                 J2dTraceLn(J2D_TRACE_ERROR, "Composite rule RULE_SrcIn with opaque src isn't implemented (src alpha won't be ignored)");
             }
-            if (dstFlags->isOpaque) {
+            if (renderOptions->dstFlags.isOpaque) {
                 J2dTraceLn(J2D_TRACE_VERBOSE, "rule=RULE_SrcIn, but blending is disabled because dest is opaque");
                 cad.blendingEnabled = NO;
                 return;
             }
-            if (!srcFlags->isPremultiplied) {
+            if (!renderOptions->srcFlags.isPremultiplied) {
                 J2dTrace(J2D_TRACE_ERROR, "Composite rule RULE_SrcIn with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)");
             }
             cad.sourceAlphaBlendFactor = MTLBlendFactorDestinationAlpha;
             cad.sourceRGBBlendFactor = MTLBlendFactorDestinationAlpha;
             cad.destinationAlphaBlendFactor = MTLBlendFactorZero;
@@ -358,14 +283,14 @@
             break;
         }
         case RULE_DstIn: {
             // Ar = Ad*As
             // Cr = Cd*As
-            if (srcFlags->isOpaque) {
+            if (renderOptions->srcFlags.isOpaque) {
                 J2dTraceLn(J2D_TRACE_ERROR, "Composite rule RULE_DstIn with opaque src isn't implemented (src alpha won't be ignored)");
             }
-            if (dstFlags->isOpaque) {
+            if (renderOptions->dstFlags.isOpaque) {
                 J2dTraceLn(J2D_TRACE_ERROR, "Composite rule RULE_DstIn with opaque dest isn't implemented (dest alpha won't be ignored)");
             }
             cad.sourceAlphaBlendFactor = MTLBlendFactorZero;
             cad.sourceRGBBlendFactor = MTLBlendFactorZero;
             cad.destinationAlphaBlendFactor = MTLBlendFactorSourceAlpha;
@@ -374,11 +299,11 @@
             break;
         }
         case RULE_SrcOut: {
             // Ar = As*(1-Ad)
             // Cr = Cs*(1-Ad)
-            if (!srcFlags->isPremultiplied) {
+            if (!renderOptions->srcFlags.isPremultiplied) {
                 J2dTrace(J2D_TRACE_ERROR, "Composite rule SrcOut with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)");
             }
             cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
             cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
             cad.destinationAlphaBlendFactor = MTLBlendFactorZero;
@@ -397,11 +322,11 @@
             break;
         }
         case RULE_Xor: {
             // Ar = As*(1-Ad) + Ad*(1-As)
             // Cr = Cs*(1-Ad) + Cd*(1-As)
-            if (!srcFlags->isPremultiplied) {
+            if (!renderOptions->srcFlags.isPremultiplied) {
                 J2dTrace(J2D_TRACE_ERROR, "Composite rule Xor with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)");
             }
             cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
             cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
             cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m
@@ -950,38 +950,47 @@
                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
                 jlong pSrc        = NEXT_LONG(b);
                 jboolean edgeZero = NEXT_BOOLEAN(b);
                 jint kernelWidth  = NEXT_INT(b);
                 jint kernelHeight = NEXT_INT(b);
-                MTLBufImgOps_EnableConvolveOp(mtlc, pSrc, edgeZero,
-                                              kernelWidth, kernelHeight, b);
+
+                BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
+                MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
+                        kernelWidth:kernelWidth
+                       kernelHeight:kernelHeight
+                           srcWidth:bmtlsdOps->width
+                          srcHeight:bmtlsdOps->height
+                             kernel:b
+                             device:mtlc.device
+                                              ];
+                [mtlc setBufImgOp:convolveOp];
                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
             }
             break;
         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
             {
                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                MTLBufImgOps_DisableConvolveOp(mtlc);
+                [mtlc setBufImgOp:NULL];
             }
             break;
         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
             {
                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
                 jlong pSrc          = NEXT_LONG(b);
                 jboolean nonPremult = NEXT_BOOLEAN(b);
                 jint numFactors     = 4;
                 unsigned char *scaleFactors = b;
                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
-                MTLBufImgOps_EnableRescaleOp(mtlc, pSrc, nonPremult,
-                                             scaleFactors, offsets);
+                MTLRescaleOp * rescaleOp = [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
+                [mtlc setBufImgOp:rescaleOp];
                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
             }
             break;
         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
             {
                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                MTLBufImgOps_DisableRescaleOp(mtlc);
+                [mtlc setBufImgOp:NULL];
             }
             break;
         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
             {
                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
@@ -991,20 +1000,26 @@
                 jint numBands       = NEXT_INT(b);
                 jint bandLength     = NEXT_INT(b);
                 jint offset         = NEXT_INT(b);
                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
                 void *tableValues = b;
-                MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
-                                            numBands, bandLength, offset,
-                                            tableValues);
+
+                MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
+                                                         shortData:shortData
+                                                          numBands:numBands
+                                                        bandLength:bandLength
+                                                            offset:offset
+                                                       tableValues:tableValues
+                                                            device:mtlc.device];
+                [mtlc setBufImgOp:lookupOp];
                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
             }
             break;
         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
             {
                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
-                MTLBufImgOps_DisableLookupOp(mtlc);
+                [mtlc setBufImgOp:NULL];
             }
             break;
 
         default:
             J2dRlsTraceLn1(J2D_TRACE_ERROR,
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/RenderOptions.h b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/RenderOptions.h
--- /dev/null
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/RenderOptions.h
@@ -0,0 +1,17 @@
+#ifndef __RENDEROPTIONS_H
+#define __RENDEROPTIONS_H
+
+#include <jni.h>
+#include "MTLSurfaceDataBase.h"
+
+// Utility struct to transfer rendering paramenters
+typedef struct {
+    jboolean isTexture;
+    jboolean isAA;
+    int interpolation;
+    SurfaceRasterFlags srcFlags;
+    SurfaceRasterFlags dstFlags;
+} RenderOptions;
+
+
+#endif //__RENDEROPTIONS_H

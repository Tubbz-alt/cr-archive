<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 232 
 233     return JNI_TRUE;
 234 }
 235 
 236 id&lt;MTLTexture&gt;
 237 MTLTR_GetGlyphCacheTexture()
 238 {
 239     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
 240     if (glyphCacheAA != NULL) {
 241         return glyphCacheAA-&gt;texture;
 242     }
 243     return NULL;
 244 }
 245 
 246 /**
 247  * Adds the given glyph to the glyph cache (texture and data structure)
 248  * associated with the given MTLContext.
 249  */
 250 static void
 251 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
<span class="line-modified"> 252                       MTLPixelFormat pixelFormat)</span>
 253 {
 254     MTLCacheCellInfo *ccinfo;
 255     MTLGlyphCacheInfo *gcinfo;
<span class="line-removed"> 256     jboolean isLCD = JNI_FALSE;</span>
 257     jint w = glyph-&gt;width;
 258     jint h = glyph-&gt;height;
 259 
 260     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
<span class="line-modified"> 261     if (pixelFormat == MTLPixelFormatA8Unorm) {</span>
 262         gcinfo = glyphCacheAA;
 263     } else {
 264         gcinfo = glyphCacheLCD;
<span class="line-removed"> 265         isLCD = JNI_TRUE;</span>
 266     }
 267 
 268     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
 269         return;
 270     }
 271 
 272     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
 273     if (isCacheFull) {
 274         MTLGlyphCache_Free(gcinfo);
<span class="line-modified"> 275         if (!isLCD) {</span>
 276             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
 277             gcinfo = glyphCacheAA;
 278         } else {
 279             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
 280             gcinfo = glyphCacheLCD;
 281         }
 282     }
 283     MTLGlyphCache_AddGlyph(gcinfo, glyph);
 284     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
 285 
 286     if (ccinfo != NULL) {
 287         // store glyph image in texture cell
 288         MTLRegion region = {
 289                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
 290                 {w, h, 1}
 291         };
<span class="line-modified"> 292         if (!isLCD) {</span>
 293             // Opengl uses GL_INTENSITY as internal pixel format to set number of
 294             // color components in the texture for grayscale texture.
 295             // It is mentioned that for GL_INTENSITY format,
 296             // the GL assembles it into an RGBA element by replicating the
 297             // intensity value three times for red, green, blue, and alpha.
 298             // To let metal behave the same for grayscale text,
 299             // we need to make sure we create BGRA component by replicating
 300             // graycale pixel value as in R=G=B=A=grayscale pixel value
 301 
 302             unsigned int imageBytes = w * h * 4;
 303             unsigned char imageData[imageBytes];
 304             memset(&amp;imageData, 0, sizeof(imageData));
 305 
 306             unsigned int dstindex = 0;
 307             for (int i = 0; i &lt; (w * h); i++) {
 308                 imageData[dstindex++] = glyph-&gt;image[i];
 309                 imageData[dstindex++] = glyph-&gt;image[i];
 310                 imageData[dstindex++] = glyph-&gt;image[i];
 311                 imageData[dstindex++] = glyph-&gt;image[i];
 312             }
</pre>
<hr />
<pre>
 536 static jboolean
 537 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
 538                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 539 {
 540     MTLCacheCellInfo *cell;
 541     jfloat x1, y1, x2, y2;
 542 
 543     if (glyphMode != MODE_USE_CACHE_GRAY) {
 544         if (glyphMode == MODE_NO_CACHE_GRAY) {
 545             MTLVertexCache_DisableMaskCache(mtlc);
 546         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 547             [mtlc.encoderManager endEncoder];
 548             lcdCacheEncoder = nil;
 549         }
 550         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
 551         glyphMode = MODE_USE_CACHE_GRAY;
 552     }
 553 
 554     if (ginfo-&gt;cellInfo == NULL) {
 555         // attempt to add glyph to accelerated glyph cache
<span class="line-modified"> 556         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatA8Unorm);</span>
 557 
 558         if (ginfo-&gt;cellInfo == NULL) {
 559             // we&#39;ll just no-op in the rare case that the cell is NULL
 560             return JNI_TRUE;
 561         }
 562     }
 563 
 564     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
 565     cell-&gt;timesRendered++;
 566 
 567     x1 = (jfloat)x;
 568     y1 = (jfloat)y;
 569     x2 = x1 + ginfo-&gt;width;
 570     y2 = y1 + ginfo-&gt;height;
 571 
 572     MTLVertexCache_AddGlyphQuad(mtlc,
 573                                 cell-&gt;tx1, cell-&gt;ty1,
 574                                 cell-&gt;tx2, cell-&gt;ty2,
 575                                 x1, y1, x2, y2);
 576 
</pre>
<hr />
<pre>
 632                 return JNI_FALSE;
 633             }
 634         }
 635         if (lcdCacheEncoder == nil) {
 636             lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 637             MTLTR_SetLCDCachePipelineState(mtlc);
 638         }
 639         if (rgbOrder != lastRGBOrder) {
 640             // need to invalidate the cache in this case; see comments
 641             // for lastRGBOrder above
 642             MTLGlyphCache_Invalidate(glyphCacheLCD);
 643             lastRGBOrder = rgbOrder;
 644         }
 645 
 646         glyphMode = MODE_USE_CACHE_LCD;
 647     }
 648 
 649     if (ginfo-&gt;cellInfo == NULL) {
 650         // attempt to add glyph to accelerated glyph cache
 651         // TODO : Handle RGB order
<span class="line-modified"> 652         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);</span>
 653 
 654         if (ginfo-&gt;cellInfo == NULL) {
 655             // we&#39;ll just no-op in the rare case that the cell is NULL
 656             return JNI_TRUE;
 657         }
 658     }
 659     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
 660     cell-&gt;timesRendered++;
 661 
 662     MTLTR_SetLCDContrast(mtlc, contrast);
 663     tx1 = cell-&gt;tx1;
 664     ty1 = cell-&gt;ty1;
 665     tx2 = cell-&gt;tx2;
 666     ty2 = cell-&gt;ty2;
 667 
 668     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 669     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 670 
 671     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 672 
</pre>
</td>
<td>
<hr />
<pre>
 232 
 233     return JNI_TRUE;
 234 }
 235 
 236 id&lt;MTLTexture&gt;
 237 MTLTR_GetGlyphCacheTexture()
 238 {
 239     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
 240     if (glyphCacheAA != NULL) {
 241         return glyphCacheAA-&gt;texture;
 242     }
 243     return NULL;
 244 }
 245 
 246 /**
 247  * Adds the given glyph to the glyph cache (texture and data structure)
 248  * associated with the given MTLContext.
 249  */
 250 static void
 251 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
<span class="line-modified"> 252                       jboolean lcdCache)</span>
 253 {
 254     MTLCacheCellInfo *ccinfo;
 255     MTLGlyphCacheInfo *gcinfo;

 256     jint w = glyph-&gt;width;
 257     jint h = glyph-&gt;height;
 258 
 259     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
<span class="line-modified"> 260     if (!lcdCache) {</span>
 261         gcinfo = glyphCacheAA;
 262     } else {
 263         gcinfo = glyphCacheLCD;

 264     }
 265 
 266     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
 267         return;
 268     }
 269 
 270     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
 271     if (isCacheFull) {
 272         MTLGlyphCache_Free(gcinfo);
<span class="line-modified"> 273         if (!lcdCache) {</span>
 274             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
 275             gcinfo = glyphCacheAA;
 276         } else {
 277             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
 278             gcinfo = glyphCacheLCD;
 279         }
 280     }
 281     MTLGlyphCache_AddGlyph(gcinfo, glyph);
 282     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
 283 
 284     if (ccinfo != NULL) {
 285         // store glyph image in texture cell
 286         MTLRegion region = {
 287                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
 288                 {w, h, 1}
 289         };
<span class="line-modified"> 290         if (!lcdCache) {</span>
 291             // Opengl uses GL_INTENSITY as internal pixel format to set number of
 292             // color components in the texture for grayscale texture.
 293             // It is mentioned that for GL_INTENSITY format,
 294             // the GL assembles it into an RGBA element by replicating the
 295             // intensity value three times for red, green, blue, and alpha.
 296             // To let metal behave the same for grayscale text,
 297             // we need to make sure we create BGRA component by replicating
 298             // graycale pixel value as in R=G=B=A=grayscale pixel value
 299 
 300             unsigned int imageBytes = w * h * 4;
 301             unsigned char imageData[imageBytes];
 302             memset(&amp;imageData, 0, sizeof(imageData));
 303 
 304             unsigned int dstindex = 0;
 305             for (int i = 0; i &lt; (w * h); i++) {
 306                 imageData[dstindex++] = glyph-&gt;image[i];
 307                 imageData[dstindex++] = glyph-&gt;image[i];
 308                 imageData[dstindex++] = glyph-&gt;image[i];
 309                 imageData[dstindex++] = glyph-&gt;image[i];
 310             }
</pre>
<hr />
<pre>
 534 static jboolean
 535 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
 536                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 537 {
 538     MTLCacheCellInfo *cell;
 539     jfloat x1, y1, x2, y2;
 540 
 541     if (glyphMode != MODE_USE_CACHE_GRAY) {
 542         if (glyphMode == MODE_NO_CACHE_GRAY) {
 543             MTLVertexCache_DisableMaskCache(mtlc);
 544         } else if (glyphMode == MODE_USE_CACHE_LCD) {
 545             [mtlc.encoderManager endEncoder];
 546             lcdCacheEncoder = nil;
 547         }
 548         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
 549         glyphMode = MODE_USE_CACHE_GRAY;
 550     }
 551 
 552     if (ginfo-&gt;cellInfo == NULL) {
 553         // attempt to add glyph to accelerated glyph cache
<span class="line-modified"> 554         MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_FALSE);</span>
 555 
 556         if (ginfo-&gt;cellInfo == NULL) {
 557             // we&#39;ll just no-op in the rare case that the cell is NULL
 558             return JNI_TRUE;
 559         }
 560     }
 561 
 562     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
 563     cell-&gt;timesRendered++;
 564 
 565     x1 = (jfloat)x;
 566     y1 = (jfloat)y;
 567     x2 = x1 + ginfo-&gt;width;
 568     y2 = y1 + ginfo-&gt;height;
 569 
 570     MTLVertexCache_AddGlyphQuad(mtlc,
 571                                 cell-&gt;tx1, cell-&gt;ty1,
 572                                 cell-&gt;tx2, cell-&gt;ty2,
 573                                 x1, y1, x2, y2);
 574 
</pre>
<hr />
<pre>
 630                 return JNI_FALSE;
 631             }
 632         }
 633         if (lcdCacheEncoder == nil) {
 634             lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 635             MTLTR_SetLCDCachePipelineState(mtlc);
 636         }
 637         if (rgbOrder != lastRGBOrder) {
 638             // need to invalidate the cache in this case; see comments
 639             // for lastRGBOrder above
 640             MTLGlyphCache_Invalidate(glyphCacheLCD);
 641             lastRGBOrder = rgbOrder;
 642         }
 643 
 644         glyphMode = MODE_USE_CACHE_LCD;
 645     }
 646 
 647     if (ginfo-&gt;cellInfo == NULL) {
 648         // attempt to add glyph to accelerated glyph cache
 649         // TODO : Handle RGB order
<span class="line-modified"> 650         MTLTR_AddToGlyphCache(ginfo, mtlc, JNI_TRUE);</span>
 651 
 652         if (ginfo-&gt;cellInfo == NULL) {
 653             // we&#39;ll just no-op in the rare case that the cell is NULL
 654             return JNI_TRUE;
 655         }
 656     }
 657     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
 658     cell-&gt;timesRendered++;
 659 
 660     MTLTR_SetLCDContrast(mtlc, contrast);
 661     tx1 = cell-&gt;tx1;
 662     ty1 = cell-&gt;ty1;
 663     tx2 = cell-&gt;tx2;
 664     ty2 = cell-&gt;ty2;
 665 
 666     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 667     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 668 
 669     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 670 
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
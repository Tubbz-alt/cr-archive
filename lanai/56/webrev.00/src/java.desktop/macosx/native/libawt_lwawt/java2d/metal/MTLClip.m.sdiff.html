<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLBlitLoops.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
136 }
137 
138 - (void)beginShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {
139     _stencilMaskGenerationInProgress = YES;
140 
141     if ((dstOps == NULL) || (dstOps-&gt;pStencilData == NULL) || (dstOps-&gt;pStencilTexture == NULL)) {
142         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_beginShapeClip: stencil render target or stencil texture is NULL&quot;);
143         return;
144     }
145 
146     // Clear the stencil render buffer &amp; stencil texture
147     @autoreleasepool {
148         if (dstOps-&gt;width &lt;= 0 || dstOps-&gt;height &lt;= 0) {
149           return;
150         }
151 
152         NSUInteger width = (NSUInteger)dstOps-&gt;width;
153         NSUInteger height = (NSUInteger)dstOps-&gt;height;
154         NSUInteger size = width*height;
155         id &lt;MTLBuffer&gt; buff = [mtlc.device newBufferWithLength:size*4 options:MTLResourceStorageModePrivate];
<span class="line-modified">156         id&lt;MTLCommandBuffer&gt; commandBuf = [mtlc createBlitCommandBuffer];</span>
157         id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [commandBuf blitCommandEncoder];
158         [blitEncoder fillBuffer:buff range:NSMakeRange(0, size*4) value:0];
159 
160         MTLOrigin origin = MTLOriginMake(0, 0, 0);
161         MTLSize sourceSize = MTLSizeMake(width, height, 1);
162         [blitEncoder copyFromBuffer:buff
163                        sourceOffset:0
164                   sourceBytesPerRow:width
165                 sourceBytesPerImage:size
166                          sourceSize:sourceSize
167                           toTexture:dstOps-&gt;pStencilData
168                    destinationSlice:0
169                    destinationLevel:0
170                   destinationOrigin:origin];
171         [blitEncoder endEncoding];
172         [commandBuf commit];
173         [commandBuf waitUntilCompleted];
174 
175         [buff release];
176     }
</pre>
<hr />
<pre>
187     [mtlc.encoderManager endEncoder];
188 
189     MTLCommandBufferWrapper* cbWrapper = [mtlc pullCommandBufferWrapper];
190 
191     id&lt;MTLCommandBuffer&gt; commandBuffer = [cbWrapper getCommandBuffer];
192     [commandBuffer addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; c) {
193         [cbWrapper release];
194     }];
195 
196     [commandBuffer commit];
197     [commandBuffer waitUntilCompleted];
198 
199     // Now the stencil data is ready, this needs to be used while rendering further
200     @autoreleasepool {
201         if (dstOps-&gt;width &gt; 0 &amp;&amp; dstOps-&gt;height &gt; 0) {
202             NSUInteger width = (NSUInteger)dstOps-&gt;width;
203             NSUInteger height = (NSUInteger)dstOps-&gt;height;
204             NSUInteger size = width*height;
205             NSUInteger sizeX4 = size*4;
206 
<span class="line-modified">207             id&lt;MTLCommandBuffer&gt; cb = [mtlc createBlitCommandBuffer];</span>
208             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
209             MTLSize sourceSize = MTLSizeMake(width, height, 1);
210             MTLOrigin origin = MTLOriginMake(0, 0, 0);
211             [blitEncoder copyFromTexture:dstOps-&gt;pStencilData
212                              sourceSlice:0
213                              sourceLevel:0
214                             sourceOrigin:origin
215                               sourceSize:sourceSize
216                                 toBuffer:dstOps-&gt;pStencilDataBuf
217                        destinationOffset:0
218                   destinationBytesPerRow:width
219                 destinationBytesPerImage:size];
220             [blitEncoder endEncoding];
221             [cb commit];
222             [cb waitUntilCompleted];
223         }
224     }
225 
226     _stencilMaskGenerationInProgress = JNI_FALSE;
227     _mtlc = mtlc;
</pre>
<hr />
<pre>
283     }
284 }
285 
286 - (NSString *)getDescription __unused {
287     if (_clipType == NO_CLIP) {
288         return @&quot;NO_CLIP&quot;;
289     }
290     if (_clipType == RECT_CLIP) {
291         return [NSString stringWithFormat:@&quot;RECT_CLIP [%lu,%lu - %lux%lu]&quot;, _clipRect.x, _clipRect.y, _clipRect.width, _clipRect.height];
292     }
293     return [NSString stringWithFormat:@&quot;SHAPE_CLIP&quot;];
294 }
295 
296 - (id&lt;MTLTexture&gt;) stencilTextureRef {
297     if (_dstOps == NULL) return nil;
298 
299     id &lt;MTLTexture&gt; _stencilTextureRef = _dstOps-&gt;pStencilTexture;
300 
301     if (!_clipReady) {
302         @autoreleasepool {
<span class="line-modified">303             id &lt;MTLCommandBuffer&gt; cb = [_mtlc createBlitCommandBuffer];</span>
304             id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
305             id &lt;MTLBuffer&gt; _stencilDataBufRef = _dstOps-&gt;pStencilDataBuf;
306 
307             NSUInteger width = _stencilTextureRef.width;
308             NSUInteger height = _stencilTextureRef.height;
309 
310             [blitEncoder copyFromBuffer:_stencilDataBufRef
311                            sourceOffset:0
312                       sourceBytesPerRow:width
313                     sourceBytesPerImage:width * height
314                              sourceSize:MTLSizeMake(width, height, 1)
315                               toTexture:_stencilTextureRef
316                        destinationSlice:0
317                        destinationLevel:0
318                       destinationOrigin:MTLOriginMake(0, 0, 0)];
319             [blitEncoder endEncoding];
320             [cb commit];
321             [cb waitUntilCompleted];
322             _clipReady = YES;
323         }
324     }
325     return _stencilTextureRef;
326 }
327 
328 - (id&lt;MTLTexture&gt;) stencilAADataRef {
329     if (_dstOps == NULL) return nil;
330 
331     id &lt;MTLTexture&gt; _stencilAADataRef = _dstOps-&gt;pAAStencilData;
332 
333     if (!_aaClipReady) {
334 
335         @autoreleasepool {
336 
<span class="line-modified">337             id &lt;MTLCommandBuffer&gt; cb = [_mtlc createBlitCommandBuffer];</span>
338             id &lt;MTLComputeCommandEncoder&gt; computeEncoder = [cb computeCommandEncoder];
339             id&lt;MTLComputePipelineState&gt; computePipelineState = [_mtlc.pipelineStateStorage getComputePipelineState:@&quot;stencil2tex&quot;];
340             id &lt;MTLBuffer&gt; _stencilDataBufRef = _dstOps-&gt;pStencilDataBuf;
341             id &lt;MTLBuffer&gt; _stencilAADataBufRef = _dstOps-&gt;pAAStencilDataBuf;
342             NSUInteger width = _stencilAADataRef.width;
343             NSUInteger height = _stencilAADataRef.height;
344             NSUInteger size = width * height;
345 
346             [computeEncoder setComputePipelineState:computePipelineState];
347 
348             [computeEncoder setBuffer:_stencilDataBufRef offset:0 atIndex:0];
349             [computeEncoder setBuffer:_stencilAADataBufRef offset:0 atIndex:1];
350             NSUInteger threadGroupSize = computePipelineState.maxTotalThreadsPerThreadgroup;
351             if (threadGroupSize &gt; _stencilDataBufRef.length)
352             {
353                 threadGroupSize = _stencilDataBufRef.length;
354             }
355 
356             MTLSize threadgroupCounts = MTLSizeMake(threadGroupSize, 1, 1);
357             MTLSize threadgroups = MTLSizeMake(_stencilDataBufRef.length / threadGroupSize,
</pre>
</td>
<td>
<hr />
<pre>
136 }
137 
138 - (void)beginShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {
139     _stencilMaskGenerationInProgress = YES;
140 
141     if ((dstOps == NULL) || (dstOps-&gt;pStencilData == NULL) || (dstOps-&gt;pStencilTexture == NULL)) {
142         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_beginShapeClip: stencil render target or stencil texture is NULL&quot;);
143         return;
144     }
145 
146     // Clear the stencil render buffer &amp; stencil texture
147     @autoreleasepool {
148         if (dstOps-&gt;width &lt;= 0 || dstOps-&gt;height &lt;= 0) {
149           return;
150         }
151 
152         NSUInteger width = (NSUInteger)dstOps-&gt;width;
153         NSUInteger height = (NSUInteger)dstOps-&gt;height;
154         NSUInteger size = width*height;
155         id &lt;MTLBuffer&gt; buff = [mtlc.device newBufferWithLength:size*4 options:MTLResourceStorageModePrivate];
<span class="line-modified">156         id&lt;MTLCommandBuffer&gt; commandBuf = [mtlc createCommandBuffer];</span>
157         id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [commandBuf blitCommandEncoder];
158         [blitEncoder fillBuffer:buff range:NSMakeRange(0, size*4) value:0];
159 
160         MTLOrigin origin = MTLOriginMake(0, 0, 0);
161         MTLSize sourceSize = MTLSizeMake(width, height, 1);
162         [blitEncoder copyFromBuffer:buff
163                        sourceOffset:0
164                   sourceBytesPerRow:width
165                 sourceBytesPerImage:size
166                          sourceSize:sourceSize
167                           toTexture:dstOps-&gt;pStencilData
168                    destinationSlice:0
169                    destinationLevel:0
170                   destinationOrigin:origin];
171         [blitEncoder endEncoding];
172         [commandBuf commit];
173         [commandBuf waitUntilCompleted];
174 
175         [buff release];
176     }
</pre>
<hr />
<pre>
187     [mtlc.encoderManager endEncoder];
188 
189     MTLCommandBufferWrapper* cbWrapper = [mtlc pullCommandBufferWrapper];
190 
191     id&lt;MTLCommandBuffer&gt; commandBuffer = [cbWrapper getCommandBuffer];
192     [commandBuffer addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; c) {
193         [cbWrapper release];
194     }];
195 
196     [commandBuffer commit];
197     [commandBuffer waitUntilCompleted];
198 
199     // Now the stencil data is ready, this needs to be used while rendering further
200     @autoreleasepool {
201         if (dstOps-&gt;width &gt; 0 &amp;&amp; dstOps-&gt;height &gt; 0) {
202             NSUInteger width = (NSUInteger)dstOps-&gt;width;
203             NSUInteger height = (NSUInteger)dstOps-&gt;height;
204             NSUInteger size = width*height;
205             NSUInteger sizeX4 = size*4;
206 
<span class="line-modified">207             id&lt;MTLCommandBuffer&gt; cb = [mtlc createCommandBuffer];</span>
208             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
209             MTLSize sourceSize = MTLSizeMake(width, height, 1);
210             MTLOrigin origin = MTLOriginMake(0, 0, 0);
211             [blitEncoder copyFromTexture:dstOps-&gt;pStencilData
212                              sourceSlice:0
213                              sourceLevel:0
214                             sourceOrigin:origin
215                               sourceSize:sourceSize
216                                 toBuffer:dstOps-&gt;pStencilDataBuf
217                        destinationOffset:0
218                   destinationBytesPerRow:width
219                 destinationBytesPerImage:size];
220             [blitEncoder endEncoding];
221             [cb commit];
222             [cb waitUntilCompleted];
223         }
224     }
225 
226     _stencilMaskGenerationInProgress = JNI_FALSE;
227     _mtlc = mtlc;
</pre>
<hr />
<pre>
283     }
284 }
285 
286 - (NSString *)getDescription __unused {
287     if (_clipType == NO_CLIP) {
288         return @&quot;NO_CLIP&quot;;
289     }
290     if (_clipType == RECT_CLIP) {
291         return [NSString stringWithFormat:@&quot;RECT_CLIP [%lu,%lu - %lux%lu]&quot;, _clipRect.x, _clipRect.y, _clipRect.width, _clipRect.height];
292     }
293     return [NSString stringWithFormat:@&quot;SHAPE_CLIP&quot;];
294 }
295 
296 - (id&lt;MTLTexture&gt;) stencilTextureRef {
297     if (_dstOps == NULL) return nil;
298 
299     id &lt;MTLTexture&gt; _stencilTextureRef = _dstOps-&gt;pStencilTexture;
300 
301     if (!_clipReady) {
302         @autoreleasepool {
<span class="line-modified">303             id &lt;MTLCommandBuffer&gt; cb = [_mtlc createCommandBuffer];</span>
304             id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
305             id &lt;MTLBuffer&gt; _stencilDataBufRef = _dstOps-&gt;pStencilDataBuf;
306 
307             NSUInteger width = _stencilTextureRef.width;
308             NSUInteger height = _stencilTextureRef.height;
309 
310             [blitEncoder copyFromBuffer:_stencilDataBufRef
311                            sourceOffset:0
312                       sourceBytesPerRow:width
313                     sourceBytesPerImage:width * height
314                              sourceSize:MTLSizeMake(width, height, 1)
315                               toTexture:_stencilTextureRef
316                        destinationSlice:0
317                        destinationLevel:0
318                       destinationOrigin:MTLOriginMake(0, 0, 0)];
319             [blitEncoder endEncoding];
320             [cb commit];
321             [cb waitUntilCompleted];
322             _clipReady = YES;
323         }
324     }
325     return _stencilTextureRef;
326 }
327 
328 - (id&lt;MTLTexture&gt;) stencilAADataRef {
329     if (_dstOps == NULL) return nil;
330 
331     id &lt;MTLTexture&gt; _stencilAADataRef = _dstOps-&gt;pAAStencilData;
332 
333     if (!_aaClipReady) {
334 
335         @autoreleasepool {
336 
<span class="line-modified">337             id &lt;MTLCommandBuffer&gt; cb = [_mtlc createCommandBuffer];</span>
338             id &lt;MTLComputeCommandEncoder&gt; computeEncoder = [cb computeCommandEncoder];
339             id&lt;MTLComputePipelineState&gt; computePipelineState = [_mtlc.pipelineStateStorage getComputePipelineState:@&quot;stencil2tex&quot;];
340             id &lt;MTLBuffer&gt; _stencilDataBufRef = _dstOps-&gt;pStencilDataBuf;
341             id &lt;MTLBuffer&gt; _stencilAADataBufRef = _dstOps-&gt;pAAStencilDataBuf;
342             NSUInteger width = _stencilAADataRef.width;
343             NSUInteger height = _stencilAADataRef.height;
344             NSUInteger size = width * height;
345 
346             [computeEncoder setComputePipelineState:computePipelineState];
347 
348             [computeEncoder setBuffer:_stencilDataBufRef offset:0 atIndex:0];
349             [computeEncoder setBuffer:_stencilAADataBufRef offset:0 atIndex:1];
350             NSUInteger threadGroupSize = computePipelineState.maxTotalThreadsPerThreadgroup;
351             if (threadGroupSize &gt; _stencilDataBufRef.length)
352             {
353                 threadGroupSize = _stencilDataBufRef.length;
354             }
355 
356             MTLSize threadgroupCounts = MTLSizeMake(threadGroupSize, 1, 1);
357             MTLSize threadgroups = MTLSizeMake(_stencilDataBufRef.length / threadGroupSize,
</pre>
</td>
</tr>
</table>
<center><a href="MTLBlitLoops.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
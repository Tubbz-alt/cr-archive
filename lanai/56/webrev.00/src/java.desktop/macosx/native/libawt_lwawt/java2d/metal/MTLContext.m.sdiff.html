<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLContext.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 80     [self-&gt;_commandBuffer release];
 81     [super dealloc];
 82 }
 83 
 84 @end
 85 
 86 @implementation MTLContext {
 87     MTLCommandBufferWrapper * _commandBufferWrapper;
 88 
 89     MTLComposite *     _composite;
 90     MTLPaint *         _paint;
 91     MTLTransform *     _transform;
 92     MTLClip *          _clip;
 93     NSObject*          _bufImgOp; // TODO: pass as parameter of IsoBlit
 94 
 95     EncoderManager * _encoderManager;
 96 }
 97 
 98 @synthesize textureFunction,
 99             vertexCacheEnabled, aaEnabled, device, library, pipelineStateStorage,
<span class="line-modified">100             commandQueue, vertexBuffer,</span>
101             texturePool;
102 
103 extern void initSamplers(id&lt;MTLDevice&gt; device);
104 
105 - (id)initWithDevice:(id&lt;MTLDevice&gt;)d shadersLib:(NSString*)shadersLib {
106     self = [super init];
107     if (self) {
108         // Initialization code here.
109         device = d;
110 
111         texturePool = [[MTLTexturePool alloc] initWithDevice:device];
112         pipelineStateStorage = [[MTLPipelineStatesStorage alloc] initWithDevice:device shaderLibPath:shadersLib];
113 
114         vertexBuffer = [device newBufferWithBytes:verts
115                                            length:sizeof(verts)
116                                           options:MTLResourceCPUCacheModeDefaultCache];
117 
118         NSError *error = nil;
119 
120         library = [device newLibraryWithFile:shadersLib error:&amp;error];
121         if (!library) {
122             NSLog(@&quot;Failed to load library. error %@&quot;, error);
123             exit(0);
124         }
125 
126         _encoderManager = [[EncoderManager alloc] init];
127         [_encoderManager setContext:self];
128         _composite = [[MTLComposite alloc] init];
129         _paint = [[MTLPaint alloc] init];
130         _transform = [[MTLTransform alloc] init];
131         _clip = [[MTLClip alloc] init];
132         _bufImgOp = nil;
133 
134         _commandBufferWrapper = nil;
135 
136         // Create command queue
137         commandQueue = [device newCommandQueue];

138 
139         initSamplers(device);
140     }
141     return self;
142 }
143 
144 - (void)dealloc {
145     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLContext.dealloc&quot;);
146 
147     self.texturePool = nil;
148     self.library = nil;
149     self.vertexBuffer = nil;
150     self.commandQueue = nil;

151     self.pipelineStateStorage = nil;
152     [_encoderManager release];
153     [_composite release];
154     [_paint release];
155     [_transform release];
156     [_clip release];
157     [super dealloc];
158 }
159 
160  - (MTLCommandBufferWrapper *) getCommandBufferWrapper {
161     if (_commandBufferWrapper == nil) {
162         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLContext : commandBuffer is NULL&quot;);
163         // NOTE: Command queues are thread-safe and allow multiple outstanding command buffers to be encoded simultaneously.
164         _commandBufferWrapper = [[MTLCommandBufferWrapper alloc] initWithCommandBuffer:[self.commandQueue commandBuffer]];// released in [layer blitTexture]
165     }
166     return _commandBufferWrapper;
167 }
168 
169 - (MTLCommandBufferWrapper *) pullCommandBufferWrapper {
170     MTLCommandBufferWrapper * result = _commandBufferWrapper;
</pre>
<hr />
<pre>
395     
396     if (srcOps == NULL || srcOps-&gt;pTexture == NULL) {
397         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_setTexturePaint: texture paint - texture is null&quot;);
398         return;
399     }
400 
401     J2dTraceLn1(J2D_TRACE_INFO, &quot;MTLContext.setTexturePaint [tex=%p]&quot;, srcOps-&gt;pTexture);
402 
403 
404     [_paint setTexture:useMask
405                textureID:srcOps-&gt;pTexture
406                 filter:filter
407                    xp0:xp0
408                    xp1:xp1
409                    xp3:xp3
410                    yp0:yp0
411                    yp1:yp1
412                    yp3:yp3];
413 }
414 
<span class="line-modified">415 - (id&lt;MTLCommandBuffer&gt;)createBlitCommandBuffer {</span>
416     return [self.commandQueue commandBuffer];
417 }
418 








419 -(void)setBufImgOp:(NSObject*)bufImgOp {
420     if (_bufImgOp != nil) {
421         [_bufImgOp release]; // context owns bufImgOp object
422     }
423     _bufImgOp = bufImgOp;
424 }
425 
426 -(NSObject*)getBufImgOp {
427     return _bufImgOp;
428 }
429 
430 @end
431 
432 /*
433  * Class:     sun_java2d_metal_MTLContext
434  * Method:    getMTLIdString
435  * Signature: ()Ljava/lang/String;
436  */
437 JNIEXPORT jstring JNICALL Java_sun_java2d_metal_MTLContext_getMTLIdString
438   (JNIEnv *env, jclass mtlcc)
</pre>
</td>
<td>
<hr />
<pre>
 80     [self-&gt;_commandBuffer release];
 81     [super dealloc];
 82 }
 83 
 84 @end
 85 
 86 @implementation MTLContext {
 87     MTLCommandBufferWrapper * _commandBufferWrapper;
 88 
 89     MTLComposite *     _composite;
 90     MTLPaint *         _paint;
 91     MTLTransform *     _transform;
 92     MTLClip *          _clip;
 93     NSObject*          _bufImgOp; // TODO: pass as parameter of IsoBlit
 94 
 95     EncoderManager * _encoderManager;
 96 }
 97 
 98 @synthesize textureFunction,
 99             vertexCacheEnabled, aaEnabled, device, library, pipelineStateStorage,
<span class="line-modified">100             commandQueue, blitCommandQueue, vertexBuffer,</span>
101             texturePool;
102 
103 extern void initSamplers(id&lt;MTLDevice&gt; device);
104 
105 - (id)initWithDevice:(id&lt;MTLDevice&gt;)d shadersLib:(NSString*)shadersLib {
106     self = [super init];
107     if (self) {
108         // Initialization code here.
109         device = d;
110 
111         texturePool = [[MTLTexturePool alloc] initWithDevice:device];
112         pipelineStateStorage = [[MTLPipelineStatesStorage alloc] initWithDevice:device shaderLibPath:shadersLib];
113 
114         vertexBuffer = [device newBufferWithBytes:verts
115                                            length:sizeof(verts)
116                                           options:MTLResourceCPUCacheModeDefaultCache];
117 
118         NSError *error = nil;
119 
120         library = [device newLibraryWithFile:shadersLib error:&amp;error];
121         if (!library) {
122             NSLog(@&quot;Failed to load library. error %@&quot;, error);
123             exit(0);
124         }
125 
126         _encoderManager = [[EncoderManager alloc] init];
127         [_encoderManager setContext:self];
128         _composite = [[MTLComposite alloc] init];
129         _paint = [[MTLPaint alloc] init];
130         _transform = [[MTLTransform alloc] init];
131         _clip = [[MTLClip alloc] init];
132         _bufImgOp = nil;
133 
134         _commandBufferWrapper = nil;
135 
136         // Create command queue
137         commandQueue = [device newCommandQueue];
<span class="line-added">138         blitCommandQueue = [device newCommandQueue];</span>
139 
140         initSamplers(device);
141     }
142     return self;
143 }
144 
145 - (void)dealloc {
146     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLContext.dealloc&quot;);
147 
148     self.texturePool = nil;
149     self.library = nil;
150     self.vertexBuffer = nil;
151     self.commandQueue = nil;
<span class="line-added">152     self.blitCommandQueue = nil;</span>
153     self.pipelineStateStorage = nil;
154     [_encoderManager release];
155     [_composite release];
156     [_paint release];
157     [_transform release];
158     [_clip release];
159     [super dealloc];
160 }
161 
162  - (MTLCommandBufferWrapper *) getCommandBufferWrapper {
163     if (_commandBufferWrapper == nil) {
164         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLContext : commandBuffer is NULL&quot;);
165         // NOTE: Command queues are thread-safe and allow multiple outstanding command buffers to be encoded simultaneously.
166         _commandBufferWrapper = [[MTLCommandBufferWrapper alloc] initWithCommandBuffer:[self.commandQueue commandBuffer]];// released in [layer blitTexture]
167     }
168     return _commandBufferWrapper;
169 }
170 
171 - (MTLCommandBufferWrapper *) pullCommandBufferWrapper {
172     MTLCommandBufferWrapper * result = _commandBufferWrapper;
</pre>
<hr />
<pre>
397     
398     if (srcOps == NULL || srcOps-&gt;pTexture == NULL) {
399         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_setTexturePaint: texture paint - texture is null&quot;);
400         return;
401     }
402 
403     J2dTraceLn1(J2D_TRACE_INFO, &quot;MTLContext.setTexturePaint [tex=%p]&quot;, srcOps-&gt;pTexture);
404 
405 
406     [_paint setTexture:useMask
407                textureID:srcOps-&gt;pTexture
408                 filter:filter
409                    xp0:xp0
410                    xp1:xp1
411                    xp3:xp3
412                    yp0:yp0
413                    yp1:yp1
414                    yp3:yp3];
415 }
416 
<span class="line-modified">417 - (id&lt;MTLCommandBuffer&gt;)createCommandBuffer {</span>
418     return [self.commandQueue commandBuffer];
419 }
420 
<span class="line-added">421 /*</span>
<span class="line-added">422  * This should be exclusively used only for final blit</span>
<span class="line-added">423  * and present of CAMetalDrawable in MTLLayer</span>
<span class="line-added">424  */</span>
<span class="line-added">425 - (id&lt;MTLCommandBuffer&gt;)createBlitCommandBuffer {</span>
<span class="line-added">426     return [self.blitCommandQueue commandBuffer];</span>
<span class="line-added">427 }</span>
<span class="line-added">428 </span>
429 -(void)setBufImgOp:(NSObject*)bufImgOp {
430     if (_bufImgOp != nil) {
431         [_bufImgOp release]; // context owns bufImgOp object
432     }
433     _bufImgOp = bufImgOp;
434 }
435 
436 -(NSObject*)getBufImgOp {
437     return _bufImgOp;
438 }
439 
440 @end
441 
442 /*
443  * Class:     sun_java2d_metal_MTLContext
444  * Method:    getMTLIdString
445  * Signature: ()Ljava/lang/String;
446  */
447 JNIEXPORT jstring JNICALL Java_sun_java2d_metal_MTLContext_getMTLIdString
448   (JNIEnv *env, jclass mtlcc)
</pre>
</td>
</tr>
</table>
<center><a href="MTLContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;stdlib.h&gt;
 29 #include &lt;limits.h&gt;
 30 #include &lt;math.h&gt;
 31 #include &lt;jlong.h&gt;
 32 
 33 #include &quot;sun_java2d_metal_MTLTextRenderer.h&quot;
 34 
 35 #include &quot;SurfaceData.h&quot;
 36 #include &quot;MTLContext.h&quot;
 37 #include &quot;MTLRenderQueue.h&quot;
 38 #include &quot;MTLTextRenderer.h&quot;
 39 #include &quot;MTLVertexCache.h&quot;
 40 #include &quot;MTLGlyphCache.h&quot;
 41 #include &quot;MTLBlitLoops.h&quot;
 42 
 43 /**
 44  * The following constants define the inner and outer bounds of the
 45  * accelerated glyph cache.
 46  */
 47 #define MTLTR_CACHE_WIDTH       512
 48 #define MTLTR_CACHE_HEIGHT      512
 49 #define MTLTR_CACHE_CELL_WIDTH  32
 50 #define MTLTR_CACHE_CELL_HEIGHT 32
 51 
 52 /**
 53  * The current &quot;glyph mode&quot; state.  This variable is used to track the
 54  * codepath used to render a particular glyph.  This variable is reset to
 55  * MODE_NOT_INITED at the beginning of every call to MTLTR_DrawGlyphList().
 56  * As each glyph is rendered, the glyphMode variable is updated to reflect
 57  * the current mode, so if the current mode is the same as the mode used
 58  * to render the previous glyph, we can avoid doing costly setup operations
 59  * each time.
 60  */
 61 typedef enum {
 62     MODE_NOT_INITED,
 63     MODE_USE_CACHE_GRAY,
 64     MODE_USE_CACHE_LCD,
 65     MODE_NO_CACHE_GRAY,
 66     MODE_NO_CACHE_LCD,
 67     MODE_NO_CACHE_COLOR
 68 } GlyphMode;
 69 static GlyphMode glyphMode = MODE_NOT_INITED;
 70 
 71 /**
 72  * There are two separate glyph caches: for AA and for LCD.
 73  * Once one of them is initialized as either GRAY or LCD, it
 74  * stays in that mode for the duration of the application.  It should
 75  * be safe to use this one glyph cache for all screens in a multimon
 76  * environment, since the glyph cache texture is shared between all contexts,
 77  * and (in theory) OpenGL drivers should be smart enough to manage that
 78  * texture across all screens.
 79  */
 80 
 81 static MTLGlyphCacheInfo *glyphCacheLCD = NULL;
 82 static MTLGlyphCacheInfo *glyphCacheAA = NULL;
 83 
 84 /**
 85  * The handle to the LCD text fragment program object.
 86  */
 87 static GLhandleARB lcdTextProgram = 0;
 88 
 89 /**
 90  * This value tracks the previous LCD contrast setting, so if the contrast
 91  * value hasn&#39;t changed since the last time the gamma uniforms were
 92  * updated (not very common), then we can skip updating the unforms.
 93  */
 94 static jint lastLCDContrast = -1;
 95 
 96 /**
 97  * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder
 98  * value has changed since the last time, it indicates that we need to
 99  * invalidate the cache, which may already store glyph images in the reverse
100  * order.  Note that in most real world applications this value will not
101  * change over the course of the application, but tests like Font2DTest
102  * allow for changing the ordering at runtime, so we need to handle that case.
103  */
104 static jboolean lastRGBOrder = JNI_TRUE;
105 
106 /**
107  * This constant defines the size of the tile to use in the
108  * MTLTR_DrawLCDGlyphNoCache() method.  See below for more on why we
109  * restrict this value to a particular size.
110  */
111 #define MTLTR_NOCACHE_TILE_SIZE 32
112 
113 /**
114  * These constants define the size of the &quot;cached destination&quot; texture.
115  * This texture is only used when rendering LCD-optimized text, as that
116  * codepath needs direct access to the destination.  There is no way to
117  * access the framebuffer directly from an OpenGL shader, so we need to first
118  * copy the destination region corresponding to a particular glyph into
119  * this cached texture, and then that texture will be accessed inside the
120  * shader.  Copying the destination into this cached texture can be a very
121  * expensive operation (accounting for about half the rendering time for
122  * LCD text), so to mitigate this cost we try to bulk read a horizontal
123  * region of the destination at a time.  (These values are empirically
124  * derived for the common case where text runs horizontally.)
125  *
126  * Note: It is assumed in various calculations below that:
127  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_CACHE_CELL_WIDTH)  &amp;&amp;
128  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_NOCACHE_TILE_SIZE) &amp;&amp;
129  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_CACHE_CELL_HEIGHT) &amp;&amp;
130  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_NOCACHE_TILE_SIZE)
131  */
132 #define MTLTR_CACHED_DEST_WIDTH  512
133 #define MTLTR_CACHED_DEST_HEIGHT (MTLTR_CACHE_CELL_HEIGHT * 2)
134 
135 /**
136  * The handle to the &quot;cached destination&quot; texture object.
137  */
138 static GLuint cachedDestTextureID = 0;
139 
140 /**
141  * The current bounds of the &quot;cached destination&quot; texture, in destination
142  * coordinate space.  The width/height of these bounds will not exceed the
143  * MTLTR_CACHED_DEST_WIDTH/HEIGHT values defined above.  These bounds are
144  * only considered valid when the isCachedDestValid flag is JNI_TRUE.
145  */
146 static SurfaceDataBounds cachedDestBounds;
147 
148 /**
149  * This flag indicates whether the &quot;cached destination&quot; texture contains
150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
153  * limit the number of times we need to copy destination data, which is a
154  * very costly operation.
155  */
156 static jboolean isCachedDestValid = JNI_FALSE;
157 
158 /**
159  * The bounds of the previously rendered LCD glyph, in destination
160  * coordinate space.  We use these bounds to determine whether the glyph
161  * currently being rendered overlaps the previously rendered glyph (i.e.
162  * its bounding box intersects that of the previously rendered glyph).  If
163  * so, we need to re-read the destination area associated with that previous
164  * glyph so that we can correctly blend with the actual destination data.
165  */
166 static SurfaceDataBounds previousGlyphBounds;
167 
168 static struct TxtVertex txtVertices[6];
169 static jint vertexCacheIndex = 0;
170 
171 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
172     do { \
173         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
174         v-&gt;txtpos[0] = TX; \
175         v-&gt;txtpos[1] = TY; \
176         v-&gt;position[0]= DX; \
177         v-&gt;position[1] = DY; \
178     } while (0)
179 
180 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
181     do { \
182         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
183         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
184         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
186         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
187         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
188     } while (0)
189 
190 /**
191  * Initializes the one glyph cache (texture and data structure).
192  * If lcdCache is JNI_TRUE, the texture will contain RGB data,
193  * otherwise we will simply store the grayscale/monochrome glyph images
194  * as intensity values (which work well with the GL_MODULATE function).
195  */
196 static jboolean
197 MTLTR_InitGlyphCache(MTLContext *mtlc, jboolean lcdCache)
198 {
199     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_InitGlyphCache&quot;);
200     MTLPixelFormat pixelFormat =
201         lcdCache ? MTLPixelFormatRGBA8Unorm : MTLPixelFormatA8Unorm;
202 
203     MTLGlyphCacheInfo *gcinfo;
204     // init glyph cache data structure
205     gcinfo = MTLGlyphCache_Init(MTLTR_CACHE_WIDTH,
206                                 MTLTR_CACHE_HEIGHT,
207                                 MTLTR_CACHE_CELL_WIDTH,
208                                 MTLTR_CACHE_CELL_HEIGHT,
209                                 MTLVertexCache_FlushGlyphVertexCache);
210 
211     if (gcinfo == NULL) {
212         J2dRlsTraceLn(J2D_TRACE_ERROR,
213                       &quot;MTLTR_InitGlyphCache: could not init MTL glyph cache&quot;);
214         return JNI_FALSE;
215     }
216 
217     MTLTextureDescriptor *textureDescriptor =
218         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat
219                                                             width:MTLTR_CACHE_WIDTH
220                                                             height:MTLTR_CACHE_HEIGHT
221                                                             mipmapped:NO];
222 
223     gcinfo-&gt;texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
224     [textureDescriptor release];
225 
226     if (lcdCache) {
227         glyphCacheLCD = gcinfo;
228     } else {
229         glyphCacheAA = gcinfo;
230     }
231 
232     return JNI_TRUE;
233 }
234 
235 id&lt;MTLTexture&gt;
236 MTLTR_GetGlyphCacheTexture()
237 {
238     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
239     if (glyphCacheAA != NULL) {
240         return glyphCacheAA-&gt;texture;
241     }
242     return NULL;
243 }
244 
245 /**
246  * Adds the given glyph to the glyph cache (texture and data structure)
247  * associated with the given MTLContext.
248  */
249 static void
250 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
251                       MTLPixelFormat pixelFormat)
252 {
253     MTLCacheCellInfo *ccinfo;
254     MTLGlyphCacheInfo *gcinfo;
255 
256     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
257     if (pixelFormat == MTLPixelFormatA8Unorm) {
258         gcinfo = glyphCacheAA;
259     } else {
260         gcinfo = glyphCacheLCD;
261     }
262 
263     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
264         return;
265     }
266 
267     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
268     if (isCacheFull) {
269         MTLGlyphCache_Free(gcinfo);
270         if (pixelFormat == MTLPixelFormatA8Unorm) {
271             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
272         } else {
273             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
274         }
275         gcinfo = glyphCacheAA;
276     }
277     MTLGlyphCache_AddGlyph(gcinfo, glyph);
278     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
279 
280     if (ccinfo != NULL) {
281         // store glyph image in texture cell
282         MTLRegion region = {
283                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
284                 {glyph-&gt;width, glyph-&gt;height, 1}
285         };
286         NSUInteger bytesPerRow = 1 * glyph-&gt;width;
287         [gcinfo-&gt;texture replaceRegion:region
288                          mipmapLevel:0
289                          withBytes:glyph-&gt;image
290                          bytesPerRow:bytesPerRow];
291     }
292 }
293 
294 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
295 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
296 
297 /**
298  * Enables the LCD text shader and updates any related state, such as the
299  * gamma lookup table textures.
300  */
301 static jboolean
302 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
303                               MTLContext *mtlc, 
304                               MTLSDOps *dstOps,
305                               jint contrast)
306 {
307     // create the LCD text shader, if necessary
308     if (templateLCDPipelineDesc == nil) {
309 
310         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
311         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
312         vertDesc.attributes[VertexAttributePosition].offset = 0;
313         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
314         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
315         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
316         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
317 
318         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
319         templateLCDPipelineDesc.sampleCount = 1;
320         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
321         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
322         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
323         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
324         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
325         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
326         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
327         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
328         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
329     }
330 
331     id&lt;MTLRenderPipelineState&gt; pipelineState =
332                 [mtlc.pipelineStateStorage
333                     getPipelineState:templateLCDPipelineDesc
334                     vertexShaderId:@&quot;vert_txt&quot;
335                     fragmentShaderId:@&quot;lcd_color&quot;
336                    ];
337 
338     [encoder setRenderPipelineState:pipelineState];
339 
<a name="1" id="anc1"></a><span class="line-removed">340     double g = 0;</span>
<span class="line-removed">341     double ig = 0;</span>
<span class="line-removed">342 </span>
<span class="line-removed">343     // update the current contrast setting, if necessary</span>
<span class="line-removed">344     if (lastLCDContrast != contrast) {</span>
<span class="line-removed">345         g = ((double)contrast) / 100.0;</span>
<span class="line-removed">346         ig = 1.0 / g;</span>
<span class="line-removed">347         lastLCDContrast = contrast;</span>
<span class="line-removed">348     }</span>
<span class="line-removed">349 </span>
350     // update the current color settings
351     double gamma = ((double)contrast) / 100.0;
<a name="2" id="anc2"></a>
352     jfloat radj, gadj, badj;
353     jfloat clr[4];
354     jint col = [mtlc.paint getColor];
355 
<a name="3" id="anc3"></a><span class="line-modified">356     J2dTraceLn1(J2D_TRACE_INFO, &quot;primary color %x&quot;, col);</span>

357 
358     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
359     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
360     clr[2] = ((col) &amp; 0xFF)/255.0f;
361 
362     // gamma adjust the primary color
363     radj = (float)pow(clr[0], gamma);
364     gadj = (float)pow(clr[1], gamma);
365     badj = (float)pow(clr[2], gamma);
366 
367     struct LCDFrameUniforms uf = {
368             {radj, gadj, badj},
<a name="4" id="anc4"></a><span class="line-modified">369             {g, g, g},</span>
<span class="line-modified">370             {ig, ig, ig}};</span>
371     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
372 
373     return JNI_TRUE;
374 }
375 
376 void
377 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
378 {
379 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
380 
381     if (!MTLVertexCache_InitVertexCache()) {
382         return;
383     }
384 
385     if (glyphCacheAA == NULL) {
386         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
387             return;
388         }
389     }
390     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
391 }
392 
393 void
394 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
395 {
396     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DisableGlyphVertexCache&quot;);
397     MTLVertexCache_FlushGlyphVertexCache();
398     MTLVertexCache_RestoreColorState(mtlc);
399     MTLVertexCache_FreeVertexCache();
400 }
401 
402 /**
403  * Disables any pending state associated with the current &quot;glyph mode&quot;.
404  */
405 void
406 MTLTR_DisableGlyphModeState()
407 {
408     // TODO : This is similar to OpenGL implementation
409     // When LCD implementation is done weshould make
410     // more changes.
411     J2dTraceLn1(J2D_TRACE_VERBOSE,
412                 &quot;MTLTR_DisableGlyphModeState: mode=%d&quot;, glyphMode);
413     switch (glyphMode) {
414     case MODE_NO_CACHE_LCD:
415         // TODO : Along with LCD implementation
416         // changes needs to be made
417     case MODE_USE_CACHE_LCD:
418         // TODO : Along with LCD implementation
419         // changes needs to be made
420         break;
421     case MODE_NO_CACHE_GRAY:
422     case MODE_USE_CACHE_GRAY:
423     case MODE_NOT_INITED:
424     default:
425         break;
426     }
427 }
428 
429 static jboolean
430 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
431                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
432 {
433     MTLCacheCellInfo *cell;
434     jfloat x1, y1, x2, y2;
435 
436     if (glyphMode != MODE_USE_CACHE_GRAY) {
437         if (glyphMode == MODE_NO_CACHE_GRAY) {
438             MTLVertexCache_DisableMaskCache(mtlc);
439         }
440         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
441         glyphMode = MODE_USE_CACHE_GRAY;
442     }
443 
444     if (ginfo-&gt;cellInfo == NULL) {
445         // attempt to add glyph to accelerated glyph cache
446         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatA8Unorm);
447 
448         if (ginfo-&gt;cellInfo == NULL) {
449             // we&#39;ll just no-op in the rare case that the cell is NULL
450             return JNI_TRUE;
451         }
452     }
453 
454     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
455     cell-&gt;timesRendered++;
456 
457     x1 = (jfloat)x;
458     y1 = (jfloat)y;
459     x2 = x1 + ginfo-&gt;width;
460     y2 = y1 + ginfo-&gt;height;
461 
462     MTLVertexCache_AddGlyphQuad(mtlc,
463                                 cell-&gt;tx1, cell-&gt;ty1,
464                                 cell-&gt;tx2, cell-&gt;ty2,
465                                 x1, y1, x2, y2);
466 
467     return JNI_TRUE;
468 }
469 
470 /**
471  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 is
472  * inside outerBounds.
473  */
474 #define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \
475     (((gx1) &gt;= outerBounds.x1) &amp;&amp; ((gy1) &gt;= outerBounds.y1) &amp;&amp; \
476      ((gx2) &lt;= outerBounds.x2) &amp;&amp; ((gy2) &lt;= outerBounds.y2))
477 
478 /**
479  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 intersects
480  * the rectangle defined by bounds.
481  */
482 #define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \
483     ((bounds.x2 &gt; (gx1)) &amp;&amp; (bounds.y2 &gt; (gy1)) &amp;&amp; \
484      (bounds.x1 &lt; (gx2)) &amp;&amp; (bounds.y1 &lt; (gy2)))
485 
486 /**
487  * This method checks to see if the given LCD glyph bounds fall within the
488  * cached destination texture bounds.  If so, this method can return
489  * immediately.  If not, this method will copy a chunk of framebuffer data
490  * into the cached destination texture and then update the current cached
491  * destination bounds before returning.
492  */
493 static void
494 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
495                               jint gx1, jint gy1, jint gx2, jint gy2,
496                               jint glyphIndex, jint totalGlyphs)
497 {
498     //TODO
499 }
500 
501 static jboolean
502 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
503                            GlyphInfo *ginfo, jint x, jint y,
504                            jint glyphIndex, jint totalGlyphs,
505                            jboolean rgbOrder, jint contrast,
506                            id&lt;MTLTexture&gt; dstTexture)
507 {
508     CacheCellInfo *cell;
509     jfloat tx1, ty1, tx2, ty2;
510     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
511     jint tw, th;
512     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
513     jint x0;
514     jint w = ginfo-&gt;width;
515     jint h = ginfo-&gt;height;
516     id&lt;MTLTexture&gt; blitTexture = nil;
517 
518     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
519 
520     MTLTextureDescriptor *textureDescriptor =
521         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
522                                                             width:w
523                                                             height:h
524                                                             mipmapped:NO];
525 
526     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
527     [textureDescriptor release];
528 
529     if (glyphMode != MODE_USE_CACHE_LCD) {
530         if (glyphMode == MODE_NO_CACHE_GRAY) {
531             MTLVertexCache_DisableMaskCache(mtlc);
532         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
533             MTLTR_DisableGlyphVertexCache(mtlc);
534         }
535 
536         if (glyphCacheLCD == NULL) {
537             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
538                 return JNI_FALSE;
539             }
540         }
541 
542         if (rgbOrder != lastRGBOrder) {
543             // need to invalidate the cache in this case; see comments
544             // for lastRGBOrder above
545             MTLGlyphCache_Invalidate(glyphCacheLCD);
546             lastRGBOrder = rgbOrder;
547         }
548 
549         glyphMode = MODE_USE_CACHE_LCD;
550     }
551 
552     if (ginfo-&gt;cellInfo == NULL) {
553         // attempt to add glyph to accelerated glyph cache
554         // TODO : Handle RGB order
555         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
556 
557         if (ginfo-&gt;cellInfo == NULL) {
558             // we&#39;ll just no-op in the rare case that the cell is NULL
559             return JNI_TRUE;
560         }
561     }
562     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
563     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
564     {
565         return JNI_FALSE;
566     }
567 
568 
569     unsigned int imageBytes = w * h *4;
570     unsigned char imageData[imageBytes];
571     memset(&amp;imageData, 0, sizeof(imageData));
572 
573     for (int i = 0; i &lt; h; i++) {
574         for (int j = 0; j &lt; w; j++) {
575             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
576             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
577             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
578             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
579         }
580     }
581 
582     // copy LCD mask into glyph texture tile
583     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
584 
585     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
586     [blitTexture replaceRegion:region
587                  mipmapLevel:0
588                  withBytes:imageData
589                  bytesPerRow:bytesPerRow];
590 
591     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
592 
593     x0 = x;
594     tx1 = 0.0f;
595     ty1 = 0.0f;
596     dtx1 = 0.0f;
597     dty2 = 0.0f;
598     tw = MTLTR_NOCACHE_TILE_SIZE;
599     th = MTLTR_NOCACHE_TILE_SIZE;
600 
601     // update the lower-right glyph texture coordinates
602     tx2 = 1.0f;
603     ty2 = 1.0f;
604 
605     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
606 
607     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
608     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
609   
610     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
611     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
612 
613     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
614     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
615     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
616 
617     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
618 
619     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
620     [encoder setFragmentTexture:blitTexture atIndex:0];
621     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
622 
623     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
624 
625     vertexCacheIndex = 0;
626     [mtlc.encoderManager endEncoder];
627 
628     [blitTexture release];
629 
630     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
631 
632     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
633     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
634         [cbwrapper release];
635     }];
636 
637     [commandbuf commit];
638     [commandbuf waitUntilCompleted];
639 
640     // TODO : Updating cache bounds and texture mapping.
641     return JNI_TRUE;
642 }
643 
644 static jboolean
645 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
646                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
647 {
648     jint tw, th;
649     jint sx, sy, sw, sh;
650     jint x0;
651     jint w = ginfo-&gt;width;
652     jint h = ginfo-&gt;height;
653 
654     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
655     if (glyphMode != MODE_NO_CACHE_GRAY) {
656         if (glyphMode == MODE_USE_CACHE_GRAY) {
657             MTLTR_DisableGlyphVertexCache(mtlc);
658         }
659         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
660         glyphMode = MODE_NO_CACHE_GRAY;
661     }
662 
663     x0 = x;
664     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
665     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
666 
667     for (sy = 0; sy &lt; h; sy += th, y += th) {
668         x = x0;
669         sh = ((sy + th) &gt; h) ? (h - sy) : th;
670 
671         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
672             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
673 
674             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
675             MTLVertexCache_AddMaskQuad(mtlc,
676                                        sx, sy, x, y, sw, sh,
677                                        w, ginfo-&gt;image,
678                                        dstOps,
679                                        ginfo-&gt;width);
680         }
681     }
682 
683     return JNI_TRUE;
684 }
685 
686 
687 static jboolean
688 MTLTR_DrawLCDGlyphNoCache(MTLContext *mtlc, BMTLSDOps *dstOps,
689                           GlyphInfo *ginfo, jint x, jint y,
690                           jint rowBytesOffset,
691                           jboolean rgbOrder, jint contrast,
692                           id&lt;MTLTexture&gt; dstTexture)
693 {
694     jfloat tx1, ty1, tx2, ty2;
695     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
696     jint tw, th;
697     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
698     jint x0;
699     jint w = ginfo-&gt;width;
700     jint h = ginfo-&gt;height;
701     id&lt;MTLTexture&gt; blitTexture = nil;
702 
703     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
704     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
705 
706 
707     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
708 
709     MTLTextureDescriptor *textureDescriptor =
710         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
711                                                             width:w
712                                                             height:h
713                                                             mipmapped:NO];
714 
715     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
716     [textureDescriptor release];
717 
718     if (glyphMode != MODE_NO_CACHE_LCD) {
719         if (glyphMode == MODE_NO_CACHE_GRAY) {
720             MTLVertexCache_DisableMaskCache(mtlc);
721         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
722             MTLTR_DisableGlyphVertexCache(mtlc);
723         }
724 
725         if (blitTexture == nil) {
726             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
727             return JNI_FALSE;
728         }
729 
730 
731         glyphMode = MODE_NO_CACHE_LCD;
732     }
733     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
734     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
735     {
736         return JNI_FALSE;
737     }
738 
739     x0 = x;
740     tx1 = 0.0f;
741     ty1 = 0.0f;
742     dtx1 = 0.0f;
743     dty2 = 0.0f;
744     tw = MTLTR_NOCACHE_TILE_SIZE;
745     th = MTLTR_NOCACHE_TILE_SIZE;
746 
747     unsigned int imageBytes = w * h *4;
748     unsigned char imageData[imageBytes];
749     memset(&amp;imageData, 0, sizeof(imageData));
750 
751     for (int i = 0; i &lt; h; i++) {
752         for (int j = 0; j &lt; w; j++) {
753             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
754             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
755             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
756             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
757         }
758     }
759 
760     // copy LCD mask into glyph texture tile
761     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
762 
763     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
764     [blitTexture replaceRegion:region
765                  mipmapLevel:0
766                  withBytes:imageData
767                  bytesPerRow:bytesPerRow];
768 
769     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
770 
771 
772     // update the lower-right glyph texture coordinates
773     tx2 = 1.0f;
774     ty2 = 1.0f;
775 
776     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
777 
778     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
779     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
780   
781     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
782     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
783 
784     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
785     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
786     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
787 
788     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
789 
790     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
791     [encoder setFragmentTexture:blitTexture atIndex:0];
792     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
793 
794     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
795 
796     vertexCacheIndex = 0;
797     [mtlc.encoderManager endEncoder];
798     [blitTexture release];
799 
800     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
801 
802     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
803     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
804         [cbwrapper release];
805     }];
806 
807     [commandbuf commit];
808     [commandbuf waitUntilCompleted];
809 
810     return JNI_TRUE;
811 }
812 
813 static jboolean
814 MTLTR_DrawColorGlyphNoCache(MTLContext *mtlc, GlyphInfo *ginfo, jint x, jint y)
815 {
816     //TODO
817     return JNI_TRUE;
818 }
819 
820 
821 // see DrawGlyphList.c for more on this macro...
822 #define FLOOR_ASSIGN(l, r) \
823     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
824 
825 void
826 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
827                     jint totalGlyphs, jboolean usePositions,
828                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
829                     jfloat glyphListOrigX, jfloat glyphListOrigY,
830                     unsigned char *images, unsigned char *positions)
831 {
832     int glyphCounter;
833 
834     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
835 
836     RETURN_IF_NULL(mtlc);
837     RETURN_IF_NULL(dstOps);
838     RETURN_IF_NULL(images);
839     if (usePositions) {
840         RETURN_IF_NULL(positions);
841     }
842 
843     glyphMode = MODE_NOT_INITED;
844     isCachedDestValid = JNI_FALSE;
845     J2dTraceLn1(J2D_TRACE_INFO, &quot;totalGlyphs = %d&quot;, totalGlyphs);
846 
847     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
848         J2dTraceLn(J2D_TRACE_INFO, &quot;Entered for loop for glyph list&quot;);
849         jint x, y;
850         jfloat glyphx, glyphy;
851         jboolean grayscale, ok;
852         GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));
853 
854         if (ginfo == NULL) {
855             // this shouldn&#39;t happen, but if it does we&#39;ll just break out...
856             J2dRlsTraceLn(J2D_TRACE_ERROR,
857                           &quot;MTLTR_DrawGlyphList: glyph info is null&quot;);
858             break;
859         }
860 
861         grayscale = (ginfo-&gt;rowBytes == ginfo-&gt;width);
862 
863         if (usePositions) {
864             jfloat posx = NEXT_FLOAT(positions);
865             jfloat posy = NEXT_FLOAT(positions);
866             glyphx = glyphListOrigX + posx + ginfo-&gt;topLeftX;
867             glyphy = glyphListOrigY + posy + ginfo-&gt;topLeftY;
868             FLOOR_ASSIGN(x, glyphx);
869             FLOOR_ASSIGN(y, glyphy);
870         } else {
871             glyphx = glyphListOrigX + ginfo-&gt;topLeftX;
872             glyphy = glyphListOrigY + ginfo-&gt;topLeftY;
873             FLOOR_ASSIGN(x, glyphx);
874             FLOOR_ASSIGN(y, glyphy);
875             glyphListOrigX += ginfo-&gt;advanceX;
876             glyphListOrigY += ginfo-&gt;advanceY;
877         }
878 
879         if (ginfo-&gt;image == NULL) {
880             J2dTraceLn(J2D_TRACE_INFO, &quot;Glyph image is null&quot;);
881             continue;
882         }
883 
884         J2dTraceLn2(J2D_TRACE_INFO, &quot;Glyph width = %d height = %d&quot;, ginfo-&gt;width, ginfo-&gt;height);
885         J2dTraceLn1(J2D_TRACE_INFO, &quot;rowBytes = %d&quot;, ginfo-&gt;rowBytes);
886         //TODO : Right now we have initial texture mapping logic
887         // as we implement LCD, cache usage add new selection condition.
888         if (grayscale) {
889             // grayscale or monochrome glyph data
890             if (ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
891                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
892             {
893                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale cache&quot;);
894                 ok = MTLTR_DrawGrayscaleGlyphViaCache(mtlc, ginfo, x, y, dstOps);
895             } else {
896                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale no cache&quot;);
897                 ok = MTLTR_DrawGrayscaleGlyphNoCache(mtlc, ginfo, x, y, dstOps);
898             }
899         } else {
900             void* dstTexture = dstOps-&gt;textureLCD;
901 
902             // LCD-optimized glyph data
903             jint rowBytesOffset = 0;
904 
905             if (subPixPos) {
906                 jint frac = (jint)((glyphx - x) * 3);
907                 if (frac != 0) {
908                     rowBytesOffset = 3 - frac;
909                     x += 1;
910                 }
911             }
912 
913             // TODO: Implement LCD text rendering
914             if (rowBytesOffset == 0 &amp;&amp;
915                 ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
916                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
917             {
918                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD cache -- :TODO&quot;);
919                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
920                                                 ginfo, x, y,
921                                                 glyphCounter, totalGlyphs,
922                                                 rgbOrder, lcdContrast,
923                                                 dstTexture);
924             } else {
925                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
926                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
927                                                ginfo, x, y,
928                                                rowBytesOffset,
929                                                rgbOrder, lcdContrast,
930                                                dstTexture);
931             }
932         }
933 
934         if (!ok) {
935             break;
936         }
937     }
938     /*
939      * This state management needs to be extended for other glyphmodes
940      * when they are implemented.
941      */
942     if (glyphMode != MODE_NO_CACHE_LCD) {
943         if (glyphMode == MODE_NO_CACHE_GRAY) {
944             MTLVertexCache_DisableMaskCache(mtlc);
945         } else {
946             MTLTR_DisableGlyphVertexCache(mtlc);
947         }
948     }
949 }
950 
951 JNIEXPORT void JNICALL
952 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
953     (JNIEnv *env, jobject self,
954      jint numGlyphs, jboolean usePositions,
955      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
956      jfloat glyphListOrigX, jfloat glyphListOrigY,
957      jlongArray imgArray, jfloatArray posArray)
958 {
959     unsigned char *images;
960 
961     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
962 
963     images = (unsigned char *)
964         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
965     if (images != NULL) {
966         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
967         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
968 
969         if (usePositions) {
970             unsigned char *positions = (unsigned char *)
971                 (*env)-&gt;GetPrimitiveArrayCritical(env, posArray, NULL);
972             if (positions != NULL) {
973                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
974                                     numGlyphs, usePositions,
975                                     subPixPos, rgbOrder, lcdContrast,
976                                     glyphListOrigX, glyphListOrigY,
977                                     images, positions);
978                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, posArray,
979                                                       positions, JNI_ABORT);
980             }
981         } else {
982             MTLTR_DrawGlyphList(env, mtlc, dstOps,
983                                 numGlyphs, usePositions,
984                                 subPixPos, rgbOrder, lcdContrast,
985                                 glyphListOrigX, glyphListOrigY,
986                                 images, NULL);
987         }
988 
989         (*env)-&gt;ReleasePrimitiveArrayCritical(env, imgArray,
990                                               images, JNI_ABORT);
991     }
992 }
993 
994 #endif /* !HEADLESS */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 #import &quot;MTLComposite.h&quot;
 37 
 38 #define RGBA_TO_V4(c)              \
 39 {                                  \
 40     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 41     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 42     ((c) &amp; 0xFF)/255.0f,           \
 43     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 44 }
 45 
 46 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 47 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 48 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 49 
 50 static void initTemplatePipelineDescriptors() {
 51     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 52         return;
 53 
 54     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 55     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 56     vertDesc.attributes[VertexAttributePosition].offset = 0;
 57     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 58     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 59     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 60     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 61 
 62     templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 63     templateRenderPipelineDesc.sampleCount = 1;
 64     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 65     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 66     templateRenderPipelineDesc.label = @&quot;template_render&quot;;
 67 
 68     templateTexturePipelineDesc = [[templateRenderPipelineDesc copy] autorelease];
 69     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 70     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 71     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 72     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 73     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 74     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 75     templateTexturePipelineDesc.label = @&quot;template_texture&quot;;
 76 
 77     templateAATexturePipelineDesc = [[templateTexturePipelineDesc copy] autorelease];
 78     templateAATexturePipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;
 79     templateAATexturePipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
 80     templateAATexturePipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 81     templateAATexturePipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 82     templateAATexturePipelineDesc.label = @&quot;template_aa_texture&quot;;
 83 
 84 }
 85 
 86 @implementation MTLPaint {
 87     // TODO: remove paintState, split into heirarchy of Paint-objects (i.e. PaintColor, PaintGrad, e.t.c)
 88     jint          _paintState;
 89 
 90     // color-mode
 91     jint          _color;
 92 
 93     // lin-grad-mode
 94     jdouble       _p0;
 95     jdouble       _p1;
 96     jdouble       _p3;
 97     jboolean      _cyclic;
 98     jint          _pixel1;
 99     jint          _pixel2;
100     jboolean      _useMask;
101 
102     // texture paint
103     id&lt;MTLTexture&gt; _paintTexture;
104     struct AnchorData _anchor;
105 }
106 
107 - (id)init {
108     self = [super init];
109     if (self) {
110         _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
111     }
112     return self;
113 }
114 
115 - (BOOL)isEqual:(MTLPaint *)other {
116     if (self == other)
117         return YES;
118     if (_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
119         return _paintState == other-&gt;_paintState;
120     if (_paintState != other-&gt;_paintState)
121         return NO;
122     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
123         return _p0 == other-&gt;_p0
124                &amp;&amp; _p1 == other-&gt;_p1
125                &amp;&amp; _p3 == other-&gt;_p3
126                &amp;&amp; _pixel1 == other-&gt;_pixel1
127                &amp;&amp; _pixel2 == other-&gt;_pixel2;
128     }
129     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
130         return _color == other-&gt;_color;
131     }
132     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
133         return _paintTexture == other-&gt;_paintTexture
134                &amp;&amp; _anchor.xParams[0] == other-&gt;_anchor.xParams[0]
135                &amp;&amp; _anchor.xParams[1] == other-&gt;_anchor.xParams[1]
136                &amp;&amp; _anchor.xParams[2] == other-&gt;_anchor.xParams[2]
137                &amp;&amp; _anchor.yParams[0] == other-&gt;_anchor.yParams[0]
138                &amp;&amp; _anchor.yParams[1] == other-&gt;_anchor.yParams[1]
139                &amp;&amp; _anchor.yParams[2] == other-&gt;_anchor.yParams[2];
140     }
141 
142     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unimplemented paint mode %d&quot;, _paintState);
143     return NO;
144 }
145 
146 - (void)copyFrom:(MTLPaint *)other {
147     _paintState = other-&gt;_paintState;
148     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
149         return;
150 
151     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
152         _p0 = other-&gt;_p0;
153         _p1 = other-&gt;_p1;
154         _p3 = other-&gt;_p3;
155         _pixel1 = other-&gt;_pixel1;
156         _pixel2 = other-&gt;_pixel2;
157         return;
158     }
159     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
160         _color = other-&gt;_color;
161         return;
162     }
163 
164     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
165         _color = other-&gt;_color;
166         _paintTexture = other-&gt;_paintTexture;
167         _anchor = other-&gt;_anchor;
168         return;
169     }
170 
171     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unsupported paint mode %d&quot;, _paintState);
172 }
173 
174 - (NSString *)getDescription {
175     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
176         return [NSString stringWithFormat:@&quot;[r=%d g=%d b=%d a=%d]&quot;, (_color &gt;&gt; 16) &amp; (0xFF), (_color &gt;&gt; 8) &amp; 0xFF, (_color) &amp; 0xFF, (_color &gt;&gt; 24) &amp; 0xFF];
177     }
178     
179     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
180         return [NSString stringWithFormat:@&quot;gradient&quot;];
181     }
182 
183     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
184         return [NSString stringWithFormat:@&quot;texture_paint&quot;];
185     }
186 
187     return @&quot;unknown-paint&quot;;
188 }
189 
190 - (jint)getColor {
191     return _color;
192 }
193 
194 - (void)reset {
195     _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
196     _paintTexture = nil;
197     _anchor.xParams[0] = _anchor.xParams[1] = _anchor.xParams[2] = 0.0f;
198     _anchor.yParams[0] = _anchor.yParams[1] = _anchor.yParams[2] = 0.0f; 
199 }
200 
201 - (void)setColor:(jint)pixelColor {
202     _paintState = sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR;
203     _color = pixelColor;
204 }
205 
206 - (void)setGradientUseMask:(jboolean)useMask
207                     cyclic:(jboolean)cyclic
208                         p0:(jdouble)p0
209                         p1:(jdouble)p1
210                         p3:(jdouble)p3
211                     pixel1:(jint)pixel1
212                     pixel2:(jint)pixel2
213 {
214     //TODO Resolve gradient distribution problem
215     //TODO Implement useMask
216     //TODO Implement cyclic
217     //fprintf(stderr,
218     //        &quot;MTLPaints_SetGradientPaint useMask=%d cyclic=%d &quot;
219     //        &quot;p0=%f p1=%f p3=%f pix1=%d pix2=%d\n&quot;, useMask, cyclic,
220     //        p0, p1, p3, pixel1, pixel2);
221 
222     _paintState = sun_java2d_SunGraphics2D_PAINT_GRADIENT;
223     _useMask = useMask;
224     _pixel1 = pixel1;
225     _pixel2 = pixel2;
226     _p0 = p0;
227     _p1 = p1;
228     _p3 = p3;
229     _cyclic = cyclic;
230 }
231 
232 - (void)setLinearGradient:(jboolean)useMask
233                    linear:(jboolean)linear
234               cycleMethod:(jboolean)cycleMethod
235                  numStops:(jint)numStops
236                        p0:(jfloat)p0
237                        p1:(jfloat)p1
238                        p3:(jfloat)p3
239                 fractions:(void *)fractions
240                    pixels:(void *)pixels
241 {
242     J2dTraceLn(J2D_TRACE_ERROR, &quot;setLinearGradient: UNIMPLEMENTED&quot;);
243     [self setColor:0];
244 }
245 
246 - (void)setRadialGradient:(jboolean)useMask
247                    linear:(jboolean)linear
248               cycleMethod:(jboolean)cycleMethod
249                  numStops:(jint)numStops
250                       m00:(jfloat)m00
251                       m01:(jfloat)m01
252                       m02:(jfloat)m02
253                       m10:(jfloat)m10
254                       m11:(jfloat)m11
255                       m12:(jfloat)m12
256                    focusX:(jfloat)focusX
257                 fractions:(void *)fractions
258                    pixels:(void *)pixels
259 {
260     J2dTraceLn(J2D_TRACE_ERROR, &quot;setRadialGradient: UNIMPLEMENTED&quot;);
261     [self setColor:0];
262 }
263 
264 - (void)setTexture:(jboolean)useMask
265            textureID:(id&lt;MTLTexture&gt;)textureID
266             filter:(jboolean)filter
267                xp0:(jdouble)xp0
268                xp1:(jdouble)xp1
269                xp3:(jdouble)xp3
270                yp0:(jdouble)yp0
271                yp1:(jdouble)yp1
272                yp3:(jdouble)yp3
273 {
274     _paintState = sun_java2d_SunGraphics2D_PAINT_TEXTURE;
275     _paintTexture = textureID;
276     
277     _anchor.xParams[0] = xp0;
278     _anchor.xParams[1] = xp1;
279     _anchor.xParams[2] = xp3;
280 
281     _anchor.yParams[0] = yp0;
282     _anchor.yParams[1] = yp1;
283     _anchor.yParams[2] = yp3;
284 }
285 
286 static id&lt;MTLSamplerState&gt; samplerNearestClamp = nil;
287 static id&lt;MTLSamplerState&gt; samplerLinearClamp = nil;
288 static id&lt;MTLSamplerState&gt; samplerNearestRepeat = nil;
289 static id&lt;MTLSamplerState&gt; samplerLinearRepeat = nil;
290 
291 void initSamplers(id&lt;MTLDevice&gt; device) {
292     // TODO: move this code into SamplerManager (need implement)
293 
294     if (samplerNearestClamp != nil)
295         return;
296 
297     MTLSamplerDescriptor *samplerDescriptor = [MTLSamplerDescriptor new];
298 
299     samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;
300     samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;
301     samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;
302 
303     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
304     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
305     samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
306 
307     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
308     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
309     samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];
310 
311     samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;
312     samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;
313     samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;
314 
315     samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;
316     samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;
317     samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
318 
319     samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;
320     samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;
321     samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];
322 }
323 
324 static void setTxtUniforms(
325         id&lt;MTLRenderCommandEncoder&gt; encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
326         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
327 ) {
328     struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque, interpolation};
329     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
330 
331     id&lt;MTLSamplerState&gt; sampler;
332     if (repeat) {
333         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
334     } else {
335         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;
336     }
337     [encoder setFragmentSamplerState:sampler atIndex:0];
338 }
339 
340 // TODO: need support hints for all shaders
341 
342 // For the current paint mode:
343 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
344 // 2. Set vertex and fragment buffers
345 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
346                composite:(MTLComposite *)composite
347            isStencilUsed:(jboolean)isStencilUsed
348                isTexture:(jboolean)isTexture
349            interpolation:(int)interpolation
350                     isAA:(jboolean)isAA
351                 srcFlags:(const SurfaceRasterFlags *)srcFlags
352                 dstFlags:(const SurfaceRasterFlags *)dstFlags
353     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
354 {
355     initTemplatePipelineDescriptors();
356 
357     const bool stencil = isStencilUsed == JNI_TRUE;
358 
359     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;
360     if (isTexture) {
361 
362       if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
363         pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
364                                                 vertexShaderId:@&quot;vert_txt_tp&quot;
365                                               fragmentShaderId:@&quot;frag_txt_tp&quot;
366                                                  compositeRule:[composite getRule]
367                                                           isAA:JNI_FALSE
368                                                       srcFlags:srcFlags
369                                                       dstFlags:dstFlags
370                                                  stencilNeeded:stencil];
371         [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
372         [encoder setFragmentTexture:_paintTexture atIndex: 1];
373 
374         setTxtUniforms(encoder, 0, 0, interpolation, YES, [composite getExtraAlpha], srcFlags, dstFlags);
375       } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
376         pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
377                                                 vertexShaderId:@&quot;vert_txt_grad&quot;
378                                               fragmentShaderId:@&quot;frag_txt_grad&quot;
379                                                  compositeRule:[composite getRule]
380                                                           isAA:JNI_FALSE
381                                                       srcFlags:srcFlags
382                                                       dstFlags:dstFlags
383                                                  stencilNeeded:stencil];
384         struct GradFrameUniforms uf = {
385             {_p0, _p1, _p3},
386             RGBA_TO_V4(_pixel1),
387             RGBA_TO_V4(_pixel2)};
388         [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
389 
390       } else {
391         if (isAA) {
392           pipelineState = [pipelineStateStorage
393               getPipelineState:templateAATexturePipelineDesc
394                 vertexShaderId:@&quot;vert_txt&quot;
395               fragmentShaderId:@&quot;aa_frag_txt&quot;
396                  compositeRule:[composite getRule]
397                           isAA:JNI_FALSE
398                       srcFlags:srcFlags
399                       dstFlags:dstFlags
400                  stencilNeeded:stencil];
401 
402         } else {
403           pipelineState =
404               [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
405                                       vertexShaderId:@&quot;vert_txt&quot;
406                                     fragmentShaderId:@&quot;frag_txt&quot;
407                                        compositeRule:[composite getRule]
408                                            composite:composite
409                                                 isAA:JNI_FALSE
410                                             srcFlags:srcFlags
411                                             dstFlags:dstFlags
412                                        stencilNeeded:stencil];
413         }
414 
415         setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);
416       }
417     } else {
418         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
419             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
420                                                     vertexShaderId:@&quot;vert_col&quot;
421                                                   fragmentShaderId:@&quot;frag_col&quot;
422                                                      compositeRule:[composite getRule]
423                                                               isAA:isAA
424                                                           srcFlags:srcFlags
425                                                           dstFlags:dstFlags
426                                                      stencilNeeded:stencil];
427 
428             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
429             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
430         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
431             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
432                                                     vertexShaderId:@&quot;vert_grad&quot;
433                                                   fragmentShaderId:@&quot;frag_grad&quot;
434                                                      compositeRule:[composite getRule]
435                                                               isAA:isAA
436                                                           srcFlags:srcFlags
437                                                           dstFlags:dstFlags
438                                                      stencilNeeded:stencil];
439 
440             struct GradFrameUniforms uf = {
441                     {_p0, _p1, _p3},
442                     RGBA_TO_V4(_pixel1),
443                     RGBA_TO_V4(_pixel2)};
444             [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
445         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
446             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
447                                         vertexShaderId:@&quot;vert_tp&quot;
448                                       fragmentShaderId:@&quot;frag_tp&quot;
449                                          compositeRule:[composite getRule]
450                                                   isAA:isAA
451                                               srcFlags:srcFlags
452                                               dstFlags:dstFlags
453                                          stencilNeeded:stencil];
454 
455             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
456             [encoder setFragmentTexture:_paintTexture atIndex: 0];
457         }
458     }
459 
460     [encoder setRenderPipelineState:pipelineState];
461 }
462 
463 
464 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
465 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
466 // 2. Set vertex and fragment buffers
467 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
468                composite:(MTLComposite *)composite
469            isStencilUsed:(jboolean)isStencilUsed
470                isTexture:(jboolean)isTexture
471            interpolation:(int)interpolation
472                 srcFlags:(const SurfaceRasterFlags *)srcFlags
473                 dstFlags:(const SurfaceRasterFlags *)dstFlags
474     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage {
475     initTemplatePipelineDescriptors();
476 
477     const bool stencil = isStencilUsed == JNI_TRUE;
478     jint xorColor = (jint) [composite getXorColor];
479 
480     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;
481     if (isTexture) {
482           pipelineState = [pipelineStateStorage getXorModePipelineState:templateTexturePipelineDesc
483                                           vertexShaderId:@&quot;vert_txt&quot;
484                                         fragmentShaderId:@&quot;frag_txt&quot;
485                                                 srcFlags:srcFlags
486                                                 dstFlags:dstFlags
487                                            stencilNeeded:stencil];
488         const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;
489         setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0, interpolation, NO, [composite getExtraAlpha], srcFlags, dstFlags);
490         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
491     } else {
492         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
493 
494             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
495                                         vertexShaderId:@&quot;vert_col&quot;
496                                       fragmentShaderId:@&quot;frag_col&quot;
497                                               srcFlags:srcFlags
498                                               dstFlags:dstFlags
499                                          stencilNeeded:stencil];
500 
501             // Calculate _color ^ xorColor for RGB components
502             // This color gets XORed with destination framebuffer pixel color
503             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
504             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
505 
506         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
507 
508             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
509                                         vertexShaderId:@&quot;vert_grad&quot;
510                                       fragmentShaderId:@&quot;frag_grad&quot;
511                                               srcFlags:srcFlags
512                                               dstFlags:dstFlags
513                                          stencilNeeded:stencil];
514 
515                 struct GradFrameUniforms uf = {
516                         {_p0, _p1, _p3},
517                         RGBA_TO_V4(_pixel1 ^ xorColor),
518                         RGBA_TO_V4(_pixel2 ^ xorColor)};
519                 [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
520             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
521 
522                 pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
523                                             vertexShaderId:@&quot;vert_tp&quot;
524                                           fragmentShaderId:@&quot;frag_tp_xorMode&quot;
525                                                   srcFlags:srcFlags
526                                                   dstFlags:dstFlags
527                                              stencilNeeded:stencil];
528 
529                 [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
530                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
531                 [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
532             }
533         }
534     [encoder setRenderPipelineState:pipelineState];
535 }
536 
537 @end
538 
539 /************************* GradientPaint support ****************************/
540 
541 static void
542 MTLPaints_InitGradientTexture()
543 {
544     //TODO
545     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
546 }
547 
548 /****************** Shared MultipleGradientPaint support ********************/
549 
550 /**
551  * These constants are identical to those defined in the
552  * MultipleGradientPaint.CycleMethod enum; they are copied here for
553  * convenience (ideally we would pull them directly from the Java level,
554  * but that entails more hassle than it is worth).
555  */
556 #define CYCLE_NONE    0
557 #define CYCLE_REFLECT 1
558 #define CYCLE_REPEAT  2
559 
560 /**
561  * The following constants are flags that can be bitwise-or&#39;ed together
562  * to control how the MultipleGradientPaint shader source code is generated:
563  *
564  *   MULTI_CYCLE_METHOD
565  *     Placeholder for the CycleMethod enum constant.
566  *
567  *   MULTI_LARGE
568  *     If set, use the (slower) shader that supports a larger number of
569  *     gradient colors; otherwise, use the optimized codepath.  See
570  *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
571  *
572  *   MULTI_USE_MASK
573  *     If set, apply the alpha mask value from texture unit 0 to the
574  *     final color result (only used in the MaskFill case).
575  *
576  *   MULTI_LINEAR_RGB
577  *     If set, convert the linear RGB result back into the sRGB color space.
578  */
579 #define MULTI_CYCLE_METHOD (3 &lt;&lt; 0)
580 #define MULTI_LARGE        (1 &lt;&lt; 2)
581 #define MULTI_USE_MASK     (1 &lt;&lt; 3)
582 #define MULTI_LINEAR_RGB   (1 &lt;&lt; 4)
583 
584 /**
585  * This value determines the size of the array of programs for each
586  * MultipleGradientPaint type.  This value reflects the maximum value that
587  * can be represented by performing a bitwise-or of all the MULTI_*
588  * constants defined above.
589  */
590 #define MAX_PROGRAMS 32
591 
592 /** Evaluates to true if the given bit is set on the local flags variable. */
593 #define IS_SET(flagbit) \
594     (((flags) &amp; (flagbit)) != 0)
595 
596 /** Composes the given parameters as flags into the given flags variable.*/
597 #define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \
598     do {                                                   \
599         flags |= ((cycleMethod) &amp; MULTI_CYCLE_METHOD);     \
600         if (large)   flags |= MULTI_LARGE;                 \
601         if (useMask) flags |= MULTI_USE_MASK;              \
602         if (linear)  flags |= MULTI_LINEAR_RGB;            \
603     } while (0)
604 
605 /** Extracts the CycleMethod enum value from the given flags variable. */
606 #define EXTRACT_CYCLE_METHOD(flags) \
607     ((flags) &amp; MULTI_CYCLE_METHOD)
608 
609 /**
610  * The maximum number of gradient &quot;stops&quot; supported by the fragment shader
611  * and related code.  When the MULTI_LARGE flag is set, we will use
612  * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
613  * two separate values, we can have one highly optimized shader (SMALL) that
614  * supports only a few fractions/colors, and then another, less optimal
615  * shader that supports more stops.
616  */
617 #define MAX_FRACTIONS sun_java2d_pipe_BufferedPaints_MULTI_MAX_FRACTIONS
618 #define MAX_FRACTIONS_LARGE MAX_FRACTIONS
619 #define MAX_FRACTIONS_SMALL 4
620 
621 /**
622  * The maximum number of gradient colors supported by all of the gradient
623  * fragment shaders.  Note that this value must be a power of two, as it
624  * determines the size of the 1D texture created below.  It also must be
625  * greater than or equal to MAX_FRACTIONS (there is no strict requirement
626  * that the two values be equal).
627  */
628 #define MAX_COLORS 16
629 
630 /**
631  * The handle to the gradient color table texture object used by the shaders.
632  */
633 static jint multiGradientTexID = 0;
634 
635 /**
636  * This is essentially a template of the shader source code that can be used
637  * for either LinearGradientPaint or RadialGradientPaint.  It includes the
638  * structure and some variables that are common to each; the remaining
639  * code snippets (for CycleMethod, ColorSpaceType, and mask modulation)
640  * are filled in prior to compiling the shader at runtime depending on the
641  * paint parameters.  See MTLPaints_CreateMultiGradProgram() for more details.
642  */
643 static const char *multiGradientShaderSource =
644     // gradient texture size (in texels)
645     &quot;const int TEXTURE_SIZE = %d;&quot;
646     // maximum number of fractions/colors supported by this shader
647     &quot;const int MAX_FRACTIONS = %d;&quot;
648     // size of a single texel
649     &quot;const float FULL_TEXEL = (1.0 / float(TEXTURE_SIZE));&quot;
650     // size of half of a single texel
651     &quot;const float HALF_TEXEL = (FULL_TEXEL / 2.0);&quot;
652     // texture containing the gradient colors
653     &quot;uniform sampler1D colors;&quot;
654     // array of gradient stops/fractions
655     &quot;uniform float fractions[MAX_FRACTIONS];&quot;
656     // array of scale factors (one for each interval)
657     &quot;uniform float scaleFactors[MAX_FRACTIONS-1];&quot;
658     // (placeholder for mask variable)
659     &quot;%s&quot;
660     // (placeholder for Linear/RadialGP-specific variables)
661     &quot;%s&quot;
662     &quot;&quot;
663     &quot;void main(void)&quot;
664     &quot;{&quot;
665     &quot;    float dist;&quot;
666          // (placeholder for Linear/RadialGradientPaint-specific code)
667     &quot;    %s&quot;
668     &quot;&quot;
669     &quot;    float tc;&quot;
670          // (placeholder for CycleMethod-specific code)
671     &quot;    %s&quot;
672     &quot;&quot;
673          // calculate interpolated color
674     &quot;    vec4 result = texture1D(colors, tc);&quot;
675     &quot;&quot;
676          // (placeholder for ColorSpace conversion code)
677     &quot;    %s&quot;
678     &quot;&quot;
679          // (placeholder for mask modulation code)
680     &quot;    %s&quot;
681     &quot;&quot;
682          // modulate with gl_Color in order to apply extra alpha
683     &quot;    gl_FragColor = result * gl_Color;&quot;
684     &quot;}&quot;;
685 
686 /**
687  * This code takes a &quot;dist&quot; value as input (as calculated earlier by the
688  * LGP/RGP-specific code) in the range [0,1] and produces a texture
689  * coordinate value &quot;tc&quot; that represents the position of the chosen color
690  * in the one-dimensional gradient texture (also in the range [0,1]).
691  *
692  * One naive way to implement this would be to iterate through the fractions
693  * to figure out in which interval &quot;dist&quot; falls, and then compute the
694  * relative distance between the two nearest stops.  This approach would
695  * require an &quot;if&quot; check on every iteration, and it is best to avoid
696  * conditionals in fragment shaders for performance reasons.  Also, one might
697  * be tempted to use a break statement to jump out of the loop once the
698  * interval was found, but break statements (and non-constant loop bounds)
699  * are not natively available on most graphics hardware today, so that is
700  * a non-starter.
701  *
702  * The more optimal approach used here avoids these issues entirely by using
703  * an accumulation function that is equivalent to the process described above.
704  * The scaleFactors array is pre-initialized at enable time as follows:
705  *     scaleFactors[i] = 1.0 / (fractions[i+1] - fractions[i]);
706  *
707  * For each iteration, we subtract fractions[i] from dist and then multiply
708  * that value by scaleFactors[i].  If we are within the target interval,
709  * this value will be a fraction in the range [0,1] indicating the relative
710  * distance between fraction[i] and fraction[i+1].  If we are below the
711  * target interval, this value will be negative, so we clamp it to zero
712  * to avoid accumulating any value.  If we are above the target interval,
713  * the value will be greater than one, so we clamp it to one.  Upon exiting
714  * the loop, we will have accumulated zero or more 1.0&#39;s and a single
715  * fractional value.  This accumulated value tells us the position of the
716  * fragment color in the one-dimensional gradient texture, i.e., the
717  * texcoord called &quot;tc&quot;.
718  */
719 static const char *texCoordCalcCode =
720     &quot;int i;&quot;
721     &quot;float relFraction = 0.0;&quot;
722     &quot;for (i = 0; i &lt; MAX_FRACTIONS-1; i++) {&quot;
723     &quot;    relFraction +=&quot;
724     &quot;        clamp((dist - fractions[i]) * scaleFactors[i], 0.0, 1.0);&quot;
725     &quot;}&quot;
726     // we offset by half a texel so that we find the linearly interpolated
727     // color between the two texel centers of interest
728     &quot;tc = HALF_TEXEL + (FULL_TEXEL * relFraction);&quot;;
729 
730 /** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. */
731 static const char *noCycleCode =
732     &quot;if (dist &lt;= 0.0) {&quot;
733     &quot;    tc = 0.0;&quot;
734     &quot;} else if (dist &gt;= 1.0) {&quot;
735     &quot;    tc = 1.0;&quot;
736     &quot;} else {&quot;
737          // (placeholder for texcoord calculation)
738     &quot;    %s&quot;
739     &quot;}&quot;;
740 
741 /** Code for REFLECT that gets plugged into the CycleMethod placeholder. */
742 static const char *reflectCode =
743     &quot;dist = 1.0 - (abs(fract(dist * 0.5) - 0.5) * 2.0);&quot;
744     // (placeholder for texcoord calculation)
745     &quot;%s&quot;;
746 
747 /** Code for REPEAT that gets plugged into the CycleMethod placeholder. */
748 static const char *repeatCode =
749     &quot;dist = fract(dist);&quot;
750     // (placeholder for texcoord calculation)
751     &quot;%s&quot;;
752 
753 static void
754 MTLPaints_InitMultiGradientTexture()
755 {
756     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitMultiGradientTexture -- :TODO&quot;);
757 }
758 
759 /**
760  * Compiles and links the MultipleGradientPaint shader program.  If
761  * successful, this function returns a handle to the newly created
762  * shader program; otherwise returns 0.
763  */
764 static void*
765 MTLPaints_CreateMultiGradProgram(jint flags,
766                                  char *paintVars, char *distCode)
767 {
768 
769     //TODO
770     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_CreateMultiGradProgram -- :TODO&quot;);
771 
772     return NULL;
773 }
774 
775 /**
776  * Called from the MTLPaints_SetLinear/RadialGradientPaint() methods
777  * in order to setup the fraction/color values that are common to both.
778  */
779 static void
780 MTLPaints_SetMultiGradientPaint(void* multiGradProgram,
781                                 jint numStops,
782                                 void *pFractions, void *pPixels)
783 {
784     //TODO
785     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_SetMultiGradientPaint -- :TODO&quot;);
786 
787 }
788 
789 /********************** LinearGradientPaint support *************************/
790 
791 /**
792  * The handles to the LinearGradientPaint fragment program objects.  The
793  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
794  * above.  Note that most applications will likely need to initialize one
795  * or two of these elements, so the array is usually sparsely populated.
796  */
797 static void* linearGradPrograms[MAX_PROGRAMS];
798 
799 /**
800  * Compiles and links the LinearGradientPaint shader program.  If successful,
801  * this function returns a handle to the newly created shader program;
802  * otherwise returns 0.
803  */
804 static void*
805 MTLPaints_CreateLinearGradProgram(jint flags)
806 {
807     char *paintVars;
808     char *distCode;
809 
810     J2dTraceLn1(J2D_TRACE_INFO,
811                 &quot;MTLPaints_CreateLinearGradProgram&quot;,
812                 flags);
813 
814     /*
815      * To simplify the code and to make it easier to upload a number of
816      * uniform values at once, we pack a bunch of scalar (float) values
817      * into vec3 values below.  Here&#39;s how the values are related:
818      *
819      *   params.x = p0
820      *   params.y = p1
821      *   params.z = p3
822      *
823      *   yoff = dstOps-&gt;yOffset + dstOps-&gt;height
824      */
825     paintVars =
826         &quot;uniform vec3 params;&quot;
827         &quot;uniform float yoff;&quot;;
828     distCode =
829         // note that gl_FragCoord is in window space relative to the
830         // lower-left corner, so we have to flip the y-coordinate here
831         &quot;vec3 fragCoord = vec3(gl_FragCoord.x, yoff-gl_FragCoord.y, 1.0);&quot;
832         &quot;dist = dot(params, fragCoord);&quot;;
833 
834     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
835 }
836 
837 /********************** RadialGradientPaint support *************************/
838 
839 /**
840  * The handles to the RadialGradientPaint fragment program objects.  The
841  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
842  * above.  Note that most applications will likely need to initialize one
843  * or two of these elements, so the array is usually sparsely populated.
844  */
845 static void* radialGradPrograms[MAX_PROGRAMS];
846 
847 /**
848  * Compiles and links the RadialGradientPaint shader program.  If successful,
849  * this function returns a handle to the newly created shader program;
850  * otherwise returns 0.
851  */
852 static void*
853 MTLPaints_CreateRadialGradProgram(jint flags)
854 {
855     char *paintVars;
856     char *distCode;
857 
858     J2dTraceLn1(J2D_TRACE_INFO,
859                 &quot;MTLPaints_CreateRadialGradProgram&quot;,
860                 flags);
861 
862     /*
863      * To simplify the code and to make it easier to upload a number of
864      * uniform values at once, we pack a bunch of scalar (float) values
865      * into vec3 and vec4 values below.  Here&#39;s how the values are related:
866      *
867      *   m0.x = m00
868      *   m0.y = m01
869      *   m0.z = m02
870      *
871      *   m1.x = m10
872      *   m1.y = m11
873      *   m1.z = m12
874      *
875      *   precalc.x = focusX
876      *   precalc.y = yoff = dstOps-&gt;yOffset + dstOps-&gt;height
877      *   precalc.z = 1.0 - (focusX * focusX)
878      *   precalc.w = 1.0 / precalc.z
879      */
880     paintVars =
881         &quot;uniform vec3 m0;&quot;
882         &quot;uniform vec3 m1;&quot;
883         &quot;uniform vec4 precalc;&quot;;
884 
885     /*
886      * The following code is derived from Daniel Rice&#39;s whitepaper on
887      * radial gradient performance (attached to the bug report for 6521533).
888      * Refer to that document as well as the setup code in the Java-level
889      * BufferedPaints.setRadialGradientPaint() method for more details.
890      */
891     distCode =
892         // note that gl_FragCoord is in window space relative to the
893         // lower-left corner, so we have to flip the y-coordinate here
894         &quot;vec3 fragCoord =&quot;
895         &quot;    vec3(gl_FragCoord.x, precalc.y - gl_FragCoord.y, 1.0);&quot;
896         &quot;float x = dot(fragCoord, m0);&quot;
897         &quot;float y = dot(fragCoord, m1);&quot;
898         &quot;float xfx = x - precalc.x;&quot;
899         &quot;dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.z))*precalc.w;&quot;;
900 
901     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
902 }
903 
904 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
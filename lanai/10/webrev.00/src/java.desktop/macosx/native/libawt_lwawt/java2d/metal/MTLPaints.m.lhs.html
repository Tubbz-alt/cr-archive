<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 
 37 #define RGBA_TO_V4(c)              \
 38 {                                  \
 39     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 40     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 41     ((c) &amp; 0xFF)/255.0f,           \
 42     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 43 }
 44 
 45 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 46 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 47 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 48 
 49 static void initTemplatePipelineDescriptors() {
 50     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 51         return;
 52 
 53     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 54     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 55     vertDesc.attributes[VertexAttributePosition].offset = 0;
 56     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 57     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 58     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 59     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 60 
 61     templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 62     templateRenderPipelineDesc.sampleCount = 1;
 63     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 64     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 65     templateRenderPipelineDesc.label = @&quot;template_render&quot;;
 66 
 67     templateTexturePipelineDesc = [[templateRenderPipelineDesc copy] autorelease];
 68     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 69     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 70     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 71     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 72     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 73     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 74     templateTexturePipelineDesc.label = @&quot;template_texture&quot;;
 75 
 76     templateAATexturePipelineDesc = [[templateTexturePipelineDesc copy] autorelease];
 77     templateAATexturePipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;
 78     templateAATexturePipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
 79     templateAATexturePipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 80     templateAATexturePipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 81     templateAATexturePipelineDesc.label = @&quot;template_aa_texture&quot;;
 82 
 83 }
 84 
 85 @implementation MTLPaint {
 86     // TODO: remove paintState, split into heirarchy of Paint-objects (i.e. PaintColor, PaintGrad, e.t.c)
 87     jint          _paintState;
 88 
 89     // color-mode
 90     jint          _color;
 91 
 92     // lin-grad-mode
 93     jdouble       _p0;
 94     jdouble       _p1;
 95     jdouble       _p3;
 96     jboolean      _cyclic;
 97     jint          _pixel1;
 98     jint          _pixel2;
 99     jboolean      _useMask;
100 
101     // texture paint
102     id&lt;MTLTexture&gt; _paintTexture;
103     struct AnchorData _anchor;
104 }
105 
106 - (id)init {
107     self = [super init];
108     if (self) {
109         _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
110     }
111     return self;
112 }
113 
114 - (BOOL)isEqual:(MTLPaint *)other {
115     if (self == other)
116         return YES;
117     if (_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
118         return _paintState == other-&gt;_paintState;
119     if (_paintState != other-&gt;_paintState)
120         return NO;
121     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
122         return _p0 == other-&gt;_p0
123                &amp;&amp; _p1 == other-&gt;_p1
124                &amp;&amp; _p3 == other-&gt;_p3
125                &amp;&amp; _pixel1 == other-&gt;_pixel1
126                &amp;&amp; _pixel2 == other-&gt;_pixel2;
127     }
128     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
129         return _color == other-&gt;_color;
130     }
131     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
132         return _paintTexture == other-&gt;_paintTexture
133                &amp;&amp; _anchor.xParams[0] == other-&gt;_anchor.xParams[0]
134                &amp;&amp; _anchor.xParams[1] == other-&gt;_anchor.xParams[1]
135                &amp;&amp; _anchor.xParams[2] == other-&gt;_anchor.xParams[2]
136                &amp;&amp; _anchor.yParams[0] == other-&gt;_anchor.yParams[0]
137                &amp;&amp; _anchor.yParams[1] == other-&gt;_anchor.yParams[1]
138                &amp;&amp; _anchor.yParams[2] == other-&gt;_anchor.yParams[2];
139     }
140 
141     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unimplemented paint mode %d&quot;, _paintState);
142     return NO;
143 }
144 
145 - (void)copyFrom:(MTLPaint *)other {
146     _paintState = other-&gt;_paintState;
147     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
148         return;
149 
150     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
151         _p0 = other-&gt;_p0;
152         _p1 = other-&gt;_p1;
153         _p3 = other-&gt;_p3;
154         _pixel1 = other-&gt;_pixel1;
155         _pixel2 = other-&gt;_pixel2;
156         return;
157     }
158     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
159         _color = other-&gt;_color;
160         return;
161     }
162 
163     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
164         _color = other-&gt;_color;
165         _paintTexture = other-&gt;_paintTexture;
166         _anchor = other-&gt;_anchor;
167         return;
168     }
169 
170     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unsupported paint mode %d&quot;, _paintState);
171 }
172 
173 - (NSString *)getDescription {
174     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
175         return [NSString stringWithFormat:@&quot;[r=%d g=%d b=%d a=%d]&quot;, (_color &gt;&gt; 16) &amp; (0xFF), (_color &gt;&gt; 8) &amp; 0xFF, (_color) &amp; 0xFF, (_color &gt;&gt; 24) &amp; 0xFF];
176     }
177     
178     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
179         return [NSString stringWithFormat:@&quot;gradient&quot;];
180     }
181 
182     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
183         return [NSString stringWithFormat:@&quot;texture_paint&quot;];
184     }
185 
186     return @&quot;unknown-paint&quot;;
187 }
188 
189 - (jint)getColor {
190     return _color;
191 }
192 
193 - (void)reset {
194     _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
195     _paintTexture = nil;
196     _anchor.xParams[0] = _anchor.xParams[1] = _anchor.xParams[2] = 0.0f;
197     _anchor.yParams[0] = _anchor.yParams[1] = _anchor.yParams[2] = 0.0f; 
198 }
199 
200 - (void)setColor:(jint)pixelColor {
201     _paintState = sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR;
202     _color = pixelColor;
203 }
204 
205 - (void)setGradientUseMask:(jboolean)useMask
206                     cyclic:(jboolean)cyclic
207                         p0:(jdouble)p0
208                         p1:(jdouble)p1
209                         p3:(jdouble)p3
210                     pixel1:(jint)pixel1
211                     pixel2:(jint)pixel2
212 {
213     //TODO Resolve gradient distribution problem
214     //TODO Implement useMask
215     //TODO Implement cyclic
216     //fprintf(stderr,
217     //        &quot;MTLPaints_SetGradientPaint useMask=%d cyclic=%d &quot;
218     //        &quot;p0=%f p1=%f p3=%f pix1=%d pix2=%d\n&quot;, useMask, cyclic,
219     //        p0, p1, p3, pixel1, pixel2);
220 
221     _paintState = sun_java2d_SunGraphics2D_PAINT_GRADIENT;
222     _useMask = useMask;
223     _pixel1 = pixel1;
224     _pixel2 = pixel2;
225     _p0 = p0;
226     _p1 = p1;
227     _p3 = p3;
228     _cyclic = cyclic;
229 }
230 
231 - (void)setLinearGradient:(jboolean)useMask
232                    linear:(jboolean)linear
233               cycleMethod:(jboolean)cycleMethod
234                  numStops:(jint)numStops
235                        p0:(jfloat)p0
236                        p1:(jfloat)p1
237                        p3:(jfloat)p3
238                 fractions:(void *)fractions
239                    pixels:(void *)pixels
240 {
241     J2dTraceLn(J2D_TRACE_ERROR, &quot;setLinearGradient: UNIMPLEMENTED&quot;);
242     [self setColor:0];
243 }
244 
245 - (void)setRadialGradient:(jboolean)useMask
246                    linear:(jboolean)linear
247               cycleMethod:(jboolean)cycleMethod
248                  numStops:(jint)numStops
249                       m00:(jfloat)m00
250                       m01:(jfloat)m01
251                       m02:(jfloat)m02
252                       m10:(jfloat)m10
253                       m11:(jfloat)m11
254                       m12:(jfloat)m12
255                    focusX:(jfloat)focusX
256                 fractions:(void *)fractions
257                    pixels:(void *)pixels
258 {
259     J2dTraceLn(J2D_TRACE_ERROR, &quot;setRadialGradient: UNIMPLEMENTED&quot;);
260     [self setColor:0];
261 }
262 
263 - (void)setTexture:(jboolean)useMask
264            textureID:(id&lt;MTLTexture&gt;)textureID
265             filter:(jboolean)filter
266                xp0:(jdouble)xp0
267                xp1:(jdouble)xp1
268                xp3:(jdouble)xp3
269                yp0:(jdouble)yp0
270                yp1:(jdouble)yp1
271                yp3:(jdouble)yp3
272 {
273     _paintState = sun_java2d_SunGraphics2D_PAINT_TEXTURE;
274     _paintTexture = textureID;
275     
276     _anchor.xParams[0] = xp0;
277     _anchor.xParams[1] = xp1;
278     _anchor.xParams[2] = xp3;
279 
280     _anchor.yParams[0] = yp0;
281     _anchor.yParams[1] = yp1;
282     _anchor.yParams[2] = yp3;
283 }
284 
285 // For the current paint mode:
286 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
287 // 2. Set vertex and fragment buffers
288 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
289                composite:(MTLComposite *)composite
290            isStencilUsed:(jboolean)isStencilUsed
291                isTexture:(jboolean)isTexture
292                     isAA:(jboolean)isAA
293                 srcFlags:(const SurfaceRasterFlags *)srcFlags
294                 dstFlags:(const SurfaceRasterFlags *)dstFlags
295     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
296 {
297     initTemplatePipelineDescriptors();
298 
299     const bool stencil = isStencilUsed == JNI_TRUE;
300 
301     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;
302     if (isTexture) {
303 
304       if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
305         pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
306                                                 vertexShaderId:@&quot;vert_txt_tp&quot;
307                                               fragmentShaderId:@&quot;frag_txt_tp&quot;
308                                                  compositeRule:[composite getRule]
309                                                           isAA:JNI_FALSE
310                                                       srcFlags:srcFlags
311                                                       dstFlags:dstFlags
312                                                  stencilNeeded:stencil];
313         [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
314         [encoder setFragmentTexture:_paintTexture atIndex: 1];
315 
316         struct TxtFrameUniforms uf = {RGBA_TO_V4(0), 0, srcFlags-&gt;isOpaque,
317                                       dstFlags-&gt;isOpaque};
318         [encoder setFragmentBytes:&amp;uf length:sizeof(uf)
319                           atIndex:FrameUniformBuffer];
320 
<a name="1" id="anc1"></a>














321       } else {
322         if (isAA) {
323           pipelineState = [pipelineStateStorage
324               getPipelineState:templateAATexturePipelineDesc
325                 vertexShaderId:@&quot;vert_txt&quot;
326               fragmentShaderId:@&quot;aa_frag_txt&quot;
327                  compositeRule:[composite getRule]
328                           isAA:JNI_FALSE
329                       srcFlags:srcFlags
330                       dstFlags:dstFlags
331                  stencilNeeded:stencil];
332 
333         } else {
334           pipelineState =
335               [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
336                                       vertexShaderId:@&quot;vert_txt&quot;
337                                     fragmentShaderId:@&quot;frag_txt&quot;
338                                        compositeRule:[composite getRule]
339                                                 isAA:JNI_FALSE
340                                             srcFlags:srcFlags
341                                             dstFlags:dstFlags
342                                        stencilNeeded:stencil];
343         }
344 
345         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
346           struct TxtFrameUniforms uf = {RGBA_TO_V4(_color), 1, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
347           [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
348         } else {
349           struct TxtFrameUniforms uf = {RGBA_TO_V4(0), 0, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
350           [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
351         }
352       }
353     } else {
354         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
355             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
356                                                     vertexShaderId:@&quot;vert_col&quot;
357                                                   fragmentShaderId:@&quot;frag_col&quot;
358                                                      compositeRule:[composite getRule]
359                                                               isAA:isAA
360                                                           srcFlags:srcFlags
361                                                           dstFlags:dstFlags
362                                                      stencilNeeded:stencil];
363 
364             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
365             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
366         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
367             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
368                                                     vertexShaderId:@&quot;vert_grad&quot;
369                                                   fragmentShaderId:@&quot;frag_grad&quot;
370                                                      compositeRule:[composite getRule]
371                                                               isAA:isAA
372                                                           srcFlags:srcFlags
373                                                           dstFlags:dstFlags
374                                                      stencilNeeded:stencil];
375 
376             struct GradFrameUniforms uf = {
377                     {_p0, _p1, _p3},
378                     RGBA_TO_V4(_pixel1),
379                     RGBA_TO_V4(_pixel2)};
380             [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
381         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
382             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
383                                         vertexShaderId:@&quot;vert_tp&quot;
384                                       fragmentShaderId:@&quot;frag_tp&quot;
385                                          compositeRule:[composite getRule]
386                                                   isAA:isAA
387                                               srcFlags:srcFlags
388                                               dstFlags:dstFlags
389                                          stencilNeeded:stencil];
390 
391             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
392             [encoder setFragmentTexture:_paintTexture atIndex: 0];
393         }
394     }
395 
396     [encoder setRenderPipelineState:pipelineState];
397 }
398 
399 
400 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
401 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
402 // 2. Set vertex and fragment buffers
403 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
404                composite:(MTLComposite *)composite
405            isStencilUsed:(jboolean)isStencilUsed
406                isTexture:(jboolean)isTexture
407                 srcFlags:(const SurfaceRasterFlags *)srcFlags
408                 dstFlags:(const SurfaceRasterFlags *)dstFlags
409     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage {
410     initTemplatePipelineDescriptors();
411 
412     const bool stencil = isStencilUsed == JNI_TRUE;
413     jint xorColor = (jint) [composite getXorColor];
414 
415     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;
416     if (isTexture) {
417           pipelineState = [pipelineStateStorage getXorModePipelineState:templateTexturePipelineDesc
418                                           vertexShaderId:@&quot;vert_txt&quot;
419                                         fragmentShaderId:@&quot;frag_txt&quot;
420                                                 srcFlags:srcFlags
421                                                 dstFlags:dstFlags
422                                            stencilNeeded:stencil];
423 
424         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
425             struct TxtFrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor), 1, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
426             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
427         } else {
428             struct TxtFrameUniforms uf = {RGBA_TO_V4(0 ^ xorColor), 0, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
429             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
430         }
431         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
432     } else {
433         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
434 
435             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
436                                         vertexShaderId:@&quot;vert_col&quot;
437                                       fragmentShaderId:@&quot;frag_col&quot;
438                                               srcFlags:srcFlags
439                                               dstFlags:dstFlags
440                                          stencilNeeded:stencil];
441 
442             // Calculate _color ^ xorColor for RGB components
443             // This color gets XORed with destination framebuffer pixel color
444             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
445             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
446 
447         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
448 
449             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
450                                         vertexShaderId:@&quot;vert_grad&quot;
451                                       fragmentShaderId:@&quot;frag_grad&quot;
452                                               srcFlags:srcFlags
453                                               dstFlags:dstFlags
454                                          stencilNeeded:stencil];
455 
456                 struct GradFrameUniforms uf = {
457                         {_p0, _p1, _p3},
458                         RGBA_TO_V4(_pixel1 ^ xorColor),
459                         RGBA_TO_V4(_pixel2 ^ xorColor)};
460                 [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
461             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
462 
463                 pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
464                                             vertexShaderId:@&quot;vert_tp&quot;
465                                           fragmentShaderId:@&quot;frag_tp_xorMode&quot;
466                                                   srcFlags:srcFlags
467                                                   dstFlags:dstFlags
468                                              stencilNeeded:stencil];
469 
470                 [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
471                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
472                 [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
473             }
474         }
475     [encoder setRenderPipelineState:pipelineState];
476 }
477 
478 @end
479 
480 /************************* GradientPaint support ****************************/
481 
482 static void
483 MTLPaints_InitGradientTexture()
484 {
485     //TODO
486     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
487 }
488 
489 /****************** Shared MultipleGradientPaint support ********************/
490 
491 /**
492  * These constants are identical to those defined in the
493  * MultipleGradientPaint.CycleMethod enum; they are copied here for
494  * convenience (ideally we would pull them directly from the Java level,
495  * but that entails more hassle than it is worth).
496  */
497 #define CYCLE_NONE    0
498 #define CYCLE_REFLECT 1
499 #define CYCLE_REPEAT  2
500 
501 /**
502  * The following constants are flags that can be bitwise-or&#39;ed together
503  * to control how the MultipleGradientPaint shader source code is generated:
504  *
505  *   MULTI_CYCLE_METHOD
506  *     Placeholder for the CycleMethod enum constant.
507  *
508  *   MULTI_LARGE
509  *     If set, use the (slower) shader that supports a larger number of
510  *     gradient colors; otherwise, use the optimized codepath.  See
511  *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
512  *
513  *   MULTI_USE_MASK
514  *     If set, apply the alpha mask value from texture unit 0 to the
515  *     final color result (only used in the MaskFill case).
516  *
517  *   MULTI_LINEAR_RGB
518  *     If set, convert the linear RGB result back into the sRGB color space.
519  */
520 #define MULTI_CYCLE_METHOD (3 &lt;&lt; 0)
521 #define MULTI_LARGE        (1 &lt;&lt; 2)
522 #define MULTI_USE_MASK     (1 &lt;&lt; 3)
523 #define MULTI_LINEAR_RGB   (1 &lt;&lt; 4)
524 
525 /**
526  * This value determines the size of the array of programs for each
527  * MultipleGradientPaint type.  This value reflects the maximum value that
528  * can be represented by performing a bitwise-or of all the MULTI_*
529  * constants defined above.
530  */
531 #define MAX_PROGRAMS 32
532 
533 /** Evaluates to true if the given bit is set on the local flags variable. */
534 #define IS_SET(flagbit) \
535     (((flags) &amp; (flagbit)) != 0)
536 
537 /** Composes the given parameters as flags into the given flags variable.*/
538 #define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \
539     do {                                                   \
540         flags |= ((cycleMethod) &amp; MULTI_CYCLE_METHOD);     \
541         if (large)   flags |= MULTI_LARGE;                 \
542         if (useMask) flags |= MULTI_USE_MASK;              \
543         if (linear)  flags |= MULTI_LINEAR_RGB;            \
544     } while (0)
545 
546 /** Extracts the CycleMethod enum value from the given flags variable. */
547 #define EXTRACT_CYCLE_METHOD(flags) \
548     ((flags) &amp; MULTI_CYCLE_METHOD)
549 
550 /**
551  * The maximum number of gradient &quot;stops&quot; supported by the fragment shader
552  * and related code.  When the MULTI_LARGE flag is set, we will use
553  * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
554  * two separate values, we can have one highly optimized shader (SMALL) that
555  * supports only a few fractions/colors, and then another, less optimal
556  * shader that supports more stops.
557  */
558 #define MAX_FRACTIONS sun_java2d_pipe_BufferedPaints_MULTI_MAX_FRACTIONS
559 #define MAX_FRACTIONS_LARGE MAX_FRACTIONS
560 #define MAX_FRACTIONS_SMALL 4
561 
562 /**
563  * The maximum number of gradient colors supported by all of the gradient
564  * fragment shaders.  Note that this value must be a power of two, as it
565  * determines the size of the 1D texture created below.  It also must be
566  * greater than or equal to MAX_FRACTIONS (there is no strict requirement
567  * that the two values be equal).
568  */
569 #define MAX_COLORS 16
570 
571 /**
572  * The handle to the gradient color table texture object used by the shaders.
573  */
574 static jint multiGradientTexID = 0;
575 
576 /**
577  * This is essentially a template of the shader source code that can be used
578  * for either LinearGradientPaint or RadialGradientPaint.  It includes the
579  * structure and some variables that are common to each; the remaining
580  * code snippets (for CycleMethod, ColorSpaceType, and mask modulation)
581  * are filled in prior to compiling the shader at runtime depending on the
582  * paint parameters.  See MTLPaints_CreateMultiGradProgram() for more details.
583  */
584 static const char *multiGradientShaderSource =
585     // gradient texture size (in texels)
586     &quot;const int TEXTURE_SIZE = %d;&quot;
587     // maximum number of fractions/colors supported by this shader
588     &quot;const int MAX_FRACTIONS = %d;&quot;
589     // size of a single texel
590     &quot;const float FULL_TEXEL = (1.0 / float(TEXTURE_SIZE));&quot;
591     // size of half of a single texel
592     &quot;const float HALF_TEXEL = (FULL_TEXEL / 2.0);&quot;
593     // texture containing the gradient colors
594     &quot;uniform sampler1D colors;&quot;
595     // array of gradient stops/fractions
596     &quot;uniform float fractions[MAX_FRACTIONS];&quot;
597     // array of scale factors (one for each interval)
598     &quot;uniform float scaleFactors[MAX_FRACTIONS-1];&quot;
599     // (placeholder for mask variable)
600     &quot;%s&quot;
601     // (placeholder for Linear/RadialGP-specific variables)
602     &quot;%s&quot;
603     &quot;&quot;
604     &quot;void main(void)&quot;
605     &quot;{&quot;
606     &quot;    float dist;&quot;
607          // (placeholder for Linear/RadialGradientPaint-specific code)
608     &quot;    %s&quot;
609     &quot;&quot;
610     &quot;    float tc;&quot;
611          // (placeholder for CycleMethod-specific code)
612     &quot;    %s&quot;
613     &quot;&quot;
614          // calculate interpolated color
615     &quot;    vec4 result = texture1D(colors, tc);&quot;
616     &quot;&quot;
617          // (placeholder for ColorSpace conversion code)
618     &quot;    %s&quot;
619     &quot;&quot;
620          // (placeholder for mask modulation code)
621     &quot;    %s&quot;
622     &quot;&quot;
623          // modulate with gl_Color in order to apply extra alpha
624     &quot;    gl_FragColor = result * gl_Color;&quot;
625     &quot;}&quot;;
626 
627 /**
628  * This code takes a &quot;dist&quot; value as input (as calculated earlier by the
629  * LGP/RGP-specific code) in the range [0,1] and produces a texture
630  * coordinate value &quot;tc&quot; that represents the position of the chosen color
631  * in the one-dimensional gradient texture (also in the range [0,1]).
632  *
633  * One naive way to implement this would be to iterate through the fractions
634  * to figure out in which interval &quot;dist&quot; falls, and then compute the
635  * relative distance between the two nearest stops.  This approach would
636  * require an &quot;if&quot; check on every iteration, and it is best to avoid
637  * conditionals in fragment shaders for performance reasons.  Also, one might
638  * be tempted to use a break statement to jump out of the loop once the
639  * interval was found, but break statements (and non-constant loop bounds)
640  * are not natively available on most graphics hardware today, so that is
641  * a non-starter.
642  *
643  * The more optimal approach used here avoids these issues entirely by using
644  * an accumulation function that is equivalent to the process described above.
645  * The scaleFactors array is pre-initialized at enable time as follows:
646  *     scaleFactors[i] = 1.0 / (fractions[i+1] - fractions[i]);
647  *
648  * For each iteration, we subtract fractions[i] from dist and then multiply
649  * that value by scaleFactors[i].  If we are within the target interval,
650  * this value will be a fraction in the range [0,1] indicating the relative
651  * distance between fraction[i] and fraction[i+1].  If we are below the
652  * target interval, this value will be negative, so we clamp it to zero
653  * to avoid accumulating any value.  If we are above the target interval,
654  * the value will be greater than one, so we clamp it to one.  Upon exiting
655  * the loop, we will have accumulated zero or more 1.0&#39;s and a single
656  * fractional value.  This accumulated value tells us the position of the
657  * fragment color in the one-dimensional gradient texture, i.e., the
658  * texcoord called &quot;tc&quot;.
659  */
660 static const char *texCoordCalcCode =
661     &quot;int i;&quot;
662     &quot;float relFraction = 0.0;&quot;
663     &quot;for (i = 0; i &lt; MAX_FRACTIONS-1; i++) {&quot;
664     &quot;    relFraction +=&quot;
665     &quot;        clamp((dist - fractions[i]) * scaleFactors[i], 0.0, 1.0);&quot;
666     &quot;}&quot;
667     // we offset by half a texel so that we find the linearly interpolated
668     // color between the two texel centers of interest
669     &quot;tc = HALF_TEXEL + (FULL_TEXEL * relFraction);&quot;;
670 
671 /** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. */
672 static const char *noCycleCode =
673     &quot;if (dist &lt;= 0.0) {&quot;
674     &quot;    tc = 0.0;&quot;
675     &quot;} else if (dist &gt;= 1.0) {&quot;
676     &quot;    tc = 1.0;&quot;
677     &quot;} else {&quot;
678          // (placeholder for texcoord calculation)
679     &quot;    %s&quot;
680     &quot;}&quot;;
681 
682 /** Code for REFLECT that gets plugged into the CycleMethod placeholder. */
683 static const char *reflectCode =
684     &quot;dist = 1.0 - (abs(fract(dist * 0.5) - 0.5) * 2.0);&quot;
685     // (placeholder for texcoord calculation)
686     &quot;%s&quot;;
687 
688 /** Code for REPEAT that gets plugged into the CycleMethod placeholder. */
689 static const char *repeatCode =
690     &quot;dist = fract(dist);&quot;
691     // (placeholder for texcoord calculation)
692     &quot;%s&quot;;
693 
694 static void
695 MTLPaints_InitMultiGradientTexture()
696 {
697     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitMultiGradientTexture -- :TODO&quot;);
698 }
699 
700 /**
701  * Compiles and links the MultipleGradientPaint shader program.  If
702  * successful, this function returns a handle to the newly created
703  * shader program; otherwise returns 0.
704  */
705 static void*
706 MTLPaints_CreateMultiGradProgram(jint flags,
707                                  char *paintVars, char *distCode)
708 {
709 
710     //TODO
711     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_CreateMultiGradProgram -- :TODO&quot;);
712 
713     return NULL;
714 }
715 
716 /**
717  * Called from the MTLPaints_SetLinear/RadialGradientPaint() methods
718  * in order to setup the fraction/color values that are common to both.
719  */
720 static void
721 MTLPaints_SetMultiGradientPaint(void* multiGradProgram,
722                                 jint numStops,
723                                 void *pFractions, void *pPixels)
724 {
725     //TODO
726     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_SetMultiGradientPaint -- :TODO&quot;);
727 
728 }
729 
730 /********************** LinearGradientPaint support *************************/
731 
732 /**
733  * The handles to the LinearGradientPaint fragment program objects.  The
734  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
735  * above.  Note that most applications will likely need to initialize one
736  * or two of these elements, so the array is usually sparsely populated.
737  */
738 static void* linearGradPrograms[MAX_PROGRAMS];
739 
740 /**
741  * Compiles and links the LinearGradientPaint shader program.  If successful,
742  * this function returns a handle to the newly created shader program;
743  * otherwise returns 0.
744  */
745 static void*
746 MTLPaints_CreateLinearGradProgram(jint flags)
747 {
748     char *paintVars;
749     char *distCode;
750 
751     J2dTraceLn1(J2D_TRACE_INFO,
752                 &quot;MTLPaints_CreateLinearGradProgram&quot;,
753                 flags);
754 
755     /*
756      * To simplify the code and to make it easier to upload a number of
757      * uniform values at once, we pack a bunch of scalar (float) values
758      * into vec3 values below.  Here&#39;s how the values are related:
759      *
760      *   params.x = p0
761      *   params.y = p1
762      *   params.z = p3
763      *
764      *   yoff = dstOps-&gt;yOffset + dstOps-&gt;height
765      */
766     paintVars =
767         &quot;uniform vec3 params;&quot;
768         &quot;uniform float yoff;&quot;;
769     distCode =
770         // note that gl_FragCoord is in window space relative to the
771         // lower-left corner, so we have to flip the y-coordinate here
772         &quot;vec3 fragCoord = vec3(gl_FragCoord.x, yoff-gl_FragCoord.y, 1.0);&quot;
773         &quot;dist = dot(params, fragCoord);&quot;;
774 
775     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
776 }
777 
778 /********************** RadialGradientPaint support *************************/
779 
780 /**
781  * The handles to the RadialGradientPaint fragment program objects.  The
782  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
783  * above.  Note that most applications will likely need to initialize one
784  * or two of these elements, so the array is usually sparsely populated.
785  */
786 static void* radialGradPrograms[MAX_PROGRAMS];
787 
788 /**
789  * Compiles and links the RadialGradientPaint shader program.  If successful,
790  * this function returns a handle to the newly created shader program;
791  * otherwise returns 0.
792  */
793 static void*
794 MTLPaints_CreateRadialGradProgram(jint flags)
795 {
796     char *paintVars;
797     char *distCode;
798 
799     J2dTraceLn1(J2D_TRACE_INFO,
800                 &quot;MTLPaints_CreateRadialGradProgram&quot;,
801                 flags);
802 
803     /*
804      * To simplify the code and to make it easier to upload a number of
805      * uniform values at once, we pack a bunch of scalar (float) values
806      * into vec3 and vec4 values below.  Here&#39;s how the values are related:
807      *
808      *   m0.x = m00
809      *   m0.y = m01
810      *   m0.z = m02
811      *
812      *   m1.x = m10
813      *   m1.y = m11
814      *   m1.z = m12
815      *
816      *   precalc.x = focusX
817      *   precalc.y = yoff = dstOps-&gt;yOffset + dstOps-&gt;height
818      *   precalc.z = 1.0 - (focusX * focusX)
819      *   precalc.w = 1.0 / precalc.z
820      */
821     paintVars =
822         &quot;uniform vec3 m0;&quot;
823         &quot;uniform vec3 m1;&quot;
824         &quot;uniform vec4 precalc;&quot;;
825 
826     /*
827      * The following code is derived from Daniel Rice&#39;s whitepaper on
828      * radial gradient performance (attached to the bug report for 6521533).
829      * Refer to that document as well as the setup code in the Java-level
830      * BufferedPaints.setRadialGradientPaint() method for more details.
831      */
832     distCode =
833         // note that gl_FragCoord is in window space relative to the
834         // lower-left corner, so we have to flip the y-coordinate here
835         &quot;vec3 fragCoord =&quot;
836         &quot;    vec3(gl_FragCoord.x, precalc.y - gl_FragCoord.y, 1.0);&quot;
837         &quot;float x = dot(fragCoord, m0);&quot;
838         &quot;float y = dot(fragCoord, m1);&quot;
839         &quot;float xfx = x - precalc.x;&quot;
840         &quot;dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.z))*precalc.w;&quot;;
841 
842     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
843 }
844 
845 #endif /* !HEADLESS */
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
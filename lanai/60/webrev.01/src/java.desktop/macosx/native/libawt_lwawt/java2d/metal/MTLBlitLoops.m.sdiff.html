<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLSurfaceData.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
153     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
156 #endif //TRACE_drawTex2Tex
157 
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
<span class="line-modified">173 id&lt;MTLTexture&gt; replaceTextureRegion(id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {</span>
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;
178     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;
179 
180     id&lt;MTLTexture&gt; result = nil;
181     if (rfi-&gt;permuteMap != NULL) {
182 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
183         if (@available(macOS 10.15, *)) {
184             @autoreleasepool {
185                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
186                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
187                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
188                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
189                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
190                         uint2swizzle(swzRed),
191                         uint2swizzle(swzGreen),
192                         uint2swizzle(swzBlue),
193                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
</pre>
<hr />
<pre>
225             srcBuf.rowBytes = srcInfo-&gt;scanStride;
226             srcBuf.data = raster;
227 
228             vImage_Buffer destBuf;
229             destBuf.height = dh;
230             destBuf.width = dw;
231             destBuf.rowBytes = dw*4;
232             destBuf.data = buffer;
233 
234             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
235             raster = buffer;
236 
237             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
238                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
239         }
240     }
241 
242     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
243     if (result != nil)
244         dest = result;
<span class="line-modified">245     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];</span>













246     return result;
247 }
248 
249 /**
250  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
251  * destination MTL &quot;Surface&quot;.  This method is invoked from
252  * MTLBlitLoops_Blit().
253  */
254 
255 static void
256 MTLBlitSwToTextureViaPooledTexture(
257         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
258         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
259         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
260 {
261     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
262     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
263     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
264 
265     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
266     if (texHandle == nil) {
267         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
268         return;
269     }
270     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
271     [texHandle release];
272 
273     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
<span class="line-modified">274     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(texBuff, srcInfo, rfi, 0, 0, sw, sh);</span>
275     if (useBlitEncoder) {
276         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
277         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
278                          sourceSlice:0
279                          sourceLevel:0
280                         sourceOrigin:MTLOriginMake(0, 0, 0)
281                           sourceSize:MTLSizeMake(sw, sh, 1)
282                            toTexture:dest
283                     destinationSlice:0
284                     destinationLevel:0
285                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
286         [blitEncoder endEncoding];
287     } else {
288         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
289                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
290     }
291 
292     if (swizzledTexture != nil) {
293         [swizzledTexture release];
294     }
</pre>
<hr />
<pre>
601                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
602                     texture, xform, [mtlc getCompositeDescription].cString,
603                     getSurfaceDescription(dstOps).cString, srcOps,
604                     sx2 - sx1, sy2 - sy1,
605                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
606                     sx1, sy1, sx2, sy2,
607                     dx1, dy1, dx2, dy2);
608 #endif //TRACE_BLIT
609 
610             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
611             const jboolean useReplaceRegion = texture ||
612                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
613                     &amp;&amp; !xform
614                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
615 
616             if (useReplaceRegion) {
617                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
618 #ifdef TRACE_BLIT
619                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
620 #endif //TRACE_BLIT
<span class="line-modified">621                     replaceTextureRegion(dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);</span>
622                 } else {
623 #ifdef TRACE_BLIT
624                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
625 #endif //TRACE_BLIT
626                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
627                 }
628             } else { // !useReplaceRegion
629 #ifdef TRACE_BLIT
630                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
631 #endif //TRACE_BLIT
632                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
633             }
634         }
635         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
636     }
637     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
638 }
639 
640 /**
641  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
</pre>
</td>
<td>
<hr />
<pre>
153     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
156 #endif //TRACE_drawTex2Tex
157 
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
<span class="line-modified">173 id&lt;MTLTexture&gt; replaceTextureRegion(MTLContext *mtlc, id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {</span>
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;
178     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;
179 
180     id&lt;MTLTexture&gt; result = nil;
181     if (rfi-&gt;permuteMap != NULL) {
182 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
183         if (@available(macOS 10.15, *)) {
184             @autoreleasepool {
185                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
186                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
187                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
188                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
189                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
190                         uint2swizzle(swzRed),
191                         uint2swizzle(swzGreen),
192                         uint2swizzle(swzBlue),
193                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
</pre>
<hr />
<pre>
225             srcBuf.rowBytes = srcInfo-&gt;scanStride;
226             srcBuf.data = raster;
227 
228             vImage_Buffer destBuf;
229             destBuf.height = dh;
230             destBuf.width = dw;
231             destBuf.rowBytes = dw*4;
232             destBuf.data = buffer;
233 
234             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
235             raster = buffer;
236 
237             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
238                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
239         }
240     }
241 
242     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
243     if (result != nil)
244         dest = result;
<span class="line-modified">245 </span>
<span class="line-added">246     @autoreleasepool {</span>
<span class="line-added">247         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];</span>
<span class="line-added">248 </span>
<span class="line-added">249         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion src (dw, dh) : [%d, %d] dest (dx1, dy1) =[%d, %d]&quot;,</span>
<span class="line-added">250                     dw, dh, dx1, dy1);</span>
<span class="line-added">251 </span>
<span class="line-added">252         id &lt;MTLBuffer&gt; buff = [[mtlc.device newBufferWithBytes:raster length:srcInfo-&gt;scanStride * dh options:MTLResourceStorageModeManaged] autorelease];</span>
<span class="line-added">253         [blitEncoder copyFromBuffer:buff</span>
<span class="line-added">254                 sourceOffset:0 sourceBytesPerRow:srcInfo-&gt;scanStride sourceBytesPerImage:srcInfo-&gt;scanStride * dh sourceSize:MTLSizeMake(dw, dh, 1)</span>
<span class="line-added">255                 toTexture:dest destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dx1, dy1, 0)];</span>
<span class="line-added">256         [blitEncoder endEncoding];</span>
<span class="line-added">257     }</span>
<span class="line-added">258 </span>
259     return result;
260 }
261 
262 /**
263  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
264  * destination MTL &quot;Surface&quot;.  This method is invoked from
265  * MTLBlitLoops_Blit().
266  */
267 
268 static void
269 MTLBlitSwToTextureViaPooledTexture(
270         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
271         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
272         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
273 {
274     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
275     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
276     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
277 
278     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
279     if (texHandle == nil) {
280         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
281         return;
282     }
283     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
284     [texHandle release];
285 
286     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
<span class="line-modified">287     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(mtlc, texBuff, srcInfo, rfi, 0, 0, sw, sh);</span>
288     if (useBlitEncoder) {
289         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
290         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
291                          sourceSlice:0
292                          sourceLevel:0
293                         sourceOrigin:MTLOriginMake(0, 0, 0)
294                           sourceSize:MTLSizeMake(sw, sh, 1)
295                            toTexture:dest
296                     destinationSlice:0
297                     destinationLevel:0
298                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
299         [blitEncoder endEncoding];
300     } else {
301         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
302                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
303     }
304 
305     if (swizzledTexture != nil) {
306         [swizzledTexture release];
307     }
</pre>
<hr />
<pre>
614                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
615                     texture, xform, [mtlc getCompositeDescription].cString,
616                     getSurfaceDescription(dstOps).cString, srcOps,
617                     sx2 - sx1, sy2 - sy1,
618                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
619                     sx1, sy1, sx2, sy2,
620                     dx1, dy1, dx2, dy2);
621 #endif //TRACE_BLIT
622 
623             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
624             const jboolean useReplaceRegion = texture ||
625                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
626                     &amp;&amp; !xform
627                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
628 
629             if (useReplaceRegion) {
630                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
631 #ifdef TRACE_BLIT
632                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
633 #endif //TRACE_BLIT
<span class="line-modified">634                     replaceTextureRegion(mtlc, dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);</span>
635                 } else {
636 #ifdef TRACE_BLIT
637                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
638 #endif //TRACE_BLIT
639                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
640                 }
641             } else { // !useReplaceRegion
642 #ifdef TRACE_BLIT
643                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
644 #endif //TRACE_BLIT
645                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
646             }
647         }
648         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
649     }
650     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
651 }
652 
653 /**
654  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLSurfaceData.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jni.h&gt;
 29 #include &lt;jlong.h&gt;
 30 
 31 #include &quot;SurfaceData.h&quot;
 32 #include &quot;MTLBlitLoops.h&quot;
 33 #include &quot;MTLRenderQueue.h&quot;
 34 #include &quot;MTLSurfaceData.h&quot;
 35 #include &quot;MTLUtils.h&quot;
 36 #include &quot;GraphicsPrimitiveMgr.h&quot;
 37 
 38 #include &lt;stdlib.h&gt; // malloc
 39 #include &lt;string.h&gt; // memcpy
 40 #include &quot;IntArgbPre.h&quot;
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
 44 #ifdef DEBUG
 45 #define TRACE_ISOBLIT
 46 #define TRACE_BLIT
 47 #endif //DEBUG
 48 //#define DEBUG_ISOBLIT
 49 //#define DEBUG_BLIT
 50 
 51 typedef struct {
 52     MTLPixelFormat   format;
 53     jboolean hasAlpha;
 54     jboolean isPremult;
 55     const uint8_t * permuteMap;
 56 } MTLRasterFormatInfo;
 57 
 58 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 59 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 60 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
 61 
 62 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 63     for (int c = 0; c &lt; 4; ++c) {
 64         if (perm[c] == pos)
 65             return c;
 66     }
 67     return -1;
 68 }
 69 
 70 #define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))
 71 
 72 /**
 73  * This table contains the &quot;pixel formats&quot; for all system memory surfaces
 74  * that Metal is capable of handling, indexed by the &quot;PF_&quot; constants defined
 75  * in MTLLSurfaceData.java.  These pixel formats contain information that is
 76  * passed to Metal when copying from a system memory (&quot;Sw&quot;) surface to
 77  * an Metal surface
 78  */
 79 MTLRasterFormatInfo RasterFormatInfos[] = {
 80         { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, /* 0 - IntArgb      */ // Argb (in java notation)
 81         { MTLPixelFormatBGRA8Unorm, 1, 1, NULL }, /* 1 - IntArgbPre   */
 82         { MTLPixelFormatBGRA8Unorm, 0, 1, NULL }, /* 2 - IntRgb       */ // xrgb
 83         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_rgbx }, /* 3 - IntRgbx      */
 84         { MTLPixelFormatRGBA8Unorm, 0, 1, NULL }, /* 4 - IntBgr       */ // xbgr
 85         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_bgrx }, /* 5 - IntBgrx      */
 86 
 87 //        TODO: support 2-byte formats
 88 //        { GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV,
 89 //                2, 0, 1,                                     }, /* 7 - Ushort555Rgb */
 90 //        { GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1,
 91 //                2, 0, 1,                                     }, /* 8 - Ushort555Rgbx*/
 92 //        { GL_LUMINANCE, GL_UNSIGNED_BYTE,
 93 //                1, 0, 1,                                     }, /* 9 - ByteGray     */
 94 //        { GL_LUMINANCE, GL_UNSIGNED_SHORT,
 95 //                2, 0, 1,                                     }, /*10 - UshortGray   */
 96 //        { GL_BGR,  GL_UNSIGNED_BYTE,
 97 //                1, 0, 1,                                     }, /*11 - ThreeByteBgr */
 98 };
 99 
100 extern void J2dTraceImpl(int level, jboolean cr, const char *string, ...);
101 
102 void fillTxQuad(
103         struct TxtVertex * txQuadVerts,
104         jint sx1, jint sy1, jint sx2, jint sy2, jint sw, jint sh,
105         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2, jdouble dw, jdouble dh
106 ) {
107     const float nsx1 = sx1/(float)sw;
108     const float nsy1 = sy1/(float)sh;
109     const float nsx2 = sx2/(float)sw;
110     const float nsy2 = sy2/(float)sh;
111 
112     txQuadVerts[0].position[0] = dx1;
113     txQuadVerts[0].position[1] = dy1;
114     txQuadVerts[0].txtpos[0]   = nsx1;
115     txQuadVerts[0].txtpos[1]   = nsy1;
116 
117     txQuadVerts[1].position[0] = dx2;
118     txQuadVerts[1].position[1] = dy1;
119     txQuadVerts[1].txtpos[0]   = nsx2;
120     txQuadVerts[1].txtpos[1]   = nsy1;
121 
122     txQuadVerts[2].position[0] = dx2;
123     txQuadVerts[2].position[1] = dy2;
124     txQuadVerts[2].txtpos[0]   = nsx2;
125     txQuadVerts[2].txtpos[1]   = nsy2;
126 
127     txQuadVerts[3].position[0] = dx2;
128     txQuadVerts[3].position[1] = dy2;
129     txQuadVerts[3].txtpos[0]   = nsx2;
130     txQuadVerts[3].txtpos[1]   = nsy2;
131 
132     txQuadVerts[4].position[0] = dx1;
133     txQuadVerts[4].position[1] = dy2;
134     txQuadVerts[4].txtpos[0]   = nsx1;
135     txQuadVerts[4].txtpos[1]   = nsy2;
136 
137     txQuadVerts[5].position[0] = dx1;
138     txQuadVerts[5].position[1] = dy1;
139     txQuadVerts[5].txtpos[0]   = nsx1;
140     txQuadVerts[5].txtpos[1]   = nsy1;
141 }
142 
143 //#define TRACE_drawTex2Tex
144 
145 void drawTex2Tex(MTLContext *mtlc,
146                         id&lt;MTLTexture&gt; src, id&lt;MTLTexture&gt; dst,
147                         jboolean isSrcOpaque, jboolean isDstOpaque, jint hint,
148                         jint sx1, jint sy1, jint sx2, jint sy2,
149                         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
150 {
151 #ifdef TRACE_drawTex2Tex
152     J2dRlsTraceLn2(J2D_TRACE_VERBOSE, &quot;drawTex2Tex: src tex=%p, dst tex=%p&quot;, src, dst);
153     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
156 #endif //TRACE_drawTex2Tex
157 
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
<a name="1" id="anc1"></a><span class="line-modified">173 id&lt;MTLTexture&gt; replaceTextureRegion(id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {</span>
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;
178     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;
179 
180     id&lt;MTLTexture&gt; result = nil;
181     if (rfi-&gt;permuteMap != NULL) {
182 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
183         if (@available(macOS 10.15, *)) {
184             @autoreleasepool {
185                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
186                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
187                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
188                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
189                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
190                         uint2swizzle(swzRed),
191                         uint2swizzle(swzGreen),
192                         uint2swizzle(swzBlue),
193                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
194                 );
195                 result = [dest
196                         newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm
197                         textureType:MTLTextureType2D
198                         levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)
199                         swizzle:swizzle];
200                 J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use swizzle for pooled]: %d, %d, %d, %d, hasA=%d&quot;,
201                             swizzle.red, swizzle.green, swizzle.blue, swizzle.alpha, rfi-&gt;hasAlpha);
202             }
203         } else
204 #endif // __MAC_10_15 &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
205         {
206             // perform raster conversion
207             // invoked only from rq-thread, so use static buffers
208             // but it&#39;s better to use thread-local buffers (or special buffer manager)
209             const int destRasterSize = dw*dh*4;
210 
211             static int bufferSize = 0;
212             static void * buffer = NULL;
213             if (buffer == NULL || bufferSize &lt; destRasterSize) {
214                 bufferSize = destRasterSize;
215                 buffer = realloc(buffer, bufferSize);
216             }
217             if (buffer == NULL) {
218                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
219                 bufferSize = 0;
220                 return nil;
221             }
222             vImage_Buffer srcBuf;
223             srcBuf.height = dh;
224             srcBuf.width = dw;
225             srcBuf.rowBytes = srcInfo-&gt;scanStride;
226             srcBuf.data = raster;
227 
228             vImage_Buffer destBuf;
229             destBuf.height = dh;
230             destBuf.width = dw;
231             destBuf.rowBytes = dw*4;
232             destBuf.data = buffer;
233 
234             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
235             raster = buffer;
236 
237             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
238                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
239         }
240     }
241 
242     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
243     if (result != nil)
244         dest = result;
<a name="2" id="anc2"></a><span class="line-modified">245     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];</span>













246     return result;
247 }
248 
249 /**
250  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
251  * destination MTL &quot;Surface&quot;.  This method is invoked from
252  * MTLBlitLoops_Blit().
253  */
254 
255 static void
256 MTLBlitSwToTextureViaPooledTexture(
257         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
258         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
259         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
260 {
261     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
262     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
263     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
264 
265     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
266     if (texHandle == nil) {
267         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
268         return;
269     }
270     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
271     [texHandle release];
272 
273     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
<a name="3" id="anc3"></a><span class="line-modified">274     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(texBuff, srcInfo, rfi, 0, 0, sw, sh);</span>
275     if (useBlitEncoder) {
276         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
277         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
278                          sourceSlice:0
279                          sourceLevel:0
280                         sourceOrigin:MTLOriginMake(0, 0, 0)
281                           sourceSize:MTLSizeMake(sw, sh, 1)
282                            toTexture:dest
283                     destinationSlice:0
284                     destinationLevel:0
285                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
286         [blitEncoder endEncoding];
287     } else {
288         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
289                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
290     }
291 
292     if (swizzledTexture != nil) {
293         [swizzledTexture release];
294     }
295 }
296 
297 static
298 jboolean isIntegerAndUnscaled(
299         jint sx1, jint sy1, jint sx2, jint sy2,
300         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2
301 ) {
302     const jdouble epsilon = 0.0001f;
303 
304     // check that dx1,dy1 is integer
305     if (fabs(dx1 - (int)dx1) &gt; epsilon || fabs(dy1 - (int)dy1) &gt; epsilon) {
306         return JNI_FALSE;
307     }
308     // check that destSize equals srcSize
309     if (fabs(dx2 - dx1 - sx2 + sx1) &gt; epsilon || fabs(dy2 - dy1 - sy2 + sy1) &gt; epsilon) {
310         return JNI_FALSE;
311     }
312     return JNI_TRUE;
313 }
314 
315 static
316 jboolean clipDestCoords(
317         jdouble *dx1, jdouble *dy1, jdouble *dx2, jdouble *dy2,
318         jint *sx1, jint *sy1, jint *sx2, jint *sy2,
319         jint destW, jint destH, const MTLScissorRect * clipRect
320 ) {
321     // Trim destination rect by clip-rect (or dest.bounds)
322     const jint sw    = *sx2 - *sx1;
323     const jint sh    = *sy2 - *sy1;
324     const jdouble dw = *dx2 - *dx1;
325     const jdouble dh = *dy2 - *dy1;
326 
327     jdouble dcx1 = 0;
328     jdouble dcx2 = destW;
329     jdouble dcy1 = 0;
330     jdouble dcy2 = destH;
331     if (clipRect != NULL) {
332         if (clipRect-&gt;x &gt; dcx1)
333             dcx1 = clipRect-&gt;x;
334         const int maxX = clipRect-&gt;x + clipRect-&gt;width;
335         if (dcx2 &gt; maxX)
336             dcx2 = maxX;
337         if (clipRect-&gt;y &gt; dcy1)
338             dcy1 = clipRect-&gt;y;
339         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
340         if (dcy2 &gt; maxY)
341             dcy2 = maxY;
342 
343         if (dcx1 &gt;= dcx2) {
344             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
345             dcx1 = dcx2;
346         }
347         if (dcy1 &gt;= dcy2) {
348             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
349             dcy1 = dcy2;
350         }
351     }
352     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
353         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
354         J2dTraceLn4(J2D_TRACE_INFO, &quot;\tdx2=%1.4f &lt;= dcx1=%1.4f || *dx1=%1.4f &gt;= dcx2=%1.4f&quot;, *dx2, dcx1, *dx1, dcx2);
355         J2dTraceLn4(J2D_TRACE_INFO, &quot;\t*dy2=%1.4f &lt;= dcy1=%1.4f || *dy1=%1.4f &gt;= dcy2=%1.4f&quot;, *dy2, dcy1, *dy1, dcy2);
356         return JNI_FALSE;
357     }
358     if (*dx1 &lt; dcx1) {
359         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f | sx1+=%d&quot;, *dx1, dcx1, (jint)((dcx1 - *dx1) * (sw/dw)));
360         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
361         *dx1 = dcx1;
362     }
363     if (*dx2 &gt; dcx2) {
364         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f | sx2-=%d&quot;, *dx2, dcx2, (jint)((*dx2 - dcx2) * (sw/dw)));
365         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
366         *dx2 = dcx2;
367     }
368     if (*dy1 &lt; dcy1) {
369         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f | sy1+=%d&quot;, *dy1, dcy1, (jint)((dcy1 - *dy1) * (sh/dh)));
370         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
371         *dy1 = dcy1;
372     }
373     if (*dy2 &gt; dcy2) {
374         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f | sy2-=%d&quot;, *dy2, dcy2, (jint)((*dy2 - dcy2) * (sh/dh)));
375         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
376         *dy2 = dcy2;
377     }
378     return JNI_TRUE;
379 }
380 
381 /**
382  * General blit method for copying a native MTL surface to another MTL &quot;Surface&quot;.
383  * Parameter texture == true forces to use &#39;texture&#39; codepath (dest coordinates will always be integers).
384  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
385  */
386 void
387 MTLBlitLoops_IsoBlit(JNIEnv *env,
388                      MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
389                      jboolean xform, jint hint, jboolean texture,
390                      jint sx1, jint sy1, jint sx2, jint sy2,
391                      jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
392 {
393     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
394     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
395 
396     RETURN_IF_NULL(mtlc);
397     RETURN_IF_NULL(srcOps);
398     RETURN_IF_NULL(dstOps);
399 
400     id&lt;MTLTexture&gt; srcTex = srcOps-&gt;pTexture;
401     id&lt;MTLTexture&gt; dstTex = dstOps-&gt;pTexture;
402     if (srcTex == nil || srcTex == nil) {
403         J2dTraceLn2(J2D_TRACE_ERROR, &quot;MTLBlitLoops_IsoBlit: surface is null (stex=%p, dtex=%p)&quot;, srcTex, dstTex);
404         return;
405     }
406 
407     const jint sw    = sx2 - sx1;
408     const jint sh    = sy2 - sy1;
409     const jdouble dw = dx2 - dx1;
410     const jdouble dh = dy2 - dy1;
411 
412     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
413         J2dTraceLn4(J2D_TRACE_WARNING, &quot;MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d&quot;, sw, sh, dw, dh);
414         return;
415     }
416 
417 #ifdef DEBUG_ISOBLIT
418     if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {
419         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
420                 &quot;MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
421                 xform, mtlc.useTransform, texture);
422     }
423 #endif // DEBUG_ISOBLIT
424 
425     clipDestCoords(
426             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
427             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
428             dstTex.width, dstTex.height, texture ? NULL : [mtlc.clip getRect]
429     );
430 
431     SurfaceDataBounds bounds;
432     bounds.x1 = sx1;
433     bounds.y1 = sy1;
434     bounds.x2 = sx2;
435     bounds.y2 = sy2;
436     SurfaceData_IntersectBoundsXYXY(&amp;bounds, 0, 0, srcOps-&gt;width, srcOps-&gt;height);
437 
438     if (bounds.x2 &lt;= bounds.x1 || bounds.y2 &lt;= bounds.y1) {
439         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_IsoBlit: source rectangle doesn&#39;t intersect with source surface bounds&quot;);
440         J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d&quot;, sx1, sy1, sx2, sy2, srcOps-&gt;width, srcOps-&gt;height);
441         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
442         return;
443     }
444 
445     if (bounds.x1 != sx1) {
446         dx1 += (bounds.x1 - sx1) * (dw / sw);
447         sx1 = bounds.x1;
448     }
449     if (bounds.y1 != sy1) {
450         dy1 += (bounds.y1 - sy1) * (dh / sh);
451         sy1 = bounds.y1;
452     }
453     if (bounds.x2 != sx2) {
454         dx2 += (bounds.x2 - sx2) * (dw / sw);
455         sx2 = bounds.x2;
456     }
457     if (bounds.y2 != sy2) {
458         dy2 += (bounds.y2 - sy2) * (dh / sh);
459         sy2 = bounds.y2;
460     }
461 
462 #ifdef TRACE_ISOBLIT
463     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
464          &quot;MTLBlitLoops_IsoBlit [tx=%d, xf=%d, AC=%s]: src=%s, dst=%s | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
465          texture, xform, [mtlc getCompositeDescription].cString,
466          getSurfaceDescription(srcOps).cString, getSurfaceDescription(dstOps).cString,
467          sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
468 #endif //TRACE_ISOBLIT
469 
470     if (!texture &amp;&amp; !xform
471         &amp;&amp; [mtlc isBlendingDisabled:srcOps-&gt;isOpaque]
472         &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)
473         &amp;&amp; (dstOps-&gt;isOpaque || !srcOps-&gt;isOpaque)
474     ) {
475 #ifdef TRACE_ISOBLIT
476         J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via blitEncoder]&quot;);
477 #endif //TRACE_ISOBLIT
478 
479         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
480         [blitEncoder copyFromTexture:srcTex
481                          sourceSlice:0
482                          sourceLevel:0
483                         sourceOrigin:MTLOriginMake(sx1, sy1, 0)
484                           sourceSize:MTLSizeMake(sx2 - sx1, sy2 - sy1, 1)
485                            toTexture:dstTex
486                     destinationSlice:0
487                     destinationLevel:0
488                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
489         [blitEncoder endEncoding];
490         return;
491     }
492 
493 #ifdef TRACE_ISOBLIT
494     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via sampling]&quot;);
495 #endif //TRACE_ISOBLIT
496     drawTex2Tex(mtlc, srcTex, dstTex,
497             [mtlc isBlendingDisabled:srcOps-&gt;isOpaque],
498             dstOps-&gt;isOpaque, hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
499 }
500 
501 /**
502  * General blit method for copying a system memory (&quot;Sw&quot;) surface to a native MTL surface.
503  * Parameter texture == true only in SwToTextureBlit (straight copy from sw to texture), dest coordinates will always be integers.
504  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
505  */
506 void
507 MTLBlitLoops_Blit(JNIEnv *env,
508                   MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
509                   jboolean xform, jint hint,
510                   jint srctype, jboolean texture,
511                   jint sx1, jint sy1, jint sx2, jint sy2,
512                   jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
513 {
514     SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);
515     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
516 
517     RETURN_IF_NULL(mtlc);
518     RETURN_IF_NULL(srcOps);
519     RETURN_IF_NULL(dstOps);
520 
521     id&lt;MTLTexture&gt; dest = dstOps-&gt;pTexture;
522     if (dest == NULL) {
523         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: dest is null&quot;);
524         return;
525     }
526     if (srctype &lt; 0 || srctype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
527         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: source pixel format %d isn&#39;t supported&quot;, srctype);
528         return;
529     }
530     const jint sw    = sx2 - sx1;
531     const jint sh    = sy2 - sy1;
532     const jdouble dw = dx2 - dx1;
533     const jdouble dh = dy2 - dy1;
534 
535     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
536         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: invalid dimensions&quot;);
537         return;
538     }
539 
540 #ifdef DEBUG_BLIT
541     if (
542         (xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)
543         || (xform &amp;&amp; texture)
544     ) {
545         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
546                 &quot;MTLBlitLoops_Blit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
547                 xform, mtlc.useTransform, texture);
548     }
549     if (texture) {
550         if (!isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)) {
551             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
552                     &quot;MTLBlitLoops_Blit state error: texture=true, but src and dst dimensions aren&#39;t equal or dest coords aren&#39;t integers&quot;);
553         }
554         if (!dstOps-&gt;isOpaque &amp;&amp; !RasterFormatInfos[srctype].hasAlpha) {
555             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
556                     &quot;MTLBlitLoops_Blit state error: texture=true, but dest has alpha and source hasn&#39;t alpha, can&#39;t use texture-codepath&quot;);
557         }
558     }
559 #endif // DEBUG_BLIT
560 
561     clipDestCoords(
562             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
563             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
564             dest.width, dest.height, texture ? NULL : [mtlc.clip getRect]
565     );
566 
567     SurfaceDataRasInfo srcInfo;
568     srcInfo.bounds.x1 = sx1;
569     srcInfo.bounds.y1 = sy1;
570     srcInfo.bounds.x2 = sx2;
571     srcInfo.bounds.y2 = sy2;
572 
573     // NOTE: This function will modify the contents of the bounds field to represent the maximum available raster data.
574     if (srcOps-&gt;Lock(env, srcOps, &amp;srcInfo, SD_LOCK_READ) != SD_SUCCESS) {
575         J2dTraceLn(J2D_TRACE_WARNING, &quot;MTLBlitLoops_Blit: could not acquire lock&quot;);
576         return;
577     }
578 
579     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp; srcInfo.bounds.y2 &gt; srcInfo.bounds.y1) {
580         srcOps-&gt;GetRasInfo(env, srcOps, &amp;srcInfo);
581         if (srcInfo.rasBase) {
582             if (srcInfo.bounds.x1 != sx1) {
583                 const int dx = srcInfo.bounds.x1 - sx1;
584                 dx1 += dx * (dw / sw);
585             }
586             if (srcInfo.bounds.y1 != sy1) {
587                 const int dy = srcInfo.bounds.y1 - sy1;
588                 dy1 += dy * (dh / sh);
589             }
590             if (srcInfo.bounds.x2 != sx2) {
591                 const int dx = srcInfo.bounds.x2 - sx2;
592                 dx2 += dx * (dw / sw);
593             }
594             if (srcInfo.bounds.y2 != sy2) {
595                 const int dy = srcInfo.bounds.y2 - sy2;
596                 dy2 += dy * (dh / sh);
597             }
598 
599 #ifdef TRACE_BLIT
600             J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
601                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
602                     texture, xform, [mtlc getCompositeDescription].cString,
603                     getSurfaceDescription(dstOps).cString, srcOps,
604                     sx2 - sx1, sy2 - sy1,
605                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
606                     sx1, sy1, sx2, sy2,
607                     dx1, dy1, dx2, dy2);
608 #endif //TRACE_BLIT
609 
610             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
611             const jboolean useReplaceRegion = texture ||
612                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
613                     &amp;&amp; !xform
614                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
615 
616             if (useReplaceRegion) {
617                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
618 #ifdef TRACE_BLIT
619                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
620 #endif //TRACE_BLIT
<a name="4" id="anc4"></a><span class="line-modified">621                     replaceTextureRegion(dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);</span>
622                 } else {
623 #ifdef TRACE_BLIT
624                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
625 #endif //TRACE_BLIT
626                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
627                 }
628             } else { // !useReplaceRegion
629 #ifdef TRACE_BLIT
630                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
631 #endif //TRACE_BLIT
632                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
633             }
634         }
635         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
636     }
637     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
638 }
639 
640 /**
641  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
642  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
643  */
644 void
645 MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,
646                              jlong pSrcOps, jlong pDstOps, jint dsttype,
647                              jint srcx, jint srcy, jint dstx, jint dsty,
648                              jint width, jint height)
649 {
650     J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: sx=%d sy=%d w=%d h=%d dx=%d dy=%d&quot;, srcx, srcy, width, height, dstx, dsty);
651 
652     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
653     SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);
654     SurfaceDataRasInfo srcInfo, dstInfo;
655 
656     if (dsttype &lt; 0 || dsttype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
657         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: destination pixel format %d isn&#39;t supported&quot;, dsttype);
658         return;
659     }
660 
661     if (width &lt;= 0 || height &lt;= 0) {
662         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: dimensions are non-positive&quot;);
663         return;
664     }
665 
666     RETURN_IF_NULL(srcOps);
667     RETURN_IF_NULL(dstOps);
668     RETURN_IF_NULL(mtlc);
669 
670     srcInfo.bounds.x1 = srcx;
671     srcInfo.bounds.y1 = srcy;
672     srcInfo.bounds.x2 = srcx + width;
673     srcInfo.bounds.y2 = srcy + height;
674     dstInfo.bounds.x1 = dstx;
675     dstInfo.bounds.y1 = dsty;
676     dstInfo.bounds.x2 = dstx + width;
677     dstInfo.bounds.y2 = dsty + height;
678 
679     if (dstOps-&gt;Lock(env, dstOps, &amp;dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {
680         J2dTraceLn(J2D_TRACE_WARNING,&quot;MTLBlitLoops_SurfaceToSwBlit: could not acquire dst lock&quot;);
681         return;
682     }
683 
684     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,
685                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);
686     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,
687                                     srcx - dstx, srcy - dsty);
688 
689     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;
690         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)
691     {
692         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);
693         if (dstInfo.rasBase) {
694             void *pDst = dstInfo.rasBase;
695 
696             srcx = srcInfo.bounds.x1;
697             srcy = srcInfo.bounds.y1;
698             dstx = dstInfo.bounds.x1;
699             dsty = dstInfo.bounds.y1;
700             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
701             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
702 
703             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
704             pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);
705 
706             // this accounts for lower-left origin of the source region
707             srcx = srcOps-&gt;xOffset + srcx;
708             srcy = srcOps-&gt;yOffset + srcOps-&gt;height - srcy - height;
709             const int srcLength = width * height * 4; // NOTE: assume that src format is MTLPixelFormatBGRA8Unorm
710 
711 #ifdef DEBUG
712             void *pDstEnd = dstInfo.rasBase + (height - 1)*dstInfo.scanStride + width*dstInfo.pixelStride;
713             if (pDst + srcLength &gt; pDstEnd) {
714                 J2dTraceLn6(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: length mismatch: dstx=%d, dsty=%d, w=%d, h=%d, pixStride=%d, scanStride=%d&quot;,
715                         dstx, dsty, width, height, dstInfo.pixelStride, dstInfo.scanStride);
716                 return;
717             }
718 #endif //DEBUG
719 
720             // Create MTLBuffer (or use static)
721             MTLRasterFormatInfo rfi = RasterFormatInfos[dsttype];
722             const jboolean directCopy = rfi.permuteMap == NULL;
723 
724             id&lt;MTLBuffer&gt; mtlbuf;
725 #ifdef USE_STATIC_BUFFER
726             if (directCopy) {
727                 // NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API
728                 // mtlbuf = [mtlc.device
729                 //          newBufferWithBytesNoCopy:pDst
730                 //                            length:(NSUInteger) srcLength
731                 //                           options:MTLResourceCPUCacheModeDefaultCache
732                 //                       deallocator:nil];
733                 //
734                 // see https://developer.apple.com/documentation/metal/mtldevice/1433382-newbufferwithbytesnocopy?language=objc
735                 //
736                 // The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.
737                 // The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.
738                 // Memory allocated by malloc is specifically disallowed.
739             }
740 
741             static id&lt;MTLBuffer&gt; mtlIntermediateBuffer = nil; // need to reimplement with MTLBufferManager
742             if (mtlIntermediateBuffer == nil || mtlIntermediateBuffer.length &lt; srcLength) {
743                 if (mtlIntermediateBuffer != nil) {
744                     [mtlIntermediateBuffer release];
745                 }
746                 mtlIntermediateBuffer = [mtlc.device newBufferWithLength:srcLength options:MTLResourceCPUCacheModeDefaultCache];
747             }
748             mtlbuf = mtlIntermediateBuffer;
749 #else // USE_STATIC_BUFFER
750             mtlbuf = [mtlc.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];
751 #endif // USE_STATIC_BUFFER
752 
753             // Read from surface into MTLBuffer
754             // NOTE: using of separate blitCommandBuffer can produce errors (draw into surface (with general cmd-buf)
755             // can be unfinished when reading raster from blit cmd-buf).
756             // Consider to use [mtlc.encoderManager createBlitEncoder] and [mtlc commitCommandBuffer:JNI_TRUE];
757             J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: source texture %p&quot;, srcOps-&gt;pTexture);
758 
759             id&lt;MTLCommandBuffer&gt; cb = [mtlc createCommandBuffer];
760             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
761             [blitEncoder synchronizeTexture:srcOps-&gt;pTexture slice:0 level:0];
762             [blitEncoder copyFromTexture:srcOps-&gt;pTexture
763                             sourceSlice:0
764                             sourceLevel:0
765                            sourceOrigin:MTLOriginMake(srcx, srcy, 0)
766                              sourceSize:MTLSizeMake(width, height, 1)
767                                toBuffer:mtlbuf
768                       destinationOffset:0 /*offset already taken in: pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride)*/
769                  destinationBytesPerRow:width*4
770                destinationBytesPerImage:width * height*4];
771             [blitEncoder endEncoding];
772 
773             // Commit and wait for reading complete
774             [cb commit];
775             [cb waitUntilCompleted];
776 
777             // Perform conversion if necessary
778             if (directCopy) {
779                 memcpy(pDst, mtlbuf.contents, srcLength);
780             } else {
781                 J2dTraceLn6(J2D_TRACE_VERBOSE,&quot;MTLBlitLoops_SurfaceToSwBlit: dsttype=%d, raster conversion will be performed, dest rfi: %d, %d, %d, %d, hasA=%d&quot;,
782                             dsttype, rfi.permuteMap[0], rfi.permuteMap[1], rfi.permuteMap[2], rfi.permuteMap[3], rfi.hasAlpha);
783 
784                 // perform raster conversion: mtlIntermediateBuffer(8888) -&gt; pDst(rfi)
785                 // invoked only from rq-thread, so use static buffers
786                 // but it&#39;s better to use thread-local buffers (or special buffer manager)
787                 vImage_Buffer srcBuf;
788                 srcBuf.height = height;
789                 srcBuf.width = width;
790                 srcBuf.rowBytes = 4*width;
791                 srcBuf.data = mtlbuf.contents;
792 
793                 vImage_Buffer destBuf;
794                 destBuf.height = height;
795                 destBuf.width = width;
796                 destBuf.rowBytes = dstInfo.scanStride;
797                 destBuf.data = pDst;
798 
799                 vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi.permuteMap, kvImageNoFlags);
800             }
801 #ifndef USE_STATIC_BUFFER
802             [mtlbuf release];
803 #endif // USE_STATIC_BUFFER
804         }
805         SurfaceData_InvokeRelease(env, dstOps, &amp;dstInfo);
806     }
807     SurfaceData_InvokeUnlock(env, dstOps, &amp;dstInfo);
808 }
809 
810 void
811 MTLBlitLoops_CopyArea(JNIEnv *env,
812                       MTLContext *mtlc, BMTLSDOps *dstOps,
813                       jint x, jint y, jint width, jint height,
814                       jint dx, jint dy)
815 {
816 #ifdef DEBUG
817     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, &quot;MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -&gt; dst (%d, %d)&quot;,
818             dstOps, dstOps-&gt;pTexture, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).width, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).height, x, y, width, height, dx, dy);
819 #endif //DEBUG
820 
821     @autoreleasepool {
822     id&lt;MTLCommandBuffer&gt; cb = [mtlc createCommandBuffer];
823     id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
824 
825     // Create an intrermediate buffer
826     int totalBuffsize = width * height * 4;
827     id &lt;MTLBuffer&gt; buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];
828 
829     [blitEncoder copyFromTexture:dstOps-&gt;pTexture
830             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
831              toBuffer:buff destinationOffset:0 destinationBytesPerRow:(width * 4) destinationBytesPerImage:totalBuffsize];
832 
833     [blitEncoder copyFromBuffer:buff
834             sourceOffset:0 sourceBytesPerRow:width*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(width, height, 1)
835             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
836     [blitEncoder endEncoding];
837 
838     [cb commit];
839     //[cb waitUntilCompleted];
840 
841     /*[blitEncoder
842             copyFromTexture:dstOps-&gt;pTexture
843             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
844             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
845     [blitEncoder endEncoding];*/
846 
847     }
848     // TODO:
849     //  1. check rect bounds
850     //  2. support CopyArea with extra-alpha (and with custom Composite if necessary)
851 }
852 
853 #endif /* !HEADLESS */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
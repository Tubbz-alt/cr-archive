<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLSurfaceData.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
 44 #ifdef DEBUG
 45 #define TRACE_ISOBLIT
 46 #define TRACE_BLIT
 47 #endif //DEBUG
 48 //#define DEBUG_ISOBLIT
 49 //#define DEBUG_BLIT
 50 
 51 typedef struct {
 52     MTLPixelFormat   format;
 53     jboolean hasAlpha;
 54     jboolean isPremult;
 55     const uint8_t * permuteMap;
 56 } MTLRasterFormatInfo;
 57 
 58 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 59 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 60 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };

 61 
 62 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 63     for (int c = 0; c &lt; 4; ++c) {
 64         if (perm[c] == pos)
 65             return c;
 66     }
 67     return -1;
 68 }
 69 
 70 #define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))
 71 
 72 /**
 73  * This table contains the &quot;pixel formats&quot; for all system memory surfaces
 74  * that Metal is capable of handling, indexed by the &quot;PF_&quot; constants defined
 75  * in MTLLSurfaceData.java.  These pixel formats contain information that is
 76  * passed to Metal when copying from a system memory (&quot;Sw&quot;) surface to
 77  * an Metal surface
 78  */
 79 MTLRasterFormatInfo RasterFormatInfos[] = {
 80         { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, /* 0 - IntArgb      */ // Argb (in java notation)
</pre>
<hr />
<pre>
153     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
156 #endif //TRACE_drawTex2Tex
157 
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
<span class="line-modified">173 id&lt;MTLTexture&gt; replaceTextureRegion(id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {</span>
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;
178     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;
179 
180     id&lt;MTLTexture&gt; result = nil;
181     if (rfi-&gt;permuteMap != NULL) {
182 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
183         if (@available(macOS 10.15, *)) {
184             @autoreleasepool {
185                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
186                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
187                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
188                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
189                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
190                         uint2swizzle(swzRed),
191                         uint2swizzle(swzGreen),
192                         uint2swizzle(swzBlue),
193                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
</pre>
<hr />
<pre>
225             srcBuf.rowBytes = srcInfo-&gt;scanStride;
226             srcBuf.data = raster;
227 
228             vImage_Buffer destBuf;
229             destBuf.height = dh;
230             destBuf.width = dw;
231             destBuf.rowBytes = dw*4;
232             destBuf.data = buffer;
233 
234             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
235             raster = buffer;
236 
237             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
238                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
239         }
240     }
241 
242     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
243     if (result != nil)
244         dest = result;
<span class="line-modified">245     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];</span>













246     return result;
247 }
248 
249 /**
250  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
251  * destination MTL &quot;Surface&quot;.  This method is invoked from
252  * MTLBlitLoops_Blit().
253  */
254 
255 static void
256 MTLBlitSwToTextureViaPooledTexture(
257         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
258         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
259         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
260 {
261     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
262     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
263     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
264 
265     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
266     if (texHandle == nil) {
267         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
268         return;
269     }
270     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
271     [texHandle release];
272 
273     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
<span class="line-modified">274     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(texBuff, srcInfo, rfi, 0, 0, sw, sh);</span>
275     if (useBlitEncoder) {
276         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
277         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
278                          sourceSlice:0
279                          sourceLevel:0
280                         sourceOrigin:MTLOriginMake(0, 0, 0)
281                           sourceSize:MTLSizeMake(sw, sh, 1)
282                            toTexture:dest
283                     destinationSlice:0
284                     destinationLevel:0
285                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
286         [blitEncoder endEncoding];
287     } else {
288         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
289                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
290     }
291 
292     if (swizzledTexture != nil) {
293         [swizzledTexture release];
294     }
</pre>
<hr />
<pre>
601                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
602                     texture, xform, [mtlc getCompositeDescription].cString,
603                     getSurfaceDescription(dstOps).cString, srcOps,
604                     sx2 - sx1, sy2 - sy1,
605                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
606                     sx1, sy1, sx2, sy2,
607                     dx1, dy1, dx2, dy2);
608 #endif //TRACE_BLIT
609 
610             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
611             const jboolean useReplaceRegion = texture ||
612                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
613                     &amp;&amp; !xform
614                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
615 
616             if (useReplaceRegion) {
617                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
618 #ifdef TRACE_BLIT
619                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
620 #endif //TRACE_BLIT
<span class="line-modified">621                     replaceTextureRegion(dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);</span>
622                 } else {
623 #ifdef TRACE_BLIT
624                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
625 #endif //TRACE_BLIT
626                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
627                 }
628             } else { // !useReplaceRegion
629 #ifdef TRACE_BLIT
630                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
631 #endif //TRACE_BLIT
632                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
633             }
634         }
635         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
636     }
637     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
638 }
639 
640 /**
641  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
</pre>
</td>
<td>
<hr />
<pre>
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
 44 #ifdef DEBUG
 45 #define TRACE_ISOBLIT
 46 #define TRACE_BLIT
 47 #endif //DEBUG
 48 //#define DEBUG_ISOBLIT
 49 //#define DEBUG_BLIT
 50 
 51 typedef struct {
 52     MTLPixelFormat   format;
 53     jboolean hasAlpha;
 54     jboolean isPremult;
 55     const uint8_t * permuteMap;
 56 } MTLRasterFormatInfo;
 57 
 58 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 59 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 60 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
<span class="line-added"> 61 const uint8_t permuteMap_argb[4] = { 0, 1, 2, 3 };</span>
 62 
 63 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 64     for (int c = 0; c &lt; 4; ++c) {
 65         if (perm[c] == pos)
 66             return c;
 67     }
 68     return -1;
 69 }
 70 
 71 #define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))
 72 
 73 /**
 74  * This table contains the &quot;pixel formats&quot; for all system memory surfaces
 75  * that Metal is capable of handling, indexed by the &quot;PF_&quot; constants defined
 76  * in MTLLSurfaceData.java.  These pixel formats contain information that is
 77  * passed to Metal when copying from a system memory (&quot;Sw&quot;) surface to
 78  * an Metal surface
 79  */
 80 MTLRasterFormatInfo RasterFormatInfos[] = {
 81         { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, /* 0 - IntArgb      */ // Argb (in java notation)
</pre>
<hr />
<pre>
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
156     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
157 #endif //TRACE_drawTex2Tex
158 
159     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
160                                                                      isSrcOpaque:isSrcOpaque
161                                                                      isDstOpaque:isDstOpaque
162                                                                    interpolation:hint
163     ];
164 
165     struct TxtVertex quadTxVerticesBuffer[6];
166     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
167 
168     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
169     [encoder setFragmentTexture:src atIndex: 0];
170     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
171 }
172 
173 static
<span class="line-modified">174 id&lt;MTLTexture&gt; replaceTextureRegion(MTLContext *mtlc, id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {</span>
175     const int dw = dx2 - dx1;
176     const int dh = dy2 - dy1;
177 
178     const void * raster = srcInfo-&gt;rasBase;
179     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;
180 
181     id&lt;MTLTexture&gt; result = nil;
182     if (rfi-&gt;permuteMap != NULL) {
183 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
184         if (@available(macOS 10.15, *)) {
185             @autoreleasepool {
186                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
187                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
188                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
189                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
190                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
191                         uint2swizzle(swzRed),
192                         uint2swizzle(swzGreen),
193                         uint2swizzle(swzBlue),
194                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
</pre>
<hr />
<pre>
226             srcBuf.rowBytes = srcInfo-&gt;scanStride;
227             srcBuf.data = raster;
228 
229             vImage_Buffer destBuf;
230             destBuf.height = dh;
231             destBuf.width = dw;
232             destBuf.rowBytes = dw*4;
233             destBuf.data = buffer;
234 
235             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
236             raster = buffer;
237 
238             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
239                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
240         }
241     }
242 
243     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
244     if (result != nil)
245         dest = result;
<span class="line-modified">246 </span>
<span class="line-added">247     @autoreleasepool {</span>
<span class="line-added">248         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];</span>
<span class="line-added">249 </span>
<span class="line-added">250         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion scr (dw, dh) : [%d, %d] dest (dx1, dy1) =[%d, %d]&quot;,</span>
<span class="line-added">251                     dw, dh, dx1, dy1);</span>
<span class="line-added">252 </span>
<span class="line-added">253         id &lt;MTLBuffer&gt; buff = [[mtlc.device newBufferWithBytes:raster length:srcInfo-&gt;scanStride * dh options:MTLResourceStorageModeManaged] autorelease];</span>
<span class="line-added">254         [blitEncoder copyFromBuffer:buff</span>
<span class="line-added">255                 sourceOffset:0 sourceBytesPerRow:srcInfo-&gt;scanStride sourceBytesPerImage:srcInfo-&gt;scanStride * dh sourceSize:MTLSizeMake(dw, dh, 1)</span>
<span class="line-added">256                 toTexture:dest destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dx1, dy1, 0)];</span>
<span class="line-added">257         [blitEncoder endEncoding];</span>
<span class="line-added">258     }</span>
<span class="line-added">259 </span>
260     return result;
261 }
262 
263 /**
264  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
265  * destination MTL &quot;Surface&quot;.  This method is invoked from
266  * MTLBlitLoops_Blit().
267  */
268 
269 static void
270 MTLBlitSwToTextureViaPooledTexture(
271         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
272         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
273         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
274 {
275     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
276     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
277     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
278 
279     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
280     if (texHandle == nil) {
281         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
282         return;
283     }
284     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
285     [texHandle release];
286 
287     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
<span class="line-modified">288     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(mtlc, texBuff, srcInfo, rfi, 0, 0, sw, sh);</span>
289     if (useBlitEncoder) {
290         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
291         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
292                          sourceSlice:0
293                          sourceLevel:0
294                         sourceOrigin:MTLOriginMake(0, 0, 0)
295                           sourceSize:MTLSizeMake(sw, sh, 1)
296                            toTexture:dest
297                     destinationSlice:0
298                     destinationLevel:0
299                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
300         [blitEncoder endEncoding];
301     } else {
302         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
303                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
304     }
305 
306     if (swizzledTexture != nil) {
307         [swizzledTexture release];
308     }
</pre>
<hr />
<pre>
615                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
616                     texture, xform, [mtlc getCompositeDescription].cString,
617                     getSurfaceDescription(dstOps).cString, srcOps,
618                     sx2 - sx1, sy2 - sy1,
619                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
620                     sx1, sy1, sx2, sy2,
621                     dx1, dy1, dx2, dy2);
622 #endif //TRACE_BLIT
623 
624             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
625             const jboolean useReplaceRegion = texture ||
626                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
627                     &amp;&amp; !xform
628                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
629 
630             if (useReplaceRegion) {
631                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
632 #ifdef TRACE_BLIT
633                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
634 #endif //TRACE_BLIT
<span class="line-modified">635                     replaceTextureRegion(mtlc, dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);</span>
636                 } else {
637 #ifdef TRACE_BLIT
638                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
639 #endif //TRACE_BLIT
640                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
641                 }
642             } else { // !useReplaceRegion
643 #ifdef TRACE_BLIT
644                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
645 #endif //TRACE_BLIT
646                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
647             }
648         }
649         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
650     }
651     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
652 }
653 
654 /**
655  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLSurfaceData.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
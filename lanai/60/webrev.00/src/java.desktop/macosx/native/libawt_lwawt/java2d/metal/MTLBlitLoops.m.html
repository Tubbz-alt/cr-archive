<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jni.h&gt;
 29 #include &lt;jlong.h&gt;
 30 
 31 #include &quot;SurfaceData.h&quot;
 32 #include &quot;MTLBlitLoops.h&quot;
 33 #include &quot;MTLRenderQueue.h&quot;
 34 #include &quot;MTLSurfaceData.h&quot;
 35 #include &quot;MTLUtils.h&quot;
 36 #include &quot;GraphicsPrimitiveMgr.h&quot;
 37 
 38 #include &lt;stdlib.h&gt; // malloc
 39 #include &lt;string.h&gt; // memcpy
 40 #include &quot;IntArgbPre.h&quot;
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
 44 #ifdef DEBUG
 45 #define TRACE_ISOBLIT
 46 #define TRACE_BLIT
 47 #endif //DEBUG
 48 //#define DEBUG_ISOBLIT
 49 //#define DEBUG_BLIT
 50 
 51 typedef struct {
 52     MTLPixelFormat   format;
 53     jboolean hasAlpha;
 54     jboolean isPremult;
 55     const uint8_t * permuteMap;
 56 } MTLRasterFormatInfo;
 57 
 58 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 59 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 60 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
 61 const uint8_t permuteMap_argb[4] = { 0, 1, 2, 3 };
 62 
 63 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 64     for (int c = 0; c &lt; 4; ++c) {
 65         if (perm[c] == pos)
 66             return c;
 67     }
 68     return -1;
 69 }
 70 
 71 #define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))
 72 
 73 /**
 74  * This table contains the &quot;pixel formats&quot; for all system memory surfaces
 75  * that Metal is capable of handling, indexed by the &quot;PF_&quot; constants defined
 76  * in MTLLSurfaceData.java.  These pixel formats contain information that is
 77  * passed to Metal when copying from a system memory (&quot;Sw&quot;) surface to
 78  * an Metal surface
 79  */
 80 MTLRasterFormatInfo RasterFormatInfos[] = {
 81         { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, /* 0 - IntArgb      */ // Argb (in java notation)
 82         { MTLPixelFormatBGRA8Unorm, 1, 1, NULL }, /* 1 - IntArgbPre   */
 83         { MTLPixelFormatBGRA8Unorm, 0, 1, NULL }, /* 2 - IntRgb       */ // xrgb
 84         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_rgbx }, /* 3 - IntRgbx      */
 85         { MTLPixelFormatRGBA8Unorm, 0, 1, NULL }, /* 4 - IntBgr       */ // xbgr
 86         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_bgrx }, /* 5 - IntBgrx      */
 87 
 88 //        TODO: support 2-byte formats
 89 //        { GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV,
 90 //                2, 0, 1,                                     }, /* 7 - Ushort555Rgb */
 91 //        { GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1,
 92 //                2, 0, 1,                                     }, /* 8 - Ushort555Rgbx*/
 93 //        { GL_LUMINANCE, GL_UNSIGNED_BYTE,
 94 //                1, 0, 1,                                     }, /* 9 - ByteGray     */
 95 //        { GL_LUMINANCE, GL_UNSIGNED_SHORT,
 96 //                2, 0, 1,                                     }, /*10 - UshortGray   */
 97 //        { GL_BGR,  GL_UNSIGNED_BYTE,
 98 //                1, 0, 1,                                     }, /*11 - ThreeByteBgr */
 99 };
100 
101 extern void J2dTraceImpl(int level, jboolean cr, const char *string, ...);
102 
103 void fillTxQuad(
104         struct TxtVertex * txQuadVerts,
105         jint sx1, jint sy1, jint sx2, jint sy2, jint sw, jint sh,
106         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2, jdouble dw, jdouble dh
107 ) {
108     const float nsx1 = sx1/(float)sw;
109     const float nsy1 = sy1/(float)sh;
110     const float nsx2 = sx2/(float)sw;
111     const float nsy2 = sy2/(float)sh;
112 
113     txQuadVerts[0].position[0] = dx1;
114     txQuadVerts[0].position[1] = dy1;
115     txQuadVerts[0].txtpos[0]   = nsx1;
116     txQuadVerts[0].txtpos[1]   = nsy1;
117 
118     txQuadVerts[1].position[0] = dx2;
119     txQuadVerts[1].position[1] = dy1;
120     txQuadVerts[1].txtpos[0]   = nsx2;
121     txQuadVerts[1].txtpos[1]   = nsy1;
122 
123     txQuadVerts[2].position[0] = dx2;
124     txQuadVerts[2].position[1] = dy2;
125     txQuadVerts[2].txtpos[0]   = nsx2;
126     txQuadVerts[2].txtpos[1]   = nsy2;
127 
128     txQuadVerts[3].position[0] = dx2;
129     txQuadVerts[3].position[1] = dy2;
130     txQuadVerts[3].txtpos[0]   = nsx2;
131     txQuadVerts[3].txtpos[1]   = nsy2;
132 
133     txQuadVerts[4].position[0] = dx1;
134     txQuadVerts[4].position[1] = dy2;
135     txQuadVerts[4].txtpos[0]   = nsx1;
136     txQuadVerts[4].txtpos[1]   = nsy2;
137 
138     txQuadVerts[5].position[0] = dx1;
139     txQuadVerts[5].position[1] = dy1;
140     txQuadVerts[5].txtpos[0]   = nsx1;
141     txQuadVerts[5].txtpos[1]   = nsy1;
142 }
143 
144 //#define TRACE_drawTex2Tex
145 
146 void drawTex2Tex(MTLContext *mtlc,
147                         id&lt;MTLTexture&gt; src, id&lt;MTLTexture&gt; dst,
148                         jboolean isSrcOpaque, jboolean isDstOpaque, jint hint,
149                         jint sx1, jint sy1, jint sx2, jint sy2,
150                         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
151 {
152 #ifdef TRACE_drawTex2Tex
153     J2dRlsTraceLn2(J2D_TRACE_VERBOSE, &quot;drawTex2Tex: src tex=%p, dst tex=%p&quot;, src, dst);
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
156     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
157 #endif //TRACE_drawTex2Tex
158 
159     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
160                                                                      isSrcOpaque:isSrcOpaque
161                                                                      isDstOpaque:isDstOpaque
162                                                                    interpolation:hint
163     ];
164 
165     struct TxtVertex quadTxVerticesBuffer[6];
166     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
167 
168     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
169     [encoder setFragmentTexture:src atIndex: 0];
170     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
171 }
172 
173 static
174 id&lt;MTLTexture&gt; replaceTextureRegion(MTLContext *mtlc, id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {
175     const int dw = dx2 - dx1;
176     const int dh = dy2 - dy1;
177 
178     const void * raster = srcInfo-&gt;rasBase;
179     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;
180 
181     id&lt;MTLTexture&gt; result = nil;
182     if (rfi-&gt;permuteMap != NULL) {
183 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
184         if (@available(macOS 10.15, *)) {
185             @autoreleasepool {
186                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
187                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
188                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
189                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
190                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
191                         uint2swizzle(swzRed),
192                         uint2swizzle(swzGreen),
193                         uint2swizzle(swzBlue),
194                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
195                 );
196                 result = [dest
197                         newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm
198                         textureType:MTLTextureType2D
199                         levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)
200                         swizzle:swizzle];
201                 J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use swizzle for pooled]: %d, %d, %d, %d, hasA=%d&quot;,
202                             swizzle.red, swizzle.green, swizzle.blue, swizzle.alpha, rfi-&gt;hasAlpha);
203             }
204         } else
205 #endif // __MAC_10_15 &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
206         {
207             // perform raster conversion
208             // invoked only from rq-thread, so use static buffers
209             // but it&#39;s better to use thread-local buffers (or special buffer manager)
210             const int destRasterSize = dw*dh*4;
211 
212             static int bufferSize = 0;
213             static void * buffer = NULL;
214             if (buffer == NULL || bufferSize &lt; destRasterSize) {
215                 bufferSize = destRasterSize;
216                 buffer = realloc(buffer, bufferSize);
217             }
218             if (buffer == NULL) {
219                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
220                 bufferSize = 0;
221                 return nil;
222             }
223             vImage_Buffer srcBuf;
224             srcBuf.height = dh;
225             srcBuf.width = dw;
226             srcBuf.rowBytes = srcInfo-&gt;scanStride;
227             srcBuf.data = raster;
228 
229             vImage_Buffer destBuf;
230             destBuf.height = dh;
231             destBuf.width = dw;
232             destBuf.rowBytes = dw*4;
233             destBuf.data = buffer;
234 
235             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
236             raster = buffer;
237 
238             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
239                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
240         }
241     }
242 
243     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
244     if (result != nil)
245         dest = result;
246 
247     @autoreleasepool {
248         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
249 
250         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion scr (dw, dh) : [%d, %d] dest (dx1, dy1) =[%d, %d]&quot;,
251                     dw, dh, dx1, dy1);
252 
253         id &lt;MTLBuffer&gt; buff = [[mtlc.device newBufferWithBytes:raster length:srcInfo-&gt;scanStride * dh options:MTLResourceStorageModeManaged] autorelease];
254         [blitEncoder copyFromBuffer:buff
255                 sourceOffset:0 sourceBytesPerRow:srcInfo-&gt;scanStride sourceBytesPerImage:srcInfo-&gt;scanStride * dh sourceSize:MTLSizeMake(dw, dh, 1)
256                 toTexture:dest destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
257         [blitEncoder endEncoding];
258     }
259 
260     return result;
261 }
262 
263 /**
264  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
265  * destination MTL &quot;Surface&quot;.  This method is invoked from
266  * MTLBlitLoops_Blit().
267  */
268 
269 static void
270 MTLBlitSwToTextureViaPooledTexture(
271         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
272         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
273         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
274 {
275     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
276     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
277     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
278 
279     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
280     if (texHandle == nil) {
281         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
282         return;
283     }
284     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
285     [texHandle release];
286 
287     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
288     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(mtlc, texBuff, srcInfo, rfi, 0, 0, sw, sh);
289     if (useBlitEncoder) {
290         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
291         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
292                          sourceSlice:0
293                          sourceLevel:0
294                         sourceOrigin:MTLOriginMake(0, 0, 0)
295                           sourceSize:MTLSizeMake(sw, sh, 1)
296                            toTexture:dest
297                     destinationSlice:0
298                     destinationLevel:0
299                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
300         [blitEncoder endEncoding];
301     } else {
302         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
303                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
304     }
305 
306     if (swizzledTexture != nil) {
307         [swizzledTexture release];
308     }
309 }
310 
311 static
312 jboolean isIntegerAndUnscaled(
313         jint sx1, jint sy1, jint sx2, jint sy2,
314         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2
315 ) {
316     const jdouble epsilon = 0.0001f;
317 
318     // check that dx1,dy1 is integer
319     if (fabs(dx1 - (int)dx1) &gt; epsilon || fabs(dy1 - (int)dy1) &gt; epsilon) {
320         return JNI_FALSE;
321     }
322     // check that destSize equals srcSize
323     if (fabs(dx2 - dx1 - sx2 + sx1) &gt; epsilon || fabs(dy2 - dy1 - sy2 + sy1) &gt; epsilon) {
324         return JNI_FALSE;
325     }
326     return JNI_TRUE;
327 }
328 
329 static
330 jboolean clipDestCoords(
331         jdouble *dx1, jdouble *dy1, jdouble *dx2, jdouble *dy2,
332         jint *sx1, jint *sy1, jint *sx2, jint *sy2,
333         jint destW, jint destH, const MTLScissorRect * clipRect
334 ) {
335     // Trim destination rect by clip-rect (or dest.bounds)
336     const jint sw    = *sx2 - *sx1;
337     const jint sh    = *sy2 - *sy1;
338     const jdouble dw = *dx2 - *dx1;
339     const jdouble dh = *dy2 - *dy1;
340 
341     jdouble dcx1 = 0;
342     jdouble dcx2 = destW;
343     jdouble dcy1 = 0;
344     jdouble dcy2 = destH;
345     if (clipRect != NULL) {
346         if (clipRect-&gt;x &gt; dcx1)
347             dcx1 = clipRect-&gt;x;
348         const int maxX = clipRect-&gt;x + clipRect-&gt;width;
349         if (dcx2 &gt; maxX)
350             dcx2 = maxX;
351         if (clipRect-&gt;y &gt; dcy1)
352             dcy1 = clipRect-&gt;y;
353         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
354         if (dcy2 &gt; maxY)
355             dcy2 = maxY;
356 
357         if (dcx1 &gt;= dcx2) {
358             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
359             dcx1 = dcx2;
360         }
361         if (dcy1 &gt;= dcy2) {
362             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
363             dcy1 = dcy2;
364         }
365     }
366     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
367         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
368         J2dTraceLn4(J2D_TRACE_INFO, &quot;\tdx2=%1.4f &lt;= dcx1=%1.4f || *dx1=%1.4f &gt;= dcx2=%1.4f&quot;, *dx2, dcx1, *dx1, dcx2);
369         J2dTraceLn4(J2D_TRACE_INFO, &quot;\t*dy2=%1.4f &lt;= dcy1=%1.4f || *dy1=%1.4f &gt;= dcy2=%1.4f&quot;, *dy2, dcy1, *dy1, dcy2);
370         return JNI_FALSE;
371     }
372     if (*dx1 &lt; dcx1) {
373         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f | sx1+=%d&quot;, *dx1, dcx1, (jint)((dcx1 - *dx1) * (sw/dw)));
374         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
375         *dx1 = dcx1;
376     }
377     if (*dx2 &gt; dcx2) {
378         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f | sx2-=%d&quot;, *dx2, dcx2, (jint)((*dx2 - dcx2) * (sw/dw)));
379         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
380         *dx2 = dcx2;
381     }
382     if (*dy1 &lt; dcy1) {
383         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f | sy1+=%d&quot;, *dy1, dcy1, (jint)((dcy1 - *dy1) * (sh/dh)));
384         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
385         *dy1 = dcy1;
386     }
387     if (*dy2 &gt; dcy2) {
388         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f | sy2-=%d&quot;, *dy2, dcy2, (jint)((*dy2 - dcy2) * (sh/dh)));
389         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
390         *dy2 = dcy2;
391     }
392     return JNI_TRUE;
393 }
394 
395 /**
396  * General blit method for copying a native MTL surface to another MTL &quot;Surface&quot;.
397  * Parameter texture == true forces to use &#39;texture&#39; codepath (dest coordinates will always be integers).
398  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
399  */
400 void
401 MTLBlitLoops_IsoBlit(JNIEnv *env,
402                      MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
403                      jboolean xform, jint hint, jboolean texture,
404                      jint sx1, jint sy1, jint sx2, jint sy2,
405                      jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
406 {
407     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
408     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
409 
410     RETURN_IF_NULL(mtlc);
411     RETURN_IF_NULL(srcOps);
412     RETURN_IF_NULL(dstOps);
413 
414     id&lt;MTLTexture&gt; srcTex = srcOps-&gt;pTexture;
415     id&lt;MTLTexture&gt; dstTex = dstOps-&gt;pTexture;
416     if (srcTex == nil || srcTex == nil) {
417         J2dTraceLn2(J2D_TRACE_ERROR, &quot;MTLBlitLoops_IsoBlit: surface is null (stex=%p, dtex=%p)&quot;, srcTex, dstTex);
418         return;
419     }
420 
421     const jint sw    = sx2 - sx1;
422     const jint sh    = sy2 - sy1;
423     const jdouble dw = dx2 - dx1;
424     const jdouble dh = dy2 - dy1;
425 
426     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
427         J2dTraceLn4(J2D_TRACE_WARNING, &quot;MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d&quot;, sw, sh, dw, dh);
428         return;
429     }
430 
431 #ifdef DEBUG_ISOBLIT
432     if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {
433         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
434                 &quot;MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
435                 xform, mtlc.useTransform, texture);
436     }
437 #endif // DEBUG_ISOBLIT
438 
439     clipDestCoords(
440             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
441             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
442             dstTex.width, dstTex.height, texture ? NULL : [mtlc.clip getRect]
443     );
444 
445     SurfaceDataBounds bounds;
446     bounds.x1 = sx1;
447     bounds.y1 = sy1;
448     bounds.x2 = sx2;
449     bounds.y2 = sy2;
450     SurfaceData_IntersectBoundsXYXY(&amp;bounds, 0, 0, srcOps-&gt;width, srcOps-&gt;height);
451 
452     if (bounds.x2 &lt;= bounds.x1 || bounds.y2 &lt;= bounds.y1) {
453         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_IsoBlit: source rectangle doesn&#39;t intersect with source surface bounds&quot;);
454         J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d&quot;, sx1, sy1, sx2, sy2, srcOps-&gt;width, srcOps-&gt;height);
455         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
456         return;
457     }
458 
459     if (bounds.x1 != sx1) {
460         dx1 += (bounds.x1 - sx1) * (dw / sw);
461         sx1 = bounds.x1;
462     }
463     if (bounds.y1 != sy1) {
464         dy1 += (bounds.y1 - sy1) * (dh / sh);
465         sy1 = bounds.y1;
466     }
467     if (bounds.x2 != sx2) {
468         dx2 += (bounds.x2 - sx2) * (dw / sw);
469         sx2 = bounds.x2;
470     }
471     if (bounds.y2 != sy2) {
472         dy2 += (bounds.y2 - sy2) * (dh / sh);
473         sy2 = bounds.y2;
474     }
475 
476 #ifdef TRACE_ISOBLIT
477     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
478          &quot;MTLBlitLoops_IsoBlit [tx=%d, xf=%d, AC=%s]: src=%s, dst=%s | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
479          texture, xform, [mtlc getCompositeDescription].cString,
480          getSurfaceDescription(srcOps).cString, getSurfaceDescription(dstOps).cString,
481          sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
482 #endif //TRACE_ISOBLIT
483 
484     if (!texture &amp;&amp; !xform
485         &amp;&amp; [mtlc isBlendingDisabled:srcOps-&gt;isOpaque]
486         &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)
487         &amp;&amp; (dstOps-&gt;isOpaque || !srcOps-&gt;isOpaque)
488     ) {
489 #ifdef TRACE_ISOBLIT
490         J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via blitEncoder]&quot;);
491 #endif //TRACE_ISOBLIT
492 
493         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
494         [blitEncoder copyFromTexture:srcTex
495                          sourceSlice:0
496                          sourceLevel:0
497                         sourceOrigin:MTLOriginMake(sx1, sy1, 0)
498                           sourceSize:MTLSizeMake(sx2 - sx1, sy2 - sy1, 1)
499                            toTexture:dstTex
500                     destinationSlice:0
501                     destinationLevel:0
502                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
503         [blitEncoder endEncoding];
504         return;
505     }
506 
507 #ifdef TRACE_ISOBLIT
508     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via sampling]&quot;);
509 #endif //TRACE_ISOBLIT
510     drawTex2Tex(mtlc, srcTex, dstTex,
511             [mtlc isBlendingDisabled:srcOps-&gt;isOpaque],
512             dstOps-&gt;isOpaque, hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
513 }
514 
515 /**
516  * General blit method for copying a system memory (&quot;Sw&quot;) surface to a native MTL surface.
517  * Parameter texture == true only in SwToTextureBlit (straight copy from sw to texture), dest coordinates will always be integers.
518  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
519  */
520 void
521 MTLBlitLoops_Blit(JNIEnv *env,
522                   MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
523                   jboolean xform, jint hint,
524                   jint srctype, jboolean texture,
525                   jint sx1, jint sy1, jint sx2, jint sy2,
526                   jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
527 {
528     SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);
529     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
530 
531     RETURN_IF_NULL(mtlc);
532     RETURN_IF_NULL(srcOps);
533     RETURN_IF_NULL(dstOps);
534 
535     id&lt;MTLTexture&gt; dest = dstOps-&gt;pTexture;
536     if (dest == NULL) {
537         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: dest is null&quot;);
538         return;
539     }
540     if (srctype &lt; 0 || srctype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
541         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: source pixel format %d isn&#39;t supported&quot;, srctype);
542         return;
543     }
544     const jint sw    = sx2 - sx1;
545     const jint sh    = sy2 - sy1;
546     const jdouble dw = dx2 - dx1;
547     const jdouble dh = dy2 - dy1;
548 
549     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
550         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: invalid dimensions&quot;);
551         return;
552     }
553 
554 #ifdef DEBUG_BLIT
555     if (
556         (xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)
557         || (xform &amp;&amp; texture)
558     ) {
559         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
560                 &quot;MTLBlitLoops_Blit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
561                 xform, mtlc.useTransform, texture);
562     }
563     if (texture) {
564         if (!isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)) {
565             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
566                     &quot;MTLBlitLoops_Blit state error: texture=true, but src and dst dimensions aren&#39;t equal or dest coords aren&#39;t integers&quot;);
567         }
568         if (!dstOps-&gt;isOpaque &amp;&amp; !RasterFormatInfos[srctype].hasAlpha) {
569             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
570                     &quot;MTLBlitLoops_Blit state error: texture=true, but dest has alpha and source hasn&#39;t alpha, can&#39;t use texture-codepath&quot;);
571         }
572     }
573 #endif // DEBUG_BLIT
574 
575     clipDestCoords(
576             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
577             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
578             dest.width, dest.height, texture ? NULL : [mtlc.clip getRect]
579     );
580 
581     SurfaceDataRasInfo srcInfo;
582     srcInfo.bounds.x1 = sx1;
583     srcInfo.bounds.y1 = sy1;
584     srcInfo.bounds.x2 = sx2;
585     srcInfo.bounds.y2 = sy2;
586 
587     // NOTE: This function will modify the contents of the bounds field to represent the maximum available raster data.
588     if (srcOps-&gt;Lock(env, srcOps, &amp;srcInfo, SD_LOCK_READ) != SD_SUCCESS) {
589         J2dTraceLn(J2D_TRACE_WARNING, &quot;MTLBlitLoops_Blit: could not acquire lock&quot;);
590         return;
591     }
592 
593     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp; srcInfo.bounds.y2 &gt; srcInfo.bounds.y1) {
594         srcOps-&gt;GetRasInfo(env, srcOps, &amp;srcInfo);
595         if (srcInfo.rasBase) {
596             if (srcInfo.bounds.x1 != sx1) {
597                 const int dx = srcInfo.bounds.x1 - sx1;
598                 dx1 += dx * (dw / sw);
599             }
600             if (srcInfo.bounds.y1 != sy1) {
601                 const int dy = srcInfo.bounds.y1 - sy1;
602                 dy1 += dy * (dh / sh);
603             }
604             if (srcInfo.bounds.x2 != sx2) {
605                 const int dx = srcInfo.bounds.x2 - sx2;
606                 dx2 += dx * (dw / sw);
607             }
608             if (srcInfo.bounds.y2 != sy2) {
609                 const int dy = srcInfo.bounds.y2 - sy2;
610                 dy2 += dy * (dh / sh);
611             }
612 
613 #ifdef TRACE_BLIT
614             J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
615                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
616                     texture, xform, [mtlc getCompositeDescription].cString,
617                     getSurfaceDescription(dstOps).cString, srcOps,
618                     sx2 - sx1, sy2 - sy1,
619                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
620                     sx1, sy1, sx2, sy2,
621                     dx1, dy1, dx2, dy2);
622 #endif //TRACE_BLIT
623 
624             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
625             const jboolean useReplaceRegion = texture ||
626                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
627                     &amp;&amp; !xform
628                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
629 
630             if (useReplaceRegion) {
631                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
632 #ifdef TRACE_BLIT
633                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
634 #endif //TRACE_BLIT
635                     replaceTextureRegion(mtlc, dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);
636                 } else {
637 #ifdef TRACE_BLIT
638                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
639 #endif //TRACE_BLIT
640                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
641                 }
642             } else { // !useReplaceRegion
643 #ifdef TRACE_BLIT
644                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
645 #endif //TRACE_BLIT
646                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
647             }
648         }
649         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
650     }
651     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
652 }
653 
654 /**
655  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
656  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
657  */
658 void
659 MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,
660                              jlong pSrcOps, jlong pDstOps, jint dsttype,
661                              jint srcx, jint srcy, jint dstx, jint dsty,
662                              jint width, jint height)
663 {
664     J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: sx=%d sy=%d w=%d h=%d dx=%d dy=%d&quot;, srcx, srcy, width, height, dstx, dsty);
665 
666     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
667     SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);
668     SurfaceDataRasInfo srcInfo, dstInfo;
669 
670     if (dsttype &lt; 0 || dsttype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
671         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: destination pixel format %d isn&#39;t supported&quot;, dsttype);
672         return;
673     }
674 
675     if (width &lt;= 0 || height &lt;= 0) {
676         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: dimensions are non-positive&quot;);
677         return;
678     }
679 
680     RETURN_IF_NULL(srcOps);
681     RETURN_IF_NULL(dstOps);
682     RETURN_IF_NULL(mtlc);
683 
684     srcInfo.bounds.x1 = srcx;
685     srcInfo.bounds.y1 = srcy;
686     srcInfo.bounds.x2 = srcx + width;
687     srcInfo.bounds.y2 = srcy + height;
688     dstInfo.bounds.x1 = dstx;
689     dstInfo.bounds.y1 = dsty;
690     dstInfo.bounds.x2 = dstx + width;
691     dstInfo.bounds.y2 = dsty + height;
692 
693     if (dstOps-&gt;Lock(env, dstOps, &amp;dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {
694         J2dTraceLn(J2D_TRACE_WARNING,&quot;MTLBlitLoops_SurfaceToSwBlit: could not acquire dst lock&quot;);
695         return;
696     }
697 
698     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,
699                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);
700     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,
701                                     srcx - dstx, srcy - dsty);
702 
703     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;
704         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)
705     {
706         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);
707         if (dstInfo.rasBase) {
708             void *pDst = dstInfo.rasBase;
709 
710             srcx = srcInfo.bounds.x1;
711             srcy = srcInfo.bounds.y1;
712             dstx = dstInfo.bounds.x1;
713             dsty = dstInfo.bounds.y1;
714             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
715             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
716 
717             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
718             pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);
719 
720             // this accounts for lower-left origin of the source region
721             srcx = srcOps-&gt;xOffset + srcx;
722             srcy = srcOps-&gt;yOffset + srcOps-&gt;height - srcy - height;
723             const int srcLength = width * height * 4; // NOTE: assume that src format is MTLPixelFormatBGRA8Unorm
724 
725 #ifdef DEBUG
726             void *pDstEnd = dstInfo.rasBase + (height - 1)*dstInfo.scanStride + width*dstInfo.pixelStride;
727             if (pDst + srcLength &gt; pDstEnd) {
728                 J2dTraceLn6(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: length mismatch: dstx=%d, dsty=%d, w=%d, h=%d, pixStride=%d, scanStride=%d&quot;,
729                         dstx, dsty, width, height, dstInfo.pixelStride, dstInfo.scanStride);
730                 return;
731             }
732 #endif //DEBUG
733 
734             // Create MTLBuffer (or use static)
735             MTLRasterFormatInfo rfi = RasterFormatInfos[dsttype];
736             const jboolean directCopy = rfi.permuteMap == NULL;
737 
738             id&lt;MTLBuffer&gt; mtlbuf;
739 #ifdef USE_STATIC_BUFFER
740             if (directCopy) {
741                 // NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API
742                 // mtlbuf = [mtlc.device
743                 //          newBufferWithBytesNoCopy:pDst
744                 //                            length:(NSUInteger) srcLength
745                 //                           options:MTLResourceCPUCacheModeDefaultCache
746                 //                       deallocator:nil];
747                 //
748                 // see https://developer.apple.com/documentation/metal/mtldevice/1433382-newbufferwithbytesnocopy?language=objc
749                 //
750                 // The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.
751                 // The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.
752                 // Memory allocated by malloc is specifically disallowed.
753             }
754 
755             static id&lt;MTLBuffer&gt; mtlIntermediateBuffer = nil; // need to reimplement with MTLBufferManager
756             if (mtlIntermediateBuffer == nil || mtlIntermediateBuffer.length &lt; srcLength) {
757                 if (mtlIntermediateBuffer != nil) {
758                     [mtlIntermediateBuffer release];
759                 }
760                 mtlIntermediateBuffer = [mtlc.device newBufferWithLength:srcLength options:MTLResourceCPUCacheModeDefaultCache];
761             }
762             mtlbuf = mtlIntermediateBuffer;
763 #else // USE_STATIC_BUFFER
764             mtlbuf = [mtlc.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];
765 #endif // USE_STATIC_BUFFER
766 
767             // Read from surface into MTLBuffer
768             // NOTE: using of separate blitCommandBuffer can produce errors (draw into surface (with general cmd-buf)
769             // can be unfinished when reading raster from blit cmd-buf).
770             // Consider to use [mtlc.encoderManager createBlitEncoder] and [mtlc commitCommandBuffer:JNI_TRUE];
771             J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: source texture %p&quot;, srcOps-&gt;pTexture);
772 
773             id&lt;MTLCommandBuffer&gt; cb = [mtlc createCommandBuffer];
774             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
775             [blitEncoder synchronizeTexture:srcOps-&gt;pTexture slice:0 level:0];
776             [blitEncoder copyFromTexture:srcOps-&gt;pTexture
777                             sourceSlice:0
778                             sourceLevel:0
779                            sourceOrigin:MTLOriginMake(srcx, srcy, 0)
780                              sourceSize:MTLSizeMake(width, height, 1)
781                                toBuffer:mtlbuf
782                       destinationOffset:0 /*offset already taken in: pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride)*/
783                  destinationBytesPerRow:width*4
784                destinationBytesPerImage:width * height*4];
785             [blitEncoder endEncoding];
786 
787             // Commit and wait for reading complete
788             [cb commit];
789             [cb waitUntilCompleted];
790 
791             // Perform conversion if necessary
792             if (directCopy) {
793                 memcpy(pDst, mtlbuf.contents, srcLength);
794             } else {
795                 J2dTraceLn6(J2D_TRACE_VERBOSE,&quot;MTLBlitLoops_SurfaceToSwBlit: dsttype=%d, raster conversion will be performed, dest rfi: %d, %d, %d, %d, hasA=%d&quot;,
796                             dsttype, rfi.permuteMap[0], rfi.permuteMap[1], rfi.permuteMap[2], rfi.permuteMap[3], rfi.hasAlpha);
797 
798                 // perform raster conversion: mtlIntermediateBuffer(8888) -&gt; pDst(rfi)
799                 // invoked only from rq-thread, so use static buffers
800                 // but it&#39;s better to use thread-local buffers (or special buffer manager)
801                 vImage_Buffer srcBuf;
802                 srcBuf.height = height;
803                 srcBuf.width = width;
804                 srcBuf.rowBytes = 4*width;
805                 srcBuf.data = mtlbuf.contents;
806 
807                 vImage_Buffer destBuf;
808                 destBuf.height = height;
809                 destBuf.width = width;
810                 destBuf.rowBytes = dstInfo.scanStride;
811                 destBuf.data = pDst;
812 
813                 vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi.permuteMap, kvImageNoFlags);
814             }
815 #ifndef USE_STATIC_BUFFER
816             [mtlbuf release];
817 #endif // USE_STATIC_BUFFER
818         }
819         SurfaceData_InvokeRelease(env, dstOps, &amp;dstInfo);
820     }
821     SurfaceData_InvokeUnlock(env, dstOps, &amp;dstInfo);
822 }
823 
824 void
825 MTLBlitLoops_CopyArea(JNIEnv *env,
826                       MTLContext *mtlc, BMTLSDOps *dstOps,
827                       jint x, jint y, jint width, jint height,
828                       jint dx, jint dy)
829 {
830 #ifdef DEBUG
831     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, &quot;MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -&gt; dst (%d, %d)&quot;,
832             dstOps, dstOps-&gt;pTexture, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).width, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).height, x, y, width, height, dx, dy);
833 #endif //DEBUG
834 
835     @autoreleasepool {
836     id&lt;MTLCommandBuffer&gt; cb = [mtlc createCommandBuffer];
837     id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
838 
839     // Create an intrermediate buffer
840     int totalBuffsize = width * height * 4;
841     id &lt;MTLBuffer&gt; buff = [[mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate] autorelease];
842 
843     [blitEncoder copyFromTexture:dstOps-&gt;pTexture
844             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
845              toBuffer:buff destinationOffset:0 destinationBytesPerRow:(width * 4) destinationBytesPerImage:totalBuffsize];
846 
847     [blitEncoder copyFromBuffer:buff
848             sourceOffset:0 sourceBytesPerRow:width*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(width, height, 1)
849             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
850     [blitEncoder endEncoding];
851 
852     [cb commit];
853     //[cb waitUntilCompleted];
854 
855     /*[blitEncoder
856             copyFromTexture:dstOps-&gt;pTexture
857             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
858             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
859     [blitEncoder endEncoding];*/
860 
861     }
862     // TODO:
863     //  1. check rect bounds
864     //  2. support CopyArea with extra-alpha (and with custom Composite if necessary)
865 }
866 
867 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
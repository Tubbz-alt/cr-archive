diff a/src/demo/share/java2d/RenderPerfTest/src/renderperf/RenderPerfTest.java b/src/demo/share/java2d/RenderPerfTest/src/renderperf/RenderPerfTest.java
--- a/src/demo/share/java2d/RenderPerfTest/src/renderperf/RenderPerfTest.java
+++ b/src/demo/share/java2d/RenderPerfTest/src/renderperf/RenderPerfTest.java
@@ -201,11 +201,11 @@
             super(n, r);
         }
 
         @Override
         public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {
-            if ((id % 5) == 0) {
+            if ((id % 10) == 0) {
                 g2d.setColor(colors[id % colors.length]);
                 g2d.setClip(new Ellipse2D.Double((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r)));
                 g2d.fillRect((int) (x[id] - 2 * r), (int) (y[id] - 2 * r), (int) (4 * r), (int) (4 * r));
             }
         }
@@ -345,11 +345,11 @@
         ClipFlatBoxParticleRenderer(int n, float r) {
             super(n, r);
         }
         @Override
         public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {
-            if ((id % 5) == 0) {
+            if ((id % 10) == 0) {
                 g2d.setColor(colors[id % colors.length]);
                 g2d.setClip((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));
                 g2d.fillRect((int) (x[id] - 2 * r), (int) (y[id] - 2 * r), (int) (4 * r), (int) (4 * r));
             }
         }
diff a/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal b/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal
--- a/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal
+++ b/src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal
@@ -430,5 +430,14 @@
 
     // gamma re-adjust the resulting color (alpha is always set to 1.0)
     return float4(pow(result.rgb, invgamma), 1.0);
 
 }
+// Compute shader to transfer clipping data to the texture used for manual clipping in
+// aa_frag_txt shader
+kernel void stencil2tex(const device uchar *imageBuffer [[buffer(0)]],
+    device uchar4 *outputBuffer [[buffer(1)]],
+    uint gid [[thread_position_in_grid]])
+{
+    uchar p = imageBuffer[gid];
+    outputBuffer[gid] = uchar4(p, p, p, p);
+}
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m
@@ -333,22 +333,37 @@
     if (!_aaClipReady) {
 
         @autoreleasepool {
 
             id <MTLCommandBuffer> cb = [_mtlc createBlitCommandBuffer];
-            id <MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];
+            id <MTLComputeCommandEncoder> computeEncoder = [cb computeCommandEncoder];
+            id<MTLComputePipelineState> computePipelineState = [_mtlc.pipelineStateStorage getComputePipelineState:@"stencil2tex"];
             id <MTLBuffer> _stencilDataBufRef = _dstOps->pStencilDataBuf;
             id <MTLBuffer> _stencilAADataBufRef = _dstOps->pAAStencilDataBuf;
             NSUInteger width = _stencilAADataRef.width;
             NSUInteger height = _stencilAADataRef.height;
             NSUInteger size = width * height;
 
-            for (int i = 0; i < size; i++) {
-                unsigned char c = ((unsigned char *) (((id <MTLBuffer>) (_stencilDataBufRef)).contents))[i];
-                ((jint *) (_stencilAADataBufRef.contents))[i] = c + (c << 8) + (c << 16) + (c << 24);
+            [computeEncoder setComputePipelineState:computePipelineState];
+
+            [computeEncoder setBuffer:_stencilDataBufRef offset:0 atIndex:0];
+            [computeEncoder setBuffer:_stencilAADataBufRef offset:0 atIndex:1];
+            NSUInteger threadGroupSize = computePipelineState.maxTotalThreadsPerThreadgroup;
+            if (threadGroupSize > _stencilDataBufRef.length)
+            {
+                threadGroupSize = _stencilDataBufRef.length;
             }
 
+            MTLSize threadgroupCounts = MTLSizeMake(threadGroupSize, 1, 1);
+            MTLSize threadgroups = MTLSizeMake(_stencilDataBufRef.length / threadGroupSize,
+                                               1, 1);
+            [computeEncoder dispatchThreadgroups:threadgroups
+                           threadsPerThreadgroup:threadgroupCounts];
+            [computeEncoder endEncoding];
+
+            id <MTLBlitCommandEncoder> blitEncoder = [cb blitCommandEncoder];
+
             [blitEncoder copyFromBuffer:_stencilAADataBufRef
                            sourceOffset:0
                       sourceBytesPerRow:width * 4
                     sourceBytesPerImage:size * 4
                              sourceSize:MTLSizeMake(width, height, 1)
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.h
@@ -15,10 +15,11 @@
 @private
 
 id<MTLDevice>       device;
 id<MTLLibrary>      library;
 NSMutableDictionary<NSString*, id<MTLFunction>> * shaders;
+NSMutableDictionary<NSString*, id<MTLComputePipelineState>> * computeStates;
 }
 
 @property (readwrite, assign) id<MTLDevice> device;
 @property (readwrite, retain) id<MTLLibrary> library;
 @property (readwrite, retain) NSMutableDictionary<NSString*, id<MTLFunction>> * shaders;
@@ -35,10 +36,12 @@
                                fragmentShaderId:(NSString *)fragmentShaderId
                                       composite:(MTLComposite*)composite
                                   renderOptions:(const RenderOptions *)renderOptions
                                   stencilNeeded:(bool)stencilNeeded;
 
+- (id<MTLComputePipelineState>) getComputePipelineState:(NSString *)computeShaderId;
+
 - (id<MTLFunction>) getShader:(NSString *)name;
 @end
 
 
 #endif // MTLPipelineStatesStorage_h_Included
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
@@ -31,10 +31,11 @@
         NSLog(@"Failed to load library. error %@", error);
         exit(0);
     }
     self.shaders = [NSMutableDictionary dictionaryWithCapacity:10];
     self.states = [NSMutableDictionary dictionaryWithCapacity:10];
+    computeStates = [[NSMutableDictionary dictionaryWithCapacity:10] retain] ;
     return self;
 }
 
 - (NSPointerArray * ) getSubStates:(NSString *)vertexShaderId fragmentShader:(NSString *)fragmentShaderId {
     NSMutableDictionary * vSubStates = states[vertexShaderId];
@@ -172,18 +173,40 @@
     }
 
     return result;
 }
 
+- (id<MTLComputePipelineState>) getComputePipelineState:(NSString *)computeShaderId {
+    id<MTLComputePipelineState> result = computeStates[computeShaderId];
+    if (result == nil) {
+        id <MTLFunction> computeShader = [self getShader:computeShaderId];
+        @autoreleasepool {
+            NSError *error = nil;
+            result = (id <MTLComputePipelineState>) [[self.device newComputePipelineStateWithFunction:computeShader error:&error] autorelease];
+            if (result == nil) {
+                NSLog(@"Failed to create pipeline state, error %@", error);
+                exit(0);
+            }
+            computeStates[computeShaderId] = result;
+        }
+    }
+    return result;
+}
+
 - (id<MTLFunction>) getShader:(NSString *)name {
     id<MTLFunction> result = [self.shaders valueForKey:name];
     if (result == nil) {
         result = [[self.library newFunctionWithName:name] autorelease];
         [self.shaders setValue:result forKey:name];
     }
     return result;
 }
+
+- (void) dealloc {
+    [super dealloc];
+    [computeStates release];
+}
 @end
 
 static void setBlendingFactors(
         MTLRenderPipelineColorAttachmentDescriptor * cad,
         MTLComposite* composite,
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLSurfaceData.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLSurfaceData.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLSurfaceData.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLSurfaceData.m
@@ -76,12 +76,12 @@
             [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatR8Uint width:width height:height mipmapped:NO];
         stencilDataDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead;
         stencilDataDescriptor.storageMode = MTLStorageModePrivate;
         bmtlsdo->pStencilData = [ctx.device newTextureWithDescriptor:stencilDataDescriptor];
         bmtlsdo->pAAStencilData = [ctx.device newTextureWithDescriptor:textureDescriptor];
-        bmtlsdo->pStencilDataBuf = [ctx.device newBufferWithLength:width*height options:MTLResourceStorageModeShared];
-        bmtlsdo->pAAStencilDataBuf = [ctx.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];
+        bmtlsdo->pStencilDataBuf = [ctx.device newBufferWithLength:width*height options:MTLResourceStorageModePrivate];
+        bmtlsdo->pAAStencilDataBuf = [ctx.device newBufferWithLength:width*height*4 options:MTLResourceStorageModePrivate];
 
 
         MTLTextureDescriptor *stencilTextureDescriptor =
             [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatStencil8 width:width height:height mipmapped:NO];
         stencilTextureDescriptor.usage = MTLTextureUsageRenderTarget | MTLTextureUsageShaderRead | MTLTextureUsageShaderWrite;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/JList.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing;
  26 
  27 import java.awt.*;
  28 import java.awt.event.*;
  29 
  30 import java.util.Vector;
  31 import java.util.Locale;
  32 import java.util.ArrayList;
  33 import java.util.Collections;
  34 import java.util.List;
  35 
  36 import java.beans.JavaBean;
  37 import java.beans.BeanProperty;
  38 import java.beans.PropertyChangeEvent;
  39 import java.beans.PropertyChangeListener;
  40 import java.beans.Transient;
  41 
  42 import javax.swing.event.*;
  43 import javax.accessibility.*;
  44 import javax.swing.plaf.*;
  45 import javax.swing.text.Position;
  46 
  47 import java.io.ObjectOutputStream;
  48 import java.io.IOException;
  49 import java.io.Serializable;
  50 
  51 import sun.awt.AWTAccessor;
  52 import sun.awt.AWTAccessor.MouseEventAccessor;
  53 import sun.swing.SwingUtilities2;
  54 import sun.swing.SwingUtilities2.Section;
  55 import static sun.swing.SwingUtilities2.Section.*;
  56 
  57 /**
  58  * A component that displays a list of objects and allows the user to select
  59  * one or more items. A separate model, {@code ListModel}, maintains the
  60  * contents of the list.
  61  * &lt;p&gt;
  62  * It&#39;s easy to display an array or Vector of objects, using the {@code JList}
  63  * constructor that automatically builds a read-only {@code ListModel} instance
  64  * for you:
  65  * &lt;pre&gt;
  66  * {@code
  67  * // Create a JList that displays strings from an array
  68  *
  69  * String[] data = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;};
  70  * JList&lt;String&gt; myList = new JList&lt;String&gt;(data);
  71  *
  72  * // Create a JList that displays the superclasses of JList.class, by
  73  * // creating it with a Vector populated with this data
  74  *
  75  * Vector&lt;Class&lt;?&gt;&gt; superClasses = new Vector&lt;Class&lt;?&gt;&gt;();
  76  * Class&lt;JList&gt; rootClass = javax.swing.JList.class;
  77  * for(Class&lt;?&gt; cls = rootClass; cls != null; cls = cls.getSuperclass()) {
  78  *     superClasses.addElement(cls);
  79  * }
  80  * JList&lt;Class&lt;?&gt;&gt; myList = new JList&lt;Class&lt;?&gt;&gt;(superClasses);
  81  *
  82  * // The automatically created model is stored in JList&#39;s &quot;model&quot;
  83  * // property, which you can retrieve
  84  *
  85  * ListModel&lt;Class&lt;?&gt;&gt; model = myList.getModel();
  86  * for(int i = 0; i &lt; model.getSize(); i++) {
  87  *     System.out.println(model.getElementAt(i));
  88  * }
  89  * }
  90  * &lt;/pre&gt;
  91  * &lt;p&gt;
  92  * A {@code ListModel} can be supplied directly to a {@code JList} by way of a
  93  * constructor or the {@code setModel} method. The contents need not be static -
  94  * the number of items, and the values of items can change over time. A correct
  95  * {@code ListModel} implementation notifies the set of
  96  * {@code javax.swing.event.ListDataListener}s that have been added to it, each
  97  * time a change occurs. These changes are characterized by a
  98  * {@code javax.swing.event.ListDataEvent}, which identifies the range of list
  99  * indices that have been modified, added, or removed. {@code JList}&#39;s
 100  * {@code ListUI} is responsible for keeping the visual representation up to
 101  * date with changes, by listening to the model.
 102  * &lt;p&gt;
 103  * Simple, dynamic-content, {@code JList} applications can use the
 104  * {@code DefaultListModel} class to maintain list elements. This class
 105  * implements the {@code ListModel} interface and also provides a
 106  * &lt;code&gt;java.util.Vector&lt;/code&gt;-like API. Applications that need a more
 107  * custom &lt;code&gt;ListModel&lt;/code&gt; implementation may instead wish to subclass
 108  * {@code AbstractListModel}, which provides basic support for managing and
 109  * notifying listeners. For example, a read-only implementation of
 110  * {@code AbstractListModel}:
 111  * &lt;pre&gt;
 112  * {@code
 113  * // This list model has about 2^16 elements.  Enjoy scrolling.
 114  *
 115  * ListModel&lt;String&gt; bigData = new AbstractListModel&lt;String&gt;() {
 116  *     public int getSize() { return Short.MAX_VALUE; }
 117  *     public String getElementAt(int index) { return &quot;Index &quot; + index; }
 118  * };
 119  * }
 120  * &lt;/pre&gt;
 121  * &lt;p&gt;
 122  * The selection state of a {@code JList} is managed by another separate
 123  * model, an instance of {@code ListSelectionModel}. {@code JList} is
 124  * initialized with a selection model on construction, and also contains
 125  * methods to query or set this selection model. Additionally, {@code JList}
 126  * provides convenient methods for easily managing the selection. These methods,
 127  * such as {@code setSelectedIndex} and {@code getSelectedValue}, are cover
 128  * methods that take care of the details of interacting with the selection
 129  * model. By default, {@code JList}&#39;s selection model is configured to allow any
 130  * combination of items to be selected at a time; selection mode
 131  * {@code MULTIPLE_INTERVAL_SELECTION}. The selection mode can be changed
 132  * on the selection model directly, or via {@code JList}&#39;s cover method.
 133  * Responsibility for updating the selection model in response to user gestures
 134  * lies with the list&#39;s {@code ListUI}.
 135  * &lt;p&gt;
 136  * A correct {@code ListSelectionModel} implementation notifies the set of
 137  * {@code javax.swing.event.ListSelectionListener}s that have been added to it
 138  * each time a change to the selection occurs. These changes are characterized
 139  * by a {@code javax.swing.event.ListSelectionEvent}, which identifies the range
 140  * of the selection change.
 141  * &lt;p&gt;
 142  * The preferred way to listen for changes in list selection is to add
 143  * {@code ListSelectionListener}s directly to the {@code JList}. {@code JList}
 144  * then takes care of listening to the selection model and notifying your
 145  * listeners of change.
 146  * &lt;p&gt;
 147  * Responsibility for listening to selection changes in order to keep the list&#39;s
 148  * visual representation up to date lies with the list&#39;s {@code ListUI}.
 149  * &lt;p&gt;
 150  * &lt;a id=&quot;renderer&quot;&gt;&lt;/a&gt;
 151  * Painting of cells in a {@code JList} is handled by a delegate called a
 152  * cell renderer, installed on the list as the {@code cellRenderer} property.
 153  * The renderer provides a {@code java.awt.Component} that is used
 154  * like a &quot;rubber stamp&quot; to paint the cells. Each time a cell needs to be
 155  * painted, the list&#39;s {@code ListUI} asks the cell renderer for the component,
 156  * moves it into place, and has it paint the contents of the cell by way of its
 157  * {@code paint} method. A default cell renderer, which uses a {@code JLabel}
 158  * component to render, is installed by the lists&#39;s {@code ListUI}. You can
 159  * substitute your own renderer using code like this:
 160  * &lt;pre&gt;
 161  * {@code
 162  *  // Display an icon and a string for each object in the list.
 163  *
 164  * class MyCellRenderer extends JLabel implements ListCellRenderer&lt;Object&gt; {
 165  *     static final ImageIcon longIcon = new ImageIcon(&quot;long.gif&quot;);
 166  *     static final ImageIcon shortIcon = new ImageIcon(&quot;short.gif&quot;);
 167  *
 168  *     // This is the only method defined by ListCellRenderer.
 169  *     // We just reconfigure the JLabel each time we&#39;re called.
 170  *
 171  *     public Component getListCellRendererComponent(
 172  *       JList&lt;?&gt; list,           // the list
 173  *       Object value,            // value to display
 174  *       int index,               // cell index
 175  *       boolean isSelected,      // is the cell selected
 176  *       boolean cellHasFocus)    // does the cell have focus
 177  *     {
 178  *         String s = value.toString();
 179  *         setText(s);
 180  *         setIcon((s.length() &gt; 10) ? longIcon : shortIcon);
 181  *         if (isSelected) {
 182  *             setBackground(list.getSelectionBackground());
 183  *             setForeground(list.getSelectionForeground());
 184  *         } else {
 185  *             setBackground(list.getBackground());
 186  *             setForeground(list.getForeground());
 187  *         }
 188  *         setEnabled(list.isEnabled());
 189  *         setFont(list.getFont());
 190  *         setOpaque(true);
 191  *         return this;
 192  *     }
 193  * }
 194  *
 195  * myList.setCellRenderer(new MyCellRenderer());
 196  * }
 197  * &lt;/pre&gt;
 198  * &lt;p&gt;
 199  * Another job for the cell renderer is in helping to determine sizing
 200  * information for the list. By default, the list&#39;s {@code ListUI} determines
 201  * the size of cells by asking the cell renderer for its preferred
 202  * size for each list item. This can be expensive for large lists of items.
 203  * To avoid these calculations, you can set a {@code fixedCellWidth} and
 204  * {@code fixedCellHeight} on the list, or have these values calculated
 205  * automatically based on a single prototype value:
 206  * &lt;a id=&quot;prototype_example&quot;&gt;&lt;/a&gt;
 207  * &lt;pre&gt;
 208  * {@code
 209  * JList&lt;String&gt; bigDataList = new JList&lt;String&gt;(bigData);
 210  *
 211  * // We don&#39;t want the JList implementation to compute the width
 212  * // or height of all of the list cells, so we give it a string
 213  * // that&#39;s as big as we&#39;ll need for any cell.  It uses this to
 214  * // compute values for the fixedCellWidth and fixedCellHeight
 215  * // properties.
 216  *
 217  * bigDataList.setPrototypeCellValue(&quot;Index 1234567890&quot;);
 218  * }
 219  * &lt;/pre&gt;
 220  * &lt;p&gt;
 221  * {@code JList} doesn&#39;t implement scrolling directly. To create a list that
 222  * scrolls, make it the viewport view of a {@code JScrollPane}. For example:
 223  * &lt;pre&gt;
 224  * JScrollPane scrollPane = new JScrollPane(myList);
 225  *
 226  * // Or in two steps:
 227  * JScrollPane scrollPane = new JScrollPane();
 228  * scrollPane.getViewport().setView(myList);
 229  * &lt;/pre&gt;
 230  * &lt;p&gt;
 231  * {@code JList} doesn&#39;t provide any special handling of double or triple
 232  * (or N) mouse clicks, but it&#39;s easy to add a {@code MouseListener} if you
 233  * wish to take action on these events. Use the {@code locationToIndex}
 234  * method to determine what cell was clicked. For example:
 235  * &lt;pre&gt;
 236  * MouseListener mouseListener = new MouseAdapter() {
 237  *     public void mouseClicked(MouseEvent e) {
 238  *         if (e.getClickCount() == 2) {
 239  *             int index = list.locationToIndex(e.getPoint());
 240  *             System.out.println(&quot;Double clicked on Item &quot; + index);
 241  *          }
 242  *     }
 243  * };
 244  * list.addMouseListener(mouseListener);
 245  * &lt;/pre&gt;
 246  * &lt;p&gt;
 247  * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 248  * information see &lt;a
 249  * href=&quot;package-summary.html#threading&quot;&gt;Swing&#39;s Threading
 250  * Policy&lt;/a&gt;.
 251  * &lt;p&gt;
 252  * &lt;strong&gt;Warning:&lt;/strong&gt;
 253  * Serialized objects of this class will not be compatible with
 254  * future Swing releases. The current serialization support is
 255  * appropriate for short term storage or RMI between applications running
 256  * the same version of Swing.  As of 1.4, support for long term storage
 257  * of all JavaBeans&amp;trade;
 258  * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 259  * Please see {@link java.beans.XMLEncoder}.
 260  * &lt;p&gt;
 261  * See &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/components/list.html&quot;&gt;How to Use Lists&lt;/a&gt;
 262  * in &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/&quot;&gt;&lt;em&gt;The Java Tutorial&lt;/em&gt;&lt;/a&gt;
 263  * for further documentation.
 264  *
 265  * @see ListModel
 266  * @see AbstractListModel
 267  * @see DefaultListModel
 268  * @see ListSelectionModel
 269  * @see DefaultListSelectionModel
 270  * @see ListCellRenderer
 271  * @see DefaultListCellRenderer
 272  *
 273  * @param &lt;E&gt; the type of the elements of this list
 274  *
 275  * @author Hans Muller
 276  * @since 1.2
 277  */
 278 @JavaBean(defaultProperty = &quot;UI&quot;, description = &quot;A component which allows for the selection of one or more objects from a list.&quot;)
 279 @SwingContainer(false)
 280 @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
 281 public class JList&lt;E&gt; extends JComponent implements Scrollable, Accessible
 282 {
 283     /**
 284      * @see #getUIClassID
 285      * @see #readObject
 286      */
 287     private static final String uiClassID = &quot;ListUI&quot;;
 288 
 289     /**
 290      * Indicates a vertical layout of cells, in a single column;
 291      * the default layout.
 292      * @see #setLayoutOrientation
 293      * @since 1.4
 294      */
 295     public static final int VERTICAL = 0;
 296 
 297     /**
 298      * Indicates a &quot;newspaper style&quot; layout with cells flowing vertically
 299      * then horizontally.
 300      * @see #setLayoutOrientation
 301      * @since 1.4
 302      */
 303     public static final int VERTICAL_WRAP = 1;
 304 
 305     /**
 306      * Indicates a &quot;newspaper style&quot; layout with cells flowing horizontally
 307      * then vertically.
 308      * @see #setLayoutOrientation
 309      * @since 1.4
 310      */
 311     public static final int HORIZONTAL_WRAP = 2;
 312 
 313     private int fixedCellWidth = -1;
 314     private int fixedCellHeight = -1;
 315     private int horizontalScrollIncrement = -1;
 316     private E prototypeCellValue;
 317     private int visibleRowCount = 8;
 318     private Color selectionForeground;
 319     private Color selectionBackground;
 320     private boolean dragEnabled;
 321 
 322     private ListSelectionModel selectionModel;
 323     private ListModel&lt;E&gt; dataModel;
 324     private ListCellRenderer&lt;? super E&gt; cellRenderer;
 325     private ListSelectionListener selectionListener;
 326 
 327     /**
 328      * How to lay out the cells; defaults to &lt;code&gt;VERTICAL&lt;/code&gt;.
 329      */
 330     private int layoutOrientation;
 331 
 332     /**
 333      * The drop mode for this component.
 334      */
 335     private DropMode dropMode = DropMode.USE_SELECTION;
 336 
 337     /**
 338      * The drop location.
 339      */
 340     private transient DropLocation dropLocation;
 341 
 342     /**
 343      * Flag to indicate UI update is in progress
 344      */
 345     private transient boolean updateInProgress;
 346 
 347     /**
 348      * A subclass of &lt;code&gt;TransferHandler.DropLocation&lt;/code&gt; representing
 349      * a drop location for a &lt;code&gt;JList&lt;/code&gt;.
 350      *
 351      * @see #getDropLocation
 352      * @since 1.6
 353      */
 354     public static final class DropLocation extends TransferHandler.DropLocation {
 355         private final int index;
 356         private final boolean isInsert;
 357 
 358         private DropLocation(Point p, int index, boolean isInsert) {
 359             super(p);
 360             this.index = index;
 361             this.isInsert = isInsert;
 362         }
 363 
 364         /**
 365          * Returns the index where dropped data should be placed in the
 366          * list. Interpretation of the value depends on the drop mode set on
 367          * the associated component. If the drop mode is either
 368          * &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt; or &lt;code&gt;DropMode.ON&lt;/code&gt;,
 369          * the return value is an index of a row in the list. If the drop mode is
 370          * &lt;code&gt;DropMode.INSERT&lt;/code&gt;, the return value refers to the index
 371          * where the data should be inserted. If the drop mode is
 372          * &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;, the value of
 373          * &lt;code&gt;isInsert()&lt;/code&gt; indicates whether the index is an index
 374          * of a row, or an insert index.
 375          * &lt;p&gt;
 376          * &lt;code&gt;-1&lt;/code&gt; indicates that the drop occurred over empty space,
 377          * and no index could be calculated.
 378          *
 379          * @return the drop index
 380          */
 381         public int getIndex() {
 382             return index;
 383         }
 384 
 385         /**
 386          * Returns whether or not this location represents an insert
 387          * location.
 388          *
 389          * @return whether or not this is an insert location
 390          */
 391         public boolean isInsert() {
 392             return isInsert;
 393         }
 394 
 395         /**
 396          * Returns a string representation of this drop location.
 397          * This method is intended to be used for debugging purposes,
 398          * and the content and format of the returned string may vary
 399          * between implementations.
 400          *
 401          * @return a string representation of this drop location
 402          */
 403         public String toString() {
 404             return getClass().getName()
 405                    + &quot;[dropPoint=&quot; + getDropPoint() + &quot;,&quot;
 406                    + &quot;index=&quot; + index + &quot;,&quot;
 407                    + &quot;insert=&quot; + isInsert + &quot;]&quot;;
 408         }
 409     }
 410 
 411     /**
 412      * Constructs a {@code JList} that displays elements from the specified,
 413      * {@code non-null}, model. All {@code JList} constructors delegate to
 414      * this one.
 415      * &lt;p&gt;
 416      * This constructor registers the list with the {@code ToolTipManager},
 417      * allowing for tooltips to be provided by the cell renderers.
 418      *
 419      * @param dataModel the model for the list
 420      * @exception IllegalArgumentException if the model is {@code null}
 421      */
 422     public JList(ListModel&lt;E&gt; dataModel)
 423     {
 424         if (dataModel == null) {
 425             throw new IllegalArgumentException(&quot;dataModel must be non null&quot;);
 426         }
 427 
 428         // Register with the ToolTipManager so that tooltips from the
 429         // renderer show through.
 430         ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
 431         toolTipManager.registerComponent(this);
 432 
 433         layoutOrientation = VERTICAL;
 434 
 435         this.dataModel = dataModel;
 436         selectionModel = createSelectionModel();
 437         setAutoscrolls(true);
 438         setOpaque(true);
 439         updateUI();
 440     }
 441 
 442 
 443     /**
 444      * Constructs a &lt;code&gt;JList&lt;/code&gt; that displays the elements in
 445      * the specified array. This constructor creates a read-only model
 446      * for the given array, and then delegates to the constructor that
 447      * takes a {@code ListModel}.
 448      * &lt;p&gt;
 449      * Attempts to pass a {@code null} value to this method results in
 450      * undefined behavior and, most likely, exceptions. The created model
 451      * references the given array directly. Attempts to modify the array
 452      * after constructing the list results in undefined behavior.
 453      *
 454      * @param  listData  the array of Objects to be loaded into the data model,
 455      *                   {@code non-null}
 456      */
 457     public JList(final E[] listData)
 458     {
 459         this (
 460             new AbstractListModel&lt;E&gt;() {
 461                 public int getSize() { return listData.length; }
 462                 public E getElementAt(int i) { return listData[i]; }
 463             }
 464         );
 465     }
 466 
 467 
 468     /**
 469      * Constructs a &lt;code&gt;JList&lt;/code&gt; that displays the elements in
 470      * the specified &lt;code&gt;Vector&lt;/code&gt;. This constructor creates a read-only
 471      * model for the given {@code Vector}, and then delegates to the constructor
 472      * that takes a {@code ListModel}.
 473      * &lt;p&gt;
 474      * Attempts to pass a {@code null} value to this method results in
 475      * undefined behavior and, most likely, exceptions. The created model
 476      * references the given {@code Vector} directly. Attempts to modify the
 477      * {@code Vector} after constructing the list results in undefined behavior.
 478      *
 479      * @param  listData  the &lt;code&gt;Vector&lt;/code&gt; to be loaded into the
 480      *                   data model, {@code non-null}
 481      */
 482     public JList(final Vector&lt;? extends E&gt; listData) {
 483         this (
 484             new AbstractListModel&lt;E&gt;() {
 485                 public int getSize() { return listData.size(); }
 486                 public E getElementAt(int i) { return listData.elementAt(i); }
 487             }
 488         );
 489     }
 490 
 491 
 492     /**
 493      * Constructs a &lt;code&gt;JList&lt;/code&gt; with an empty, read-only, model.
 494      */
 495     public JList() {
 496         this (
 497             new AbstractListModel&lt;E&gt;() {
 498               public int getSize() { return 0; }
 499               public E getElementAt(int i) { throw new IndexOutOfBoundsException(&quot;No Data Model&quot;); }
 500             }
 501         );
 502     }
 503 
 504 
 505     /**
 506      * Returns the {@code ListUI}, the look and feel object that
 507      * renders this component.
 508      *
 509      * @return the &lt;code&gt;ListUI&lt;/code&gt; object that renders this component
 510      */
 511     public ListUI getUI() {
 512         return (ListUI)ui;
 513     }
 514 
 515 
 516     /**
 517      * Sets the {@code ListUI}, the look and feel object that
 518      * renders this component.
 519      *
 520      * @param ui  the &lt;code&gt;ListUI&lt;/code&gt; object
 521      * @see UIDefaults#getUI
 522      */
 523     @BeanProperty(hidden = true, visualUpdate = true, description
 524             = &quot;The UI object that implements the Component&#39;s LookAndFeel.&quot;)
 525     public void setUI(ListUI ui) {
 526         super.setUI(ui);
 527     }
 528 
 529 
 530     /**
 531      * Resets the {@code ListUI} property by setting it to the value provided
 532      * by the current look and feel. If the current cell renderer was installed
 533      * by the developer (rather than the look and feel itself), this also causes
 534      * the cell renderer and its children to be updated, by calling
 535      * {@code SwingUtilities.updateComponentTreeUI} on it.
 536      *
 537      * @see UIManager#getUI
 538      * @see SwingUtilities#updateComponentTreeUI
 539      */
 540     public void updateUI() {
 541         if (!updateInProgress) {
 542             updateInProgress = true;
 543             try {
 544                 setUI((ListUI)UIManager.getUI(this));
 545 
 546                 ListCellRenderer&lt;? super E&gt; renderer = getCellRenderer();
 547                 if (renderer instanceof Component) {
 548                     SwingUtilities.updateComponentTreeUI((Component)renderer);
 549                 }
 550             } finally {
 551                 updateInProgress = false;
 552             }
 553         }
 554     }
 555 
 556 
 557     /**
 558      * Returns {@code &quot;ListUI&quot;}, the &lt;code&gt;UIDefaults&lt;/code&gt; key used to look
 559      * up the name of the {@code javax.swing.plaf.ListUI} class that defines
 560      * the look and feel for this component.
 561      *
 562      * @return the string &quot;ListUI&quot;
 563      * @see JComponent#getUIClassID
 564      * @see UIDefaults#getUI
 565      */
 566     @BeanProperty(bound = false)
 567     public String getUIClassID() {
 568         return uiClassID;
 569     }
 570 
 571 
 572     /* -----private-----
 573      * This method is called by setPrototypeCellValue and setCellRenderer
 574      * to update the fixedCellWidth and fixedCellHeight properties from the
 575      * current value of prototypeCellValue (if it&#39;s non null).
 576      * &lt;p&gt;
 577      * This method sets fixedCellWidth and fixedCellHeight but does &lt;b&gt;not&lt;/b&gt;
 578      * generate PropertyChangeEvents for them.
 579      *
 580      * @see #setPrototypeCellValue
 581      * @see #setCellRenderer
 582      */
 583     private void updateFixedCellSize()
 584     {
 585         ListCellRenderer&lt;? super E&gt; cr = getCellRenderer();
 586         E value = getPrototypeCellValue();
 587 
 588         if ((cr != null) &amp;&amp; (value != null)) {
 589             Component c = cr.getListCellRendererComponent(this, value, 0, false, false);
 590 
 591             /* The ListUI implementation will add Component c to its private
 592              * CellRendererPane however we can&#39;t assume that&#39;s already
 593              * been done here.  So we temporarily set the one &quot;inherited&quot;
 594              * property that may affect the renderer components preferred size:
 595              * its font.
 596              */
 597             Font f = c.getFont();
 598             c.setFont(getFont());
 599 
 600             Dimension d = c.getPreferredSize();
 601             fixedCellWidth = d.width;
 602             fixedCellHeight = d.height;
 603 
 604             c.setFont(f);
 605         }
 606     }
 607 
 608 
 609     /**
 610      * Returns the &quot;prototypical&quot; cell value -- a value used to calculate a
 611      * fixed width and height for cells. This can be {@code null} if there
 612      * is no such value.
 613      *
 614      * @return the value of the {@code prototypeCellValue} property
 615      * @see #setPrototypeCellValue
 616      */
 617     public E getPrototypeCellValue() {
 618         return prototypeCellValue;
 619     }
 620 
 621     /**
 622      * Sets the {@code prototypeCellValue} property, and then (if the new value
 623      * is {@code non-null}), computes the {@code fixedCellWidth} and
 624      * {@code fixedCellHeight} properties by requesting the cell renderer
 625      * component for the given value (and index 0) from the cell renderer, and
 626      * using that component&#39;s preferred size.
 627      * &lt;p&gt;
 628      * This method is useful when the list is too long to allow the
 629      * {@code ListUI} to compute the width/height of each cell, and there is a
 630      * single cell value that is known to occupy as much space as any of the
 631      * others, a so-called prototype.
 632      * &lt;p&gt;
 633      * While all three of the {@code prototypeCellValue},
 634      * {@code fixedCellHeight}, and {@code fixedCellWidth} properties may be
 635      * modified by this method, {@code PropertyChangeEvent} notifications are
 636      * only sent when the {@code prototypeCellValue} property changes.
 637      * &lt;p&gt;
 638      * To see an example which sets this property, see the
 639      * &lt;a href=&quot;#prototype_example&quot;&gt;class description&lt;/a&gt; above.
 640      * &lt;p&gt;
 641      * The default value of this property is &lt;code&gt;null&lt;/code&gt;.
 642      * &lt;p&gt;
 643      * This is a JavaBeans bound property.
 644      *
 645      * @param prototypeCellValue  the value on which to base
 646      *                          &lt;code&gt;fixedCellWidth&lt;/code&gt; and
 647      *                          &lt;code&gt;fixedCellHeight&lt;/code&gt;
 648      * @see #getPrototypeCellValue
 649      * @see #setFixedCellWidth
 650      * @see #setFixedCellHeight
 651      * @see JComponent#addPropertyChangeListener
 652      */
 653     @BeanProperty(visualUpdate = true, description
 654             = &quot;The cell prototype value, used to compute cell width and height.&quot;)
 655     public void setPrototypeCellValue(E prototypeCellValue) {
 656         E oldValue = this.prototypeCellValue;
 657         this.prototypeCellValue = prototypeCellValue;
 658 
 659         /* If the prototypeCellValue has changed and is non-null,
 660          * then recompute fixedCellWidth and fixedCellHeight.
 661          */
 662 
 663         if ((prototypeCellValue != null) &amp;&amp; !prototypeCellValue.equals(oldValue)) {
 664             updateFixedCellSize();
 665         }
 666 
 667         firePropertyChange(&quot;prototypeCellValue&quot;, oldValue, prototypeCellValue);
 668     }
 669 
 670 
 671     /**
 672      * Returns the value of the {@code fixedCellWidth} property.
 673      *
 674      * @return the fixed cell width
 675      * @see #setFixedCellWidth
 676      */
 677     public int getFixedCellWidth() {
 678         return fixedCellWidth;
 679     }
 680 
 681     /**
 682      * Sets a fixed value to be used for the width of every cell in the list.
 683      * If {@code width} is -1, cell widths are computed in the {@code ListUI}
 684      * by applying &lt;code&gt;getPreferredSize&lt;/code&gt; to the cell renderer component
 685      * for each list element.
 686      * &lt;p&gt;
 687      * The default value of this property is {@code -1}.
 688      * &lt;p&gt;
 689      * This is a JavaBeans bound property.
 690      *
 691      * @param width the width to be used for all cells in the list
 692      * @see #setPrototypeCellValue
 693      * @see #setFixedCellWidth
 694      * @see JComponent#addPropertyChangeListener
 695      */
 696     @BeanProperty(visualUpdate = true, description
 697             = &quot;Defines a fixed cell width when greater than zero.&quot;)
 698     public void setFixedCellWidth(int width) {
 699         int oldValue = fixedCellWidth;
 700         fixedCellWidth = width;
 701         firePropertyChange(&quot;fixedCellWidth&quot;, oldValue, fixedCellWidth);
 702     }
 703 
 704 
 705     /**
 706      * Returns the value of the {@code fixedCellHeight} property.
 707      *
 708      * @return the fixed cell height
 709      * @see #setFixedCellHeight
 710      */
 711     public int getFixedCellHeight() {
 712         return fixedCellHeight;
 713     }
 714 
 715     /**
 716      * Sets a fixed value to be used for the height of every cell in the list.
 717      * If {@code height} is -1, cell heights are computed in the {@code ListUI}
 718      * by applying &lt;code&gt;getPreferredSize&lt;/code&gt; to the cell renderer component
 719      * for each list element.
 720      * &lt;p&gt;
 721      * The default value of this property is {@code -1}.
 722      * &lt;p&gt;
 723      * This is a JavaBeans bound property.
 724      *
 725      * @param height the height to be used for all cells in the list
 726      * @see #setPrototypeCellValue
 727      * @see #setFixedCellWidth
 728      * @see JComponent#addPropertyChangeListener
 729      */
 730     @BeanProperty(visualUpdate = true, description
 731             = &quot;Defines a fixed cell height when greater than zero.&quot;)
 732     public void setFixedCellHeight(int height) {
 733         int oldValue = fixedCellHeight;
 734         fixedCellHeight = height;
 735         firePropertyChange(&quot;fixedCellHeight&quot;, oldValue, fixedCellHeight);
 736     }
 737 
 738 
 739     /**
 740      * Returns the object responsible for painting list items.
 741      *
 742      * @return the value of the {@code cellRenderer} property
 743      * @see #setCellRenderer
 744      */
 745     @Transient
 746     public ListCellRenderer&lt;? super E&gt; getCellRenderer() {
 747         return cellRenderer;
 748     }
 749 
 750     /**
 751      * Sets the delegate that is used to paint each cell in the list.
 752      * The job of a cell renderer is discussed in detail in the
 753      * &lt;a href=&quot;#renderer&quot;&gt;class level documentation&lt;/a&gt;.
 754      * &lt;p&gt;
 755      * If the {@code prototypeCellValue} property is {@code non-null},
 756      * setting the cell renderer also causes the {@code fixedCellWidth} and
 757      * {@code fixedCellHeight} properties to be re-calculated. Only one
 758      * &lt;code&gt;PropertyChangeEvent&lt;/code&gt; is generated however -
 759      * for the &lt;code&gt;cellRenderer&lt;/code&gt; property.
 760      * &lt;p&gt;
 761      * The default value of this property is provided by the {@code ListUI}
 762      * delegate, i.e. by the look and feel implementation.
 763      * &lt;p&gt;
 764      * This is a JavaBeans bound property.
 765      *
 766      * @param cellRenderer the &lt;code&gt;ListCellRenderer&lt;/code&gt;
 767      *                          that paints list cells
 768      * @see #getCellRenderer
 769      */
 770     @BeanProperty(visualUpdate = true, description
 771             = &quot;The component used to draw the cells.&quot;)
 772     public void setCellRenderer(ListCellRenderer&lt;? super E&gt; cellRenderer) {
 773         ListCellRenderer&lt;? super E&gt; oldValue = this.cellRenderer;
 774         this.cellRenderer = cellRenderer;
 775 
 776         /* If the cellRenderer has changed and prototypeCellValue
 777          * was set, then recompute fixedCellWidth and fixedCellHeight.
 778          */
 779         if ((cellRenderer != null) &amp;&amp; !cellRenderer.equals(oldValue)) {
 780             updateFixedCellSize();
 781         }
 782 
 783         firePropertyChange(&quot;cellRenderer&quot;, oldValue, cellRenderer);
 784     }
 785 
 786 
 787     /**
 788      * Returns the color used to draw the foreground of selected items.
 789      * {@code DefaultListCellRenderer} uses this color to draw the foreground
 790      * of items in the selected state, as do the renderers installed by most
 791      * {@code ListUI} implementations.
 792      *
 793      * @return the color to draw the foreground of selected items
 794      * @see #setSelectionForeground
 795      * @see DefaultListCellRenderer
 796      */
 797     public Color getSelectionForeground() {
 798         return selectionForeground;
 799     }
 800 
 801 
 802     /**
 803      * Sets the color used to draw the foreground of selected items, which
 804      * cell renderers can use to render text and graphics.
 805      * {@code DefaultListCellRenderer} uses this color to draw the foreground
 806      * of items in the selected state, as do the renderers installed by most
 807      * {@code ListUI} implementations.
 808      * &lt;p&gt;
 809      * The default value of this property is defined by the look and feel
 810      * implementation.
 811      * &lt;p&gt;
 812      * This is a JavaBeans bound property.
 813      *
 814      * @param selectionForeground  the {@code Color} to use in the foreground
 815      *                             for selected list items
 816      * @see #getSelectionForeground
 817      * @see #setSelectionBackground
 818      * @see #setForeground
 819      * @see #setBackground
 820      * @see #setFont
 821      * @see DefaultListCellRenderer
 822      */
 823     @BeanProperty(visualUpdate = true, description
 824             = &quot;The foreground color of selected cells.&quot;)
 825     public void setSelectionForeground(Color selectionForeground) {
 826         Color oldValue = this.selectionForeground;
 827         this.selectionForeground = selectionForeground;
 828         firePropertyChange(&quot;selectionForeground&quot;, oldValue, selectionForeground);
 829     }
 830 
 831 
 832     /**
 833      * Returns the color used to draw the background of selected items.
 834      * {@code DefaultListCellRenderer} uses this color to draw the background
 835      * of items in the selected state, as do the renderers installed by most
 836      * {@code ListUI} implementations.
 837      *
 838      * @return the color to draw the background of selected items
 839      * @see #setSelectionBackground
 840      * @see DefaultListCellRenderer
 841      */
 842     public Color getSelectionBackground() {
 843         return selectionBackground;
 844     }
 845 
 846 
 847     /**
 848      * Sets the color used to draw the background of selected items, which
 849      * cell renderers can use fill selected cells.
 850      * {@code DefaultListCellRenderer} uses this color to fill the background
 851      * of items in the selected state, as do the renderers installed by most
 852      * {@code ListUI} implementations.
 853      * &lt;p&gt;
 854      * The default value of this property is defined by the look
 855      * and feel implementation.
 856      * &lt;p&gt;
 857      * This is a JavaBeans bound property.
 858      *
 859      * @param selectionBackground  the {@code Color} to use for the
 860      *                             background of selected cells
 861      * @see #getSelectionBackground
 862      * @see #setSelectionForeground
 863      * @see #setForeground
 864      * @see #setBackground
 865      * @see #setFont
 866      * @see DefaultListCellRenderer
 867      */
 868     @BeanProperty(visualUpdate = true, description
 869             = &quot;The background color of selected cells.&quot;)
 870     public void setSelectionBackground(Color selectionBackground) {
 871         Color oldValue = this.selectionBackground;
 872         this.selectionBackground = selectionBackground;
 873         firePropertyChange(&quot;selectionBackground&quot;, oldValue, selectionBackground);
 874     }
 875 
 876 
 877     /**
 878      * Returns the value of the {@code visibleRowCount} property. See the
 879      * documentation for {@link #setVisibleRowCount} for details on how to
 880      * interpret this value.
 881      *
 882      * @return the value of the {@code visibleRowCount} property.
 883      * @see #setVisibleRowCount
 884      */
 885     public int getVisibleRowCount() {
 886         return visibleRowCount;
 887     }
 888 
 889     /**
 890      * Sets the {@code visibleRowCount} property, which has different meanings
 891      * depending on the layout orientation: For a {@code VERTICAL} layout
 892      * orientation, this sets the preferred number of rows to display without
 893      * requiring scrolling; for other orientations, it affects the wrapping of
 894      * cells.
 895      * &lt;p&gt;
 896      * In {@code VERTICAL} orientation:&lt;br&gt;
 897      * Setting this property affects the return value of the
 898      * {@link #getPreferredScrollableViewportSize} method, which is used to
 899      * calculate the preferred size of an enclosing viewport. See that method&#39;s
 900      * documentation for more details.
 901      * &lt;p&gt;
 902      * In {@code HORIZONTAL_WRAP} and {@code VERTICAL_WRAP} orientations:&lt;br&gt;
 903      * This affects how cells are wrapped. See the documentation of
 904      * {@link #setLayoutOrientation} for more details.
 905      * &lt;p&gt;
 906      * The default value of this property is {@code 8}.
 907      * &lt;p&gt;
 908      * Calling this method with a negative value results in the property
 909      * being set to {@code 0}.
 910      * &lt;p&gt;
 911      * This is a JavaBeans bound property.
 912      *
 913      * @param visibleRowCount  an integer specifying the preferred number of
 914      *                         rows to display without requiring scrolling
 915      * @see #getVisibleRowCount
 916      * @see #getPreferredScrollableViewportSize
 917      * @see #setLayoutOrientation
 918      * @see JComponent#getVisibleRect
 919      * @see JViewport
 920      */
 921     @BeanProperty(visualUpdate = true, description
 922             = &quot;The preferred number of rows to display without requiring scrolling&quot;)
 923     public void setVisibleRowCount(int visibleRowCount) {
 924         int oldValue = this.visibleRowCount;
 925         this.visibleRowCount = Math.max(0, visibleRowCount);
 926         firePropertyChange(&quot;visibleRowCount&quot;, oldValue, visibleRowCount);
 927     }
 928 
 929 
 930     /**
 931      * Returns the layout orientation property for the list: {@code VERTICAL}
 932      * if the layout is a single column of cells, {@code VERTICAL_WRAP} if the
 933      * layout is &quot;newspaper style&quot; with the content flowing vertically then
 934      * horizontally, or {@code HORIZONTAL_WRAP} if the layout is &quot;newspaper
 935      * style&quot; with the content flowing horizontally then vertically.
 936      *
 937      * @return the value of the {@code layoutOrientation} property
 938      * @see #setLayoutOrientation
 939      * @since 1.4
 940      */
 941     public int getLayoutOrientation() {
 942         return layoutOrientation;
 943     }
 944 
 945 
 946     /**
 947      * Defines the way list cells are layed out. Consider a {@code JList}
 948      * with five cells. Cells can be layed out in one of the following ways:
 949      *
 950      * &lt;pre&gt;
 951      * VERTICAL:          0
 952      *                    1
 953      *                    2
 954      *                    3
 955      *                    4
 956      *
 957      * HORIZONTAL_WRAP:   0  1  2
 958      *                    3  4
 959      *
 960      * VERTICAL_WRAP:     0  3
 961      *                    1  4
 962      *                    2
 963      * &lt;/pre&gt;
 964      * &lt;p&gt;
 965      * A description of these layouts follows:
 966      *
 967      * &lt;table class=&quot;striped&quot;&gt;
 968      * &lt;caption&gt;Describes layouts VERTICAL,HORIZONTAL_WRAP, and VERTICAL_WRAP
 969      * &lt;/caption&gt;
 970      * &lt;thead&gt;
 971      *   &lt;tr&gt;
 972      *     &lt;th scope=&quot;col&quot;&gt;Value
 973      *     &lt;th scope=&quot;col&quot;&gt;Description
 974      * &lt;/thead&gt;
 975      * &lt;tbody&gt;
 976      *   &lt;tr&gt;
 977      *     &lt;th scope=&quot;row&quot;&gt;{@code VERTICAL}
 978      *     &lt;td&gt;Cells are layed out vertically in a single column.
 979      *   &lt;tr&gt;
 980      *     &lt;th scope=&quot;row&quot;&gt;{@code HORIZONTAL_WRAP}
 981      *     &lt;td&gt;Cells are layed out horizontally, wrapping to a new row as
 982      *     necessary. If the {@code visibleRowCount} property is less than or
 983      *     equal to zero, wrapping is determined by the width of the list;
 984      *     otherwise wrapping is done in such a way as to ensure
 985      *     {@code visibleRowCount} rows in the list.
 986      *   &lt;tr&gt;
 987      *     &lt;th scope=&quot;row&quot;&gt;{@code VERTICAL_WRAP}
 988      *     &lt;td&gt;Cells are layed out vertically, wrapping to a new column as
 989      *     necessary. If the {@code visibleRowCount} property is less than or
 990      *     equal to zero, wrapping is determined by the height of the list;
 991      *     otherwise wrapping is done at {@code visibleRowCount} rows.
 992      * &lt;/tbody&gt;
 993      * &lt;/table&gt;
 994      *
 995      * The default value of this property is &lt;code&gt;VERTICAL&lt;/code&gt;.
 996      *
 997      * @param layoutOrientation the new layout orientation, one of:
 998      *        {@code VERTICAL}, {@code HORIZONTAL_WRAP} or {@code VERTICAL_WRAP}
 999      * @see #getLayoutOrientation
1000      * @see #setVisibleRowCount
1001      * @see #getScrollableTracksViewportHeight
1002      * @see #getScrollableTracksViewportWidth
1003      * @throws IllegalArgumentException if {@code layoutOrientation} isn&#39;t one of the
1004      *         allowable values
1005      * @since 1.4
1006      */
1007     @BeanProperty(visualUpdate = true, enumerationValues = {
1008             &quot;JList.VERTICAL&quot;,
1009             &quot;JList.HORIZONTAL_WRAP&quot;,
1010             &quot;JList.VERTICAL_WRAP&quot;}, description
1011             = &quot;Defines the way list cells are layed out.&quot;)
1012     public void setLayoutOrientation(int layoutOrientation) {
1013         int oldValue = this.layoutOrientation;
1014         switch (layoutOrientation) {
1015         case VERTICAL:
1016         case VERTICAL_WRAP:
1017         case HORIZONTAL_WRAP:
1018             this.layoutOrientation = layoutOrientation;
1019             firePropertyChange(&quot;layoutOrientation&quot;, oldValue, layoutOrientation);
1020             break;
1021         default:
1022             throw new IllegalArgumentException(&quot;layoutOrientation must be one of: VERTICAL, HORIZONTAL_WRAP or VERTICAL_WRAP&quot;);
1023         }
1024     }
1025 
1026 
1027     /**
1028      * Returns the smallest list index that is currently visible.
1029      * In a left-to-right {@code componentOrientation}, the first visible
1030      * cell is found closest to the list&#39;s upper-left corner. In right-to-left
1031      * orientation, it is found closest to the upper-right corner.
1032      * If nothing is visible or the list is empty, {@code -1} is returned.
1033      * Note that the returned cell may only be partially visible.
1034      *
1035      * @return the index of the first visible cell
1036      * @see #getLastVisibleIndex
1037      * @see JComponent#getVisibleRect
1038      */
1039     @BeanProperty(bound = false)
1040     public int getFirstVisibleIndex() {
1041         Rectangle r = getVisibleRect();
1042         int first;
1043         if (this.getComponentOrientation().isLeftToRight()) {
1044             first = locationToIndex(r.getLocation());
1045         } else {
1046             first = locationToIndex(new Point((r.x + r.width) - 1, r.y));
1047         }
1048         if (first != -1) {
1049             Rectangle bounds = getCellBounds(first, first);
1050             if (bounds != null) {
1051                 SwingUtilities.computeIntersection(r.x, r.y, r.width, r.height, bounds);
1052                 if (bounds.width == 0 || bounds.height == 0) {
1053                     first = -1;
1054                 }
1055             }
1056         }
1057         return first;
1058     }
1059 
1060 
1061     /**
1062      * Returns the largest list index that is currently visible.
1063      * If nothing is visible or the list is empty, {@code -1} is returned.
1064      * Note that the returned cell may only be partially visible.
1065      *
1066      * @return the index of the last visible cell
1067      * @see #getFirstVisibleIndex
1068      * @see JComponent#getVisibleRect
1069      */
1070     @BeanProperty(bound = false)
1071     public int getLastVisibleIndex() {
1072         boolean leftToRight = this.getComponentOrientation().isLeftToRight();
1073         Rectangle r = getVisibleRect();
1074         Point lastPoint;
1075         if (leftToRight) {
1076             lastPoint = new Point((r.x + r.width) - 1, (r.y + r.height) - 1);
1077         } else {
1078             lastPoint = new Point(r.x, (r.y + r.height) - 1);
1079         }
1080         int location = locationToIndex(lastPoint);
1081 
1082         if (location != -1) {
1083             Rectangle bounds = getCellBounds(location, location);
1084 
1085             if (bounds != null) {
1086                 SwingUtilities.computeIntersection(r.x, r.y, r.width, r.height, bounds);
1087                 if (bounds.width == 0 || bounds.height == 0) {
1088                     // Try the top left(LTR) or top right(RTL) corner, and
1089                     // then go across checking each cell for HORIZONTAL_WRAP.
1090                     // Try the lower left corner, and then go across checking
1091                     // each cell for other list layout orientation.
1092                     boolean isHorizontalWrap =
1093                         (getLayoutOrientation() == HORIZONTAL_WRAP);
1094                     Point visibleLocation = isHorizontalWrap ?
1095                         new Point(lastPoint.x, r.y) :
1096                         new Point(r.x, lastPoint.y);
1097                     int last;
1098                     int visIndex = -1;
1099                     int lIndex = location;
1100                     location = -1;
1101 
1102                     do {
1103                         last = visIndex;
1104                         visIndex = locationToIndex(visibleLocation);
1105 
1106                         if (visIndex != -1) {
1107                             bounds = getCellBounds(visIndex, visIndex);
1108                             if (visIndex != lIndex &amp;&amp; bounds != null &amp;&amp;
1109                                 bounds.contains(visibleLocation)) {
1110                                 location = visIndex;
1111                                 if (isHorizontalWrap) {
1112                                     visibleLocation.y = bounds.y + bounds.height;
1113                                     if (visibleLocation.y &gt;= lastPoint.y) {
1114                                         // Past visible region, bail.
1115                                         last = visIndex;
1116                                     }
1117                                 }
1118                                 else {
1119                                     visibleLocation.x = bounds.x + bounds.width;
1120                                     if (visibleLocation.x &gt;= lastPoint.x) {
1121                                         // Past visible region, bail.
1122                                         last = visIndex;
1123                                     }
1124                                 }
1125 
1126                             }
1127                             else {
1128                                 last = visIndex;
1129                             }
1130                         }
1131                     } while (visIndex != -1 &amp;&amp; last != visIndex);
1132                 }
1133             }
1134         }
1135         return location;
1136     }
1137 
1138 
1139     /**
1140      * Scrolls the list within an enclosing viewport to make the specified
1141      * cell completely visible. This calls {@code scrollRectToVisible} with
1142      * the bounds of the specified cell. For this method to work, the
1143      * {@code JList} must be within a &lt;code&gt;JViewport&lt;/code&gt;.
1144      * &lt;p&gt;
1145      * If the given index is outside the list&#39;s range of cells, this method
1146      * results in nothing.
1147      *
1148      * @param index  the index of the cell to make visible
1149      * @see JComponent#scrollRectToVisible
1150      * @see #getVisibleRect
1151      */
1152     public void ensureIndexIsVisible(int index) {
1153         Rectangle cellBounds = getCellBounds(index, index);
1154         if (cellBounds != null) {
1155             scrollRectToVisible(cellBounds);
1156         }
1157     }
1158 
1159     /**
1160      * Turns on or off automatic drag handling. In order to enable automatic
1161      * drag handling, this property should be set to {@code true}, and the
1162      * list&#39;s {@code TransferHandler} needs to be {@code non-null}.
1163      * The default value of the {@code dragEnabled} property is {@code false}.
1164      * &lt;p&gt;
1165      * The job of honoring this property, and recognizing a user drag gesture,
1166      * lies with the look and feel implementation, and in particular, the list&#39;s
1167      * {@code ListUI}. When automatic drag handling is enabled, most look and
1168      * feels (including those that subclass {@code BasicLookAndFeel}) begin a
1169      * drag and drop operation whenever the user presses the mouse button over
1170      * an item and then moves the mouse a few pixels. Setting this property to
1171      * {@code true} can therefore have a subtle effect on how selections behave.
1172      * &lt;p&gt;
1173      * If a look and feel is used that ignores this property, you can still
1174      * begin a drag and drop operation by calling {@code exportAsDrag} on the
1175      * list&#39;s {@code TransferHandler}.
1176      *
1177      * @param b whether or not to enable automatic drag handling
1178      * @exception HeadlessException if
1179      *            &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
1180      *            &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt;
1181      *            returns &lt;code&gt;true&lt;/code&gt;
1182      * @see java.awt.GraphicsEnvironment#isHeadless
1183      * @see #getDragEnabled
1184      * @see #setTransferHandler
1185      * @see TransferHandler
1186      * @since 1.4
1187      */
1188     @BeanProperty(bound = false, description
1189             = &quot;determines whether automatic drag handling is enabled&quot;)
1190     public void setDragEnabled(boolean b) {
1191         if (b &amp;&amp; GraphicsEnvironment.isHeadless()) {
1192             throw new HeadlessException();
1193         }
1194         dragEnabled = b;
1195     }
1196 
1197     /**
1198      * Returns whether or not automatic drag handling is enabled.
1199      *
1200      * @return the value of the {@code dragEnabled} property
1201      * @see #setDragEnabled
1202      * @since 1.4
1203      */
1204     public boolean getDragEnabled() {
1205         return dragEnabled;
1206     }
1207 
1208     /**
1209      * Sets the drop mode for this component. For backward compatibility,
1210      * the default for this property is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;.
1211      * Usage of one of the other modes is recommended, however, for an
1212      * improved user experience. &lt;code&gt;DropMode.ON&lt;/code&gt;, for instance,
1213      * offers similar behavior of showing items as selected, but does so without
1214      * affecting the actual selection in the list.
1215      * &lt;p&gt;
1216      * &lt;code&gt;JList&lt;/code&gt; supports the following drop modes:
1217      * &lt;ul&gt;
1218      *    &lt;li&gt;&lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;&lt;/li&gt;
1219      *    &lt;li&gt;&lt;code&gt;DropMode.ON&lt;/code&gt;&lt;/li&gt;
1220      *    &lt;li&gt;&lt;code&gt;DropMode.INSERT&lt;/code&gt;&lt;/li&gt;
1221      *    &lt;li&gt;&lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;&lt;/li&gt;
1222      * &lt;/ul&gt;
1223      * The drop mode is only meaningful if this component has a
1224      * &lt;code&gt;TransferHandler&lt;/code&gt; that accepts drops.
1225      *
1226      * @param dropMode the drop mode to use
1227      * @throws IllegalArgumentException if the drop mode is unsupported
1228      *         or &lt;code&gt;null&lt;/code&gt;
1229      * @see #getDropMode
1230      * @see #getDropLocation
1231      * @see #setTransferHandler
1232      * @see TransferHandler
1233      * @since 1.6
1234      */
1235     public final void setDropMode(DropMode dropMode) {
1236         if (dropMode != null) {
1237             switch (dropMode) {
1238                 case USE_SELECTION:
1239                 case ON:
1240                 case INSERT:
1241                 case ON_OR_INSERT:
1242                     this.dropMode = dropMode;
1243                     return;
1244             }
1245         }
1246 
1247         throw new IllegalArgumentException(dropMode + &quot;: Unsupported drop mode for list&quot;);
1248     }
1249 
1250     /**
1251      * Returns the drop mode for this component.
1252      *
1253      * @return the drop mode for this component
1254      * @see #setDropMode
1255      * @since 1.6
1256      */
1257     public final DropMode getDropMode() {
1258         return dropMode;
1259     }
1260 
1261     /**
1262      * Calculates a drop location in this component, representing where a
1263      * drop at the given point should insert data.
1264      *
1265      * @param p the point to calculate a drop location for
1266      * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
1267      */
1268     DropLocation dropLocationForPoint(Point p) {
1269         DropLocation location = null;
1270         Rectangle rect = null;
1271 
1272         int index = locationToIndex(p);
1273         if (index != -1) {
1274             rect = getCellBounds(index, index);
1275         }
1276 
1277         switch(dropMode) {
1278             case USE_SELECTION:
1279             case ON:
1280                 location = new DropLocation(p,
1281                     (rect != null &amp;&amp; rect.contains(p)) ? index : -1,
1282                     false);
1283 
1284                 break;
1285             case INSERT:
1286                 if (index == -1) {
1287                     location = new DropLocation(p, getModel().getSize(), true);
1288                     break;
1289                 }
1290 
1291                 if (layoutOrientation == HORIZONTAL_WRAP) {
1292                     boolean ltr = getComponentOrientation().isLeftToRight();
1293 
1294                     if (SwingUtilities2.liesInHorizontal(rect, p, ltr, false) == TRAILING) {
1295                         index++;
1296                     // special case for below all cells
1297                     } else if (index == getModel().getSize() - 1 &amp;&amp; p.y &gt;= rect.y + rect.height) {
1298                         index++;
1299                     }
1300                 } else {
1301                     if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {
1302                         index++;
1303                     }
1304                 }
1305 
1306                 location = new DropLocation(p, index, true);
1307 
1308                 break;
1309             case ON_OR_INSERT:
1310                 if (index == -1) {
1311                     location = new DropLocation(p, getModel().getSize(), true);
1312                     break;
1313                 }
1314 
1315                 boolean between = false;
1316 
1317                 if (layoutOrientation == HORIZONTAL_WRAP) {
1318                     boolean ltr = getComponentOrientation().isLeftToRight();
1319 
1320                     Section section = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);
1321                     if (section == TRAILING) {
1322                         index++;
1323                         between = true;
1324                     // special case for below all cells
1325                     } else if (index == getModel().getSize() - 1 &amp;&amp; p.y &gt;= rect.y + rect.height) {
1326                         index++;
1327                         between = true;
1328                     } else if (section == LEADING) {
1329                         between = true;
1330                     }
1331                 } else {
1332                     Section section = SwingUtilities2.liesInVertical(rect, p, true);
1333                     if (section == LEADING) {
1334                         between = true;
1335                     } else if (section == TRAILING) {
1336                         index++;
1337                         between = true;
1338                     }
1339                 }
1340 
1341                 location = new DropLocation(p, index, between);
1342 
1343                 break;
1344             default:
1345                 assert false : &quot;Unexpected drop mode&quot;;
1346         }
1347 
1348         return location;
1349     }
1350 
1351     /**
1352      * Called to set or clear the drop location during a DnD operation.
1353      * In some cases, the component may need to use it&#39;s internal selection
1354      * temporarily to indicate the drop location. To help facilitate this,
1355      * this method returns and accepts as a parameter a state object.
1356      * This state object can be used to store, and later restore, the selection
1357      * state. Whatever this method returns will be passed back to it in
1358      * future calls, as the state parameter. If it wants the DnD system to
1359      * continue storing the same state, it must pass it back every time.
1360      * Here&#39;s how this is used:
1361      * &lt;p&gt;
1362      * Let&#39;s say that on the first call to this method the component decides
1363      * to save some state (because it is about to use the selection to show
1364      * a drop index). It can return a state object to the caller encapsulating
1365      * any saved selection state. On a second call, let&#39;s say the drop location
1366      * is being changed to something else. The component doesn&#39;t need to
1367      * restore anything yet, so it simply passes back the same state object
1368      * to have the DnD system continue storing it. Finally, let&#39;s say this
1369      * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
1370      * is finished with this component for now, meaning it should restore
1371      * state. At this point, it can use the state parameter to restore
1372      * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there&#39;s
1373      * no longer anything to store.
1374      *
1375      * @param location the drop location (as calculated by
1376      *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
1377      *        if there&#39;s no longer a valid drop location
1378      * @param state the state object saved earlier for this component,
1379      *        or &lt;code&gt;null&lt;/code&gt;
1380      * @param forDrop whether or not the method is being called because an
1381      *        actual drop occurred
1382      * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
1383      */
1384     Object setDropLocation(TransferHandler.DropLocation location,
1385                            Object state,
1386                            boolean forDrop) {
1387 
1388         Object retVal = null;
1389         DropLocation listLocation = (DropLocation)location;
1390 
1391         if (dropMode == DropMode.USE_SELECTION) {
1392             if (listLocation == null) {
1393                 if (!forDrop &amp;&amp; state != null) {
1394                     setSelectedIndices(((int[][])state)[0]);
1395 
1396                     int anchor = ((int[][])state)[1][0];
1397                     int lead = ((int[][])state)[1][1];
1398 
1399                     SwingUtilities2.setLeadAnchorWithoutSelection(
1400                             getSelectionModel(), lead, anchor);
1401                 }
1402             } else {
1403                 if (dropLocation == null) {
1404                     int[] inds = getSelectedIndices();
1405                     retVal = new int[][] {inds, {getAnchorSelectionIndex(),
1406                                                  getLeadSelectionIndex()}};
1407                 } else {
1408                     retVal = state;
1409                 }
1410 
1411                 int index = listLocation.getIndex();
1412                 if (index == -1) {
1413                     clearSelection();
1414                     getSelectionModel().setAnchorSelectionIndex(-1);
1415                     getSelectionModel().setLeadSelectionIndex(-1);
1416                 } else {
1417                     setSelectionInterval(index, index);
1418                 }
1419             }
1420         }
1421 
1422         DropLocation old = dropLocation;
1423         dropLocation = listLocation;
1424         firePropertyChange(&quot;dropLocation&quot;, old, dropLocation);
1425 
1426         return retVal;
1427     }
1428 
1429     /**
1430      * Returns the location that this component should visually indicate
1431      * as the drop location during a DnD operation over the component,
1432      * or {@code null} if no location is to currently be shown.
1433      * &lt;p&gt;
1434      * This method is not meant for querying the drop location
1435      * from a {@code TransferHandler}, as the drop location is only
1436      * set after the {@code TransferHandler}&#39;s &lt;code&gt;canImport&lt;/code&gt;
1437      * has returned and has allowed for the location to be shown.
1438      * &lt;p&gt;
1439      * When this property changes, a property change event with
1440      * name &quot;dropLocation&quot; is fired by the component.
1441      * &lt;p&gt;
1442      * By default, responsibility for listening for changes to this property
1443      * and indicating the drop location visually lies with the list&#39;s
1444      * {@code ListUI}, which may paint it directly and/or install a cell
1445      * renderer to do so. Developers wishing to implement custom drop location
1446      * painting and/or replace the default cell renderer, may need to honor
1447      * this property.
1448      *
1449      * @return the drop location
1450      * @see #setDropMode
1451      * @see TransferHandler#canImport(TransferHandler.TransferSupport)
1452      * @since 1.6
1453      */
1454     @BeanProperty(bound = false)
1455     public final DropLocation getDropLocation() {
1456         return dropLocation;
1457     }
1458 
1459     /**
1460      * Returns the next list element whose {@code toString} value
1461      * starts with the given prefix.
1462      *
1463      * @param prefix the string to test for a match
1464      * @param startIndex the index for starting the search
1465      * @param bias the search direction, either
1466      * Position.Bias.Forward or Position.Bias.Backward.
1467      * @return the index of the next list element that
1468      * starts with the prefix; otherwise {@code -1}
1469      * @exception IllegalArgumentException if prefix is {@code null}
1470      * or startIndex is out of bounds
1471      * @since 1.4
1472      */
1473     public int getNextMatch(String prefix, int startIndex, Position.Bias bias) {
1474         ListModel&lt;E&gt; model = getModel();
1475         int max = model.getSize();
1476         if (prefix == null) {
1477             throw new IllegalArgumentException();
1478         }
1479         if (startIndex &lt; 0 || startIndex &gt;= max) {
1480             throw new IllegalArgumentException();
1481         }
1482         prefix = prefix.toUpperCase();
1483 
1484         // start search from the next element after the selected element
1485         int increment = (bias == Position.Bias.Forward) ? 1 : -1;
1486         int index = startIndex;
1487         do {
1488             E element = model.getElementAt(index);
1489 
1490             if (element != null) {
1491                 String string;
1492 
1493                 if (element instanceof String) {
1494                     string = ((String)element).toUpperCase();
1495                 }
1496                 else {
1497                     string = element.toString();
1498                     if (string != null) {
1499                         string = string.toUpperCase();
1500                     }
1501                 }
1502 
1503                 if (string != null &amp;&amp; string.startsWith(prefix)) {
1504                     return index;
1505                 }
1506             }
1507             index = (index + increment + max) % max;
1508         } while (index != startIndex);
1509         return -1;
1510     }
1511 
1512     /**
1513      * Returns the tooltip text to be used for the given event. This overrides
1514      * {@code JComponent}&#39;s {@code getToolTipText} to first check the cell
1515      * renderer component for the cell over which the event occurred, returning
1516      * its tooltip text, if any. This implementation allows you to specify
1517      * tooltip text on the cell level, by using {@code setToolTipText} on your
1518      * cell renderer component.
1519      * &lt;p&gt;
1520      * &lt;strong&gt;Note:&lt;/strong&gt; For &lt;code&gt;JList&lt;/code&gt; to properly display the
1521      * tooltips of its renderers in this manner, &lt;code&gt;JList&lt;/code&gt; must be a
1522      * registered component with the &lt;code&gt;ToolTipManager&lt;/code&gt;. This registration
1523      * is done automatically in the constructor. However, if at a later point
1524      * &lt;code&gt;JList&lt;/code&gt; is unregistered, by way of a call to
1525      * {@code setToolTipText(null)}, tips from the renderers will no longer display.
1526      *
1527      * @param event the {@code MouseEvent} to fetch the tooltip text for
1528      * @see JComponent#setToolTipText
1529      * @see JComponent#getToolTipText
1530      */
1531     @SuppressWarnings(&quot;deprecation&quot;)
1532     public String getToolTipText(MouseEvent event) {
1533         if(event != null) {
1534             Point p = event.getPoint();
1535             int index = locationToIndex(p);
1536             ListCellRenderer&lt;? super E&gt; r = getCellRenderer();
1537             Rectangle cellBounds;
1538 
1539             if (index != -1 &amp;&amp; r != null &amp;&amp; (cellBounds =
1540                                getCellBounds(index, index)) != null &amp;&amp;
1541                                cellBounds.contains(p.x, p.y)) {
1542                 ListSelectionModel lsm = getSelectionModel();
1543                 Component rComponent = r.getListCellRendererComponent(
1544                            this, getModel().getElementAt(index), index,
1545                            lsm.isSelectedIndex(index),
1546                            (hasFocus() &amp;&amp; (lsm.getLeadSelectionIndex() ==
1547                                            index)));
1548 
1549                 if(rComponent instanceof JComponent) {
1550                     MouseEvent      newEvent;
1551 
1552                     p.translate(-cellBounds.x, -cellBounds.y);
1553                     newEvent = new MouseEvent(rComponent, event.getID(),
1554                                               event.getWhen(),
1555                                               event.getModifiers(),
1556                                               p.x, p.y,
1557                                               event.getXOnScreen(),
1558                                               event.getYOnScreen(),
1559                                               event.getClickCount(),
1560                                               event.isPopupTrigger(),
1561                                               MouseEvent.NOBUTTON);
1562                     MouseEventAccessor meAccessor =
1563                         AWTAccessor.getMouseEventAccessor();
1564                     meAccessor.setCausedByTouchEvent(newEvent,
1565                         meAccessor.isCausedByTouchEvent(event));
1566 
1567                     String tip = ((JComponent)rComponent).getToolTipText(
1568                                               newEvent);
1569 
1570                     if (tip != null) {
1571                         return tip;
1572                     }
1573                 }
1574             }
1575         }
1576         return super.getToolTipText();
1577     }
1578 
1579     /**
1580      * --- ListUI Delegations ---
1581      */
1582 
1583 
1584     /**
1585      * Returns the cell index closest to the given location in the list&#39;s
1586      * coordinate system. To determine if the cell actually contains the
1587      * specified location, compare the point against the cell&#39;s bounds,
1588      * as provided by {@code getCellBounds}. This method returns {@code -1}
1589      * if the model is empty
1590      * &lt;p&gt;
1591      * This is a cover method that delegates to the method of the same name
1592      * in the list&#39;s {@code ListUI}. It returns {@code -1} if the list has
1593      * no {@code ListUI}.
1594      *
1595      * @param location the coordinates of the point
1596      * @return the cell index closest to the given location, or {@code -1}
1597      */
1598     public int locationToIndex(Point location) {
1599         ListUI ui = getUI();
1600         return (ui != null) ? ui.locationToIndex(this, location) : -1;
1601     }
1602 
1603 
1604     /**
1605      * Returns the origin of the specified item in the list&#39;s coordinate
1606      * system. This method returns {@code null} if the index isn&#39;t valid.
1607      * &lt;p&gt;
1608      * This is a cover method that delegates to the method of the same name
1609      * in the list&#39;s {@code ListUI}. It returns {@code null} if the list has
1610      * no {@code ListUI}.
1611      *
1612      * @param index the cell index
1613      * @return the origin of the cell, or {@code null}
1614      */
1615     public Point indexToLocation(int index) {
1616         ListUI ui = getUI();
1617         return (ui != null) ? ui.indexToLocation(this, index) : null;
1618     }
1619 
1620 
1621     /**
1622      * Returns the bounding rectangle, in the list&#39;s coordinate system,
1623      * for the range of cells specified by the two indices.
1624      * These indices can be supplied in any order.
1625      * &lt;p&gt;
1626      * If the smaller index is outside the list&#39;s range of cells, this method
1627      * returns {@code null}. If the smaller index is valid, but the larger
1628      * index is outside the list&#39;s range, the bounds of just the first index
1629      * is returned. Otherwise, the bounds of the valid range is returned.
1630      * &lt;p&gt;
1631      * This is a cover method that delegates to the method of the same name
1632      * in the list&#39;s {@code ListUI}. It returns {@code null} if the list has
1633      * no {@code ListUI}.
1634      *
1635      * @param index0 the first index in the range
1636      * @param index1 the second index in the range
1637      * @return the bounding rectangle for the range of cells, or {@code null}
1638      */
1639     public Rectangle getCellBounds(int index0, int index1) {
1640         ListUI ui = getUI();
1641         return (ui != null) ? ui.getCellBounds(this, index0, index1) : null;
1642     }
1643 
1644 
1645     /**
1646      * --- ListModel Support ---
1647      */
1648 
1649 
1650     /**
1651      * Returns the data model that holds the list of items displayed
1652      * by the &lt;code&gt;JList&lt;/code&gt; component.
1653      *
1654      * @return the &lt;code&gt;ListModel&lt;/code&gt; that provides the displayed
1655      *                          list of items
1656      * @see #setModel
1657      */
1658     public ListModel&lt;E&gt; getModel() {
1659         return dataModel;
1660     }
1661 
1662     /**
1663      * Sets the model that represents the contents or &quot;value&quot; of the
1664      * list, notifies property change listeners, and then clears the
1665      * list&#39;s selection.
1666      * &lt;p&gt;
1667      * This is a JavaBeans bound property.
1668      *
1669      * @param model  the &lt;code&gt;ListModel&lt;/code&gt; that provides the
1670      *                                          list of items for display
1671      * @exception IllegalArgumentException  if &lt;code&gt;model&lt;/code&gt; is
1672      *                                          &lt;code&gt;null&lt;/code&gt;
1673      * @see #getModel
1674      * @see #clearSelection
1675      */
1676     @BeanProperty(visualUpdate = true, description
1677             = &quot;The object that contains the data to be drawn by this JList.&quot;)
1678     public void setModel(ListModel&lt;E&gt; model) {
1679         if (model == null) {
1680             throw new IllegalArgumentException(&quot;model must be non null&quot;);
1681         }
1682         ListModel&lt;E&gt; oldValue = dataModel;
1683         dataModel = model;
1684         firePropertyChange(&quot;model&quot;, oldValue, dataModel);
1685         clearSelection();
1686     }
1687 
1688 
1689     /**
1690      * Constructs a read-only &lt;code&gt;ListModel&lt;/code&gt; from an array of items,
1691      * and calls {@code setModel} with this model.
1692      * &lt;p&gt;
1693      * Attempts to pass a {@code null} value to this method results in
1694      * undefined behavior and, most likely, exceptions. The created model
1695      * references the given array directly. Attempts to modify the array
1696      * after invoking this method results in undefined behavior.
1697      *
1698      * @param listData an array of {@code E} containing the items to
1699      *        display in the list
1700      * @see #setModel
1701      */
1702     public void setListData(final E[] listData) {
1703         setModel (
1704             new AbstractListModel&lt;E&gt;() {
1705                 public int getSize() { return listData.length; }
1706                 public E getElementAt(int i) { return listData[i]; }
1707             }
1708         );
1709     }
1710 
1711 
1712     /**
1713      * Constructs a read-only &lt;code&gt;ListModel&lt;/code&gt; from a &lt;code&gt;Vector&lt;/code&gt;
1714      * and calls {@code setModel} with this model.
1715      * &lt;p&gt;
1716      * Attempts to pass a {@code null} value to this method results in
1717      * undefined behavior and, most likely, exceptions. The created model
1718      * references the given {@code Vector} directly. Attempts to modify the
1719      * {@code Vector} after invoking this method results in undefined behavior.
1720      *
1721      * @param listData a &lt;code&gt;Vector&lt;/code&gt; containing the items to
1722      *                                          display in the list
1723      * @see #setModel
1724      */
1725     public void setListData(final Vector&lt;? extends E&gt; listData) {
1726         setModel (
1727             new AbstractListModel&lt;E&gt;() {
1728                 public int getSize() { return listData.size(); }
1729                 public E getElementAt(int i) { return listData.elementAt(i); }
1730             }
1731         );
1732     }
1733 
1734 
1735     /**
1736      * --- ListSelectionModel delegations and extensions ---
1737      */
1738 
1739 
1740     /**
1741      * Returns an instance of {@code DefaultListSelectionModel}; called
1742      * during construction to initialize the list&#39;s selection model
1743      * property.
1744      *
1745      * @return a {@code DefaultListSelecitonModel}, used to initialize
1746      *         the list&#39;s selection model property during construction
1747      * @see #setSelectionModel
1748      * @see DefaultListSelectionModel
1749      */
1750     protected ListSelectionModel createSelectionModel() {
1751         return new DefaultListSelectionModel();
1752     }
1753 
1754 
1755     /**
1756      * Returns the current selection model. The selection model maintains the
1757      * selection state of the list. See the class level documentation for more
1758      * details.
1759      *
1760      * @return the &lt;code&gt;ListSelectionModel&lt;/code&gt; that maintains the
1761      *         list&#39;s selections
1762      *
1763      * @see #setSelectionModel
1764      * @see ListSelectionModel
1765      */
1766     public ListSelectionModel getSelectionModel() {
1767         return selectionModel;
1768     }
1769 
1770 
1771     /**
1772      * Notifies {@code ListSelectionListener}s added directly to the list
1773      * of selection changes made to the selection model. {@code JList}
1774      * listens for changes made to the selection in the selection model,
1775      * and forwards notification to listeners added to the list directly,
1776      * by calling this method.
1777      * &lt;p&gt;
1778      * This method constructs a {@code ListSelectionEvent} with this list
1779      * as the source, and the specified arguments, and sends it to the
1780      * registered {@code ListSelectionListeners}.
1781      *
1782      * @param firstIndex the first index in the range, {@code &lt;= lastIndex}
1783      * @param lastIndex the last index in the range, {@code &gt;= firstIndex}
1784      * @param isAdjusting whether or not this is one in a series of
1785      *        multiple events, where changes are still being made
1786      *
1787      * @see #addListSelectionListener
1788      * @see #removeListSelectionListener
1789      * @see javax.swing.event.ListSelectionEvent
1790      * @see EventListenerList
1791      */
1792     protected void fireSelectionValueChanged(int firstIndex, int lastIndex,
1793                                              boolean isAdjusting)
1794     {
1795         Object[] listeners = listenerList.getListenerList();
1796         ListSelectionEvent e = null;
1797 
1798         for (int i = listeners.length - 2; i &gt;= 0; i -= 2) {
1799             if (listeners[i] == ListSelectionListener.class) {
1800                 if (e == null) {
1801                     e = new ListSelectionEvent(this, firstIndex, lastIndex,
1802                                                isAdjusting);
1803                 }
1804                 ((ListSelectionListener)listeners[i+1]).valueChanged(e);
1805             }
1806         }
1807     }
1808 
1809 
1810     /* A ListSelectionListener that forwards ListSelectionEvents from
1811      * the selectionModel to the JList ListSelectionListeners.  The
1812      * forwarded events only differ from the originals in that their
1813      * source is the JList instead of the selectionModel itself.
1814      */
1815     private class ListSelectionHandler implements ListSelectionListener, Serializable
1816     {
1817         public void valueChanged(ListSelectionEvent e) {
1818             fireSelectionValueChanged(e.getFirstIndex(),
1819                                       e.getLastIndex(),
1820                                       e.getValueIsAdjusting());
1821         }
1822     }
1823 
1824 
1825     /**
1826      * Adds a listener to the list, to be notified each time a change to the
1827      * selection occurs; the preferred way of listening for selection state
1828      * changes. {@code JList} takes care of listening for selection state
1829      * changes in the selection model, and notifies the given listener of
1830      * each change. {@code ListSelectionEvent}s sent to the listener have a
1831      * {@code source} property set to this list.
1832      *
1833      * @param listener the {@code ListSelectionListener} to add
1834      * @see #getSelectionModel
1835      * @see #getListSelectionListeners
1836      */
1837     public void addListSelectionListener(ListSelectionListener listener)
1838     {
1839         if (selectionListener == null) {
1840             selectionListener = new ListSelectionHandler();
1841             getSelectionModel().addListSelectionListener(selectionListener);
1842         }
1843 
1844         listenerList.add(ListSelectionListener.class, listener);
1845     }
1846 
1847 
1848     /**
1849      * Removes a selection listener from the list.
1850      *
1851      * @param listener the {@code ListSelectionListener} to remove
1852      * @see #addListSelectionListener
1853      * @see #getSelectionModel
1854      */
1855     public void removeListSelectionListener(ListSelectionListener listener) {
1856         listenerList.remove(ListSelectionListener.class, listener);
1857     }
1858 
1859 
1860     /**
1861      * Returns an array of all the {@code ListSelectionListener}s added
1862      * to this {@code JList} by way of {@code addListSelectionListener}.
1863      *
1864      * @return all of the {@code ListSelectionListener}s on this list, or
1865      *         an empty array if no listeners have been added
1866      * @see #addListSelectionListener
1867      * @since 1.4
1868      */
1869     @BeanProperty(bound = false)
1870     public ListSelectionListener[] getListSelectionListeners() {
1871         return listenerList.getListeners(ListSelectionListener.class);
1872     }
1873 
1874 
1875     /**
1876      * Sets the &lt;code&gt;selectionModel&lt;/code&gt; for the list to a
1877      * non-&lt;code&gt;null&lt;/code&gt; &lt;code&gt;ListSelectionModel&lt;/code&gt;
1878      * implementation. The selection model handles the task of making single
1879      * selections, selections of contiguous ranges, and non-contiguous
1880      * selections.
1881      * &lt;p&gt;
1882      * This is a JavaBeans bound property.
1883      *
1884      * @param selectionModel  the &lt;code&gt;ListSelectionModel&lt;/code&gt; that
1885      *                          implements the selections
1886      * @exception IllegalArgumentException   if &lt;code&gt;selectionModel&lt;/code&gt;
1887      *                                          is &lt;code&gt;null&lt;/code&gt;
1888      * @see #getSelectionModel
1889      */
1890     @BeanProperty(description
1891             = &quot;The selection model, recording which cells are selected.&quot;)
1892     public void setSelectionModel(ListSelectionModel selectionModel) {
1893         if (selectionModel == null) {
1894             throw new IllegalArgumentException(&quot;selectionModel must be non null&quot;);
1895         }
1896 
1897         /* Remove the forwarding ListSelectionListener from the old
1898          * selectionModel, and add it to the new one, if necessary.
1899          */
1900         if (selectionListener != null) {
1901             this.selectionModel.removeListSelectionListener(selectionListener);
1902             selectionModel.addListSelectionListener(selectionListener);
1903         }
1904 
1905         ListSelectionModel oldValue = this.selectionModel;
1906         this.selectionModel = selectionModel;
1907         firePropertyChange(&quot;selectionModel&quot;, oldValue, selectionModel);
1908     }
1909 
1910 
1911     /**
1912      * Sets the selection mode for the list. This is a cover method that sets
1913      * the selection mode directly on the selection model.
1914      * &lt;p&gt;
1915      * The following list describes the accepted selection modes:
1916      * &lt;ul&gt;
1917      * &lt;li&gt;{@code ListSelectionModel.SINGLE_SELECTION} -
1918      *   Only one list index can be selected at a time. In this mode,
1919      *   {@code setSelectionInterval} and {@code addSelectionInterval} are
1920      *   equivalent, both replacing the current selection with the index
1921      *   represented by the second argument (the &quot;lead&quot;).
1922      * &lt;li&gt;{@code ListSelectionModel.SINGLE_INTERVAL_SELECTION} -
1923      *   Only one contiguous interval can be selected at a time.
1924      *   In this mode, {@code addSelectionInterval} behaves like
1925      *   {@code setSelectionInterval} (replacing the current selection},
1926      *   unless the given interval is immediately adjacent to or overlaps
1927      *   the existing selection, and can be used to grow the selection.
1928      * &lt;li&gt;{@code ListSelectionModel.MULTIPLE_INTERVAL_SELECTION} -
1929      *   In this mode, there&#39;s no restriction on what can be selected.
1930      *   This mode is the default.
1931      * &lt;/ul&gt;
1932      *
1933      * @param selectionMode the selection mode
1934      * @see #getSelectionMode
1935      * @throws IllegalArgumentException if the selection mode isn&#39;t
1936      *         one of those allowed
1937      */
1938     @BeanProperty(bound = false, enumerationValues = {
1939             &quot;ListSelectionModel.SINGLE_SELECTION&quot;,
1940             &quot;ListSelectionModel.SINGLE_INTERVAL_SELECTION&quot;,
1941             &quot;ListSelectionModel.MULTIPLE_INTERVAL_SELECTION&quot;}, description
1942             = &quot;The selection mode.&quot;)
1943     public void setSelectionMode(int selectionMode) {
1944         getSelectionModel().setSelectionMode(selectionMode);
1945     }
1946 
1947     /**
1948      * Returns the current selection mode for the list. This is a cover
1949      * method that delegates to the method of the same name on the
1950      * list&#39;s selection model.
1951      *
1952      * @return the current selection mode
1953      * @see #setSelectionMode
1954      */
1955     public int getSelectionMode() {
1956         return getSelectionModel().getSelectionMode();
1957     }
1958 
1959 
1960     /**
1961      * Returns the anchor selection index. This is a cover method that
1962      * delegates to the method of the same name on the list&#39;s selection model.
1963      *
1964      * @return the anchor selection index
1965      * @see ListSelectionModel#getAnchorSelectionIndex
1966      */
1967     @BeanProperty(bound = false)
1968     public int getAnchorSelectionIndex() {
1969         return getSelectionModel().getAnchorSelectionIndex();
1970     }
1971 
1972 
1973     /**
1974      * Returns the lead selection index. This is a cover method that
1975      * delegates to the method of the same name on the list&#39;s selection model.
1976      *
1977      * @return the lead selection index
1978      * @see ListSelectionModel#getLeadSelectionIndex
1979      */
1980     @BeanProperty(bound = false, description
1981             = &quot;The lead selection index.&quot;)
1982     public int getLeadSelectionIndex() {
1983         return getSelectionModel().getLeadSelectionIndex();
1984     }
1985 
1986 
1987     /**
1988      * Returns the smallest selected cell index, or {@code -1} if the selection
1989      * is empty. This is a cover method that delegates to the method of the same
1990      * name on the list&#39;s selection model.
1991      *
1992      * @return the smallest selected cell index, or {@code -1}
1993      * @see ListSelectionModel#getMinSelectionIndex
1994      */
1995     @BeanProperty(bound = false)
1996     public int getMinSelectionIndex() {
1997         return getSelectionModel().getMinSelectionIndex();
1998     }
1999 
2000 
2001     /**
2002      * Returns the largest selected cell index, or {@code -1} if the selection
2003      * is empty. This is a cover method that delegates to the method of the same
2004      * name on the list&#39;s selection model.
2005      *
2006      * @return the largest selected cell index
2007      * @see ListSelectionModel#getMaxSelectionIndex
2008      */
2009     @BeanProperty(bound = false)
2010     public int getMaxSelectionIndex() {
2011         return getSelectionModel().getMaxSelectionIndex();
2012     }
2013 
2014 
2015     /**
2016      * Returns {@code true} if the specified index is selected,
2017      * else {@code false}. This is a cover method that delegates to the method
2018      * of the same name on the list&#39;s selection model.
2019      *
2020      * @param index index to be queried for selection state
2021      * @return {@code true} if the specified index is selected,
2022      *         else {@code false}
2023      * @see ListSelectionModel#isSelectedIndex
2024      * @see #setSelectedIndex
2025      */
2026     public boolean isSelectedIndex(int index) {
2027         return getSelectionModel().isSelectedIndex(index);
2028     }
2029 
2030 
2031     /**
2032      * Returns {@code true} if nothing is selected, else {@code false}.
2033      * This is a cover method that delegates to the method of the same
2034      * name on the list&#39;s selection model.
2035      *
2036      * @return {@code true} if nothing is selected, else {@code false}
2037      * @see ListSelectionModel#isSelectionEmpty
2038      * @see #clearSelection
2039      */
2040     @BeanProperty(bound = false)
2041     public boolean isSelectionEmpty() {
2042         return getSelectionModel().isSelectionEmpty();
2043     }
2044 
2045 
2046     /**
2047      * Clears the selection; after calling this method, {@code isSelectionEmpty}
2048      * will return {@code true}. This is a cover method that delegates to the
2049      * method of the same name on the list&#39;s selection model.
2050      *
2051      * @see ListSelectionModel#clearSelection
2052      * @see #isSelectionEmpty
2053      */
2054     public void clearSelection() {
2055         getSelectionModel().clearSelection();
2056     }
2057 
2058 
2059     /**
2060      * Selects the specified interval. Both {@code anchor} and {@code lead}
2061      * indices are included. {@code anchor} doesn&#39;t have to be less than or
2062      * equal to {@code lead}. This is a cover method that delegates to the
2063      * method of the same name on the list&#39;s selection model.
2064      * &lt;p&gt;
2065      * Refer to the documentation of the selection model class being used
2066      * for details on how values less than {@code 0} are handled.
2067      *
2068      * @param anchor the first index to select
2069      * @param lead the last index to select
2070      * @see ListSelectionModel#setSelectionInterval
2071      * @see DefaultListSelectionModel#setSelectionInterval
2072      * @see #createSelectionModel
2073      * @see #addSelectionInterval
2074      * @see #removeSelectionInterval
2075      */
2076     public void setSelectionInterval(int anchor, int lead) {
2077         getSelectionModel().setSelectionInterval(anchor, lead);
2078     }
2079 
2080 
2081     /**
2082      * Sets the selection to be the union of the specified interval with current
2083      * selection. Both the {@code anchor} and {@code lead} indices are
2084      * included. {@code anchor} doesn&#39;t have to be less than or
2085      * equal to {@code lead}. This is a cover method that delegates to the
2086      * method of the same name on the list&#39;s selection model.
2087      * &lt;p&gt;
2088      * Refer to the documentation of the selection model class being used
2089      * for details on how values less than {@code 0} are handled.
2090      *
2091      * @param anchor the first index to add to the selection
2092      * @param lead the last index to add to the selection
2093      * @see ListSelectionModel#addSelectionInterval
2094      * @see DefaultListSelectionModel#addSelectionInterval
2095      * @see #createSelectionModel
2096      * @see #setSelectionInterval
2097      * @see #removeSelectionInterval
2098      */
2099     public void addSelectionInterval(int anchor, int lead) {
2100         getSelectionModel().addSelectionInterval(anchor, lead);
2101     }
2102 
2103 
2104     /**
2105      * Sets the selection to be the set difference of the specified interval
2106      * and the current selection. Both the {@code index0} and {@code index1}
2107      * indices are removed. {@code index0} doesn&#39;t have to be less than or
2108      * equal to {@code index1}. This is a cover method that delegates to the
2109      * method of the same name on the list&#39;s selection model.
2110      * &lt;p&gt;
2111      * Refer to the documentation of the selection model class being used
2112      * for details on how values less than {@code 0} are handled.
2113      *
2114      * @param index0 the first index to remove from the selection
2115      * @param index1 the last index to remove from the selection
2116      * @see ListSelectionModel#removeSelectionInterval
2117      * @see DefaultListSelectionModel#removeSelectionInterval
2118      * @see #createSelectionModel
2119      * @see #setSelectionInterval
2120      * @see #addSelectionInterval
2121      */
2122     public void removeSelectionInterval(int index0, int index1) {
2123         getSelectionModel().removeSelectionInterval(index0, index1);
2124     }
2125 
2126 
2127     /**
2128      * Sets the selection model&#39;s {@code valueIsAdjusting} property. When
2129      * {@code true}, upcoming changes to selection should be considered part
2130      * of a single change. This property is used internally and developers
2131      * typically need not call this method. For example, when the model is being
2132      * updated in response to a user drag, the value of the property is set
2133      * to {@code true} when the drag is initiated and set to {@code false}
2134      * when the drag is finished. This allows listeners to update only
2135      * when a change has been finalized, rather than handling all of the
2136      * intermediate values.
2137      * &lt;p&gt;
2138      * You may want to use this directly if making a series of changes
2139      * that should be considered part of a single change.
2140      * &lt;p&gt;
2141      * This is a cover method that delegates to the method of the same name on
2142      * the list&#39;s selection model. See the documentation for
2143      * {@link javax.swing.ListSelectionModel#setValueIsAdjusting} for
2144      * more details.
2145      *
2146      * @param b the new value for the property
2147      * @see ListSelectionModel#setValueIsAdjusting
2148      * @see javax.swing.event.ListSelectionEvent#getValueIsAdjusting
2149      * @see #getValueIsAdjusting
2150      */
2151     public void setValueIsAdjusting(boolean b) {
2152         getSelectionModel().setValueIsAdjusting(b);
2153     }
2154 
2155 
2156     /**
2157      * Returns the value of the selection model&#39;s {@code isAdjusting} property.
2158      * &lt;p&gt;
2159      * This is a cover method that delegates to the method of the same name on
2160      * the list&#39;s selection model.
2161      *
2162      * @return the value of the selection model&#39;s {@code isAdjusting} property.
2163      *
2164      * @see #setValueIsAdjusting
2165      * @see ListSelectionModel#getValueIsAdjusting
2166      */
2167     public boolean getValueIsAdjusting() {
2168         return getSelectionModel().getValueIsAdjusting();
2169     }
2170 
2171 
2172     /**
2173      * Returns an array of all of the selected indices, in increasing
2174      * order.
2175      *
2176      * @return all of the selected indices, in increasing order,
2177      *         or an empty array if nothing is selected
2178      * @see #removeSelectionInterval
2179      * @see #addListSelectionListener
2180      */
2181     @Transient
2182     public int[] getSelectedIndices() {
2183         return getSelectionModel().getSelectedIndices();
2184     }
2185 
2186 
2187     /**
2188      * Selects a single cell. Does nothing if the given index is greater
2189      * than or equal to the model size. This is a convenience method that uses
2190      * {@code setSelectionInterval} on the selection model. Refer to the
2191      * documentation for the selection model class being used for details on
2192      * how values less than {@code 0} are handled.
2193      *
2194      * @param index the index of the cell to select
2195      * @see ListSelectionModel#setSelectionInterval
2196      * @see #isSelectedIndex
2197      * @see #addListSelectionListener
2198      */
2199     @BeanProperty(bound = false, description
2200             = &quot;The index of the selected cell.&quot;)
2201     public void setSelectedIndex(int index) {
2202         if (index &gt;= getModel().getSize()) {
2203             return;
2204         }
2205         getSelectionModel().setSelectionInterval(index, index);
2206     }
2207 
2208 
2209     /**
2210      * Changes the selection to be the set of indices specified by the given
2211      * array. Indices greater than or equal to the model size are ignored.
2212      * This is a convenience method that clears the selection and then uses
2213      * {@code addSelectionInterval} on the selection model to add the indices.
2214      * Refer to the documentation of the selection model class being used for
2215      * details on how values less than {@code 0} are handled.
2216      *
2217      * @param indices an array of the indices of the cells to select,
2218      *                {@code non-null}
2219      * @see ListSelectionModel#addSelectionInterval
2220      * @see #isSelectedIndex
2221      * @see #addListSelectionListener
2222      * @throws NullPointerException if the given array is {@code null}
2223      */
2224     public void setSelectedIndices(int[] indices) {
2225         ListSelectionModel sm = getSelectionModel();
2226         sm.clearSelection();
2227         int size = getModel().getSize();
2228         for (int i : indices) {
2229             if (i &lt; size) {
2230                 sm.addSelectionInterval(i, i);
2231             }
2232         }
2233     }
2234 
2235 
2236     /**
2237      * Returns an array of all the selected values, in increasing order based
2238      * on their indices in the list.
2239      *
2240      * @return the selected values, or an empty array if nothing is selected
2241      * @see #isSelectedIndex
2242      * @see #getModel
2243      * @see #addListSelectionListener
2244      *
2245      * @deprecated As of JDK 1.7, replaced by {@link #getSelectedValuesList()}
2246      */
2247     @Deprecated
2248     @BeanProperty(bound = false)
2249     public Object[] getSelectedValues() {
2250         ListSelectionModel sm = getSelectionModel();
2251         ListModel&lt;E&gt; dm = getModel();
2252 
2253         int iMin = sm.getMinSelectionIndex();
2254         int iMax = sm.getMaxSelectionIndex();
2255         int size = dm.getSize();
2256 
2257         if ((iMin &lt; 0) || (iMax &lt; 0) || (iMin &gt;= size)) {
2258             return new Object[0];
2259         }
2260         iMax = iMax &lt; size ? iMax : size - 1;
2261 
2262         Object[] rvTmp = new Object[1+ (iMax - iMin)];
2263         int n = 0;
2264         for(int i = iMin; i &lt;= iMax; i++) {
2265             if (sm.isSelectedIndex(i)) {
2266                 rvTmp[n++] = dm.getElementAt(i);
2267             }
2268         }
2269         Object[] rv = new Object[n];
2270         System.arraycopy(rvTmp, 0, rv, 0, n);
2271         return rv;
2272     }
2273 
2274     /**
2275      * Returns a list of all the selected items, in increasing order based
2276      * on their indices in the list.
2277      *
2278      * @return the selected items, or an empty list if nothing is selected
2279      * @see #isSelectedIndex
2280      * @see #getModel
2281      * @see #addListSelectionListener
2282      *
2283      * @since 1.7
2284      */
2285     @BeanProperty(bound = false)
2286     public List&lt;E&gt; getSelectedValuesList() {
2287         ListModel&lt;E&gt; dm = getModel();
2288         int[] selectedIndices = getSelectedIndices();
2289 
2290         if (selectedIndices.length &gt; 0) {
2291             int size = dm.getSize();
2292             if (selectedIndices[0] &gt;= size) {
2293                 return Collections.emptyList();
2294             }
2295             List&lt;E&gt; selectedItems = new ArrayList&lt;E&gt;();
2296             for (int i : selectedIndices) {
2297                 if (i &gt;= size)
2298                     break;
2299                 selectedItems.add(dm.getElementAt(i));
2300             }
2301             return selectedItems;
2302         }
2303         return Collections.emptyList();
2304     }
2305 
2306 
2307     /**
2308      * Returns the smallest selected cell index; &lt;i&gt;the selection&lt;/i&gt; when only
2309      * a single item is selected in the list. When multiple items are selected,
2310      * it is simply the smallest selected index. Returns {@code -1} if there is
2311      * no selection.
2312      * &lt;p&gt;
2313      * This method is a cover that delegates to {@code getMinSelectionIndex}.
2314      *
2315      * @return the smallest selected cell index
2316      * @see #getMinSelectionIndex
2317      * @see #addListSelectionListener
2318      */
2319     public int getSelectedIndex() {
2320         return getMinSelectionIndex();
2321     }
2322 
2323 
2324     /**
2325      * Returns the value for the smallest selected cell index;
2326      * &lt;i&gt;the selected value&lt;/i&gt; when only a single item is selected in the
2327      * list. When multiple items are selected, it is simply the value for the
2328      * smallest selected index. Returns {@code null} if there is no selection.
2329      * &lt;p&gt;
2330      * This is a convenience method that simply returns the model value for
2331      * {@code getMinSelectionIndex}.
2332      *
2333      * @return the first selected value
2334      * @see #getMinSelectionIndex
2335      * @see #getModel
2336      * @see #addListSelectionListener
2337      */
2338     @BeanProperty(bound = false)
2339     public E getSelectedValue() {
2340         int i = getMinSelectionIndex();
2341         return ((i == -1) || (i &gt;= getModel().getSize())) ? null :
2342                 getModel().getElementAt(i);
2343     }
2344 
2345 
2346     /**
2347      * Selects the specified object from the list.
2348      * If the object passed is {@code null}, the selection is cleared.
2349      *
2350      * @param anObject      the object to select
2351      * @param shouldScroll  {@code true} if the list should scroll to display
2352      *                      the selected object, if one exists; otherwise {@code false}
2353      */
2354     public void setSelectedValue(Object anObject,boolean shouldScroll) {
2355         if(anObject == null)
2356             clearSelection();
2357         else if(!anObject.equals(getSelectedValue())) {
2358             int i,c;
2359             ListModel&lt;E&gt; dm = getModel();
2360             for(i=0,c=dm.getSize();i&lt;c;i++)
2361                 if(anObject.equals(dm.getElementAt(i))){
2362                     setSelectedIndex(i);
2363                     if(shouldScroll)
2364                         ensureIndexIsVisible(i);
2365                     repaint();  /** FIX-ME setSelectedIndex does not redraw all the time with the basic l&amp;f**/
2366                     return;
2367                 }
2368             setSelectedIndex(-1);
2369         }
2370         repaint(); /** FIX-ME setSelectedIndex does not redraw all the time with the basic l&amp;f**/
2371     }
2372 
2373 
2374 
2375     /**
2376      * --- The Scrollable Implementation ---
2377      */
2378 
2379     private void checkScrollableParameters(Rectangle visibleRect, int orientation) {
2380         if (visibleRect == null) {
2381             throw new IllegalArgumentException(&quot;visibleRect must be non-null&quot;);
2382         }
2383         switch (orientation) {
2384         case SwingConstants.VERTICAL:
2385         case SwingConstants.HORIZONTAL:
2386             break;
2387         default:
2388             throw new IllegalArgumentException(&quot;orientation must be one of: VERTICAL, HORIZONTAL&quot;);
2389         }
2390     }
2391 
2392 
2393     /**
2394      * Computes the size of viewport needed to display {@code visibleRowCount}
2395      * rows. The value returned by this method depends on the layout
2396      * orientation:
2397      * &lt;p&gt;
2398      * &lt;b&gt;{@code VERTICAL}:&lt;/b&gt;
2399      * &lt;br&gt;
2400      * This is trivial if both {@code fixedCellWidth} and {@code fixedCellHeight}
2401      * have been set (either explicitly or by specifying a prototype cell value).
2402      * The width is simply the {@code fixedCellWidth} plus the list&#39;s horizontal
2403      * insets. The height is the {@code fixedCellHeight} multiplied by the
2404      * {@code visibleRowCount}, plus the list&#39;s vertical insets.
2405      * &lt;p&gt;
2406      * If either {@code fixedCellWidth} or {@code fixedCellHeight} haven&#39;t been
2407      * specified, heuristics are used. If the model is empty, the width is
2408      * the {@code fixedCellWidth}, if greater than {@code 0}, or a hard-coded
2409      * value of {@code 256}. The height is the {@code fixedCellHeight} multiplied
2410      * by {@code visibleRowCount}, if {@code fixedCellHeight} is greater than
2411      * {@code 0}, otherwise it is a hard-coded value of {@code 16} multiplied by
2412      * {@code visibleRowCount}.
2413      * &lt;p&gt;
2414      * If the model isn&#39;t empty, the width is the preferred size&#39;s width,
2415      * typically the width of the widest list element. The height is the
2416      * height of the cell with index 0 multiplied by the {@code visibleRowCount},
2417      * plus the list&#39;s vertical insets.
2418      * &lt;p&gt;
2419      * &lt;b&gt;{@code VERTICAL_WRAP} or {@code HORIZONTAL_WRAP}:&lt;/b&gt;
2420      * &lt;br&gt;
2421      * This method simply returns the value from {@code getPreferredSize}.
2422      * The list&#39;s {@code ListUI} is expected to override {@code getPreferredSize}
2423      * to return an appropriate value.
2424      *
2425      * @return a dimension containing the size of the viewport needed
2426      *          to display {@code visibleRowCount} rows
2427      * @see #getPreferredScrollableViewportSize
2428      * @see #setPrototypeCellValue
2429      */
2430     @BeanProperty(bound = false)
2431     public Dimension getPreferredScrollableViewportSize()
2432     {
2433         if (getLayoutOrientation() != VERTICAL) {
2434             return getPreferredSize();
2435         }
2436         Insets insets = getInsets();
2437         int dx = insets.left + insets.right;
2438         int dy = insets.top + insets.bottom;
2439 
2440         int visibleRowCount = getVisibleRowCount();
2441         int fixedCellWidth = getFixedCellWidth();
2442         int fixedCellHeight = getFixedCellHeight();
2443 
2444         if ((fixedCellWidth &gt; 0) &amp;&amp; (fixedCellHeight &gt; 0)) {
2445             int width = fixedCellWidth + dx;
2446             int height = (visibleRowCount * fixedCellHeight) + dy;
2447             return new Dimension(width, height);
2448         }
2449         else if (getModel().getSize() &gt; 0) {
2450             int width = getPreferredSize().width;
2451             int height;
2452             Rectangle r = getCellBounds(0, 0);
2453             if (r != null) {
2454                 height = (visibleRowCount * r.height) + dy;
2455             }
2456             else {
2457                 // Will only happen if UI null, shouldn&#39;t matter what we return
2458                 height = 1;
2459             }
2460             return new Dimension(width, height);
2461         }
2462         else {
2463             fixedCellWidth = (fixedCellWidth &gt; 0) ? fixedCellWidth : 256;
2464             fixedCellHeight = (fixedCellHeight &gt; 0) ? fixedCellHeight : 16;
2465             return new Dimension(fixedCellWidth, fixedCellHeight * visibleRowCount);
2466         }
2467     }
2468 
2469 
2470     /**
2471      * Returns the distance to scroll to expose the next or previous
2472      * row (for vertical scrolling) or column (for horizontal scrolling).
2473      * &lt;p&gt;
2474      * For horizontal scrolling, if the layout orientation is {@code VERTICAL},
2475      * then the list&#39;s font size is returned (or {@code 1} if the font is
2476      * {@code null}).
2477      *
2478      * @param visibleRect the view area visible within the viewport
2479      * @param orientation {@code SwingConstants.HORIZONTAL} or
2480      *                    {@code SwingConstants.VERTICAL}
2481      * @param direction less or equal to zero to scroll up/back,
2482      *                  greater than zero for down/forward
2483      * @return the &quot;unit&quot; increment for scrolling in the specified direction;
2484      *         always positive
2485      * @see #getScrollableBlockIncrement
2486      * @see Scrollable#getScrollableUnitIncrement
2487      * @throws IllegalArgumentException if {@code visibleRect} is {@code null}, or
2488      *         {@code orientation} isn&#39;t one of {@code SwingConstants.VERTICAL} or
2489      *         {@code SwingConstants.HORIZONTAL}
2490      */
2491     public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
2492     {
2493         checkScrollableParameters(visibleRect, orientation);
2494 
2495         if (orientation == SwingConstants.VERTICAL) {
2496             int row = locationToIndex(visibleRect.getLocation());
2497 
2498             if (row == -1) {
2499                 return 0;
2500             }
2501             else {
2502                 /* Scroll Down */
2503                 if (direction &gt; 0) {
2504                     Rectangle r = getCellBounds(row, row);
2505                     return (r == null) ? 0 : r.height - (visibleRect.y - r.y);
2506                 }
2507                 /* Scroll Up */
2508                 else {
2509                     Rectangle r = getCellBounds(row, row);
2510 
2511                     /* The first row is completely visible and it&#39;s row 0.
2512                      * We&#39;re done.
2513                      */
2514                     if ((r.y == visibleRect.y) &amp;&amp; (row == 0))  {
2515                         return 0;
2516                     }
2517                     /* The first row is completely visible, return the
2518                      * height of the previous row or 0 if the first row
2519                      * is the top row of the list.
2520                      */
2521                     else if (r.y == visibleRect.y) {
2522                         Point loc = r.getLocation();
2523                         loc.y--;
2524                         int prevIndex = locationToIndex(loc);
2525                         Rectangle prevR = getCellBounds(prevIndex, prevIndex);
2526 
2527                         if (prevR == null || prevR.y &gt;= r.y) {
2528                             return 0;
2529                         }
2530                         return prevR.height;
2531                     }
2532                     /* The first row is partially visible, return the
2533                      * height of hidden part.
2534                      */
2535                     else {
2536                         return visibleRect.y - r.y;
2537                     }
2538                 }
2539             }
2540         } else if (orientation == SwingConstants.HORIZONTAL &amp;&amp;
2541                            getLayoutOrientation() != JList.VERTICAL) {
2542             boolean leftToRight = getComponentOrientation().isLeftToRight();
2543             int index;
2544             Point leadingPoint;
2545 
2546             if (leftToRight) {
2547                 leadingPoint = visibleRect.getLocation();
2548             }
2549             else {
2550                 leadingPoint = new Point(visibleRect.x + visibleRect.width -1,
2551                                          visibleRect.y);
2552             }
2553             index = locationToIndex(leadingPoint);
2554 
2555             if (index != -1) {
2556                 Rectangle cellBounds = getCellBounds(index, index);
2557                 if (cellBounds != null &amp;&amp; cellBounds.contains(leadingPoint)) {
2558                     int leadingVisibleEdge;
2559                     int leadingCellEdge;
2560 
2561                     if (leftToRight) {
2562                         leadingVisibleEdge = visibleRect.x;
2563                         leadingCellEdge = cellBounds.x;
2564                     }
2565                     else {
2566                         leadingVisibleEdge = visibleRect.x + visibleRect.width;
2567                         leadingCellEdge = cellBounds.x + cellBounds.width;
2568                     }
2569 
2570                     if (leadingCellEdge != leadingVisibleEdge) {
2571                         if (direction &lt; 0) {
2572                             // Show remainder of leading cell
2573                             return Math.abs(leadingVisibleEdge - leadingCellEdge);
2574 
2575                         }
2576                         else if (leftToRight) {
2577                             // Hide rest of leading cell
2578                             return leadingCellEdge + cellBounds.width - leadingVisibleEdge;
2579                         }
2580                         else {
2581                             // Hide rest of leading cell
2582                             return leadingVisibleEdge - cellBounds.x;
2583                         }
2584                     }
2585                     // ASSUME: All cells are the same width
2586                     return cellBounds.width;
2587                 }
2588             }
2589         }
2590         Font f = getFont();
2591         return (f != null) ? f.getSize() : 1;
2592     }
2593 
2594 
2595     /**
2596      * Returns the distance to scroll to expose the next or previous block.
2597      * &lt;p&gt;
2598      * For vertical scrolling, the following rules are used:
2599      * &lt;ul&gt;
2600      * &lt;li&gt;if scrolling down, returns the distance to scroll so that the last
2601      * visible element becomes the first completely visible element
2602      * &lt;li&gt;if scrolling up, returns the distance to scroll so that the first
2603      * visible element becomes the last completely visible element
2604      * &lt;li&gt;returns {@code visibleRect.height} if the list is empty
2605      * &lt;/ul&gt;
2606      * &lt;p&gt;
2607      * For horizontal scrolling, when the layout orientation is either
2608      * {@code VERTICAL_WRAP} or {@code HORIZONTAL_WRAP}:
2609      * &lt;ul&gt;
2610      * &lt;li&gt;if scrolling right, returns the distance to scroll so that the
2611      * last visible element becomes
2612      * the first completely visible element
2613      * &lt;li&gt;if scrolling left, returns the distance to scroll so that the first
2614      * visible element becomes the last completely visible element
2615      * &lt;li&gt;returns {@code visibleRect.width} if the list is empty
2616      * &lt;/ul&gt;
2617      * &lt;p&gt;
2618      * For horizontal scrolling and {@code VERTICAL} orientation,
2619      * returns {@code visibleRect.width}.
2620      * &lt;p&gt;
2621      * Note that the value of {@code visibleRect} must be the equal to
2622      * {@code this.getVisibleRect()}.
2623      *
2624      * @param visibleRect the view area visible within the viewport
2625      * @param orientation {@code SwingConstants.HORIZONTAL} or
2626      *                    {@code SwingConstants.VERTICAL}
2627      * @param direction less or equal to zero to scroll up/back,
2628      *                  greater than zero for down/forward
2629      * @return the &quot;block&quot; increment for scrolling in the specified direction;
2630      *         always positive
2631      * @see #getScrollableUnitIncrement
2632      * @see Scrollable#getScrollableBlockIncrement
2633      * @throws IllegalArgumentException if {@code visibleRect} is {@code null}, or
2634      *         {@code orientation} isn&#39;t one of {@code SwingConstants.VERTICAL} or
2635      *         {@code SwingConstants.HORIZONTAL}
2636      */
2637     public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
2638         checkScrollableParameters(visibleRect, orientation);
2639         if (orientation == SwingConstants.VERTICAL) {
2640             int inc = visibleRect.height;
2641             /* Scroll Down */
2642             if (direction &gt; 0) {
2643                 // last cell is the lowest left cell
2644                 int last = locationToIndex(new Point(visibleRect.x, visibleRect.y+visibleRect.height-1));
2645                 if (last != -1) {
2646                     Rectangle lastRect = getCellBounds(last,last);
2647                     if (lastRect != null) {
2648                         inc = lastRect.y - visibleRect.y;
2649                         if ( (inc == 0) &amp;&amp; (last &lt; getModel().getSize()-1) ) {
2650                             inc = lastRect.height;
2651                         }
2652                     }
2653                 }
2654             }
2655             /* Scroll Up */
2656             else {
2657                 int newFirst = locationToIndex(new Point(visibleRect.x, visibleRect.y-visibleRect.height));
2658                 int first = getFirstVisibleIndex();
2659                 if (newFirst != -1) {
2660                     if (first == -1) {
2661                         first = locationToIndex(visibleRect.getLocation());
2662                     }
2663                     Rectangle newFirstRect = getCellBounds(newFirst,newFirst);
2664                     Rectangle firstRect = getCellBounds(first,first);
2665                     if ((newFirstRect != null) &amp;&amp; (firstRect!=null)) {
2666                         while ( (newFirstRect.y + visibleRect.height &lt;
2667                                  firstRect.y + firstRect.height) &amp;&amp;
2668                                 (newFirstRect.y &lt; firstRect.y) ) {
2669                             newFirst++;
2670                             newFirstRect = getCellBounds(newFirst,newFirst);
2671                         }
2672                         inc = visibleRect.y - newFirstRect.y;
2673                         if ( (inc &lt;= 0) &amp;&amp; (newFirstRect.y &gt; 0)) {
2674                             newFirst--;
2675                             newFirstRect = getCellBounds(newFirst,newFirst);
2676                             if (newFirstRect != null) {
2677                                 inc = visibleRect.y - newFirstRect.y;
2678                             }
2679                         }
2680                     }
2681                 }
2682             }
2683             return inc;
2684         }
2685         else if (orientation == SwingConstants.HORIZONTAL &amp;&amp;
2686                  getLayoutOrientation() != JList.VERTICAL) {
2687             boolean leftToRight = getComponentOrientation().isLeftToRight();
2688             int inc = visibleRect.width;
2689             /* Scroll Right (in ltr mode) or Scroll Left (in rtl mode) */
2690             if (direction &gt; 0) {
2691                 // position is upper right if ltr, or upper left otherwise
2692                 int x = visibleRect.x + (leftToRight ? (visibleRect.width - 1) : 0);
2693                 int last = locationToIndex(new Point(x, visibleRect.y));
2694 
2695                 if (last != -1) {
2696                     Rectangle lastRect = getCellBounds(last,last);
2697                     if (lastRect != null) {
2698                         if (leftToRight) {
2699                             inc = lastRect.x - visibleRect.x;
2700                         } else {
2701                             inc = visibleRect.x + visibleRect.width
2702                                       - (lastRect.x + lastRect.width);
2703                         }
2704                         if (inc &lt; 0) {
2705                             inc += lastRect.width;
2706                         } else if ( (inc == 0) &amp;&amp; (last &lt; getModel().getSize()-1) ) {
2707                             inc = lastRect.width;
2708                         }
2709                     }
2710                 }
2711             }
2712             /* Scroll Left (in ltr mode) or Scroll Right (in rtl mode) */
2713             else {
2714                 // position is upper left corner of the visibleRect shifted
2715                 // left by the visibleRect.width if ltr, or upper right shifted
2716                 // right by the visibleRect.width otherwise
2717                 int x = visibleRect.x + (leftToRight
2718                                          ? -visibleRect.width
2719                                          : visibleRect.width - 1 + visibleRect.width);
2720                 int first = locationToIndex(new Point(x, visibleRect.y));
2721 
2722                 if (first != -1) {
2723                     Rectangle firstRect = getCellBounds(first,first);
2724                     if (firstRect != null) {
2725                         // the right of the first cell
2726                         int firstRight = firstRect.x + firstRect.width;
2727 
2728                         if (leftToRight) {
2729                             if ((firstRect.x &lt; visibleRect.x - visibleRect.width)
2730                                     &amp;&amp; (firstRight &lt; visibleRect.x)) {
2731                                 inc = visibleRect.x - firstRight;
2732                             } else {
2733                                 inc = visibleRect.x - firstRect.x;
2734                             }
2735                         } else {
2736                             int visibleRight = visibleRect.x + visibleRect.width;
2737 
2738                             if ((firstRight &gt; visibleRight + visibleRect.width)
2739                                     &amp;&amp; (firstRect.x &gt; visibleRight)) {
2740                                 inc = firstRect.x - visibleRight;
2741                             } else {
2742                                 inc = firstRight - visibleRight;
2743                             }
2744                         }
2745                     }
2746                 }
2747             }
2748             return inc;
2749         }
2750         return visibleRect.width;
2751     }
2752 
2753 
2754     /**
2755      * Returns {@code true} if this {@code JList} is displayed in a
2756      * {@code JViewport} and the viewport is wider than the list&#39;s
2757      * preferred width, or if the layout orientation is {@code HORIZONTAL_WRAP}
2758      * and {@code visibleRowCount &lt;= 0}; otherwise returns {@code false}.
2759      * &lt;p&gt;
2760      * If {@code false}, then don&#39;t track the viewport&#39;s width. This allows
2761      * horizontal scrolling if the {@code JViewport} is itself embedded in a
2762      * {@code JScrollPane}.
2763      *
2764      * @return whether or not an enclosing viewport should force the list&#39;s
2765      *         width to match its own
2766      * @see Scrollable#getScrollableTracksViewportWidth
2767      */
2768     @BeanProperty(bound = false)
2769     public boolean getScrollableTracksViewportWidth() {
2770         if (getLayoutOrientation() == HORIZONTAL_WRAP &amp;&amp;
2771                                       getVisibleRowCount() &lt;= 0) {
2772             return true;
2773         }
2774         Container parent = SwingUtilities.getUnwrappedParent(this);
2775         if (parent instanceof JViewport) {
2776             return parent.getWidth() &gt; getPreferredSize().width;
2777         }
2778         return false;
2779     }
2780 
2781     /**
2782      * Returns {@code true} if this {@code JList} is displayed in a
2783      * {@code JViewport} and the viewport is taller than the list&#39;s
2784      * preferred height, or if the layout orientation is {@code VERTICAL_WRAP}
2785      * and {@code visibleRowCount &lt;= 0}; otherwise returns {@code false}.
2786      * &lt;p&gt;
2787      * If {@code false}, then don&#39;t track the viewport&#39;s height. This allows
2788      * vertical scrolling if the {@code JViewport} is itself embedded in a
2789      * {@code JScrollPane}.
2790      *
2791      * @return whether or not an enclosing viewport should force the list&#39;s
2792      *         height to match its own
2793      * @see Scrollable#getScrollableTracksViewportHeight
2794      */
2795     @BeanProperty(bound = false)
2796     public boolean getScrollableTracksViewportHeight() {
2797         if (getLayoutOrientation() == VERTICAL_WRAP &amp;&amp;
2798                      getVisibleRowCount() &lt;= 0) {
2799             return true;
2800         }
2801         Container parent = SwingUtilities.getUnwrappedParent(this);
2802         if (parent instanceof JViewport) {
2803             return parent.getHeight() &gt; getPreferredSize().height;
2804         }
2805         return false;
2806     }
2807 
2808 
2809     /*
2810      * See {@code readObject} and {@code writeObject} in {@code JComponent}
2811      * for more information about serialization in Swing.
2812      */
2813     private void writeObject(ObjectOutputStream s) throws IOException {
2814         s.defaultWriteObject();
2815         if (getUIClassID().equals(uiClassID)) {
2816             byte count = JComponent.getWriteObjCounter(this);
2817             JComponent.setWriteObjCounter(this, --count);
2818             if (count == 0 &amp;&amp; ui != null) {
2819                 ui.installUI(this);
2820             }
2821         }
2822     }
2823 
2824 
2825     /**
2826      * Returns a {@code String} representation of this {@code JList}.
2827      * This method is intended to be used only for debugging purposes,
2828      * and the content and format of the returned {@code String} may vary
2829      * between implementations. The returned {@code String} may be empty,
2830      * but may not be {@code null}.
2831      *
2832      * @return  a {@code String} representation of this {@code JList}.
2833      */
2834     protected String paramString() {
2835         String selectionForegroundString = (selectionForeground != null ?
2836                                             selectionForeground.toString() :
2837                                             &quot;&quot;);
2838         String selectionBackgroundString = (selectionBackground != null ?
2839                                             selectionBackground.toString() :
2840                                             &quot;&quot;);
2841 
2842         return super.paramString() +
2843         &quot;,fixedCellHeight=&quot; + fixedCellHeight +
2844         &quot;,fixedCellWidth=&quot; + fixedCellWidth +
2845         &quot;,horizontalScrollIncrement=&quot; + horizontalScrollIncrement +
2846         &quot;,selectionBackground=&quot; + selectionBackgroundString +
2847         &quot;,selectionForeground=&quot; + selectionForegroundString +
2848         &quot;,visibleRowCount=&quot; + visibleRowCount +
2849         &quot;,layoutOrientation=&quot; + layoutOrientation;
2850     }
2851 
2852 
2853     /**
2854      * --- Accessibility Support ---
2855      */
2856 
2857     /**
2858      * Gets the {@code AccessibleContext} associated with this {@code JList}.
2859      * For {@code JList}, the {@code AccessibleContext} takes the form of an
2860      * {@code AccessibleJList}.
2861      * &lt;p&gt;
2862      * A new {@code AccessibleJList} instance is created if necessary.
2863      *
2864      * @return an {@code AccessibleJList} that serves as the
2865      *         {@code AccessibleContext} of this {@code JList}
2866      */
2867     @BeanProperty(bound = false)
2868     public AccessibleContext getAccessibleContext() {
2869         if (accessibleContext == null) {
2870             accessibleContext = new AccessibleJList();
2871         }
2872         return accessibleContext;
2873     }
2874 
2875     /**
2876      * This class implements accessibility support for the
2877      * {@code JList} class. It provides an implementation of the
2878      * Java Accessibility API appropriate to list user-interface
2879      * elements.
2880      * &lt;p&gt;
2881      * &lt;strong&gt;Warning:&lt;/strong&gt;
2882      * Serialized objects of this class will not be compatible with
2883      * future Swing releases. The current serialization support is
2884      * appropriate for short term storage or RMI between applications running
2885      * the same version of Swing.  As of 1.4, support for long term storage
2886      * of all JavaBeans&amp;trade;
2887      * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
2888      * Please see {@link java.beans.XMLEncoder}.
2889      */
2890     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2891     protected class AccessibleJList extends AccessibleJComponent
2892         implements AccessibleSelection, PropertyChangeListener,
2893         ListSelectionListener, ListDataListener {
2894 
2895         int leadSelectionIndex;
2896 
2897         /**
2898          * Constructs an {@code AccessibleJList}.
2899          */
2900         public AccessibleJList() {
2901             super();
2902             JList.this.addPropertyChangeListener(this);
2903             JList.this.getSelectionModel().addListSelectionListener(this);
2904             JList.this.getModel().addListDataListener(this);
2905             leadSelectionIndex = JList.this.getLeadSelectionIndex();
2906         }
2907 
2908         /**
2909          * Property Change Listener change method. Used to track changes
2910          * to the DataModel and ListSelectionModel, in order to re-set
2911          * listeners to those for reporting changes there via the Accessibility
2912          * PropertyChange mechanism.
2913          *
2914          * @param e PropertyChangeEvent
2915          */
2916         public void propertyChange(PropertyChangeEvent e) {
2917             String name = e.getPropertyName();
2918             Object oldValue = e.getOldValue();
2919             Object newValue = e.getNewValue();
2920 
2921                 // re-set listData listeners
2922             if (name.compareTo(&quot;model&quot;) == 0) {
2923 
2924                 if (oldValue != null &amp;&amp; oldValue instanceof ListModel) {
2925                     ((ListModel) oldValue).removeListDataListener(this);
2926                 }
2927                 if (newValue != null &amp;&amp; newValue instanceof ListModel) {
2928                     ((ListModel) newValue).addListDataListener(this);
2929                 }
2930 
2931                 // re-set listSelectionModel listeners
2932             } else if (name.compareTo(&quot;selectionModel&quot;) == 0) {
2933 
2934                 if (oldValue != null &amp;&amp; oldValue instanceof ListSelectionModel) {
2935                     ((ListSelectionModel) oldValue).removeListSelectionListener(this);
2936                 }
2937                 if (newValue != null &amp;&amp; newValue instanceof ListSelectionModel) {
2938                     ((ListSelectionModel) newValue).addListSelectionListener(this);
2939                 }
2940 
2941                 firePropertyChange(
2942                     AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
2943                     Boolean.valueOf(false), Boolean.valueOf(true));
2944             }
2945         }
2946 
2947         /**
2948          * List Selection Listener value change method. Used to fire
2949          * the property change
2950          *
2951          * @param e ListSelectionEvent
2952          *
2953          */
2954         public void valueChanged(ListSelectionEvent e) {
2955             int oldLeadSelectionIndex = leadSelectionIndex;
2956             leadSelectionIndex = JList.this.getLeadSelectionIndex();
2957             if (oldLeadSelectionIndex != leadSelectionIndex) {
2958                 Accessible oldLS, newLS;
2959                 oldLS = (oldLeadSelectionIndex &gt;= 0)
2960                         ? getAccessibleChild(oldLeadSelectionIndex)
2961                         : null;
2962                 newLS = (leadSelectionIndex &gt;= 0)
2963                         ? getAccessibleChild(leadSelectionIndex)
2964                         : null;
2965                 firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,
2966                                    oldLS, newLS);
2967             }
2968 
2969             firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
2970                                Boolean.valueOf(false), Boolean.valueOf(true));
2971             firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
2972                                Boolean.valueOf(false), Boolean.valueOf(true));
2973 
2974             // Process the State changes for Multiselectable
2975             AccessibleStateSet s = getAccessibleStateSet();
2976             ListSelectionModel lsm = JList.this.getSelectionModel();
2977             if (lsm.getSelectionMode() != ListSelectionModel.SINGLE_SELECTION) {
2978                 if (!s.contains(AccessibleState.MULTISELECTABLE)) {
2979                     s.add(AccessibleState.MULTISELECTABLE);
2980                     firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
2981                                        null, AccessibleState.MULTISELECTABLE);
2982                 }
2983             } else {
2984                 if (s.contains(AccessibleState.MULTISELECTABLE)) {
2985                     s.remove(AccessibleState.MULTISELECTABLE);
2986                     firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
2987                                        AccessibleState.MULTISELECTABLE, null);
2988                 }
2989             }
2990         }
2991 
2992         /**
2993          * List Data Listener interval added method. Used to fire the visible data property change
2994          *
2995          * @param e ListDataEvent
2996          *
2997          */
2998         public void intervalAdded(ListDataEvent e) {
2999             firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
3000                                Boolean.valueOf(false), Boolean.valueOf(true));
3001         }
3002 
3003         /**
3004          * List Data Listener interval removed method. Used to fire the visible data property change
3005          *
3006          * @param e ListDataEvent
3007          *
3008          */
3009         public void intervalRemoved(ListDataEvent e) {
3010             firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
3011                                Boolean.valueOf(false), Boolean.valueOf(true));
3012         }
3013 
3014         /**
3015          * List Data Listener contents changed method. Used to fire the visible data property change
3016          *
3017          * @param e ListDataEvent
3018          *
3019          */
3020          public void contentsChanged(ListDataEvent e) {
3021              firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
3022                                 Boolean.valueOf(false), Boolean.valueOf(true));
3023          }
3024 
3025     // AccessibleContext methods
3026 
3027         /**
3028          * Get the state set of this object.
3029          *
3030          * @return an instance of AccessibleState containing the current state
3031          * of the object
3032          * @see AccessibleState
3033          */
3034         public AccessibleStateSet getAccessibleStateSet() {
3035             AccessibleStateSet states = super.getAccessibleStateSet();
3036             if (selectionModel.getSelectionMode() !=
3037                 ListSelectionModel.SINGLE_SELECTION) {
3038                 states.add(AccessibleState.MULTISELECTABLE);
3039             }
3040             return states;
3041         }
3042 
3043         /**
3044          * Get the role of this object.
3045          *
3046          * @return an instance of AccessibleRole describing the role of the
3047          * object
3048          * @see AccessibleRole
3049          */
3050         public AccessibleRole getAccessibleRole() {
3051             return AccessibleRole.LIST;
3052         }
3053 
3054         /**
3055          * Returns the &lt;code&gt;Accessible&lt;/code&gt; child contained at
3056          * the local coordinate &lt;code&gt;Point&lt;/code&gt;, if one exists.
3057          * Otherwise returns &lt;code&gt;null&lt;/code&gt;.
3058          *
3059          * @return the &lt;code&gt;Accessible&lt;/code&gt; at the specified
3060          *    location, if it exists
3061          */
3062         public Accessible getAccessibleAt(Point p) {
3063             int i = locationToIndex(p);
3064             if (i &gt;= 0) {
3065                 return new AccessibleJListChild(JList.this, i);
3066             } else {
3067                 return null;
3068             }
3069         }
3070 
3071         /**
3072          * Returns the number of accessible children in the object.  If all
3073          * of the children of this object implement Accessible, than this
3074          * method should return the number of children of this object.
3075          *
3076          * @return the number of accessible children in the object.
3077          */
3078         public int getAccessibleChildrenCount() {
3079             return getModel().getSize();
3080         }
3081 
3082         /**
3083          * Return the nth Accessible child of the object.
3084          *
3085          * @param i zero-based index of child
3086          * @return the nth Accessible child of the object
3087          */
3088         public Accessible getAccessibleChild(int i) {
3089             if (i &gt;= getModel().getSize()) {
3090                 return null;
3091             } else {
3092                 return new AccessibleJListChild(JList.this, i);
3093             }
3094         }
3095 
3096         /**
3097          * Get the AccessibleSelection associated with this object.  In the
3098          * implementation of the Java Accessibility API for this class,
3099          * return this object, which is responsible for implementing the
3100          * AccessibleSelection interface on behalf of itself.
3101          *
3102          * @return this object
3103          */
3104         public AccessibleSelection getAccessibleSelection() {
3105             return this;
3106         }
3107 
3108 
3109     // AccessibleSelection methods
3110 
3111         /**
3112          * Returns the number of items currently selected.
3113          * If no items are selected, the return value will be 0.
3114          *
3115          * @return the number of items currently selected.
3116          */
3117          public int getAccessibleSelectionCount() {
3118              return JList.this.getSelectedIndices().length;
3119          }
3120 
3121         /**
3122          * Returns an Accessible representing the specified selected item
3123          * in the object.  If there isn&#39;t a selection, or there are
3124          * fewer items selected than the integer passed in, the return
3125          * value will be &lt;code&gt;null&lt;/code&gt;.
3126          *
3127          * @param i the zero-based index of selected items
3128          * @return an Accessible containing the selected item
3129          */
3130          public Accessible getAccessibleSelection(int i) {
3131              int len = getAccessibleSelectionCount();
3132              if (i &lt; 0 || i &gt;= len) {
3133                  return null;
3134              } else {
3135                  return getAccessibleChild(JList.this.getSelectedIndices()[i]);
3136              }
3137          }
3138 
3139         /**
3140          * Returns true if the current child of this object is selected.
3141          *
3142          * @param i the zero-based index of the child in this Accessible
3143          * object.
3144          * @see AccessibleContext#getAccessibleChild
3145          */
3146         public boolean isAccessibleChildSelected(int i) {
3147             return isSelectedIndex(i);
3148         }
3149 
3150         /**
3151          * Adds the specified selected item in the object to the object&#39;s
3152          * selection.  If the object supports multiple selections,
3153          * the specified item is added to any existing selection, otherwise
3154          * it replaces any existing selection in the object.  If the
3155          * specified item is already selected, this method has no effect.
3156          *
3157          * @param i the zero-based index of selectable items
3158          */
3159          public void addAccessibleSelection(int i) {
3160              JList.this.addSelectionInterval(i, i);
3161          }
3162 
3163         /**
3164          * Removes the specified selected item in the object from the object&#39;s
3165          * selection.  If the specified item isn&#39;t currently selected, this
3166          * method has no effect.
3167          *
3168          * @param i the zero-based index of selectable items
3169          */
3170          public void removeAccessibleSelection(int i) {
3171              JList.this.removeSelectionInterval(i, i);
3172          }
3173 
3174         /**
3175          * Clears the selection in the object, so that nothing in the
3176          * object is selected.
3177          */
3178          public void clearAccessibleSelection() {
3179              JList.this.clearSelection();
3180          }
3181 
3182         /**
3183          * Causes every selected item in the object to be selected
3184          * if the object supports multiple selections.
3185          */
3186          public void selectAllAccessibleSelection() {
3187              JList.this.addSelectionInterval(0, getAccessibleChildrenCount() -1);
3188          }
3189 
3190           /**
3191            * This class implements accessibility support appropriate
3192            * for list children.
3193            */
3194         protected class AccessibleJListChild extends AccessibleContext
3195                 implements Accessible, AccessibleComponent, AccessibleAction {
3196             private JList&lt;E&gt;     parent = null;
3197             int indexInParent;
3198             private Component component = null;
3199             private AccessibleContext accessibleContext = null;
3200             private ListModel&lt;E&gt; listModel;
3201             private ListCellRenderer&lt;? super E&gt; cellRenderer = null;
3202 
3203             /**
3204              * Constructs an {@code AccessibleJListChild}.
3205              * @param parent the parent
3206              * @param indexInParent the index in the parent
3207              */
3208             public AccessibleJListChild(JList&lt;E&gt; parent, int indexInParent) {
3209                 this.parent = parent;
3210                 this.setAccessibleParent(parent);
3211                 this.indexInParent = indexInParent;
3212                 if (parent != null) {
3213                     listModel = parent.getModel();
3214                     cellRenderer = parent.getCellRenderer();
3215                 }
3216             }
3217 
3218             private Component getCurrentComponent() {
3219                 return getComponentAtIndex(indexInParent);
3220             }
3221 
3222             AccessibleContext getCurrentAccessibleContext() {
3223                 Component c = getComponentAtIndex(indexInParent);
3224                 if (c instanceof Accessible) {
3225                     return c.getAccessibleContext();
3226                 } else {
3227                     return null;
3228                 }
3229             }
3230 
3231             private Component getComponentAtIndex(int index) {
3232                 if (index &lt; 0 || index &gt;= listModel.getSize()) {
3233                     return null;
3234                 }
3235                 if ((parent != null)
3236                         &amp;&amp; (listModel != null)
3237                         &amp;&amp; cellRenderer != null) {
3238                     E value = listModel.getElementAt(index);
3239                     boolean isSelected = parent.isSelectedIndex(index);
3240                     boolean isFocussed = parent.isFocusOwner()
3241                             &amp;&amp; (index == parent.getLeadSelectionIndex());
3242                     return cellRenderer.getListCellRendererComponent(
3243                             parent,
3244                             value,
3245                             index,
3246                             isSelected,
3247                             isFocussed);
3248                 } else {
3249                     return null;
3250                 }
3251             }
3252 
3253 
3254             // Accessible Methods
3255            /**
3256             * Get the AccessibleContext for this object. In the
3257             * implementation of the Java Accessibility API for this class,
3258             * returns this object, which is its own AccessibleContext.
3259             *
3260             * @return this object
3261             */
3262             public AccessibleContext getAccessibleContext() {
3263                 return this;
3264             }
3265 
3266 
3267             // AccessibleContext methods
3268 
3269             public String getAccessibleName() {
3270                 AccessibleContext ac = getCurrentAccessibleContext();
3271                 if (ac != null) {
3272                     return ac.getAccessibleName();
3273                 } else {
3274                     return null;
3275                 }
3276             }
3277 
3278             public void setAccessibleName(String s) {
3279                 AccessibleContext ac = getCurrentAccessibleContext();
3280                 if (ac != null) {
3281                     ac.setAccessibleName(s);
3282                 }
3283             }
3284 
3285             public String getAccessibleDescription() {
3286                 AccessibleContext ac = getCurrentAccessibleContext();
3287                 if (ac != null) {
3288                     return ac.getAccessibleDescription();
3289                 } else {
3290                     return null;
3291                 }
3292             }
3293 
3294             public void setAccessibleDescription(String s) {
3295                 AccessibleContext ac = getCurrentAccessibleContext();
3296                 if (ac != null) {
3297                     ac.setAccessibleDescription(s);
3298                 }
3299             }
3300 
3301             public AccessibleRole getAccessibleRole() {
3302                 AccessibleContext ac = getCurrentAccessibleContext();
3303                 if (ac != null) {
3304                     return ac.getAccessibleRole();
3305                 } else {
3306                     return null;
3307                 }
3308             }
3309 
3310             public AccessibleStateSet getAccessibleStateSet() {
3311                 AccessibleContext ac = getCurrentAccessibleContext();
3312                 AccessibleStateSet s;
3313                 if (ac != null) {
3314                     s = ac.getAccessibleStateSet();
3315                 } else {
3316                     s = new AccessibleStateSet();
3317                 }
3318 
3319                 s.add(AccessibleState.SELECTABLE);
<a name="2" id="anc2"></a>
3320                 if (parent.isFocusOwner()
3321                     &amp;&amp; (indexInParent == parent.getLeadSelectionIndex())) {
3322                     s.add(AccessibleState.ACTIVE);
3323                 }
3324                 if (parent.isSelectedIndex(indexInParent)) {
3325                     s.add(AccessibleState.SELECTED);
3326                 }
3327                 if (this.isShowing()) {
3328                     s.add(AccessibleState.SHOWING);
3329                 } else if (s.contains(AccessibleState.SHOWING)) {
3330                     s.remove(AccessibleState.SHOWING);
3331                 }
<a name="3" id="anc3"></a><span class="line-removed">3332                 if (this.isVisible()) {</span>
<span class="line-removed">3333                     s.add(AccessibleState.VISIBLE);</span>
<span class="line-removed">3334                 } else if (s.contains(AccessibleState.VISIBLE)) {</span>
<span class="line-removed">3335                     s.remove(AccessibleState.VISIBLE);</span>
<span class="line-removed">3336                 }</span>
3337                 s.add(AccessibleState.TRANSIENT); // cell-rendered
3338                 return s;
3339             }
3340 
3341             public int getAccessibleIndexInParent() {
3342                 return indexInParent;
3343             }
3344 
3345             public int getAccessibleChildrenCount() {
3346                 AccessibleContext ac = getCurrentAccessibleContext();
3347                 if (ac != null) {
3348                     return ac.getAccessibleChildrenCount();
3349                 } else {
3350                     return 0;
3351                 }
3352             }
3353 
3354             public Accessible getAccessibleChild(int i) {
3355                 AccessibleContext ac = getCurrentAccessibleContext();
3356                 if (ac != null) {
3357                     Accessible accessibleChild = ac.getAccessibleChild(i);
3358                     ac.setAccessibleParent(this);
3359                     return accessibleChild;
3360                 } else {
3361                     return null;
3362                 }
3363             }
3364 
3365             public Locale getLocale() {
3366                 AccessibleContext ac = getCurrentAccessibleContext();
3367                 if (ac != null) {
3368                     return ac.getLocale();
3369                 } else {
3370                     return null;
3371                 }
3372             }
3373 
3374             public void addPropertyChangeListener(PropertyChangeListener l) {
3375                 AccessibleContext ac = getCurrentAccessibleContext();
3376                 if (ac != null) {
3377                     ac.addPropertyChangeListener(l);
3378                 }
3379             }
3380 
3381             public void removePropertyChangeListener(PropertyChangeListener l) {
3382                 AccessibleContext ac = getCurrentAccessibleContext();
3383                 if (ac != null) {
3384                     ac.removePropertyChangeListener(l);
3385                 }
3386             }
3387 
3388            /**
3389             * Get the AccessibleComponent associated with this object.  In the
3390             * implementation of the Java Accessibility API for this class,
3391             * return this object, which is responsible for implementing the
3392             * AccessibleComponent interface on behalf of itself.
3393             *
3394             * @return this object
3395             */
3396             public AccessibleComponent getAccessibleComponent() {
3397                 return this; // to override getBounds()
3398             }
3399 
3400             public AccessibleSelection getAccessibleSelection() {
3401                 AccessibleContext ac = getCurrentAccessibleContext();
3402                 return ac != null ? ac.getAccessibleSelection() : null;
3403             }
3404 
3405             public AccessibleText getAccessibleText() {
3406                 AccessibleContext ac = getCurrentAccessibleContext();
3407                 return ac != null ? ac.getAccessibleText() : null;
3408             }
3409 
3410             public AccessibleValue getAccessibleValue() {
3411                 AccessibleContext ac = getCurrentAccessibleContext();
3412                 return ac != null ? ac.getAccessibleValue() : null;
3413             }
3414 
3415 
3416             // AccessibleComponent methods
3417 
3418             public Color getBackground() {
3419                 AccessibleContext ac = getCurrentAccessibleContext();
3420                 if (ac instanceof AccessibleComponent) {
3421                     return ((AccessibleComponent) ac).getBackground();
3422                 } else {
3423                     Component c = getCurrentComponent();
3424                     if (c != null) {
3425                         return c.getBackground();
3426                     } else {
3427                         return null;
3428                     }
3429                 }
3430             }
3431 
3432             public void setBackground(Color c) {
3433                 AccessibleContext ac = getCurrentAccessibleContext();
3434                 if (ac instanceof AccessibleComponent) {
3435                     ((AccessibleComponent) ac).setBackground(c);
3436                 } else {
3437                     Component cp = getCurrentComponent();
3438                     if (cp != null) {
3439                         cp.setBackground(c);
3440                     }
3441                 }
3442             }
3443 
3444             public Color getForeground() {
3445                 AccessibleContext ac = getCurrentAccessibleContext();
3446                 if (ac instanceof AccessibleComponent) {
3447                     return ((AccessibleComponent) ac).getForeground();
3448                 } else {
3449                     Component c = getCurrentComponent();
3450                     if (c != null) {
3451                         return c.getForeground();
3452                     } else {
3453                         return null;
3454                     }
3455                 }
3456             }
3457 
3458             public void setForeground(Color c) {
3459                 AccessibleContext ac = getCurrentAccessibleContext();
3460                 if (ac instanceof AccessibleComponent) {
3461                     ((AccessibleComponent) ac).setForeground(c);
3462                 } else {
3463                     Component cp = getCurrentComponent();
3464                     if (cp != null) {
3465                         cp.setForeground(c);
3466                     }
3467                 }
3468             }
3469 
3470             public Cursor getCursor() {
3471                 AccessibleContext ac = getCurrentAccessibleContext();
3472                 if (ac instanceof AccessibleComponent) {
3473                     return ((AccessibleComponent) ac).getCursor();
3474                 } else {
3475                     Component c = getCurrentComponent();
3476                     if (c != null) {
3477                         return c.getCursor();
3478                     } else {
3479                         Accessible ap = getAccessibleParent();
3480                         if (ap instanceof AccessibleComponent) {
3481                             return ((AccessibleComponent) ap).getCursor();
3482                         } else {
3483                             return null;
3484                         }
3485                     }
3486                 }
3487             }
3488 
3489             public void setCursor(Cursor c) {
3490                 AccessibleContext ac = getCurrentAccessibleContext();
3491                 if (ac instanceof AccessibleComponent) {
3492                     ((AccessibleComponent) ac).setCursor(c);
3493                 } else {
3494                     Component cp = getCurrentComponent();
3495                     if (cp != null) {
3496                         cp.setCursor(c);
3497                     }
3498                 }
3499             }
3500 
3501             public Font getFont() {
3502                 AccessibleContext ac = getCurrentAccessibleContext();
3503                 if (ac instanceof AccessibleComponent) {
3504                     return ((AccessibleComponent) ac).getFont();
3505                 } else {
3506                     Component c = getCurrentComponent();
3507                     if (c != null) {
3508                         return c.getFont();
3509                     } else {
3510                         return null;
3511                     }
3512                 }
3513             }
3514 
3515             public void setFont(Font f) {
3516                 AccessibleContext ac = getCurrentAccessibleContext();
3517                 if (ac instanceof AccessibleComponent) {
3518                     ((AccessibleComponent) ac).setFont(f);
3519                 } else {
3520                     Component c = getCurrentComponent();
3521                     if (c != null) {
3522                         c.setFont(f);
3523                     }
3524                 }
3525             }
3526 
3527             public FontMetrics getFontMetrics(Font f) {
3528                 AccessibleContext ac = getCurrentAccessibleContext();
3529                 if (ac instanceof AccessibleComponent) {
3530                     return ((AccessibleComponent) ac).getFontMetrics(f);
3531                 } else {
3532                     Component c = getCurrentComponent();
3533                     if (c != null) {
3534                         return c.getFontMetrics(f);
3535                     } else {
3536                         return null;
3537                     }
3538                 }
3539             }
3540 
3541             public boolean isEnabled() {
3542                 AccessibleContext ac = getCurrentAccessibleContext();
3543                 if (ac instanceof AccessibleComponent) {
3544                     return ((AccessibleComponent) ac).isEnabled();
3545                 } else {
3546                     Component c = getCurrentComponent();
3547                     if (c != null) {
3548                         return c.isEnabled();
3549                     } else {
3550                         return false;
3551                     }
3552                 }
3553             }
3554 
3555             public void setEnabled(boolean b) {
3556                 AccessibleContext ac = getCurrentAccessibleContext();
3557                 if (ac instanceof AccessibleComponent) {
3558                     ((AccessibleComponent) ac).setEnabled(b);
3559                 } else {
3560                     Component c = getCurrentComponent();
3561                     if (c != null) {
3562                         c.setEnabled(b);
3563                     }
3564                 }
3565             }
3566 
3567             public boolean isVisible() {
3568                 int fi = parent.getFirstVisibleIndex();
3569                 int li = parent.getLastVisibleIndex();
3570                 // The UI incorrectly returns a -1 for the last
3571                 // visible index if the list is smaller than the
3572                 // viewport size.
3573                 if (li == -1) {
3574                     li = parent.getModel().getSize() - 1;
3575                 }
3576                 return ((indexInParent &gt;= fi)
3577                         &amp;&amp; (indexInParent &lt;= li));
3578             }
3579 
3580             public void setVisible(boolean b) {
3581             }
3582 
3583             public boolean isShowing() {
3584                 return (parent.isShowing() &amp;&amp; isVisible());
3585             }
3586 
3587             public boolean contains(Point p) {
3588                 AccessibleContext ac = getCurrentAccessibleContext();
3589                 if (ac instanceof AccessibleComponent) {
3590                     Rectangle r = ((AccessibleComponent) ac).getBounds();
3591                     return r.contains(p);
3592                 } else {
3593                     Component c = getCurrentComponent();
3594                     if (c != null) {
3595                         Rectangle r = c.getBounds();
3596                         return r.contains(p);
3597                     } else {
3598                         return getBounds().contains(p);
3599                     }
3600                 }
3601             }
3602 
3603             public Point getLocationOnScreen() {
3604                 if (parent != null) {
3605                     Point listLocation;
3606                     try {
3607                         listLocation = parent.getLocationOnScreen();
3608                     } catch (IllegalComponentStateException e) {
3609                         // This can happen if the component isn&#39;t visisble
3610                         return null;
3611                     }
3612                     Point componentLocation = parent.indexToLocation(indexInParent);
3613                     if (componentLocation != null) {
3614                         componentLocation.translate(listLocation.x, listLocation.y);
3615                         return componentLocation;
3616                     } else {
3617                         return null;
3618                     }
3619                 } else {
3620                     return null;
3621                 }
3622             }
3623 
3624             public Point getLocation() {
3625                 if (parent != null) {
3626                     return parent.indexToLocation(indexInParent);
3627                 } else {
3628                     return null;
3629                 }
3630             }
3631 
3632             public void setLocation(Point p) {
3633                 if ((parent != null)  &amp;&amp; (parent.contains(p))) {
3634                     ensureIndexIsVisible(indexInParent);
3635                 }
3636             }
3637 
3638             public Rectangle getBounds() {
3639                 if (parent != null) {
3640                     return parent.getCellBounds(indexInParent,indexInParent);
3641                 } else {
3642                     return null;
3643                 }
3644             }
3645 
3646             public void setBounds(Rectangle r) {
3647                 AccessibleContext ac = getCurrentAccessibleContext();
3648                 if (ac instanceof AccessibleComponent) {
3649                     ((AccessibleComponent) ac).setBounds(r);
3650                 }
3651             }
3652 
3653             public Dimension getSize() {
3654                 Rectangle cellBounds = this.getBounds();
3655                 if (cellBounds != null) {
3656                     return cellBounds.getSize();
3657                 } else {
3658                     return null;
3659                 }
3660             }
3661 
3662             public void setSize (Dimension d) {
3663                 AccessibleContext ac = getCurrentAccessibleContext();
3664                 if (ac instanceof AccessibleComponent) {
3665                     ((AccessibleComponent) ac).setSize(d);
3666                 } else {
3667                     Component c = getCurrentComponent();
3668                     if (c != null) {
3669                         c.setSize(d);
3670                     }
3671                 }
3672             }
3673 
3674             public Accessible getAccessibleAt(Point p) {
3675                 AccessibleContext ac = getCurrentAccessibleContext();
3676                 if (ac instanceof AccessibleComponent) {
3677                     return ((AccessibleComponent) ac).getAccessibleAt(p);
3678                 } else {
3679                     return null;
3680                 }
3681             }
3682 
3683             @SuppressWarnings(&quot;deprecation&quot;)
3684             public boolean isFocusTraversable() {
3685                 AccessibleContext ac = getCurrentAccessibleContext();
3686                 if (ac instanceof AccessibleComponent) {
3687                     return ((AccessibleComponent) ac).isFocusTraversable();
3688                 } else {
3689                     Component c = getCurrentComponent();
3690                     if (c != null) {
3691                         return c.isFocusTraversable();
3692                     } else {
3693                         return false;
3694                     }
3695                 }
3696             }
3697 
3698             public void requestFocus() {
3699                 AccessibleContext ac = getCurrentAccessibleContext();
3700                 if (ac instanceof AccessibleComponent) {
3701                     ((AccessibleComponent) ac).requestFocus();
3702                 } else {
3703                     Component c = getCurrentComponent();
3704                     if (c != null) {
3705                         c.requestFocus();
3706                     }
3707                 }
3708             }
3709 
3710             public void addFocusListener(FocusListener l) {
3711                 AccessibleContext ac = getCurrentAccessibleContext();
3712                 if (ac instanceof AccessibleComponent) {
3713                     ((AccessibleComponent) ac).addFocusListener(l);
3714                 } else {
3715                     Component c = getCurrentComponent();
3716                     if (c != null) {
3717                         c.addFocusListener(l);
3718                     }
3719                 }
3720             }
3721 
3722             public void removeFocusListener(FocusListener l) {
3723                 AccessibleContext ac = getCurrentAccessibleContext();
3724                 if (ac instanceof AccessibleComponent) {
3725                     ((AccessibleComponent) ac).removeFocusListener(l);
3726                 } else {
3727                     Component c = getCurrentComponent();
3728                     if (c != null) {
3729                         c.removeFocusListener(l);
3730                     }
3731                 }
3732             }
3733 
3734             // TIGER - 4733624
3735             /**
3736              * Returns the icon for the element renderer, as the only item
3737              * of an array of &lt;code&gt;AccessibleIcon&lt;/code&gt;s or a &lt;code&gt;null&lt;/code&gt; array
3738              * if the renderer component contains no icons.
3739              *
3740              * @return an array containing the accessible icon
3741              *         or a &lt;code&gt;null&lt;/code&gt; array if none
3742              * @since 1.3
3743              */
3744             public AccessibleIcon [] getAccessibleIcon() {
3745                 AccessibleContext ac = getCurrentAccessibleContext();
3746                 if (ac != null) {
3747                     return ac.getAccessibleIcon();
3748                 } else {
3749                     return null;
3750                 }
3751             }
3752 
3753             /**
3754              * {@inheritDoc}
3755              * @implSpec Returns the AccessibleAction for this AccessibleJListChild
3756              * as follows:  First getListCellRendererComponent of the ListCellRenderer
3757              * for the component at the &quot;index in parent&quot; of this child is called.
3758              * Then its AccessibleContext is fetched and that AccessibleContext&#39;s
3759              * AccessibleAction is returned.  Note that if an AccessibleAction
3760              * is not found using this process then this object with its implementation
3761              * of the AccessibleAction interface is returned.
3762              * @since 9
3763              */
3764             @Override
3765             public AccessibleAction getAccessibleAction() {
3766                 AccessibleContext ac = getCurrentAccessibleContext();
3767                 if (ac == null) {
3768                     return null;
3769                 } else {
3770                     AccessibleAction aa = ac.getAccessibleAction();
3771                     if (aa != null) {
3772                         return aa;
3773                     } else {
3774                         return this;
3775                     }
3776                 }
3777             }
3778 
3779             /**
3780              * {@inheritDoc}
3781              * @implSpec If i == 0 selects this AccessibleJListChild by calling
3782              * JList.this.setSelectedIndex(indexInParent) and then returns true;
3783              * otherwise returns false.
3784              * @since 9
3785              */
3786             @Override
3787             public boolean doAccessibleAction(int i) {
3788                 if (i == 0) {
3789                     JList.this.setSelectedIndex(indexInParent);
3790                     return true;
3791                 } else {
3792                     return false;
3793                 }
3794             }
3795 
3796             /**
3797              * {@inheritDoc}
3798              * @implSpec If i == 0 returns the action description fetched from
3799              * UIManager.getString(&quot;AbstractButton.clickText&quot;);
3800              * otherwise returns null.
3801              * @since 9
3802              */
3803             @Override
3804             public String getAccessibleActionDescription(int i) {
3805                 if (i == 0) {
3806                     return UIManager.getString(&quot;AbstractButton.clickText&quot;);
3807                 } else {
3808                     return null;
3809                 }
3810             }
3811 
3812             /**
3813              * {@inheritDoc}
3814              * @implSpec Returns 1, i.e. there is only one action.
3815              * @since 9
3816              */
3817             @Override
3818             public int getAccessibleActionCount() {
3819                 return 1;
3820             }
3821 
3822         } // inner class AccessibleJListChild
3823 
3824     } // inner class AccessibleJList
3825 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
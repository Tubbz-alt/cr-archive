<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.amd64;
 27 
 28 import static jdk.vm.ci.code.ValueUtil.asRegister;
 29 import static jdk.vm.ci.code.ValueUtil.isAllocatableValue;
 30 import static jdk.vm.ci.code.ValueUtil.isRegister;
<span class="line-modified"> 31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;</span>
 32 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 33 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
 34 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
 35 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 36 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 37 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 40 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 41 import static org.graalvm.compiler.lir.LIRValueUtil.isIntConstant;
 42 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 43 
 44 import java.util.Optional;
 45 
 46 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
 47 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 50 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 51 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
</pre>
<hr />
<pre>
 61 import org.graalvm.compiler.lir.ConstantValue;
 62 import org.graalvm.compiler.lir.LIRFrameState;
 63 import org.graalvm.compiler.lir.LIRInstruction;
 64 import org.graalvm.compiler.lir.LIRValueUtil;
 65 import org.graalvm.compiler.lir.LabelRef;
 66 import org.graalvm.compiler.lir.StandardOp.JumpOp;
 67 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;
 68 import org.graalvm.compiler.lir.SwitchStrategy;
 69 import org.graalvm.compiler.lir.Variable;
 70 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 71 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 72 import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
 73 import org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp;
 74 import org.graalvm.compiler.lir.amd64.AMD64ArrayIndexOfOp;
 75 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 76 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 77 import org.graalvm.compiler.lir.amd64.AMD64ByteSwapOp;
 78 import org.graalvm.compiler.lir.amd64.AMD64Call;
 79 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow;
 80 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;



 81 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
 82 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
 83 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
 84 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
 85 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;
 86 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;
 87 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
 88 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
 89 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;



 90 import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
 91 import org.graalvm.compiler.lir.amd64.AMD64Move;
 92 import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
 93 import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
 94 import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
 95 import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
 96 import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
 97 import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
 98 import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
 99 import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;
100 import org.graalvm.compiler.lir.amd64.AMD64ZeroMemoryOp;
101 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorCompareOp;
102 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
103 import org.graalvm.compiler.lir.gen.LIRGenerator;
104 import org.graalvm.compiler.lir.hashing.Hasher;
105 import org.graalvm.compiler.phases.util.Providers;
106 
107 import jdk.vm.ci.amd64.AMD64;
108 import jdk.vm.ci.amd64.AMD64Kind;
109 import jdk.vm.ci.code.CallingConvention;
110 import jdk.vm.ci.code.Register;
111 import jdk.vm.ci.code.RegisterValue;
112 import jdk.vm.ci.code.StackSlot;
113 import jdk.vm.ci.meta.AllocatableValue;

114 import jdk.vm.ci.meta.JavaConstant;
115 import jdk.vm.ci.meta.JavaKind;
116 import jdk.vm.ci.meta.PlatformKind;
117 import jdk.vm.ci.meta.VMConstant;
118 import jdk.vm.ci.meta.Value;
119 import jdk.vm.ci.meta.ValueKind;
120 
121 /**
122  * This class implements the AMD64 specific portion of the LIR generator.
123  */
124 public abstract class AMD64LIRGenerator extends LIRGenerator {
125 
126     public AMD64LIRGenerator(LIRKindTool lirKindTool, AMD64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, Providers providers, LIRGenerationResult lirGenRes) {
127         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
128     }
129 
130     /**
131      * Checks whether the supplied constant can be used without loading it into a register for store
132      * operations, i.e., on the right hand side of a memory access.
133      *
</pre>
<hr />
<pre>
229         Value reinterpretedExpectedValue = expectedValue;
230         Value reinterpretedNewValue = newValue;
231         boolean isXmm = ((AMD64Kind) accessKind.getPlatformKind()).isXMM();
232         if (isXmm) {
233             if (accessKind.getPlatformKind().equals(AMD64Kind.SINGLE)) {
234                 integralAccessKind = LIRKind.fromJavaKind(target().arch, JavaKind.Int);
235             } else {
236                 integralAccessKind = LIRKind.fromJavaKind(target().arch, JavaKind.Long);
237             }
238             reinterpretedExpectedValue = arithmeticLIRGen.emitReinterpret(integralAccessKind, expectedValue);
239             reinterpretedNewValue = arithmeticLIRGen.emitReinterpret(integralAccessKind, newValue);
240         }
241         AMD64Kind memKind = (AMD64Kind) integralAccessKind.getPlatformKind();
242         RegisterValue aRes = AMD64.rax.asValue(integralAccessKind);
243         AllocatableValue allocatableNewValue = asAllocatable(reinterpretedNewValue, integralAccessKind);
244         emitMove(aRes, reinterpretedExpectedValue);
245         append(new CompareAndSwapOp(memKind, aRes, addressValue, aRes, allocatableNewValue));
246 
247         if (isLogic) {
248             assert trueValue.getValueKind().equals(falseValue.getValueKind());
<span class="line-modified">249             Variable result = newVariable(trueValue.getValueKind());</span>
<span class="line-removed">250             append(new CondMoveOp(result, Condition.EQ, asAllocatable(trueValue), falseValue));</span>
<span class="line-removed">251             return result;</span>
252         } else {
253             if (isXmm) {
254                 return arithmeticLIRGen.emitReinterpret(accessKind, aRes);
255             } else {
256                 Variable result = newVariable(kind);
257                 emitMove(result, aRes);
258                 return result;
259             }
260         }
261     }
262 
263     @Override
264     public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {
265         return (Variable) emitCompareAndSwap(true, accessKind, address, expectedValue, newValue, trueValue, falseValue);
266     }
267 
268     @Override
269     public Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue) {
270         return emitCompareAndSwap(false, accessKind, address, expectedValue, newValue, null, null);
271     }
</pre>
<hr />
<pre>
294     public Value emitAtomicReadAndWrite(Value address, ValueKind&lt;?&gt; kind, Value newValue) {
295         Variable result = newVariable(kind);
296         AMD64AddressValue addressValue = asAddressValue(address);
297         append(new AMD64Move.AtomicReadAndWriteOp((AMD64Kind) kind.getPlatformKind(), result, addressValue, asAllocatable(newValue)));
298         return result;
299     }
300 
301     @Override
302     public void emitNullCheck(Value address, LIRFrameState state) {
303         append(new AMD64Move.NullCheckOp(asAddressValue(address), state));
304     }
305 
306     @Override
307     public void emitJump(LabelRef label) {
308         assert label != null;
309         append(new JumpOp(label));
310     }
311 
312     @Override
313     public void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel, double trueLabelProbability) {
<span class="line-removed">314         Condition finalCondition = emitCompare(cmpKind, left, right, cond);</span>
315         if (cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE) {

316             append(new FloatBranchOp(finalCondition, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));





317         } else {
<span class="line-modified">318             append(new BranchOp(finalCondition, trueLabel, falseLabel, trueLabelProbability));</span>
319         }
320     }
321 







































322     public void emitCompareBranchMemory(AMD64Kind cmpKind, Value left, AMD64AddressValue right, LIRFrameState state, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel,
323                     double trueLabelProbability) {
<span class="line-removed">324         boolean mirrored = emitCompareMemory(cmpKind, left, right, state);</span>
<span class="line-removed">325         Condition finalCondition = mirrored ? cond.mirror() : cond;</span>
326         if (cmpKind.isXMM()) {
<span class="line-modified">327             append(new FloatBranchOp(finalCondition, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));</span>








328         } else {
<span class="line-modified">329             append(new BranchOp(finalCondition, trueLabel, falseLabel, trueLabelProbability));</span>


















330         }
331     }
332 
333     @Override
334     public void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpLIRKind, double overflowProbability) {
335         append(new BranchOp(ConditionFlag.Overflow, overflow, noOverflow, overflowProbability));
336     }
337 
338     @Override
339     public void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
<span class="line-modified">340         emitIntegerTest(left, right);</span>
<span class="line-modified">341         append(new BranchOp(Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>














342     }
343 
344     @Override
345     public Variable emitConditionalMove(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue) {
346         boolean isFloatComparison = cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE;
347 
348         Condition finalCondition = cond;
349         Value finalTrueValue = trueValue;
350         Value finalFalseValue = falseValue;
351         if (isFloatComparison) {
352             // eliminate the parity check in case of a float comparison
353             Value finalLeft = left;
354             Value finalRight = right;
355             if (unorderedIsTrue != AMD64ControlFlow.trueOnUnordered(finalCondition)) {
356                 if (unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(finalCondition.mirror())) {
357                     finalCondition = finalCondition.mirror();
358                     finalLeft = right;
359                     finalRight = left;
360                 } else if (finalCondition != Condition.EQ &amp;&amp; finalCondition != Condition.NE) {
361                     // negating EQ and NE does not make any sense as we would need to negate
362                     // unorderedIsTrue as well (otherwise, we would no longer fulfill the Java
363                     // NaN semantics)
364                     assert unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(finalCondition.negate());
365                     finalCondition = finalCondition.negate();
366                     finalTrueValue = falseValue;
367                     finalFalseValue = trueValue;
368                 }
369             }
370             emitRawCompare(cmpKind, finalLeft, finalRight);
371         } else {
372             finalCondition = emitCompare(cmpKind, left, right, cond);
373         }
374 
<span class="line-modified">375         boolean isParityCheckNecessary = isFloatComparison &amp;&amp; unorderedIsTrue != AMD64ControlFlow.trueOnUnordered(finalCondition);</span>
<span class="line-modified">376         Variable result = newVariable(finalTrueValue.getValueKind());</span>
<span class="line-modified">377         if (!isParityCheckNecessary &amp;&amp; isIntConstant(finalTrueValue, 1) &amp;&amp; isIntConstant(finalFalseValue, 0)) {</span>




378             if (isFloatComparison) {
<span class="line-modified">379                 append(new FloatCondSetOp(result, finalCondition));</span>
380             } else {
<span class="line-modified">381                 append(new CondSetOp(result, finalCondition));</span>
382             }
<span class="line-modified">383         } else if (!isParityCheckNecessary &amp;&amp; isIntConstant(finalTrueValue, 0) &amp;&amp; isIntConstant(finalFalseValue, 1)) {</span>
384             if (isFloatComparison) {
<span class="line-modified">385                 if (unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(finalCondition.negate())) {</span>
<span class="line-modified">386                     append(new FloatCondSetOp(result, finalCondition.negate()));</span>
387                 } else {
<span class="line-modified">388                     append(new FloatCondSetOp(result, finalCondition));</span>
389                     Variable negatedResult = newVariable(result.getValueKind());
390                     append(new AMD64Binary.ConstOp(AMD64BinaryArithmetic.XOR, OperandSize.get(result.getPlatformKind()), negatedResult, result, 1));
391                     result = negatedResult;
392                 }
393             } else {
<span class="line-modified">394                 append(new CondSetOp(result, finalCondition.negate()));</span>
395             }
396         } else if (isFloatComparison) {
<span class="line-modified">397             append(new FloatCondMoveOp(result, finalCondition, unorderedIsTrue, load(finalTrueValue), load(finalFalseValue)));</span>
398         } else {
<span class="line-modified">399             append(new CondMoveOp(result, finalCondition, load(finalTrueValue), loadNonConst(finalFalseValue)));</span>
400         }
401         return result;
402     }
403 
404     @Override
405     public Variable emitIntegerTestMove(Value left, Value right, Value trueValue, Value falseValue) {
406         emitIntegerTest(left, right);
<span class="line-modified">407         Variable result = newVariable(trueValue.getValueKind());</span>
<span class="line-removed">408         append(new CondMoveOp(result, Condition.EQ, load(trueValue), loadNonConst(falseValue)));</span>
<span class="line-removed">409         return result;</span>
410     }
411 
412     protected static AVXSize getRegisterSize(Value a) {
413         AMD64Kind kind = (AMD64Kind) a.getPlatformKind();
414         if (kind.isXMM()) {
415             return AVXKind.getRegisterSize(kind);
416         } else {
417             return AVXSize.XMM;
418         }
419     }
420 
421     private void emitIntegerTest(Value a, Value b) {
422         if (a.getPlatformKind().getVectorLength() &gt; 1) {
423             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(a), asAllocatable(a), asAllocatable(b)));
424         } else {
425             assert ((AMD64Kind) a.getPlatformKind()).isInteger();
426             OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;
427             if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {
428                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));
429             } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {
430                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));
431             } else if (isAllocatableValue(b)) {
432                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));
433             } else {
434                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));
435             }
436         }
437     }
438 
<span class="line-removed">439     /**</span>
<span class="line-removed">440      * This method emits the compare against memory instruction, and may reorder the operands. It</span>
<span class="line-removed">441      * returns true if it did so.</span>
<span class="line-removed">442      *</span>
<span class="line-removed">443      * @param b the right operand of the comparison</span>
<span class="line-removed">444      * @return true if the left and right operands were switched, false otherwise</span>
<span class="line-removed">445      */</span>
<span class="line-removed">446     private boolean emitCompareMemory(AMD64Kind cmpKind, Value a, AMD64AddressValue b, LIRFrameState state) {</span>
<span class="line-removed">447         OperandSize size;</span>
<span class="line-removed">448         switch (cmpKind) {</span>
<span class="line-removed">449             case BYTE:</span>
<span class="line-removed">450                 size = OperandSize.BYTE;</span>
<span class="line-removed">451                 break;</span>
<span class="line-removed">452             case WORD:</span>
<span class="line-removed">453                 size = OperandSize.WORD;</span>
<span class="line-removed">454                 break;</span>
<span class="line-removed">455             case DWORD:</span>
<span class="line-removed">456                 size = OperandSize.DWORD;</span>
<span class="line-removed">457                 break;</span>
<span class="line-removed">458             case QWORD:</span>
<span class="line-removed">459                 size = OperandSize.QWORD;</span>
<span class="line-removed">460                 break;</span>
<span class="line-removed">461             case SINGLE:</span>
<span class="line-removed">462                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PS, asAllocatable(a), b, state));</span>
<span class="line-removed">463                 return false;</span>
<span class="line-removed">464             case DOUBLE:</span>
<span class="line-removed">465                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PD, asAllocatable(a), b, state));</span>
<span class="line-removed">466                 return false;</span>
<span class="line-removed">467             default:</span>
<span class="line-removed">468                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);</span>
<span class="line-removed">469         }</span>
<span class="line-removed">470 </span>
<span class="line-removed">471         if (isConstantValue(a)) {</span>
<span class="line-removed">472             return emitCompareMemoryConOp(size, asConstantValue(a), b, state);</span>
<span class="line-removed">473         } else {</span>
<span class="line-removed">474             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
<span class="line-removed">475         }</span>
<span class="line-removed">476     }</span>
<span class="line-removed">477 </span>
<span class="line-removed">478     protected boolean emitCompareMemoryConOp(OperandSize size, ConstantValue a, AMD64AddressValue b, LIRFrameState state) {</span>
<span class="line-removed">479         if (JavaConstant.isNull(a.getConstant())) {</span>
<span class="line-removed">480             append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, 0, state));</span>
<span class="line-removed">481             return true;</span>
<span class="line-removed">482         } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD &amp;&amp; target().inlineObjects) {</span>
<span class="line-removed">483             VMConstant vc = (VMConstant) a.getConstant();</span>
<span class="line-removed">484             append(new AMD64BinaryConsumer.MemoryVMConstOp(CMP.getMIOpcode(size, false), b, vc, state));</span>
<span class="line-removed">485             return true;</span>
<span class="line-removed">486         } else {</span>
<span class="line-removed">487             if (a.getConstant() instanceof JavaConstant &amp;&amp; a.getJavaConstant().getJavaKind() != JavaKind.Object) {</span>
<span class="line-removed">488                 long value = a.getJavaConstant().asLong();</span>
<span class="line-removed">489                 if (NumUtil.is32bit(value)) {</span>
<span class="line-removed">490                     append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, (int) value, state));</span>
<span class="line-removed">491                     return true;</span>
<span class="line-removed">492                 }</span>
<span class="line-removed">493             }</span>
<span class="line-removed">494             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
<span class="line-removed">495         }</span>
<span class="line-removed">496     }</span>
<span class="line-removed">497 </span>
<span class="line-removed">498     private boolean emitCompareRegMemoryOp(OperandSize size, AllocatableValue a, AMD64AddressValue b, LIRFrameState state) {</span>
<span class="line-removed">499         AMD64RMOp op = CMP.getRMOpcode(size);</span>
<span class="line-removed">500         append(new AMD64BinaryConsumer.MemoryRMOp(op, size, a, b, state));</span>
<span class="line-removed">501         return false;</span>
<span class="line-removed">502     }</span>
<span class="line-removed">503 </span>
504     /**
505      * This method emits the compare instruction, and may reorder the operands. It returns true if
506      * it did so.
507      *
508      * @param a the left operand of the comparison
509      * @param b the right operand of the comparison
510      * @param cond the condition of the comparison
511      * @return true if the left and right operands were switched, false otherwise
512      */
513     private Condition emitCompare(PlatformKind cmpKind, Value a, Value b, Condition cond) {
514         if (LIRValueUtil.isVariable(b)) {
515             emitRawCompare(cmpKind, b, a);
516             return cond.mirror();
517         } else {
518             emitRawCompare(cmpKind, a, b);
519             return cond;
520         }
521     }
522 
523     private void emitRawCompare(PlatformKind cmpKind, Value left, Value right) {
</pre>
<hr />
<pre>
542         } else {
543             append(new AMD64Call.DirectNearForeignCallOp(linkage, result, arguments, temps, info));
544         }
545     }
546 
547     @Override
548     public Variable emitByteSwap(Value input) {
549         Variable result = newVariable(LIRKind.combine(input));
550         append(new AMD64ByteSwapOp(result, input));
551         return result;
552     }
553 
554     @Override
555     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
556         LIRKind resultKind = LIRKind.value(AMD64Kind.DWORD);
557         RegisterValue raxRes = AMD64.rax.asValue(resultKind);
558         RegisterValue cnt1 = AMD64.rcx.asValue(length1.getValueKind());
559         RegisterValue cnt2 = AMD64.rdx.asValue(length2.getValueKind());
560         emitMove(cnt1, length1);
561         emitMove(cnt2, length2);
<span class="line-modified">562         append(new AMD64ArrayCompareToOp(this, kind1, kind2, raxRes, array1, array2, cnt1, cnt2));</span>
563         Variable result = newVariable(resultKind);
564         emitMove(result, raxRes);
565         return result;
566     }
567 
568     @Override
569     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {
570         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
571         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, length, directPointers, getMaxVectorSize()));
572         return result;
573     }
574 
575     @Override
576     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {
577         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
578         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, length, directPointers, getMaxVectorSize()));
579         return result;
580     }
581 
582     /**
583      * Return the maximum size of vector registers used in SSE/AVX instructions.
584      */
585     protected int getMaxVectorSize() {
586         // default for &quot;unlimited&quot;
587         return -1;
588     }
589 







590     @Override
591     public Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value fromIndex, Value... searchValues) {
592         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
593         append(new AMD64ArrayIndexOfOp(arrayKind, valueKind, findTwoConsecutive, getMaxVectorSize(), this, result,
594                         asAllocatable(arrayPointer), asAllocatable(arrayLength), asAllocatable(fromIndex), searchValues));
595         return result;
596     }
597 
598     @Override
599     public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
600         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
601         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
602         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
603 
604         emitMove(rsrc, src);
605         emitMove(rdst, dst);
606         emitMove(rlen, len);
607 
<span class="line-modified">608         append(new AMD64StringLatin1InflateOp(this, rsrc, rdst, rlen));</span>
609     }
610 
611     @Override
612     public Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
613         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
614         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
615         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
616 
617         emitMove(rsrc, src);
618         emitMove(rdst, dst);
619         emitMove(rlen, len);
620 
621         LIRKind reskind = LIRKind.value(AMD64Kind.DWORD);
622         RegisterValue rres = AMD64.rax.asValue(reskind);
623 
<span class="line-modified">624         append(new AMD64StringUTF16CompressOp(this, rres, rsrc, rdst, rlen));</span>
625 
626         Variable res = newVariable(reskind);
627         emitMove(res, rres);
628         return res;
629     }
630 
631     @Override
632     public void emitReturn(JavaKind kind, Value input) {
633         AllocatableValue operand = Value.ILLEGAL;
634         if (input != null) {
635             operand = resultOperandFor(kind, input.getValueKind());
636             emitMove(operand, input);
637         }
638         append(new ReturnOp(operand));
639     }
640 
641     protected StrategySwitchOp createStrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, AllocatableValue temp) {
642         return new StrategySwitchOp(strategy, keyTargets, defaultTarget, key, temp);
643     }
644 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.amd64;
 27 
 28 import static jdk.vm.ci.code.ValueUtil.asRegister;
 29 import static jdk.vm.ci.code.ValueUtil.isAllocatableValue;
 30 import static jdk.vm.ci.code.ValueUtil.isRegister;
<span class="line-modified"> 31 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.BYTE;</span>
 32 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 33 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
 34 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
 35 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 36 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 37 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 40 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 41 import static org.graalvm.compiler.lir.LIRValueUtil.isIntConstant;
 42 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 43 
 44 import java.util.Optional;
 45 
 46 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
 47 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 50 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 51 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
</pre>
<hr />
<pre>
 61 import org.graalvm.compiler.lir.ConstantValue;
 62 import org.graalvm.compiler.lir.LIRFrameState;
 63 import org.graalvm.compiler.lir.LIRInstruction;
 64 import org.graalvm.compiler.lir.LIRValueUtil;
 65 import org.graalvm.compiler.lir.LabelRef;
 66 import org.graalvm.compiler.lir.StandardOp.JumpOp;
 67 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;
 68 import org.graalvm.compiler.lir.SwitchStrategy;
 69 import org.graalvm.compiler.lir.Variable;
 70 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 71 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 72 import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
 73 import org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp;
 74 import org.graalvm.compiler.lir.amd64.AMD64ArrayIndexOfOp;
 75 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 76 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 77 import org.graalvm.compiler.lir.amd64.AMD64ByteSwapOp;
 78 import org.graalvm.compiler.lir.amd64.AMD64Call;
 79 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow;
 80 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;
<span class="line-added"> 81 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CmpBranchOp;</span>
<span class="line-added"> 82 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CmpConstBranchOp;</span>
<span class="line-added"> 83 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CmpDataBranchOp;</span>
 84 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
 85 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
 86 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
 87 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
 88 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;
 89 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;
 90 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
 91 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
 92 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;
<span class="line-added"> 93 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TestBranchOp;</span>
<span class="line-added"> 94 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TestByteBranchOp;</span>
<span class="line-added"> 95 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TestConstBranchOp;</span>
 96 import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
 97 import org.graalvm.compiler.lir.amd64.AMD64Move;
 98 import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
 99 import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
100 import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
101 import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
102 import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
103 import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
104 import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
105 import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;
106 import org.graalvm.compiler.lir.amd64.AMD64ZeroMemoryOp;
107 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorCompareOp;
108 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
109 import org.graalvm.compiler.lir.gen.LIRGenerator;
110 import org.graalvm.compiler.lir.hashing.Hasher;
111 import org.graalvm.compiler.phases.util.Providers;
112 
113 import jdk.vm.ci.amd64.AMD64;
114 import jdk.vm.ci.amd64.AMD64Kind;
115 import jdk.vm.ci.code.CallingConvention;
116 import jdk.vm.ci.code.Register;
117 import jdk.vm.ci.code.RegisterValue;
118 import jdk.vm.ci.code.StackSlot;
119 import jdk.vm.ci.meta.AllocatableValue;
<span class="line-added">120 import jdk.vm.ci.meta.Constant;</span>
121 import jdk.vm.ci.meta.JavaConstant;
122 import jdk.vm.ci.meta.JavaKind;
123 import jdk.vm.ci.meta.PlatformKind;
124 import jdk.vm.ci.meta.VMConstant;
125 import jdk.vm.ci.meta.Value;
126 import jdk.vm.ci.meta.ValueKind;
127 
128 /**
129  * This class implements the AMD64 specific portion of the LIR generator.
130  */
131 public abstract class AMD64LIRGenerator extends LIRGenerator {
132 
133     public AMD64LIRGenerator(LIRKindTool lirKindTool, AMD64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, Providers providers, LIRGenerationResult lirGenRes) {
134         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
135     }
136 
137     /**
138      * Checks whether the supplied constant can be used without loading it into a register for store
139      * operations, i.e., on the right hand side of a memory access.
140      *
</pre>
<hr />
<pre>
236         Value reinterpretedExpectedValue = expectedValue;
237         Value reinterpretedNewValue = newValue;
238         boolean isXmm = ((AMD64Kind) accessKind.getPlatformKind()).isXMM();
239         if (isXmm) {
240             if (accessKind.getPlatformKind().equals(AMD64Kind.SINGLE)) {
241                 integralAccessKind = LIRKind.fromJavaKind(target().arch, JavaKind.Int);
242             } else {
243                 integralAccessKind = LIRKind.fromJavaKind(target().arch, JavaKind.Long);
244             }
245             reinterpretedExpectedValue = arithmeticLIRGen.emitReinterpret(integralAccessKind, expectedValue);
246             reinterpretedNewValue = arithmeticLIRGen.emitReinterpret(integralAccessKind, newValue);
247         }
248         AMD64Kind memKind = (AMD64Kind) integralAccessKind.getPlatformKind();
249         RegisterValue aRes = AMD64.rax.asValue(integralAccessKind);
250         AllocatableValue allocatableNewValue = asAllocatable(reinterpretedNewValue, integralAccessKind);
251         emitMove(aRes, reinterpretedExpectedValue);
252         append(new CompareAndSwapOp(memKind, aRes, addressValue, aRes, allocatableNewValue));
253 
254         if (isLogic) {
255             assert trueValue.getValueKind().equals(falseValue.getValueKind());
<span class="line-modified">256             return emitCondMoveOp(Condition.EQ, trueValue, falseValue, false, false);</span>


257         } else {
258             if (isXmm) {
259                 return arithmeticLIRGen.emitReinterpret(accessKind, aRes);
260             } else {
261                 Variable result = newVariable(kind);
262                 emitMove(result, aRes);
263                 return result;
264             }
265         }
266     }
267 
268     @Override
269     public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {
270         return (Variable) emitCompareAndSwap(true, accessKind, address, expectedValue, newValue, trueValue, falseValue);
271     }
272 
273     @Override
274     public Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue) {
275         return emitCompareAndSwap(false, accessKind, address, expectedValue, newValue, null, null);
276     }
</pre>
<hr />
<pre>
299     public Value emitAtomicReadAndWrite(Value address, ValueKind&lt;?&gt; kind, Value newValue) {
300         Variable result = newVariable(kind);
301         AMD64AddressValue addressValue = asAddressValue(address);
302         append(new AMD64Move.AtomicReadAndWriteOp((AMD64Kind) kind.getPlatformKind(), result, addressValue, asAllocatable(newValue)));
303         return result;
304     }
305 
306     @Override
307     public void emitNullCheck(Value address, LIRFrameState state) {
308         append(new AMD64Move.NullCheckOp(asAddressValue(address), state));
309     }
310 
311     @Override
312     public void emitJump(LabelRef label) {
313         assert label != null;
314         append(new JumpOp(label));
315     }
316 
317     @Override
318     public void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel, double trueLabelProbability) {

319         if (cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE) {
<span class="line-added">320             Condition finalCondition = emitCompare(cmpKind, left, right, cond);</span>
321             append(new FloatBranchOp(finalCondition, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));
<span class="line-added">322             return;</span>
<span class="line-added">323         }</span>
<span class="line-added">324 </span>
<span class="line-added">325         if (LIRValueUtil.isVariable(right)) {</span>
<span class="line-added">326             emitRawCompareBranch(OperandSize.get(cmpKind), load(right), loadNonConst(left), cond.mirror(), trueLabel, falseLabel, trueLabelProbability);</span>
327         } else {
<span class="line-modified">328             emitRawCompareBranch(OperandSize.get(cmpKind), load(left), loadNonConst(right), cond, trueLabel, falseLabel, trueLabelProbability);</span>
329         }
330     }
331 
<span class="line-added">332     private void emitRawCompareBranch(OperandSize size, Variable left, Value right, Condition cond, LabelRef trueLabel, LabelRef falseLabel, double trueLabelProbability) {</span>
<span class="line-added">333         if (isConstantValue(right)) {</span>
<span class="line-added">334             Constant c = LIRValueUtil.asConstant(right);</span>
<span class="line-added">335             if (JavaConstant.isNull(c)) {</span>
<span class="line-added">336                 AMD64ArithmeticLIRGenerator arithmeticLIRGenerator = (AMD64ArithmeticLIRGenerator) arithmeticLIRGen;</span>
<span class="line-added">337                 if (arithmeticLIRGenerator.mustReplaceNullWithNullRegister(c)) {</span>
<span class="line-added">338                     append(new CmpBranchOp(size, left, arithmeticLIRGenerator.getNullRegisterValue(), null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">339                 } else {</span>
<span class="line-added">340                     append(new TestBranchOp(size, left, left, null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">341                 }</span>
<span class="line-added">342                 return;</span>
<span class="line-added">343             } else if (c instanceof VMConstant) {</span>
<span class="line-added">344                 VMConstant vc = (VMConstant) c;</span>
<span class="line-added">345                 if (size == DWORD &amp;&amp; !GeneratePIC.getValue(getResult().getLIR().getOptions()) &amp;&amp; target().inlineObjects) {</span>
<span class="line-added">346                     append(new CmpConstBranchOp(DWORD, left, vc, null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">347                 } else {</span>
<span class="line-added">348                     append(new CmpDataBranchOp(size, left, vc, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">349                 }</span>
<span class="line-added">350                 return;</span>
<span class="line-added">351             } else if (c instanceof JavaConstant) {</span>
<span class="line-added">352                 JavaConstant jc = (JavaConstant) c;</span>
<span class="line-added">353                 if (jc.isDefaultForKind()) {</span>
<span class="line-added">354                     if (size == BYTE) {</span>
<span class="line-added">355                         append(new TestByteBranchOp(left, left, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">356                     } else {</span>
<span class="line-added">357                         append(new TestBranchOp(size, left, left, null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">358                     }</span>
<span class="line-added">359                     return;</span>
<span class="line-added">360                 } else if (NumUtil.is32bit(jc.asLong())) {</span>
<span class="line-added">361                     append(new CmpConstBranchOp(size, left, (int) jc.asLong(), null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">362                     return;</span>
<span class="line-added">363                 }</span>
<span class="line-added">364             }</span>
<span class="line-added">365         }</span>
<span class="line-added">366 </span>
<span class="line-added">367         // fallback: load, then compare</span>
<span class="line-added">368         append(new CmpBranchOp(size, left, asAllocatable(right), null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">369     }</span>
<span class="line-added">370 </span>
371     public void emitCompareBranchMemory(AMD64Kind cmpKind, Value left, AMD64AddressValue right, LIRFrameState state, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel,
372                     double trueLabelProbability) {


373         if (cmpKind.isXMM()) {
<span class="line-modified">374             if (cmpKind == AMD64Kind.SINGLE) {</span>
<span class="line-added">375                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PS, asAllocatable(left), right, state));</span>
<span class="line-added">376                 append(new FloatBranchOp(cond, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">377             } else if (cmpKind == AMD64Kind.DOUBLE) {</span>
<span class="line-added">378                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PD, asAllocatable(left), right, state));</span>
<span class="line-added">379                 append(new FloatBranchOp(cond, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">380             } else {</span>
<span class="line-added">381                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);</span>
<span class="line-added">382             }</span>
383         } else {
<span class="line-modified">384             OperandSize size = OperandSize.get(cmpKind);</span>
<span class="line-added">385             if (isConstantValue(left)) {</span>
<span class="line-added">386                 ConstantValue a = asConstantValue(left);</span>
<span class="line-added">387                 if (JavaConstant.isNull(a.getConstant())) {</span>
<span class="line-added">388                     append(new CmpConstBranchOp(size, right, 0, state, cond.mirror(), trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">389                     return;</span>
<span class="line-added">390                 } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD &amp;&amp; target().inlineObjects) {</span>
<span class="line-added">391                     VMConstant vc = (VMConstant) a.getConstant();</span>
<span class="line-added">392                     append(new CmpConstBranchOp(size, right, vc, state, cond.mirror(), trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">393                     return;</span>
<span class="line-added">394                 } else if (a.getConstant() instanceof JavaConstant &amp;&amp; a.getJavaConstant().getJavaKind() != JavaKind.Object) {</span>
<span class="line-added">395                     long value = a.getJavaConstant().asLong();</span>
<span class="line-added">396                     if (NumUtil.is32bit(value)) {</span>
<span class="line-added">397                         append(new CmpConstBranchOp(size, right, (int) value, state, cond.mirror(), trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">398                         return;</span>
<span class="line-added">399                     }</span>
<span class="line-added">400                 }</span>
<span class="line-added">401             }</span>
<span class="line-added">402             append(new CmpBranchOp(size, asAllocatable(left), right, state, cond, trueLabel, falseLabel, trueLabelProbability));</span>
403         }
404     }
405 
406     @Override
407     public void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpLIRKind, double overflowProbability) {
408         append(new BranchOp(ConditionFlag.Overflow, overflow, noOverflow, overflowProbability));
409     }
410 
411     @Override
412     public void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
<span class="line-modified">413         if (left.getPlatformKind().getVectorLength() &gt; 1) {</span>
<span class="line-modified">414             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(left), asAllocatable(left), asAllocatable(right)));</span>
<span class="line-added">415             append(new BranchOp(Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">416         } else {</span>
<span class="line-added">417             assert ((AMD64Kind) left.getPlatformKind()).isInteger();</span>
<span class="line-added">418             OperandSize size = left.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;</span>
<span class="line-added">419             if (isJavaConstant(right) &amp;&amp; NumUtil.is32bit(asJavaConstant(right).asLong())) {</span>
<span class="line-added">420                 append(new TestConstBranchOp(size, asAllocatable(left), (int) asJavaConstant(right).asLong(), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">421             } else if (isJavaConstant(left) &amp;&amp; NumUtil.is32bit(asJavaConstant(left).asLong())) {</span>
<span class="line-added">422                 append(new TestConstBranchOp(size, asAllocatable(right), (int) asJavaConstant(left).asLong(), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">423             } else if (isAllocatableValue(right)) {</span>
<span class="line-added">424                 append(new TestBranchOp(size, asAllocatable(right), asAllocatable(left), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">425             } else {</span>
<span class="line-added">426                 append(new TestBranchOp(size, asAllocatable(left), asAllocatable(right), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">427             }</span>
<span class="line-added">428         }</span>
429     }
430 
431     @Override
432     public Variable emitConditionalMove(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue) {
433         boolean isFloatComparison = cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE;
434 
435         Condition finalCondition = cond;
436         Value finalTrueValue = trueValue;
437         Value finalFalseValue = falseValue;
438         if (isFloatComparison) {
439             // eliminate the parity check in case of a float comparison
440             Value finalLeft = left;
441             Value finalRight = right;
442             if (unorderedIsTrue != AMD64ControlFlow.trueOnUnordered(finalCondition)) {
443                 if (unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(finalCondition.mirror())) {
444                     finalCondition = finalCondition.mirror();
445                     finalLeft = right;
446                     finalRight = left;
447                 } else if (finalCondition != Condition.EQ &amp;&amp; finalCondition != Condition.NE) {
448                     // negating EQ and NE does not make any sense as we would need to negate
449                     // unorderedIsTrue as well (otherwise, we would no longer fulfill the Java
450                     // NaN semantics)
451                     assert unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(finalCondition.negate());
452                     finalCondition = finalCondition.negate();
453                     finalTrueValue = falseValue;
454                     finalFalseValue = trueValue;
455                 }
456             }
457             emitRawCompare(cmpKind, finalLeft, finalRight);
458         } else {
459             finalCondition = emitCompare(cmpKind, left, right, cond);
460         }
461 
<span class="line-modified">462         return emitCondMoveOp(finalCondition, finalTrueValue, finalFalseValue, isFloatComparison, unorderedIsTrue);</span>
<span class="line-modified">463     }</span>
<span class="line-modified">464 </span>
<span class="line-added">465     private Variable emitCondMoveOp(Condition condition, Value trueValue, Value falseValue, boolean isFloatComparison, boolean unorderedIsTrue) {</span>
<span class="line-added">466         boolean isParityCheckNecessary = isFloatComparison &amp;&amp; unorderedIsTrue != AMD64ControlFlow.trueOnUnordered(condition);</span>
<span class="line-added">467         Variable result = newVariable(trueValue.getValueKind());</span>
<span class="line-added">468         if (!isParityCheckNecessary &amp;&amp; isIntConstant(trueValue, 1) &amp;&amp; isIntConstant(falseValue, 0)) {</span>
469             if (isFloatComparison) {
<span class="line-modified">470                 append(new FloatCondSetOp(result, condition));</span>
471             } else {
<span class="line-modified">472                 append(new CondSetOp(result, condition));</span>
473             }
<span class="line-modified">474         } else if (!isParityCheckNecessary &amp;&amp; isIntConstant(trueValue, 0) &amp;&amp; isIntConstant(falseValue, 1)) {</span>
475             if (isFloatComparison) {
<span class="line-modified">476                 if (unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(condition.negate())) {</span>
<span class="line-modified">477                     append(new FloatCondSetOp(result, condition.negate()));</span>
478                 } else {
<span class="line-modified">479                     append(new FloatCondSetOp(result, condition));</span>
480                     Variable negatedResult = newVariable(result.getValueKind());
481                     append(new AMD64Binary.ConstOp(AMD64BinaryArithmetic.XOR, OperandSize.get(result.getPlatformKind()), negatedResult, result, 1));
482                     result = negatedResult;
483                 }
484             } else {
<span class="line-modified">485                 append(new CondSetOp(result, condition.negate()));</span>
486             }
487         } else if (isFloatComparison) {
<span class="line-modified">488             append(new FloatCondMoveOp(result, condition, unorderedIsTrue, load(trueValue), load(falseValue)));</span>
489         } else {
<span class="line-modified">490             append(new CondMoveOp(result, condition, load(trueValue), loadNonConst(falseValue)));</span>
491         }
492         return result;
493     }
494 
495     @Override
496     public Variable emitIntegerTestMove(Value left, Value right, Value trueValue, Value falseValue) {
497         emitIntegerTest(left, right);
<span class="line-modified">498         return emitCondMoveOp(Condition.EQ, load(trueValue), loadNonConst(falseValue), false, false);</span>


499     }
500 
501     protected static AVXSize getRegisterSize(Value a) {
502         AMD64Kind kind = (AMD64Kind) a.getPlatformKind();
503         if (kind.isXMM()) {
504             return AVXKind.getRegisterSize(kind);
505         } else {
506             return AVXSize.XMM;
507         }
508     }
509 
510     private void emitIntegerTest(Value a, Value b) {
511         if (a.getPlatformKind().getVectorLength() &gt; 1) {
512             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(a), asAllocatable(a), asAllocatable(b)));
513         } else {
514             assert ((AMD64Kind) a.getPlatformKind()).isInteger();
515             OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;
516             if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {
517                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));
518             } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {
519                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));
520             } else if (isAllocatableValue(b)) {
521                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));
522             } else {
523                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));
524             }
525         }
526     }
527 

































































528     /**
529      * This method emits the compare instruction, and may reorder the operands. It returns true if
530      * it did so.
531      *
532      * @param a the left operand of the comparison
533      * @param b the right operand of the comparison
534      * @param cond the condition of the comparison
535      * @return true if the left and right operands were switched, false otherwise
536      */
537     private Condition emitCompare(PlatformKind cmpKind, Value a, Value b, Condition cond) {
538         if (LIRValueUtil.isVariable(b)) {
539             emitRawCompare(cmpKind, b, a);
540             return cond.mirror();
541         } else {
542             emitRawCompare(cmpKind, a, b);
543             return cond;
544         }
545     }
546 
547     private void emitRawCompare(PlatformKind cmpKind, Value left, Value right) {
</pre>
<hr />
<pre>
566         } else {
567             append(new AMD64Call.DirectNearForeignCallOp(linkage, result, arguments, temps, info));
568         }
569     }
570 
571     @Override
572     public Variable emitByteSwap(Value input) {
573         Variable result = newVariable(LIRKind.combine(input));
574         append(new AMD64ByteSwapOp(result, input));
575         return result;
576     }
577 
578     @Override
579     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
580         LIRKind resultKind = LIRKind.value(AMD64Kind.DWORD);
581         RegisterValue raxRes = AMD64.rax.asValue(resultKind);
582         RegisterValue cnt1 = AMD64.rcx.asValue(length1.getValueKind());
583         RegisterValue cnt2 = AMD64.rdx.asValue(length2.getValueKind());
584         emitMove(cnt1, length1);
585         emitMove(cnt2, length2);
<span class="line-modified">586         append(new AMD64ArrayCompareToOp(this, getAVX3Threshold(), kind1, kind2, raxRes, array1, array2, cnt1, cnt2));</span>
587         Variable result = newVariable(resultKind);
588         emitMove(result, raxRes);
589         return result;
590     }
591 
592     @Override
593     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {
594         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
595         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, length, directPointers, getMaxVectorSize()));
596         return result;
597     }
598 
599     @Override
600     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {
601         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
602         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, length, directPointers, getMaxVectorSize()));
603         return result;
604     }
605 
606     /**
607      * Return the maximum size of vector registers used in SSE/AVX instructions.
608      */
609     protected int getMaxVectorSize() {
610         // default for &quot;unlimited&quot;
611         return -1;
612     }
613 
<span class="line-added">614     /**</span>
<span class="line-added">615      * Return the minimal array size for using AVX3 instructions.</span>
<span class="line-added">616      */</span>
<span class="line-added">617     protected int getAVX3Threshold() {</span>
<span class="line-added">618         return 4096;</span>
<span class="line-added">619     }</span>
<span class="line-added">620 </span>
621     @Override
622     public Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value fromIndex, Value... searchValues) {
623         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
624         append(new AMD64ArrayIndexOfOp(arrayKind, valueKind, findTwoConsecutive, getMaxVectorSize(), this, result,
625                         asAllocatable(arrayPointer), asAllocatable(arrayLength), asAllocatable(fromIndex), searchValues));
626         return result;
627     }
628 
629     @Override
630     public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
631         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
632         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
633         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
634 
635         emitMove(rsrc, src);
636         emitMove(rdst, dst);
637         emitMove(rlen, len);
638 
<span class="line-modified">639         append(new AMD64StringLatin1InflateOp(this, getAVX3Threshold(), rsrc, rdst, rlen));</span>
640     }
641 
642     @Override
643     public Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
644         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
645         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
646         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
647 
648         emitMove(rsrc, src);
649         emitMove(rdst, dst);
650         emitMove(rlen, len);
651 
652         LIRKind reskind = LIRKind.value(AMD64Kind.DWORD);
653         RegisterValue rres = AMD64.rax.asValue(reskind);
654 
<span class="line-modified">655         append(new AMD64StringUTF16CompressOp(this, getAVX3Threshold(), rres, rsrc, rdst, rlen));</span>
656 
657         Variable res = newVariable(reskind);
658         emitMove(res, rres);
659         return res;
660     }
661 
662     @Override
663     public void emitReturn(JavaKind kind, Value input) {
664         AllocatableValue operand = Value.ILLEGAL;
665         if (input != null) {
666             operand = resultOperandFor(kind, input.getValueKind());
667             emitMove(operand, input);
668         }
669         append(new ReturnOp(operand));
670     }
671 
672     protected StrategySwitchOp createStrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, AllocatableValue temp) {
673         return new StrategySwitchOp(strategy, keyTargets, defaultTarget, key, temp);
674     }
675 
</pre>
</td>
</tr>
</table>
<center><a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
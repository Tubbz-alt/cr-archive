<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64Assembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 package org.graalvm.compiler.asm.aarch64;
  27 
  28 import static jdk.vm.ci.aarch64.AArch64.CPU;
  29 import static jdk.vm.ci.aarch64.AArch64.SIMD;
  30 import static jdk.vm.ci.aarch64.AArch64.cpuRegisters;
  31 import static jdk.vm.ci.aarch64.AArch64.r0;
  32 import static jdk.vm.ci.aarch64.AArch64.sp;
  33 import static jdk.vm.ci.aarch64.AArch64.zr;
  34 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADD;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDS;
  36 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDV;
  37 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADR;
  38 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADRP;
  39 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.AND;
  40 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ANDS;
  41 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ASRV;
  42 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BFM;
  43 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BIC;
  44 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BICS;
  45 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BLR;
  46 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BR;
  47 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BRK;
  48 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CAS;
  49 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CCMP;
  50 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLREX;
  51 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLS;
  52 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLZ;
  53 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CNT;
  54 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSEL;
  55 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSINC;
  56 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSNEG;
  57 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DC;
  58 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DMB;
  59 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EON;
  60 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EOR;
  61 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EXTR;
  62 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FABS;
  63 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FADD;
  64 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCCMP;
  65 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMP;
  66 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMPZERO;
  67 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCSEL;
  68 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTDS;
  69 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTSD;
  70 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTZS;
  71 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FDIV;
  72 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMADD;
  73 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMOV;
  74 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMSUB;
  75 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMUL;
  76 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FNEG;
  77 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTM;
  78 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTN;
  79 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTP;
  80 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTZ;
  81 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSQRT;
  82 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSUB;
  83 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HINT;
  84 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HLT;
<a name="2" id="anc2"></a>
  85 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDADD;
  86 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAR;
  87 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAXR;
  88 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;
  89 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDR;
  90 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDRS;
  91 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDXR;
  92 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSLV;
  93 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSRV;
  94 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MADD;
  95 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVK;
  96 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVN;
  97 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVZ;
  98 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MRS;
  99 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MSUB;
 100 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORN;
 101 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORR;
 102 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RBIT;
 103 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RET;
 104 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVW;
 105 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVX;
 106 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RORV;
 107 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SBFM;
 108 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SCVTF;
 109 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SDIV;
 110 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLR;
 111 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLXR;
 112 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;
 113 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STR;
 114 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STXR;
 115 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUB;
 116 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUBS;
 117 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SWP;
 118 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBNZ;
 119 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBZ;
 120 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UBFM;
 121 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UDIV;
 122 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UMOV;
 123 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP32;
 124 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP64;
 125 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General32;
 126 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General64;
 127 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.floatFromSize;
 128 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.generalFromSize;
 129 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.simdFromSize;
 130 
 131 import java.util.Arrays;
 132 
 133 import org.graalvm.compiler.asm.Assembler;
 134 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
 135 import org.graalvm.compiler.core.common.NumUtil;
 136 import org.graalvm.compiler.debug.GraalError;
 137 
 138 import jdk.vm.ci.aarch64.AArch64;
 139 import jdk.vm.ci.aarch64.AArch64.CPUFeature;
 140 import jdk.vm.ci.aarch64.AArch64.Flag;
 141 import jdk.vm.ci.code.Register;
 142 import jdk.vm.ci.code.TargetDescription;
 143 
 144 public abstract class AArch64Assembler extends Assembler {
 145 
 146     public static class LogicalImmediateTable {
 147 
 148         private static final Immediate[] IMMEDIATE_TABLE = buildImmediateTable();
 149 
 150         private static final int ImmediateOffset = 10;
 151         private static final int ImmediateRotateOffset = 16;
 152         private static final int ImmediateSizeOffset = 22;
 153 
 154         /**
 155          * Specifies whether immediate can be represented in all cases (YES), as a 64bit instruction
 156          * (SIXTY_FOUR_BIT_ONLY) or not at all (NO).
 157          */
 158         enum Representable {
 159             YES,
 160             SIXTY_FOUR_BIT_ONLY,
 161             NO
 162         }
 163 
 164         /**
 165          * Tests whether an immediate can be encoded for logical instructions.
 166          *
 167          * @param is64bit if true immediate is considered a 64-bit pattern. If false we may use a
 168          *            64-bit instruction to load the 32-bit pattern into a register.
 169          * @return enum specifying whether immediate can be used for 32- and 64-bit logical
 170          *         instructions ({@code #Representable.YES}), for 64-bit instructions only (
 171          *         {@link Representable#SIXTY_FOUR_BIT_ONLY}) or not at all (
 172          *         {@link Representable#NO}).
 173          */
 174         public static Representable isRepresentable(boolean is64bit, long immediate) {
 175             int pos = getLogicalImmTablePos(is64bit, immediate);
 176             if (pos &lt; 0) {
 177                 // if 32bit instruction we can try again as 64bit immediate which may succeed.
 178                 // i.e. 0xffffffff fails as a 32bit immediate but works as 64bit one.
 179                 if (!is64bit) {
 180                     assert NumUtil.isUnsignedNbit(32, immediate);
 181                     pos = getLogicalImmTablePos(true, immediate);
 182                     return pos &gt;= 0 ? Representable.SIXTY_FOUR_BIT_ONLY : Representable.NO;
 183                 }
 184                 return Representable.NO;
 185             }
 186             Immediate imm = IMMEDIATE_TABLE[pos];
 187             return imm.only64bit() ? Representable.SIXTY_FOUR_BIT_ONLY : Representable.YES;
 188         }
 189 
 190         public static Representable isRepresentable(int immediate) {
 191             return isRepresentable(false, immediate &amp; 0xFFFF_FFFFL);
 192         }
 193 
 194         public static int getLogicalImmEncoding(boolean is64bit, long value) {
 195             int pos = getLogicalImmTablePos(is64bit, value);
 196             assert pos &gt;= 0 : &quot;Value cannot be represented as logical immediate: &quot; + value + &quot;, is64bit=&quot; + is64bit;
 197             Immediate imm = IMMEDIATE_TABLE[pos];
 198             assert is64bit || !imm.only64bit() : &quot;Immediate can only be represented for 64bit, but 32bit instruction specified&quot;;
 199             return IMMEDIATE_TABLE[pos].encoding;
 200         }
 201 
 202         /**
 203          * @param is64bit if true also allow 64-bit only encodings to be returned.
 204          * @return If positive the return value is the position into the IMMEDIATE_TABLE for the
 205          *         given immediate, if negative the immediate cannot be encoded.
 206          */
 207         private static int getLogicalImmTablePos(boolean is64bit, long value) {
 208             Immediate imm;
 209             if (!is64bit) {
 210                 // 32bit instructions can only have 32bit immediates.
 211                 if (!NumUtil.isUnsignedNbit(32, value)) {
 212                     return -1;
 213                 }
 214                 // If we have a 32bit instruction (and therefore immediate) we have to duplicate it
 215                 // across 64bit to find it in the table.
 216                 imm = new Immediate(value &lt;&lt; 32 | value);
 217             } else {
 218                 imm = new Immediate(value);
 219             }
 220             int pos = Arrays.binarySearch(IMMEDIATE_TABLE, imm);
 221             if (pos &lt; 0) {
 222                 return -1;
 223             }
 224             if (!is64bit &amp;&amp; IMMEDIATE_TABLE[pos].only64bit()) {
 225                 return -1;
 226             }
 227             return pos;
 228         }
 229 
 230         /**
 231          * To quote 5.4.2: [..] an immediate is a 32 or 64 bit pattern viewed as a vector of
 232          * identical elements of size e = 2, 4, 8, 16, 32 or (in the case of bimm64) 64 bits. Each
 233          * element contains the same sub-pattern: a single run of 1 to e-1 non-zero bits, rotated by
 234          * 0 to e-1 bits. It is encoded in the following: 10-16: rotation amount (6bit) starting
 235          * from 1s in the LSB (i.e. 0111-&gt;1011-&gt;1101-&gt;1110) 16-22: This stores a combination of the
 236          * number of set bits and the pattern size. The pattern size is encoded as follows (x is
 237          * used to store the number of 1 bits - 1) e pattern 2 1111xx 4 1110xx 8 110xxx 16 10xxxx 32
 238          * 0xxxxx 64 xxxxxx 22: if set we have an instruction with 64bit pattern?
 239          */
 240         private static final class Immediate implements Comparable&lt;Immediate&gt; {
 241             public final long imm;
 242             public final int encoding;
 243 
 244             Immediate(long imm, boolean is64, int s, int r) {
 245                 this.imm = imm;
 246                 this.encoding = computeEncoding(is64, s, r);
 247             }
 248 
 249             // Used to be able to binary search for an immediate in the table.
 250             Immediate(long imm) {
 251                 this(imm, false, 0, 0);
 252             }
 253 
 254             /**
 255              * Returns true if this pattern is only representable as 64bit.
 256              */
 257             public boolean only64bit() {
 258                 return (encoding &amp; (1 &lt;&lt; ImmediateSizeOffset)) != 0;
 259             }
 260 
 261             private static int computeEncoding(boolean is64, int s, int r) {
 262                 int sf = is64 ? 1 : 0;
 263                 return sf &lt;&lt; ImmediateSizeOffset | r &lt;&lt; ImmediateRotateOffset | s &lt;&lt; ImmediateOffset;
 264             }
 265 
 266             @Override
 267             public int compareTo(Immediate o) {
 268                 return Long.compare(imm, o.imm);
 269             }
 270         }
 271 
 272         private static Immediate[] buildImmediateTable() {
 273             final int nrImmediates = 5334;
 274             final Immediate[] table = new Immediate[nrImmediates];
 275             int nrImms = 0;
 276             for (int logE = 1; logE &lt;= 6; logE++) {
 277                 int e = 1 &lt;&lt; logE;
 278                 long mask = NumUtil.getNbitNumberLong(e);
 279                 for (int nrOnes = 1; nrOnes &lt; e; nrOnes++) {
 280                     long val = (1L &lt;&lt; nrOnes) - 1;
 281                     // r specifies how much we rotate the value
 282                     for (int r = 0; r &lt; e; r++) {
 283                         long immediate = (val &gt;&gt;&gt; r | val &lt;&lt; (e - r)) &amp; mask;
 284                         // Duplicate pattern to fill whole 64bit range.
 285                         switch (logE) {
 286                             case 1:
 287                                 immediate |= immediate &lt;&lt; 2;
 288                                 immediate |= immediate &lt;&lt; 4;
 289                                 immediate |= immediate &lt;&lt; 8;
 290                                 immediate |= immediate &lt;&lt; 16;
 291                                 immediate |= immediate &lt;&lt; 32;
 292                                 break;
 293                             case 2:
 294                                 immediate |= immediate &lt;&lt; 4;
 295                                 immediate |= immediate &lt;&lt; 8;
 296                                 immediate |= immediate &lt;&lt; 16;
 297                                 immediate |= immediate &lt;&lt; 32;
 298                                 break;
 299                             case 3:
 300                                 immediate |= immediate &lt;&lt; 8;
 301                                 immediate |= immediate &lt;&lt; 16;
 302                                 immediate |= immediate &lt;&lt; 32;
 303                                 break;
 304                             case 4:
 305                                 immediate |= immediate &lt;&lt; 16;
 306                                 immediate |= immediate &lt;&lt; 32;
 307                                 break;
 308                             case 5:
 309                                 immediate |= immediate &lt;&lt; 32;
 310                                 break;
 311                         }
 312                         // 5 - logE can underflow to -1, but we shift this bogus result
 313                         // out of the masked area.
 314                         int sizeEncoding = (1 &lt;&lt; (5 - logE)) - 1;
 315                         int s = ((sizeEncoding &lt;&lt; (logE + 1)) &amp; 0x3f) | (nrOnes - 1);
 316                         table[nrImms++] = new Immediate(immediate, /* is64bit */e == 64, s, r);
 317                     }
 318                 }
 319             }
 320             Arrays.sort(table);
 321             assert nrImms == nrImmediates : nrImms + &quot; instead of &quot; + nrImmediates + &quot; in table.&quot;;
 322             assert checkDuplicates(table) : &quot;Duplicate values in table.&quot;;
 323             return table;
 324         }
 325 
 326         private static boolean checkDuplicates(Immediate[] table) {
 327             for (int i = 0; i &lt; table.length - 1; i++) {
 328                 if (table[i].imm &gt;= table[i + 1].imm) {
 329                     return false;
 330                 }
 331             }
 332             return true;
 333         }
 334     }
 335 
 336     private static final int RdOffset = 0;
 337     private static final int Rs1Offset = 5;
 338     private static final int Rs2Offset = 16;
 339     private static final int Rs3Offset = 10;
 340     private static final int RtOffset = 0;
 341     private static final int RnOffset = 5;
 342     private static final int Rt2Offset = 10;
 343 
 344     /* Helper functions */
 345     private static int rd(Register reg) {
 346         return reg.encoding &lt;&lt; RdOffset;
 347     }
 348 
 349     private static int rs1(Register reg) {
 350         return reg.encoding &lt;&lt; Rs1Offset;
 351     }
 352 
 353     private static int rs2(Register reg) {
 354         return reg.encoding &lt;&lt; Rs2Offset;
 355     }
 356 
 357     private static int rs3(Register reg) {
 358         return reg.encoding &lt;&lt; Rs3Offset;
 359     }
 360 
 361     private static int rt(Register reg) {
 362         return reg.encoding &lt;&lt; RtOffset;
 363     }
 364 
 365     private static int rt2(Register reg) {
 366         return reg.encoding &lt;&lt; Rt2Offset;
 367     }
 368 
 369     private static int rn(Register reg) {
 370         return reg.encoding &lt;&lt; RnOffset;
 371     }
 372 
 373     private static int maskField(int sizeInBits, int n) {
 374         assert NumUtil.isSignedNbit(sizeInBits, n);
 375         return n &amp; NumUtil.getNbitNumberInt(sizeInBits);
 376     }
 377 
 378     /**
 379      * Enumeration of all different lane types of SIMD register.
 380      *
 381      * Byte(B):8b/lane; HalfWord(H):16b/lane; Word(S):32b/lane; DoubleWord(D):64b/lane.
 382      */
 383     public enum SIMDElementSize {
 384         Byte(0, 8),
 385         HalfWord(1, 16),
 386         Word(2, 32),
 387         DoubleWord(3, 64);
 388 
 389         public final int encoding;
 390         public final int nbits;
 391 
 392         SIMDElementSize(int encoding, int nbits) {
 393             this.encoding = encoding;
 394             this.nbits = nbits;
 395         }
 396     }
 397 
 398     /**
 399      * Enumeration of all different instruction kinds: General32/64 are the general instructions
 400      * (integer, branch, etc.), for 32-, respectively 64-bit operands. FP32/64 is the encoding for
 401      * the 32/64bit float operations. SIMDByte/HalfWord/Word/DoubleWord is the encoding for SIMD
 402      * instructions
 403      */
 404     protected enum InstructionType {
 405         General32(0b00 &lt;&lt; 30, 32, true),
 406         General64(0b10 &lt;&lt; 30, 64, true),
 407         FP32(0x00000000, 32, false),
 408         FP64(0x00400000, 64, false),
 409 
 410         SIMDByte(0x01, 8, false),
 411         SIMDHalfWord(0x02, 16, false),
 412         SIMDWord(0x04, 32, false),
 413         SIMDDoubleWord(0x08, 64, false);
 414 
 415         public final int encoding;
 416         public final int width;
 417         public final boolean isGeneral;
 418 
 419         InstructionType(int encoding, int width, boolean isGeneral) {
 420             this.encoding = encoding;
 421             this.width = width;
 422             this.isGeneral = isGeneral;
 423         }
 424 
 425         public static InstructionType generalFromSize(int size) {
 426             assert size == 32 || size == 64;
 427             return size == 32 ? General32 : General64;
 428         }
 429 
 430         public static InstructionType floatFromSize(int size) {
 431             assert size == 32 || size == 64;
 432             return size == 32 ? FP32 : FP64;
 433         }
 434 
 435         public static InstructionType simdFromSize(int size) {
 436             switch (size) {
 437                 case 8:
 438                     return SIMDByte;
 439                 case 16:
 440                     return SIMDHalfWord;
 441                 case 32:
 442                     return SIMDWord;
 443                 case 64:
 444                     return SIMDDoubleWord;
 445                 default:
 446                     throw GraalError.shouldNotReachHere();
 447             }
 448         }
 449     }
 450 
 451     private static final int ImmediateOffset = 10;
 452     private static final int ImmediateRotateOffset = 16;
 453     private static final int ImmediateSizeOffset = 22;
 454     private static final int ExtendTypeOffset = 13;
 455 
 456     private static final int AddSubImmOp = 0x11000000;
 457     private static final int AddSubShift12 = 0b01 &lt;&lt; 22;
 458     private static final int AddSubSetFlag = 0x20000000;
 459 
 460     private static final int LogicalImmOp = 0x12000000;
 461 
 462     private static final int MoveWideImmOp = 0x12800000;
 463     private static final int MoveWideImmOffset = 5;
 464     private static final int MoveWideShiftOffset = 21;
 465 
 466     private static final int BitfieldImmOp = 0x13000000;
 467 
 468     private static final int AddSubShiftedOp = 0x0B000000;
 469     private static final int ShiftTypeOffset = 22;
 470 
 471     private static final int AddSubExtendedOp = 0x0B200000;
 472 
 473     private static final int MulOp = 0x1B000000;
 474     private static final int SignedMulLongOp = 0x9B200000;
 475     private static final int DataProcessing1SourceOp = 0x5AC00000;
 476     private static final int DataProcessing2SourceOp = 0x1AC00000;
 477 
 478     private static final int Fp1SourceOp = 0x1E204000;
 479     private static final int Fp2SourceOp = 0x1E200800;
 480     private static final int Fp3SourceOp = 0x1F000000;
 481 
 482     private static final int FpConvertOp = 0x1E200000;
 483     private static final int FpImmOp = 0x1E201000;
 484     private static final int FpImmOffset = 13;
 485 
 486     private static final int FpCmpOp = 0x1E202000;
 487     private static final int FpCmpeOp = 0x1E202010;
 488 
 489     private static final int PcRelImmHiOffset = 5;
 490     private static final int PcRelImmLoOffset = 29;
 491 
 492     private static final int PcRelImmOp = 0x10000000;
 493 
 494     private static final int UnconditionalBranchImmOp = 0x14000000;
 495     private static final int UnconditionalBranchRegOp = 0xD6000000;
 496     private static final int CompareBranchOp = 0x34000000;
 497 
 498     private static final int ConditionalBranchImmOffset = 5;
 499 
 500     private static final int ConditionalSelectOp = 0x1A800000;
 501     private static final int ConditionalConditionOffset = 12;
 502 
 503     private static final int LoadStoreScaledOp = 0b111_0_01_00 &lt;&lt; 22;
 504     private static final int LoadStoreUnscaledOp = 0b111_0_00_00 &lt;&lt; 22;
 505 
 506     private static final int LoadStoreRegisterOp = 0b111_0_00_00_1 &lt;&lt; 21 | 0b10 &lt;&lt; 10;
 507 
 508     private static final int LoadLiteralOp = 0x18000000;
 509 
 510     private static final int LoadStorePostIndexedOp = 0b111_0_00_00_0 &lt;&lt; 21 | 0b01 &lt;&lt; 10;
 511     private static final int LoadStorePreIndexedOp = 0b111_0_00_00_0 &lt;&lt; 21 | 0b11 &lt;&lt; 10;
 512 
 513     private static final int LoadStoreUnscaledImmOffset = 12;
 514     private static final int LoadStoreScaledImmOffset = 10;
 515     private static final int LoadStoreScaledRegOffset = 12;
 516     private static final int LoadStoreIndexedImmOffset = 12;
 517     private static final int LoadStoreTransferSizeOffset = 30;
 518     private static final int LoadStoreFpFlagOffset = 26;
 519     private static final int LoadLiteralImmeOffset = 5;
 520 
 521     private static final int LoadStorePairOp = 0b101_0 &lt;&lt; 26;
 522     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPostIndexOp = 0b101_0_001 &lt;&lt; 23;
 523     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPreIndexOp = 0b101_0_011 &lt;&lt; 23;
 524     private static final int LoadStorePairImm7Offset = 15;
 525 
 526     private static final int LogicalShiftOp = 0x0A000000;
 527 
 528     private static final int ExceptionOp = 0xD4000000;
 529     private static final int SystemImmediateOffset = 5;
 530 
 531     @SuppressWarnings(&quot;unused&quot;) private static final int SimdImmediateOffset = 16;
 532 
 533     private static final int BarrierOp = 0xD503301F;
 534     private static final int BarrierKindOffset = 8;
 535 
 536     private static final int CASAcquireOffset = 22;
 537     private static final int CASReleaseOffset = 15;
 538 
 539     private static final int LDADDAcquireOffset = 23;
 540     private static final int LDADDReleaseOffset = 22;
 541 
 542     private static final int SIMDImm5Offset = 16;
 543     private static final int SIMDQBitOffset = 30;
 544     private static final int SIMDSizeOffset = 22;
 545 
 546     /**
 547      * Encoding for all instructions.
 548      */
 549     public enum Instruction {
 550         BCOND(0x54000000),
 551         CBNZ(0x01000000),
 552         CBZ(0x00000000),
 553         TBZ(0x36000000),
 554         TBNZ(0x37000000),
 555 
 556         B(0x00000000),
 557         BL(0x80000000),
 558         BR(0x001F0000),
 559         BLR(0x003F0000),
 560         RET(0x005F0000),
 561 
 562         LDR(0x00000000),
 563         LDRS(0x00800000),
 564         LDXR(0x081f7c00),
 565         LDAR(0x8dffc00),
 566         LDAXR(0x85ffc00),
 567 
 568         STR(0x00000000),
 569         STXR(0x08007c00),
 570         STLR(0x089ffc00),
 571         STLXR(0x0800fc00),
 572 
 573         LDP(0b1 &lt;&lt; 22),
 574         STP(0b0 &lt;&lt; 22),
 575 
 576         CAS(0x08A07C00),
 577         LDADD(0x38200000),
 578         SWP(0x38208000),
 579 
 580         ADR(0x00000000),
 581         ADRP(0x80000000),
 582 
 583         ADD(0x00000000),
 584         ADDS(ADD.encoding | AddSubSetFlag),
 585         SUB(0x40000000),
 586         SUBS(SUB.encoding | AddSubSetFlag),
 587 
 588         CCMP(0x7A400000),
 589 
 590         NOT(0x00200000),
 591         AND(0x00000000),
 592         BIC(AND.encoding | NOT.encoding),
 593         ORR(0x20000000),
 594         ORN(ORR.encoding | NOT.encoding),
 595         EOR(0x40000000),
 596         EON(EOR.encoding | NOT.encoding),
 597         ANDS(0x60000000),
 598         BICS(ANDS.encoding | NOT.encoding),
 599 
 600         ASRV(0x00002800),
 601         RORV(0x00002C00),
 602         LSRV(0x00002400),
 603         LSLV(0x00002000),
 604 
 605         CLS(0x00001400),
 606         CLZ(0x00001000),
 607         RBIT(0x00000000),
 608         REVX(0x00000C00),
 609         REVW(0x00000800),
 610 
 611         MOVN(0x00000000),
 612         MOVZ(0x40000000),
 613         MOVK(0x60000000),
 614 
 615         CSEL(0x00000000),
 616         CSNEG(0x40000400),
 617         CSINC(0x00000400),
 618 
 619         BFM(0x20000000),
 620         SBFM(0x00000000),
 621         UBFM(0x40000000),
 622         EXTR(0x13800000),
 623 
 624         MADD(0x00000000),
 625         MSUB(0x00008000),
 626         SDIV(0x00000C00),
 627         UDIV(0x00000800),
 628 
 629         FMOV(0x00000000),
 630         FMOVCPU2FPU(0x00070000),
 631         FMOVFPU2CPU(0x00060000),
 632 
 633         FCVTDS(0x00028000),
 634         FCVTSD(0x00020000),
 635 
 636         FCVTZS(0x00180000),
 637         SCVTF(0x00020000),
 638 
 639         FABS(0x00008000),
 640         FSQRT(0x00018000),
 641         FNEG(0x00010000),
 642 
 643         FRINTM(0x00050000),
 644         FRINTN(0x00040000),
 645         FRINTP(0x00048000),
 646         FRINTZ(0x00058000),
 647 
 648         FADD(0x00002000),
 649         FSUB(0x00003000),
 650         FMUL(0x00000000),
 651         FDIV(0x00001000),
 652         FMAX(0x00004000),
 653         FMIN(0x00005000),
 654 
 655         FMADD(0x00000000),
 656         FMSUB(0x00008000),
 657 
 658         FCMP(0x00000000),
 659         FCMPZERO(0x00000008),
 660         FCCMP(0x1E200400),
 661         FCSEL(0x1E200C00),
 662 
 663         INS(0x4e081c00),
 664         UMOV(0x0e003c00),
 665 
 666         CNT(0xe205800),
 667         USRA(0x6f001400),
 668 
 669         HLT(0x00400000),
 670         BRK(0x00200000),
 671 
 672         CLREX(0xd5033f5f),
 673         HINT(0xD503201F),
 674         DMB(0x000000A0),
 675 
 676         MRS(0xD5300000),
 677         MSR(0xD5100000),
 678         DC(0xD5087000),
<a name="3" id="anc3"></a>
 679 
 680         BLR_NATIVE(0xc0000000),
 681 
 682         ADDV(0x0e31b800);
 683 
 684         public final int encoding;
 685 
 686         Instruction(int encoding) {
 687             this.encoding = encoding;
 688         }
 689 
 690     }
 691 
 692     public enum SystemRegister {
 693         FPCR(0b11, 0b011, 0b0100, 0b0100, 0b000),
 694         FPSR(0b11, 0b011, 0b0100, 0b0100, 0b001);
 695 
 696         SystemRegister(int op0, int op1, int crn, int crm, int op2) {
 697             this.op0 = op0;
 698             this.op1 = op1;
 699             this.crn = crn;
 700             this.crm = crm;
 701             this.op2 = op2;
 702         }
 703 
 704         public int encoding() {
 705             return op0 &lt;&lt; 19 | op1 &lt;&lt; 16 | crn &lt;&lt; 12 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;
 706         }
 707 
 708         private final int op0;
 709         private final int op1;
 710         private final int crn;
 711         private final int crm;
 712         private final int op2;
 713     }
 714 
 715     public enum DataCacheOperationType {
 716         ZVA(0b011, 0b0100, 0b001);
 717 
 718         DataCacheOperationType(int op1, int crm, int op2) {
 719             this.op1 = op1;
 720             this.crm = crm;
 721             this.op2 = op2;
 722         }
 723 
 724         public int encoding() {
 725             return op1 &lt;&lt; 16 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;
 726         }
 727 
 728         private final int op1;
 729         private final int crm;
 730         private final int op2;
 731     }
 732 
 733     public enum ShiftType {
 734         LSL(0),
 735         LSR(1),
 736         ASR(2),
 737         ROR(3);
 738 
 739         public final int encoding;
 740 
 741         ShiftType(int encoding) {
 742             this.encoding = encoding;
 743         }
 744     }
 745 
 746     public enum ExtendType {
 747         UXTB(0),
 748         UXTH(1),
 749         UXTW(2),
 750         UXTX(3),
 751         SXTB(4),
 752         SXTH(5),
 753         SXTW(6),
 754         SXTX(7);
 755 
 756         public final int encoding;
 757 
 758         ExtendType(int encoding) {
 759             this.encoding = encoding;
 760         }
 761     }
 762 
 763     /**
 764      * Condition Flags for branches. See 4.3
 765      */
 766     public enum ConditionFlag {
 767         // Integer | Floating-point meanings
 768         /** Equal | Equal. */
 769         EQ(0x0),
 770 
 771         /** Not Equal | Not equal or unordered. */
 772         NE(0x1),
 773 
 774         /** Unsigned Higher or Same | Greater than, equal or unordered. */
 775         HS(0x2),
 776 
 777         /** Unsigned lower | less than. */
 778         LO(0x3),
 779 
 780         /** Minus (negative) | less than. */
 781         MI(0x4),
 782 
 783         /** Plus (positive or zero) | greater than, equal or unordered. */
 784         PL(0x5),
 785 
 786         /** Overflow set | unordered. */
 787         VS(0x6),
 788 
 789         /** Overflow clear | ordered. */
 790         VC(0x7),
 791 
 792         /** Unsigned higher | greater than or unordered. */
 793         HI(0x8),
 794 
 795         /** Unsigned lower or same | less than or equal. */
 796         LS(0x9),
 797 
 798         /** Signed greater than or equal | greater than or equal. */
 799         GE(0xA),
 800 
 801         /** Signed less than | less than or unordered. */
 802         LT(0xB),
 803 
 804         /** Signed greater than | greater than. */
 805         GT(0xC),
 806 
 807         /** Signed less than or equal | less than, equal or unordered. */
 808         LE(0xD),
 809 
 810         /** Always | always. */
 811         AL(0xE),
 812 
 813         /** Always | always (identical to AL, just to have valid 0b1111 encoding). */
 814         NV(0xF);
 815 
 816         public final int encoding;
 817 
 818         ConditionFlag(int encoding) {
 819             this.encoding = encoding;
 820         }
 821 
 822         /**
 823          * @return ConditionFlag specified by decoding.
 824          */
 825         public static ConditionFlag fromEncoding(int encoding) {
 826             return values()[encoding];
 827         }
 828 
 829         public ConditionFlag negate() {
 830             switch (this) {
 831                 case EQ:
 832                     return NE;
 833                 case NE:
 834                     return EQ;
 835                 case HS:
 836                     return LO;
 837                 case LO:
 838                     return HS;
 839                 case MI:
 840                     return PL;
 841                 case PL:
 842                     return MI;
 843                 case VS:
 844                     return VC;
 845                 case VC:
 846                     return VS;
 847                 case HI:
 848                     return LS;
 849                 case LS:
 850                     return HI;
 851                 case GE:
 852                     return LT;
 853                 case LT:
 854                     return GE;
 855                 case GT:
 856                     return LE;
 857                 case LE:
 858                     return GT;
 859                 case AL:
 860                 case NV:
 861                 default:
 862                     throw GraalError.shouldNotReachHere();
 863             }
 864         }
 865     }
 866 
 867     public AArch64Assembler(TargetDescription target) {
 868         super(target);
 869     }
 870 
 871     public boolean supports(CPUFeature feature) {
 872         return ((AArch64) target.arch).getFeatures().contains(feature);
 873     }
 874 
 875     public boolean isFlagSet(Flag flag) {
 876         return ((AArch64) target.arch).getFlags().contains(flag);
 877     }
 878 
 879     /* Conditional Branch (5.2.1) */
 880 
 881     /**
 882      * Branch conditionally.
 883      *
 884      * @param condition may not be null.
 885      * @param imm21 Signed 21-bit offset, has to be word aligned.
 886      */
 887     protected void b(ConditionFlag condition, int imm21) {
 888         b(condition, imm21, -1);
 889     }
 890 
 891     /**
 892      * Branch conditionally. Inserts instruction into code buffer at pos.
 893      *
 894      * @param condition may not be null.
 895      * @param imm21 Signed 21-bit offset, has to be word aligned.
 896      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 897      */
 898     protected void b(ConditionFlag condition, int imm21, int pos) {
 899         if (pos == -1) {
 900             emitInt(Instruction.BCOND.encoding | getConditionalBranchImm(imm21) | condition.encoding);
 901         } else {
 902             emitInt(Instruction.BCOND.encoding | getConditionalBranchImm(imm21) | condition.encoding, pos);
 903         }
 904     }
 905 
 906     /**
 907      * Compare register and branch if non-zero.
 908      *
 909      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 910      * @param size Instruction size in bits. Should be either 32 or 64.
 911      * @param imm21 Signed 21-bit offset, has to be word aligned.
 912      */
 913     protected void cbnz(int size, Register reg, int imm21) {
 914         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBNZ, -1);
 915     }
 916 
 917     /**
 918      * Compare register and branch if non-zero.
 919      *
 920      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 921      * @param size Instruction size in bits. Should be either 32 or 64.
 922      * @param imm21 Signed 21-bit offset, has to be word aligned.
 923      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 924      */
 925     protected void cbnz(int size, Register reg, int imm21, int pos) {
 926         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBNZ, pos);
 927     }
 928 
 929     /**
 930      * Compare and branch if zero.
 931      *
 932      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 933      * @param size Instruction size in bits. Should be either 32 or 64.
 934      * @param imm21 Signed 21-bit offset, has to be word aligned.
 935      */
 936     protected void cbz(int size, Register reg, int imm21) {
 937         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBZ, -1);
 938     }
 939 
 940     /**
 941      * Compare register and branch if zero.
 942      *
 943      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 944      * @param size Instruction size in bits. Should be either 32 or 64.
 945      * @param imm21 Signed 21-bit offset, has to be word aligned.
 946      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 947      */
 948     protected void cbz(int size, Register reg, int imm21, int pos) {
 949         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBZ, pos);
 950     }
 951 
 952     /**
 953      * Test a single bit and branch if the bit is nonzero.
 954      *
 955      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 956      * @param uimm6 Unsigned 6-bit bit index.
 957      * @param imm16 signed 16 bit offset
 958      */
 959     protected void tbnz(Register reg, int uimm6, int imm16) {
 960         tbnz(reg, uimm6, imm16, -1);
 961     }
 962 
 963     /**
 964      * Test a single bit and branch if the bit is zero.
 965      *
 966      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 967      * @param uimm6 Unsigned 6-bit bit index.
 968      * @param imm16 signed 16 bit offset
 969      */
 970     protected void tbz(Register reg, int uimm6, int imm16) {
 971         tbz(reg, uimm6, imm16, -1);
 972     }
 973 
 974     /**
 975      * Test a single bit and branch if the bit is nonzero.
 976      *
 977      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 978      * @param uimm6 Unsigned 6-bit bit index.
 979      * @param imm16 signed 16 bit offset
 980      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 981      */
 982     protected void tbnz(Register reg, int uimm6, int imm16, int pos) {
 983         assert reg.getRegisterCategory().equals(CPU);
 984         assert NumUtil.isUnsignedNbit(6, uimm6);
 985         assert NumUtil.isSignedNbit(16, imm16) : String.format(&quot;Offset value must fit in 16 bits signed: 0x%x&quot;, imm16);
 986         assert (imm16 &amp; 3) == 0 : String.format(&quot;Lower two bits must be zero: 0x%x&quot;, imm16 &amp; 3);
 987         // size bit is overloaded as top bit of uimm6 bit index
 988         int size = (((uimm6 &gt;&gt; 5) &amp; 1) == 0 ? 32 : 64);
 989         // remaining 5 bits are encoded lower down
 990         int uimm5 = uimm6 &amp; 0x1F;
 991         int imm14 = (imm16 &amp; NumUtil.getNbitNumberInt(16)) &gt;&gt; 2;
 992         InstructionType type = generalFromSize(size);
 993         int encoding = type.encoding | TBNZ.encoding | (uimm5 &lt;&lt; 19) | (imm14 &lt;&lt; 5) | rd(reg);
 994         if (pos == -1) {
 995             emitInt(encoding);
 996         } else {
 997             emitInt(encoding, pos);
 998         }
 999     }
1000 
1001     /**
1002      * Test a single bit and branch if the bit is zero.
1003      *
1004      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1005      * @param uimm6 Unsigned 6-bit bit index.
1006      * @param imm16 signed 16 bit offset
1007      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
1008      */
1009     protected void tbz(Register reg, int uimm6, int imm16, int pos) {
1010         assert reg.getRegisterCategory().equals(CPU);
1011         assert NumUtil.isUnsignedNbit(6, uimm6);
1012         assert NumUtil.isSignedNbit(16, imm16) : String.format(&quot;Offset value must fit in 16 bits signed: 0x%x&quot;, imm16);
1013         assert (imm16 &amp; 3) == 0 : String.format(&quot;Lower two bits must be zero: 0x%x&quot;, imm16 &amp; 3);
1014         // size bit is overloaded as top bit of uimm6 bit index
1015         int size = (((uimm6 &gt;&gt; 5) &amp; 1) == 0 ? 32 : 64);
1016         // remaining 5 bits are encoded lower down
1017         int uimm5 = uimm6 &amp; 0x1F;
1018         int imm14 = (imm16 &amp; NumUtil.getNbitNumberInt(16)) &gt;&gt; 2;
1019         InstructionType type = generalFromSize(size);
1020         int encoding = type.encoding | TBZ.encoding | (uimm5 &lt;&lt; 19) | (imm14 &lt;&lt; 5) | rd(reg);
1021         if (pos == -1) {
1022             emitInt(encoding);
1023         } else {
1024             emitInt(encoding, pos);
1025         }
1026     }
1027 
1028     private void conditionalBranchInstruction(Register reg, int imm21, InstructionType type, Instruction instr, int pos) {
1029         assert reg.getRegisterCategory().equals(CPU);
1030         int instrEncoding = instr.encoding | CompareBranchOp;
1031         if (pos == -1) {
1032             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg));
1033         } else {
1034             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg), pos);
1035         }
1036     }
1037 
1038     private static int getConditionalBranchImm(int imm21) {
1039         assert NumUtil.isSignedNbit(21, imm21) &amp;&amp; (imm21 &amp; 0x3) == 0 : String.format(&quot;Immediate has to be 21bit signed number and word aligned got value 0x%x&quot;, imm21);
1040         int imm = (imm21 &amp; NumUtil.getNbitNumberInt(21)) &gt;&gt; 2;
1041         return imm &lt;&lt; ConditionalBranchImmOffset;
1042     }
1043 
1044     /* Unconditional Branch (immediate) (5.2.2) */
1045 
1046     /**
1047      * @param imm28 Signed 28-bit offset, has to be word aligned.
1048      */
1049     protected void b(int imm28) {
1050         unconditionalBranchImmInstruction(imm28, Instruction.B, -1);
1051     }
1052 
1053     /**
1054      *
1055      * @param imm28 Signed 28-bit offset, has to be word aligned.
1056      * @param pos Position where instruction is inserted into code buffer.
1057      */
1058     protected void b(int imm28, int pos) {
1059         unconditionalBranchImmInstruction(imm28, Instruction.B, pos);
1060     }
1061 
1062     /**
1063      * Branch and link return address to register X30.
1064      *
1065      * @param imm28 Signed 28-bit offset, has to be word aligned.
1066      */
1067     public void bl(int imm28) {
1068         unconditionalBranchImmInstruction(imm28, Instruction.BL, -1);
1069     }
1070 
1071     private void unconditionalBranchImmInstruction(int imm28, Instruction instr, int pos) {
1072         assert NumUtil.isSignedNbit(28, imm28) &amp;&amp; (imm28 &amp; 0x3) == 0 : &quot;Immediate has to be 28bit signed number and word aligned&quot;;
1073         int imm = (imm28 &amp; NumUtil.getNbitNumberInt(28)) &gt;&gt; 2;
1074         int instrEncoding = instr.encoding | UnconditionalBranchImmOp;
1075         if (pos == -1) {
1076             annotatePatchingImmediate(position(), instr, 26, 0, 2);
1077             emitInt(instrEncoding | imm);
1078         } else {
1079             annotatePatchingImmediate(pos, instr, 26, 0, 2);
1080             emitInt(instrEncoding | imm, pos);
1081         }
1082     }
1083 
1084     /* Unconditional Branch (register) (5.2.3) */
1085 
1086     /**
1087      * Branches to address in register and writes return address into register X30.
1088      *
1089      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1090      */
1091     public void blr(Register reg) {
1092         unconditionalBranchRegInstruction(BLR, reg);
1093     }
1094 
1095     /**
1096      * Branches to address in register.
1097      *
1098      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1099      */
1100     protected void br(Register reg) {
1101         unconditionalBranchRegInstruction(BR, reg);
1102     }
1103 
1104     /**
1105      * Return to address in register.
1106      *
1107      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1108      */
1109     public void ret(Register reg) {
1110         unconditionalBranchRegInstruction(RET, reg);
1111     }
1112 
1113     private void unconditionalBranchRegInstruction(Instruction instr, Register reg) {
1114         assert reg.getRegisterCategory().equals(CPU);
1115         assert !reg.equals(zr);
1116         assert !reg.equals(sp);
1117         emitInt(instr.encoding | UnconditionalBranchRegOp | rs1(reg));
1118 
1119     }
1120 
1121     /* Load-Store Single Register (5.3.1) */
1122 
1123     /**
1124      * Loads a srcSize value from address into rt zero-extending it.
1125      *
1126      * @param srcSize size of memory read in bits. Must be 8, 16, 32 or 64.
1127      * @param rt general purpose register. May not be null or stackpointer.
1128      * @param address all addressing modes allowed. May not be null.
1129      */
1130     public void ldr(int srcSize, Register rt, AArch64Address address) {
1131         assert rt.getRegisterCategory().equals(CPU);
1132         assert srcSize == 8 || srcSize == 16 || srcSize == 32 || srcSize == 64;
1133         int transferSize = NumUtil.log2Ceil(srcSize / 8);
1134         loadStoreInstruction(LDR, rt, address, General32, transferSize);
1135     }
1136 
1137     /**
1138      * Loads a srcSize value from address into rt sign-extending it.
1139      *
1140      * @param targetSize size of target register in bits. Must be 32 or 64.
1141      * @param srcSize size of memory read in bits. Must be 8, 16 or 32, but may not be equivalent to
1142      *            targetSize.
1143      * @param rt general purpose register. May not be null or stackpointer.
1144      * @param address all addressing modes allowed. May not be null.
1145      */
1146     protected void ldrs(int targetSize, int srcSize, Register rt, AArch64Address address) {
1147         assert rt.getRegisterCategory().equals(CPU);
1148         assert (srcSize == 8 || srcSize == 16 || srcSize == 32) &amp;&amp; srcSize != targetSize;
1149         int transferSize = NumUtil.log2Ceil(srcSize / 8);
1150         loadStoreInstruction(LDRS, rt, address, generalFromSize(targetSize), transferSize);
1151     }
1152 
1153     public enum PrefetchMode {
1154         PLDL1KEEP(0b00000),
1155         PLDL1STRM(0b00001),
1156         PLDL2KEEP(0b00010),
1157         PLDL2STRM(0b00011),
1158         PLDL3KEEP(0b00100),
1159         PLDL3STRM(0b00101),
1160 
1161         PLIL1KEEP(0b01000),
1162         PLIL1STRM(0b01001),
1163         PLIL2KEEP(0b01010),
1164         PLIL2STRM(0b01011),
1165         PLIL3KEEP(0b01100),
1166         PLIL3STRM(0b01101),
1167 
1168         PSTL1KEEP(0b10000),
1169         PSTL1STRM(0b10001),
1170         PSTL2KEEP(0b10010),
1171         PSTL2STRM(0b10011),
1172         PSTL3KEEP(0b10100),
1173         PSTL3STRM(0b10101);
1174 
1175         private final int encoding;
1176 
1177         PrefetchMode(int encoding) {
1178             this.encoding = encoding;
1179         }
1180 
1181         private static PrefetchMode[] modes = {
1182                         PLDL1KEEP,
1183                         PLDL1STRM,
1184                         PLDL2KEEP,
1185                         PLDL2STRM,
1186                         PLDL3KEEP,
1187                         PLDL3STRM,
1188 
1189                         null,
1190                         null,
1191 
1192                         PLIL1KEEP,
1193                         PLIL1STRM,
1194                         PLIL2KEEP,
1195                         PLIL2STRM,
1196                         PLIL3KEEP,
1197                         PLIL3STRM,
1198 
1199                         null,
1200                         null,
1201 
1202                         PSTL1KEEP,
1203                         PSTL1STRM,
1204                         PSTL2KEEP,
1205                         PSTL2STRM,
1206                         PSTL3KEEP,
1207                         PSTL3STRM
1208         };
1209 
1210         public static PrefetchMode lookup(int enc) {
1211             assert enc &gt;= 00 &amp;&amp; enc &lt; modes.length;
1212             return modes[enc];
1213         }
1214 
1215         public Register toRegister() {
1216             return cpuRegisters.get(encoding);
1217         }
1218     }
1219 
1220     /*
1221      * implements a prefetch at a 64-bit aligned address using a scaled 12 bit or unscaled 9 bit
1222      * displacement addressing mode
1223      *
1224      * @param rt general purpose register. May not be null, zr or stackpointer.
1225      *
1226      * @param address only displacement addressing modes allowed. May not be null.
1227      */
1228     public void prfm(AArch64Address address, PrefetchMode mode) {
1229         assert (address.getAddressingMode() == AddressingMode.IMMEDIATE_SCALED ||
1230                         address.getAddressingMode() == AddressingMode.IMMEDIATE_UNSCALED ||
1231                         address.getAddressingMode() == AddressingMode.REGISTER_OFFSET);
1232         assert mode != null;
1233         final int srcSize = 64;
1234         final int transferSize = NumUtil.log2Ceil(srcSize / 8);
1235         final Register rt = mode.toRegister();
1236         // this looks weird but that&#39;s because loadStoreInstruction is weird
1237         // instruction select fields are size [31:30], v [26] and opc [25:24]
1238         // prfm requires size == 0b11, v == 0b0 and opc == 0b11
1239         // passing LDRS ensures opc[1] == 0b1
1240         // (n.b. passing LDR/STR makes no difference to opc[1:0]!!)
1241         // passing General64 ensures opc[0] == 0b1 and v = 0b0
1242         // (n.b. passing General32 ensures opc[0] == 0b0 and v = 0b0)
1243         // srcSize 64 ensures size == 0b11
1244         loadStoreInstruction(LDRS, rt, address, General64, transferSize);
1245     }
1246 
1247     /**
1248      * Stores register rt into memory pointed by address.
1249      *
1250      * @param destSize number of bits written to memory. Must be 8, 16, 32 or 64.
1251      * @param rt general purpose register. May not be null or stackpointer.
1252      * @param address all addressing modes allowed. May not be null.
1253      */
1254     public void str(int destSize, Register rt, AArch64Address address) {
1255         assert rt.getRegisterCategory().equals(CPU) : rt;
1256         assert destSize == 8 || destSize == 16 || destSize == 32 || destSize == 64;
1257         int transferSize = NumUtil.log2Ceil(destSize / 8);
1258         loadStoreInstruction(STR, rt, address, General64, transferSize);
1259     }
1260 
1261     private void loadStoreInstruction(Instruction instr, Register reg, AArch64Address address, InstructionType type, int log2TransferSize) {
1262         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1263         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1264         int is32Bit = type.width == 32 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1265         int isFloat = !type.isGeneral ? 1 &lt;&lt; LoadStoreFpFlagOffset : 0;
1266         int memop = instr.encoding | transferSizeEncoding | is32Bit | isFloat | rt(reg);
1267         switch (address.getAddressingMode()) {
1268             case IMMEDIATE_SCALED:
1269                 annotatePatchingImmediate(position(), instr, 12, LoadStoreScaledImmOffset, log2TransferSize);
1270                 emitInt(memop | LoadStoreScaledOp | address.getImmediate() &lt;&lt; LoadStoreScaledImmOffset | rs1(address.getBase()));
1271                 break;
1272             case IMMEDIATE_UNSCALED:
1273                 annotatePatchingImmediate(position(), instr, 9, LoadStoreUnscaledImmOffset, 0);
1274                 emitInt(memop | LoadStoreUnscaledOp | address.getImmediate() &lt;&lt; LoadStoreUnscaledImmOffset | rs1(address.getBase()));
1275                 break;
1276             case BASE_REGISTER_ONLY:
1277                 emitInt(memop | LoadStoreScaledOp | rs1(address.getBase()));
1278                 break;
1279             case EXTENDED_REGISTER_OFFSET:
1280             case REGISTER_OFFSET:
1281                 ExtendType extendType = address.getAddressingMode() == AddressingMode.EXTENDED_REGISTER_OFFSET ? address.getExtendType() : ExtendType.UXTX;
1282                 boolean shouldScale = address.isScaled() &amp;&amp; log2TransferSize != 0;
1283                 emitInt(memop | LoadStoreRegisterOp | rs2(address.getOffset()) | extendType.encoding &lt;&lt; ExtendTypeOffset | (shouldScale ? 1 : 0) &lt;&lt; LoadStoreScaledRegOffset | rs1(address.getBase()));
1284                 break;
1285             case PC_LITERAL:
1286                 assert log2TransferSize &gt;= 2 : &quot;PC literal loads only works for load/stores of 32-bit and larger&quot;;
1287                 transferSizeEncoding = (log2TransferSize - 2) &lt;&lt; LoadStoreTransferSizeOffset;
1288                 annotatePatchingImmediate(position(), instr, 21, LoadLiteralImmeOffset, 2);
1289                 emitInt(transferSizeEncoding | isFloat | LoadLiteralOp | rd(reg) | address.getImmediate() &lt;&lt; LoadLiteralImmeOffset);
1290                 break;
1291             case IMMEDIATE_POST_INDEXED:
1292                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);
1293                 emitInt(memop | LoadStorePostIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1294                 break;
1295             case IMMEDIATE_PRE_INDEXED:
1296                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);
1297                 emitInt(memop | LoadStorePreIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1298                 break;
1299             default:
1300                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1301         }
1302     }
1303 
1304     /**
1305      * Insert ldp/stp at the specified position.
1306      */
1307     protected void insertLdpStp(int size, Instruction instr, Register rt, Register rt2, Register base, int offset, int position) {
1308         InstructionType type = generalFromSize(size);
1309         int scaledOffset = maskField(7, offset);
1310         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(base) | rt(rt);
1311         emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23), position);
1312     }
1313 
1314     /**
1315      * Load Pair of Registers calculates an address from a base register value and an immediate
1316      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1317      * two registers.
1318      */
1319     public void ldp(int size, Register rt, Register rt2, AArch64Address address) {
1320         assert size == 32 || size == 64;
1321         loadStorePairInstruction(size, LDP, rt, rt2, address);
1322     }
1323 
1324     /**
1325      * Store Pair of Registers calculates an address from a base register value and an immediate
1326      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1327      * two registers.
1328      */
1329     public void stp(int size, Register rt, Register rt2, AArch64Address address) {
1330         assert size == 32 || size == 64;
1331         loadStorePairInstruction(size, STP, rt, rt2, address);
1332     }
1333 
1334     private void loadStorePairInstruction(int size, Instruction instr, Register rt, Register rt2, AArch64Address address) {
1335         InstructionType type = generalFromSize(size);
1336         // LDP/STP uses a 7-bit scaled offset
1337         int offset = address.getImmediateRaw();
1338         if (address.getAddressingMode() == AddressingMode.IMMEDIATE_UNSCALED) {
1339             int sizeInBytes = size / Byte.SIZE;
1340             long mask = sizeInBytes - 1;
1341             assert (offset &amp; mask) == 0 : &quot;LDP/STP only supports aligned offset.&quot;;
1342             offset = offset / sizeInBytes;
1343         }
1344         int scaledOffset = maskField(7, offset);
1345         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(address.getBase()) | rt(rt);
1346         switch (address.getAddressingMode()) {
1347             case IMMEDIATE_SCALED:
1348             case IMMEDIATE_UNSCALED:
1349                 emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23));
1350                 break;
1351             case IMMEDIATE_POST_INDEXED:
1352                 emitInt(memop | LoadStorePairOp | (0b001 &lt;&lt; 23));
1353                 break;
1354             case IMMEDIATE_PRE_INDEXED:
1355                 emitInt(memop | LoadStorePairOp | (0b011 &lt;&lt; 23));
1356                 break;
1357             default:
1358                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1359         }
1360     }
1361 
1362     /* Load-Store Exclusive (5.3.6) */
1363 
1364     /**
1365      * Load address exclusive. Natural alignment of address is required.
1366      *
1367      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1368      * @param rt general purpose register. May not be null or stackpointer.
1369      * @param rn general purpose register.
1370      */
1371     protected void ldxr(int size, Register rt, Register rn) {
1372         assert size == 8 || size == 16 || size == 32 || size == 64;
1373         int transferSize = NumUtil.log2Ceil(size / 8);
1374         exclusiveLoadInstruction(LDXR, rt, rn, transferSize);
1375     }
1376 
1377     /**
1378      * Store address exclusive. Natural alignment of address is required. rs and rt may not point to
1379      * the same register.
1380      *
1381      * @param size size of bits written to memory. Must be 8, 16, 32 or 64.
1382      * @param rs general purpose register. Set to exclusive access status. 0 means success,
1383      *            everything else failure. May not be null, or stackpointer.
1384      * @param rt general purpose register. May not be null or stackpointer.
1385      * @param rn general purpose register.
1386      */
1387     protected void stxr(int size, Register rs, Register rt, Register rn) {
1388         assert size == 8 || size == 16 || size == 32 || size == 64;
1389         int transferSize = NumUtil.log2Ceil(size / 8);
1390         exclusiveStoreInstruction(STXR, rs, rt, rn, transferSize);
1391     }
1392 
1393     /* Load-Acquire/Store-Release (5.3.7) */
1394 
1395     /* non exclusive access */
1396     /**
1397      * Load acquire. Natural alignment of address is required.
1398      *
1399      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1400      * @param rt general purpose register. May not be null or stackpointer.
1401      * @param rn general purpose register.
1402      */
1403     protected void ldar(int size, Register rt, Register rn) {
1404         assert size == 8 || size == 16 || size == 32 || size == 64;
1405         int transferSize = NumUtil.log2Ceil(size / 8);
1406         exclusiveLoadInstruction(LDAR, rt, rn, transferSize);
1407     }
1408 
1409     /**
1410      * Store-release. Natural alignment of address is required.
1411      *
1412      * @param size size of bits written to memory. Must be 8, 16, 32 or 64.
1413      * @param rt general purpose register. May not be null or stackpointer.
1414      * @param rn general purpose register.
1415      */
1416     protected void stlr(int size, Register rt, Register rn) {
1417         assert size == 8 || size == 16 || size == 32 || size == 64;
1418         int transferSize = NumUtil.log2Ceil(size / 8);
1419         // Hack: Passing the zero-register means it is ignored when building the encoding.
1420         exclusiveStoreInstruction(STLR, r0, rt, rn, transferSize);
1421     }
1422 
1423     /* exclusive access */
1424     /**
1425      * Load acquire exclusive. Natural alignment of address is required.
1426      *
1427      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1428      * @param rt general purpose register. May not be null or stackpointer.
1429      * @param rn general purpose register.
1430      */
1431     public void ldaxr(int size, Register rt, Register rn) {
1432         assert size == 8 || size == 16 || size == 32 || size == 64;
1433         int transferSize = NumUtil.log2Ceil(size / 8);
1434         exclusiveLoadInstruction(LDAXR, rt, rn, transferSize);
1435     }
1436 
1437     /**
1438      * Store-release exclusive. Natural alignment of address is required. rs and rt may not point to
1439      * the same register.
1440      *
1441      * @param size size of bits written to memory. Must be 8, 16, 32 or 64.
1442      * @param rs general purpose register. Set to exclusive access status. 0 means success,
1443      *            everything else failure. May not be null, or stackpointer.
1444      * @param rt general purpose register. May not be null or stackpointer.
1445      * @param rn general purpose register.
1446      */
1447     public void stlxr(int size, Register rs, Register rt, Register rn) {
1448         assert size == 8 || size == 16 || size == 32 || size == 64;
1449         int transferSize = NumUtil.log2Ceil(size / 8);
1450         exclusiveStoreInstruction(STLXR, rs, rt, rn, transferSize);
1451     }
1452 
1453     private void exclusiveLoadInstruction(Instruction instr, Register reg, Register rn, int log2TransferSize) {
1454         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1455         assert reg.getRegisterCategory().equals(CPU);
1456         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1457         emitInt(transferSizeEncoding | instr.encoding | 1 &lt;&lt; ImmediateSizeOffset | rn(rn) | rt(reg));
1458     }
1459 
1460     /**
1461      * Stores data from rt into address and sets rs to the returned exclusive access status.
1462      *
1463      * @param rs general purpose register into which the exclusive access status is written. May not
1464      *            be null.
1465      * @param rt general purpose register containing data to be written to memory at address. May
1466      *            not be null
1467      * @param rn general purpose register containing the address specifying where rt is written to.
1468      * @param log2TransferSize log2Ceil of memory transfer size.
1469      */
1470     private void exclusiveStoreInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize) {
1471         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1472         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1473         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1474         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt));
1475     }
1476 
1477     /**
1478      * Compare And Swap word or doubleword in memory. This reads a value from an address rn,
1479      * compares it against a given value rs, and, if equal, stores the value rt to memory. The value
1480      * read from address rn is stored in register rs.
1481      *
1482      * @param size size of bits read from memory. Must be 32 or 64.
1483      * @param rs general purpose register to be compared and loaded. May not be null.
1484      * @param rt general purpose register to be conditionally stored. May not be null.
1485      * @param rn general purpose register containing the address from which to read.
1486      * @param acquire boolean value signifying if the load should use acquire semantics.
1487      * @param release boolean value signifying if the store should use release semantics.
1488      */
1489     public void cas(int size, Register rs, Register rt, Register rn, boolean acquire, boolean release) {
1490         assert size == 32 || size == 64;
1491         int transferSize = NumUtil.log2Ceil(size / 8);
1492         compareAndSwapInstruction(CAS, rs, rt, rn, transferSize, acquire, release);
1493     }
1494 
1495     private void compareAndSwapInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize, boolean acquire, boolean release) {
1496         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1497         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1498         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1499         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt) | (acquire ? 1 : 0) &lt;&lt; CASAcquireOffset | (release ? 1 : 0) &lt;&lt; CASReleaseOffset);
1500     }
1501 
1502     /**
1503      * Atomic add. This reads a value from an address rn, stores the value in rt, and adds the value
1504      * in rs to it, and stores the result back at address rn. The initial value read from memory is
1505      * stored in rt.
1506      *
1507      * @param size size of operand to read from memory. Must be 8, 16, 32, or 64.
1508      * @param rs general purpose register to be added to contents. May not be null.
1509      * @param rt general purpose register to be loaded. May not be null.
1510      * @param rn general purpose register or stack pointer holding an address from which to load.
1511      * @param acquire boolean value signifying if the load should use acquire semantics.
1512      * @param release boolean value signifying if the store should use release semantics.
1513      */
1514     public void ldadd(int size, Register rs, Register rt, Register rn, boolean acquire, boolean release) {
1515         assert size == 8 || size == 16 || size == 32 || size == 64;
1516         int transferSize = NumUtil.log2Ceil(size / 8);
1517         loadAndAddInstruction(LDADD, rs, rt, rn, transferSize, acquire, release);
1518     }
1519 
1520     private void loadAndAddInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize, boolean acquire, boolean release) {
1521         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1522         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1523         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1524         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt) | (acquire ? 1 : 0) &lt;&lt; LDADDAcquireOffset | (release ? 1 : 0) &lt;&lt; LDADDReleaseOffset);
1525     }
1526 
1527     /**
1528      * Atomic swap. This reads a value from an address rn, stores the value in rt, and then stores
1529      * the value in rs back at address rn.
1530      *
1531      * @param size size of operand to read from memory. Must be 8, 16, 32, or 64.
1532      * @param rs general purpose register to be stored. May not be null.
1533      * @param rt general purpose register to be loaded. May not be null.
1534      * @param rn general purpose register or stack pointer holding an address from which to load.
1535      * @param acquire boolean value signifying if the load should use acquire semantics.
1536      * @param release boolean value signifying if the store should use release semantics.
1537      */
1538     public void swp(int size, Register rs, Register rt, Register rn, boolean acquire, boolean release) {
1539         assert size == 8 || size == 16 || size == 32 || size == 64;
1540         int transferSize = NumUtil.log2Ceil(size / 8);
1541         swapInstruction(SWP, rs, rt, rn, transferSize, acquire, release);
1542     }
1543 
1544     private void swapInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize, boolean acquire, boolean release) {
1545         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1546         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1547         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1548         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt) | (acquire ? 1 : 0) &lt;&lt; LDADDAcquireOffset | (release ? 1 : 0) &lt;&lt; LDADDReleaseOffset);
1549     }
1550 
1551     /* PC-relative Address Calculation (5.4.4) */
1552 
1553     /**
1554      * Address of page: sign extends 21-bit offset, shifts if left by 12 and adds it to the value of
1555      * the PC with its bottom 12-bits cleared, writing the result to dst. No offset is emitted; the
1556      * instruction will be patched later.
1557      *
1558      * @param dst general purpose register. May not be null, zero-register or stackpointer.
1559      */
1560     public void adrp(Register dst) {
1561         emitInt(ADRP.encoding | PcRelImmOp | rd(dst));
1562     }
1563 
1564     /**
1565      * Adds a 21-bit signed offset to the program counter and writes the result to dst.
1566      *
1567      * @param dst general purpose register. May not be null, zero-register or stackpointer.
1568      * @param imm21 Signed 21-bit offset.
1569      */
1570     public void adr(Register dst, int imm21) {
1571         emitInt(ADR.encoding | PcRelImmOp | rd(dst) | getPcRelativeImmEncoding(imm21));
1572     }
1573 
1574     /**
1575      * Adds a 21-bit signed offset to the program counter and writes the result to dst.
1576      *
1577      * @param dst general purpose register. May not be null, zero-register or stackpointer.
1578      * @param imm21 Signed 21-bit offset.
1579      * @param pos the position in the code that the instruction is emitted.
1580      */
1581     public void adr(Register dst, int imm21, int pos) {
1582         emitInt(ADR.encoding | PcRelImmOp | rd(dst) | getPcRelativeImmEncoding(imm21), pos);
1583     }
1584 
1585     private static int getPcRelativeImmEncoding(int imm21) {
1586         assert NumUtil.isSignedNbit(21, imm21);
1587         int imm = imm21 &amp; NumUtil.getNbitNumberInt(21);
1588         // higher 19 bit
1589         int immHi = (imm &gt;&gt; 2) &lt;&lt; PcRelImmHiOffset;
1590         // lower 2 bit
1591         int immLo = (imm &amp; 0x3) &lt;&lt; PcRelImmLoOffset;
1592         return immHi | immLo;
1593     }
1594 
1595     /* Arithmetic (Immediate) (5.4.1) */
1596 
1597     /**
1598      * dst = src + aimm.
1599      *
1600      * @param size register size. Has to be 32 or 64.
1601      * @param dst general purpose register. May not be null or zero-register.
1602      * @param src general purpose register. May not be null or zero-register.
1603      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1604      *            the lower 12-bit cleared.
1605      */
1606     protected void add(int size, Register dst, Register src, int aimm) {
1607         assert !dst.equals(zr);
1608         assert !src.equals(zr);
1609         addSubImmInstruction(ADD, dst, src, aimm, generalFromSize(size));
1610     }
1611 
1612     /**
1613      * dst = src + aimm and sets condition flags.
1614      *
1615      * @param size register size. Has to be 32 or 64.
1616      * @param dst general purpose register. May not be null or stackpointer.
1617      * @param src general purpose register. May not be null or zero-register.
1618      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1619      *            the lower 12-bit cleared.
1620      */
1621     protected void adds(int size, Register dst, Register src, int aimm) {
1622         assert !dst.equals(sp);
1623         assert !src.equals(zr);
1624         addSubImmInstruction(ADDS, dst, src, aimm, generalFromSize(size));
1625     }
1626 
1627     /**
1628      * dst = src - aimm.
1629      *
1630      * @param size register size. Has to be 32 or 64.
1631      * @param dst general purpose register. May not be null or zero-register.
1632      * @param src general purpose register. May not be null or zero-register.
1633      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1634      *            the lower 12-bit cleared.
1635      */
1636     protected void sub(int size, Register dst, Register src, int aimm) {
1637         assert !dst.equals(zr);
1638         assert !src.equals(zr);
1639         addSubImmInstruction(SUB, dst, src, aimm, generalFromSize(size));
1640     }
1641 
1642     /**
1643      * dst = src - aimm and sets condition flags.
1644      *
1645      * @param size register size. Has to be 32 or 64.
1646      * @param dst general purpose register. May not be null or stackpointer.
1647      * @param src general purpose register. May not be null or zero-register.
1648      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1649      *            the lower 12-bit cleared.
1650      */
1651     protected void subs(int size, Register dst, Register src, int aimm) {
1652         assert !dst.equals(sp);
1653         assert !src.equals(zr);
1654         addSubImmInstruction(SUBS, dst, src, aimm, generalFromSize(size));
1655     }
1656 
1657     private void addSubImmInstruction(Instruction instr, Register dst, Register src, int aimm, InstructionType type) {
1658         emitInt(type.encoding | instr.encoding | AddSubImmOp | encodeAimm(aimm) | rd(dst) | rs1(src));
1659     }
1660 
1661     public void ccmp(int size, Register x, Register y, int aimm, ConditionFlag condition) {
1662         emitInt(generalFromSize(size).encoding | CCMP.encoding | rs1(x) | rs2(y) | encodeAimm(aimm) | condition.encoding &lt;&lt; ConditionalConditionOffset);
1663     }
1664 
1665     /**
1666      * Encodes arithmetic immediate.
1667      *
1668      * @param imm Immediate has to be either an unsigned 12-bit value or an unsigned 24-bit value
1669      *            with the lower 12 bits zero.
1670      * @return Representation of immediate for use with arithmetic instructions.
1671      */
1672     private static int encodeAimm(int imm) {
1673         assert isAimm(imm) : &quot;Immediate has to be legal arithmetic immediate value &quot; + imm;
1674         if (NumUtil.isUnsignedNbit(12, imm)) {
1675             return imm &lt;&lt; ImmediateOffset;
1676         } else {
1677             // First 12-bit are zero, so shift immediate 12-bit and set flag to indicate
1678             // shifted immediate value.
1679             return (imm &gt;&gt;&gt; 12 &lt;&lt; ImmediateOffset) | AddSubShift12;
1680         }
1681     }
1682 
1683     /**
1684      * Checks whether immediate can be encoded as an arithmetic immediate.
1685      *
1686      * @param imm Immediate has to be either an unsigned 12bit value or un unsigned 24bit value with
1687      *            the lower 12 bits 0.
1688      * @return true if valid arithmetic immediate, false otherwise.
1689      */
1690     protected static boolean isAimm(int imm) {
1691         return NumUtil.isUnsignedNbit(12, imm) || NumUtil.isUnsignedNbit(12, imm &gt;&gt;&gt; 12) &amp;&amp; (imm &amp; 0xfff) == 0;
1692     }
1693 
1694     /* Logical (immediate) (5.4.2) */
1695 
1696     /**
1697      * dst = src &amp; bimm.
1698      *
1699      * @param size register size. Has to be 32 or 64.
1700      * @param dst general purpose register. May not be null or zero-register.
1701      * @param src general purpose register. May not be null or stack-pointer.
1702      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1703      */
1704     public void and(int size, Register dst, Register src, long bimm) {
1705         assert !dst.equals(zr);
1706         assert !src.equals(sp);
1707         logicalImmInstruction(AND, dst, src, bimm, generalFromSize(size));
1708     }
1709 
1710     /**
1711      * dst = src &amp; bimm and sets condition flags.
1712      *
1713      * @param size register size. Has to be 32 or 64.
1714      * @param dst general purpose register. May not be null or stack-pointer.
1715      * @param src general purpose register. May not be null or stack-pointer.
1716      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1717      */
1718     public void ands(int size, Register dst, Register src, long bimm) {
1719         assert !dst.equals(sp);
1720         assert !src.equals(sp);
1721         logicalImmInstruction(ANDS, dst, src, bimm, generalFromSize(size));
1722     }
1723 
1724     /**
1725      * dst = src ^ bimm.
1726      *
1727      * @param size register size. Has to be 32 or 64.
1728      * @param dst general purpose register. May not be null or zero-register.
1729      * @param src general purpose register. May not be null or stack-pointer.
1730      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1731      */
1732     public void eor(int size, Register dst, Register src, long bimm) {
1733         assert !dst.equals(zr);
1734         assert !src.equals(sp);
1735         logicalImmInstruction(EOR, dst, src, bimm, generalFromSize(size));
1736     }
1737 
1738     /**
1739      * dst = src | bimm.
1740      *
1741      * @param size register size. Has to be 32 or 64.
1742      * @param dst general purpose register. May not be null or zero-register.
1743      * @param src general purpose register. May not be null or stack-pointer.
1744      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1745      */
1746     protected void orr(int size, Register dst, Register src, long bimm) {
1747         assert !dst.equals(zr);
1748         assert !src.equals(sp);
1749         logicalImmInstruction(ORR, dst, src, bimm, generalFromSize(size));
1750     }
1751 
1752     private void logicalImmInstruction(Instruction instr, Register dst, Register src, long bimm, InstructionType type) {
1753         // Mask higher bits off, since we always pass longs around even for the 32-bit instruction.
1754         long bimmValue;
1755         if (type == General32) {
1756             assert (bimm &gt;&gt; 32) == 0 || (bimm &gt;&gt; 32) == -1L : &quot;Higher order bits for 32-bit instruction must either all be 0 or 1.&quot;;
1757             bimmValue = bimm &amp; NumUtil.getNbitNumberLong(32);
1758         } else {
1759             bimmValue = bimm;
1760         }
1761         int immEncoding = LogicalImmediateTable.getLogicalImmEncoding(type == General64, bimmValue);
1762         emitInt(type.encoding | instr.encoding | LogicalImmOp | immEncoding | rd(dst) | rs1(src));
1763     }
1764 
1765     /* Move (wide immediate) (5.4.3) */
1766 
1767     /**
1768      * dst = uimm16 &lt;&lt; shiftAmt.
1769      *
1770      * @param size register size. Has to be 32 or 64.
1771      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1772      * @param uimm16 16-bit unsigned immediate
1773      * @param shiftAmt amount by which uimm16 is left shifted. Can be any multiple of 16 smaller
1774      *            than size.
1775      */
1776     protected void movz(int size, Register dst, int uimm16, int shiftAmt) {
1777         moveWideImmInstruction(MOVZ, dst, uimm16, shiftAmt, generalFromSize(size));
1778     }
1779 
1780     /**
1781      * dst = ~(uimm16 &lt;&lt; shiftAmt).
1782      *
1783      * @param size register size. Has to be 32 or 64.
1784      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1785      * @param uimm16 16-bit unsigned immediate
1786      * @param shiftAmt amount by which uimm16 is left shifted. Can be any multiple of 16 smaller
1787      *            than size.
1788      */
1789     protected void movn(int size, Register dst, int uimm16, int shiftAmt) {
1790         moveWideImmInstruction(MOVN, dst, uimm16, shiftAmt, generalFromSize(size));
1791     }
1792 
1793     /**
1794      * dst&lt;pos+15:pos&gt; = uimm16.
1795      *
1796      * @param size register size. Has to be 32 or 64.
1797      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1798      * @param uimm16 16-bit unsigned immediate
1799      * @param pos position into which uimm16 is inserted. Can be any multiple of 16 smaller than
1800      *            size.
1801      */
1802     protected void movk(int size, Register dst, int uimm16, int pos) {
1803         moveWideImmInstruction(MOVK, dst, uimm16, pos, generalFromSize(size));
1804     }
1805 
1806     private void moveWideImmInstruction(Instruction instr, Register dst, int uimm16, int shiftAmt, InstructionType type) {
1807         assert dst.getRegisterCategory().equals(CPU);
1808         assert NumUtil.isUnsignedNbit(16, uimm16) : &quot;Immediate has to be unsigned 16bit&quot;;
1809         assert shiftAmt == 0 || shiftAmt == 16 || (type == InstructionType.General64 &amp;&amp; (shiftAmt == 32 || shiftAmt == 48)) : &quot;Invalid shift amount: &quot; + shiftAmt;
1810         int shiftValue = shiftAmt &gt;&gt; 4;
1811         emitInt(type.encoding | instr.encoding | MoveWideImmOp | rd(dst) | uimm16 &lt;&lt; MoveWideImmOffset | shiftValue &lt;&lt; MoveWideShiftOffset);
1812     }
1813 
1814     /* Bitfield Operations (5.4.5) */
1815 
1816     /**
1817      * Bitfield move.
1818      *
1819      * @param size register size. Has to be 32 or 64.
1820      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1821      * @param src general purpose register. May not be null, stackpointer or zero-register.
1822      * @param r must be in the range 0 to size - 1
1823      * @param s must be in the range 0 to size - 1
1824      */
1825     public void bfm(int size, Register dst, Register src, int r, int s) {
1826         bitfieldInstruction(BFM, dst, src, r, s, generalFromSize(size));
1827     }
1828 
1829     /**
1830      * Unsigned bitfield move.
1831      *
1832      * @param size register size. Has to be 32 or 64.
1833      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1834      * @param src general purpose register. May not be null, stackpointer or zero-register.
1835      * @param r must be in the range 0 to size - 1
1836      * @param s must be in the range 0 to size - 1
1837      */
1838     public void ubfm(int size, Register dst, Register src, int r, int s) {
1839         bitfieldInstruction(UBFM, dst, src, r, s, generalFromSize(size));
1840     }
1841 
1842     /**
1843      * Signed bitfield move.
1844      *
1845      * @param size register size. Has to be 32 or 64.
1846      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1847      * @param src general purpose register. May not be null, stackpointer or zero-register.
1848      * @param r must be in the range 0 to size - 1
1849      * @param s must be in the range 0 to size - 1
1850      */
1851     protected void sbfm(int size, Register dst, Register src, int r, int s) {
1852         bitfieldInstruction(SBFM, dst, src, r, s, generalFromSize(size));
1853     }
1854 
1855     private void bitfieldInstruction(Instruction instr, Register dst, Register src, int r, int s, InstructionType type) {
1856         assert !dst.equals(sp) &amp;&amp; !dst.equals(zr);
1857         assert !src.equals(sp) &amp;&amp; !src.equals(zr);
1858         assert s &gt;= 0 &amp;&amp; s &lt; type.width &amp;&amp; r &gt;= 0 &amp;&amp; r &lt; type.width;
1859         int sf = type == General64 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1860         emitInt(type.encoding | instr.encoding | BitfieldImmOp | sf | r &lt;&lt; ImmediateRotateOffset | s &lt;&lt; ImmediateOffset | rd(dst) | rs1(src));
1861     }
1862 
1863     /* Extract (Immediate) (5.4.6) */
1864 
1865     /**
1866      * Extract. dst = src1:src2&lt;lsb+31:lsb&gt;
1867      *
1868      * @param size register size. Has to be 32 or 64.
1869      * @param dst general purpose register. May not be null or stackpointer.
1870      * @param src1 general purpose register. May not be null or stackpointer.
1871      * @param src2 general purpose register. May not be null or stackpointer.
1872      * @param lsb must be in range 0 to size - 1.
1873      */
1874     protected void extr(int size, Register dst, Register src1, Register src2, int lsb) {
1875         assert !dst.equals(sp);
1876         assert !src1.equals(sp);
1877         assert !src2.equals(sp);
1878         InstructionType type = generalFromSize(size);
1879         assert lsb &gt;= 0 &amp;&amp; lsb &lt; type.width;
1880         int sf = type == General64 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1881         emitInt(type.encoding | EXTR.encoding | sf | lsb &lt;&lt; ImmediateOffset | rd(dst) | rs1(src1) | rs2(src2));
1882     }
1883 
1884     /* Arithmetic (shifted register) (5.5.1) */
1885 
1886     /**
1887      * dst = src1 + shiftType(src2, imm).
1888      *
1889      * @param size register size. Has to be 32 or 64.
1890      * @param dst general purpose register. May not be null or stackpointer.
1891      * @param src1 general purpose register. May not be null or stackpointer.
1892      * @param src2 general purpose register. May not be null or stackpointer.
1893      * @param shiftType any type but ROR.
1894      * @param imm must be in range 0 to size - 1.
1895      */
1896     protected void add(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1897         addSubShiftedInstruction(ADD, dst, src1, src2, shiftType, imm, generalFromSize(size));
1898     }
1899 
1900     /**
1901      * dst = src1 + shiftType(src2, imm) and sets condition flags.
1902      *
1903      * @param size register size. Has to be 32 or 64.
1904      * @param dst general purpose register. May not be null or stackpointer.
1905      * @param src1 general purpose register. May not be null or stackpointer.
1906      * @param src2 general purpose register. May not be null or stackpointer.
1907      * @param shiftType any type but ROR.
1908      * @param imm must be in range 0 to size - 1.
1909      */
1910     public void adds(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1911         addSubShiftedInstruction(ADDS, dst, src1, src2, shiftType, imm, generalFromSize(size));
1912     }
1913 
1914     /**
1915      * dst = src1 - shiftType(src2, imm).
1916      *
1917      * @param size register size. Has to be 32 or 64.
1918      * @param dst general purpose register. May not be null or stackpointer.
1919      * @param src1 general purpose register. May not be null or stackpointer.
1920      * @param src2 general purpose register. May not be null or stackpointer.
1921      * @param shiftType any type but ROR.
1922      * @param imm must be in range 0 to size - 1.
1923      */
1924     protected void sub(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1925         addSubShiftedInstruction(SUB, dst, src1, src2, shiftType, imm, generalFromSize(size));
1926     }
1927 
1928     /**
1929      * dst = src1 - shiftType(src2, imm) and sets condition flags.
1930      *
1931      * @param size register size. Has to be 32 or 64.
1932      * @param dst general purpose register. May not be null or stackpointer.
1933      * @param src1 general purpose register. May not be null or stackpointer.
1934      * @param src2 general purpose register. May not be null or stackpointer.
1935      * @param shiftType any type but ROR.
1936      * @param imm must be in range 0 to size - 1.
1937      */
1938     public void subs(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1939         addSubShiftedInstruction(SUBS, dst, src1, src2, shiftType, imm, generalFromSize(size));
1940     }
1941 
1942     private void addSubShiftedInstruction(Instruction instr, Register dst, Register src1, Register src2, ShiftType shiftType, int imm, InstructionType type) {
1943         assert shiftType != ShiftType.ROR;
1944         assert imm &gt;= 0 &amp;&amp; imm &lt; type.width;
1945         emitInt(type.encoding | instr.encoding | AddSubShiftedOp | imm &lt;&lt; ImmediateOffset | shiftType.encoding &lt;&lt; ShiftTypeOffset | rd(dst) | rs1(src1) | rs2(src2));
1946     }
1947 
1948     /* Arithmetic (extended register) (5.5.2) */
1949     /**
1950      * dst = src1 + extendType(src2) &lt;&lt; imm.
1951      *
1952      * @param size register size. Has to be 32 or 64.
1953      * @param dst general purpose register. May not be null or zero-register..
1954      * @param src1 general purpose register. May not be null or zero-register.
1955      * @param src2 general purpose register. May not be null or stackpointer.
1956      * @param extendType defines how src2 is extended to the same size as src1.
1957      * @param shiftAmt must be in range 0 to 4.
1958      */
1959     public void add(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
1960         assert !dst.equals(zr);
1961         assert !src1.equals(zr);
1962         assert !src2.equals(sp);
1963         addSubExtendedInstruction(ADD, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
1964     }
1965 
1966     /**
1967      * dst = src1 + extendType(src2) &lt;&lt; imm and sets condition flags.
1968      *
1969      * @param size register size. Has to be 32 or 64.
1970      * @param dst general purpose register. May not be null or stackpointer..
1971      * @param src1 general purpose register. May not be null or zero-register.
1972      * @param src2 general purpose register. May not be null or stackpointer.
1973      * @param extendType defines how src2 is extended to the same size as src1.
1974      * @param shiftAmt must be in range 0 to 4.
1975      */
1976     protected void adds(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
1977         assert !dst.equals(sp);
1978         assert !src1.equals(zr);
1979         assert !src2.equals(sp);
1980         addSubExtendedInstruction(ADDS, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
1981     }
1982 
1983     /**
1984      * dst = src1 - extendType(src2) &lt;&lt; imm.
1985      *
1986      * @param size register size. Has to be 32 or 64.
1987      * @param dst general purpose register. May not be null or zero-register..
1988      * @param src1 general purpose register. May not be null or zero-register.
1989      * @param src2 general purpose register. May not be null or stackpointer.
1990      * @param extendType defines how src2 is extended to the same size as src1.
1991      * @param shiftAmt must be in range 0 to 4.
1992      */
1993     protected void sub(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
1994         assert !dst.equals(zr);
1995         assert !src1.equals(zr);
1996         assert !src2.equals(sp);
1997         addSubExtendedInstruction(SUB, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
1998     }
1999 
2000     /**
2001      * dst = src1 - extendType(src2) &lt;&lt; imm and sets flags.
2002      *
2003      * @param size register size. Has to be 32 or 64.
2004      * @param dst general purpose register. May not be null or stackpointer..
2005      * @param src1 general purpose register. May not be null or zero-register.
2006      * @param src2 general purpose register. May not be null or stackpointer.
2007      * @param extendType defines how src2 is extended to the same size as src1.
2008      * @param shiftAmt must be in range 0 to 4.
2009      */
2010     public void subs(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
2011         assert !dst.equals(sp);
2012         assert !src1.equals(zr);
2013         assert !src2.equals(sp);
2014         addSubExtendedInstruction(SUBS, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
2015     }
2016 
2017     private void addSubExtendedInstruction(Instruction instr, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt, InstructionType type) {
2018         assert shiftAmt &gt;= 0 &amp;&amp; shiftAmt &lt;= 4;
2019         emitInt(type.encoding | instr.encoding | AddSubExtendedOp | shiftAmt &lt;&lt; ImmediateOffset | extendType.encoding &lt;&lt; ExtendTypeOffset | rd(dst) | rs1(src1) | rs2(src2));
2020     }
2021 
2022     /* Logical (shifted register) (5.5.3) */
2023     /**
2024      * dst = src1 &amp; shiftType(src2, imm).
2025      *
2026      * @param size register size. Has to be 32 or 64.
2027      * @param dst general purpose register. May not be null or stackpointer.
2028      * @param src1 general purpose register. May not be null or stackpointer.
2029      * @param src2 general purpose register. May not be null or stackpointer.
2030      * @param shiftType all types allowed, may not be null.
2031      * @param shiftAmt must be in range 0 to size - 1.
2032      */
2033     protected void and(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2034         logicalRegInstruction(AND, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2035     }
2036 
2037     /**
2038      * dst = src1 &amp; shiftType(src2, imm) and sets condition flags.
2039      *
2040      * @param size register size. Has to be 32 or 64.
2041      * @param dst general purpose register. May not be null or stackpointer.
2042      * @param src1 general purpose register. May not be null or stackpointer.
2043      * @param src2 general purpose register. May not be null or stackpointer.
2044      * @param shiftType all types allowed, may not be null.
2045      * @param shiftAmt must be in range 0 to size - 1.
2046      */
2047     protected void ands(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2048         logicalRegInstruction(ANDS, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2049     }
2050 
2051     /**
2052      * dst = src1 &amp; ~(shiftType(src2, imm)).
2053      *
2054      * @param size register size. Has to be 32 or 64.
2055      * @param dst general purpose register. May not be null or stackpointer.
2056      * @param src1 general purpose register. May not be null or stackpointer.
2057      * @param src2 general purpose register. May not be null or stackpointer.
2058      * @param shiftType all types allowed, may not be null.
2059      * @param shiftAmt must be in range 0 to size - 1.
2060      */
2061     protected void bic(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2062         logicalRegInstruction(BIC, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2063     }
2064 
2065     /**
2066      * dst = src1 &amp; ~(shiftType(src2, imm)) and sets condition flags.
2067      *
2068      * @param size register size. Has to be 32 or 64.
2069      * @param dst general purpose register. May not be null or stackpointer.
2070      * @param src1 general purpose register. May not be null or stackpointer.
2071      * @param src2 general purpose register. May not be null or stackpointer.
2072      * @param shiftType all types allowed, may not be null.
2073      * @param shiftAmt must be in range 0 to size - 1.
2074      */
2075     protected void bics(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2076         logicalRegInstruction(BICS, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2077     }
2078 
2079     /**
2080      * dst = src1 ^ ~(shiftType(src2, imm)).
2081      *
2082      * @param size register size. Has to be 32 or 64.
2083      * @param dst general purpose register. May not be null or stackpointer.
2084      * @param src1 general purpose register. May not be null or stackpointer.
2085      * @param src2 general purpose register. May not be null or stackpointer.
2086      * @param shiftType all types allowed, may not be null.
2087      * @param shiftAmt must be in range 0 to size - 1.
2088      */
2089     protected void eon(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2090         logicalRegInstruction(EON, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2091     }
2092 
2093     /**
2094      * dst = src1 ^ shiftType(src2, imm).
2095      *
2096      * @param size register size. Has to be 32 or 64.
2097      * @param dst general purpose register. May not be null or stackpointer.
2098      * @param src1 general purpose register. May not be null or stackpointer.
2099      * @param src2 general purpose register. May not be null or stackpointer.
2100      * @param shiftType all types allowed, may not be null.
2101      * @param shiftAmt must be in range 0 to size - 1.
2102      */
2103     protected void eor(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2104         logicalRegInstruction(EOR, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2105     }
2106 
2107     /**
2108      * dst = src1 | shiftType(src2, imm).
2109      *
2110      * @param size register size. Has to be 32 or 64.
2111      * @param dst general purpose register. May not be null or stackpointer.
2112      * @param src1 general purpose register. May not be null or stackpointer.
2113      * @param src2 general purpose register. May not be null or stackpointer.
2114      * @param shiftType all types allowed, may not be null.
2115      * @param shiftAmt must be in range 0 to size - 1.
2116      */
2117     protected void orr(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2118         logicalRegInstruction(ORR, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2119     }
2120 
2121     /**
2122      * dst = src1 | ~(shiftType(src2, imm)).
2123      *
2124      * @param size register size. Has to be 32 or 64.
2125      * @param dst general purpose register. May not be null or stackpointer.
2126      * @param src1 general purpose register. May not be null or stackpointer.
2127      * @param src2 general purpose register. May not be null or stackpointer.
2128      * @param shiftType all types allowed, may not be null.
2129      * @param shiftAmt must be in range 0 to size - 1.
2130      */
2131     protected void orn(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2132         logicalRegInstruction(ORN, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2133     }
2134 
2135     private void logicalRegInstruction(Instruction instr, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt, InstructionType type) {
2136         assert !dst.equals(sp);
2137         assert !src1.equals(sp);
2138         assert !src2.equals(sp);
2139         assert shiftAmt &gt;= 0 &amp;&amp; shiftAmt &lt; type.width;
2140         emitInt(type.encoding | instr.encoding | LogicalShiftOp | shiftAmt &lt;&lt; ImmediateOffset | shiftType.encoding &lt;&lt; ShiftTypeOffset | rd(dst) | rs1(src1) | rs2(src2));
2141     }
2142 
2143     /* Variable Shift (5.5.4) */
2144     /**
2145      * dst = src1 &gt;&gt; (src2 &amp; log2(size)).
2146      *
2147      * @param size register size. Has to be 32 or 64.
2148      * @param dst general purpose register. May not be null or stackpointer.
2149      * @param src1 general purpose register. May not be null or stackpointer.
2150      * @param src2 general purpose register. May not be null or stackpointer.
2151      */
2152     protected void asr(int size, Register dst, Register src1, Register src2) {
2153         dataProcessing2SourceOp(ASRV, dst, src1, src2, generalFromSize(size));
2154     }
2155 
2156     /**
2157      * dst = src1 &lt;&lt; (src2 &amp; log2(size)).
2158      *
2159      * @param size register size. Has to be 32 or 64.
2160      * @param dst general purpose register. May not be null or stackpointer.
2161      * @param src1 general purpose register. May not be null or stackpointer.
2162      * @param src2 general purpose register. May not be null or stackpointer.
2163      */
2164     protected void lsl(int size, Register dst, Register src1, Register src2) {
2165         dataProcessing2SourceOp(LSLV, dst, src1, src2, generalFromSize(size));
2166     }
2167 
2168     /**
2169      * dst = src1 &gt;&gt;&gt; (src2 &amp; log2(size)).
2170      *
2171      * @param size register size. Has to be 32 or 64.
2172      * @param dst general purpose register. May not be null or stackpointer.
2173      * @param src1 general purpose register. May not be null or stackpointer.
2174      * @param src2 general purpose register. May not be null or stackpointer.
2175      */
2176     protected void lsr(int size, Register dst, Register src1, Register src2) {
2177         dataProcessing2SourceOp(LSRV, dst, src1, src2, generalFromSize(size));
2178     }
2179 
2180     /**
<a name="4" id="anc4"></a><span class="line-modified">2181      * dst = rotateRight(src1, (src2 &amp; log2(size))).</span>
2182      *
2183      * @param size register size. Has to be 32 or 64.
2184      * @param dst general purpose register. May not be null or stackpointer.
2185      * @param src1 general purpose register. May not be null or stackpointer.
2186      * @param src2 general purpose register. May not be null or stackpointer.
2187      */
<a name="5" id="anc5"></a><span class="line-modified">2188     protected void ror(int size, Register dst, Register src1, Register src2) {</span>
2189         dataProcessing2SourceOp(RORV, dst, src1, src2, generalFromSize(size));
2190     }
2191 
2192     /* Bit Operations (5.5.5) */
2193 
2194     /**
2195      * Counts leading sign bits. Sets Wd to the number of consecutive bits following the topmost bit
2196      * in dst, that are the same as the topmost bit. The count does not include the topmost bit
2197      * itself , so the result will be in the range 0 to size-1 inclusive.
2198      *
2199      * @param size register size. Has to be 32 or 64.
2200      * @param dst general purpose register. May not be null, zero-register or the stackpointer.
2201      * @param src source register. May not be null, zero-register or the stackpointer.
2202      */
2203     protected void cls(int size, Register dst, Register src) {
2204         dataProcessing1SourceOp(CLS, dst, src, generalFromSize(size));
2205     }
2206 
2207     /**
2208      * Counts leading zeros.
2209      *
2210      * @param size register size. Has to be 32 or 64.
2211      * @param dst general purpose register. May not be null, zero-register or the stackpointer.
2212      * @param src source register. May not be null, zero-register or the stackpointer.
2213      */
2214     public void clz(int size, Register dst, Register src) {
2215         dataProcessing1SourceOp(CLZ, dst, src, generalFromSize(size));
2216     }
2217 
2218     /**
2219      * Reverses bits.
2220      *
2221      * @param size register size. Has to be 32 or 64.
2222      * @param dst general purpose register. May not be null, zero-register or the stackpointer.
2223      * @param src source register. May not be null, zero-register or the stackpointer.
2224      */
2225     public void rbit(int size, Register dst, Register src) {
2226         dataProcessing1SourceOp(RBIT, dst, src, generalFromSize(size));
2227     }
2228 
2229     /**
2230      * Reverses bytes.
2231      *
2232      * @param size register size. Has to be 32 or 64.
2233      * @param dst general purpose register. May not be null or the stackpointer.
2234      * @param src source register. May not be null or the stackpointer.
2235      */
2236     public void rev(int size, Register dst, Register src) {
2237         if (size == 64) {
2238             dataProcessing1SourceOp(REVX, dst, src, generalFromSize(size));
2239         } else {
2240             assert size == 32;
2241             dataProcessing1SourceOp(REVW, dst, src, generalFromSize(size));
2242         }
2243     }
2244 
2245     /* Conditional Data Processing (5.5.6) */
2246 
2247     /**
2248      * Conditional select. dst = src1 if condition else src2.
2249      *
2250      * @param size register size. Has to be 32 or 64.
2251      * @param dst general purpose register. May not be null or the stackpointer.
2252      * @param src1 general purpose register. May not be null or the stackpointer.
2253      * @param src2 general purpose register. May not be null or the stackpointer.
2254      * @param condition any condition flag. May not be null.
2255      */
2256     protected void csel(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2257         conditionalSelectInstruction(CSEL, dst, src1, src2, condition, generalFromSize(size));
2258     }
2259 
2260     /**
2261      * Conditional select negate. dst = src1 if condition else -src2.
2262      *
2263      * @param size register size. Has to be 32 or 64.
2264      * @param dst general purpose register. May not be null or the stackpointer.
2265      * @param src1 general purpose register. May not be null or the stackpointer.
2266      * @param src2 general purpose register. May not be null or the stackpointer.
2267      * @param condition any condition flag. May not be null.
2268      */
2269     protected void csneg(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2270         conditionalSelectInstruction(CSNEG, dst, src1, src2, condition, generalFromSize(size));
2271     }
2272 
2273     /**
2274      * Conditional increase. dst = src1 if condition else src2 + 1.
2275      *
2276      * @param size register size. Has to be 32 or 64.
2277      * @param dst general purpose register. May not be null or the stackpointer.
2278      * @param src1 general purpose register. May not be null or the stackpointer.
2279      * @param src2 general purpose register. May not be null or the stackpointer.
2280      * @param condition any condition flag. May not be null.
2281      */
2282     protected void csinc(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2283         conditionalSelectInstruction(CSINC, dst, src1, src2, condition, generalFromSize(size));
2284     }
2285 
2286     private void conditionalSelectInstruction(Instruction instr, Register dst, Register src1, Register src2, ConditionFlag condition, InstructionType type) {
2287         assert !dst.equals(sp);
2288         assert !src1.equals(sp);
2289         assert !src2.equals(sp);
2290         emitInt(type.encoding | instr.encoding | ConditionalSelectOp | rd(dst) | rs1(src1) | rs2(src2) | condition.encoding &lt;&lt; ConditionalConditionOffset);
2291     }
2292 
2293     /* Integer Multiply/Divide (5.6) */
2294 
2295     /**
2296      * dst = src1 * src2 + src3.
2297      *
2298      * @param size register size. Has to be 32 or 64.
2299      * @param dst general purpose register. May not be null or the stackpointer.
2300      * @param src1 general purpose register. May not be null or the stackpointer.
2301      * @param src2 general purpose register. May not be null or the stackpointer.
2302      * @param src3 general purpose register. May not be null or the stackpointer.
2303      */
2304     protected void madd(int size, Register dst, Register src1, Register src2, Register src3) {
2305         mulInstruction(MADD, dst, src1, src2, src3, generalFromSize(size));
2306     }
2307 
2308     /**
2309      * dst = src3 - src1 * src2.
2310      *
2311      * @param size register size. Has to be 32 or 64.
2312      * @param dst general purpose register. May not be null or the stackpointer.
2313      * @param src1 general purpose register. May not be null or the stackpointer.
2314      * @param src2 general purpose register. May not be null or the stackpointer.
2315      * @param src3 general purpose register. May not be null or the stackpointer.
2316      */
2317     protected void msub(int size, Register dst, Register src1, Register src2, Register src3) {
2318         mulInstruction(MSUB, dst, src1, src2, src3, generalFromSize(size));
2319     }
2320 
2321     /**
2322      * Signed multiply high. dst = (src1 * src2)[127:64]
2323      *
2324      * @param dst general purpose register. May not be null or the stackpointer.
2325      * @param src1 general purpose register. May not be null or the stackpointer.
2326      * @param src2 general purpose register. May not be null or the stackpointer.
2327      */
2328     protected void smulh(Register dst, Register src1, Register src2) {
2329         assert !dst.equals(sp);
2330         assert !src1.equals(sp);
2331         assert !src2.equals(sp);
2332         emitInt(0b10011011010 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2333     }
2334 
2335     /**
2336      * Unsigned multiply high. dst = (src1 * src2)[127:64]
2337      *
2338      * @param dst general purpose register. May not be null or the stackpointer.
2339      * @param src1 general purpose register. May not be null or the stackpointer.
2340      * @param src2 general purpose register. May not be null or the stackpointer.
2341      */
2342     protected void umulh(Register dst, Register src1, Register src2) {
2343         assert !dst.equals(sp);
2344         assert !src1.equals(sp);
2345         assert !src2.equals(sp);
2346         emitInt(0b10011011110 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2347     }
2348 
2349     /**
2350      * Unsigned multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)
2351      *
2352      * @param dst general purpose register. May not be null or the stackpointer.
2353      * @param src1 general purpose register. May not be null or the stackpointer.
2354      * @param src2 general purpose register. May not be null or the stackpointer.
2355      * @param src3 general purpose register. May not be null or the stackpointer.
2356      */
2357     protected void umaddl(Register dst, Register src1, Register src2, Register src3) {
2358         assert !dst.equals(sp);
2359         assert !src1.equals(sp);
2360         assert !src2.equals(sp);
2361         assert !src3.equals(sp);
2362         emitInt(0b10011011101 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2363     }
2364 
2365     /**
2366      * Signed multiply-add long. xDst = xSrc3 + (wSrc1 * wSrc2)
2367      *
2368      * @param dst general purpose register. May not be null or the stackpointer.
2369      * @param src1 general purpose register. May not be null or the stackpointer.
2370      * @param src2 general purpose register. May not be null or the stackpointer.
2371      * @param src3 general purpose register. May not be null or the stackpointer.
2372      */
2373     public void smaddl(Register dst, Register src1, Register src2, Register src3) {
2374         smullInstruction(MADD, dst, src1, src2, src3);
2375     }
2376 
2377     /**
2378      * Signed multiply-sub long. xDst = xSrc3 - (wSrc1 * wSrc2)
2379      *
2380      * @param dst general purpose register. May not be null or the stackpointer.
2381      * @param src1 general purpose register. May not be null or the stackpointer.
2382      * @param src2 general purpose register. May not be null or the stackpointer.
2383      * @param src3 general purpose register. May not be null or the stackpointer.
2384      */
2385     public void smsubl(Register dst, Register src1, Register src2, Register src3) {
2386         smullInstruction(MSUB, dst, src1, src2, src3);
2387     }
2388 
2389     private void mulInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {
2390         assert !dst.equals(sp);
2391         assert !src1.equals(sp);
2392         assert !src2.equals(sp);
2393         assert !src3.equals(sp);
2394         emitInt(type.encoding | instr.encoding | MulOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2395     }
2396 
2397     private void smullInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3) {
2398         assert !dst.equals(sp);
2399         assert !src1.equals(sp);
2400         assert !src2.equals(sp);
2401         assert !src3.equals(sp);
2402         emitInt(instr.encoding | SignedMulLongOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2403     }
2404 
2405     /**
2406      * Signed divide. dst = src1 / src2.
2407      *
2408      * @param size register size. Has to be 32 or 64.
2409      * @param dst general purpose register. May not be null or the stackpointer.
2410      * @param src1 general purpose register. May not be null or the stackpointer.
2411      * @param src2 general purpose register. May not be null or the stackpointer.
2412      */
2413     public void sdiv(int size, Register dst, Register src1, Register src2) {
2414         dataProcessing2SourceOp(SDIV, dst, src1, src2, generalFromSize(size));
2415     }
2416 
2417     /**
2418      * Unsigned divide. dst = src1 / src2.
2419      *
2420      * @param size register size. Has to be 32 or 64.
2421      * @param dst general purpose register. May not be null or the stackpointer.
2422      * @param src1 general purpose register. May not be null or the stackpointer.
2423      * @param src2 general purpose register. May not be null or the stackpointer.
2424      */
2425     public void udiv(int size, Register dst, Register src1, Register src2) {
2426         dataProcessing2SourceOp(UDIV, dst, src1, src2, generalFromSize(size));
2427     }
2428 
2429     private void dataProcessing1SourceOp(Instruction instr, Register dst, Register src, InstructionType type) {
2430         emitInt(type.encoding | instr.encoding | DataProcessing1SourceOp | rd(dst) | rs1(src));
2431     }
2432 
2433     private void dataProcessing2SourceOp(Instruction instr, Register dst, Register src1, Register src2, InstructionType type) {
2434         assert !dst.equals(sp);
2435         assert !src1.equals(sp);
2436         assert !src2.equals(sp);
2437         emitInt(type.encoding | instr.encoding | DataProcessing2SourceOp | rd(dst) | rs1(src1) | rs2(src2));
2438     }
2439 
2440     /* Floating point operations */
2441 
2442     /* Load-Store Single FP register (5.7.1.1) */
2443     /**
2444      * Floating point load.
2445      *
2446      * @param size number of bits read from memory into rt. Must be 32 or 64.
2447      * @param rt floating point register. May not be null.
2448      * @param address all addressing modes allowed. May not be null.
2449      */
2450     public void fldr(int size, Register rt, AArch64Address address) {
2451         assert rt.getRegisterCategory().equals(SIMD);
2452         assert size == 32 || size == 64;
2453         int transferSize = NumUtil.log2Ceil(size / 8);
2454         loadStoreInstruction(LDR, rt, address, InstructionType.FP32, transferSize);
2455     }
2456 
2457     /**
2458      * Floating point store.
2459      *
2460      * @param size number of bits read from memory into rt. Must be 32 or 64.
2461      * @param rt floating point register. May not be null.
2462      * @param address all addressing modes allowed. May not be null.
2463      */
2464     public void fstr(int size, Register rt, AArch64Address address) {
2465         assert rt.getRegisterCategory().equals(SIMD);
2466         assert size == 32 || size == 64;
2467         int transferSize = NumUtil.log2Ceil(size / 8);
2468         loadStoreInstruction(STR, rt, address, InstructionType.FP64, transferSize);
2469     }
2470 
2471     /* Floating-point Move (register) (5.7.2) */
2472 
2473     /**
2474      * Floating point move.
2475      *
2476      * @param size register size. Has to be 32 or 64.
2477      * @param dst floating point register. May not be null.
2478      * @param src floating point register. May not be null.
2479      */
2480     protected void fmov(int size, Register dst, Register src) {
2481         fpDataProcessing1Source(FMOV, dst, src, floatFromSize(size));
2482     }
2483 
2484     /**
2485      * Move size bits from floating point register unchanged to general purpose register.
2486      *
2487      * @param size number of bits read from memory into rt. Must be 32 or 64.
2488      * @param dst general purpose register. May not be null, stack-pointer or zero-register
2489      * @param src floating point register. May not be null.
2490      */
2491     protected void fmovFpu2Cpu(int size, Register dst, Register src) {
2492         assert dst.getRegisterCategory().equals(CPU);
2493         assert src.getRegisterCategory().equals(SIMD);
2494         fmovCpuFpuInstruction(dst, src, size == 64, Instruction.FMOVFPU2CPU);
2495     }
2496 
2497     /**
2498      * Move size bits from general purpose register unchanged to floating point register.
2499      *
2500      * @param size register size. Has to be 32 or 64.
2501      * @param dst floating point register. May not be null.
2502      * @param src general purpose register. May not be null or stack-pointer.
2503      */
2504     protected void fmovCpu2Fpu(int size, Register dst, Register src) {
2505         assert dst.getRegisterCategory().equals(SIMD);
2506         assert src.getRegisterCategory().equals(CPU);
2507         fmovCpuFpuInstruction(dst, src, size == 64, Instruction.FMOVCPU2FPU);
2508     }
2509 
2510     private void fmovCpuFpuInstruction(Register dst, Register src, boolean is64bit, Instruction instr) {
2511         int sf = is64bit ? FP64.encoding | General64.encoding : FP32.encoding | General32.encoding;
2512         emitInt(sf | instr.encoding | FpConvertOp | rd(dst) | rs1(src));
2513     }
2514 
2515     /* Floating-point Move (immediate) (5.7.3) */
2516 
2517     /**
2518      * Move immediate into register.
2519      *
2520      * @param size register size. Has to be 32 or 64.
2521      * @param dst floating point register. May not be null.
2522      * @param imm immediate that is loaded into dst. If size is 32 only float immediates can be
2523      *            loaded, i.e. (float) imm == imm must be true. In all cases
2524      *            {@code isFloatImmediate}, respectively {@code #isDoubleImmediate} must be true
2525      *            depending on size.
2526      */
2527     protected void fmov(int size, Register dst, double imm) {
2528         assert dst.getRegisterCategory().equals(SIMD);
2529         InstructionType type = floatFromSize(size);
2530         int immEncoding;
2531         if (type == FP64) {
2532             immEncoding = getDoubleImmediate(imm);
2533         } else {
2534             assert imm == (float) imm : &quot;float mov must use an immediate that can be represented using a float.&quot;;
2535             immEncoding = getFloatImmediate((float) imm);
2536         }
2537         emitInt(type.encoding | FMOV.encoding | FpImmOp | immEncoding | rd(dst));
2538     }
2539 
2540     private static int getDoubleImmediate(double imm) {
2541         assert isDoubleImmediate(imm);
2542         // bits: aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000
2543         // 0000.0000.0000.0000.0000.0000.0000.0000
2544         long repr = Double.doubleToRawLongBits(imm);
2545         int a = (int) (repr &gt;&gt;&gt; 63) &lt;&lt; 7;
2546         int b = (int) ((repr &gt;&gt;&gt; 61) &amp; 0x1) &lt;&lt; 6;
2547         int cToH = (int) (repr &gt;&gt;&gt; 48) &amp; 0x3f;
2548         return (a | b | cToH) &lt;&lt; FpImmOffset;
2549     }
2550 
2551     protected static boolean isDoubleImmediate(double imm) {
2552         // Valid values will have the form:
2553         // aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000
2554         // 0000.0000.0000.0000.0000.0000.0000.0000
2555         long bits = Double.doubleToRawLongBits(imm);
2556         // lower 48 bits are cleared
2557         if ((bits &amp; NumUtil.getNbitNumberLong(48)) != 0) {
2558             return false;
2559         }
2560         // bits[61..54] are all set or all cleared.
2561         long pattern = (bits &gt;&gt; 54) &amp; NumUtil.getNbitNumberLong(7);
2562         if (pattern != 0 &amp;&amp; pattern != NumUtil.getNbitNumberLong(7)) {
2563             return false;
2564         }
2565         // bits[62] and bits[61] are opposites.
2566         boolean result = ((bits ^ (bits &lt;&lt; 1)) &amp; (1L &lt;&lt; 62)) != 0;
2567         return result;
2568     }
2569 
2570     private static int getFloatImmediate(float imm) {
2571         assert isFloatImmediate(imm);
2572         // bits: aBbb.bbbc.defg.h000.0000.0000.0000.0000
2573         int repr = Float.floatToRawIntBits(imm);
2574         int a = (repr &gt;&gt;&gt; 31) &lt;&lt; 7;
2575         int b = ((repr &gt;&gt;&gt; 29) &amp; 0x1) &lt;&lt; 6;
2576         int cToH = (repr &gt;&gt;&gt; 19) &amp; NumUtil.getNbitNumberInt(6);
2577         return (a | b | cToH) &lt;&lt; FpImmOffset;
2578     }
2579 
2580     protected static boolean isFloatImmediate(float imm) {
2581         // Valid values will have the form:
2582         // aBbb.bbbc.defg.h000.0000.0000.0000.0000
2583         int bits = Float.floatToRawIntBits(imm);
2584         // lower 20 bits are cleared.
2585         if ((bits &amp; NumUtil.getNbitNumberInt(19)) != 0) {
2586             return false;
2587         }
2588         // bits[29..25] are all set or all cleared
2589         int pattern = (bits &gt;&gt; 25) &amp; NumUtil.getNbitNumberInt(5);
2590         if (pattern != 0 &amp;&amp; pattern != NumUtil.getNbitNumberInt(5)) {
2591             return false;
2592         }
2593         // bits[29] and bits[30] have to be opposite
2594         return ((bits ^ (bits &lt;&lt; 1)) &amp; (1 &lt;&lt; 30)) != 0;
2595     }
2596 
2597     /* Convert Floating-point Precision (5.7.4.1) */
2598     /* Converts float to double and vice-versa */
2599 
2600     /**
2601      * Convert float to double and vice-versa.
2602      *
2603      * @param srcSize size of source register in bits.
2604      * @param dst floating point register. May not be null.
2605      * @param src floating point register. May not be null.
2606      */
2607     public void fcvt(int srcSize, Register dst, Register src) {
2608         if (srcSize == 32) {
2609             fpDataProcessing1Source(FCVTDS, dst, src, floatFromSize(srcSize));
2610         } else {
2611             fpDataProcessing1Source(FCVTSD, dst, src, floatFromSize(srcSize));
2612         }
2613     }
2614 
2615     /* Convert to Integer (5.7.4.2) */
2616 
2617     /**
2618      * Convert floating point to integer. Rounds towards zero.
2619      *
2620      * @param targetSize size of integer register. 32 or 64.
2621      * @param srcSize size of floating point register. 32 or 64.
2622      * @param dst general purpose register. May not be null, the zero-register or the stackpointer.
2623      * @param src floating point register. May not be null.
2624      */
2625     public void fcvtzs(int targetSize, int srcSize, Register dst, Register src) {
2626         assert !dst.equals(zr) &amp;&amp; !dst.equals(sp);
2627         assert src.getRegisterCategory().equals(SIMD);
2628         fcvtCpuFpuInstruction(FCVTZS, dst, src, generalFromSize(targetSize), floatFromSize(srcSize));
2629     }
2630 
2631     /* Convert from Integer (5.7.4.2) */
2632     /**
2633      * Converts integer to floating point. Uses rounding mode defined by FCPR.
2634      *
2635      * @param targetSize size of floating point register. 32 or 64.
2636      * @param srcSize size of integer register. 32 or 64.
2637      * @param dst floating point register. May not be null.
2638      * @param src general purpose register. May not be null or the stackpointer.
2639      */
2640     public void scvtf(int targetSize, int srcSize, Register dst, Register src) {
2641         assert dst.getRegisterCategory().equals(SIMD);
2642         assert !src.equals(sp);
2643         fcvtCpuFpuInstruction(SCVTF, dst, src, floatFromSize(targetSize), generalFromSize(srcSize));
2644     }
2645 
2646     private void fcvtCpuFpuInstruction(Instruction instr, Register dst, Register src, InstructionType type1, InstructionType type2) {
2647         emitInt(type1.encoding | type2.encoding | instr.encoding | FpConvertOp | rd(dst) | rs1(src));
2648     }
2649 
2650     /* Floating-point Round to Integral (5.7.5) */
2651 
2652     /**
2653      * Rounds floating-point to integral. Rounds towards zero.
2654      *
2655      * @param size register size.
2656      * @param dst floating point register. May not be null.
2657      * @param src floating point register. May not be null.
2658      */
2659     protected void frintz(int size, Register dst, Register src) {
2660         fpDataProcessing1Source(FRINTZ, dst, src, floatFromSize(size));
2661     }
2662 
2663     /**
2664      * Rounds floating-point to integral. Rounds towards nearest with ties to even.
2665      *
2666      * @param size register size.
2667      * @param dst floating point register. May not be null.
2668      * @param src floating point register. May not be null.
2669      */
2670     public void frintn(int size, Register dst, Register src) {
2671         fpDataProcessing1Source(FRINTN, dst, src, floatFromSize(size));
2672     }
2673 
2674     /**
2675      * Rounds floating-point to integral. Rounds towards minus infinity.
2676      *
2677      * @param size register size.
2678      * @param dst floating point register. May not be null.
2679      * @param src floating point register. May not be null.
2680      */
2681     public void frintm(int size, Register dst, Register src) {
2682         fpDataProcessing1Source(FRINTM, dst, src, floatFromSize(size));
2683     }
2684 
2685     /**
2686      * Rounds floating-point to integral. Rounds towards plus infinity.
2687      *
2688      * @param size register size.
2689      * @param dst floating point register. May not be null.
2690      * @param src floating point register. May not be null.
2691      */
2692     public void frintp(int size, Register dst, Register src) {
2693         fpDataProcessing1Source(FRINTP, dst, src, floatFromSize(size));
2694     }
2695 
2696     /* Floating-point Arithmetic (1 source) (5.7.6) */
2697 
2698     /**
2699      * dst = |src|.
2700      *
2701      * @param size register size.
2702      * @param dst floating point register. May not be null.
2703      * @param src floating point register. May not be null.
2704      */
2705     public void fabs(int size, Register dst, Register src) {
2706         fpDataProcessing1Source(FABS, dst, src, floatFromSize(size));
2707     }
2708 
2709     /**
2710      * dst = -neg.
2711      *
2712      * @param size register size.
2713      * @param dst floating point register. May not be null.
2714      * @param src floating point register. May not be null.
2715      */
2716     public void fneg(int size, Register dst, Register src) {
2717         fpDataProcessing1Source(FNEG, dst, src, floatFromSize(size));
2718     }
2719 
2720     /**
2721      * dst = Sqrt(src).
2722      *
2723      * @param size register size.
2724      * @param dst floating point register. May not be null.
2725      * @param src floating point register. May not be null.
2726      */
2727     public void fsqrt(int size, Register dst, Register src) {
2728         fpDataProcessing1Source(FSQRT, dst, src, floatFromSize(size));
2729     }
2730 
2731     private void fpDataProcessing1Source(Instruction instr, Register dst, Register src, InstructionType type) {
2732         assert dst.getRegisterCategory().equals(SIMD);
2733         assert src.getRegisterCategory().equals(SIMD);
2734         emitInt(type.encoding | instr.encoding | Fp1SourceOp | rd(dst) | rs1(src));
2735     }
2736 
2737     /* Floating-point Arithmetic (2 source) (5.7.7) */
2738 
2739     /**
2740      * dst = src1 + src2.
2741      *
2742      * @param size register size.
2743      * @param dst floating point register. May not be null.
2744      * @param src1 floating point register. May not be null.
2745      * @param src2 floating point register. May not be null.
2746      */
2747     public void fadd(int size, Register dst, Register src1, Register src2) {
2748         fpDataProcessing2Source(FADD, dst, src1, src2, floatFromSize(size));
2749     }
2750 
2751     /**
2752      * dst = src1 - src2.
2753      *
2754      * @param size register size.
2755      * @param dst floating point register. May not be null.
2756      * @param src1 floating point register. May not be null.
2757      * @param src2 floating point register. May not be null.
2758      */
2759     public void fsub(int size, Register dst, Register src1, Register src2) {
2760         fpDataProcessing2Source(FSUB, dst, src1, src2, floatFromSize(size));
2761     }
2762 
2763     /**
2764      * dst = src1 * src2.
2765      *
2766      * @param size register size.
2767      * @param dst floating point register. May not be null.
2768      * @param src1 floating point register. May not be null.
2769      * @param src2 floating point register. May not be null.
2770      */
2771     public void fmul(int size, Register dst, Register src1, Register src2) {
2772         fpDataProcessing2Source(FMUL, dst, src1, src2, floatFromSize(size));
2773     }
2774 
2775     /**
2776      * dst = src1 / src2.
2777      *
2778      * @param size register size.
2779      * @param dst floating point register. May not be null.
2780      * @param src1 floating point register. May not be null.
2781      * @param src2 floating point register. May not be null.
2782      */
2783     public void fdiv(int size, Register dst, Register src1, Register src2) {
2784         fpDataProcessing2Source(FDIV, dst, src1, src2, floatFromSize(size));
2785     }
2786 
2787     private void fpDataProcessing2Source(Instruction instr, Register dst, Register src1, Register src2, InstructionType type) {
2788         assert dst.getRegisterCategory().equals(SIMD);
2789         assert src1.getRegisterCategory().equals(SIMD);
2790         assert src2.getRegisterCategory().equals(SIMD);
2791         emitInt(type.encoding | instr.encoding | Fp2SourceOp | rd(dst) | rs1(src1) | rs2(src2));
2792     }
2793 
2794     /* Floating-point Multiply-Add (5.7.9) */
2795 
2796     /**
2797      * dst = src1 * src2 + src3.
2798      *
2799      * @param size register size.
2800      * @param dst floating point register. May not be null.
2801      * @param src1 floating point register. May not be null.
2802      * @param src2 floating point register. May not be null.
2803      * @param src3 floating point register. May not be null.
2804      */
2805     protected void fmadd(int size, Register dst, Register src1, Register src2, Register src3) {
2806         fpDataProcessing3Source(FMADD, dst, src1, src2, src3, floatFromSize(size));
2807     }
2808 
2809     /**
2810      * dst = src3 - src1 * src2.
2811      *
2812      * @param size register size.
2813      * @param dst floating point register. May not be null.
2814      * @param src1 floating point register. May not be null.
2815      * @param src2 floating point register. May not be null.
2816      * @param src3 floating point register. May not be null.
2817      */
2818     protected void fmsub(int size, Register dst, Register src1, Register src2, Register src3) {
2819         fpDataProcessing3Source(FMSUB, dst, src1, src2, src3, floatFromSize(size));
2820     }
2821 
2822     private void fpDataProcessing3Source(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {
2823         assert dst.getRegisterCategory().equals(SIMD);
2824         assert src1.getRegisterCategory().equals(SIMD);
2825         assert src2.getRegisterCategory().equals(SIMD);
2826         assert src3.getRegisterCategory().equals(SIMD);
2827         emitInt(type.encoding | instr.encoding | Fp3SourceOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2828     }
2829 
2830     /* Floating-point Comparison (5.7.10) */
2831 
2832     /**
2833      * Compares src1 to src2.
2834      *
2835      * @param size register size.
2836      * @param src1 floating point register. May not be null.
2837      * @param src2 floating point register. May not be null.
2838      */
2839     public void fcmp(int size, Register src1, Register src2) {
2840         assert src1.getRegisterCategory().equals(SIMD);
2841         assert src2.getRegisterCategory().equals(SIMD);
2842         InstructionType type = floatFromSize(size);
2843         emitInt(type.encoding | FCMP.encoding | FpCmpOp | rs1(src1) | rs2(src2));
2844     }
2845 
2846     /**
2847      * Signalling compares src1 to src2.
2848      *
2849      * @param size register size.
2850      * @param src1 floating point register. May not be null.
2851      * @param src2 floating point register. May not be null.
2852      */
2853     public void fcmpe(int size, Register src1, Register src2) {
2854         assert src1.getRegisterCategory().equals(SIMD);
2855         assert src2.getRegisterCategory().equals(SIMD);
2856         InstructionType type = floatFromSize(size);
2857         emitInt(type.encoding | FCMP.encoding | FpCmpeOp | rs1(src1) | rs2(src2));
2858     }
2859 
2860     /**
2861      * Conditional compare. NZCV = fcmp(src1, src2) if condition else uimm4.
2862      *
2863      * @param size register size.
2864      * @param src1 floating point register. May not be null.
2865      * @param src2 floating point register. May not be null.
2866      * @param uimm4 condition flags that are used if condition is false.
2867      * @param condition every condition allowed. May not be null.
2868      */
2869     public void fccmp(int size, Register src1, Register src2, int uimm4, ConditionFlag condition) {
2870         assert NumUtil.isUnsignedNbit(4, uimm4);
2871         assert src1.getRegisterCategory().equals(SIMD);
2872         assert src2.getRegisterCategory().equals(SIMD);
2873         InstructionType type = floatFromSize(size);
2874         emitInt(type.encoding | FCCMP.encoding | uimm4 | condition.encoding &lt;&lt; ConditionalConditionOffset | rs1(src1) | rs2(src2));
2875     }
2876 
2877     /**
2878      * Compare register to 0.0 .
2879      *
2880      * @param size register size.
2881      * @param src floating point register. May not be null.
2882      */
2883     public void fcmpZero(int size, Register src) {
2884         assert src.getRegisterCategory().equals(SIMD);
2885         InstructionType type = floatFromSize(size);
2886         emitInt(type.encoding | FCMPZERO.encoding | FpCmpOp | rs1(src));
2887     }
2888 
2889     /**
2890      * Signalling compare register to 0.0 .
2891      *
2892      * @param size register size.
2893      * @param src floating point register. May not be null.
2894      */
2895     public void fcmpeZero(int size, Register src) {
2896         assert src.getRegisterCategory().equals(SIMD);
2897         InstructionType type = floatFromSize(size);
2898         emitInt(type.encoding | FCMPZERO.encoding | FpCmpeOp | rs1(src));
2899     }
2900 
2901     /* Floating-point Conditional Select (5.7.11) */
2902 
2903     /**
2904      * Conditional select. dst = src1 if condition else src2.
2905      *
2906      * @param size register size.
2907      * @param dst floating point register. May not be null.
2908      * @param src1 floating point register. May not be null.
2909      * @param src2 floating point register. May not be null.
2910      * @param condition every condition allowed. May not be null.
2911      */
2912     protected void fcsel(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2913         assert dst.getRegisterCategory().equals(SIMD);
2914         assert src1.getRegisterCategory().equals(SIMD);
2915         assert src2.getRegisterCategory().equals(SIMD);
2916         InstructionType type = floatFromSize(size);
2917         emitInt(type.encoding | FCSEL.encoding | rd(dst) | rs1(src1) | rs2(src2) | condition.encoding &lt;&lt; ConditionalConditionOffset);
2918     }
2919 
2920     /* Debug exceptions (5.9.1.2) */
2921 
2922     /**
2923      * Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as
2924      * UNALLOCATED instruction.
2925      *
2926      * @param uimm16 Arbitrary 16-bit unsigned payload.
2927      */
2928     protected void hlt(int uimm16) {
2929         exceptionInstruction(HLT, uimm16);
2930     }
2931 
2932     /**
2933      * Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher
2934      * exception level.
2935      *
2936      * @param uimm16 Arbitrary 16-bit unsigned payload.
2937      */
2938     protected void brk(int uimm16) {
2939         exceptionInstruction(BRK, uimm16);
2940     }
2941 
2942     private void exceptionInstruction(Instruction instr, int uimm16) {
2943         assert NumUtil.isUnsignedNbit(16, uimm16);
2944         emitInt(instr.encoding | ExceptionOp | uimm16 &lt;&lt; SystemImmediateOffset);
2945     }
2946 
2947     /* Architectural hints (5.9.4) */
2948     public enum SystemHint {
2949         NOP(0x0),
2950         YIELD(0x1),
2951         WFE(0x2),
2952         WFI(0x3),
2953         SEV(0x4),
2954         SEVL(0x5),
2955         CSDB(0x14);
2956 
2957         private final int encoding;
2958 
2959         SystemHint(int encoding) {
2960             this.encoding = encoding;
2961         }
2962     }
2963 
2964     /**
2965      * Architectural hints.
2966      *
2967      * @param hint Can be any of the defined hints. May not be null.
2968      */
2969     protected void hint(SystemHint hint) {
2970         emitInt(HINT.encoding | hint.encoding &lt;&lt; SystemImmediateOffset);
2971     }
2972 
2973     /**
2974      * Clear Exclusive: clears the local record of the executing processor that an address has had a
2975      * request for an exclusive access.
2976      */
2977     protected void clrex() {
2978         emitInt(CLREX.encoding);
2979     }
2980 
2981     /**
2982      * Possible barrier definitions for Aarch64. LOAD_LOAD and LOAD_STORE map to the same underlying
2983      * barrier.
2984      *
2985      * We only need synchronization across the inner shareable domain (see B2-90 in the Reference
2986      * documentation).
2987      */
2988     public enum BarrierKind {
2989         LOAD_LOAD(0x9, &quot;ISHLD&quot;),
2990         LOAD_STORE(0x9, &quot;ISHLD&quot;),
2991         STORE_STORE(0xA, &quot;ISHST&quot;),
<a name="6" id="anc6"></a><span class="line-modified">2992         ANY_ANY(0xB, &quot;ISH&quot;);</span>

2993 
2994         public final int encoding;
2995         public final String optionName;
2996 
2997         BarrierKind(int encoding, String optionName) {
2998             this.encoding = encoding;
2999             this.optionName = optionName;
3000         }
3001     }
3002 
3003     /**
3004      * Data Memory Barrier.
3005      *
3006      * @param barrierKind barrier that is issued. May not be null.
3007      */
3008     public void dmb(BarrierKind barrierKind) {
3009         emitInt(DMB.encoding | BarrierOp | barrierKind.encoding &lt;&lt; BarrierKindOffset);
3010     }
3011 
<a name="7" id="anc7"></a>






3012     public void mrs(Register dst, SystemRegister systemRegister) {
3013         emitInt(MRS.encoding | systemRegister.encoding() | rt(dst));
3014     }
3015 
3016     public void msr(SystemRegister systemRegister, Register src) {
3017         emitInt(MRS.encoding | systemRegister.encoding() | rt(src));
3018     }
3019 
3020     public void dc(DataCacheOperationType type, Register src) {
3021         emitInt(DC.encoding | type.encoding() | rt(src));
3022     }
3023 
3024     public void annotatePatchingImmediate(int pos, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {
3025         if (codePatchingAnnotationConsumer != null) {
3026             codePatchingAnnotationConsumer.accept(new SingleInstructionAnnotation(pos, instruction, operandSizeBits, offsetBits, shift));
3027         }
3028     }
3029 
<a name="8" id="anc8"></a><span class="line-modified">3030     void annotateImmediateMovSequence(int pos, int numInstrs) {</span>
<span class="line-modified">3031         if (codePatchingAnnotationConsumer != null) {</span>
<span class="line-modified">3032             codePatchingAnnotationConsumer.accept(new MovSequenceAnnotation(pos, numInstrs));</span>

3033         }
<a name="9" id="anc9"></a>

3034     }
3035 
<a name="10" id="anc10"></a><span class="line-modified">3036     public static class SingleInstructionAnnotation extends CodeAnnotation {</span>








































3037 
3038         /**
3039          * The size of the operand, in bytes.
3040          */
3041         public final int operandSizeBits;
3042         public final int offsetBits;
3043         public final Instruction instruction;
3044         public final int shift;
3045 
3046         SingleInstructionAnnotation(int instructionPosition, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {
3047             super(instructionPosition);
3048             this.operandSizeBits = operandSizeBits;
3049             this.offsetBits = offsetBits;
3050             this.shift = shift;
3051             this.instruction = instruction;
3052         }
<a name="11" id="anc11"></a><span class="line-removed">3053     }</span>
3054 
<a name="12" id="anc12"></a><span class="line-modified">3055     public static class MovSequenceAnnotation extends CodeAnnotation {</span>



3056 
<a name="13" id="anc13"></a><span class="line-modified">3057         /**</span>
<span class="line-modified">3058          * The size of the operand, in bytes.</span>
<span class="line-modified">3059          */</span>
<span class="line-modified">3060         public final int numInstrs;</span>

3061 
<a name="14" id="anc14"></a><span class="line-modified">3062         MovSequenceAnnotation(int instructionPosition, int numInstrs) {</span>
<span class="line-modified">3063             super(instructionPosition);</span>
<span class="line-modified">3064             this.numInstrs = numInstrs;</span>























3065         }
3066     }
3067 
3068     /**
3069      * dst[0...n] = countBitCountOfEachByte(src[0...n]), n = size/8.
3070      *
3071      * @param size register size. Has to be 64 or 128.
3072      * @param dst SIMD register. Should not be null.
3073      * @param src SIMD register. Should not be null.
3074      */
3075     public void cnt(int size, Register dst, Register src) {
3076         assert 64 == size || 128 == size : &quot;Invalid size for cnt&quot;;
3077         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | CNT.encoding | rd(dst) | rs1(src));
3078     }
3079 
3080     /**
3081      * dst = src[0] + ....+ src[n].
3082      *
3083      * @param size register size. Has to be 64 or 128.
3084      * @param laneWidth the width that SIMD register is treated as different lanes with.
3085      * @param dst SIMD register. Should not be null.
3086      * @param src SIMD register. Should not be null.
3087      */
3088     public void addv(int size, SIMDElementSize laneWidth, Register dst, Register src) {
3089         assert 64 == size || 128 == size : &quot;Invalid size for addv&quot;;
3090         assert SIMDElementSize.DoubleWord != laneWidth : &quot;Invalid lane width for addv&quot;;
3091         assert 64 != size || SIMDElementSize.Word != laneWidth : &quot;Invalid size and lane combination for addv&quot;;
3092         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | laneWidth.encoding &lt;&lt; SIMDSizeOffset | ADDV.encoding | rd(dst) | rs1(src));
3093     }
3094 
3095     /**
3096      * dst = src[srcIdx].
3097      *
3098      * @param size register size. Can be 8, 16, 32 or 64.
3099      * @param dst general purpose register. Should not be null or zero-register.
3100      * @param srcIdx lane index of source register that dest data is from.
3101      * @param src SIMD register. Should not be null.
3102      */
3103     public void umov(int size, Register dst, int srcIdx, Register src) {
3104         assert (srcIdx + 1) * size &lt;= 128 : &quot;Invalid src vectRegister index&quot;;
3105         InstructionType simdDataType = simdFromSize(size);
3106         int imm5 = simdDataType.encoding | srcIdx &lt;&lt; Integer.numberOfTrailingZeros(simdDataType.encoding) + 1;
3107         emitInt((size &gt;&gt; 6) &lt;&lt; SIMDQBitOffset | imm5 &lt;&lt; SIMDImm5Offset | UMOV.encoding | rd(dst) | rs1(src));
3108     }
3109 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
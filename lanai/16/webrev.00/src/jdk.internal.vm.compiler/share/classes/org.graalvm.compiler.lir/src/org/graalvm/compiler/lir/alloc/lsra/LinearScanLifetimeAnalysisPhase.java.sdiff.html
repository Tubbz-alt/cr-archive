<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/alloc/lsra/LinearScanLifetimeAnalysisPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LinearScan.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../asm/CompilationResultBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/alloc/lsra/LinearScanLifetimeAnalysisPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 import static org.graalvm.compiler.lir.LIRValueUtil.asVariable;
 32 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 33 import static org.graalvm.compiler.lir.debug.LIRGenerationDebugContext.getSourceForOperandFromDebugContext;
 34 
 35 import java.util.ArrayDeque;
 36 import java.util.ArrayList;
 37 import java.util.BitSet;
 38 import java.util.EnumSet;
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicSet;
 41 import jdk.internal.vm.compiler.collections.Equivalence;
 42 import org.graalvm.compiler.core.common.LIRKind;
 43 import org.graalvm.compiler.core.common.PermanentBailoutException;
 44 import org.graalvm.compiler.core.common.alloc.ComputeBlockOrder;
 45 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 46 import org.graalvm.compiler.core.common.util.BitMap2D;
 47 import org.graalvm.compiler.debug.Assertions;
 48 import org.graalvm.compiler.debug.DebugContext;
 49 import org.graalvm.compiler.debug.GraalError;
 50 import org.graalvm.compiler.debug.Indent;

 51 import org.graalvm.compiler.lir.InstructionValueConsumer;
 52 import org.graalvm.compiler.lir.LIRInstruction;
 53 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 54 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 55 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
 56 import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
 57 import org.graalvm.compiler.lir.ValueConsumer;
 58 import org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterPriority;
 59 import org.graalvm.compiler.lir.alloc.lsra.Interval.SpillState;
 60 import org.graalvm.compiler.lir.alloc.lsra.LinearScan.BlockData;
 61 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 62 import org.graalvm.compiler.lir.phases.AllocationPhase.AllocationContext;
 63 
 64 import jdk.vm.ci.code.Register;
 65 import jdk.vm.ci.code.RegisterArray;
 66 import jdk.vm.ci.code.StackSlot;
 67 import jdk.vm.ci.code.TargetDescription;
 68 import jdk.vm.ci.meta.AllocatableValue;
 69 import jdk.vm.ci.meta.Constant;
 70 import jdk.vm.ci.meta.JavaConstant;
 71 import jdk.vm.ci.meta.Value;
 72 import jdk.vm.ci.meta.ValueKind;

 73 
 74 public class LinearScanLifetimeAnalysisPhase extends LinearScanAllocationPhase {
 75 
 76     protected final LinearScan allocator;
 77     protected final DebugContext debug;
 78 
 79     /**
 80      * @param linearScan
 81      */
 82     protected LinearScanLifetimeAnalysisPhase(LinearScan linearScan) {
 83         allocator = linearScan;
 84         debug = allocator.getDebug();
 85     }
 86 
 87     @Override
 88     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, AllocationContext context) {
 89         numberInstructions();
 90         debug.dump(DebugContext.VERBOSE_LEVEL, lirGenRes.getLIR(), &quot;Before register allocation&quot;);
 91         computeLocalLiveSets();
 92         computeGlobalLiveSets();
</pre>
<hr />
<pre>
732             InstructionValueConsumer aliveConsumer = (op, operand, mode, flags) -&gt; {
733                 if (LinearScan.isVariableOrRegister(operand)) {
734                     RegisterPriority p = registerPriorityOfInputOperand(flags);
735                     int opId = op.id();
736                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
737                     addUse((AllocatableValue) operand, blockFrom, opId + 1, p, operand.getValueKind(), detailedAsserts);
738                     addRegisterHint(op, operand, mode, flags, false);
739                 }
740             };
741 
742             InstructionValueConsumer inputConsumer = (op, operand, mode, flags) -&gt; {
743                 if (LinearScan.isVariableOrRegister(operand)) {
744                     int opId = op.id();
745                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
746                     RegisterPriority p = registerPriorityOfInputOperand(flags);
747                     addUse((AllocatableValue) operand, blockFrom, opId, p, operand.getValueKind(), detailedAsserts);
748                     addRegisterHint(op, operand, mode, flags, false);
749                 }
750             };
751 
<span class="line-modified">752             InstructionValueConsumer stateProc = (op, operand, mode, flags) -&gt; {</span>
753                 if (LinearScan.isVariableOrRegister(operand)) {
754                     int opId = op.id();
755                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
756                     addUse((AllocatableValue) operand, blockFrom, opId + 1, RegisterPriority.None, operand.getValueKind(), detailedAsserts);
757                 }
758             };






















759 
760             // create a list with all caller-save registers (cpu, fpu, xmm)
761             RegisterArray callerSaveRegs = allocator.getRegisterAllocationConfig().getRegisterConfig().getCallerSaveRegisters();
762 
763             // iterate all blocks in reverse order
764             for (int i = allocator.blockCount() - 1; i &gt;= 0; i--) {
765 
766                 AbstractBlockBase&lt;?&gt; block = allocator.blockAt(i);
767                 try (Indent indent2 = debug.logAndIndent(&quot;handle block %d&quot;, block.getId())) {
768 
769                     ArrayList&lt;LIRInstruction&gt; instructions = allocator.getLIR().getLIRforBlock(block);
770                     final int blockFrom = allocator.getFirstLirInstructionId(block);
771                     int blockTo = allocator.getLastLirInstructionId(block);
772 
773                     assert blockFrom == instructions.get(0).id();
774                     assert blockTo == instructions.get(instructions.size() - 1).id();
775 
776                     // Update intervals for operands live at the end of this block;
777                     BitSet live = allocator.getBlockData(block).liveOut;
778                     for (int operandNum = live.nextSetBit(0); operandNum &gt;= 0; operandNum = live.nextSetBit(operandNum + 1)) {
</pre>
<hr />
<pre>
811                                     if (allocator.attributes(r).isAllocatable()) {
812                                         addTemp(r.asValue(), opId, RegisterPriority.None, LIRKind.Illegal, detailedAsserts);
813                                     }
814                                 }
815                                 if (debug.isLogEnabled()) {
816                                     debug.log(&quot;operation destroys all caller-save registers&quot;);
817                                 }
818                             }
819 
820                             op.visitEachOutput(outputConsumer);
821                             op.visitEachTemp(tempConsumer);
822                             op.visitEachAlive(aliveConsumer);
823                             op.visitEachInput(inputConsumer);
824 
825                             /*
826                              * Add uses of live locals from interpreter&#39;s point of view for proper
827                              * debug information generation. Treat these operands as temp values (if
828                              * the live range is extended to a call site, the value would be in a
829                              * register at the call otherwise).
830                              */
<span class="line-modified">831                             op.visitEachState(stateProc);</span>
832 
833                             // special steps for some instructions (especially moves)
834                             handleMethodArguments(op);
835 
836                         }
837 
838                     } // end of instruction iteration
839                 }
840             } // end of block iteration
841 
842             /*
843              * Add the range [0, 1] to all fixed intervals. the register allocator need not handle
844              * unhandled fixed intervals.
845              */
846             for (Interval interval : allocator.intervals()) {
847                 if (interval != null &amp;&amp; isRegister(interval.operand)) {
848                     interval.addRange(0, 1);
849                 }
850             }
851         }
</pre>
</td>
<td>
<hr />
<pre>
 31 import static org.graalvm.compiler.lir.LIRValueUtil.asVariable;
 32 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 33 import static org.graalvm.compiler.lir.debug.LIRGenerationDebugContext.getSourceForOperandFromDebugContext;
 34 
 35 import java.util.ArrayDeque;
 36 import java.util.ArrayList;
 37 import java.util.BitSet;
 38 import java.util.EnumSet;
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicSet;
 41 import jdk.internal.vm.compiler.collections.Equivalence;
 42 import org.graalvm.compiler.core.common.LIRKind;
 43 import org.graalvm.compiler.core.common.PermanentBailoutException;
 44 import org.graalvm.compiler.core.common.alloc.ComputeBlockOrder;
 45 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 46 import org.graalvm.compiler.core.common.util.BitMap2D;
 47 import org.graalvm.compiler.debug.Assertions;
 48 import org.graalvm.compiler.debug.DebugContext;
 49 import org.graalvm.compiler.debug.GraalError;
 50 import org.graalvm.compiler.debug.Indent;
<span class="line-added"> 51 import org.graalvm.compiler.lir.InstructionStateProcedure;</span>
 52 import org.graalvm.compiler.lir.InstructionValueConsumer;
 53 import org.graalvm.compiler.lir.LIRInstruction;
 54 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 55 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 56 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
 57 import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
 58 import org.graalvm.compiler.lir.ValueConsumer;
 59 import org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterPriority;
 60 import org.graalvm.compiler.lir.alloc.lsra.Interval.SpillState;
 61 import org.graalvm.compiler.lir.alloc.lsra.LinearScan.BlockData;
 62 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 63 import org.graalvm.compiler.lir.phases.AllocationPhase.AllocationContext;
 64 
 65 import jdk.vm.ci.code.Register;
 66 import jdk.vm.ci.code.RegisterArray;
 67 import jdk.vm.ci.code.StackSlot;
 68 import jdk.vm.ci.code.TargetDescription;
 69 import jdk.vm.ci.meta.AllocatableValue;
 70 import jdk.vm.ci.meta.Constant;
 71 import jdk.vm.ci.meta.JavaConstant;
 72 import jdk.vm.ci.meta.Value;
 73 import jdk.vm.ci.meta.ValueKind;
<span class="line-added"> 74 import org.graalvm.compiler.lir.util.IndexedValueMap;</span>
 75 
 76 public class LinearScanLifetimeAnalysisPhase extends LinearScanAllocationPhase {
 77 
 78     protected final LinearScan allocator;
 79     protected final DebugContext debug;
 80 
 81     /**
 82      * @param linearScan
 83      */
 84     protected LinearScanLifetimeAnalysisPhase(LinearScan linearScan) {
 85         allocator = linearScan;
 86         debug = allocator.getDebug();
 87     }
 88 
 89     @Override
 90     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, AllocationContext context) {
 91         numberInstructions();
 92         debug.dump(DebugContext.VERBOSE_LEVEL, lirGenRes.getLIR(), &quot;Before register allocation&quot;);
 93         computeLocalLiveSets();
 94         computeGlobalLiveSets();
</pre>
<hr />
<pre>
734             InstructionValueConsumer aliveConsumer = (op, operand, mode, flags) -&gt; {
735                 if (LinearScan.isVariableOrRegister(operand)) {
736                     RegisterPriority p = registerPriorityOfInputOperand(flags);
737                     int opId = op.id();
738                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
739                     addUse((AllocatableValue) operand, blockFrom, opId + 1, p, operand.getValueKind(), detailedAsserts);
740                     addRegisterHint(op, operand, mode, flags, false);
741                 }
742             };
743 
744             InstructionValueConsumer inputConsumer = (op, operand, mode, flags) -&gt; {
745                 if (LinearScan.isVariableOrRegister(operand)) {
746                     int opId = op.id();
747                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
748                     RegisterPriority p = registerPriorityOfInputOperand(flags);
749                     addUse((AllocatableValue) operand, blockFrom, opId, p, operand.getValueKind(), detailedAsserts);
750                     addRegisterHint(op, operand, mode, flags, false);
751                 }
752             };
753 
<span class="line-modified">754             InstructionValueConsumer nonBasePointersStateProc = (op, operand, mode, flags) -&gt; {</span>
755                 if (LinearScan.isVariableOrRegister(operand)) {
756                     int opId = op.id();
757                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
758                     addUse((AllocatableValue) operand, blockFrom, opId + 1, RegisterPriority.None, operand.getValueKind(), detailedAsserts);
759                 }
760             };
<span class="line-added">761             InstructionValueConsumer basePointerStateProc = (op, operand, mode, flags) -&gt; {</span>
<span class="line-added">762                 if (LinearScan.isVariableOrRegister(operand)) {</span>
<span class="line-added">763                     int opId = op.id();</span>
<span class="line-added">764                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));</span>
<span class="line-added">765                     /*</span>
<span class="line-added">766                      * Setting priority of base pointers to ShouldHaveRegister to avoid</span>
<span class="line-added">767                      * rematerialization (see #getMaterializedValue).</span>
<span class="line-added">768                      */</span>
<span class="line-added">769                     addUse((AllocatableValue) operand, blockFrom, opId + 1, RegisterPriority.ShouldHaveRegister, operand.getValueKind(), detailedAsserts);</span>
<span class="line-added">770                 }</span>
<span class="line-added">771             };</span>
<span class="line-added">772 </span>
<span class="line-added">773             InstructionStateProcedure stateProc = (op, state) -&gt; {</span>
<span class="line-added">774                 IndexedValueMap liveBasePointers = state.getLiveBasePointers();</span>
<span class="line-added">775                 // temporarily unset the base pointers to that the procedure will not visit them</span>
<span class="line-added">776                 state.setLiveBasePointers(null);</span>
<span class="line-added">777                 state.visitEachState(op, nonBasePointersStateProc);</span>
<span class="line-added">778                 // visit the base pointers explicitly</span>
<span class="line-added">779                 liveBasePointers.visitEach(op, OperandMode.ALIVE, null, basePointerStateProc);</span>
<span class="line-added">780                 // reset the base pointers</span>
<span class="line-added">781                 state.setLiveBasePointers(liveBasePointers);</span>
<span class="line-added">782             };</span>
783 
784             // create a list with all caller-save registers (cpu, fpu, xmm)
785             RegisterArray callerSaveRegs = allocator.getRegisterAllocationConfig().getRegisterConfig().getCallerSaveRegisters();
786 
787             // iterate all blocks in reverse order
788             for (int i = allocator.blockCount() - 1; i &gt;= 0; i--) {
789 
790                 AbstractBlockBase&lt;?&gt; block = allocator.blockAt(i);
791                 try (Indent indent2 = debug.logAndIndent(&quot;handle block %d&quot;, block.getId())) {
792 
793                     ArrayList&lt;LIRInstruction&gt; instructions = allocator.getLIR().getLIRforBlock(block);
794                     final int blockFrom = allocator.getFirstLirInstructionId(block);
795                     int blockTo = allocator.getLastLirInstructionId(block);
796 
797                     assert blockFrom == instructions.get(0).id();
798                     assert blockTo == instructions.get(instructions.size() - 1).id();
799 
800                     // Update intervals for operands live at the end of this block;
801                     BitSet live = allocator.getBlockData(block).liveOut;
802                     for (int operandNum = live.nextSetBit(0); operandNum &gt;= 0; operandNum = live.nextSetBit(operandNum + 1)) {
</pre>
<hr />
<pre>
835                                     if (allocator.attributes(r).isAllocatable()) {
836                                         addTemp(r.asValue(), opId, RegisterPriority.None, LIRKind.Illegal, detailedAsserts);
837                                     }
838                                 }
839                                 if (debug.isLogEnabled()) {
840                                     debug.log(&quot;operation destroys all caller-save registers&quot;);
841                                 }
842                             }
843 
844                             op.visitEachOutput(outputConsumer);
845                             op.visitEachTemp(tempConsumer);
846                             op.visitEachAlive(aliveConsumer);
847                             op.visitEachInput(inputConsumer);
848 
849                             /*
850                              * Add uses of live locals from interpreter&#39;s point of view for proper
851                              * debug information generation. Treat these operands as temp values (if
852                              * the live range is extended to a call site, the value would be in a
853                              * register at the call otherwise).
854                              */
<span class="line-modified">855                             op.forEachState(stateProc);</span>
856 
857                             // special steps for some instructions (especially moves)
858                             handleMethodArguments(op);
859 
860                         }
861 
862                     } // end of instruction iteration
863                 }
864             } // end of block iteration
865 
866             /*
867              * Add the range [0, 1] to all fixed intervals. the register allocator need not handle
868              * unhandled fixed intervals.
869              */
870             for (Interval interval : allocator.intervals()) {
871                 if (interval != null &amp;&amp; isRegister(interval.operand)) {
872                     interval.addRange(0, 1);
873                 }
874             }
875         }
</pre>
</td>
</tr>
</table>
<center><a href="LinearScan.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../asm/CompilationResultBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/alloc/lsra/LinearScan.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.alloc.lsra;
 26 
 27 import static jdk.vm.ci.code.CodeUtil.isEven;
 28 import static jdk.vm.ci.code.ValueUtil.asRegister;
 29 import static jdk.vm.ci.code.ValueUtil.isIllegal;
 30 import static jdk.vm.ci.code.ValueUtil.isLegal;
 31 import static jdk.vm.ci.code.ValueUtil.isRegister;
 32 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 33 import static org.graalvm.compiler.lir.phases.LIRPhase.Options.LIROptimization;
 34 
 35 import java.util.ArrayList;
 36 import java.util.Arrays;
 37 import java.util.BitSet;
 38 import java.util.EnumSet;
 39 
 40 import jdk.internal.vm.compiler.collections.Pair;
 41 import org.graalvm.compiler.core.common.LIRKind;
 42 import org.graalvm.compiler.core.common.alloc.RegisterAllocationConfig;
 43 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 44 import org.graalvm.compiler.core.common.cfg.BlockMap;
 45 import org.graalvm.compiler.debug.Assertions;
 46 import org.graalvm.compiler.debug.DebugContext;
 47 import org.graalvm.compiler.debug.GraalError;
 48 import org.graalvm.compiler.debug.Indent;
 49 import org.graalvm.compiler.lir.LIR;
 50 import org.graalvm.compiler.lir.LIRInstruction;
 51 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 52 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 53 import org.graalvm.compiler.lir.ValueConsumer;
 54 import org.graalvm.compiler.lir.Variable;
 55 import org.graalvm.compiler.lir.VirtualStackSlot;
 56 import org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterBinding;
 57 import org.graalvm.compiler.lir.framemap.FrameMapBuilder;
 58 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 59 import org.graalvm.compiler.lir.gen.LIRGeneratorTool.MoveFactory;
 60 import org.graalvm.compiler.lir.phases.AllocationPhase.AllocationContext;
 61 import org.graalvm.compiler.options.NestedBooleanOptionKey;
 62 import org.graalvm.compiler.options.Option;
 63 import org.graalvm.compiler.options.OptionKey;
 64 import org.graalvm.compiler.options.OptionType;
 65 import org.graalvm.compiler.options.OptionValues;
 66 
 67 import jdk.vm.ci.code.Register;
 68 import jdk.vm.ci.code.RegisterArray;
 69 import jdk.vm.ci.code.RegisterAttributes;
 70 import jdk.vm.ci.code.RegisterValue;
 71 import jdk.vm.ci.code.TargetDescription;
 72 import jdk.vm.ci.meta.AllocatableValue;
 73 import jdk.vm.ci.meta.Value;
 74 
 75 /**
 76  * An implementation of the linear scan register allocator algorithm described in
 77  * &lt;a href=&quot;http://doi.acm.org/10.1145/1064979.1064998&quot; &gt; &quot;Optimized Interval Splitting in a Linear
 78  * Scan Register Allocator&quot;&lt;/a&gt; by Christian Wimmer and Hanspeter Moessenboeck.
 79  */
 80 public class LinearScan {
 81 
 82     public static class Options {
 83         // @formatter:off
 84         @Option(help = &quot;Enable spill position optimization&quot;, type = OptionType.Debug)
 85         public static final OptionKey&lt;Boolean&gt; LIROptLSRAOptimizeSpillPosition = new NestedBooleanOptionKey(LIROptimization, true);
 86         // @formatter:on
 87     }
 88 
 89     public static class BlockData {
 90 
 91         /**
 92          * Bit map specifying which operands are live upon entry to this block. These are values
 93          * used in this block or any of its successors where such value are not defined in this
 94          * block. The bit index of an operand is its {@linkplain LinearScan#operandNumber(Value)
 95          * operand number}.
 96          */
 97         public BitSet liveIn;
 98 
 99         /**
100          * Bit map specifying which operands are live upon exit from this block. These are values
101          * used in a successor block that are either defined in this block or were live upon entry
102          * to this block. The bit index of an operand is its
103          * {@linkplain LinearScan#operandNumber(Value) operand number}.
104          */
105         public BitSet liveOut;
106 
107         /**
108          * Bit map specifying which operands are used (before being defined) in this block. That is,
109          * these are the values that are live upon entry to the block. The bit index of an operand
110          * is its {@linkplain LinearScan#operandNumber(Value) operand number}.
111          */
112         public BitSet liveGen;
113 
114         /**
115          * Bit map specifying which operands are defined/overwritten in this block. The bit index of
116          * an operand is its {@linkplain LinearScan#operandNumber(Value) operand number}.
117          */
118         public BitSet liveKill;
119     }
120 
121     public static final int DOMINATOR_SPILL_MOVE_ID = -2;
122     private static final int SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT = 1;
123 
124     private final LIR ir;
125     private final FrameMapBuilder frameMapBuilder;
126     private final RegisterAttributes[] registerAttributes;
127     private final RegisterArray registers;
128     private final RegisterAllocationConfig regAllocConfig;
129     private final MoveFactory moveFactory;
130 
131     private final BlockMap&lt;BlockData&gt; blockData;
132     protected final DebugContext debug;
133 
134     /**
135      * List of blocks in linear-scan order. This is only correct as long as the CFG does not change.
136      */
137     private final AbstractBlockBase&lt;?&gt;[] sortedBlocks;
138 
139     /**
140      * @see #intervals()
141      */
142     private Interval[] intervals;
143 
144     /**
145      * The number of valid entries in {@link #intervals}.
146      */
147     private int intervalsSize;
148 
149     /**
150      * The index of the first entry in {@link #intervals} for a
151      * {@linkplain #createDerivedInterval(Interval) derived interval}.
152      */
153     private int firstDerivedIntervalIndex = -1;
154 
155     /**
156      * Intervals sorted by {@link Interval#from()}.
157      */
158     private Interval[] sortedIntervals;
159 
160     /**
161      * Map from an instruction {@linkplain LIRInstruction#id id} to the instruction. Entries should
162      * be retrieved with {@link #instructionForId(int)} as the id is not simply an index into this
163      * array.
164      */
165     private LIRInstruction[] opIdToInstructionMap;
166 
167     /**
168      * Map from an instruction {@linkplain LIRInstruction#id id} to the
169      * {@linkplain AbstractBlockBase block} containing the instruction. Entries should be retrieved
170      * with {@link #blockForId(int)} as the id is not simply an index into this array.
171      */
172     private AbstractBlockBase&lt;?&gt;[] opIdToBlockMap;
173 
174     /**
175      * The {@linkplain #operandNumber(Value) number} of the first variable operand allocated.
176      */
177     private final int firstVariableNumber;
178     /**
179      * Number of variables.
180      */
181     private int numVariables;
182     private final boolean neverSpillConstants;
183 
184     /**
185      * Sentinel interval to denote the end of an interval list.
186      */
187     protected final Interval intervalEndMarker;
188     public final Range rangeEndMarker;
189     public final boolean detailedAsserts;
190     private final LIRGenerationResult res;
191 
192     protected LinearScan(TargetDescription target, LIRGenerationResult res, MoveFactory spillMoveFactory, RegisterAllocationConfig regAllocConfig, AbstractBlockBase&lt;?&gt;[] sortedBlocks,
193                     boolean neverSpillConstants) {
194         this.ir = res.getLIR();
195         this.res = res;
196         this.debug = ir.getDebug();
197         this.moveFactory = spillMoveFactory;
198         this.frameMapBuilder = res.getFrameMapBuilder();
199         this.sortedBlocks = sortedBlocks;
200         this.registerAttributes = regAllocConfig.getRegisterConfig().getAttributesMap();
201         this.regAllocConfig = regAllocConfig;
202 
203         this.registers = target.arch.getRegisters();
204         this.firstVariableNumber = getRegisters().size();
205         this.numVariables = ir.numVariables();
206         this.blockData = new BlockMap&lt;&gt;(ir.getControlFlowGraph());
207         this.neverSpillConstants = neverSpillConstants;
208         this.rangeEndMarker = new Range(Integer.MAX_VALUE, Integer.MAX_VALUE, null);
209         this.intervalEndMarker = new Interval(Value.ILLEGAL, Interval.END_MARKER_OPERAND_NUMBER, null, rangeEndMarker);
210         this.intervalEndMarker.next = intervalEndMarker;
211         this.detailedAsserts = Assertions.detailedAssertionsEnabled(ir.getOptions());
212     }
213 
214     public LIRGenerationResult getLIRGenerationResult() {
215         return res;
216     }
217 
218     public Interval intervalEndMarker() {
219         return intervalEndMarker;
220     }
221 
222     public OptionValues getOptions() {
223         return ir.getOptions();
224     }
225 
226     public DebugContext getDebug() {
227         return debug;
228     }
229 
230     public int getFirstLirInstructionId(AbstractBlockBase&lt;?&gt; block) {
231         int result = ir.getLIRforBlock(block).get(0).id();
232         assert result &gt;= 0;
233         return result;
234     }
235 
236     public int getLastLirInstructionId(AbstractBlockBase&lt;?&gt; block) {
237         ArrayList&lt;LIRInstruction&gt; instructions = ir.getLIRforBlock(block);
238         int result = instructions.get(instructions.size() - 1).id();
239         assert result &gt;= 0;
240         return result;
241     }
242 
243     public MoveFactory getSpillMoveFactory() {
244         return moveFactory;
245     }
246 
247     protected MoveResolver createMoveResolver() {
248         MoveResolver moveResolver = new MoveResolver(this);
249         assert moveResolver.checkEmpty();
250         return moveResolver;
251     }
252 
253     public static boolean isVariableOrRegister(Value value) {
254         return isVariable(value) || isRegister(value);
255     }
256 
257     /**
258      * Converts an operand (variable or register) to an index in a flat address space covering all
259      * the {@linkplain Variable variables} and {@linkplain RegisterValue registers} being processed
260      * by this allocator.
261      */
262     int operandNumber(Value operand) {
263         if (isRegister(operand)) {
264             int number = asRegister(operand).number;
265             assert number &lt; firstVariableNumber;
266             return number;
267         }
268         assert isVariable(operand) : operand;
269         return firstVariableNumber + ((Variable) operand).index;
270     }
271 
272     /**
273      * Gets the number of operands. This value will increase by 1 for new variable.
274      */
275     int operandSize() {
276         return firstVariableNumber + numVariables;
277     }
278 
279     /**
280      * Gets the highest operand number for a register operand. This value will never change.
281      */
282     int maxRegisterNumber() {
283         return firstVariableNumber - 1;
284     }
285 
286     public BlockData getBlockData(AbstractBlockBase&lt;?&gt; block) {
287         return blockData.get(block);
288     }
289 
290     void initBlockData(AbstractBlockBase&lt;?&gt; block) {
291         blockData.put(block, new BlockData());
292     }
293 
294     static final IntervalPredicate IS_PRECOLORED_INTERVAL = new IntervalPredicate() {
295 
296         @Override
297         public boolean apply(Interval i) {
298             return isRegister(i.operand);
299         }
300     };
301 
302     static final IntervalPredicate IS_VARIABLE_INTERVAL = new IntervalPredicate() {
303 
304         @Override
305         public boolean apply(Interval i) {
306             return isVariable(i.operand);
307         }
308     };
309 
310     static final IntervalPredicate IS_STACK_INTERVAL = new IntervalPredicate() {
311 
312         @Override
313         public boolean apply(Interval i) {
314             return !isRegister(i.operand);
315         }
316     };
317 
318     /**
319      * Gets an object describing the attributes of a given register according to this register
320      * configuration.
321      */
322     public RegisterAttributes attributes(Register reg) {
323         return registerAttributes[reg.number];
324     }
325 
326     void assignSpillSlot(Interval interval) {
327         /*
328          * Assign the canonical spill slot of the parent (if a part of the interval is already
329          * spilled) or allocate a new spill slot.
330          */
331         if (interval.canMaterialize()) {
332             interval.assignLocation(Value.ILLEGAL);
333         } else if (interval.spillSlot() != null) {
334             interval.assignLocation(interval.spillSlot());
335         } else {
336             VirtualStackSlot slot = frameMapBuilder.allocateSpillSlot(interval.kind());
337             interval.setSpillSlot(slot);
338             interval.assignLocation(slot);
339         }
340     }
341 
342     /**
343      * Map from {@linkplain #operandNumber(Value) operand numbers} to intervals.
344      */
345     public Interval[] intervals() {
346         return intervals;
347     }
348 
349     void initIntervals() {
350         intervalsSize = operandSize();
351         intervals = new Interval[intervalsSize + (intervalsSize &gt;&gt; SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT)];
352     }
353 
354     /**
355      * Creates a new interval.
356      *
357      * @param operand the operand for the interval
358      * @return the created interval
359      */
360     Interval createInterval(AllocatableValue operand) {
361         assert isLegal(operand);
362         int operandNumber = operandNumber(operand);
363         Interval interval = new Interval(operand, operandNumber, intervalEndMarker, rangeEndMarker);
364         assert operandNumber &lt; intervalsSize;
365         assert intervals[operandNumber] == null;
366         intervals[operandNumber] = interval;
367         return interval;
368     }
369 
370     /**
371      * Creates an interval as a result of splitting or spilling another interval.
372      *
373      * @param source an interval being split of spilled
374      * @return a new interval derived from {@code source}
375      */
376     Interval createDerivedInterval(Interval source) {
377         if (firstDerivedIntervalIndex == -1) {
378             firstDerivedIntervalIndex = intervalsSize;
379         }
380         if (intervalsSize == intervals.length) {
381             intervals = Arrays.copyOf(intervals, intervals.length + (intervals.length &gt;&gt; SPLIT_INTERVALS_CAPACITY_RIGHT_SHIFT) + 1);
382         }
383         intervalsSize++;
384         assert intervalsSize &lt;= intervals.length;
385         /*
386          * Note that these variables are not managed and must therefore never be inserted into the
387          * LIR
388          */
389         Variable variable = new Variable(source.kind(), numVariables++);
390 
391         Interval interval = createInterval(variable);
392         assert intervals[intervalsSize - 1] == interval;
393         return interval;
394     }
395 
396     // access to block list (sorted in linear scan order)
397     public int blockCount() {
398         return sortedBlocks.length;
399     }
400 
401     public AbstractBlockBase&lt;?&gt; blockAt(int index) {
402         return sortedBlocks[index];
403     }
404 
405     /**
406      * Gets the size of the {@link BlockData#liveIn} and {@link BlockData#liveOut} sets for a basic
407      * block. These sets do not include any operands allocated as a result of creating
408      * {@linkplain #createDerivedInterval(Interval) derived intervals}.
409      */
410     public int liveSetSize() {
411         return firstDerivedIntervalIndex == -1 ? operandSize() : firstDerivedIntervalIndex;
412     }
413 
414     int numLoops() {
415         return ir.getControlFlowGraph().getLoops().size();
416     }
417 
418     Interval intervalFor(int operandNumber) {
419         return intervals[operandNumber];
420     }
421 
422     public Interval intervalFor(Value operand) {
423         int operandNumber = operandNumber(operand);
424         assert operandNumber &lt; intervalsSize;
425         return intervals[operandNumber];
426     }
427 
428     public Interval getOrCreateInterval(AllocatableValue operand) {
429         Interval ret = intervalFor(operand);
430         if (ret == null) {
431             return createInterval(operand);
432         } else {
433             return ret;
434         }
435     }
436 
437     void initOpIdMaps(int numInstructions) {
438         opIdToInstructionMap = new LIRInstruction[numInstructions];
439         opIdToBlockMap = new AbstractBlockBase&lt;?&gt;[numInstructions];
440     }
441 
442     void putOpIdMaps(int index, LIRInstruction op, AbstractBlockBase&lt;?&gt; block) {
443         opIdToInstructionMap[index] = op;
444         opIdToBlockMap[index] = block;
445     }
446 
447     /**
448      * Gets the highest instruction id allocated by this object.
449      */
450     int maxOpId() {
451         assert opIdToInstructionMap.length &gt; 0 : &quot;no operations&quot;;
452         return (opIdToInstructionMap.length - 1) &lt;&lt; 1;
453     }
454 
455     /**
456      * Converts an {@linkplain LIRInstruction#id instruction id} to an instruction index. All LIR
457      * instructions in a method have an index one greater than their linear-scan order predecessor
458      * with the first instruction having an index of 0.
459      */
460     private static int opIdToIndex(int opId) {
461         return opId &gt;&gt; 1;
462     }
463 
464     /**
465      * Retrieves the {@link LIRInstruction} based on its {@linkplain LIRInstruction#id id}.
466      *
467      * @param opId an instruction {@linkplain LIRInstruction#id id}
468      * @return the instruction whose {@linkplain LIRInstruction#id} {@code == id}
469      */
470     public LIRInstruction instructionForId(int opId) {
471         assert isEven(opId) : &quot;opId not even&quot;;
472         LIRInstruction instr = opIdToInstructionMap[opIdToIndex(opId)];
473         assert instr.id() == opId;
474         return instr;
475     }
476 
477     /**
478      * Gets the block containing a given instruction.
479      *
480      * @param opId an instruction {@linkplain LIRInstruction#id id}
481      * @return the block containing the instruction denoted by {@code opId}
482      */
483     public AbstractBlockBase&lt;?&gt; blockForId(int opId) {
484         assert opIdToBlockMap.length &gt; 0 &amp;&amp; opId &gt;= 0 &amp;&amp; opId &lt;= maxOpId() + 1 : &quot;opId out of range&quot;;
485         return opIdToBlockMap[opIdToIndex(opId)];
486     }
487 
488     boolean isBlockBegin(int opId) {
489         return opId == 0 || blockForId(opId) != blockForId(opId - 1);
490     }
491 
492     boolean coversBlockBegin(int opId1, int opId2) {
493         return blockForId(opId1) != blockForId(opId2);
494     }
495 
496     /**
497      * Determines if an {@link LIRInstruction} destroys all caller saved registers.
498      *
499      * @param opId an instruction {@linkplain LIRInstruction#id id}
500      * @return {@code true} if the instruction denoted by {@code id} destroys all caller saved
501      *         registers.
502      */
503     boolean hasCall(int opId) {
504         assert isEven(opId) : &quot;opId not even&quot;;
505         return instructionForId(opId).destroysCallerSavedRegisters();
506     }
507 
508     abstract static class IntervalPredicate {
509 
510         abstract boolean apply(Interval i);
511     }
512 
513     public boolean isProcessed(Value operand) {
514         return !isRegister(operand) || attributes(asRegister(operand)).isAllocatable();
515     }
516 
517     // * Phase 5: actual register allocation
518 
519     private static boolean isSorted(Interval[] intervals) {
520         int from = -1;
521         for (Interval interval : intervals) {
522             assert interval != null;
523             assert from &lt;= interval.from();
524             from = interval.from();
525         }
526         return true;
527     }
528 
529     static Interval addToList(Interval first, Interval prev, Interval interval) {
530         Interval newFirst = first;
531         if (prev != null) {
532             prev.next = interval;
533         } else {
534             newFirst = interval;
535         }
536         return newFirst;
537     }
538 
539     Pair&lt;Interval, Interval&gt; createUnhandledLists(IntervalPredicate isList1, IntervalPredicate isList2) {
540         assert isSorted(sortedIntervals) : &quot;interval list is not sorted&quot;;
541 
542         Interval list1 = intervalEndMarker;
543         Interval list2 = intervalEndMarker;
544 
545         Interval list1Prev = null;
546         Interval list2Prev = null;
547         Interval v;
548 
549         int n = sortedIntervals.length;
550         for (int i = 0; i &lt; n; i++) {
551             v = sortedIntervals[i];
552             if (v == null) {
553                 continue;
554             }
555 
556             if (isList1.apply(v)) {
557                 list1 = addToList(list1, list1Prev, v);
558                 list1Prev = v;
559             } else if (isList2 == null || isList2.apply(v)) {
560                 list2 = addToList(list2, list2Prev, v);
561                 list2Prev = v;
562             }
563         }
564 
565         if (list1Prev != null) {
566             list1Prev.next = intervalEndMarker;
567         }
568         if (list2Prev != null) {
569             list2Prev.next = intervalEndMarker;
570         }
571 
572         assert list1Prev == null || list1Prev.next.isEndMarker() : &quot;linear list ends not with sentinel&quot;;
573         assert list2Prev == null || list2Prev.next.isEndMarker() : &quot;linear list ends not with sentinel&quot;;
574 
575         return Pair.create(list1, list2);
576     }
577 
578     protected void sortIntervalsBeforeAllocation() {
579         int sortedLen = 0;
580         for (Interval interval : intervals) {
581             if (interval != null) {
582                 sortedLen++;
583             }
584         }
585 
586         Interval[] sortedList = new Interval[sortedLen];
587         int sortedIdx = 0;
588         int sortedFromMax = -1;
589 
590         // special sorting algorithm: the original interval-list is almost sorted,
591         // only some intervals are swapped. So this is much faster than a complete QuickSort
592         for (Interval interval : intervals) {
593             if (interval != null) {
594                 int from = interval.from();
595 
596                 if (sortedFromMax &lt;= from) {
597                     sortedList[sortedIdx++] = interval;
598                     sortedFromMax = interval.from();
599                 } else {
600                     // the assumption that the intervals are already sorted failed,
601                     // so this interval must be sorted in manually
602                     int j;
603                     for (j = sortedIdx - 1; j &gt;= 0 &amp;&amp; from &lt; sortedList[j].from(); j--) {
604                         sortedList[j + 1] = sortedList[j];
605                     }
606                     sortedList[j + 1] = interval;
607                     sortedIdx++;
608                 }
609             }
610         }
611         sortedIntervals = sortedList;
612     }
613 
614     void sortIntervalsAfterAllocation() {
615         if (firstDerivedIntervalIndex == -1) {
616             // no intervals have been added during allocation, so sorted list is already up to date
617             return;
618         }
619 
620         Interval[] oldList = sortedIntervals;
621         Interval[] newList = Arrays.copyOfRange(intervals, firstDerivedIntervalIndex, intervalsSize);
622         int oldLen = oldList.length;
623         int newLen = newList.length;
624 
625         // conventional sort-algorithm for new intervals
626         Arrays.sort(newList, (Interval a, Interval b) -&gt; a.from() - b.from());
627 
628         // merge old and new list (both already sorted) into one combined list
629         Interval[] combinedList = new Interval[oldLen + newLen];
630         int oldIdx = 0;
631         int newIdx = 0;
632 
633         while (oldIdx + newIdx &lt; combinedList.length) {
634             if (newIdx &gt;= newLen || (oldIdx &lt; oldLen &amp;&amp; oldList[oldIdx].from() &lt;= newList[newIdx].from())) {
635                 combinedList[oldIdx + newIdx] = oldList[oldIdx];
636                 oldIdx++;
637             } else {
638                 combinedList[oldIdx + newIdx] = newList[newIdx];
639                 newIdx++;
640             }
641         }
642 
643         sortedIntervals = combinedList;
644     }
645 
646     // wrapper for Interval.splitChildAtOpId that performs a bailout in product mode
647     // instead of returning null
648     public Interval splitChildAtOpId(Interval interval, int opId, LIRInstruction.OperandMode mode) {
649         Interval result = interval.getSplitChildAtOpId(opId, mode, this);
650 
651         if (result != null) {
652             if (debug.isLogEnabled()) {
653                 debug.log(&quot;Split child at pos %d of interval %s is %s&quot;, opId, interval, result);
654             }
655             return result;
656         }
657         throw new GraalError(&quot;LinearScan: interval is null&quot;);
658     }
659 
660     static AllocatableValue canonicalSpillOpr(Interval interval) {
661         assert interval.spillSlot() != null : &quot;canonical spill slot not set&quot;;
662         return interval.spillSlot();
663     }
664 
665     boolean isMaterialized(AllocatableValue operand, int opId, OperandMode mode) {
666         Interval interval = intervalFor(operand);
667         assert interval != null : &quot;interval must exist&quot;;
668 
669         if (opId != -1) {
670             /*
671              * Operands are not changed when an interval is split during allocation, so search the
672              * right interval here.
673              */
674             interval = splitChildAtOpId(interval, opId, mode);
675         }
676 
677         return isIllegal(interval.location()) &amp;&amp; interval.canMaterialize();
678     }
679 
680     boolean isCallerSave(Value operand) {
681         return attributes(asRegister(operand)).isCallerSave();
682     }
683 
684     @SuppressWarnings(&quot;try&quot;)
685     protected void allocate(TargetDescription target, LIRGenerationResult lirGenRes, AllocationContext context) {
686         /*
687          * This is the point to enable debug logging for the whole register allocation.
688          */
689         try (Indent indent = debug.logAndIndent(&quot;LinearScan allocate&quot;)) {
690 
691             createLifetimeAnalysisPhase().apply(target, lirGenRes, context);
692 
693             try (DebugContext.Scope s = debug.scope(&quot;AfterLifetimeAnalysis&quot;, (Object) intervals)) {
694                 sortIntervalsBeforeAllocation();
695 
696                 createRegisterAllocationPhase().apply(target, lirGenRes, context);
697 
698                 if (LinearScan.Options.LIROptLSRAOptimizeSpillPosition.getValue(getOptions())) {
699                     createOptimizeSpillPositionPhase().apply(target, lirGenRes, context);
700                 }
701                 createResolveDataFlowPhase().apply(target, lirGenRes, context);
702 
703                 sortIntervalsAfterAllocation();
704 
705                 if (detailedAsserts) {
706                     verify();
707                 }
708                 beforeSpillMoveElimination();
709                 createSpillMoveEliminationPhase().apply(target, lirGenRes, context);
710                 createAssignLocationsPhase().apply(target, lirGenRes, context);
711 
712                 if (detailedAsserts) {
713                     verifyIntervals();
714                 }
715             } catch (Throwable e) {
716                 throw debug.handle(e);
717             }
718         }
719     }
720 
721     protected void beforeSpillMoveElimination() {
722     }
723 
724     protected LinearScanLifetimeAnalysisPhase createLifetimeAnalysisPhase() {
725         return new LinearScanLifetimeAnalysisPhase(this);
726     }
727 
728     protected LinearScanRegisterAllocationPhase createRegisterAllocationPhase() {
729         return new LinearScanRegisterAllocationPhase(this);
730     }
731 
732     protected LinearScanOptimizeSpillPositionPhase createOptimizeSpillPositionPhase() {
733         return new LinearScanOptimizeSpillPositionPhase(this);
734     }
735 
736     protected LinearScanResolveDataFlowPhase createResolveDataFlowPhase() {
737         return new LinearScanResolveDataFlowPhase(this);
738     }
739 
740     protected LinearScanEliminateSpillMovePhase createSpillMoveEliminationPhase() {
741         return new LinearScanEliminateSpillMovePhase(this);
742     }
743 
744     protected LinearScanAssignLocationsPhase createAssignLocationsPhase() {
745         return new LinearScanAssignLocationsPhase(this);
746     }
747 
748     @SuppressWarnings(&quot;try&quot;)
749     public void printIntervals(String label) {
750         if (debug.isLogEnabled()) {
751             try (Indent indent = debug.logAndIndent(&quot;intervals %s&quot;, label)) {
752                 for (Interval interval : intervals) {
753                     if (interval != null) {
754                         debug.log(&quot;%s&quot;, interval.logString(this));
755                     }
756                 }
757 
758                 try (Indent indent2 = debug.logAndIndent(&quot;Basic Blocks&quot;)) {
759                     for (int i = 0; i &lt; blockCount(); i++) {
760                         AbstractBlockBase&lt;?&gt; block = blockAt(i);
761                         debug.log(&quot;B%d [%d, %d, %s] &quot;, block.getId(), getFirstLirInstructionId(block), getLastLirInstructionId(block), block.getLoop());
762                     }
763                 }
764             }
765         }
766         debug.dump(DebugContext.VERBOSE_LEVEL, new LinearScanIntervalDumper(Arrays.copyOf(intervals, intervalsSize)), label);
767     }
768 
769     boolean verify() {
770         // (check that all intervals have a correct register and that no registers are overwritten)
771         verifyIntervals();
772 
773         verifyRegisters();
774 
775         debug.log(&quot;no errors found&quot;);
776 
777         return true;
778     }
779 
780     @SuppressWarnings(&quot;try&quot;)
781     private void verifyRegisters() {
782         // Enable this logging to get output for the verification process.
783         try (Indent indent = debug.logAndIndent(&quot;verifying register allocation&quot;)) {
784             RegisterVerifier verifier = new RegisterVerifier(this);
785             verifier.verify(blockAt(0));
786         }
787     }
788 
789     @SuppressWarnings(&quot;try&quot;)
790     protected void verifyIntervals() {
791         try (Indent indent = debug.logAndIndent(&quot;verifying intervals&quot;)) {
792             int len = intervalsSize;
793 
794             for (int i = 0; i &lt; len; i++) {
795                 Interval i1 = intervals[i];
796                 if (i1 == null) {
797                     continue;
798                 }
799 
800                 i1.checkSplitChildren();
801 
802                 if (i1.operandNumber != i) {
803                     debug.log(&quot;Interval %d is on position %d in list&quot;, i1.operandNumber, i);
804                     debug.log(i1.logString(this));
805                     throw new GraalError(&quot;&quot;);
806                 }
807 
808                 if (isVariable(i1.operand) &amp;&amp; i1.kind().equals(LIRKind.Illegal)) {
809                     debug.log(&quot;Interval %d has no type assigned&quot;, i1.operandNumber);
810                     debug.log(i1.logString(this));
811                     throw new GraalError(&quot;&quot;);
812                 }
813 
814                 if (i1.location() == null) {
815                     debug.log(&quot;Interval %d has no register assigned&quot;, i1.operandNumber);
816                     debug.log(i1.logString(this));
817                     throw new GraalError(&quot;&quot;);
818                 }
819 
820                 if (i1.first().isEndMarker()) {
821                     debug.log(&quot;Interval %d has no Range&quot;, i1.operandNumber);
822                     debug.log(i1.logString(this));
823                     throw new GraalError(&quot;&quot;);
824                 }
825 
826                 for (Range r = i1.first(); !r.isEndMarker(); r = r.next) {
827                     if (r.from &gt;= r.to) {
828                         debug.log(&quot;Interval %d has zero length range&quot;, i1.operandNumber);
829                         debug.log(i1.logString(this));
830                         throw new GraalError(&quot;&quot;);
831                     }
832                 }
833 
834                 for (int j = i + 1; j &lt; len; j++) {
835                     Interval i2 = intervals[j];
836                     if (i2 == null) {
837                         continue;
838                     }
839 
840                     // special intervals that are created in MoveResolver
841                     // . ignore them because the range information has no meaning there
842                     if (i1.from() == 1 &amp;&amp; i1.to() == 2) {
843                         continue;
844                     }
845                     if (i2.from() == 1 &amp;&amp; i2.to() == 2) {
846                         continue;
847                     }
848                     Value l1 = i1.location();
849                     Value l2 = i2.location();
850                     if (i1.intersects(i2) &amp;&amp; !isIllegal(l1) &amp;&amp; (l1.equals(l2))) {
851                         throw GraalError.shouldNotReachHere(String.format(&quot;Intervals %d and %d overlap and have the same register assigned\n%s\n%s&quot;, i1.operandNumber, i2.operandNumber,
852                                         i1.logString(this), i2.logString(this)));
853                     }
854                 }
855             }
856         }
857     }
858 
859     class CheckConsumer implements ValueConsumer {
860 
861         boolean ok;
862         Interval curInterval;
863 
864         @Override
865         public void visitValue(Value operand, OperandMode mode, EnumSet&lt;OperandFlag&gt; flags) {
866             if (isRegister(operand)) {
867                 if (intervalFor(operand) == curInterval) {
868                     ok = true;
869                 }
870             }
871         }
872     }
873 
874     @SuppressWarnings(&quot;try&quot;)
875     void verifyNoOopsInFixedIntervals() {
876         try (Indent indent = debug.logAndIndent(&quot;verifying that no oops are in fixed intervals *&quot;)) {
877             CheckConsumer checkConsumer = new CheckConsumer();
878 
879             Interval fixedIntervals;
880             Interval otherIntervals;
881             fixedIntervals = createUnhandledLists(IS_PRECOLORED_INTERVAL, null).getLeft();
882             // to ensure a walking until the last instruction id, add a dummy interval
883             // with a high operation id
884             otherIntervals = new Interval(Value.ILLEGAL, -1, intervalEndMarker, rangeEndMarker);
885             otherIntervals.addRange(Integer.MAX_VALUE - 2, Integer.MAX_VALUE - 1);
886             IntervalWalker iw = new IntervalWalker(this, fixedIntervals, otherIntervals);
887 
888             for (AbstractBlockBase&lt;?&gt; block : sortedBlocks) {
889                 ArrayList&lt;LIRInstruction&gt; instructions = ir.getLIRforBlock(block);
890 
891                 for (int j = 0; j &lt; instructions.size(); j++) {
892                     LIRInstruction op = instructions.get(j);
893 
894                     if (op.hasState()) {
895                         iw.walkBefore(op.id());
896                         boolean checkLive = true;
897 
898                         /*
899                          * Make sure none of the fixed registers is live across an oopmap since we
900                          * can&#39;t handle that correctly.
901                          */
902                         if (checkLive) {
903                             for (Interval interval = iw.activeLists.get(RegisterBinding.Fixed); !interval.isEndMarker(); interval = interval.next) {
904                                 if (interval.currentTo() &gt; op.id() + 1) {
905                                     /*
906                                      * This interval is live out of this op so make sure that this
907                                      * interval represents some value that&#39;s referenced by this op
908                                      * either as an input or output.
909                                      */
910                                     checkConsumer.curInterval = interval;
911                                     checkConsumer.ok = false;
912 
913                                     op.visitEachInput(checkConsumer);
914                                     op.visitEachAlive(checkConsumer);
915                                     op.visitEachTemp(checkConsumer);
916                                     op.visitEachOutput(checkConsumer);
917 
918                                     assert checkConsumer.ok : &quot;fixed intervals should never be live across an oopmap point&quot;;
919                                 }
920                             }
921                         }
922                     }
923                 }
924             }
925         }
926     }
927 
928     public LIR getLIR() {
929         return ir;
930     }
931 
932     public FrameMapBuilder getFrameMapBuilder() {
933         return frameMapBuilder;
934     }
935 
936     public AbstractBlockBase&lt;?&gt;[] sortedBlocks() {
937         return sortedBlocks;
938     }
939 
940     public RegisterArray getRegisters() {
941         return registers;
942     }
943 
944     public RegisterAllocationConfig getRegisterAllocationConfig() {
945         return regAllocConfig;
946     }
947 
948     public boolean callKillsRegisters() {
949         return regAllocConfig.getRegisterConfig().areAllAllocatableRegistersCallerSaved();
950     }
951 
952     boolean neverSpillConstants() {
953         return neverSpillConstants;
954     }
955 
956 }
    </pre>
  </body>
</html>
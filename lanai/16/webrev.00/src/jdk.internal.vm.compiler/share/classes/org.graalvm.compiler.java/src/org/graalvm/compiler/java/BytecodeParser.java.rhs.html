<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static java.lang.String.format;
  28 import static java.lang.reflect.Modifier.STATIC;
  29 import static java.lang.reflect.Modifier.SYNCHRONIZED;
  30 import static jdk.vm.ci.code.BytecodeFrame.UNKNOWN_BCI;
  31 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;
  32 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  33 import static jdk.vm.ci.meta.DeoptimizationAction.None;
  34 import static jdk.vm.ci.meta.DeoptimizationReason.ClassCastException;
  35 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  36 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
  37 import static jdk.vm.ci.meta.DeoptimizationReason.UnreachedCode;
  38 import static jdk.vm.ci.meta.DeoptimizationReason.Unresolved;
  39 import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  40 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  41 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  42 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
  43 import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;
  44 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;
  46 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;
  47 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;
  48 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;
  49 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  50 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  51 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
  52 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;
  53 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;
  54 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;
  55 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;
  57 import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
  58 import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
  59 import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;
  60 import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;
  61 import static org.graalvm.compiler.bytecode.Bytecodes.BREAKPOINT;
  62 import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
  63 import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
  64 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
  65 import static org.graalvm.compiler.bytecode.Bytecodes.D2F;
  66 import static org.graalvm.compiler.bytecode.Bytecodes.D2I;
  67 import static org.graalvm.compiler.bytecode.Bytecodes.D2L;
  68 import static org.graalvm.compiler.bytecode.Bytecodes.DADD;
  69 import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
  70 import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;
  71 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPG;
  72 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPL;
  73 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_0;
  74 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_1;
  75 import static org.graalvm.compiler.bytecode.Bytecodes.DDIV;
  76 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;
  77 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_0;
  78 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_1;
  79 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_2;
  80 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_3;
  81 import static org.graalvm.compiler.bytecode.Bytecodes.DMUL;
  82 import static org.graalvm.compiler.bytecode.Bytecodes.DNEG;
  83 import static org.graalvm.compiler.bytecode.Bytecodes.DREM;
  84 import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
  85 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;
  86 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_0;
  87 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_1;
  88 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_2;
  89 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_3;
  90 import static org.graalvm.compiler.bytecode.Bytecodes.DSUB;
  91 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
  92 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
  93 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
  94 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
  95 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
  96 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
  97 import static org.graalvm.compiler.bytecode.Bytecodes.F2D;
  98 import static org.graalvm.compiler.bytecode.Bytecodes.F2I;
  99 import static org.graalvm.compiler.bytecode.Bytecodes.F2L;
 100 import static org.graalvm.compiler.bytecode.Bytecodes.FADD;
 101 import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
 102 import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;
 103 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPG;
 104 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPL;
 105 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_0;
 106 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_1;
 107 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_2;
 108 import static org.graalvm.compiler.bytecode.Bytecodes.FDIV;
 109 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;
 110 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_0;
 111 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_1;
 112 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_2;
 113 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_3;
 114 import static org.graalvm.compiler.bytecode.Bytecodes.FMUL;
 115 import static org.graalvm.compiler.bytecode.Bytecodes.FNEG;
 116 import static org.graalvm.compiler.bytecode.Bytecodes.FREM;
 117 import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;
 118 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;
 119 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_0;
 120 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_1;
 121 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_2;
 122 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_3;
 123 import static org.graalvm.compiler.bytecode.Bytecodes.FSUB;
 124 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
 125 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
 126 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
 127 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
 128 import static org.graalvm.compiler.bytecode.Bytecodes.I2B;
 129 import static org.graalvm.compiler.bytecode.Bytecodes.I2C;
 130 import static org.graalvm.compiler.bytecode.Bytecodes.I2D;
 131 import static org.graalvm.compiler.bytecode.Bytecodes.I2F;
 132 import static org.graalvm.compiler.bytecode.Bytecodes.I2L;
 133 import static org.graalvm.compiler.bytecode.Bytecodes.I2S;
 134 import static org.graalvm.compiler.bytecode.Bytecodes.IADD;
 135 import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;
 136 import static org.graalvm.compiler.bytecode.Bytecodes.IAND;
 137 import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;
 138 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_0;
 139 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_1;
 140 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_2;
 141 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_3;
 142 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_4;
 143 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_5;
 144 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_M1;
 145 import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
 146 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
 147 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
 148 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
 149 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
 150 import static org.graalvm.compiler.bytecode.Bytecodes.IFLT;
 151 import static org.graalvm.compiler.bytecode.Bytecodes.IFNE;
 152 import static org.graalvm.compiler.bytecode.Bytecodes.IFNONNULL;
 153 import static org.graalvm.compiler.bytecode.Bytecodes.IFNULL;
 154 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPEQ;
 155 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPNE;
 156 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPEQ;
 157 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
 158 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
 159 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
 160 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
 161 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
 162 import static org.graalvm.compiler.bytecode.Bytecodes.IINC;
 163 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;
 164 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_0;
 165 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_1;
 166 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_2;
 167 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_3;
 168 import static org.graalvm.compiler.bytecode.Bytecodes.IMUL;
 169 import static org.graalvm.compiler.bytecode.Bytecodes.INEG;
 170 import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;
 171 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
 172 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
 173 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
 174 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
 175 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
 176 import static org.graalvm.compiler.bytecode.Bytecodes.IOR;
 177 import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
 178 import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;
 179 import static org.graalvm.compiler.bytecode.Bytecodes.ISHL;
 180 import static org.graalvm.compiler.bytecode.Bytecodes.ISHR;
 181 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;
 182 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_0;
 183 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_1;
 184 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_2;
 185 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_3;
 186 import static org.graalvm.compiler.bytecode.Bytecodes.ISUB;
 187 import static org.graalvm.compiler.bytecode.Bytecodes.IUSHR;
 188 import static org.graalvm.compiler.bytecode.Bytecodes.IXOR;
 189 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
 190 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
 191 import static org.graalvm.compiler.bytecode.Bytecodes.L2D;
 192 import static org.graalvm.compiler.bytecode.Bytecodes.L2F;
 193 import static org.graalvm.compiler.bytecode.Bytecodes.L2I;
 194 import static org.graalvm.compiler.bytecode.Bytecodes.LADD;
 195 import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;
 196 import static org.graalvm.compiler.bytecode.Bytecodes.LAND;
 197 import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;
 198 import static org.graalvm.compiler.bytecode.Bytecodes.LCMP;
 199 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_0;
 200 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_1;
 201 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
 202 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
 203 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
 204 import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;
 205 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;
 206 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_0;
 207 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_1;
 208 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_2;
 209 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_3;
 210 import static org.graalvm.compiler.bytecode.Bytecodes.LMUL;
 211 import static org.graalvm.compiler.bytecode.Bytecodes.LNEG;
 212 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
 213 import static org.graalvm.compiler.bytecode.Bytecodes.LOR;
 214 import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
 215 import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;
 216 import static org.graalvm.compiler.bytecode.Bytecodes.LSHL;
 217 import static org.graalvm.compiler.bytecode.Bytecodes.LSHR;
 218 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;
 219 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_0;
 220 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_1;
 221 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_2;
 222 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_3;
 223 import static org.graalvm.compiler.bytecode.Bytecodes.LSUB;
 224 import static org.graalvm.compiler.bytecode.Bytecodes.LUSHR;
 225 import static org.graalvm.compiler.bytecode.Bytecodes.LXOR;
 226 import static org.graalvm.compiler.bytecode.Bytecodes.MONITORENTER;
 227 import static org.graalvm.compiler.bytecode.Bytecodes.MONITOREXIT;
 228 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
 229 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
 230 import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;
 231 import static org.graalvm.compiler.bytecode.Bytecodes.NOP;
 232 import static org.graalvm.compiler.bytecode.Bytecodes.POP;
 233 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
 234 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
 235 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
 236 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
 237 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 238 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 239 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
 240 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;
 241 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
 242 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
 243 import static org.graalvm.compiler.bytecode.Bytecodes.nameOf;
 244 import static org.graalvm.compiler.core.common.GraalOptions.DeoptALot;
 245 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 246 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
 247 import static org.graalvm.compiler.core.common.GraalOptions.PrintProfilingInformation;
 248 import static org.graalvm.compiler.core.common.GraalOptions.StressExplicitExceptionCode;
 249 import static org.graalvm.compiler.core.common.GraalOptions.StressInvokeWithExceptionNode;
 250 import static org.graalvm.compiler.core.common.type.StampFactory.objectNonNull;
 251 import static org.graalvm.compiler.debug.GraalError.guarantee;
 252 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
 253 import static org.graalvm.compiler.java.BytecodeParserOptions.InlinePartialIntrinsicExitDuringParsing;
 254 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceBytecodeParserLevel;
 255 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceInlineDuringParsing;
 256 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceParserPlugins;
 257 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_FAST_PATH_PROBABILITY;
 258 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_SLOW_PATH_PROBABILITY;
 259 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_DURING_PARSING;
 260 import static org.graalvm.compiler.nodes.type.StampTool.isPointerNonNull;
 261 
 262 import java.util.ArrayList;
 263 import java.util.Collections;
 264 import java.util.Comparator;
 265 import java.util.Formatter;
 266 import java.util.List;
 267 import java.util.function.Supplier;
 268 
 269 import jdk.internal.vm.compiler.collections.EconomicMap;
 270 import jdk.internal.vm.compiler.collections.Equivalence;
 271 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
 272 import org.graalvm.compiler.api.replacements.Fold;
 273 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 274 import org.graalvm.compiler.api.replacements.Snippet;
 275 import org.graalvm.compiler.bytecode.Bytecode;
 276 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
 277 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 278 import org.graalvm.compiler.bytecode.BytecodeProvider;
 279 import org.graalvm.compiler.bytecode.BytecodeStream;
 280 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 281 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 282 import org.graalvm.compiler.bytecode.Bytecodes;
 283 import org.graalvm.compiler.bytecode.Bytes;
 284 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 285 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecodeProvider;
 286 import org.graalvm.compiler.core.common.GraalOptions;
 287 import org.graalvm.compiler.core.common.PermanentBailoutException;
 288 import org.graalvm.compiler.core.common.RetryableBailoutException;
 289 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 290 import org.graalvm.compiler.core.common.calc.Condition;
 291 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
 292 import org.graalvm.compiler.core.common.calc.FloatConvert;
 293 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 294 import org.graalvm.compiler.core.common.type.IntegerStamp;
 295 import org.graalvm.compiler.core.common.type.ObjectStamp;
 296 import org.graalvm.compiler.core.common.type.Stamp;
 297 import org.graalvm.compiler.core.common.type.StampFactory;
 298 import org.graalvm.compiler.core.common.type.StampPair;
 299 import org.graalvm.compiler.core.common.type.TypeReference;
 300 import org.graalvm.compiler.core.common.util.Util;
 301 import org.graalvm.compiler.debug.Assertions;
 302 import org.graalvm.compiler.debug.CounterKey;
 303 import org.graalvm.compiler.debug.DebugCloseable;
 304 import org.graalvm.compiler.debug.DebugContext;
 305 import org.graalvm.compiler.debug.DebugOptions;
 306 import org.graalvm.compiler.debug.GraalError;
 307 import org.graalvm.compiler.debug.Indent;
 308 import org.graalvm.compiler.debug.MethodFilter;
 309 import org.graalvm.compiler.debug.TTY;
 310 import org.graalvm.compiler.graph.Graph.Mark;
 311 import org.graalvm.compiler.graph.Node;
 312 import org.graalvm.compiler.graph.NodeSourcePosition;
 313 import org.graalvm.compiler.graph.iterators.NodeIterable;
 314 import org.graalvm.compiler.java.BciBlockMapping.BciBlock;
 315 import org.graalvm.compiler.java.BciBlockMapping.ExceptionDispatchBlock;
 316 import org.graalvm.compiler.nodes.AbstractBeginNode;
 317 import org.graalvm.compiler.nodes.AbstractMergeNode;
 318 import org.graalvm.compiler.nodes.BeginNode;
 319 import org.graalvm.compiler.nodes.BeginStateSplitNode;
 320 import org.graalvm.compiler.nodes.CallTargetNode;
 321 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 322 import org.graalvm.compiler.nodes.ConstantNode;
 323 import org.graalvm.compiler.nodes.ControlSplitNode;
 324 import org.graalvm.compiler.nodes.DeoptimizeNode;
 325 import org.graalvm.compiler.nodes.EndNode;
 326 import org.graalvm.compiler.nodes.EntryMarkerNode;
 327 import org.graalvm.compiler.nodes.EntryProxyNode;
 328 import org.graalvm.compiler.nodes.FieldLocationIdentity;
 329 import org.graalvm.compiler.nodes.FixedGuardNode;
 330 import org.graalvm.compiler.nodes.FixedNode;
 331 import org.graalvm.compiler.nodes.FixedWithNextNode;
 332 import org.graalvm.compiler.nodes.FrameState;
 333 import org.graalvm.compiler.nodes.FullInfopointNode;
 334 import org.graalvm.compiler.nodes.IfNode;
 335 import org.graalvm.compiler.nodes.InliningLog;
 336 import org.graalvm.compiler.nodes.Invoke;
 337 import org.graalvm.compiler.nodes.InvokeNode;
 338 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 339 import org.graalvm.compiler.nodes.KillingBeginNode;
 340 import org.graalvm.compiler.nodes.LogicConstantNode;
 341 import org.graalvm.compiler.nodes.LogicNegationNode;
 342 import org.graalvm.compiler.nodes.LogicNode;
 343 import org.graalvm.compiler.nodes.LoopBeginNode;
 344 import org.graalvm.compiler.nodes.LoopEndNode;
 345 import org.graalvm.compiler.nodes.LoopExitNode;
 346 import org.graalvm.compiler.nodes.MergeNode;
 347 import org.graalvm.compiler.nodes.NodeView;
 348 import org.graalvm.compiler.nodes.ParameterNode;
 349 import org.graalvm.compiler.nodes.PiNode;
 350 import org.graalvm.compiler.nodes.ReturnNode;
 351 import org.graalvm.compiler.nodes.StartNode;
 352 import org.graalvm.compiler.nodes.StateSplit;
 353 import org.graalvm.compiler.nodes.StructuredGraph;
 354 import org.graalvm.compiler.nodes.UnwindNode;
 355 import org.graalvm.compiler.nodes.ValueNode;
 356 import org.graalvm.compiler.nodes.ValuePhiNode;
 357 import org.graalvm.compiler.nodes.calc.AddNode;
 358 import org.graalvm.compiler.nodes.calc.AndNode;
 359 import org.graalvm.compiler.nodes.calc.CompareNode;
 360 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 361 import org.graalvm.compiler.nodes.calc.FloatConvertNode;
 362 import org.graalvm.compiler.nodes.calc.FloatDivNode;
 363 import org.graalvm.compiler.nodes.calc.FloatNormalizeCompareNode;
 364 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 365 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
 366 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
 367 import org.graalvm.compiler.nodes.calc.IntegerNormalizeCompareNode;
 368 import org.graalvm.compiler.nodes.calc.IsNullNode;
 369 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 370 import org.graalvm.compiler.nodes.calc.MulNode;
 371 import org.graalvm.compiler.nodes.calc.NarrowNode;
 372 import org.graalvm.compiler.nodes.calc.NegateNode;
 373 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
 374 import org.graalvm.compiler.nodes.calc.OrNode;
 375 import org.graalvm.compiler.nodes.calc.RemNode;
 376 import org.graalvm.compiler.nodes.calc.RightShiftNode;
 377 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 378 import org.graalvm.compiler.nodes.calc.SignedDivNode;
 379 import org.graalvm.compiler.nodes.calc.SignedRemNode;
 380 import org.graalvm.compiler.nodes.calc.SubNode;
 381 import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
 382 import org.graalvm.compiler.nodes.calc.XorNode;
 383 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 384 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 385 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
 386 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
 387 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
 388 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 389 import org.graalvm.compiler.nodes.extended.GuardingNode;
 390 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
 391 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 392 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 393 import org.graalvm.compiler.nodes.extended.MembarNode;
 394 import org.graalvm.compiler.nodes.extended.StateSplitProxyNode;
 395 import org.graalvm.compiler.nodes.graphbuilderconf.ClassInitializationPlugin;
 396 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 397 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.BytecodeExceptionMode;
 398 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 399 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 400 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo;
 401 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 402 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 403 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.InvocationPluginReceiver;
 404 import org.graalvm.compiler.nodes.graphbuilderconf.InvokeDynamicPlugin;
 405 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
 406 import org.graalvm.compiler.nodes.graphbuilderconf.ProfilingPlugin;
 407 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 408 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 409 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 410 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 411 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 412 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 413 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 414 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 415 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 416 import org.graalvm.compiler.nodes.java.MonitorExitNode;
 417 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 418 import org.graalvm.compiler.nodes.java.NewArrayNode;
 419 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 420 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 421 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 422 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 423 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 424 import org.graalvm.compiler.nodes.spi.CoreProviders;
 425 import org.graalvm.compiler.nodes.spi.Replacements;
 426 import org.graalvm.compiler.nodes.spi.StampProvider;
 427 import org.graalvm.compiler.nodes.type.StampTool;
 428 import org.graalvm.compiler.nodes.util.GraphUtil;
 429 import org.graalvm.compiler.options.OptionValues;
 430 import org.graalvm.compiler.phases.OptimisticOptimizations;
 431 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 432 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 433 import jdk.internal.vm.compiler.word.LocationIdentity;
 434 
 435 import jdk.vm.ci.code.BailoutException;
 436 import jdk.vm.ci.code.BytecodeFrame;
 437 import jdk.vm.ci.code.CodeUtil;
 438 import jdk.vm.ci.code.site.InfopointReason;
 439 import jdk.vm.ci.meta.Constant;
 440 import jdk.vm.ci.meta.ConstantPool;
 441 import jdk.vm.ci.meta.ConstantReflectionProvider;
 442 import jdk.vm.ci.meta.DeoptimizationAction;
 443 import jdk.vm.ci.meta.DeoptimizationReason;
 444 import jdk.vm.ci.meta.JavaConstant;
 445 import jdk.vm.ci.meta.JavaField;
 446 import jdk.vm.ci.meta.JavaKind;
 447 import jdk.vm.ci.meta.JavaMethod;
 448 import jdk.vm.ci.meta.JavaType;
 449 import jdk.vm.ci.meta.JavaTypeProfile;
 450 import jdk.vm.ci.meta.LineNumberTable;
 451 import jdk.vm.ci.meta.MetaAccessProvider;
 452 import jdk.vm.ci.meta.ProfilingInfo;
 453 import jdk.vm.ci.meta.RawConstant;
 454 import jdk.vm.ci.meta.ResolvedJavaField;
 455 import jdk.vm.ci.meta.ResolvedJavaMethod;
 456 import jdk.vm.ci.meta.ResolvedJavaType;
 457 import jdk.vm.ci.meta.Signature;
 458 import jdk.vm.ci.meta.TriState;
 459 
 460 /**
 461  * The {@code GraphBuilder} class parses the bytecode of a method and builds the IR graph.
 462  */
 463 public class BytecodeParser implements GraphBuilderContext {
 464 
 465     /**
 466      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 467      * to trace the bytecode instructions as they are parsed.
 468      */
 469     public static final int TRACELEVEL_INSTRUCTIONS = 1;
 470 
 471     /**
 472      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 473      * to emit the frame state for each traced bytecode instruction.
 474      */
 475     public static final int TRACELEVEL_STATE = 2;
 476 
 477     /**
 478      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 479      * to emit the block map for each traced method.
 480      */
 481     public static final int TRACELEVEL_BLOCKMAP = 3;
 482 
 483     /**
 484      * Meters the number of actual bytecodes parsed.
 485      */
 486     public static final CounterKey BytecodesParsed = DebugContext.counter(&quot;BytecodesParsed&quot;);
 487 
 488     protected static final CounterKey EXPLICIT_EXCEPTIONS = DebugContext.counter(&quot;ExplicitExceptions&quot;);
 489 
 490     /**
 491      * A scoped object for tasks to be performed after inlining during parsing such as processing
 492      * {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frames states.
 493      */
 494     static class InliningScope implements AutoCloseable {
 495         final ResolvedJavaMethod callee;
 496         FrameState stateBefore;
 497         final Mark mark;
 498         final BytecodeParser parser;
 499         List&lt;ReturnToCallerData&gt; returnDataList;
 500 
 501         /**
 502          * Creates a scope for root parsing an intrinsic.
 503          *
 504          * @param parser the parsing context of the intrinsic
 505          */
 506         InliningScope(BytecodeParser parser) {
 507             this.parser = parser;
 508             assert parser.parent == null;
 509             assert parser.bci() == 0;
 510             mark = null;
 511             callee = null;
 512         }
 513 
 514         /**
 515          * Creates a scope for graph builder inlining.
 516          *
 517          * @param parser the parsing context of the (non-intrinsic) method calling the intrinsic
 518          * @param args the arguments to the call
 519          */
 520         InliningScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {
 521             this.callee = callee;
 522             assert !parser.parsingIntrinsic();
 523             this.parser = parser;
 524             mark = parser.getGraph().getMark();
 525             JavaKind[] argSlotKinds = callee.getSignature().toParameterKinds(!callee.isStatic());
 526             stateBefore = parser.frameState.create(parser.bci(), parser.getNonIntrinsicAncestor(), false, argSlotKinds, args);
 527         }
 528 
 529         @Override
 530         public void close() {
 531             processPlaceholderFrameStates(false);
 532         }
 533 
 534         /**
 535          * Fixes up the {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frame states
 536          * added to the graph while parsing/inlining the intrinsic for which this object exists.
 537          */
 538         protected void processPlaceholderFrameStates(boolean isCompilationRoot) {
 539             StructuredGraph graph = parser.getGraph();
 540             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processPlaceholderFrameStates in %s&quot;, parser.method);
 541             for (Node node : graph.getNewNodes(mark)) {
 542                 if (node instanceof FrameState) {
 543                     FrameState frameState = (FrameState) node;
 544                     if (BytecodeFrame.isPlaceholderBci(frameState.bci)) {
 545                         if (frameState.bci == BytecodeFrame.AFTER_BCI) {
 546                             if (parser.getInvokeReturnType() == null) {
 547                                 // A frame state in a root compiled intrinsic.
 548                                 assert isCompilationRoot;
 549                                 FrameState newFrameState = graph.add(new FrameState(BytecodeFrame.INVALID_FRAMESTATE_BCI));
 550                                 frameState.replaceAndDelete(newFrameState);
 551                             } else {
 552                                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
 553                                 FrameStateBuilder frameStateBuilder = parser.frameState;
 554                                 assert !frameState.rethrowException();
 555                                 if (frameState.stackSize() != 0) {
 556                                     ValueNode returnVal = frameState.stackAt(0);
 557                                     if (!ReturnToCallerData.containsReturnValue(returnDataList, returnVal)) {
 558                                         throw new GraalError(&quot;AFTER_BCI frame state within a sub-parse has a non-return value on the stack: %s&quot;, returnVal);
 559                                     }
 560 
 561                                     // Swap the top-of-stack value with the return value
 562                                     ValueNode tos = frameStateBuilder.pop(returnKind);
 563                                     assert tos.getStackKind() == returnVal.getStackKind();
 564                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), parser.getNonIntrinsicAncestor(), false, new JavaKind[]{returnKind},
 565                                                     new ValueNode[]{returnVal});
 566                                     frameState.replaceAndDelete(newFrameState);
 567                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 568                                     frameStateBuilder.push(returnKind, tos);
 569                                 } else if (returnKind != JavaKind.Void) {
 570                                     handleReturnMismatch(graph, frameState);
 571                                 } else {
 572                                     // An intrinsic for a void method.
 573                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), null);
 574                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 575                                     frameState.replaceAndDelete(newFrameState);
 576                                 }
 577                             }
 578                         } else if (frameState.bci == BytecodeFrame.BEFORE_BCI) {
 579                             if (stateBefore == null) {
 580                                 stateBefore = graph.start().stateAfter();
 581                             }
 582                             if (stateBefore != frameState) {
 583                                 frameState.replaceAndDelete(stateBefore);
 584                             }
 585                         } else if (frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI || (frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; !callee.isSynchronized())) {
 586                             // This is a frame state for the entry point to an exception
 587                             // dispatcher in an intrinsic. For example, the invoke denoting
 588                             // a partial intrinsic exit will have an edge to such a
 589                             // dispatcher if the profile for the original invoke being
 590                             // intrinsified indicates an exception was seen. As per JVM
 591                             // bytecode semantics, the interpreter expects a single
 592                             // value on the stack on entry to an exception handler,
 593                             // namely the exception object.
 594                             assert frameState.rethrowException();
 595                             ValueNode exceptionValue = frameState.stackAt(0);
 596                             FrameStateBuilder dispatchState = parser.frameState.copy();
 597                             dispatchState.clearStack();
 598                             dispatchState.push(JavaKind.Object, exceptionValue);
 599                             dispatchState.setRethrowException(true);
 600                             for (Node usage : frameState.usages()) {
 601                                 FrameState newFrameState = dispatchState.create(parser.bci(), (StateSplit) usage);
 602                                 frameState.replaceAndDelete(newFrameState);
 603                                 newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 604                             }
 605                         } else if (frameState.bci == BytecodeFrame.UNWIND_BCI) {
 606                             if (graph.getGuardsStage().allowsFloatingGuards()) {
 607                                 throw GraalError.shouldNotReachHere(&quot;Cannot handle this UNWIND_BCI&quot;);
 608                             }
 609                             // hope that by construction, there are no fixed guard after this unwind
 610                             // and before an other state split
 611                         } else {
 612                             assert frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI : frameState.bci;
 613                         }
 614                     }
 615                 }
 616             }
 617             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processPlaceholderFrameStates in %s&quot;, parser.method);
 618         }
 619 
 620         @SuppressWarnings(&quot;unused&quot;)
 621         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {
 622             throw GraalError.shouldNotReachHere(&quot;Unexpected return kind mismatch in &quot; + parser.method + &quot; at FS &quot; + fs);
 623         }
 624     }
 625 
 626     static class IntrinsicScope extends InliningScope {
 627         ArrayList&lt;StateSplit&gt; invalidStateUsers;
 628 
 629         IntrinsicScope(BytecodeParser parser) {
 630             super(parser);
 631         }
 632 
 633         IntrinsicScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {
 634             super(parser, callee, args);
 635         }
 636 
 637         @SuppressWarnings(&quot;unlikely-arg-type&quot;)
 638         @Override
 639         public void close() {
 640             IntrinsicContext intrinsic = parser.intrinsicContext;
 641             boolean isRootCompilation;
 642             if (intrinsic != null) {
 643                 if (intrinsic.isPostParseInlined()) {
 644                     return;
 645                 }
 646                 isRootCompilation = intrinsic.isCompilationRoot();
 647             } else {
 648                 isRootCompilation = false;
 649             }
 650             processPlaceholderFrameStates(isRootCompilation);
 651             if (invalidStateUsers != null) {
 652                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
 653                 ValueNode returnValue = parser.frameState.pop(returnKind);
 654                 if (invalidStateUsers.size() == 1 &amp;&amp; invalidStateUsers.get(0) == parser.lastInstr) {
 655                     updateSplitFrameState(invalidStateUsers.get(0), returnKind, returnValue);
 656                 } else if (parser.lastInstr instanceof MergeNode) {
 657                     ValuePhiNode returnValues = null;
 658                     MergeNode merge = (MergeNode) parser.lastInstr;
 659 
 660                     if (returnValue instanceof ValuePhiNode &amp;&amp; ((ValuePhiNode) returnValue).merge() == parser.lastInstr) {
 661                         returnValues = (ValuePhiNode) returnValue;
 662                     }
 663                     if (invalidStateUsers.remove(merge)) {
 664                         updateSplitFrameState(merge, returnKind, returnValue);
 665                     }
 666                     for (EndNode pred : merge.cfgPredecessors()) {
 667                         Node lastPred = pred.predecessor();
 668                         if (invalidStateUsers.remove(lastPred)) {
 669                             ValueNode predReturnValue = returnValue;
 670                             if (returnValues != null) {
 671                                 int index = merge.phiPredecessorIndex(pred);
 672                                 predReturnValue = ((ValuePhiNode) returnValue).valueAt(index);
 673                             }
 674                             updateSplitFrameState((StateSplit) lastPred, returnKind, predReturnValue);
 675                         }
 676                     }
 677                     if (invalidStateUsers.size() != 0) {
 678                         throw new GraalError(&quot;unexpected StateSplit above merge %s&quot;, invalidStateUsers);
 679                     }
 680                 } else {
 681                     throw new GraalError(&quot;unexpected node between return StateSplit and last instruction %s&quot;, parser.lastInstr);
 682                 }
 683                 // Restore the original return value
 684                 parser.frameState.push(returnKind, returnValue);
 685             }
 686             boolean inlinedIntrinsic = parser.getInvokeReturnType() != null;
 687             if (inlinedIntrinsic) {
 688                 for (Node n : parser.graph.getNewNodes(mark)) {
 689                     if (n instanceof FrameState) {
 690                         GraalError.guarantee(((FrameState) n).bci != BytecodeFrame.INVALID_FRAMESTATE_BCI,
 691                                         &quot;Inlined call to intrinsic (callee %s) produced invalid framestate %s. &quot; +
 692                                                         &quot;Such framestates must never be used as deoptimizing targets, thus they cannot be part of a high-tier graph, &quot; +
 693                                                         &quot;and must only be used after framestate assignment. A common error is invalid usage of foreign call nodes in method &quot; +
 694                                                         &quot;substitutions, which can be avoided by ensuring such calls are either replaced with nodes that are snippet &quot; +
 695                                                         &quot;lowered after framestate assignment (see FastNotifyNode.java for example) or by ensuring all foreign use the state after of the &quot; +
 696                                                         &quot;original call instruction.&quot;,
 697                                         callee, n);
 698                     }
 699                 }
 700             } else {
 701 
 702                 /*
 703                  * Special case root compiled method substitutions
 704                  *
 705                  * Root compiled intrinsics with self recursive calls (partial intrinsic exit) must
 706                  * never produce more than one state except the start framestate since we do not
 707                  * compile calls to the original method (or inline them) but deopt
 708                  *
 709                  * See ByteCodeParser::inline and search for compilationRoot
 710                  */
 711                 assert intrinsic == null || intrinsic.isIntrinsicEncoding() || verifyIntrinsicRootCompileEffects();
 712             }
 713         }
 714 
 715         private boolean verifyIntrinsicRootCompileEffects() {
 716             int invalidBCIsInRootCompiledIntrinsic = 0;
 717             for (Node n : parser.graph.getNewNodes(mark)) {
 718                 if (n instanceof FrameState) {
 719                     if (((FrameState) n).bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 720                         invalidBCIsInRootCompiledIntrinsic++;
 721                     }
 722                 }
 723             }
 724             if (invalidBCIsInRootCompiledIntrinsic &gt; 1) {
 725                 int invalidBCIsToFind = invalidBCIsInRootCompiledIntrinsic;
 726                 List&lt;ReturnNode&gt; returns = parser.getGraph().getNodes(ReturnNode.TYPE).snapshot();
 727                 if (returns.size() &gt; 1) {
 728                     outer: for (ReturnNode ret : returns) {
 729                         for (FixedNode f : GraphUtil.predecessorIterable(ret)) {
 730                             if (f instanceof StateSplit) {
 731                                 StateSplit split = (StateSplit) f;
 732                                 if (split.hasSideEffect()) {
 733                                     assert ((StateSplit) f).stateAfter() != null;
 734                                     if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 735                                         invalidBCIsToFind--;
 736                                         continue outer;
 737                                     }
 738                                 }
 739                             }
 740                         }
 741                     }
 742                     GraalError.guarantee(invalidBCIsToFind == 0, &quot;Root compiled intrinsic with invalid states has more than one return. &quot; +
 743                                     &quot;This is allowed, however one path down a sink has more than one state, this is prohibited. &quot; +
 744                                     &quot;Intrinsic %s&quot;, parser.method);
 745                     return true;
 746                 }
 747                 ReturnNode ret = returns.get(0);
 748                 MergeNode merge = null;
 749                 int mergeCount = parser.graph.getNodes(MergeNode.TYPE).count();
 750                 if (mergeCount != 1) {
 751                     throw new GraalError(&quot;Root compiled intrinsic with invalid states %s:Must have exactly one merge node. %d found&quot;, parser.method, mergeCount);
 752                 }
 753                 if (ret.predecessor() instanceof MergeNode) {
 754                     merge = (MergeNode) ret.predecessor();
 755                 }
 756                 if (merge == null) {
 757                     throw new GraalError(&quot;Root compiled intrinsic with invalid state: Unexpected node between return and merge.&quot;);
 758                 }
 759                 //@formatter:off
 760                 GraalError.guarantee(invalidBCIsInRootCompiledIntrinsic &lt;= merge.phiPredecessorCount() + 1 /* merge itself */,
 761                                 &quot;Root compiled intrinsic with invalid states %s must at maximum produce (0,1 or if the last instruction is a merge |merge.predCount|&quot; +
 762                                                 &quot; invalid BCI state, however %d where found.&quot;,
 763                                 parser.method, invalidBCIsInRootCompiledIntrinsic);
 764                 //@formatter:on
 765                 if (merge.stateAfter() != null &amp;&amp; merge.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 766                     invalidBCIsToFind--;
 767                 }
 768                 for (EndNode pred : merge.cfgPredecessors()) {
 769                     Node lastPred = pred.predecessor();
 770                     for (FixedNode f : GraphUtil.predecessorIterable((FixedNode) lastPred)) {
 771                         if (f instanceof StateSplit) {
 772                             StateSplit split = (StateSplit) f;
 773                             if (split.hasSideEffect()) {
 774                                 assert ((StateSplit) f).stateAfter() != null;
 775                                 if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 776                                     invalidBCIsToFind--;
 777                                 }
 778                             }
 779                         }
 780                     }
 781                 }
 782                 if (invalidBCIsToFind != 0) {
 783                     throw new GraalError(
 784                                     &quot;Invalid BCI state missmatch: This root compiled method substitution %s &quot; +
 785                                                     &quot;uses invalid side-effecting nodes resulting in invalid deoptimization information. &quot; +
 786                                                     &quot;Method substitutions must never have more than one state (the after state) for deoptimization.&quot; +
 787                                                     &quot; Multiple states are only allowed if they are dominated by a control-flow split, there is only&quot; +
 788                                                     &quot; a single effect per branch and a post dominating merge with the same invalid_bci state &quot; +
 789                                                     &quot;(that must only be different in its return value).&quot;,
 790                                     parser.method);
 791                 }
 792             }
 793             return true;
 794         }
 795 
 796         private void updateSplitFrameState(StateSplit split, JavaKind returnKind, ValueNode returnValue) {
 797             parser.frameState.push(returnKind, returnValue);
 798             FrameState oldState = split.stateAfter();
 799             split.setStateAfter(parser.createFrameState(parser.stream.nextBCI(), split));
 800             parser.frameState.pop(returnKind);
 801             if (oldState.hasNoUsages()) {
 802                 oldState.safeDelete();
 803             }
 804         }
 805 
 806         @Override
 807         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {
 808             if (invalidStateUsers == null) {
 809                 invalidStateUsers = new ArrayList&lt;&gt;();
 810             }
 811             for (Node use : fs.usages()) {
 812                 if (!(use instanceof StateSplit)) {
 813                     throw new GraalError(&quot;Expected StateSplit for return mismatch&quot;);
 814                 }
 815                 invalidStateUsers.add((StateSplit) use);
 816             }
 817         }
 818     }
 819 
 820     private static class Target {
 821         final FixedNode entry;
 822         final FixedNode originalEntry;
 823         final FrameStateBuilder state;
 824 
 825         Target(FixedNode entry, FrameStateBuilder state) {
 826             this.entry = entry;
 827             this.state = state;
 828             this.originalEntry = null;
 829         }
 830 
 831         Target(FixedNode entry, FrameStateBuilder state, FixedNode originalEntry) {
 832             this.entry = entry;
 833             this.state = state;
 834             this.originalEntry = originalEntry;
 835         }
 836     }
 837 
 838     @SuppressWarnings(&quot;serial&quot;)
 839     public static class BytecodeParserError extends GraalError {
 840 
 841         public BytecodeParserError(Throwable cause) {
 842             super(cause);
 843         }
 844 
 845         public BytecodeParserError(String msg, Object... args) {
 846             super(msg, args);
 847         }
 848     }
 849 
 850     protected static class ReturnToCallerData {
 851         protected final ValueNode returnValue;
 852         protected final FixedWithNextNode beforeReturnNode;
 853 
 854         protected ReturnToCallerData(ValueNode returnValue, FixedWithNextNode beforeReturnNode) {
 855             this.returnValue = returnValue;
 856             this.beforeReturnNode = beforeReturnNode;
 857         }
 858 
 859         static boolean containsReturnValue(List&lt;ReturnToCallerData&gt; list, ValueNode value) {
 860             for (ReturnToCallerData e : list) {
 861                 if (e.returnValue == value) {
 862                     return true;
 863                 }
 864             }
 865             return false;
 866         }
 867     }
 868 
 869     private final GraphBuilderPhase.Instance graphBuilderInstance;
 870     protected final StructuredGraph graph;
 871     protected final OptionValues options;
 872     protected final DebugContext debug;
 873 
 874     private BciBlockMapping blockMap;
 875     private LocalLiveness liveness;
 876     protected final int entryBCI;
 877     private final BytecodeParser parent;
 878 
 879     private LineNumberTable lnt;
 880     private int previousLineNumber;
 881     private int currentLineNumber;
 882 
 883     private ValueNode methodSynchronizedObject;
 884 
 885     private List&lt;ReturnToCallerData&gt; returnDataList;
 886     private ValueNode unwindValue;
 887     private FixedWithNextNode beforeUnwindNode;
 888 
 889     protected FixedWithNextNode lastInstr;                 // the last instruction added
 890     private boolean controlFlowSplit;
 891     private final InvocationPluginReceiver invocationPluginReceiver = new InvocationPluginReceiver(this);
 892 
 893     private FixedWithNextNode[] firstInstructionArray;
 894     private FrameStateBuilder[] entryStateArray;
 895 
 896     private boolean finalBarrierRequired;
 897     private ValueNode originalReceiver;
 898     private final boolean eagerInitializing;
 899     private final boolean uninitializedIsError;
 900     private final int traceLevel;
 901 
 902     protected BytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method,
 903                     int entryBCI, IntrinsicContext intrinsicContext) {
 904         this.bytecodeProvider = intrinsicContext == null ? new ResolvedJavaMethodBytecodeProvider() : intrinsicContext.getBytecodeProvider();
 905         this.code = bytecodeProvider.getBytecode(method);
 906         this.method = code.getMethod();
 907         this.graphBuilderInstance = graphBuilderInstance;
 908         this.graph = graph;
 909         this.options = graph.getOptions();
 910         this.debug = graph.getDebug();
 911         this.graphBuilderConfig = graphBuilderInstance.graphBuilderConfig;
 912         this.optimisticOpts = graphBuilderInstance.optimisticOpts;
 913         this.providers = graphBuilderInstance.providers;
 914         this.stream = new BytecodeStream(code.getCode());
 915         this.profilingInfo = graph.useProfilingInfo() ? code.getProfilingInfo() : null;
 916         this.constantPool = code.getConstantPool();
 917         this.intrinsicContext = intrinsicContext;
 918         this.entryBCI = entryBCI;
 919         this.parent = parent;
 920 
 921         ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
 922         if (classInitializationPlugin != null &amp;&amp; graphBuilderConfig.eagerResolving() &amp;&amp; classInitializationPlugin.supportsLazyInitialization(constantPool)) {
 923             eagerInitializing = false;
 924             uninitializedIsError = false;
 925         } else {
 926             eagerInitializing = graphBuilderConfig.eagerResolving();
 927             uninitializedIsError = graphBuilderConfig.unresolvedIsError();
 928         }
 929 
 930         assert code.getCode() != null : &quot;method must contain bytecodes: &quot; + method;
 931 
 932         if (graphBuilderConfig.insertFullInfopoints() &amp;&amp; !parsingIntrinsic()) {
 933             lnt = code.getLineNumberTable();
 934             previousLineNumber = -1;
 935         }
 936 
 937         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || graph.trackNodeSourcePosition();
 938         if (graphBuilderConfig.trackNodeSourcePosition() || (parent != null &amp;&amp; parent.graph.trackNodeSourcePosition())) {
 939             graph.setTrackNodeSourcePosition();
 940         }
 941 
 942         int level = TraceBytecodeParserLevel.getValue(options);
 943         this.traceLevel = level != 0 ? refineTraceLevel(level) : 0;
 944     }
 945 
 946     private int refineTraceLevel(int level) {
 947         ResolvedJavaMethod tmethod = graph.method();
 948         if (tmethod == null) {
 949             tmethod = method;
 950         }
 951         String filterValue = DebugOptions.MethodFilter.getValue(options);
 952         if (filterValue != null) {
<a name="2" id="anc2"></a><span class="line-modified"> 953             MethodFilter filter = MethodFilter.parse(filterValue);</span>
<span class="line-modified"> 954             if (!filter.matches(tmethod)) {</span>
 955                 return 0;
 956             }
 957         }
 958         return level;
 959     }
 960 
 961     protected GraphBuilderPhase.Instance getGraphBuilderInstance() {
 962         return graphBuilderInstance;
 963     }
 964 
 965     public ValueNode getUnwindValue() {
 966         return unwindValue;
 967     }
 968 
 969     public FixedWithNextNode getBeforeUnwindNode() {
 970         return this.beforeUnwindNode;
 971     }
 972 
 973     @SuppressWarnings(&quot;try&quot;)
 974     protected void buildRootMethod() {
 975         FrameStateBuilder startFrameState = new FrameStateBuilder(this, code, graph, graphBuilderConfig.retainLocalVariables());
 976         startFrameState.initializeForMethodStart(graph.getAssumptions(), graphBuilderConfig.eagerResolving() || intrinsicContext != null, graphBuilderConfig.getPlugins());
 977 
 978         try (IntrinsicScope s = intrinsicContext != null ? new IntrinsicScope(this) : null) {
 979             build(graph.start(), startFrameState);
 980         }
 981 
 982         cleanupFinalGraph();
 983         ComputeLoopFrequenciesClosure.compute(graph);
 984     }
 985 
 986     @SuppressWarnings(&quot;try&quot;)
 987     protected void build(FixedWithNextNode startInstruction, FrameStateBuilder startFrameState) {
 988         if (PrintProfilingInformation.getValue(options) &amp;&amp; profilingInfo != null) {
 989             TTY.println(&quot;Profiling info for &quot; + method.format(&quot;%H.%n(%p)&quot;));
 990             TTY.println(Util.indent(profilingInfo.toString(method, CodeUtil.NEW_LINE), &quot;  &quot;));
 991         }
 992 
 993         try (Indent indent = debug.logAndIndent(&quot;build graph for %s&quot;, method)) {
 994             if (bytecodeProvider.shouldRecordMethodDependencies()) {
 995                 assert getParent() != null || method.equals(graph.method());
 996                 // Record method dependency in the graph
 997                 graph.recordMethod(method);
 998             }
 999 
1000             // compute the block map, setup exception handlers and get the entrypoint(s)
1001             BciBlockMapping newMapping = BciBlockMapping.create(stream, code, options, graph.getDebug());
1002             this.blockMap = newMapping;
1003             this.firstInstructionArray = new FixedWithNextNode[blockMap.getBlockCount()];
1004             this.entryStateArray = new FrameStateBuilder[blockMap.getBlockCount()];
1005             if (!method.isStatic()) {
1006                 originalReceiver = startFrameState.loadLocal(0, JavaKind.Object);
1007             }
1008 
1009             /*
1010              * Configure the assertion checking behavior of the FrameStateBuilder. This needs to be
1011              * done only when assertions are enabled, so it is wrapped in an assertion itself.
1012              */
1013             assert computeKindVerification(startFrameState);
1014 
1015             try (DebugContext.Scope s = debug.scope(&quot;LivenessAnalysis&quot;)) {
1016                 int maxLocals = method.getMaxLocals();
1017                 liveness = LocalLiveness.compute(debug, stream, blockMap.getBlocks(), maxLocals, blockMap.getLoopCount());
1018             } catch (Throwable e) {
1019                 throw debug.handle(e);
1020             }
1021 
1022             lastInstr = startInstruction;
1023             this.setCurrentFrameState(startFrameState);
1024             stream.setBCI(0);
1025 
1026             BciBlock startBlock = blockMap.getStartBlock();
1027             if (this.parent == null) {
1028                 StartNode startNode = graph.start();
1029                 if (method.isSynchronized()) {
1030                     assert !parsingIntrinsic();
1031                     startNode.setStateAfter(createFrameState(BytecodeFrame.BEFORE_BCI, startNode));
1032                 } else {
1033                     if (!parsingIntrinsic()) {
1034                         if (graph.method() != null &amp;&amp; graph.method().isJavaLangObjectInit()) {
1035                             /*
1036                              * Don&#39;t clear the receiver when Object.&lt;init&gt; is the compilation root.
1037                              * The receiver is needed as input to RegisterFinalizerNode.
1038                              */
1039                         } else {
1040                             frameState.clearNonLiveLocals(startBlock, liveness, true);
1041                         }
1042                         assert bci() == 0;
1043                         startNode.setStateAfter(createFrameState(bci(), startNode));
1044                     } else {
1045                         if (startNode.stateAfter() == null) {
1046                             FrameState stateAfterStart = createStateAfterStartOfReplacementGraph();
1047                             startNode.setStateAfter(stateAfterStart);
1048                         }
1049                     }
1050                 }
1051             }
1052 
1053             try (DebugCloseable context = openNodeContext()) {
1054                 if (method.isSynchronized()) {
1055                     finishPrepare(lastInstr, BytecodeFrame.BEFORE_BCI, frameState);
1056 
1057                     // add a monitor enter to the start block
1058                     methodSynchronizedObject = synchronizedObject(frameState, method);
1059                     frameState.clearNonLiveLocals(startBlock, liveness, true);
1060                     assert bci() == 0;
1061                     genMonitorEnter(methodSynchronizedObject, bci());
1062                 }
1063 
1064                 ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
1065                 if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
1066                     FrameState stateBefore = createCurrentFrameState();
1067                     profilingPlugin.profileInvoke(this, method, stateBefore);
1068                 }
1069 
1070                 finishPrepare(lastInstr, 0, frameState);
1071 
1072                 genInfoPointNode(InfopointReason.METHOD_START, null);
1073             }
1074 
1075             currentBlock = blockMap.getStartBlock();
1076             setEntryState(startBlock, frameState);
1077             if (startBlock.isLoopHeader()) {
1078                 appendGoto(startBlock);
1079             } else {
1080                 setFirstInstruction(startBlock, lastInstr);
1081             }
1082 
1083             BciBlock[] blocks = blockMap.getBlocks();
1084             for (BciBlock block : blocks) {
1085                 processBlock(block);
1086             }
1087         }
1088     }
1089 
1090     private boolean computeKindVerification(FrameStateBuilder startFrameState) {
1091         if (blockMap.hasJsrBytecodes) {
1092             /*
1093              * The JSR return address is an int value, but stored using the astore bytecode. Instead
1094              * of weakening the kind assertion checking for all methods, we disable it completely
1095              * for methods that contain a JSR bytecode.
1096              */
1097             startFrameState.disableKindVerification();
1098         }
1099 
1100         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
1101             if (plugin.canChangeStackKind(this)) {
1102                 /*
1103                  * We have a plugin that can change the kind of values, so no kind assertion
1104                  * checking is possible.
1105                  */
1106                 startFrameState.disableKindVerification();
1107             }
1108         }
1109         return true;
1110     }
1111 
1112     /**
1113      * Hook for subclasses to modify synthetic code (start nodes and unwind nodes).
1114      *
1115      * @param instruction the current last instruction
1116      * @param bci the current bci
1117      * @param state The current frame state.
1118      */
1119     protected void finishPrepare(FixedWithNextNode instruction, int bci, FrameStateBuilder state) {
1120     }
1121 
1122     protected void cleanupFinalGraph() {
1123         GraphUtil.normalizeLoops(graph);
1124 
1125         // Remove dead parameters.
1126         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
1127             if (param.hasNoUsages()) {
1128                 assert param.inputs().isEmpty();
1129                 param.safeDelete();
1130             }
1131         }
1132 
1133         // Remove redundant begin nodes.
1134         for (BeginNode beginNode : graph.getNodes(BeginNode.TYPE)) {
1135             Node predecessor = beginNode.predecessor();
1136             if (predecessor instanceof ControlSplitNode) {
1137                 // The begin node is necessary.
1138             } else if (!beginNode.hasUsages()) {
1139                 GraphUtil.unlinkFixedNode(beginNode);
1140                 beginNode.safeDelete();
1141             }
1142         }
1143         if (graph.isOSR() &amp;&amp; getParent() == null &amp;&amp; graph.getNodes().filter(EntryMarkerNode.class).isEmpty()) {
1144             // This should generally be a transient condition because of inconsistent profile
1145             // information.
1146             throw new RetryableBailoutException(&quot;OSR entry point wasn&#39;t parsed&quot;);
1147         }
1148     }
1149 
1150     /**
1151      * Creates the frame state after the start node of a graph for an {@link IntrinsicContext
1152      * intrinsic} that is the parse root (either for root compiling or for post-parse inlining).
1153      */
1154     private FrameState createStateAfterStartOfReplacementGraph() {
1155         assert parent == null;
1156         assert frameState.getMethod().equals(intrinsicContext.getIntrinsicMethod());
1157         assert bci() == 0;
1158         assert frameState.stackSize() == 0;
1159         FrameState stateAfterStart;
1160         if (intrinsicContext.isPostParseInlined()) {
1161             stateAfterStart = graph.add(new FrameState(BytecodeFrame.BEFORE_BCI));
1162         } else {
1163             ResolvedJavaMethod original = intrinsicContext.getOriginalMethod();
1164             ValueNode[] locals;
1165             if (original.getMaxLocals() == frameState.localsSize() || original.isNative()) {
1166                 locals = new ValueNode[original.getMaxLocals()];
1167                 for (int i = 0; i &lt; locals.length; i++) {
1168                     ValueNode node = frameState.locals[i];
1169                     if (node == FrameState.TWO_SLOT_MARKER) {
1170                         node = null;
1171                     }
1172                     locals[i] = node;
1173                 }
1174             } else {
1175                 locals = new ValueNode[original.getMaxLocals()];
1176                 int parameterCount = original.getSignature().getParameterCount(!original.isStatic());
1177                 for (int i = 0; i &lt; parameterCount; i++) {
1178                     ValueNode param = frameState.locals[i];
1179                     if (param == FrameState.TWO_SLOT_MARKER) {
1180                         param = null;
1181                     }
1182                     locals[i] = param;
1183                     assert param == null || param instanceof ParameterNode || param.isConstant();
1184                 }
1185             }
1186             ValueNode[] stack = {};
1187             int stackSize = 0;
1188             ValueNode[] locks = {};
1189             List&lt;MonitorIdNode&gt; monitorIds = Collections.emptyList();
1190             stateAfterStart = graph.add(new FrameState(null, new ResolvedJavaMethodBytecode(original), 0, locals, stack, stackSize, locks, monitorIds, false, false));
1191         }
1192         return stateAfterStart;
1193     }
1194 
1195     /**
1196      * @param type the unresolved type of the constant
1197      */
1198     protected void handleUnresolvedLoadConstant(JavaType type) {
1199         assert !graphBuilderConfig.unresolvedIsError();
1200         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1201         /*
1202          * Track source position for deopt nodes even if
1203          * GraphBuilderConfiguration.trackNodeSourcePosition is not set.
1204          */
1205         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1206     }
1207 
1208     /**
1209      * @param type the unresolved type of the type check
1210      * @param object the object value whose type is being checked against {@code type}
1211      */
1212     protected void handleUnresolvedCheckCast(JavaType type, ValueNode object) {
1213         assert !graphBuilderConfig.unresolvedIsError();
1214         append(new FixedGuardNode(graph.addOrUniqueWithInputs(IsNullNode.create(object)), Unresolved, InvalidateRecompile));
1215         frameState.push(JavaKind.Object, appendConstant(JavaConstant.NULL_POINTER));
1216     }
1217 
1218     /**
1219      * @param type the unresolved type of the type check
1220      * @param object the object value whose type is being checked against {@code type}
1221      */
1222     protected void handleUnresolvedInstanceOf(JavaType type, ValueNode object) {
1223         assert !graphBuilderConfig.unresolvedIsError();
1224         AbstractBeginNode successor = graph.add(new BeginNode());
1225         DeoptimizeNode deopt = graph.add(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1226         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1227         append(new IfNode(graph.addOrUniqueWithInputs(IsNullNode.create(object)), successor, deopt, 1));
1228         lastInstr = successor;
1229         frameState.push(JavaKind.Int, appendConstant(JavaConstant.INT_0));
1230     }
1231 
1232     /**
1233      * @param type the type being instantiated
1234      */
1235     protected void handleUnresolvedNewInstance(JavaType type) {
1236         assert !graphBuilderConfig.unresolvedIsError();
1237         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1238         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1239     }
1240 
1241     /**
1242      * @param type the type being instantiated
1243      */
1244     protected void handleIllegalNewInstance(JavaType type) {
1245         assert !graphBuilderConfig.unresolvedIsError();
1246         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1247         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1248     }
1249 
1250     /**
1251      * @param type the type of the array being instantiated
1252      * @param length the length of the array
1253      */
1254     protected void handleUnresolvedNewObjectArray(JavaType type, ValueNode length) {
1255         assert !graphBuilderConfig.unresolvedIsError();
1256         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1257         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1258     }
1259 
1260     /**
1261      * @param type the type being instantiated
1262      * @param dims the dimensions for the multi-array
1263      */
1264     protected void handleUnresolvedNewMultiArray(JavaType type, ValueNode[] dims) {
1265         assert !graphBuilderConfig.unresolvedIsError();
1266         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1267         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1268     }
1269 
1270     /**
1271      * @param field the unresolved field
1272      * @param receiver the object containing the field or {@code null} if {@code field} is static
1273      */
1274     protected void handleUnresolvedLoadField(JavaField field, ValueNode receiver) {
1275         assert !graphBuilderConfig.unresolvedIsError();
1276         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1277         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1278     }
1279 
1280     /**
1281      * @param field the unresolved field
1282      * @param value the value being stored to the field
1283      * @param receiver the object containing the field or {@code null} if {@code field} is static
1284      */
1285     protected void handleUnresolvedStoreField(JavaField field, ValueNode value, ValueNode receiver) {
1286         assert !graphBuilderConfig.unresolvedIsError();
1287         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1288         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1289     }
1290 
1291     /**
1292      * @param type
1293      */
1294     protected void handleUnresolvedExceptionType(JavaType type) {
1295         assert !graphBuilderConfig.unresolvedIsError();
1296         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1297         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1298     }
1299 
1300     /**
1301      * @param javaMethod
1302      * @param invokeKind
1303      */
1304     protected void handleUnresolvedInvoke(JavaMethod javaMethod, InvokeKind invokeKind) {
1305         assert !graphBuilderConfig.unresolvedIsError();
1306         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1307         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1308     }
1309 
1310     /**
1311      * @return the entry point to exception dispatch
1312      */
1313     private AbstractBeginNode handleException(ValueNode exceptionObject, int bci, boolean deoptimizeOnly) {
1314         FixedWithNextNode currentLastInstr = lastInstr;
1315         assert bci == BytecodeFrame.BEFORE_BCI || bci == bci() : &quot;invalid bci&quot;;
1316         debug.log(&quot;Creating exception dispatch edges at %d, exception object=%s, exception seen=%s&quot;, bci, exceptionObject, (profilingInfo == null ? &quot;&quot; : profilingInfo.getExceptionSeen(bci)));
1317 
1318         FrameStateBuilder dispatchState = frameState.copy();
1319         dispatchState.clearStack();
1320 
1321         AbstractBeginNode dispatchBegin;
1322         if (exceptionObject == null) {
1323             ExceptionObjectNode newExceptionObject = graph.add(new ExceptionObjectNode(getMetaAccess()));
1324             dispatchState.push(JavaKind.Object, newExceptionObject);
1325             dispatchState.setRethrowException(true);
1326             newExceptionObject.setStateAfter(dispatchState.create(bci, newExceptionObject));
1327             dispatchBegin = newExceptionObject;
1328         } else {
1329             dispatchBegin = graph.add(new BeginNode());
1330             dispatchState.push(JavaKind.Object, exceptionObject);
1331             dispatchState.setRethrowException(true);
1332         }
1333         this.controlFlowSplit = true;
1334         FixedWithNextNode afterExceptionLoaded = finishInstruction(dispatchBegin, dispatchState);
1335 
1336         if (deoptimizeOnly) {
1337             DeoptimizeNode deoptimizeNode = graph.add(new DeoptimizeNode(DeoptimizationAction.None, DeoptimizationReason.TransferToInterpreter));
1338             afterExceptionLoaded.setNext(BeginNode.begin(deoptimizeNode));
1339         } else {
1340             createHandleExceptionTarget(afterExceptionLoaded, bci, dispatchState);
1341         }
1342         assert currentLastInstr == lastInstr;
1343         return dispatchBegin;
1344     }
1345 
1346     protected void createHandleExceptionTarget(FixedWithNextNode afterExceptionLoaded, int bci, FrameStateBuilder dispatchState) {
1347         FixedWithNextNode afterInstrumentation = afterExceptionLoaded;
1348         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
1349             afterInstrumentation = plugin.instrumentExceptionDispatch(graph, afterInstrumentation, () -&gt; dispatchState.create(bci, getNonIntrinsicAncestor(), false, null, null));
1350             assert afterInstrumentation.next() == null : &quot;exception dispatch instrumentation will be linked to dispatch block&quot;;
1351         }
1352 
1353         BciBlock dispatchBlock = currentBlock.exceptionDispatchBlock();
1354         /*
1355          * The exception dispatch block is always for the last bytecode of a block, so if we are not
1356          * at the endBci yet, there is no exception handler for this bci and we can unwind
1357          * immediately.
1358          */
1359         if (bci != currentBlock.endBci || dispatchBlock == null) {
1360             dispatchBlock = blockMap.getUnwindBlock();
1361         }
1362 
1363         FixedNode target = createTarget(dispatchBlock, dispatchState);
1364         afterInstrumentation.setNext(target);
1365     }
1366 
1367     protected ValueNode genLoadIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, JavaKind kind) {
1368         return LoadIndexedNode.create(graph.getAssumptions(), array, index, boundsCheck, kind, getMetaAccess(), getConstantReflection());
1369     }
1370 
1371     protected void genStoreIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, GuardingNode storeCheck, JavaKind kind, ValueNode value) {
1372         add(new StoreIndexedNode(array, index, boundsCheck, storeCheck, kind, value));
1373     }
1374 
1375     protected ValueNode genIntegerAdd(ValueNode x, ValueNode y) {
1376         return AddNode.create(x, y, NodeView.DEFAULT);
1377     }
1378 
1379     protected ValueNode genIntegerSub(ValueNode x, ValueNode y) {
1380         return SubNode.create(x, y, NodeView.DEFAULT);
1381     }
1382 
1383     protected ValueNode genIntegerMul(ValueNode x, ValueNode y) {
1384         return MulNode.create(x, y, NodeView.DEFAULT);
1385     }
1386 
1387     protected ValueNode genFloatAdd(ValueNode x, ValueNode y) {
1388         return AddNode.create(x, y, NodeView.DEFAULT);
1389     }
1390 
1391     protected ValueNode genFloatSub(ValueNode x, ValueNode y) {
1392         return SubNode.create(x, y, NodeView.DEFAULT);
1393     }
1394 
1395     protected ValueNode genFloatMul(ValueNode x, ValueNode y) {
1396         return MulNode.create(x, y, NodeView.DEFAULT);
1397     }
1398 
1399     protected ValueNode genFloatDiv(ValueNode x, ValueNode y) {
1400         return FloatDivNode.create(x, y, NodeView.DEFAULT);
1401     }
1402 
1403     protected ValueNode genFloatRem(ValueNode x, ValueNode y) {
1404         return RemNode.create(x, y, NodeView.DEFAULT);
1405     }
1406 
1407     protected ValueNode genIntegerDiv(ValueNode x, ValueNode y, GuardingNode zeroCheck) {
1408         return SignedDivNode.create(x, y, zeroCheck, NodeView.DEFAULT);
1409     }
1410 
1411     protected ValueNode genIntegerRem(ValueNode x, ValueNode y, GuardingNode zeroCheck) {
1412         return SignedRemNode.create(x, y, zeroCheck, NodeView.DEFAULT);
1413     }
1414 
1415     protected ValueNode genNegateOp(ValueNode x) {
1416         return NegateNode.create(x, NodeView.DEFAULT);
1417     }
1418 
1419     protected ValueNode genLeftShift(ValueNode x, ValueNode y) {
1420         return LeftShiftNode.create(x, y, NodeView.DEFAULT);
1421     }
1422 
1423     protected ValueNode genRightShift(ValueNode x, ValueNode y) {
1424         return RightShiftNode.create(x, y, NodeView.DEFAULT);
1425     }
1426 
1427     protected ValueNode genUnsignedRightShift(ValueNode x, ValueNode y) {
1428         return UnsignedRightShiftNode.create(x, y, NodeView.DEFAULT);
1429     }
1430 
1431     protected ValueNode genAnd(ValueNode x, ValueNode y) {
1432         return AndNode.create(x, y, NodeView.DEFAULT);
1433     }
1434 
1435     protected ValueNode genOr(ValueNode x, ValueNode y) {
1436         return OrNode.create(x, y, NodeView.DEFAULT);
1437     }
1438 
1439     protected ValueNode genXor(ValueNode x, ValueNode y) {
1440         return XorNode.create(x, y, NodeView.DEFAULT);
1441     }
1442 
1443     protected ValueNode genNormalizeCompare(ValueNode x, ValueNode y, boolean isUnorderedLess) {
1444         return FloatNormalizeCompareNode.create(x, y, isUnorderedLess, JavaKind.Int, getConstantReflection());
1445     }
1446 
1447     protected ValueNode genIntegerNormalizeCompare(ValueNode x, ValueNode y) {
1448         return IntegerNormalizeCompareNode.create(x, y, false, JavaKind.Int, getConstantReflection());
1449     }
1450 
1451     protected ValueNode genFloatConvert(FloatConvert op, ValueNode input) {
1452         return FloatConvertNode.create(op, input, NodeView.DEFAULT);
1453     }
1454 
1455     protected ValueNode genNarrow(ValueNode input, int bitCount) {
1456         return NarrowNode.create(input, bitCount, NodeView.DEFAULT);
1457     }
1458 
1459     protected ValueNode genSignExtend(ValueNode input, int bitCount) {
1460         return SignExtendNode.create(input, bitCount, NodeView.DEFAULT);
1461     }
1462 
1463     protected ValueNode genZeroExtend(ValueNode input, int bitCount) {
1464         return ZeroExtendNode.create(input, bitCount, NodeView.DEFAULT);
1465     }
1466 
1467     protected void genGoto() {
1468         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
1469         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
1470             FrameState stateBefore = createCurrentFrameState();
1471             int targetBci = currentBlock.getSuccessor(0).startBci;
1472             profilingPlugin.profileGoto(this, method, bci(), targetBci, stateBefore);
1473         }
1474         appendGoto(currentBlock.getSuccessor(0));
1475         assert currentBlock.numNormalSuccessors() == 1;
1476     }
1477 
1478     protected LogicNode genObjectEquals(ValueNode x, ValueNode y) {
1479         return ObjectEqualsNode.create(getConstantReflection(), getMetaAccess(), options, x, y, NodeView.DEFAULT);
1480     }
1481 
1482     protected LogicNode genIntegerEquals(ValueNode x, ValueNode y) {
1483         return IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);
1484     }
1485 
1486     protected LogicNode genIntegerLessThan(ValueNode x, ValueNode y) {
1487         return IntegerLessThanNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);
1488     }
1489 
1490     protected ValueNode genUnique(ValueNode x) {
1491         return graph.addOrUniqueWithInputs(x);
1492     }
1493 
1494     protected LogicNode genUnique(LogicNode x) {
1495         return graph.addOrUniqueWithInputs(x);
1496     }
1497 
1498     protected ValueNode genIfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double d) {
1499         return new IfNode(condition, trueSuccessor, falseSuccessor, d);
1500     }
1501 
1502     protected void genThrow() {
1503         genInfoPointNode(InfopointReason.BYTECODE_POSITION, null);
1504 
1505         ValueNode exception = maybeEmitExplicitNullCheck(frameState.pop(JavaKind.Object));
1506         if (!StampTool.isPointerNonNull(exception.stamp(NodeView.DEFAULT))) {
1507             FixedGuardNode nullCheck = append(new FixedGuardNode(graph.addOrUniqueWithInputs(IsNullNode.create(exception)), NullCheckException, InvalidateReprofile, true));
1508             exception = graph.maybeAddOrUnique(PiNode.create(exception, exception.stamp(NodeView.DEFAULT).join(objectNonNull()), nullCheck));
1509         }
1510         lastInstr.setNext(handleException(exception, bci(), false));
1511     }
1512 
1513     protected LogicNode createInstanceOf(TypeReference type, ValueNode object) {
1514         return InstanceOfNode.create(type, object);
1515     }
1516 
1517     protected AnchoringNode createAnchor(JavaTypeProfile profile) {
1518         if (profile == null || profile.getNotRecordedProbability() &gt; 0.0) {
1519             return null;
1520         } else {
1521             return BeginNode.prevBegin(lastInstr);
1522         }
1523     }
1524 
1525     protected LogicNode createInstanceOf(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1526         return InstanceOfNode.create(type, object, profile, createAnchor(profile));
1527     }
1528 
1529     protected LogicNode createInstanceOfAllowNull(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1530         return InstanceOfNode.createAllowNull(type, object, profile, createAnchor(profile));
1531     }
1532 
1533     protected ValueNode genConditional(ValueNode x) {
1534         return ConditionalNode.create((LogicNode) x, NodeView.DEFAULT);
1535     }
1536 
1537     protected NewInstanceNode createNewInstance(ResolvedJavaType type, boolean fillContents) {
1538         return new NewInstanceNode(type, fillContents);
1539     }
1540 
1541     protected NewArrayNode createNewArray(ResolvedJavaType elementType, ValueNode length, boolean fillContents) {
1542         return new NewArrayNode(elementType, length, fillContents);
1543     }
1544 
1545     protected NewMultiArrayNode createNewMultiArray(ResolvedJavaType type, ValueNode[] dimensions) {
1546         return new NewMultiArrayNode(type, dimensions);
1547     }
1548 
1549     protected ValueNode genLoadField(ValueNode receiver, ResolvedJavaField field) {
1550         StampPair stamp = graphBuilderConfig.getPlugins().getOverridingStamp(this, field.getType(), false);
1551         if (stamp == null) {
1552             return LoadFieldNode.create(getConstantFieldProvider(), getConstantReflection(), getMetaAccess(), getOptions(),
1553                             getAssumptions(), receiver, field, false, false);
1554         } else {
1555             return LoadFieldNode.createOverrideStamp(getConstantFieldProvider(), getConstantReflection(), getMetaAccess(), getOptions(),
1556                             stamp, receiver, field, false, false);
1557         }
1558     }
1559 
1560     protected StateSplitProxyNode genVolatileFieldReadProxy(ValueNode fieldRead) {
1561         return new StateSplitProxyNode(fieldRead);
1562     }
1563 
1564     protected ValueNode maybeEmitExplicitNullCheck(ValueNode receiver) {
1565         if (StampTool.isPointerNonNull(receiver.stamp(NodeView.DEFAULT)) || !needsExplicitNullCheckException(receiver)) {
1566             return receiver;
1567         }
1568         LogicNode condition = genUnique(IsNullNode.create(receiver));
1569         AbstractBeginNode passingSuccessor = emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.NULL_POINTER);
1570         return genUnique(PiNode.create(receiver, objectNonNull(), passingSuccessor));
1571     }
1572 
1573     protected GuardingNode maybeEmitExplicitBoundsCheck(ValueNode receiver, ValueNode index) {
1574         if (!needsExplicitBoundsCheckException(receiver, index)) {
1575             return null;
1576         }
1577         ValueNode length = append(genArrayLength(receiver));
1578         LogicNode condition = genUnique(IntegerBelowNode.create(getConstantReflection(), getMetaAccess(), options, null, index, length, NodeView.DEFAULT));
1579         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.OUT_OF_BOUNDS, index, length);
1580     }
1581 
1582     protected GuardingNode maybeEmitExplicitStoreCheck(ValueNode array, JavaKind elementKind, ValueNode value) {
1583         if (elementKind != JavaKind.Object || StampTool.isPointerAlwaysNull(value) || !needsExplicitStoreCheckException(array, value)) {
1584             return null;
1585         }
1586         ValueNode arrayClass = genUnique(LoadHubNode.create(array, getStampProvider(), getMetaAccess(), getConstantReflection()));
1587         ValueNode componentHub = append(LoadArrayComponentHubNode.create(arrayClass, getStampProvider(), getMetaAccess(), getConstantReflection()));
1588         LogicNode condition = genUnique(InstanceOfDynamicNode.create(graph.getAssumptions(), getConstantReflection(), componentHub, value, true));
1589         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.ARRAY_STORE, value);
1590     }
1591 
1592     protected GuardingNode maybeEmitExplicitDivisionByZeroCheck(ValueNode y) {
1593         if (!((IntegerStamp) y.stamp(NodeView.DEFAULT)).contains(0) || !needsExplicitDivisionByZeroException(y)) {
1594             return null;
1595         }
1596         ConstantNode zero = ConstantNode.defaultForKind(y.getStackKind(), graph);
1597         LogicNode condition = genUnique(IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, y, zero, NodeView.DEFAULT));
1598         return emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.DIVISION_BY_ZERO);
1599     }
1600 
1601     private AbstractBeginNode emitBytecodeExceptionCheck(LogicNode condition, boolean passingOnTrue, BytecodeExceptionKind exceptionKind, ValueNode... arguments) {
1602         if (passingOnTrue ? condition.isTautology() : condition.isContradiction()) {
1603             return null;
1604         }
1605 
1606         BytecodeExceptionNode exception = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind, arguments));
1607         AbstractBeginNode passingSuccessor = graph.add(new BeginNode());
1608 
1609         FixedNode trueSuccessor = passingOnTrue ? passingSuccessor : exception;
1610         FixedNode falseSuccessor = passingOnTrue ? exception : passingSuccessor;
1611         append(new IfNode(condition, trueSuccessor, falseSuccessor, passingOnTrue ? LUDICROUSLY_FAST_PATH_PROBABILITY : LUDICROUSLY_SLOW_PATH_PROBABILITY));
1612         lastInstr = passingSuccessor;
1613 
1614         exception.setStateAfter(createBytecodeExceptionFrameState(bci(), exception));
1615         exception.setNext(handleException(exception, bci(), false));
1616         EXPLICIT_EXCEPTIONS.increment(debug);
1617 
1618         return passingSuccessor;
1619     }
1620 
1621     protected ValueNode genArrayLength(ValueNode x) {
1622         return ArrayLengthNode.create(x, getConstantReflection());
1623     }
1624 
1625     protected void genStoreField(ValueNode receiver, ResolvedJavaField field, ValueNode value) {
1626         StoreFieldNode storeFieldNode = new StoreFieldNode(receiver, field, maskSubWordValue(value, field.getJavaKind()));
1627         append(storeFieldNode);
1628         storeFieldNode.setStateAfter(this.createFrameState(stream.nextBCI(), storeFieldNode));
1629     }
1630 
1631     /**
1632      * Ensure that concrete classes are at least linked before generating an invoke. Interfaces may
1633      * never be linked so simply return true for them.
1634      *
1635      * @param target
1636      * @return true if the declared holder is an interface or is linked
1637      */
1638     private static boolean callTargetIsResolved(JavaMethod target) {
1639         if (target instanceof ResolvedJavaMethod) {
1640             ResolvedJavaMethod resolvedTarget = (ResolvedJavaMethod) target;
1641             ResolvedJavaType resolvedType = resolvedTarget.getDeclaringClass();
1642             return resolvedType.isInterface() || resolvedType.isLinked();
1643         }
1644         return false;
1645     }
1646 
1647     /**
1648      * Check if a type is resolved. Can be overwritten by sub-classes to implement different type
1649      * resolution rules.
1650      */
1651     protected boolean typeIsResolved(JavaType type) {
1652         return type instanceof ResolvedJavaType;
1653     }
1654 
1655     protected void genInvokeStatic(int cpi, int opcode) {
1656         JavaMethod target = lookupMethod(cpi, opcode);
1657         assert !uninitializedIsError ||
1658                         (target instanceof ResolvedJavaMethod &amp;&amp; ((ResolvedJavaMethod) target).getDeclaringClass().isInitialized()) : target;
1659         genInvokeStatic(target);
1660     }
1661 
1662     void genInvokeStatic(JavaMethod target) {
1663         if (callTargetIsResolved(target)) {
1664             ResolvedJavaMethod resolvedTarget = (ResolvedJavaMethod) target;
1665             ResolvedJavaType holder = resolvedTarget.getDeclaringClass();
1666             maybeEagerlyInitialize(holder);
1667             ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
1668             if (!holder.isInitialized() &amp;&amp; classInitializationPlugin == null) {
1669                 handleUnresolvedInvoke(target, InvokeKind.Static);
1670                 return;
1671             }
1672 
1673             ValueNode[] classInit = {null};
1674             if (classInitializationPlugin != null) {
1675                 classInitializationPlugin.apply(this, resolvedTarget.getDeclaringClass(), this::createCurrentFrameState, classInit);
1676             }
1677 
1678             ValueNode[] args = frameState.popArguments(resolvedTarget.getSignature().getParameterCount(false));
1679             Invoke invoke = appendInvoke(InvokeKind.Static, resolvedTarget, args);
1680             if (invoke != null &amp;&amp; classInit[0] != null) {
1681                 invoke.setClassInit(classInit[0]);
1682             }
1683         } else {
1684             handleUnresolvedInvoke(target, InvokeKind.Static);
1685         }
1686     }
1687 
1688     /**
1689      * Creates a frame state for the current parse position.
1690      */
1691     private FrameState createCurrentFrameState() {
1692         return frameState.create(bci(), getNonIntrinsicAncestor(), false, null, null);
1693     }
1694 
1695     protected void genInvokeInterface(int cpi, int opcode) {
1696         JavaMethod target = lookupMethod(cpi, opcode);
1697         genInvokeInterface(target);
1698     }
1699 
1700     protected void genInvokeInterface(JavaMethod target) {
1701         if (callTargetIsResolved(target)) {
1702             ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(true));
1703             appendInvoke(InvokeKind.Interface, (ResolvedJavaMethod) target, args);
1704         } else {
1705             handleUnresolvedInvoke(target, InvokeKind.Interface);
1706         }
1707     }
1708 
1709     protected void genInvokeDynamic(int cpi, int opcode) {
1710         JavaMethod target = lookupMethod(cpi, opcode);
1711         genInvokeDynamic(target);
1712     }
1713 
1714     void genInvokeDynamic(JavaMethod target) {
1715         if (!(target instanceof ResolvedJavaMethod) || !genDynamicInvokeHelper((ResolvedJavaMethod) target, stream.readCPI4(), INVOKEDYNAMIC)) {
1716             handleUnresolvedInvoke(target, InvokeKind.Static);
1717         }
1718     }
1719 
1720     protected void genInvokeVirtual(int cpi, int opcode) {
1721         JavaMethod target = lookupMethod(cpi, opcode);
1722         if (callTargetIsResolved(target)) {
1723             genInvokeVirtual((ResolvedJavaMethod) target);
1724         } else {
1725             handleUnresolvedInvoke(target, InvokeKind.Virtual);
1726         }
1727     }
1728 
1729     protected void genInvokeVirtual(ResolvedJavaMethod resolvedTarget) {
1730         int cpi = stream.readCPI();
1731 
1732         /*
1733          * Special handling for runtimes that rewrite an invocation of MethodHandle.invoke(...) or
1734          * MethodHandle.invokeExact(...) to a static adapter. HotSpot does this - see
1735          * https://wiki.openjdk.java.net/display/HotSpot/Method+handles+and+invokedynamic
1736          */
1737 
1738         if (genDynamicInvokeHelper(resolvedTarget, cpi, INVOKEVIRTUAL)) {
1739             return;
1740         }
1741 
1742         ValueNode[] args = frameState.popArguments(resolvedTarget.getSignature().getParameterCount(true));
1743         appendInvoke(InvokeKind.Virtual, resolvedTarget, args);
1744     }
1745 
1746     private boolean genDynamicInvokeHelper(ResolvedJavaMethod target, int cpi, int opcode) {
1747         assert opcode == INVOKEDYNAMIC || opcode == INVOKEVIRTUAL;
1748 
1749         InvokeDynamicPlugin invokeDynamicPlugin = graphBuilderConfig.getPlugins().getInvokeDynamicPlugin();
1750 
1751         if (opcode == INVOKEVIRTUAL &amp;&amp; invokeDynamicPlugin != null &amp;&amp; !invokeDynamicPlugin.isResolvedDynamicInvoke(this, cpi, opcode)) {
1752             // regular invokevirtual, let caller handle it
1753             return false;
1754         }
1755 
1756         if (GeneratePIC.getValue(options) &amp;&amp; (invokeDynamicPlugin == null || !invokeDynamicPlugin.supportsDynamicInvoke(this, cpi, opcode))) {
1757             // bail out if static compiler and no dynamic type support
1758             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1759             return true;
1760         }
1761 
1762         JavaConstant appendix = constantPool.lookupAppendix(cpi, opcode);
1763         ValueNode appendixNode = null;
1764 
1765         if (appendix != null) {
1766             if (invokeDynamicPlugin != null) {
1767                 invokeDynamicPlugin.recordDynamicMethod(this, cpi, opcode, target);
1768 
1769                 // Will perform runtime type checks and static initialization
1770                 FrameState stateBefore = createCurrentFrameState();
1771                 appendixNode = invokeDynamicPlugin.genAppendixNode(this, cpi, opcode, appendix, stateBefore);
1772             } else {
1773                 appendixNode = ConstantNode.forConstant(appendix, getMetaAccess(), graph);
1774             }
1775 
1776             frameState.push(JavaKind.Object, appendixNode);
1777 
1778         } else if (GeneratePIC.getValue(options)) {
1779             // Need to emit runtime guard and perform static initialization.
1780             // Not implemented yet.
1781             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1782             return true;
1783         }
1784 
1785         boolean hasReceiver = (opcode == INVOKEDYNAMIC) ? false : !target.isStatic();
1786         ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(hasReceiver));
1787         if (hasReceiver) {
1788             appendInvoke(InvokeKind.Virtual, target, args);
1789         } else {
1790             appendInvoke(InvokeKind.Static, target, args);
1791         }
1792 
1793         return true;
1794     }
1795 
1796     protected void genInvokeSpecial(int cpi, int opcode) {
1797         JavaMethod target = lookupMethod(cpi, opcode);
1798         genInvokeSpecial(target);
1799     }
1800 
1801     void genInvokeSpecial(JavaMethod target) {
1802         if (callTargetIsResolved(target)) {
1803             assert target != null;
1804             assert target.getSignature() != null;
1805             ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(true));
1806             appendInvoke(InvokeKind.Special, (ResolvedJavaMethod) target, args);
1807         } else {
1808             handleUnresolvedInvoke(target, InvokeKind.Special);
1809         }
1810     }
1811 
1812     static class CurrentInvoke {
1813         final ValueNode[] args;
1814         final InvokeKind kind;
1815         final JavaType returnType;
1816 
1817         CurrentInvoke(ValueNode[] args, InvokeKind kind, JavaType returnType) {
1818             this.args = args;
1819             this.kind = kind;
1820             this.returnType = returnType;
1821         }
1822     }
1823 
1824     private CurrentInvoke currentInvoke;
1825     protected FrameStateBuilder frameState;
1826     protected BciBlock currentBlock;
1827     protected final BytecodeStream stream;
1828     protected final GraphBuilderConfiguration graphBuilderConfig;
1829     protected final ResolvedJavaMethod method;
1830     protected final Bytecode code;
1831     protected final BytecodeProvider bytecodeProvider;
1832     protected final ProfilingInfo profilingInfo;
1833     protected final OptimisticOptimizations optimisticOpts;
1834     protected final ConstantPool constantPool;
1835     protected final CoreProviders providers;
1836     protected final IntrinsicContext intrinsicContext;
1837 
1838     @Override
1839     public InvokeKind getInvokeKind() {
1840         return currentInvoke == null ? null : currentInvoke.kind;
1841     }
1842 
1843     @Override
1844     public JavaType getInvokeReturnType() {
1845         return currentInvoke == null ? null : currentInvoke.returnType;
1846     }
1847 
1848     private boolean forceInliningEverything;
1849 
1850     @Override
1851     public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean inlineEverything) {
1852         boolean previous = forceInliningEverything;
1853         forceInliningEverything = previous || inlineEverything;
1854         try {
1855             return appendInvoke(invokeKind, targetMethod, args);
1856         } finally {
1857             forceInliningEverything = previous;
1858         }
1859     }
1860 
1861     @Override
1862     public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
1863         BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
1864         ExceptionEdgeAction exceptionEdgeAction = intrinsicCallSiteParser == null ? getActionForInvokeExceptionEdge(null) : intrinsicCallSiteParser.getActionForInvokeExceptionEdge(null);
1865         createNonInlinedInvoke(exceptionEdgeAction, bci(), callTarget, resultType);
1866     }
1867 
1868     protected Invoke appendInvoke(InvokeKind initialInvokeKind, ResolvedJavaMethod initialTargetMethod, ValueNode[] args) {
1869         ResolvedJavaMethod targetMethod = initialTargetMethod;
1870         InvokeKind invokeKind = initialInvokeKind;
1871         if (initialInvokeKind.isIndirect()) {
1872             ResolvedJavaType contextType = this.frameState.getMethod().getDeclaringClass();
1873             ResolvedJavaMethod specialCallTarget = MethodCallTargetNode.findSpecialCallTarget(initialInvokeKind, args[0], initialTargetMethod, contextType);
1874             if (specialCallTarget != null) {
1875                 invokeKind = InvokeKind.Special;
1876                 targetMethod = specialCallTarget;
1877             }
1878         }
1879 
1880         JavaKind resultType = targetMethod.getSignature().getReturnKind();
1881         if (!parsingIntrinsic() &amp;&amp; DeoptALot.getValue(options)) {
1882             append(new DeoptimizeNode(DeoptimizationAction.None, RuntimeConstraint));
1883             frameState.pushReturn(resultType, ConstantNode.defaultForKind(resultType, graph));
1884             return null;
1885         }
1886 
1887         JavaType returnType = maybeEagerlyResolve(targetMethod.getSignature().getReturnType(method.getDeclaringClass()), targetMethod.getDeclaringClass());
1888         if (invokeKind.hasReceiver()) {
1889             args[0] = maybeEmitExplicitNullCheck(args[0]);
1890         }
1891 
1892         if (initialInvokeKind == InvokeKind.Special &amp;&amp; !targetMethod.isConstructor()) {
1893             emitCheckForInvokeSuperSpecial(args);
1894         } else if (initialInvokeKind == InvokeKind.Interface &amp;&amp; targetMethod.isPrivate()) {
1895             emitCheckForDeclaringClassChange(targetMethod.getDeclaringClass(), args);
1896         }
1897 
1898         InlineInfo inlineInfo = null;
1899         try {
1900             currentInvoke = new CurrentInvoke(args, invokeKind, returnType);
1901             if (tryNodePluginForInvocation(args, targetMethod)) {
1902                 if (TraceParserPlugins.getValue(options)) {
1903                     traceWithContext(&quot;used node plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1904                 }
1905                 return null;
1906             }
1907 
1908             if (invokeKind.hasReceiver() &amp;&amp; args[0].isNullConstant()) {
1909                 append(new DeoptimizeNode(InvalidateRecompile, NullCheckException));
1910                 return null;
1911             }
1912 
1913             if (!invokeKind.isIndirect()) {
1914                 if (tryInvocationPlugin(invokeKind, args, targetMethod, resultType)) {
1915                     if (TraceParserPlugins.getValue(options)) {
1916                         traceWithContext(&quot;used invocation plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1917                     }
1918                     return null;
1919                 }
1920             }
1921             if (invokeKind.isDirect()) {
1922                 inlineInfo = tryInline(args, targetMethod);
1923                 if (inlineInfo == SUCCESSFULLY_INLINED) {
1924                     return null;
1925                 }
1926             }
1927         } finally {
1928             currentInvoke = null;
1929         }
1930         int invokeBci = bci();
1931         JavaTypeProfile profile = getProfileForInvoke(invokeKind);
1932         ExceptionEdgeAction edgeAction = getActionForInvokeExceptionEdge(inlineInfo);
1933         boolean partialIntrinsicExit = false;
1934         if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1935             partialIntrinsicExit = true;
1936             ResolvedJavaMethod originalMethod = intrinsicContext.getOriginalMethod();
1937             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
1938             if (intrinsicCallSiteParser != null) {
1939                 // When exiting a partial intrinsic, the invoke to the original
1940                 // must use the same context as the call to the intrinsic.
1941                 invokeBci = intrinsicCallSiteParser.bci();
1942                 profile = intrinsicCallSiteParser.getProfileForInvoke(invokeKind);
1943                 edgeAction = intrinsicCallSiteParser.getActionForInvokeExceptionEdge(inlineInfo);
1944             } else {
1945                 // We are parsing the intrinsic for the root compilation or for inlining,
1946                 // This call is a partial intrinsic exit, and we do not have profile information
1947                 // for this callsite. We also have to assume that the call needs an exception
1948                 // edge. Finally, we know that this intrinsic is parsed for late inlining,
1949                 // so the bci must be set to unknown, so that the inliner patches it later.
1950                 assert intrinsicContext.isPostParseInlined();
1951                 invokeBci = UNKNOWN_BCI;
1952                 profile = null;
1953                 edgeAction = graph.method().getAnnotation(Snippet.class) == null ? ExceptionEdgeAction.INCLUDE_AND_HANDLE : ExceptionEdgeAction.OMIT;
1954             }
1955 
1956             if (originalMethod.isStatic()) {
1957                 invokeKind = InvokeKind.Static;
1958             } else {
1959                 // The original call to the intrinsic must have been devirtualized
1960                 // otherwise we wouldn&#39;t be here.
1961                 invokeKind = InvokeKind.Special;
1962             }
1963             Signature sig = originalMethod.getSignature();
1964             returnType = sig.getReturnType(method.getDeclaringClass());
1965             resultType = sig.getReturnKind();
1966             assert intrinsicContext.allowPartialIntrinsicArgumentMismatch() || checkPartialIntrinsicExit(intrinsicCallSiteParser == null ? null : intrinsicCallSiteParser.currentInvoke.args, args);
1967             targetMethod = originalMethod;
1968         }
1969         Invoke invoke = createNonInlinedInvoke(edgeAction, invokeBci, args, targetMethod, invokeKind, resultType, returnType, profile);
1970         graph.getInliningLog().addDecision(invoke, false, &quot;GraphBuilderPhase&quot;, null, null, &quot;bytecode parser did not replace invoke&quot;);
1971         if (partialIntrinsicExit) {
1972             // This invoke must never be later inlined as it might select the intrinsic graph.
1973             // Until there is a mechanism to guarantee that any late inlining will not select
1974             // the intrinsic graph, prevent this invoke from being inlined.
1975             invoke.setUseForInlining(false);
1976         }
1977         return invoke;
1978     }
1979 
1980     /**
1981      * Checks that the class of the receiver of an {@link Bytecodes#INVOKEINTERFACE} invocation of a
1982      * private method is assignable to the interface that declared the method. If not, then
1983      * deoptimize so that the interpreter can throw an {@link IllegalAccessError}.
1984      *
1985      * This is a check not performed by the verifier and so must be performed at runtime.
1986      *
1987      * @param declaringClass interface declaring the callee
1988      * @param args arguments to an {@link Bytecodes#INVOKEINTERFACE} call to a private method
1989      *            declared in a interface
1990      */
1991     private void emitCheckForDeclaringClassChange(ResolvedJavaType declaringClass, ValueNode[] args) {
1992         ValueNode receiver = args[0];
1993         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), declaringClass);
1994         LogicNode condition = genUnique(createInstanceOf(checkedType, receiver, null));
1995         FixedGuardNode fixedGuard = append(new FixedGuardNode(condition, ClassCastException, None, false));
1996         args[0] = append(PiNode.create(receiver, StampFactory.object(checkedType, true), fixedGuard));
1997     }
1998 
1999     /**
2000      * Checks that the class of the receiver of an {@link Bytecodes#INVOKESPECIAL} in a method
2001      * declared in an interface (i.e., a default method) is assignable to the interface. If not,
2002      * then deoptimize so that the interpreter can throw an {@link IllegalAccessError}.
2003      *
2004      * This is a check not performed by the verifier and so must be performed at runtime.
2005      *
2006      * @param args arguments to an {@link Bytecodes#INVOKESPECIAL} implementing a direct call to a
2007      *            method in a super class
2008      */
2009     protected void emitCheckForInvokeSuperSpecial(ValueNode[] args) {
2010         ResolvedJavaType callingClass = method.getDeclaringClass();
2011         if (callingClass.getHostClass() != null) {
2012             callingClass = callingClass.getHostClass();
2013         }
2014         if (callingClass.isInterface()) {
2015             ValueNode receiver = args[0];
2016             TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), callingClass);
2017             LogicNode condition = genUnique(createInstanceOf(checkedType, receiver, null));
2018             FixedGuardNode fixedGuard = append(new FixedGuardNode(condition, ClassCastException, None, false));
2019             args[0] = append(PiNode.create(receiver, StampFactory.object(checkedType, true), fixedGuard));
2020         }
2021     }
2022 
2023     protected JavaTypeProfile getProfileForInvoke(InvokeKind invokeKind) {
2024         if (invokeKind.isIndirect() &amp;&amp; profilingInfo != null &amp;&amp; this.optimisticOpts.useTypeCheckHints(getOptions())) {
2025             return profilingInfo.getTypeProfile(bci());
2026         }
2027         return null;
2028     }
2029 
2030     /**
2031      * A partial intrinsic exits by (effectively) calling the intrinsified method. This call must
2032      * use exactly the arguments to the call being intrinsified.
2033      *
2034      * @param originalArgs arguments of original call to intrinsified method
2035      * @param recursiveArgs arguments of recursive call to intrinsified method
2036      */
2037     private static boolean checkPartialIntrinsicExit(ValueNode[] originalArgs, ValueNode[] recursiveArgs) {
2038         if (originalArgs != null) {
2039             for (int i = 0; i &lt; originalArgs.length; i++) {
2040                 ValueNode arg = GraphUtil.unproxify(recursiveArgs[i]);
2041                 ValueNode icArg = GraphUtil.unproxify(originalArgs[i]);
2042                 assert arg == icArg : String.format(&quot;argument %d of call denoting partial intrinsic exit should be %s, not %s&quot;, i, icArg, arg);
2043             }
2044         } else {
2045             for (int i = 0; i &lt; recursiveArgs.length; i++) {
2046                 ValueNode arg = GraphUtil.unproxify(recursiveArgs[i]);
2047                 assert arg instanceof ParameterNode &amp;&amp; ((ParameterNode) arg).index() == i : String.format(&quot;argument %d of call denoting partial intrinsic exit should be a %s with index %d, not %s&quot;,
2048                                 i, ParameterNode.class.getSimpleName(), i, arg);
2049             }
2050         }
2051         return true;
2052     }
2053 
2054     protected Invoke createNonInlinedInvoke(ExceptionEdgeAction exceptionEdge, int invokeBci, ValueNode[] invokeArgs, ResolvedJavaMethod targetMethod,
2055                     InvokeKind invokeKind, JavaKind resultType, JavaType returnType, JavaTypeProfile profile) {
2056 
2057         StampPair returnStamp = graphBuilderConfig.getPlugins().getOverridingStamp(this, returnType, false);
2058         if (returnStamp == null) {
2059             returnStamp = StampFactory.forDeclaredType(graph.getAssumptions(), returnType, false);
2060         }
2061 
2062         MethodCallTargetNode callTarget = graph.add(createMethodCallTarget(invokeKind, targetMethod, invokeArgs, returnStamp, profile));
2063         Invoke invoke = createNonInlinedInvoke(exceptionEdge, invokeBci, callTarget, resultType);
2064 
2065         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2066             plugin.notifyNotInlined(this, targetMethod, invoke);
2067         }
2068 
2069         return invoke;
2070     }
2071 
2072     protected Invoke createNonInlinedInvoke(ExceptionEdgeAction exceptionEdge, int invokeBci, CallTargetNode callTarget, JavaKind resultType) {
2073         if (exceptionEdge == ExceptionEdgeAction.OMIT) {
2074             return createInvoke(invokeBci, callTarget, resultType);
2075         } else {
2076             Invoke invoke = createInvokeWithException(invokeBci, callTarget, resultType, exceptionEdge);
2077             AbstractBeginNode beginNode = graph.add(KillingBeginNode.create(LocationIdentity.any()));
2078             invoke.setNext(beginNode);
2079             lastInstr = beginNode;
2080             return invoke;
2081         }
2082     }
2083 
2084     /**
2085      * Describes what should be done with the exception edge of an invocation. The edge can be
2086      * omitted or included. An included edge can handle the exception or transfer execution to the
2087      * interpreter for handling (deoptimize).
2088      */
2089     protected enum ExceptionEdgeAction {
2090         OMIT,
2091         INCLUDE_AND_HANDLE,
2092         INCLUDE_AND_DEOPTIMIZE
2093     }
2094 
2095     protected ExceptionEdgeAction getActionForInvokeExceptionEdge(InlineInfo lastInlineInfo) {
2096         if (lastInlineInfo == InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION) {
2097             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2098         } else if (lastInlineInfo == InlineInfo.DO_NOT_INLINE_NO_EXCEPTION) {
2099             return ExceptionEdgeAction.OMIT;
2100         } else if (lastInlineInfo == InlineInfo.DO_NOT_INLINE_DEOPTIMIZE_ON_EXCEPTION) {
2101             return ExceptionEdgeAction.INCLUDE_AND_DEOPTIMIZE;
2102         } else if (graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.CheckAll) {
2103             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2104         } else if (graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.ExplicitOnly) {
2105             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2106         } else if (graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.OmitAll) {
2107             return ExceptionEdgeAction.OMIT;
2108         } else {
2109             assert graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.Profile;
2110             // be conservative if information was not recorded (could result in endless
2111             // recompiles otherwise)
2112             if (!StressInvokeWithExceptionNode.getValue(options)) {
2113                 if (optimisticOpts.useExceptionProbability(getOptions())) {
2114                     if (profilingInfo != null) {
2115                         TriState exceptionSeen = profilingInfo.getExceptionSeen(bci());
2116                         if (exceptionSeen == TriState.FALSE) {
2117                             return ExceptionEdgeAction.OMIT;
2118                         }
2119                     }
2120                 }
2121             }
2122             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2123         }
2124     }
2125 
2126     /**
2127      * Contains all the assertion checking logic around the application of an
2128      * {@link InvocationPlugin}. This class is only loaded when assertions are enabled.
2129      */
2130     class InvocationPluginAssertions {
2131         final InvocationPlugin plugin;
2132         final ValueNode[] args;
2133         final ResolvedJavaMethod targetMethod;
2134         final JavaKind resultType;
2135         final int beforeStackSize;
2136         final boolean needsNullCheck;
2137         final int nodeCount;
2138         final Mark mark;
2139 
2140         InvocationPluginAssertions(InvocationPlugin plugin, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
2141             guarantee(Assertions.assertionsEnabled(), &quot;%s should only be loaded and instantiated if assertions are enabled&quot;, getClass().getSimpleName());
2142             this.plugin = plugin;
2143             this.targetMethod = targetMethod;
2144             this.args = args;
2145             this.resultType = resultType;
2146             this.beforeStackSize = frameState.stackSize();
2147             this.needsNullCheck = !targetMethod.isStatic() &amp;&amp; args[0].getStackKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerNonNull(args[0].stamp(NodeView.DEFAULT));
2148             this.nodeCount = graph.getNodeCount();
2149             this.mark = graph.getMark();
2150         }
2151 
2152         String error(String format, Object... a) {
2153             return String.format(format, a) + String.format(&quot;%n\tplugin at %s&quot;, plugin.getApplySourceLocation(getMetaAccess()));
2154         }
2155 
2156         boolean check(boolean pluginResult) {
2157             if (pluginResult) {
2158                 /*
2159                  * If lastInstr is null, even if this method has a non-void return type, the method
2160                  * doesn&#39;t return a value, it probably throws an exception.
2161                  */
2162                 int expectedStackSize = beforeStackSize + resultType.getSlotCount();
2163                 assert lastInstr == null || expectedStackSize == frameState.stackSize() : error(&quot;plugin manipulated the stack incorrectly: expected=%d, actual=%d&quot;, expectedStackSize,
2164                                 frameState.stackSize());
2165 
2166                 NodeIterable&lt;Node&gt; newNodes = graph.getNewNodes(mark);
2167                 assert !needsNullCheck || isPointerNonNull(args[0].stamp(NodeView.DEFAULT)) : error(&quot;plugin needs to null check the receiver of %s: receiver=%s&quot;, targetMethod.format(&quot;%H.%n(%p)&quot;),
2168                                 args[0]);
2169                 for (Node n : newNodes) {
2170                     if (n instanceof StateSplit) {
2171                         StateSplit stateSplit = (StateSplit) n;
2172                         assert stateSplit.stateAfter() != null || !stateSplit.hasSideEffect() : error(&quot;%s node added by plugin for %s need to have a non-null frame state: %s&quot;,
2173                                         StateSplit.class.getSimpleName(), targetMethod.format(&quot;%H.%n(%p)&quot;), stateSplit);
2174                     }
2175                 }
2176                 try {
2177                     graphBuilderConfig.getPlugins().getInvocationPlugins().checkNewNodes(BytecodeParser.this, plugin, newNodes);
2178                 } catch (Throwable t) {
2179                     throw new AssertionError(error(&quot;Error in plugin&quot;), t);
2180                 }
2181             } else {
2182                 assert nodeCount == graph.getNodeCount() : error(&quot;plugin that returns false must not create new nodes&quot;);
2183                 assert beforeStackSize == frameState.stackSize() : error(&quot;plugin that returns false must not modify the stack&quot;);
2184             }
2185             return true;
2186         }
2187     }
2188 
2189     @SuppressWarnings(&quot;try&quot;)
2190     protected boolean tryInvocationPlugin(InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
2191         InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
2192         if (plugin != null) {
2193 
2194             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
2195                 // Self recursive intrinsic means the original method should be called.
2196                 return false;
2197             }
2198 
2199             InvocationPluginReceiver pluginReceiver = invocationPluginReceiver.init(targetMethod, args);
2200             assert invokeKind.isDirect() : &quot;Cannot apply invocation plugin on an indirect call site.&quot;;
2201 
2202             InvocationPluginAssertions assertions = Assertions.assertionsEnabled() ? new InvocationPluginAssertions(plugin, args, targetMethod, resultType) : null;
2203             try (DebugCloseable context = openNodeContext(targetMethod)) {
2204                 if (plugin.execute(this, targetMethod, pluginReceiver, args)) {
2205                     assert assertions.check(true);
2206                     return !plugin.isDecorator();
2207                 } else {
2208                     assert assertions.check(false);
2209                 }
2210             }
2211         }
2212         return false;
2213     }
2214 
2215     private boolean tryNodePluginForInvocation(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2216         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
2217             if (plugin.handleInvoke(this, targetMethod, args)) {
2218                 return true;
2219             }
2220         }
2221         return false;
2222     }
2223 
2224     private static final InlineInfo SUCCESSFULLY_INLINED = InlineInfo.createStandardInlineInfo(null);
2225 
2226     /**
2227      * Try to inline a method. If the method was inlined, returns {@link #SUCCESSFULLY_INLINED}.
2228      * Otherwise, it returns the {@link InlineInfo} that lead to the decision to not inline it, or
2229      * {@code null} if there is no {@link InlineInfo} for this method.
2230      */
2231     private InlineInfo tryInline(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2232         boolean canBeInlined = forceInliningEverything || parsingIntrinsic() || targetMethod.canBeInlined();
2233         if (!canBeInlined) {
2234             return null;
2235         }
2236 
2237         if (forceInliningEverything) {
2238             if (inline(targetMethod, targetMethod, null, args)) {
2239                 return SUCCESSFULLY_INLINED;
2240             } else {
2241                 return null;
2242             }
2243         }
2244 
2245         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2246             InlineInfo inlineInfo = plugin.shouldInlineInvoke(this, targetMethod, args);
2247             if (inlineInfo != null) {
2248                 if (inlineInfo.allowsInlining()) {
2249                     if (inline(targetMethod, inlineInfo.getMethodToInline(), inlineInfo.getIntrinsicBytecodeProvider(), args)) {
2250                         return SUCCESSFULLY_INLINED;
2251                     }
2252                     inlineInfo = null;
2253                 }
2254                 /* Do not inline, and do not ask the remaining plugins. */
2255                 return inlineInfo;
2256             }
2257         }
2258 
2259         // There was no inline plugin with a definite answer to whether or not
2260         // to inline. If we&#39;re parsing an intrinsic, then we need to enforce the
2261         // invariant here that methods are always force inlined in intrinsics/snippets.
2262         if (parsingIntrinsic()) {
2263             if (inline(targetMethod, targetMethod, this.bytecodeProvider, args)) {
2264                 return SUCCESSFULLY_INLINED;
2265             }
2266         }
2267         return null;
2268     }
2269 
2270     private static final int ACCESSOR_BYTECODE_LENGTH = 5;
2271 
2272     /**
2273      * Tries to inline {@code targetMethod} if it is an instance field accessor. This avoids the
2274      * overhead of creating and using a nested {@link BytecodeParser} object.
2275      */
2276     @SuppressWarnings(&quot;try&quot;)
2277     private boolean tryFastInlineAccessor(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2278         byte[] bytecode = targetMethod.getCode();
2279         if (bytecode != null &amp;&amp; bytecode.length == ACCESSOR_BYTECODE_LENGTH &amp;&amp;
2280                         Bytes.beU1(bytecode, 0) == ALOAD_0 &amp;&amp;
2281                         Bytes.beU1(bytecode, 1) == GETFIELD) {
2282             int b4 = Bytes.beU1(bytecode, 4);
2283             if (b4 &gt;= IRETURN &amp;&amp; b4 &lt;= ARETURN) {
2284                 int cpi = Bytes.beU2(bytecode, 2);
2285                 JavaField field = targetMethod.getConstantPool().lookupField(cpi, targetMethod, GETFIELD);
2286                 if (field instanceof ResolvedJavaField) {
2287                     ValueNode receiver = invocationPluginReceiver.init(targetMethod, args).get();
2288                     ResolvedJavaField resolvedField = (ResolvedJavaField) field;
2289                     try (DebugCloseable context = openNodeContext(targetMethod, 1)) {
2290                         genGetField(resolvedField, receiver);
2291                         notifyBeforeInline(targetMethod);
2292                         printInlining(targetMethod, targetMethod, true, &quot;inline accessor method (bytecode parsing)&quot;);
2293                         notifyAfterInline(targetMethod);
2294                     }
2295                     return true;
2296                 }
2297             }
2298         }
2299         return false;
2300     }
2301 
2302     /**
2303      * Inline a method substitution graph. This is necessary for libgraal as substitutions only
2304      * exist as encoded graphs and can&#39;t be parsed directly into the caller.
2305      */
2306     @Override
2307     @SuppressWarnings(&quot;try&quot;)
2308     public boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] args) {
2309         if (receiver != null) {
2310             receiver.get();
2311         }
2312 
2313         InvokeWithExceptionNode withException = null;
2314         FixedWithNextNode replacee = lastInstr;
2315         try (DebugContext.Scope a = debug.scope(&quot;instantiate&quot;, substituteGraph)) {
2316             // Inline the snippet nodes, replacing parameters with the given args in the process
2317             StartNode entryPointNode = substituteGraph.start();
2318             FixedNode firstCFGNode = entryPointNode.next();
2319             StructuredGraph replaceeGraph = replacee.graph();
2320             Mark mark = replaceeGraph.getMark();
2321             try (InliningScope inlineScope = new IntrinsicScope(this, targetMethod, args)) {
2322 
2323                 EconomicMap&lt;Node, Node&gt; replacementsMap = EconomicMap.create(Equivalence.IDENTITY);
2324                 for (ParameterNode param : substituteGraph.getNodes().filter(ParameterNode.class)) {
2325                     replacementsMap.put(param, args[param.index()]);
2326                 }
2327                 replacementsMap.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
2328 
2329                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;Before inlining method substitution %s&quot;, substituteGraph.method());
2330                 UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineMethodSubstitution(replaceeGraph, substituteGraph, replacementsMap);
2331 
2332                 FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
2333                 replacee.setNext(firstCFGNodeDuplicate);
2334                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After inlining method substitution %s&quot;, substituteGraph.method());
2335 
2336                 // Handle partial intrinsic exits
2337                 for (Node node : graph.getNewNodes(mark)) {
2338                     if (node instanceof Invoke) {
2339                         Invoke invoke = (Invoke) node;
2340                         if (invoke.bci() == BytecodeFrame.UNKNOWN_BCI) {
2341                             invoke.replaceBci(bci());
2342                         }
2343                         if (node instanceof InvokeWithExceptionNode) {
2344                             // The graphs for MethodSubsitutions are produced assuming that
2345                             // exceptions
2346                             // must be dispatched. If the calling context doesn&#39;t want exception
2347                             // then
2348                             // convert back into a normal InvokeNode.
2349                             assert withException == null : &quot;only one invoke expected&quot;;
2350                             withException = (InvokeWithExceptionNode) node;
2351                             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
2352                             if (intrinsicCallSiteParser != null &amp;&amp; intrinsicCallSiteParser.getActionForInvokeExceptionEdge(null) == ExceptionEdgeAction.OMIT) {
2353                                 InvokeNode newInvoke = graph.add(new InvokeNode(withException));
2354                                 newInvoke.setStateDuring(withException.stateDuring());
2355                                 newInvoke.setStateAfter(withException.stateAfter());
2356                                 withException.killExceptionEdge();
2357                                 AbstractBeginNode next = withException.killKillingBegin();
2358                                 FixedWithNextNode pred = (FixedWithNextNode) withException.predecessor();
2359                                 pred.setNext(newInvoke);
2360                                 withException.setNext(null);
2361                                 newInvoke.setNext(next);
2362                                 withException.replaceAndDelete(newInvoke);
2363                             } else {
2364                                 // Disconnnect exception edge
2365                                 withException.killExceptionEdge();
2366                             }
2367                         }
2368                     } else if (node instanceof ForeignCallNode) {
2369                         ForeignCallNode call = (ForeignCallNode) node;
2370                         if (call.getBci() == BytecodeFrame.UNKNOWN_BCI) {
2371                             call.setBci(bci());
2372                             if (call.stateAfter() != null &amp;&amp; call.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
2373                                 call.setStateAfter(inlineScope.stateBefore);
2374                             }
2375                         }
2376                     }
2377                 }
2378 
2379                 ArrayList&lt;ReturnToCallerData&gt; calleeReturnDataList = new ArrayList&lt;&gt;();
2380                 for (ReturnNode n : substituteGraph.getNodes().filter(ReturnNode.class)) {
2381                     ReturnNode returnNode = (ReturnNode) duplicates.get(n);
2382                     FixedWithNextNode predecessor = (FixedWithNextNode) returnNode.predecessor();
2383                     calleeReturnDataList.add(new ReturnToCallerData(returnNode.result(), predecessor));
2384                     predecessor.setNext(null);
2385                     returnNode.safeDelete();
2386                 }
2387 
2388                 // Merge multiple returns
2389                 processCalleeReturn(targetMethod, inlineScope, calleeReturnDataList);
2390 
2391                 // Exiting this scope causes processing of the placeholder frame states.
2392             }
2393 
2394             if (withException != null &amp;&amp; withException.isAlive()) {
2395                 // Connect exception edge into main graph
2396                 AbstractBeginNode exceptionEdge = handleException(null, bci(), false);
2397                 withException.setExceptionEdge(exceptionEdge);
2398             }
2399 
2400             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
2401             return true;
2402         } catch (Throwable t) {
2403             throw debug.handle(t);
2404         }
2405     }
2406 
2407     private static UnmodifiableEconomicMap&lt;Node, Node&gt; inlineMethodSubstitution(StructuredGraph replaceeGraph, StructuredGraph snippet,
2408                     EconomicMap&lt;Node, Node&gt; replacementsMap) {
2409         try (InliningLog.UpdateScope scope = replaceeGraph.getInliningLog().openUpdateScope((oldNode, newNode) -&gt; {
2410             InliningLog log = replaceeGraph.getInliningLog();
2411             if (oldNode == null) {
2412                 log.trackNewCallsite(newNode);
2413             }
2414         })) {
2415             StartNode entryPointNode = snippet.start();
2416             ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(snippet.getNodeCount());
2417             for (Node node : snippet.getNodes()) {
2418                 if (node != entryPointNode &amp;&amp; node != entryPointNode.stateAfter()) {
2419                     nodes.add(node);
2420                 }
2421             }
2422             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = replaceeGraph.addDuplicates(nodes, snippet, snippet.getNodeCount(), replacementsMap);
2423             if (scope != null) {
2424                 replaceeGraph.getInliningLog().addLog(duplicates, snippet.getInliningLog());
2425             }
2426             return duplicates;
2427         }
2428     }
2429 
2430     @Override
2431     public boolean intrinsify(BytecodeProvider intrinsicBytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
2432         if (receiver != null) {
2433             receiver.get();
2434         }
2435         boolean res = inline(targetMethod, substitute, intrinsicBytecodeProvider, args);
2436         assert res : &quot;failed to inline &quot; + substitute;
2437         return res;
2438     }
2439 
2440     private boolean inline(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, BytecodeProvider intrinsicBytecodeProvider, ValueNode[] args) {
2441         try (InliningLog.RootScope scope = graph.getInliningLog().openRootScope(targetMethod, bci())) {
2442             IntrinsicContext intrinsic = this.intrinsicContext;
2443 
2444             if (intrinsic == null &amp;&amp; !graphBuilderConfig.insertFullInfopoints() &amp;&amp;
2445                             targetMethod.equals(inlinedMethod) &amp;&amp;
2446                             (targetMethod.getModifiers() &amp; (STATIC | SYNCHRONIZED)) == 0 &amp;&amp;
2447                             tryFastInlineAccessor(args, targetMethod)) {
2448                 return true;
2449             }
2450 
2451             if (intrinsic != null &amp;&amp; intrinsic.isCallToOriginal(targetMethod)) {
2452                 if (intrinsic.isCompilationRoot()) {
2453                     // A root compiled intrinsic needs to deoptimize
2454                     // if the slow path is taken. During frame state
2455                     // assignment, the deopt node will get its stateBefore
2456                     // from the start node of the intrinsic
2457                     append(new DeoptimizeNode(InvalidateRecompile, RuntimeConstraint));
2458                     printInlining(targetMethod, inlinedMethod, true, &quot;compilation root (bytecode parsing)&quot;);
2459                     if (scope != null) {
2460                         graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;compilation root&quot;);
2461                     }
2462                     return true;
2463                 } else {
2464                     if (intrinsic.getOriginalMethod().isNative()) {
2465                         printInlining(targetMethod, inlinedMethod, false, &quot;native method (bytecode parsing)&quot;);
2466                         if (scope != null) {
2467                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;native method&quot;);
2468                         }
2469                         return false;
2470                     }
2471                     if (canInlinePartialIntrinsicExit()) {
2472                         // Otherwise inline the original method. Any frame state created
2473                         // during the inlining will exclude frame(s) in the
2474                         // intrinsic method (see FrameStateBuilder.create(int bci)).
2475                         notifyBeforeInline(inlinedMethod);
2476                         printInlining(targetMethod, inlinedMethod, true, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2477                         if (scope != null) {
2478                             graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2479                         }
2480                         parseAndInlineCallee(intrinsic.getOriginalMethod(), args, null);
2481                         notifyAfterInline(inlinedMethod);
2482                         return true;
2483                     } else {
2484                         printInlining(targetMethod, inlinedMethod, false, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2485                         if (scope != null) {
2486                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2487                         }
2488                         return false;
2489                     }
2490                 }
2491             } else {
2492                 boolean isIntrinsic = intrinsicBytecodeProvider != null;
2493                 if (intrinsic == null &amp;&amp; isIntrinsic) {
2494                     assert !inlinedMethod.equals(targetMethod);
2495                     intrinsic = new IntrinsicContext(targetMethod, inlinedMethod, intrinsicBytecodeProvider, INLINE_DURING_PARSING);
2496                 }
2497                 if (inlinedMethod.hasBytecodes()) {
2498                     notifyBeforeInline(inlinedMethod);
2499                     printInlining(targetMethod, inlinedMethod, true, &quot;inline method (bytecode parsing)&quot;);
2500                     if (scope != null) {
2501                         graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;inline method&quot;);
2502                     }
2503                     parseAndInlineCallee(inlinedMethod, args, intrinsic);
2504                     notifyAfterInline(inlinedMethod);
2505                 } else {
2506                     printInlining(targetMethod, inlinedMethod, false, &quot;no bytecodes (abstract or native) (bytecode parsing)&quot;);
2507                     if (scope != null) {
2508                         graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;no bytecodes (abstract or native)&quot;);
2509                     }
2510                     return false;
2511                 }
2512             }
2513             return true;
2514         }
2515     }
2516 
2517     protected void notifyBeforeInline(ResolvedJavaMethod inlinedMethod) {
2518         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2519             plugin.notifyBeforeInline(inlinedMethod);
2520         }
2521     }
2522 
2523     protected void notifyAfterInline(ResolvedJavaMethod inlinedMethod) {
2524         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2525             plugin.notifyAfterInline(inlinedMethod);
2526         }
2527     }
2528 
2529     /**
2530      * Determines if a partial intrinsic exit (i.e., a call to the original method within an
2531      * intrinsic) can be inlined.
2532      */
2533     protected boolean canInlinePartialIntrinsicExit() {
2534         return InlinePartialIntrinsicExitDuringParsing.getValue(options) &amp;&amp; !IS_BUILDING_NATIVE_IMAGE &amp;&amp; method.getAnnotation(Snippet.class) == null;
2535     }
2536 
2537     private void printInlining(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, boolean success, String msg) {
2538         if (success) {
2539             if (TraceInlineDuringParsing.getValue(options) || TraceParserPlugins.getValue(options)) {
2540                 if (targetMethod.equals(inlinedMethod)) {
2541                     traceWithContext(&quot;inlining call to %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;));
2542                 } else {
2543                     traceWithContext(&quot;inlining call to %s as intrinsic for %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;), targetMethod.format(&quot;%h.%n(%p)&quot;));
2544                 }
2545             }
2546         }
2547         if (HotSpotPrintInlining.getValue(options)) {
2548             if (targetMethod.equals(inlinedMethod)) {
2549                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s&quot;, msg);
2550             } else {
2551                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s intrinsic for %s&quot;, msg, targetMethod.format(&quot;%h.%n(%p)&quot;));
2552             }
2553         }
2554     }
2555 
2556     /**
2557      * Prints a line to {@link TTY} with a prefix indicating the current parse context. The prefix
2558      * is of the form:
2559      *
2560      * &lt;pre&gt;
2561      * {SPACE * n} {name of method being parsed} &quot;(&quot; {file name} &quot;:&quot; {line number} &quot;)&quot;
2562      * &lt;/pre&gt;
2563      *
2564      * where {@code n} is the current inlining depth.
2565      *
2566      * @param format a format string
2567      * @param args arguments to the format string
2568      */
2569 
2570     protected void traceWithContext(String format, Object... args) {
2571         StackTraceElement where = code.asStackTraceElement(bci());
2572         String s = format(&quot;%s%s (%s:%d) %s&quot;, nSpaces(getDepth()), method.isConstructor() ? method.format(&quot;%h.%n&quot;) : method.getName(), where.getFileName(), where.getLineNumber(),
2573                         format(format, args));
2574         TTY.println(s);
2575     }
2576 
2577     protected RuntimeException throwParserError(Throwable e) {
2578         if (e instanceof BytecodeParserError) {
2579             throw (BytecodeParserError) e;
2580         }
2581         BytecodeParser bp = this;
2582         BytecodeParserError res = new BytecodeParserError(e);
2583         while (bp != null) {
2584             res.addContext(&quot;parsing &quot; + bp.code.asStackTraceElement(bp.bci()));
2585             bp = bp.parent;
2586         }
2587         throw res;
2588     }
2589 
2590     protected void parseAndInlineCallee(ResolvedJavaMethod targetMethod, ValueNode[] args, IntrinsicContext calleeIntrinsicContext) {
2591         FixedWithNextNode calleeBeforeUnwindNode = null;
2592         ValueNode calleeUnwindValue = null;
2593 
2594         try (InliningScope s = parsingIntrinsic() ? null
2595                         : (calleeIntrinsicContext != null ? new IntrinsicScope(this, targetMethod, args)
2596                                         : new InliningScope(this, targetMethod, args))) {
2597             BytecodeParser parser = graphBuilderInstance.createBytecodeParser(graph, this, targetMethod, INVOCATION_ENTRY_BCI, calleeIntrinsicContext);
2598             boolean targetIsSubstitution = targetMethod.isAnnotationPresent(MethodSubstitution.class);
2599             FrameStateBuilder startFrameState = new FrameStateBuilder(parser, parser.code, graph, graphBuilderConfig.retainLocalVariables() &amp;&amp; !targetIsSubstitution);
2600             if (!targetMethod.isStatic()) {
2601                 args[0] = nullCheckedValue(args[0]);
2602             }
2603             startFrameState.initializeFromArgumentsArray(args);
2604             parser.build(this.lastInstr, startFrameState);
2605 
2606             List&lt;ReturnToCallerData&gt; calleeReturnDataList = parser.returnDataList;
2607 
2608             /*
2609              * Propagate any side effects into the caller when parsing intrinsics.
2610              */
2611             if (parser.frameState.isAfterSideEffect() &amp;&amp; parsingIntrinsic()) {
2612                 for (StateSplit sideEffect : parser.frameState.sideEffects()) {
2613                     frameState.addSideEffect(sideEffect);
2614                 }
2615             }
2616 
2617             processCalleeReturn(targetMethod, s, calleeReturnDataList);
2618 
2619             calleeBeforeUnwindNode = parser.getBeforeUnwindNode();
2620             if (calleeBeforeUnwindNode != null) {
2621                 calleeUnwindValue = parser.getUnwindValue();
2622                 assert calleeUnwindValue != null;
2623             }
2624         }
2625 
2626         /*
2627          * Method handleException will call createTarget, which wires this exception edge to the
2628          * corresponding exception dispatch block in the caller. In the case where it wires to the
2629          * caller&#39;s unwind block, any FrameState created meanwhile, e.g., FrameState for
2630          * LoopExitNode, would be instantiated with AFTER_EXCEPTION_BCI. Such frame states should
2631          * not be fixed by IntrinsicScope.close, as they denote the states of the caller. Thus, the
2632          * following code should be placed outside the IntrinsicScope, so that correctly created
2633          * FrameStates are not replaced.
2634          */
2635         if (calleeBeforeUnwindNode != null) {
2636             calleeBeforeUnwindNode.setNext(handleException(calleeUnwindValue, bci(), false));
2637         }
2638     }
2639 
2640     private ValueNode processCalleeReturn(ResolvedJavaMethod targetMethod, InliningScope inliningScope, List&lt;ReturnToCallerData&gt; calleeReturnDataList) {
2641         if (calleeReturnDataList == null) {
2642             /* Callee does not return. */
2643             lastInstr = null;
2644         } else {
2645             ValueNode calleeReturnValue;
2646             MergeNode returnMergeNode = null;
2647             if (inliningScope != null) {
2648                 inliningScope.returnDataList = calleeReturnDataList;
2649             }
2650             if (calleeReturnDataList.size() == 1) {
2651                 /* Callee has a single return, we can continue parsing at that point. */
2652                 ReturnToCallerData singleReturnData = calleeReturnDataList.get(0);
2653                 lastInstr = singleReturnData.beforeReturnNode;
2654                 calleeReturnValue = singleReturnData.returnValue;
2655             } else {
2656                 assert calleeReturnDataList.size() &gt; 1;
2657                 /* Callee has multiple returns, we need to insert a control flow merge. */
2658                 returnMergeNode = graph.add(new MergeNode());
2659                 calleeReturnValue = ValueMergeUtil.mergeValueProducers(returnMergeNode, calleeReturnDataList, returnData -&gt; returnData.beforeReturnNode, returnData -&gt; returnData.returnValue);
2660             }
2661 
2662             if (calleeReturnValue != null) {
2663                 frameState.push(targetMethod.getSignature().getReturnKind().getStackKind(), calleeReturnValue);
2664             }
2665             if (returnMergeNode != null) {
2666                 returnMergeNode.setStateAfter(createFrameState(stream.nextBCI(), returnMergeNode));
2667                 lastInstr = finishInstruction(returnMergeNode, frameState);
2668             }
2669             return calleeReturnValue;
2670         }
2671         return null;
2672     }
2673 
2674     public MethodCallTargetNode createMethodCallTarget(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, StampPair returnStamp, JavaTypeProfile profile) {
2675         return new MethodCallTargetNode(invokeKind, targetMethod, args, returnStamp, profile);
2676     }
2677 
2678     protected InvokeNode createInvoke(int invokeBci, CallTargetNode callTarget, JavaKind resultType) {
2679         InvokeNode invoke = append(new InvokeNode(callTarget, invokeBci));
2680         frameState.pushReturn(resultType, invoke);
2681         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2682         return invoke;
2683     }
2684 
2685     protected InvokeWithExceptionNode createInvokeWithException(int invokeBci, CallTargetNode callTarget, JavaKind resultType, ExceptionEdgeAction exceptionEdgeAction) {
2686         if (currentBlock != null &amp;&amp; stream.nextBCI() &gt; currentBlock.endBci) {
2687             /*
2688              * Clear non-live locals early so that the exception handler entry gets the cleared
2689              * state.
2690              */
2691             frameState.clearNonLiveLocals(currentBlock, liveness, false);
2692         }
2693 
2694         AbstractBeginNode exceptionEdge = handleException(null, bci(), exceptionEdgeAction == ExceptionEdgeAction.INCLUDE_AND_DEOPTIMIZE);
2695         InvokeWithExceptionNode invoke = append(new InvokeWithExceptionNode(callTarget, exceptionEdge, invokeBci));
2696         frameState.pushReturn(resultType, invoke);
2697         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2698         return invoke;
2699     }
2700 
2701     protected void genReturn(ValueNode returnVal, JavaKind returnKind) {
2702         if (parsingIntrinsic() &amp;&amp; returnVal != null) {
2703 
2704             if (returnVal instanceof StateSplit) {
2705                 StateSplit stateSplit = (StateSplit) returnVal;
2706                 FrameState stateAfter = stateSplit.stateAfter();
2707                 if (stateSplit.hasSideEffect()) {
2708                     assert stateSplit != null;
2709                     if (stateAfter.bci == BytecodeFrame.AFTER_BCI) {
2710                         assert stateAfter.hasExactlyOneUsage();
2711                         assert stateAfter.usages().first() == stateSplit;
2712                         FrameState state;
2713                         if (returnVal.getStackKind() == JavaKind.Illegal) {
2714                             // This should only occur when Fold and NodeIntrinsic plugins are
2715                             // deferred. Their return value might not be a Java type and in that
2716                             // case this can&#39;t be the final AFTER_BCI so just create a FrameState
2717                             // without a return value on the top of stack.
2718                             assert stateSplit instanceof Invoke;
2719                             ResolvedJavaMethod targetMethod = ((Invoke) stateSplit).getTargetMethod();
2720                             assert targetMethod != null &amp;&amp; (targetMethod.getAnnotation(Fold.class) != null || targetMethod.getAnnotation(Node.NodeIntrinsic.class) != null);
2721                             state = new FrameState(BytecodeFrame.AFTER_BCI);
2722                         } else {
2723                             state = new FrameState(BytecodeFrame.AFTER_BCI, returnVal);
2724                         }
2725                         stateAfter.replaceAtUsages(graph.add(state));
2726                         GraphUtil.killWithUnusedFloatingInputs(stateAfter);
2727                     } else {
2728                         /*
2729                          * This must be the return value from within a partial intrinsification.
2730                          */
2731                         assert !BytecodeFrame.isPlaceholderBci(stateAfter.bci) || intrinsicContext.isDeferredInvoke(stateSplit);
2732                     }
2733                 } else {
2734                     assert stateAfter == null;
2735                 }
2736             }
2737         }
2738 
2739         ValueNode realReturnVal = processReturnValue(returnVal, returnKind);
2740 
2741         frameState.setRethrowException(false);
2742         frameState.clearStack();
2743         beforeReturn(realReturnVal, returnKind);
2744         if (parent == null) {
2745             append(new ReturnNode(realReturnVal));
2746         } else {
2747             if (returnDataList == null) {
2748                 returnDataList = new ArrayList&lt;&gt;();
2749             }
2750             returnDataList.add(new ReturnToCallerData(realReturnVal, lastInstr));
2751             lastInstr = null;
2752         }
2753     }
2754 
2755     private ValueNode processReturnValue(ValueNode value, JavaKind kind) {
2756         JavaKind returnKind = method.getSignature().getReturnKind();
2757         if (kind != returnKind) {
2758             // sub-word integer
2759             assert returnKind.isNumericInteger() &amp;&amp; returnKind.getStackKind() == JavaKind.Int;
2760             IntegerStamp stamp = (IntegerStamp) value.stamp(NodeView.DEFAULT);
2761 
2762             // the bytecode verifier doesn&#39;t check that the value is in the correct range
2763             if (stamp.lowerBound() &lt; returnKind.getMinValue() || returnKind.getMaxValue() &lt; stamp.upperBound()) {
2764                 return maskSubWordValue(value, returnKind);
2765             }
2766         }
2767 
2768         return value;
2769     }
2770 
2771     private void beforeReturn(ValueNode x, JavaKind kind) {
2772         if (graph.method() != null &amp;&amp; graph.method().isJavaLangObjectInit()) {
2773             /*
2774              * Get the receiver from the initial state since bytecode rewriting could do arbitrary
2775              * things to the state of the locals.
2776              */
2777             ValueNode receiver = graph.start().stateAfter().localAt(0);
2778             assert receiver != null &amp;&amp; receiver.getStackKind() == JavaKind.Object;
2779             if (RegisterFinalizerNode.mayHaveFinalizer(receiver, graph.getAssumptions())) {
2780                 append(new RegisterFinalizerNode(receiver));
2781             }
2782         }
2783         genInfoPointNode(InfopointReason.METHOD_END, x);
2784         if (finalBarrierRequired) {
2785             assert originalReceiver != null;
2786             /*
2787              * When compiling an OSR with a final field store, don&#39;t bother tracking the original
2788              * receiver since the receiver cannot be EA&#39;ed.
2789              */
2790             append(new FinalFieldBarrierNode(entryBCI == INVOCATION_ENTRY_BCI ? originalReceiver : null));
2791         }
2792         synchronizedEpilogue(BytecodeFrame.AFTER_BCI, x, kind);
2793         if (method.isSynchronized()) {
2794             finishPrepare(lastInstr, BytecodeFrame.AFTER_BCI, frameState);
2795         }
2796     }
2797 
2798     protected MonitorEnterNode createMonitorEnterNode(ValueNode x, MonitorIdNode monitorId) {
2799         return new MonitorEnterNode(x, monitorId);
2800     }
2801 
2802     protected void genMonitorEnter(ValueNode x, int bci) {
2803         MonitorIdNode monitorId = graph.add(new MonitorIdNode(frameState.lockDepth(true)));
2804         MonitorEnterNode monitorEnter = append(createMonitorEnterNode(x, monitorId));
2805         frameState.pushLock(x, monitorId);
2806         monitorEnter.setStateAfter(createFrameState(bci, monitorEnter));
2807     }
2808 
2809     protected void genMonitorExit(ValueNode x, ValueNode escapedValue, int bci) {
2810         if (frameState.lockDepth(false) == 0) {
2811             throw bailout(&quot;unbalanced monitors: too many exits&quot;);
2812         }
2813         MonitorIdNode monitorId = frameState.peekMonitorId();
2814         ValueNode lockedObject = frameState.popLock();
2815         ValueNode originalLockedObject = GraphUtil.originalValue(lockedObject, false);
2816         ValueNode originalX = GraphUtil.originalValue(x, false);
2817         if (originalLockedObject != originalX) {
2818             throw bailout(String.format(&quot;unbalanced monitors: mismatch at monitorexit, %s != %s&quot;, originalLockedObject, originalX));
2819         }
2820         MonitorExitNode monitorExit = append(new MonitorExitNode(lockedObject, monitorId, escapedValue));
2821         monitorExit.setStateAfter(createFrameState(bci, monitorExit));
2822     }
2823 
2824     protected void genJsr(int dest) {
2825         BciBlock successor = currentBlock.getJsrSuccessor();
2826         assert successor.startBci == dest : successor.startBci + &quot; != &quot; + dest + &quot; @&quot; + bci();
2827         JsrScope scope = currentBlock.getJsrScope();
2828         int nextBci = getStream().nextBCI();
2829         if (!successor.getJsrScope().pop().equals(scope)) {
2830             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2831         }
2832         if (successor.getJsrScope().nextReturnAddress() != nextBci) {
2833             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2834         }
2835         ConstantNode nextBciNode = getJsrConstant(nextBci);
2836         frameState.push(JavaKind.Object, nextBciNode);
2837         appendGoto(successor);
2838     }
2839 
2840     protected void genRet(int localIndex) {
2841         BciBlock successor = currentBlock.getRetSuccessor();
2842         ValueNode local = frameState.loadLocal(localIndex, JavaKind.Object);
2843         JsrScope scope = currentBlock.getJsrScope();
2844         int retAddress = scope.nextReturnAddress();
2845         ConstantNode returnBciNode = getJsrConstant(retAddress);
2846         LogicNode guard = IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, local, returnBciNode, NodeView.DEFAULT);
2847         if (!guard.isTautology()) {
2848             throw new JsrNotSupportedBailout(&quot;cannot statically decide jsr return address &quot; + local);
2849         }
2850         if (!successor.getJsrScope().equals(scope.pop())) {
2851             throw new JsrNotSupportedBailout(&quot;unstructured control flow (ret leaves more than one scope)&quot;);
2852         }
2853         appendGoto(successor);
2854     }
2855 
2856     private ConstantNode getJsrConstant(long bci) {
2857         JavaConstant nextBciConstant = new RawConstant(bci);
2858         Stamp nextBciStamp = StampFactory.forConstant(nextBciConstant);
2859         ConstantNode nextBciNode = new ConstantNode(nextBciConstant, nextBciStamp);
2860         return graph.unique(nextBciNode);
2861     }
2862 
2863     protected void genIntegerSwitch(ValueNode value, ArrayList&lt;BciBlock&gt; actualSuccessors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
2864         if (value.isConstant()) {
2865             JavaConstant constant = (JavaConstant) value.asConstant();
2866             int constantValue = constant.asInt();
2867             for (int i = 0; i &lt; keys.length; ++i) {
2868                 if (keys[i] == constantValue) {
2869                     appendGoto(actualSuccessors.get(keySuccessors[i]));
2870                     return;
2871                 }
2872             }
2873             appendGoto(actualSuccessors.get(keySuccessors[keys.length]));
2874         } else {
2875             this.controlFlowSplit = true;
2876             double[] successorProbabilities = successorProbabilites(actualSuccessors.size(), keySuccessors, keyProbabilities);
2877             IntegerSwitchNode switchNode = append(new IntegerSwitchNode(value, actualSuccessors.size(), keys, keyProbabilities, keySuccessors));
2878             for (int i = 0; i &lt; actualSuccessors.size(); i++) {
2879                 switchNode.setBlockSuccessor(i, createBlockTarget(successorProbabilities[i], actualSuccessors.get(i), frameState));
2880             }
2881         }
2882     }
2883 
2884     /**
2885      * Helper function that sums up the probabilities of all keys that lead to a specific successor.
2886      *
2887      * @return an array of size successorCount with the accumulated probability for each successor.
2888      */
2889     private static double[] successorProbabilites(int successorCount, int[] keySuccessors, double[] keyProbabilities) {
2890         double[] probability = new double[successorCount];
2891         for (int i = 0; i &lt; keySuccessors.length; i++) {
2892             probability[keySuccessors[i]] += keyProbabilities[i];
2893         }
2894         return probability;
2895     }
2896 
2897     protected ConstantNode appendConstant(JavaConstant constant) {
2898         assert constant != null;
2899         return ConstantNode.forConstant(constant, getMetaAccess(), graph);
2900     }
2901 
2902     @Override
2903     public &lt;T extends ValueNode&gt; T append(T v) {
2904         assert !graph.trackNodeSourcePosition() || graph.currentNodeSourcePosition() != null || currentBlock == blockMap.getUnwindBlock() || currentBlock instanceof ExceptionDispatchBlock;
2905         if (v.graph() != null) {
2906             return v;
2907         }
2908         T added = graph.addOrUniqueWithInputs(v);
2909         if (added == v) {
2910             updateLastInstruction(v);
2911         }
2912         return added;
2913     }
2914 
2915     private &lt;T extends ValueNode&gt; void updateLastInstruction(T v) {
2916         if (v instanceof FixedNode) {
2917             FixedNode fixedNode = (FixedNode) v;
2918             if (lastInstr != null) {
2919                 lastInstr.setNext(fixedNode);
2920             }
2921             if (fixedNode instanceof FixedWithNextNode) {
2922                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) fixedNode;
2923                 assert fixedWithNextNode.next() == null : &quot;cannot append instruction to instruction which isn&#39;t end&quot;;
2924                 lastInstr = fixedWithNextNode;
2925             } else {
2926                 lastInstr = null;
2927             }
2928         }
2929     }
2930 
2931     private Target checkLoopExit(Target target, BciBlock targetBlock) {
2932         if (currentBlock != null) {
2933             long exits = currentBlock.loops &amp; ~targetBlock.loops;
2934             if (exits != 0) {
2935                 LoopExitNode firstLoopExit = null;
2936                 LoopExitNode lastLoopExit = null;
2937 
2938                 int pos = 0;
2939                 ArrayList&lt;BciBlock&gt; exitLoops = new ArrayList&lt;&gt;(Long.bitCount(exits));
2940                 do {
2941                     long lMask = 1L &lt;&lt; pos;
2942                     if ((exits &amp; lMask) != 0) {
2943                         exitLoops.add(blockMap.getLoopHeader(pos));
2944                         exits &amp;= ~lMask;
2945                     }
2946                     pos++;
2947                 } while (exits != 0);
2948 
2949                 Collections.sort(exitLoops, new Comparator&lt;BciBlock&gt;() {
2950 
2951                     @Override
2952                     public int compare(BciBlock o1, BciBlock o2) {
2953                         return Long.bitCount(o2.loops) - Long.bitCount(o1.loops);
2954                     }
2955                 });
2956 
2957                 int bci = targetBlock.startBci;
2958                 if (targetBlock instanceof ExceptionDispatchBlock) {
2959                     bci = ((ExceptionDispatchBlock) targetBlock).deoptBci;
2960                 }
2961                 FrameStateBuilder newState = target.state.copy();
<a name="3" id="anc3"></a><span class="line-added">2962                 // Perform the same logic as is done in processBlock</span>
<span class="line-added">2963                 if (targetBlock != blockMap.getUnwindBlock() &amp;&amp; !(targetBlock instanceof ExceptionDispatchBlock)) {</span>
<span class="line-added">2964                     newState.setRethrowException(false);</span>
<span class="line-added">2965                 }</span>
2966                 for (BciBlock loop : exitLoops) {
2967                     LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(loop);
2968                     LoopExitNode loopExit = graph.add(new LoopExitNode(loopBegin));
2969                     if (lastLoopExit != null) {
2970                         lastLoopExit.setNext(loopExit);
2971                     }
2972                     if (firstLoopExit == null) {
2973                         firstLoopExit = loopExit;
2974                     }
2975                     lastLoopExit = loopExit;
2976                     debug.log(&quot;Target %s Exits %s, scanning framestates...&quot;, targetBlock, loop);
2977                     newState.clearNonLiveLocals(targetBlock, liveness, true);
2978                     newState.insertLoopProxies(loopExit, getEntryState(loop));
2979                     loopExit.setStateAfter(newState.create(bci, loopExit));
2980                 }
2981 
2982                 // Fortify: Suppress Null Dereference false positive
2983                 assert lastLoopExit != null;
2984 
2985                 if (target.originalEntry == null) {
2986                     lastLoopExit.setNext(target.entry);
2987                     return new Target(firstLoopExit, newState, target.entry);
2988                 } else {
2989                     target.originalEntry.replaceAtPredecessor(firstLoopExit);
2990                     lastLoopExit.setNext(target.originalEntry);
2991                     return new Target(target.entry, newState, target.originalEntry);
2992                 }
2993             }
2994         }
2995         return target;
2996     }
2997 
2998     private Target checkUnwind(FixedNode target, BciBlock targetBlock, FrameStateBuilder state) {
2999         if (targetBlock != blockMap.getUnwindBlock()) {
3000             return new Target(target, state);
3001         }
3002         FrameStateBuilder newState = state;
3003         newState = newState.copy();
3004         newState.setRethrowException(false);
3005         if (!method.isSynchronized()) {
3006             return new Target(target, newState);
3007         }
3008         FixedWithNextNode originalLast = lastInstr;
3009         FrameStateBuilder originalState = frameState;
3010         BeginNode holder = new BeginNode();
3011         lastInstr = graph.add(holder);
3012         frameState = newState;
3013         assert frameState.stackSize() == 1;
3014         ValueNode exception = frameState.peekObject();
3015         synchronizedEpilogue(BytecodeFrame.AFTER_EXCEPTION_BCI, exception, JavaKind.Void);
3016         lastInstr.setNext(target);
3017 
3018         lastInstr = originalLast;
3019         frameState = originalState;
3020 
3021         FixedNode result = holder.next();
3022         holder.setNext(null);
3023         holder.safeDelete();
3024         return new Target(result, newState, target);
3025     }
3026 
3027     private FrameStateBuilder getEntryState(BciBlock block) {
3028         return entryStateArray[block.id];
3029     }
3030 
3031     private void setEntryState(BciBlock block, FrameStateBuilder entryState) {
3032         this.entryStateArray[block.id] = entryState;
3033     }
3034 
3035     private void setFirstInstruction(BciBlock block, FixedWithNextNode firstInstruction) {
3036         this.firstInstructionArray[block.id] = firstInstruction;
3037     }
3038 
3039     private FixedWithNextNode getFirstInstruction(BciBlock block) {
3040         return firstInstructionArray[block.id];
3041     }
3042 
3043     private FixedNode createTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
3044         assert probability &gt;= 0 &amp;&amp; probability &lt;= 1.01 : probability;
3045         if (isNeverExecutedCode(probability)) {
3046             return graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3047         } else {
3048             assert block != null;
3049             return createTarget(block, stateAfter);
3050         }
3051     }
3052 
3053     private FixedNode createTarget(BciBlock block, FrameStateBuilder state) {
3054         return createTarget(block, state, false, false);
3055     }
3056 
3057     @SuppressWarnings(&quot;try&quot;)
3058     private FixedNode createTarget(BciBlock block, FrameStateBuilder state, boolean canReuseInstruction, boolean canReuseState) {
3059         assert block != null &amp;&amp; state != null;
3060         assert !block.isExceptionEntry() || state.stackSize() == 1;
3061 
3062         try (DebugCloseable context = openNodeContext(state, block.startBci)) {
3063             if (getFirstInstruction(block) == null) {
3064                 /*
3065                  * This is the first time we see this block as a branch target. Create and return a
3066                  * placeholder that later can be replaced with a MergeNode when we see this block
3067                  * again.
3068                  */
3069                 if (canReuseInstruction &amp;&amp; (block.getPredecessorCount() == 1 || !controlFlowSplit) &amp;&amp; !block.isLoopHeader() &amp;&amp; (currentBlock.loops &amp; ~block.loops) == 0 &amp;&amp;
3070                                 currentBlock.getJsrScope() == block.getJsrScope()) {
3071                     /*
3072                      * If we know that no BeginNode is necessary, then we can avoid allocating and
3073                      * later removing that node. This is strictly a performance optimization:
3074                      * unnecessary BeginNode are allowed and will be removed later on. We need to be
3075                      * careful though because the predecessor information is not always enough: when
3076                      * the loop level changes, we always need a BeginNode. Also, JSR scope changes
3077                      * required a BeginNode because the predecessors coming from RET bytecodes are
3078                      * not reflected in the predecessor count.
3079                      */
3080                     setFirstInstruction(block, lastInstr);
3081                     lastInstr = null;
3082                 } else {
3083                     setFirstInstruction(block, graph.add(new BeginNode()));
3084                 }
3085                 Target target = checkUnwind(getFirstInstruction(block), block, state);
3086                 target = checkLoopExit(target, block);
3087                 FixedNode result = target.entry;
3088                 FrameStateBuilder currentEntryState = target.state == state ? (canReuseState ? state : state.copy()) : target.state;
3089                 setEntryState(block, currentEntryState);
3090                 currentEntryState.clearNonLiveLocals(block, liveness, true);
3091 
3092                 debug.log(&quot;createTarget %s: first visit, result: %s&quot;, block, result);
3093                 return result;
3094             }
3095 
3096             if (getFirstInstruction(block) instanceof LoopBeginNode) {
3097                 assert (block.isLoopHeader() &amp;&amp; currentBlock.getId() &gt;= block.getId()) : &quot;must be backward branch&quot;;
3098                 /*
3099                  * Backward loop edge. We need to create a special LoopEndNode and merge with the
3100                  * loop begin node created before.
3101                  */
3102                 LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(block);
3103                 LoopEndNode loopEnd = graph.add(new LoopEndNode(loopBegin));
3104                 Target target = checkLoopExit(new Target(loopEnd, state), block);
3105                 FixedNode result = target.entry;
3106                 getEntryState(block).merge(loopBegin, target.state);
3107 
3108                 debug.log(&quot;createTarget %s: merging backward branch to loop header %s, result: %s&quot;, block, loopBegin, result);
3109                 return result;
3110             }
3111             assert currentBlock == null || currentBlock.getId() &lt; block.getId() : &quot;must not be backward branch&quot;;
3112             assert getFirstInstruction(block).next() == null : &quot;bytecodes already parsed for block&quot;;
3113 
3114             if (getFirstInstruction(block) instanceof AbstractBeginNode &amp;&amp; !(getFirstInstruction(block) instanceof AbstractMergeNode)) {
3115                 /*
3116                  * This is the second time we see this block. Create the actual MergeNode and the
3117                  * End Node for the already existing edge.
3118                  */
3119                 AbstractBeginNode beginNode = (AbstractBeginNode) getFirstInstruction(block);
3120 
3121                 // The EndNode for the already existing edge.
3122                 EndNode end = graph.add(new EndNode());
3123                 // The MergeNode that replaces the placeholder.
3124                 AbstractMergeNode mergeNode = graph.add(new MergeNode());
3125                 FixedNode next = beginNode.next();
3126 
3127                 if (beginNode.predecessor() instanceof ControlSplitNode) {
3128                     beginNode.setNext(end);
3129                 } else {
3130                     beginNode.replaceAtPredecessor(end);
3131                     beginNode.safeDelete();
3132                 }
3133 
3134                 mergeNode.addForwardEnd(end);
3135                 mergeNode.setNext(next);
3136 
3137                 setFirstInstruction(block, mergeNode);
3138             }
3139 
3140             AbstractMergeNode mergeNode = (AbstractMergeNode) getFirstInstruction(block);
3141 
3142             // The EndNode for the newly merged edge.
3143             EndNode newEnd = graph.add(new EndNode());
3144             Target target = checkLoopExit(checkUnwind(newEnd, block, state), block);
3145             FixedNode result = target.entry;
3146             getEntryState(block).merge(mergeNode, target.state);
3147             mergeNode.addForwardEnd(newEnd);
3148 
3149             debug.log(&quot;createTarget %s: merging state, result: %s&quot;, block, result);
3150             return result;
3151         }
3152     }
3153 
3154     /**
3155      * Returns a block begin node with the specified state. If the specified probability is 0, the
3156      * block deoptimizes immediately.
3157      */
3158     private AbstractBeginNode createBlockTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
3159         FixedNode target = createTarget(probability, block, stateAfter);
3160         AbstractBeginNode begin = BeginNode.begin(target);
3161 
3162         assert !(target instanceof DeoptimizeNode &amp;&amp; begin instanceof BeginStateSplitNode &amp;&amp;
3163                         ((BeginStateSplitNode) begin).stateAfter() != null) : &quot;We are not allowed to set the stateAfter of the begin node,&quot; +
3164                                         &quot; because we have to deoptimize to a bci _before_ the actual if, so that the interpreter can update the profiling information.&quot;;
3165         return begin;
3166     }
3167 
3168     private ValueNode synchronizedObject(FrameStateBuilder state, ResolvedJavaMethod target) {
3169         if (target.isStatic()) {
3170             return appendConstant(getConstantReflection().asJavaClass(target.getDeclaringClass()));
3171         } else {
3172             return state.loadLocal(0, JavaKind.Object);
3173         }
3174     }
3175 
3176     @SuppressWarnings(&quot;try&quot;)
3177     protected void processBlock(BciBlock block) {
3178         // Ignore blocks that have no predecessors by the time their bytecodes are parsed
3179         FixedWithNextNode firstInstruction = getFirstInstruction(block);
3180         if (firstInstruction == null) {
3181             debug.log(&quot;Ignoring block %s&quot;, block);
3182             return;
3183         }
3184         try (Indent indent = debug.logAndIndent(&quot;Parsing block %s  firstInstruction: %s  loopHeader: %b&quot;, block, firstInstruction, block.isLoopHeader())) {
3185 
3186             lastInstr = firstInstruction;
3187             frameState = getEntryState(block);
3188             setCurrentFrameState(frameState);
3189             currentBlock = block;
3190 
3191             if (block != blockMap.getUnwindBlock() &amp;&amp; !(block instanceof ExceptionDispatchBlock)) {
3192                 frameState.setRethrowException(false);
3193             }
3194 
3195             if (firstInstruction instanceof AbstractMergeNode) {
3196                 setMergeStateAfter(block, firstInstruction);
3197             }
3198 
3199             if (block == blockMap.getUnwindBlock()) {
3200                 handleUnwindBlock((ExceptionDispatchBlock) block);
3201             } else if (block instanceof ExceptionDispatchBlock) {
3202                 createExceptionDispatch((ExceptionDispatchBlock) block);
3203             } else {
3204                 iterateBytecodesForBlock(block);
3205             }
3206         }
3207     }
3208 
3209     private void handleUnwindBlock(ExceptionDispatchBlock block) {
3210         if (frameState.lockDepth(false) != 0) {
3211             throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);
3212         }
3213         assert !frameState.rethrowException();
3214         finishPrepare(lastInstr, block.deoptBci, frameState);
3215         if (parent == null) {
3216             createUnwind();
3217         } else {
3218             this.unwindValue = frameState.pop(JavaKind.Object);
3219             this.beforeUnwindNode = this.lastInstr;
3220         }
3221     }
3222 
3223     private void setMergeStateAfter(BciBlock block, FixedWithNextNode firstInstruction) {
3224         AbstractMergeNode abstractMergeNode = (AbstractMergeNode) firstInstruction;
3225         if (abstractMergeNode.stateAfter() == null) {
3226             int bci = block.startBci;
3227             if (block instanceof ExceptionDispatchBlock) {
3228                 bci = ((ExceptionDispatchBlock) block).deoptBci;
3229             }
3230             abstractMergeNode.setStateAfter(createFrameState(bci, abstractMergeNode));
3231         }
3232     }
3233 
3234     @SuppressWarnings(&quot;try&quot;)
3235     private void createUnwind() {
3236         assert frameState.stackSize() == 1 : frameState;
3237         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.UNWIND_BCI)) {
3238             ValueNode exception = frameState.pop(JavaKind.Object);
3239             append(new UnwindNode(exception));
3240         }
3241     }
3242 
3243     @SuppressWarnings(&quot;try&quot;)
3244     private void synchronizedEpilogue(int bci, ValueNode currentReturnValue, JavaKind currentReturnValueKind) {
3245         try (DebugCloseable context = openNodeContext(frameState, bci)) {
3246             if (method.isSynchronized()) {
3247                 if (currentReturnValueKind != JavaKind.Void) {
3248                     // we are making a state that should look like the state after the return:
3249                     // push the return value on the stack
3250                     frameState.push(currentReturnValueKind, currentReturnValue);
3251                 }
3252                 genMonitorExit(methodSynchronizedObject, currentReturnValue, bci);
3253                 assert !frameState.rethrowException();
3254             }
3255             if (frameState.lockDepth(false) != 0) {
3256                 throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);
3257             }
3258         }
3259     }
3260 
3261     @SuppressWarnings(&quot;try&quot;)
3262     private void createExceptionDispatch(ExceptionDispatchBlock block) {
3263         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.AFTER_EXCEPTION_BCI)) {
3264             lastInstr = finishInstruction(lastInstr, frameState);
3265 
3266             assert frameState.stackSize() == 1 : frameState;
3267             if (block.handler.isCatchAll()) {
3268                 assert block.getSuccessorCount() == 1;
3269                 appendGoto(block.getSuccessor(0));
3270                 return;
3271             }
3272 
3273             JavaType catchType = block.handler.getCatchType();
3274             if (graphBuilderConfig.eagerResolving()) {
3275                 catchType = lookupType(block.handler.catchTypeCPI(), INSTANCEOF);
3276             }
3277             if (typeIsResolved(catchType)) {
3278                 TypeReference checkedCatchType = TypeReference.createTrusted(graph.getAssumptions(), (ResolvedJavaType) catchType);
3279 
3280                 if (graphBuilderConfig.getSkippedExceptionTypes() != null) {
3281                     for (ResolvedJavaType skippedType : graphBuilderConfig.getSkippedExceptionTypes()) {
3282                         if (skippedType.isAssignableFrom(checkedCatchType.getType())) {
3283                             BciBlock nextBlock = block.getSuccessorCount() == 1 ? blockMap.getUnwindBlock() : block.getSuccessor(1);
3284                             ValueNode exception = frameState.stack[0];
3285                             FixedNode trueSuccessor = graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3286                             FixedNode nextDispatch = createTarget(nextBlock, frameState);
3287                             append(new IfNode(graph.addOrUniqueWithInputs(createInstanceOf(checkedCatchType, exception)), trueSuccessor, nextDispatch, 0));
3288                             return;
3289                         }
3290                     }
3291                 }
3292 
3293                 BciBlock nextBlock = block.getSuccessorCount() == 1 ? blockMap.getUnwindBlock() : block.getSuccessor(1);
3294                 ValueNode exception = frameState.stack[0];
3295                 /*
3296                  * Anchor for the piNode, which must be before any LoopExit inserted by
3297                  * createTarget.
3298                  */
3299                 BeginNode piNodeAnchor = graph.add(new BeginNode());
3300                 ObjectStamp checkedStamp = StampFactory.objectNonNull(checkedCatchType);
3301                 PiNode piNode = graph.addWithoutUnique(new PiNode(exception, checkedStamp));
3302                 frameState.pop(JavaKind.Object);
3303                 frameState.push(JavaKind.Object, piNode);
3304                 FixedNode catchSuccessor = createTarget(block.getSuccessor(0), frameState);
3305                 frameState.pop(JavaKind.Object);
3306                 frameState.push(JavaKind.Object, exception);
3307                 FixedNode nextDispatch = createTarget(nextBlock, frameState);
3308                 piNodeAnchor.setNext(catchSuccessor);
3309                 IfNode ifNode = append(new IfNode(graph.unique(createInstanceOf(checkedCatchType, exception)), piNodeAnchor, nextDispatch, 0.5));
3310                 assert ifNode.trueSuccessor() == piNodeAnchor;
3311                 piNode.setGuard(ifNode.trueSuccessor());
3312             } else {
3313                 handleUnresolvedExceptionType(catchType);
3314             }
3315         }
3316     }
3317 
3318     private void appendGoto(BciBlock successor) {
3319         FixedNode targetInstr = createTarget(successor, frameState, true, true);
3320         if (lastInstr != null &amp;&amp; lastInstr != targetInstr) {
3321             lastInstr.setNext(targetInstr);
3322         }
3323     }
3324 
3325     @SuppressWarnings(&quot;try&quot;)
3326     protected void iterateBytecodesForBlock(BciBlock block) {
3327         if (block.isLoopHeader()) {
3328             // Create the loop header block, which later will merge the backward branches of
3329             // the loop.
3330             controlFlowSplit = true;
3331             LoopBeginNode loopBegin = appendLoopBegin(this.lastInstr, block.startBci);
3332             lastInstr = loopBegin;
3333 
3334             // Create phi functions for all local variables and operand stack slots.
3335             frameState.insertLoopPhis(liveness, block.loopId, loopBegin, forceLoopPhis() || this.graphBuilderConfig.replaceLocalsWithConstants(), stampFromValueForForcedPhis());
3336             loopBegin.setStateAfter(createFrameState(block.startBci, loopBegin));
3337 
3338             /*
3339              * We have seen all forward branches. All subsequent backward branches will merge to the
3340              * loop header. This ensures that the loop header has exactly one non-loop predecessor.
3341              */
3342             setFirstInstruction(block, loopBegin);
3343             /*
3344              * We need to preserve the frame state builder of the loop header so that we can merge
3345              * values for phi functions, so make a copy of it.
3346              */
3347             setEntryState(block, frameState.copy());
3348 
3349             debug.log(&quot;  created loop header %s&quot;, loopBegin);
3350         } else if (lastInstr instanceof MergeNode) {
3351             /*
3352              * All inputs of non-loop phi nodes are known by now. We can infer the stamp for the
3353              * phi, so that parsing continues with more precise type information.
3354              */
3355             frameState.inferPhiStamps((AbstractMergeNode) lastInstr);
3356         }
3357         assert lastInstr.next() == null : &quot;instructions already appended at block &quot; + block;
3358         debug.log(&quot;  frameState: %s&quot;, frameState);
3359 
3360         lastInstr = finishInstruction(lastInstr, frameState);
3361 
3362         int endBCI = stream.endBCI();
3363 
3364         stream.setBCI(block.startBci);
3365         int bci = block.startBci;
3366         BytecodesParsed.add(debug, block.endBci - bci);
3367 
3368         /* Reset line number for new block */
3369         if (graphBuilderConfig.insertFullInfopoints()) {
3370             previousLineNumber = -1;
3371         }
3372 
3373         while (bci &lt; endBCI) {
3374             try (DebugCloseable context = openNodeContext()) {
3375                 if (graphBuilderConfig.insertFullInfopoints() &amp;&amp; !parsingIntrinsic()) {
3376                     currentLineNumber = lnt != null ? lnt.getLineNumber(bci) : -1;
3377                     if (currentLineNumber != previousLineNumber) {
3378                         genInfoPointNode(InfopointReason.BYTECODE_POSITION, null);
3379                         previousLineNumber = currentLineNumber;
3380                     }
3381                 }
3382 
3383                 // read the opcode
3384                 int opcode = stream.currentBC();
3385                 if (traceLevel != 0) {
3386                     traceInstruction(bci, opcode, bci == block.startBci);
3387                 }
3388                 if (parent == null &amp;&amp; bci == entryBCI) {
3389                     if (block.getJsrScope() != JsrScope.EMPTY_SCOPE) {
3390                         throw new JsrNotSupportedBailout(&quot;OSR into a JSR scope is not supported&quot;);
3391                     }
3392                     EntryMarkerNode x = append(new EntryMarkerNode());
3393                     frameState.insertProxies(value -&gt; graph.unique(new EntryProxyNode(value, x)));
3394                     x.setStateAfter(createFrameState(bci, x));
3395                 }
3396 
3397                 processBytecode(bci, opcode);
3398             } catch (BailoutException e) {
3399                 // Don&#39;t wrap bailouts as parser errors
3400                 throw e;
3401             } catch (Throwable e) {
3402                 throw throwParserError(e);
3403             }
3404 
3405             if (lastInstr == null || lastInstr.next() != null) {
3406                 break;
3407             }
3408 
3409             stream.next();
3410             bci = stream.currentBCI();
3411 
3412             assert block == currentBlock;
3413             assert checkLastInstruction();
3414             lastInstr = finishInstruction(lastInstr, frameState);
3415             if (bci &lt; endBCI) {
3416                 if (bci &gt; block.endBci) {
3417                     assert !block.getSuccessor(0).isExceptionEntry();
3418                     assert block.numNormalSuccessors() == 1;
3419                     // we fell through to the next block, add a goto and break
3420                     appendGoto(block.getSuccessor(0));
3421                     break;
3422                 }
3423             }
3424         }
3425     }
3426 
3427     private DebugCloseable openNodeContext(FrameStateBuilder state, int startBci) {
3428         if (graph.trackNodeSourcePosition()) {
3429             return graph.withNodeSourcePosition(state.createBytecodePosition(startBci));
3430         }
3431         return null;
3432     }
3433 
3434     private DebugCloseable openNodeContext(ResolvedJavaMethod targetMethod) {
3435         return openNodeContext(targetMethod, -1);
3436     }
3437 
3438     private DebugCloseable openNodeContext(ResolvedJavaMethod targetMethod, int bci) {
3439         if (graph.trackNodeSourcePosition()) {
3440             return graph.withNodeSourcePosition(new NodeSourcePosition(createBytecodePosition(), targetMethod, bci));
3441         }
3442         return null;
3443     }
3444 
3445     private DebugCloseable openNodeContext() {
3446         return openNodeContext(frameState, bci());
3447     }
3448 
3449     /* Also a hook for subclasses. */
3450     protected boolean forceLoopPhis() {
3451         return graph.isOSR();
3452     }
3453 
3454     /* Hook for subclasses. */
3455     protected boolean stampFromValueForForcedPhis() {
3456         return false;
3457     }
3458 
3459     protected boolean checkLastInstruction() {
3460         if (lastInstr instanceof BeginNode) {
3461             // ignore
3462         } else if (lastInstr instanceof StateSplit) {
3463             StateSplit stateSplit = (StateSplit) lastInstr;
3464             if (stateSplit.hasSideEffect()) {
3465                 assert stateSplit.stateAfter() != null : &quot;side effect &quot; + lastInstr + &quot; requires a non-null stateAfter&quot;;
3466             }
3467         }
3468         return true;
3469     }
3470 
3471     /* Also a hook for subclasses. */
3472     protected boolean disableLoopSafepoint() {
3473         return parsingIntrinsic();
3474     }
3475 
3476     @SuppressWarnings(&quot;try&quot;)
3477     private LoopBeginNode appendLoopBegin(FixedWithNextNode fixedWithNext, int startBci) {
3478         try (DebugCloseable context = openNodeContext(frameState, startBci)) {
3479             EndNode preLoopEnd = graph.add(new EndNode());
3480             LoopBeginNode loopBegin = graph.add(new LoopBeginNode());
3481             if (disableLoopSafepoint()) {
3482                 loopBegin.disableSafepoint();
3483             }
3484             fixedWithNext.setNext(preLoopEnd);
3485             // Add the single non-loop predecessor of the loop header.
3486             loopBegin.addForwardEnd(preLoopEnd);
3487             return loopBegin;
3488         }
3489     }
3490 
3491     /**
3492      * Hook for subclasses to modify the last instruction or add other instructions.
3493      *
3494      * @param instr The last instruction (= fixed node) which was added.
3495      * @param state The current frame state.
3496      * @return Returns the (new) last instruction.
3497      */
3498     protected FixedWithNextNode finishInstruction(FixedWithNextNode instr, FrameStateBuilder state) {
3499         return instr;
3500     }
3501 
3502     private void genInfoPointNode(InfopointReason reason, ValueNode escapedReturnValue) {
3503         if (!parsingIntrinsic() &amp;&amp; graphBuilderConfig.insertFullInfopoints()) {
3504             append(new FullInfopointNode(reason, createFrameState(bci(), null), escapedReturnValue));
3505         }
3506     }
3507 
3508     protected void genIf(ValueNode x, Condition cond, ValueNode y) {
3509         assert x.getStackKind() == y.getStackKind();
3510         assert currentBlock.getSuccessorCount() == 2;
3511         BciBlock trueBlock = currentBlock.getSuccessor(0);
3512         BciBlock falseBlock = currentBlock.getSuccessor(1);
3513 
3514         if (trueBlock == falseBlock) {
3515             // The target block is the same independent of the condition.
3516             appendGoto(trueBlock);
3517             return;
3518         }
3519 
3520         ValueNode a = x;
3521         ValueNode b = y;
3522         BciBlock trueSuccessor = trueBlock;
3523         BciBlock falseSuccessor = falseBlock;
3524 
3525         CanonicalizedCondition canonicalizedCondition = cond.canonicalize();
3526 
3527         // Check whether the condition needs to mirror the operands.
3528         if (canonicalizedCondition.mustMirror()) {
3529             a = y;
3530             b = x;
3531         }
3532         if (canonicalizedCondition.mustNegate()) {
3533             trueSuccessor = falseBlock;
3534             falseSuccessor = trueBlock;
3535         }
3536 
3537         // Create the logic node for the condition.
3538         LogicNode condition = createLogicNode(canonicalizedCondition.getCanonicalCondition(), a, b);
3539 
3540         double probability = -1;
3541         if (condition instanceof IntegerEqualsNode) {
3542             probability = extractInjectedProbability((IntegerEqualsNode) condition);
3543             // the probability coming from here is about the actual condition
3544         }
3545 
3546         if (probability == -1) {
3547             probability = getProfileProbability(canonicalizedCondition.mustNegate());
3548         }
3549 
3550         genIf(condition, trueSuccessor, falseSuccessor, probability);
3551     }
3552 
3553     protected double getProfileProbability(boolean negate) {
3554         if (profilingInfo == null) {
3555             return 0.5;
3556         }
3557 
3558         assert assertAtIfBytecode();
3559         double probability = profilingInfo.getBranchTakenProbability(bci());
3560 
3561         if (probability &lt; 0) {
3562             assert probability == -1 : &quot;invalid probability&quot;;
3563             debug.log(&quot;missing probability in %s at bci %d&quot;, code, bci());
3564             return 0.5;
3565         }
3566 
3567         if (negate &amp;&amp; shouldComplementProbability()) {
3568             // the probability coming from profile is about the original condition
3569             probability = 1 - probability;
3570         }
3571         return clampProbability(probability);
3572     }
3573 
3574     private double extractInjectedProbability(IntegerEqualsNode condition) {
3575         // Propagate injected branch probability if any.
3576         IntegerEqualsNode equalsNode = condition;
3577         BranchProbabilityNode probabilityNode = null;
3578         ValueNode other = null;
3579         if (equalsNode.getX() instanceof BranchProbabilityNode) {
3580             probabilityNode = (BranchProbabilityNode) equalsNode.getX();
3581             other = equalsNode.getY();
3582         } else if (equalsNode.getY() instanceof BranchProbabilityNode) {
3583             probabilityNode = (BranchProbabilityNode) equalsNode.getY();
3584             other = equalsNode.getX();
3585         }
3586 
3587         if (probabilityNode != null &amp;&amp; probabilityNode.getProbability().isConstant() &amp;&amp; other != null &amp;&amp; other.isConstant()) {
3588             double probabilityValue = clampProbability(probabilityNode.getProbability().asJavaConstant().asDouble());
3589             return other.asJavaConstant().asInt() == 0 ? 1.0 - probabilityValue : probabilityValue;
3590         }
3591         return -1;
3592     }
3593 
3594     protected void genIf(LogicNode conditionInput, BciBlock trueBlockInput, BciBlock falseBlockInput, double probabilityInput) {
3595         BciBlock trueBlock = trueBlockInput;
3596         BciBlock falseBlock = falseBlockInput;
3597         LogicNode condition = conditionInput;
3598         double probability = probabilityInput;
3599         FrameState stateBefore = null;
3600         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
3601         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3602             stateBefore = createCurrentFrameState();
3603         }
3604 
3605         // Remove a logic negation node.
3606         if (condition instanceof LogicNegationNode) {
3607             LogicNegationNode logicNegationNode = (LogicNegationNode) condition;
3608             BciBlock tmpBlock = trueBlock;
3609             trueBlock = falseBlock;
3610             falseBlock = tmpBlock;
3611             if (shouldComplementProbability()) {
3612                 // the probability coming from profile is about the original condition
3613                 probability = 1 - probability;
3614             }
3615             condition = logicNegationNode.getValue();
3616         }
3617 
3618         if (condition instanceof LogicConstantNode) {
3619             genConstantTargetIf(trueBlock, falseBlock, condition);
3620         } else {
3621             if (condition.graph() == null) {
3622                 condition = genUnique(condition);
3623             }
3624 
3625             BciBlock deoptBlock = null;
3626             BciBlock noDeoptBlock = null;
3627             if (isNeverExecutedCode(probability)) {
3628                 deoptBlock = trueBlock;
3629                 noDeoptBlock = falseBlock;
3630             } else if (isNeverExecutedCode(1 - probability)) {
3631                 deoptBlock = falseBlock;
3632                 noDeoptBlock = trueBlock;
3633             }
3634 
3635             if (deoptBlock != null) {
3636                 NodeSourcePosition currentPosition = graph.currentNodeSourcePosition();
3637                 NodeSourcePosition survivingSuccessorPosition = null;
3638                 if (graph.trackNodeSourcePosition()) {
3639                     survivingSuccessorPosition = new NodeSourcePosition(currentPosition.getCaller(), currentPosition.getMethod(), noDeoptBlock.startBci);
3640                 }
3641                 boolean negated = deoptBlock == trueBlock;
3642                 if (!isPotentialCountedLoopExit(condition, deoptBlock)) {
3643                     if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3644                         profilingPlugin.profileGoto(this, method, bci(), noDeoptBlock.startBci, stateBefore);
3645                     }
3646                     append(new FixedGuardNode(condition, UnreachedCode, InvalidateReprofile, negated, survivingSuccessorPosition));
3647                     appendGoto(noDeoptBlock);
3648                 } else {
3649                     this.controlFlowSplit = true;
3650                     FixedNode noDeoptSuccessor = createTarget(noDeoptBlock, frameState, false, true);
3651                     DeoptimizeNode deopt = graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3652                     /*
3653                      * We do not want to `checkLoopExit` here: otherwise the deopt will go to the
3654                      * deoptBlock&#39;s BCI, skipping the branch in the interpreter, and the profile
3655                      * will never see that the branch is taken. This can lead to deopt loops or OSR
3656                      * failure.
3657                      */
3658                     double calculatedProbability = negated ? BranchProbabilityNode.DEOPT_PROBABILITY : 1.0 - BranchProbabilityNode.DEOPT_PROBABILITY;
3659                     FixedNode deoptSuccessor = BeginNode.begin(deopt);
3660                     ValueNode ifNode = genIfNode(condition, negated ? deoptSuccessor : noDeoptSuccessor, negated ? noDeoptSuccessor : deoptSuccessor, calculatedProbability);
3661                     postProcessIfNode(ifNode);
3662                     append(ifNode);
3663                 }
3664                 return;
3665             }
3666 
3667             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3668                 profilingPlugin.profileIf(this, method, bci(), condition, trueBlock.startBci, falseBlock.startBci, stateBefore);
3669             }
3670 
3671             int oldBci = stream.currentBCI();
3672             int trueBlockInt = checkPositiveIntConstantPushed(trueBlock);
3673             if (trueBlockInt != -1) {
3674                 int falseBlockInt = checkPositiveIntConstantPushed(falseBlock);
3675                 if (falseBlockInt != -1) {
3676                     if (tryGenConditionalForIf(trueBlock, falseBlock, condition, oldBci, trueBlockInt, falseBlockInt)) {
3677                         return;
3678                     }
3679                 }
3680             }
3681 
3682             this.controlFlowSplit = true;
3683             FixedNode falseSuccessor = createTarget(falseBlock, frameState, false, false);
3684             FixedNode trueSuccessor = createTarget(trueBlock, frameState, false, true);
3685 
3686             if (this.graphBuilderConfig.replaceLocalsWithConstants() &amp;&amp; condition instanceof CompareNode) {
3687                 CompareNode compareNode = (CompareNode) condition;
3688                 if (compareNode.condition() == CanonicalCondition.EQ) {
3689                     ValueNode constantNode = null;
3690                     ValueNode nonConstantNode = null;
3691                     if (compareNode.getX() instanceof ConstantNode) {
3692                         constantNode = compareNode.getX();
3693                         nonConstantNode = compareNode.getY();
3694                     } else if (compareNode.getY() instanceof ConstantNode) {
3695                         constantNode = compareNode.getY();
3696                         nonConstantNode = compareNode.getX();
3697                     }
3698 
3699                     if (constantNode != null &amp;&amp; nonConstantNode != null) {
3700                         this.getEntryState(trueBlock).replaceValue(nonConstantNode, constantNode);
3701                     }
3702                 }
3703             }
3704 
3705             ValueNode ifNode = genIfNode(condition, trueSuccessor, falseSuccessor, probability);
3706             postProcessIfNode(ifNode);
3707             append(ifNode);
3708         }
3709     }
3710 
3711     public boolean isPotentialCountedLoopExit(LogicNode condition, BciBlock target) {
3712         if (currentBlock != null) {
3713             long exits = currentBlock.loops &amp; ~target.loops;
3714             if (exits != 0) {
3715                 return condition instanceof CompareNode;
3716             }
3717         }
3718         return false;
3719     }
3720 
3721     /**
3722      * Hook for subclasses to decide whether the IfNode probability should be complemented during
3723      * conversion to Graal IR.
3724      */
3725     protected boolean shouldComplementProbability() {
3726         return true;
3727     }
3728 
3729     /**
3730      * Hook for subclasses to generate custom nodes before an IfNode.
3731      */
3732     @SuppressWarnings(&quot;unused&quot;)
3733     protected void postProcessIfNode(ValueNode node) {
3734     }
3735 
3736     private boolean tryGenConditionalForIf(BciBlock trueBlock, BciBlock falseBlock, LogicNode condition, int oldBci, int trueBlockInt, int falseBlockInt) {
3737         if (gotoOrFallThroughAfterConstant(trueBlock) &amp;&amp; gotoOrFallThroughAfterConstant(falseBlock) &amp;&amp; trueBlock.getSuccessor(0) == falseBlock.getSuccessor(0)) {
3738             genConditionalForIf(trueBlock, condition, oldBci, trueBlockInt, falseBlockInt, false);
3739             return true;
3740         } else if (this.parent != null &amp;&amp; returnAfterConstant(trueBlock) &amp;&amp; returnAfterConstant(falseBlock)) {
3741             genConditionalForIf(trueBlock, condition, oldBci, trueBlockInt, falseBlockInt, true);
3742             return true;
3743         }
3744         return false;
3745     }
3746 
3747     private void genConditionalForIf(BciBlock trueBlock, LogicNode condition, int oldBci, int trueBlockInt, int falseBlockInt, boolean genReturn) {
3748         ConstantNode trueValue = graph.unique(ConstantNode.forInt(trueBlockInt));
3749         ConstantNode falseValue = graph.unique(ConstantNode.forInt(falseBlockInt));
3750         ValueNode conditionalNode = ConditionalNode.create(condition, trueValue, falseValue, NodeView.DEFAULT);
3751         if (conditionalNode.graph() == null) {
3752             conditionalNode = graph.addOrUniqueWithInputs(conditionalNode);
3753         }
3754         if (genReturn) {
3755             JavaKind returnKind = method.getSignature().getReturnKind().getStackKind();
3756             this.genReturn(conditionalNode, returnKind);
3757         } else {
3758             frameState.push(JavaKind.Int, conditionalNode);
3759             appendGoto(trueBlock.getSuccessor(0));
3760             stream.setBCI(oldBci);
3761         }
3762     }
3763 
3764     private LogicNode createLogicNode(CanonicalCondition cond, ValueNode a, ValueNode b) {
3765         assert !a.getStackKind().isNumericFloat();
3766         switch (cond) {
3767             case EQ:
3768                 if (a.getStackKind() == JavaKind.Object) {
3769                     return genObjectEquals(a, b);
3770                 } else {
3771                     return genIntegerEquals(a, b);
3772                 }
3773             case LT:
3774                 assert a.getStackKind() != JavaKind.Object;
3775                 return genIntegerLessThan(a, b);
3776             default:
3777                 throw GraalError.shouldNotReachHere(&quot;Unexpected condition: &quot; + cond);
3778         }
3779     }
3780 
3781     private void genConstantTargetIf(BciBlock trueBlock, BciBlock falseBlock, LogicNode condition) {
3782         LogicConstantNode constantLogicNode = (LogicConstantNode) condition;
3783         boolean value = constantLogicNode.getValue();
3784         BciBlock nextBlock = falseBlock;
3785         if (value) {
3786             nextBlock = trueBlock;
3787         }
3788         int startBci = nextBlock.startBci;
3789         int targetAtStart = stream.readUByte(startBci);
3790         if (targetAtStart == Bytecodes.GOTO &amp;&amp; nextBlock.getPredecessorCount() == 1) {
3791             // This is an empty block. Skip it.
3792             BciBlock successorBlock = nextBlock.successors.get(0);
3793             ProfilingPlugin profilingPlugin = graphBuilderConfig.getPlugins().getProfilingPlugin();
3794             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3795                 FrameState stateBefore = createCurrentFrameState();
3796                 profilingPlugin.profileGoto(this, method, bci(), successorBlock.startBci, stateBefore);
3797             }
3798             appendGoto(successorBlock);
3799             assert nextBlock.numNormalSuccessors() == 1;
3800         } else {
3801             ProfilingPlugin profilingPlugin = graphBuilderConfig.getPlugins().getProfilingPlugin();
3802             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3803                 FrameState stateBefore = createCurrentFrameState();
3804                 profilingPlugin.profileGoto(this, method, bci(), nextBlock.startBci, stateBefore);
3805             }
3806             appendGoto(nextBlock);
3807         }
3808     }
3809 
3810     private int checkPositiveIntConstantPushed(BciBlock block) {
3811         stream.setBCI(block.startBci);
3812         int currentBC = stream.currentBC();
3813         if (currentBC &gt;= Bytecodes.ICONST_0 &amp;&amp; currentBC &lt;= Bytecodes.ICONST_5) {
3814             int constValue = currentBC - Bytecodes.ICONST_0;
3815             return constValue;
3816         }
3817         return -1;
3818     }
3819 
3820     private boolean gotoOrFallThroughAfterConstant(BciBlock block) {
3821         stream.setBCI(block.startBci);
3822         int currentBCI = stream.nextBCI();
3823         stream.setBCI(currentBCI);
3824         int currentBC = stream.currentBC();
3825         return stream.currentBCI() &gt; block.endBci || currentBC == Bytecodes.GOTO || currentBC == Bytecodes.GOTO_W;
3826     }
3827 
3828     private boolean returnAfterConstant(BciBlock block) {
3829         stream.setBCI(block.startBci);
3830         int currentBCI = stream.nextBCI();
3831         stream.setBCI(currentBCI);
3832         int currentBC = stream.currentBC();
3833         return currentBC == Bytecodes.IRETURN;
3834     }
3835 
3836     @Override
3837     public StampProvider getStampProvider() {
3838         return providers.getStampProvider();
3839     }
3840 
3841     @Override
3842     public MetaAccessProvider getMetaAccess() {
3843         return providers.getMetaAccess();
3844     }
3845 
3846     @Override
3847     public Replacements getReplacements() {
3848         return providers.getReplacements();
3849     }
3850 
3851     @Override
3852     public void push(JavaKind slotKind, ValueNode value) {
3853         assert value.isAlive();
3854         frameState.push(slotKind, value);
3855     }
3856 
3857     @Override
3858     public ValueNode pop(JavaKind slotKind) {
3859         return frameState.pop(slotKind);
3860     }
3861 
3862     @Override
3863     public ConstantReflectionProvider getConstantReflection() {
3864         return providers.getConstantReflection();
3865     }
3866 
3867     @Override
3868     public ConstantFieldProvider getConstantFieldProvider() {
3869         return providers.getConstantFieldProvider();
3870     }
3871 
3872     /**
3873      * Gets the graph being processed by this builder.
3874      */
3875     @Override
3876     public StructuredGraph getGraph() {
3877         return graph;
3878     }
3879 
3880     @Override
3881     public BytecodeParser getParent() {
3882         return parent;
3883     }
3884 
3885     @Override
3886     public IntrinsicContext getIntrinsic() {
3887         return intrinsicContext;
3888     }
3889 
3890     @Override
3891     public String toString() {
3892         Formatter fmt = new Formatter();
3893         BytecodeParser bp = this;
3894         String indent = &quot;&quot;;
3895         while (bp != null) {
3896             if (bp != this) {
3897                 fmt.format(&quot;%n%s&quot;, indent);
3898             }
3899             fmt.format(&quot;%s [bci: %d, intrinsic: %s]&quot;, bp.code.asStackTraceElement(bp.bci()), bp.bci(), bp.parsingIntrinsic());
3900             fmt.format(&quot;%n%s&quot;, new BytecodeDisassembler().disassemble(bp.code, bp.bci(), bp.bci() + 10));
3901             bp = bp.parent;
3902             indent += &quot; &quot;;
3903         }
3904         return fmt.toString();
3905     }
3906 
3907     @Override
3908     public BailoutException bailout(String string) {
3909         FrameState currentFrameState = createFrameState(bci(), null);
3910         StackTraceElement[] elements = GraphUtil.approxSourceStackTraceElement(currentFrameState);
3911         BailoutException bailout = new PermanentBailoutException(string);
3912         throw GraphUtil.createBailoutException(string, bailout, elements);
3913     }
3914 
3915     private FrameState createFrameState(int bci, StateSplit forStateSplit) {
3916         assert !(forStateSplit instanceof BytecodeExceptionNode);
3917         if (currentBlock != null &amp;&amp; bci &gt; currentBlock.endBci) {
3918             frameState.clearNonLiveLocals(currentBlock, liveness, false);
3919         }
3920         return frameState.create(bci, forStateSplit);
3921     }
3922 
3923     private FrameState createBytecodeExceptionFrameState(int bci, BytecodeExceptionNode bytecodeException) {
3924         FrameStateBuilder copy = frameState.copy();
3925         copy.clearStack();
3926         if (currentBlock != null) {
3927             copy.clearNonLiveLocals(currentBlock, liveness, false);
3928         }
3929         copy.setRethrowException(true);
3930         copy.push(JavaKind.Object, bytecodeException);
3931         return copy.create(bci, bytecodeException);
3932     }
3933 
3934     @Override
3935     public void setStateAfter(StateSplit sideEffect) {
3936         assert sideEffect.hasSideEffect() || sideEffect instanceof AbstractMergeNode;
3937         FrameState stateAfter = createFrameState(stream.nextBCI(), sideEffect);
3938         sideEffect.setStateAfter(stateAfter);
3939     }
3940 
3941     protected NodeSourcePosition createBytecodePosition() {
3942         NodeSourcePosition bytecodePosition = frameState.createBytecodePosition(bci());
3943         return bytecodePosition;
3944     }
3945 
3946     public void setCurrentFrameState(FrameStateBuilder frameState) {
3947         this.frameState = frameState;
3948     }
3949 
3950     protected final BytecodeStream getStream() {
3951         return stream;
3952     }
3953 
3954     @Override
3955     public int bci() {
3956         return stream.currentBCI();
3957     }
3958 
3959     public void loadLocal(int index, JavaKind kind) {
3960         ValueNode value = frameState.loadLocal(index, kind);
3961         frameState.push(kind, value);
3962     }
3963 
3964     @SuppressWarnings(&quot;try&quot;)
3965     public void loadLocalObject(int index) {
3966         ValueNode value = frameState.loadLocal(index, JavaKind.Object);
3967 
3968         int nextBCI = stream.nextBCI();
3969         int nextBC = stream.readUByte(nextBCI);
3970         if (nextBCI &lt;= currentBlock.endBci &amp;&amp; nextBC == Bytecodes.GETFIELD) {
3971             stream.next();
3972             try (DebugCloseable ignored = openNodeContext()) {
3973                 genGetField(stream.readCPI(), Bytecodes.GETFIELD, value);
3974             }
3975         } else {
3976             frameState.push(JavaKind.Object, value);
3977         }
3978     }
3979 
3980     public void storeLocal(JavaKind kind, int index) {
3981         ValueNode value = frameState.pop(kind);
3982         frameState.storeLocal(index, kind, value);
3983     }
3984 
3985     protected void genLoadConstant(int cpi, int opcode) {
3986         Object con = lookupConstant(cpi, opcode);
3987 
3988         if (con instanceof JavaType) {
3989             // this is a load of class constant which might be unresolved
3990             JavaType type = (JavaType) con;
3991             if (typeIsResolved(type)) {
3992                 frameState.push(JavaKind.Object, appendConstant(getConstantReflection().asJavaClass((ResolvedJavaType) type)));
3993             } else {
3994                 handleUnresolvedLoadConstant(type);
3995             }
3996         } else if (con instanceof JavaConstant) {
3997             JavaConstant constant = (JavaConstant) con;
3998             frameState.push(constant.getJavaKind(), appendConstant(constant));
3999         } else {
4000             throw new Error(&quot;lookupConstant returned an object of incorrect type&quot;);
4001         }
4002     }
4003 
4004     private JavaKind refineComponentType(ValueNode array, JavaKind kind) {
4005         if (kind == JavaKind.Byte) {
4006             JavaType type = array.stamp(NodeView.DEFAULT).javaType(getMetaAccess());
4007             if (type.isArray()) {
4008                 JavaType componentType = type.getComponentType();
4009                 if (componentType != null) {
4010                     JavaKind refinedKind = componentType.getJavaKind();
4011                     assert refinedKind == JavaKind.Byte || refinedKind == JavaKind.Boolean;
4012                     return refinedKind;
4013                 }
4014             }
4015         }
4016         return kind;
4017     }
4018 
4019     private void genLoadIndexed(JavaKind kind) {
4020         ValueNode index = frameState.pop(JavaKind.Int);
4021         ValueNode array = frameState.pop(JavaKind.Object);
4022 
4023         array = maybeEmitExplicitNullCheck(array);
4024         GuardingNode boundsCheck = maybeEmitExplicitBoundsCheck(array, index);
4025 
4026         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4027             if (plugin.handleLoadIndexed(this, array, index, boundsCheck, kind)) {
4028                 return;
4029             }
4030         }
4031 
4032         JavaKind actualKind = refineComponentType(array, kind);
4033         frameState.push(actualKind, append(genLoadIndexed(array, index, boundsCheck, actualKind)));
4034     }
4035 
4036     private void genStoreIndexed(JavaKind kind) {
4037         ValueNode value = frameState.pop(kind);
4038         ValueNode index = frameState.pop(JavaKind.Int);
4039         ValueNode array = frameState.pop(JavaKind.Object);
4040 
4041         array = maybeEmitExplicitNullCheck(array);
4042         GuardingNode boundsCheck = maybeEmitExplicitBoundsCheck(array, index);
4043         GuardingNode storeCheck = maybeEmitExplicitStoreCheck(array, kind, value);
4044 
4045         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4046             if (plugin.handleStoreIndexed(this, array, index, boundsCheck, storeCheck, kind, value)) {
4047                 return;
4048             }
4049         }
4050 
4051         JavaKind actualKind = refineComponentType(array, kind);
4052         genStoreIndexed(array, index, boundsCheck, storeCheck, actualKind, maskSubWordValue(value, actualKind));
4053     }
4054 
4055     private void genArithmeticOp(JavaKind kind, int opcode) {
4056         ValueNode y = frameState.pop(kind);
4057         ValueNode x = frameState.pop(kind);
4058         ValueNode v;
4059         switch (opcode) {
4060             case IADD:
4061             case LADD:
4062                 v = genIntegerAdd(x, y);
4063                 break;
4064             case FADD:
4065             case DADD:
4066                 v = genFloatAdd(x, y);
4067                 break;
4068             case ISUB:
4069             case LSUB:
4070                 v = genIntegerSub(x, y);
4071                 break;
4072             case FSUB:
4073             case DSUB:
4074                 v = genFloatSub(x, y);
4075                 break;
4076             case IMUL:
4077             case LMUL:
4078                 v = genIntegerMul(x, y);
4079                 break;
4080             case FMUL:
4081             case DMUL:
4082                 v = genFloatMul(x, y);
4083                 break;
4084             case FDIV:
4085             case DDIV:
4086                 v = genFloatDiv(x, y);
4087                 break;
4088             case FREM:
4089             case DREM:
4090                 v = genFloatRem(x, y);
4091                 break;
4092             default:
4093                 throw shouldNotReachHere();
4094         }
4095         frameState.push(kind, append(v));
4096     }
4097 
4098     private void genIntegerDivOp(JavaKind kind, int opcode) {
4099         ValueNode y = frameState.pop(kind);
4100         ValueNode x = frameState.pop(kind);
4101 
4102         GuardingNode zeroCheck = maybeEmitExplicitDivisionByZeroCheck(y);
4103 
4104         ValueNode v;
4105         switch (opcode) {
4106             case IDIV:
4107             case LDIV:
4108                 v = genIntegerDiv(x, y, zeroCheck);
4109                 break;
4110             case IREM:
4111             case LREM:
4112                 v = genIntegerRem(x, y, zeroCheck);
4113                 break;
4114             default:
4115                 throw shouldNotReachHere();
4116         }
4117         frameState.push(kind, append(v));
4118     }
4119 
4120     private void genNegateOp(JavaKind kind) {
4121         ValueNode x = frameState.pop(kind);
4122         frameState.push(kind, append(genNegateOp(x)));
4123     }
4124 
4125     private void genShiftOp(JavaKind kind, int opcode) {
4126         ValueNode s = frameState.pop(JavaKind.Int);
4127         ValueNode x = frameState.pop(kind);
4128         ValueNode v;
4129         switch (opcode) {
4130             case ISHL:
4131             case LSHL:
4132                 v = genLeftShift(x, s);
4133                 break;
4134             case ISHR:
4135             case LSHR:
4136                 v = genRightShift(x, s);
4137                 break;
4138             case IUSHR:
4139             case LUSHR:
4140                 v = genUnsignedRightShift(x, s);
4141                 break;
4142             default:
4143                 throw shouldNotReachHere();
4144         }
4145         frameState.push(kind, append(v));
4146     }
4147 
4148     private void genLogicOp(JavaKind kind, int opcode) {
4149         ValueNode y = frameState.pop(kind);
4150         ValueNode x = frameState.pop(kind);
4151         ValueNode v;
4152         switch (opcode) {
4153             case IAND:
4154             case LAND:
4155                 v = genAnd(x, y);
4156                 break;
4157             case IOR:
4158             case LOR:
4159                 v = genOr(x, y);
4160                 break;
4161             case IXOR:
4162             case LXOR:
4163                 v = genXor(x, y);
4164                 break;
4165             default:
4166                 throw shouldNotReachHere();
4167         }
4168         frameState.push(kind, append(v));
4169     }
4170 
4171     private void genFloatCompareOp(JavaKind kind, boolean isUnorderedLess) {
4172         ValueNode y = frameState.pop(kind);
4173         ValueNode x = frameState.pop(kind);
4174         frameState.push(JavaKind.Int, append(genNormalizeCompare(x, y, isUnorderedLess)));
4175     }
4176 
4177     private void genIntegerCompareOp(JavaKind kind) {
4178         ValueNode y = frameState.pop(kind);
4179         ValueNode x = frameState.pop(kind);
4180         frameState.push(JavaKind.Int, append(genIntegerNormalizeCompare(x, y)));
4181     }
4182 
4183     private void genFloatConvert(FloatConvert op, JavaKind from, JavaKind to) {
4184         ValueNode input = frameState.pop(from);
4185         frameState.push(to, append(genFloatConvert(op, input)));
4186     }
4187 
4188     private void genSignExtend(JavaKind from, JavaKind to) {
4189         ValueNode input = frameState.pop(from);
4190         if (from != from.getStackKind()) {
4191             input = append(genNarrow(input, from.getBitCount()));
4192         }
4193         frameState.push(to, append(genSignExtend(input, to.getBitCount())));
4194     }
4195 
4196     private void genZeroExtend(JavaKind from, JavaKind to) {
4197         ValueNode input = frameState.pop(from);
4198         if (from != from.getStackKind()) {
4199             input = append(genNarrow(input, from.getBitCount()));
4200         }
4201         frameState.push(to, append(genZeroExtend(input, to.getBitCount())));
4202     }
4203 
4204     private void genNarrow(JavaKind from, JavaKind to) {
4205         ValueNode input = frameState.pop(from);
4206         frameState.push(to, append(genNarrow(input, to.getBitCount())));
4207     }
4208 
4209     private void genIncrement() {
4210         int index = getStream().readLocalIndex();
4211         int delta = getStream().readIncrement();
4212         ValueNode x = frameState.loadLocal(index, JavaKind.Int);
4213         ValueNode y = appendConstant(JavaConstant.forInt(delta));
4214         frameState.storeLocal(index, JavaKind.Int, append(genIntegerAdd(x, y)));
4215     }
4216 
4217     private void genIfZero(Condition cond) {
4218         ValueNode y = appendConstant(JavaConstant.INT_0);
4219         ValueNode x = frameState.pop(JavaKind.Int);
4220         genIf(x, cond, y);
4221     }
4222 
4223     private void genIfNull(Condition cond) {
4224         ValueNode y = appendConstant(JavaConstant.NULL_POINTER);
4225         ValueNode x = frameState.pop(JavaKind.Object);
4226         genIf(x, cond, y);
4227     }
4228 
4229     private void genIfSame(JavaKind kind, Condition cond) {
4230         ValueNode y = frameState.pop(kind);
4231         ValueNode x = frameState.pop(kind);
4232         genIf(x, cond, y);
4233     }
4234 
4235     private static void initialize(ResolvedJavaType resolvedType) {
4236         /*
4237          * Since we&#39;re potentially triggering class initialization here, we need synchronization to
4238          * mitigate the potential for class initialization related deadlock being caused by the
4239          * compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
4240          */
4241         synchronized (BytecodeParser.class) {
4242             resolvedType.initialize();
4243         }
4244     }
4245 
4246     protected JavaType lookupType(int cpi, int bytecode) {
4247         maybeEagerlyResolve(cpi, bytecode);
4248         JavaType result = constantPool.lookupType(cpi, bytecode);
4249         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaType;
4250         return result;
4251     }
4252 
4253     private String unresolvedMethodAssertionMessage(JavaMethod result) {
4254         String message = result.format(&quot;%H.%n(%P)%R&quot;);
4255         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
4256             JavaType declaringClass = result.getDeclaringClass();
4257             String className = declaringClass.getName();
4258             switch (className) {
4259                 case &quot;Ljava/nio/ByteBuffer;&quot;:
4260                 case &quot;Ljava/nio/ShortBuffer;&quot;:
4261                 case &quot;Ljava/nio/CharBuffer;&quot;:
4262                 case &quot;Ljava/nio/IntBuffer;&quot;:
4263                 case &quot;Ljava/nio/LongBuffer;&quot;:
4264                 case &quot;Ljava/nio/FloatBuffer;&quot;:
4265                 case &quot;Ljava/nio/DoubleBuffer;&quot;:
4266                 case &quot;Ljava/nio/MappedByteBuffer;&quot;: {
4267                     switch (result.getName()) {
4268                         case &quot;position&quot;:
4269                         case &quot;limit&quot;:
4270                         case &quot;mark&quot;:
4271                         case &quot;reset&quot;:
4272                         case &quot;clear&quot;:
4273                         case &quot;flip&quot;:
4274                         case &quot;rewind&quot;: {
4275                             String returnType = result.getSignature().getReturnType(null).toJavaName();
4276                             if (returnType.equals(declaringClass.toJavaName())) {
4277                                 message += String.format(&quot; [Probably cause: %s was compiled with javac from JDK 9+ using &quot; +
4278                                                 &quot;`-target 8` and `-source 8` options. See https://bugs.openjdk.java.net/browse/JDK-4774077 for details.]&quot;, method.getDeclaringClass().toClassName());
4279                             }
4280                         }
4281                     }
4282                     break;
4283                 }
4284             }
4285         }
4286         return message;
4287     }
4288 
4289     private JavaMethod lookupMethod(int cpi, int opcode) {
4290         maybeEagerlyResolve(cpi, opcode);
4291         JavaMethod result = lookupMethodInPool(cpi, opcode);
4292         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaMethod : unresolvedMethodAssertionMessage(result);
4293         return result;
4294     }
4295 
4296     protected JavaMethod lookupMethodInPool(int cpi, int opcode) {
4297         return constantPool.lookupMethod(cpi, opcode);
4298     }
4299 
4300     protected JavaField lookupField(int cpi, int opcode) {
4301         maybeEagerlyResolve(cpi, opcode);
4302         JavaField result = constantPool.lookupField(cpi, method, opcode);
4303         return lookupField(result);
4304     }
4305 
4306     protected JavaField lookupField(JavaField result) {
4307         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaField : &quot;Not resolved: &quot; + result;
4308         if (parsingIntrinsic() || eagerInitializing) {
4309             if (result instanceof ResolvedJavaField) {
4310                 ResolvedJavaType declaringClass = ((ResolvedJavaField) result).getDeclaringClass();
4311                 if (!declaringClass.isInitialized()) {
4312                     // Even with eager initialization, superinterfaces are not always initialized.
4313                     // See StaticInterfaceFieldTest
4314                     assert !eagerInitializing || declaringClass.isInterface() : &quot;Declaring class not initialized but not an interface? &quot; + declaringClass;
4315                     initialize(declaringClass);
4316                 }
4317             }
4318         }
4319         assert !uninitializedIsError || (result instanceof ResolvedJavaField &amp;&amp; ((ResolvedJavaField) result).getDeclaringClass().isInitialized()) : result;
4320         return result;
4321     }
4322 
4323     private Object lookupConstant(int cpi, int opcode) {
4324         maybeEagerlyResolve(cpi, opcode);
4325         Object result = constantPool.lookupConstant(cpi);
4326         assert !graphBuilderConfig.unresolvedIsError() || !(result instanceof JavaType) || (result instanceof ResolvedJavaType) : result;
4327         return result;
4328     }
4329 
4330     protected void maybeEagerlyResolve(int cpi, int bytecode) {
4331         if (intrinsicContext != null) {
4332             constantPool.loadReferencedType(cpi, bytecode);
4333         } else if (graphBuilderConfig.eagerResolving()) {
4334             /*
4335              * Since we&#39;re potentially triggering class initialization here, we need synchronization
4336              * to mitigate the potential for class initialization related deadlock being caused by
4337              * the compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
4338              */
4339             synchronized (BytecodeParser.class) {
4340                 ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4341                 if (classInitializationPlugin != null) {
4342                     classInitializationPlugin.loadReferencedType(this, constantPool, cpi, bytecode);
4343                 } else {
4344                     constantPool.loadReferencedType(cpi, bytecode);
4345                 }
4346             }
4347         }
4348     }
4349 
4350     protected JavaType maybeEagerlyResolve(JavaType type, ResolvedJavaType accessingClass) {
4351         if (graphBuilderConfig.eagerResolving() || parsingIntrinsic()) {
4352             return type.resolve(accessingClass);
4353         }
4354         return type;
4355     }
4356 
4357     protected void maybeEagerlyInitialize(ResolvedJavaType resolvedType) {
4358         if (!resolvedType.isInitialized() &amp;&amp; eagerInitializing) {
4359             initialize(resolvedType);
4360         }
4361     }
4362 
4363     private JavaTypeProfile getProfileForTypeCheck(TypeReference type) {
4364         if (parsingIntrinsic() || profilingInfo == null || !optimisticOpts.useTypeCheckHints(getOptions()) || type.isExact()) {
4365             return null;
4366         } else {
4367             return profilingInfo.getTypeProfile(bci());
4368         }
4369     }
4370 
4371     private void genCheckCast(int cpi) {
4372         JavaType type = lookupType(cpi, CHECKCAST);
4373         ValueNode object = frameState.pop(JavaKind.Object);
4374         genCheckCast(type, object);
4375     }
4376 
4377     protected void genCheckCast(JavaType type, ValueNode object) {
4378         if (typeIsResolved(type)) {
4379             genCheckCast((ResolvedJavaType) type, object);
4380         } else {
4381             handleUnresolvedCheckCast(type, object);
4382         }
4383     }
4384 
4385     protected void genCheckCast(ResolvedJavaType resolvedType, ValueNode objectIn) {
4386         ValueNode object = objectIn;
4387         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), resolvedType);
4388         JavaTypeProfile profile = getProfileForTypeCheck(checkedType);
4389 
4390         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4391             if (plugin.handleCheckCast(this, object, checkedType.getType(), profile)) {
4392                 return;
4393             }
4394         }
4395 
4396         ValueNode castNode = null;
4397         if (profile != null) {
4398             if (profile.getNullSeen().isFalse()) {
4399                 object = nullCheckedValue(object);
4400                 ResolvedJavaType singleType = profile.asSingleType();
4401                 if (singleType != null &amp;&amp; checkedType.getType().isAssignableFrom(singleType)) {
4402                     LogicNode typeCheck = append(createInstanceOf(TypeReference.createExactTrusted(singleType), object, profile));
4403                     if (typeCheck.isTautology()) {
4404                         castNode = object;
4405                     } else {
4406                         FixedGuardNode fixedGuard = append(new FixedGuardNode(typeCheck, DeoptimizationReason.TypeCheckedInliningViolated, DeoptimizationAction.InvalidateReprofile, false));
4407                         castNode = append(PiNode.create(object, StampFactory.objectNonNull(TypeReference.createExactTrusted(singleType)), fixedGuard));
4408                     }
4409                 }
4410             }
4411         }
4412 
4413         boolean nonNull = ((ObjectStamp) object.stamp(NodeView.DEFAULT)).nonNull();
4414         if (castNode == null) {
4415             LogicNode condition = genUnique(createInstanceOfAllowNull(checkedType, object, null));
4416             if (condition.isTautology()) {
4417                 castNode = object;
4418             } else {
4419                 GuardingNode guard;
4420                 if (needsExplicitClassCastException(object)) {
4421                     Constant hub = getConstantReflection().asObjectHub(resolvedType);
4422                     Stamp hubStamp = getStampProvider().createHubStamp(StampFactory.object(TypeReference.createExactTrusted(resolvedType)));
4423                     ConstantNode hubConstant = ConstantNode.forConstant(hubStamp, hub, getMetaAccess(), graph);
4424                     guard = emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.CLASS_CAST, object, hubConstant);
4425                 } else {
4426                     guard = append(new FixedGuardNode(condition, DeoptimizationReason.ClassCastException, DeoptimizationAction.InvalidateReprofile, false));
4427                 }
4428                 castNode = append(PiNode.create(object, StampFactory.object(checkedType, nonNull), guard.asNode()));
4429             }
4430         }
4431         frameState.push(JavaKind.Object, castNode);
4432     }
4433 
4434     private void genInstanceOf(int cpi) {
4435         JavaType type = lookupType(cpi, INSTANCEOF);
4436         ValueNode object = frameState.pop(JavaKind.Object);
4437         genInstanceOf(type, object);
4438     }
4439 
4440     protected void genInstanceOf(JavaType type, ValueNode object) {
4441         if (typeIsResolved(type)) {
4442             genInstanceOf((ResolvedJavaType) type, object);
4443         } else {
4444             handleUnresolvedInstanceOf(type, object);
4445         }
4446     }
4447 
4448     @SuppressWarnings(&quot;try&quot;)
4449     protected void genInstanceOf(ResolvedJavaType resolvedType, ValueNode objectIn) {
4450         ValueNode object = objectIn;
4451         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), resolvedType);
4452         JavaTypeProfile profile = getProfileForTypeCheck(checkedType);
4453 
4454         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4455             if (plugin.handleInstanceOf(this, object, checkedType.getType(), profile)) {
4456                 return;
4457             }
4458         }
4459 
4460         LogicNode instanceOfNode = null;
4461         if (profile != null) {
4462             if (profile.getNullSeen().isFalse()) {
4463                 object = nullCheckedValue(object);
4464                 ResolvedJavaType singleType = profile.asSingleType();
4465                 if (singleType != null) {
4466                     LogicNode typeCheck = append(createInstanceOf(TypeReference.createExactTrusted(singleType), object, profile));
4467                     if (!typeCheck.isTautology()) {
4468                         append(new FixedGuardNode(typeCheck, DeoptimizationReason.TypeCheckedInliningViolated, DeoptimizationAction.InvalidateReprofile));
4469                     }
4470                     instanceOfNode = LogicConstantNode.forBoolean(checkedType.getType().isAssignableFrom(singleType));
4471                 }
4472             }
4473         }
4474         if (instanceOfNode == null) {
4475             instanceOfNode = createInstanceOf(checkedType, object, null);
4476         }
4477         LogicNode logicNode = genUnique(instanceOfNode);
4478 
4479         int next = getStream().nextBCI();
4480         int value = getStream().readUByte(next);
4481         if (next &lt;= currentBlock.endBci &amp;&amp; (value == Bytecodes.IFEQ || value == Bytecodes.IFNE)) {
4482             getStream().next();
4483             try (DebugCloseable context = openNodeContext()) {
4484                 BciBlock firstSucc = currentBlock.getSuccessor(0);
4485                 BciBlock secondSucc = currentBlock.getSuccessor(1);
4486                 if (firstSucc != secondSucc) {
4487                     boolean negate = value != Bytecodes.IFNE;
4488                     if (negate) {
4489                         BciBlock tmp = firstSucc;
4490                         firstSucc = secondSucc;
4491                         secondSucc = tmp;
4492                     }
4493                     genIf(instanceOfNode, firstSucc, secondSucc, getProfileProbability(negate));
4494                 } else {
4495                     appendGoto(firstSucc);
4496                 }
4497             }
4498         } else {
4499             // Most frequent for value is IRETURN, followed by ISTORE.
4500             frameState.push(JavaKind.Int, append(genConditional(logicNode)));
4501         }
4502     }
4503 
4504     protected void genNewInstance(int cpi) {
4505         JavaType type = lookupType(cpi, NEW);
4506         genNewInstance(type);
4507     }
4508 
4509     protected void genNewInstance(JavaType type) {
4510         if (typeIsResolved(type)) {
4511             genNewInstance((ResolvedJavaType) type);
4512         } else {
4513             handleUnresolvedNewInstance(type);
4514         }
4515     }
4516 
4517     protected void genNewInstance(ResolvedJavaType resolvedType) {
4518         if (resolvedType.isAbstract() || resolvedType.isInterface()) {
4519             handleIllegalNewInstance(resolvedType);
4520             return;
4521         }
4522         maybeEagerlyInitialize(resolvedType);
4523 
4524         ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4525         if (!resolvedType.isInitialized() &amp;&amp; classInitializationPlugin == null) {
4526             handleIllegalNewInstance(resolvedType);
4527             return;
4528         }
4529 
4530         for (ResolvedJavaType exceptionType : this.graphBuilderConfig.getSkippedExceptionTypes()) {
4531             if (exceptionType.isAssignableFrom(resolvedType)) {
4532                 append(new DeoptimizeNode(DeoptimizationAction.InvalidateRecompile, RuntimeConstraint));
4533                 return;
4534             }
4535         }
4536 
4537         if (classInitializationPlugin != null) {
4538             classInitializationPlugin.apply(this, resolvedType, this::createCurrentFrameState);
4539         }
4540 
4541         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4542             if (plugin.handleNewInstance(this, resolvedType)) {
4543                 return;
4544             }
4545         }
4546 
4547         frameState.push(JavaKind.Object, append(createNewInstance(resolvedType, true)));
4548     }
4549 
4550     /**
4551      * Gets the kind of array elements for the array type code that appears in a
4552      * {@link Bytecodes#NEWARRAY} bytecode.
4553      *
4554      * @param code the array type code
4555      * @return the kind from the array type code
4556      */
4557     private static Class&lt;?&gt; arrayTypeCodeToClass(int code) {
4558         switch (code) {
4559             case 4:
4560                 return boolean.class;
4561             case 5:
4562                 return char.class;
4563             case 6:
4564                 return float.class;
4565             case 7:
4566                 return double.class;
4567             case 8:
4568                 return byte.class;
4569             case 9:
4570                 return short.class;
4571             case 10:
4572                 return int.class;
4573             case 11:
4574                 return long.class;
4575             default:
4576                 throw new IllegalArgumentException(&quot;unknown array type code: &quot; + code);
4577         }
4578     }
4579 
4580     private void genNewPrimitiveArray(int typeCode) {
4581         ResolvedJavaType elementType = getMetaAccess().lookupJavaType(arrayTypeCodeToClass(typeCode));
4582         ValueNode length = frameState.pop(JavaKind.Int);
4583 
4584         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4585             if (plugin.handleNewArray(this, elementType, length)) {
4586                 return;
4587             }
4588         }
4589 
4590         frameState.push(JavaKind.Object, append(createNewArray(elementType, length, true)));
4591     }
4592 
4593     private void genNewObjectArray(int cpi) {
4594         JavaType type = lookupType(cpi, ANEWARRAY);
4595         genNewObjectArray(type);
4596     }
4597 
4598     private void genNewObjectArray(JavaType type) {
4599         if (typeIsResolved(type)) {
4600             genNewObjectArray((ResolvedJavaType) type);
4601         } else {
4602             ValueNode length = frameState.pop(JavaKind.Int);
4603             handleUnresolvedNewObjectArray(type, length);
4604         }
4605     }
4606 
4607     private void genNewObjectArray(ResolvedJavaType resolvedType) {
4608 
4609         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4610         if (classInitializationPlugin != null) {
4611             classInitializationPlugin.apply(this, resolvedType.getArrayClass(), this::createCurrentFrameState);
4612         }
4613 
4614         ValueNode length = frameState.pop(JavaKind.Int);
4615         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4616             if (plugin.handleNewArray(this, resolvedType, length)) {
4617                 return;
4618             }
4619         }
4620 
4621         frameState.push(JavaKind.Object, append(createNewArray(resolvedType, length, true)));
4622     }
4623 
4624     private void genNewMultiArray(int cpi) {
4625         JavaType type = lookupType(cpi, MULTIANEWARRAY);
4626         int rank = getStream().readUByte(bci() + 3);
4627         ValueNode[] dims = new ValueNode[rank];
4628         genNewMultiArray(type, rank, dims);
4629     }
4630 
4631     private void genNewMultiArray(JavaType type, int rank, ValueNode[] dims) {
4632         if (typeIsResolved(type)) {
4633             genNewMultiArray((ResolvedJavaType) type, rank, dims);
4634         } else {
4635             for (int i = rank - 1; i &gt;= 0; i--) {
4636                 dims[i] = frameState.pop(JavaKind.Int);
4637             }
4638             handleUnresolvedNewMultiArray(type, dims);
4639         }
4640     }
4641 
4642     private void genNewMultiArray(ResolvedJavaType resolvedType, int rank, ValueNode[] dims) {
4643 
4644         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4645         if (classInitializationPlugin != null) {
4646             classInitializationPlugin.apply(this, resolvedType, this::createCurrentFrameState);
4647         }
4648 
4649         for (int i = rank - 1; i &gt;= 0; i--) {
4650             dims[i] = frameState.pop(JavaKind.Int);
4651         }
4652 
4653         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4654             if (plugin.handleNewMultiArray(this, resolvedType, dims)) {
4655                 return;
4656             }
4657         }
4658 
4659         frameState.push(JavaKind.Object, append(createNewMultiArray(resolvedType, dims)));
4660     }
4661 
4662     protected void genGetField(int cpi, int opcode) {
4663         genGetField(cpi, opcode, frameState.pop(JavaKind.Object));
4664     }
4665 
4666     protected void genGetField(int cpi, int opcode, ValueNode receiverInput) {
4667         JavaField field = lookupField(cpi, opcode);
4668         genGetField(field, receiverInput);
4669     }
4670 
4671     private void genGetField(JavaField field, ValueNode receiverInput) {
4672         if (field instanceof ResolvedJavaField) {
4673             ValueNode receiver = maybeEmitExplicitNullCheck(receiverInput);
4674             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
4675             genGetField(resolvedField, receiver);
4676         } else {
4677             handleUnresolvedLoadField(field, receiverInput);
4678         }
4679     }
4680 
4681     private void genGetField(ResolvedJavaField resolvedField, ValueNode receiver) {
4682         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4683             graph.recordField(resolvedField);
4684         }
4685 
4686         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4687             if (plugin.handleLoadField(this, receiver, resolvedField)) {
4688                 return;
4689             }
4690         }
4691 
4692         ValueNode fieldRead = append(genLoadField(receiver, resolvedField));
4693 
4694         if (resolvedField.getDeclaringClass().getName().equals(&quot;Ljava/lang/ref/Reference;&quot;) &amp;&amp; resolvedField.getName().equals(&quot;referent&quot;)) {
4695             LocationIdentity referentIdentity = new FieldLocationIdentity(resolvedField);
4696             append(new MembarNode(0, referentIdentity));
4697         }
4698 
4699         JavaKind fieldKind = resolvedField.getJavaKind();
4700 
4701         pushLoadField(resolvedField, fieldRead, fieldKind);
4702     }
4703 
4704     /**
4705      * Returns true if an explicit null check should be emitted for the given object.
4706      *
4707      * @param object The object that is accessed.
4708      */
4709     protected boolean needsExplicitNullCheckException(ValueNode object) {
4710         return needsExplicitException();
4711     }
4712 
4713     /**
4714      * Returns true if an explicit null check should be emitted for the given object.
4715      *
4716      * @param array The array that is accessed.
4717      * @param index The array index that is accessed.
4718      */
4719     protected boolean needsExplicitBoundsCheckException(ValueNode array, ValueNode index) {
4720         return needsExplicitException();
4721     }
4722 
4723     /**
4724      * Returns true if an explicit check for a {@link ClassCastException} should be emitted for the
4725      * given object.
4726      *
4727      * @param object The object that is accessed.
4728      */
4729     protected boolean needsExplicitClassCastException(ValueNode object) {
4730         return needsExplicitException();
4731     }
4732 
4733     /**
4734      * Returns true if an explicit null check should be emitted for the given object.
4735      *
4736      * @param array The array that is accessed.
4737      * @param value The value that is stored into the array.
4738      */
4739     protected boolean needsExplicitStoreCheckException(ValueNode array, ValueNode value) {
4740         return needsExplicitException();
4741     }
4742 
4743     /**
4744      * Returns true if an explicit null check should be emitted for the given object.
4745      *
4746      * @param y The dividend.
4747      */
4748     protected boolean needsExplicitDivisionByZeroException(ValueNode y) {
4749         return needsExplicitException();
4750     }
4751 
4752     @Override
4753     public boolean needsExplicitException() {
4754         BytecodeExceptionMode exceptionMode = graphBuilderConfig.getBytecodeExceptionMode();
4755         if (exceptionMode == BytecodeExceptionMode.CheckAll || StressExplicitExceptionCode.getValue(options)) {
4756             return true;
4757         } else if (exceptionMode == BytecodeExceptionMode.Profile &amp;&amp; profilingInfo != null) {
4758             return profilingInfo.getExceptionSeen(bci()) == TriState.TRUE;
4759         }
4760         return false;
4761     }
4762 
4763     @Override
4764     public AbstractBeginNode genExplicitExceptionEdge(BytecodeExceptionKind exceptionKind) {
4765         BytecodeExceptionNode exceptionNode = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind));
4766         exceptionNode.setStateAfter(createBytecodeExceptionFrameState(bci(), exceptionNode));
4767         AbstractBeginNode exceptionDispatch = handleException(exceptionNode, bci(), false);
4768         exceptionNode.setNext(exceptionDispatch);
4769         return BeginNode.begin(exceptionNode);
4770     }
4771 
4772     protected void genPutField(int cpi, int opcode) {
4773         JavaField field = lookupField(cpi, opcode);
4774         genPutField(field);
4775     }
4776 
4777     protected void genPutField(JavaField field) {
4778         genPutField(field, frameState.pop(field.getJavaKind()));
4779     }
4780 
4781     private void genPutField(JavaField field, ValueNode value) {
4782         ValueNode receiverInput = frameState.pop(JavaKind.Object);
4783 
4784         if (field instanceof ResolvedJavaField) {
4785             ValueNode receiver = maybeEmitExplicitNullCheck(receiverInput);
4786             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
4787 
4788             if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4789                 graph.recordField(resolvedField);
4790             }
4791 
4792             for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4793                 if (plugin.handleStoreField(this, receiver, resolvedField, value)) {
4794                     return;
4795                 }
4796             }
4797 
4798             if (resolvedField.isFinal() &amp;&amp; method.isConstructor()) {
4799                 finalBarrierRequired = true;
4800             }
4801             genStoreField(receiver, resolvedField, value);
4802         } else {
4803             handleUnresolvedStoreField(field, value, receiverInput);
4804         }
4805     }
4806 
4807     protected void genGetStatic(int cpi, int opcode) {
4808         JavaField field = lookupField(cpi, opcode);
4809         genGetStatic(field);
4810     }
4811 
4812     private void genGetStatic(JavaField field) {
4813         ResolvedJavaField resolvedField = resolveStaticFieldAccess(field, null);
4814         if (resolvedField == null) {
4815             return;
4816         }
4817 
4818         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4819             graph.recordField(resolvedField);
4820         }
4821 
4822         /*
4823          * Javac does not allow use of &quot;$assertionsDisabled&quot; for a field name but Eclipse does, in
4824          * which case a suffix is added to the generated field.
4825          */
4826         if (resolvedField.isSynthetic() &amp;&amp; resolvedField.getName().startsWith(&quot;$assertionsDisabled&quot;)) {
4827             if (parsingIntrinsic()) {
4828                 throw new GraalError(&quot;Cannot use an assertion within the context of an intrinsic: &quot; + resolvedField);
4829             } else if (graphBuilderConfig.omitAssertions()) {
4830                 frameState.push(field.getJavaKind(), ConstantNode.forBoolean(true, graph));
4831                 return;
4832             }
4833         }
4834 
4835         ResolvedJavaType holder = resolvedField.getDeclaringClass();
4836         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4837         if (classInitializationPlugin != null) {
4838             classInitializationPlugin.apply(this, holder, this::createCurrentFrameState);
4839         }
4840 
4841         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4842             if (plugin.handleLoadStaticField(this, resolvedField)) {
4843                 return;
4844             }
4845         }
4846 
4847         ValueNode fieldRead = append(genLoadField(null, resolvedField));
4848         JavaKind fieldKind = resolvedField.getJavaKind();
4849 
4850         pushLoadField(resolvedField, fieldRead, fieldKind);
4851     }
4852 
4853     /**
4854      * Pushes a loaded field onto the stack. If the loaded field is volatile, a
4855      * {@link StateSplitProxyNode} is appended so that deoptimization does not deoptimize to a point
4856      * before the field load.
4857      */
4858     private void pushLoadField(ResolvedJavaField resolvedField, ValueNode fieldRead, JavaKind fieldKind) {
4859         if (resolvedField.isVolatile() &amp;&amp; fieldRead instanceof LoadFieldNode) {
4860             StateSplitProxyNode readProxy = append(genVolatileFieldReadProxy(fieldRead));
4861             frameState.push(fieldKind, readProxy);
4862             readProxy.setStateAfter(frameState.create(stream.nextBCI(), readProxy));
4863         } else {
4864             frameState.push(fieldKind, fieldRead);
4865         }
4866     }
4867 
4868     private ResolvedJavaField resolveStaticFieldAccess(JavaField field, ValueNode value) {
4869         if (field instanceof ResolvedJavaField) {
4870             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
4871             ResolvedJavaType resolvedType = resolvedField.getDeclaringClass();
4872             maybeEagerlyInitialize(resolvedType);
4873 
4874             if (resolvedType.isInitialized() || graphBuilderConfig.getPlugins().getClassInitializationPlugin() != null) {
4875                 return resolvedField;
4876             }
4877 
4878             /*
4879              * Static fields have initialization semantics but may be safely accessed under certain
4880              * conditions while the class is being initialized. Executing in the clinit or init of
4881              * subclasses (but not implementers) of the field holder are sure to be running in a
4882              * context where the access is safe.
4883              */
4884             if (!resolvedType.isInterface() &amp;&amp; resolvedType.isAssignableFrom(method.getDeclaringClass())) {
4885                 if (method.isClassInitializer() || method.isConstructor()) {
4886                     return resolvedField;
4887                 }
4888             }
4889         }
4890         if (value == null) {
4891             handleUnresolvedLoadField(field, null);
4892         } else {
4893             handleUnresolvedStoreField(field, value, null);
4894 
4895         }
4896         return null;
4897     }
4898 
4899     protected void genPutStatic(int cpi, int opcode) {
4900         JavaField field = lookupField(cpi, opcode);
4901         genPutStatic(field);
4902     }
4903 
4904     protected void genPutStatic(JavaField field) {
4905         int stackSizeBefore = frameState.stackSize();
4906         ValueNode value = frameState.pop(field.getJavaKind());
4907         ResolvedJavaField resolvedField = resolveStaticFieldAccess(field, value);
4908         if (resolvedField == null) {
4909             return;
4910         }
4911 
4912         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4913             graph.recordField(resolvedField);
4914         }
4915 
4916         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4917         ResolvedJavaType holder = resolvedField.getDeclaringClass();
4918         if (classInitializationPlugin != null) {
4919             Supplier&lt;FrameState&gt; stateBefore = () -&gt; {
4920                 JavaKind[] pushedSlotKinds = {field.getJavaKind()};
4921                 ValueNode[] pushedValues = {value};
4922                 FrameState fs = frameState.create(bci(), getNonIntrinsicAncestor(), false, pushedSlotKinds, pushedValues);
4923                 assert stackSizeBefore == fs.stackSize();
4924                 return fs;
4925             };
4926             classInitializationPlugin.apply(this, holder, stateBefore);
4927         }
4928 
4929         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4930             if (plugin.handleStoreStaticField(this, resolvedField, value)) {
4931                 return;
4932             }
4933         }
4934 
4935         genStoreField(null, resolvedField, value);
4936     }
4937 
4938     private double[] switchProbability(int numberOfCases, int bci) {
4939         double[] prob = (profilingInfo == null ? null : profilingInfo.getSwitchProbabilities(bci));
4940         if (prob != null) {
4941             assert prob.length == numberOfCases;
4942         } else {
4943             debug.log(&quot;Missing probability (switch) in %s at bci %d&quot;, method, bci);
4944             prob = new double[numberOfCases];
4945             for (int i = 0; i &lt; numberOfCases; i++) {
4946                 prob[i] = 1.0d / numberOfCases;
4947             }
4948         }
4949         assert allPositive(prob);
4950         return prob;
4951     }
4952 
4953     private static boolean allPositive(double[] a) {
4954         for (double d : a) {
4955             if (d &lt; 0) {
4956                 return false;
4957             }
4958         }
4959         return true;
4960     }
4961 
4962     static class SuccessorInfo {
4963         final int blockIndex;
4964         int actualIndex;
4965 
4966         SuccessorInfo(int blockSuccessorIndex) {
4967             this.blockIndex = blockSuccessorIndex;
4968             actualIndex = -1;
4969         }
4970     }
4971 
4972     private static final int SWITCH_DEOPT_UNSEEN = -2;
4973     private static final int SWITCH_DEOPT_SEEN = -1;
4974 
4975     private void genSwitch(BytecodeSwitch bs) {
4976         int bci = bci();
4977         ValueNode value = frameState.pop(JavaKind.Int);
4978 
4979         int nofCases = bs.numberOfCases();
4980         int nofCasesPlusDefault = nofCases + 1;
4981         double[] keyProbabilities = switchProbability(nofCasesPlusDefault, bci);
4982 
4983         EconomicMap&lt;Integer, SuccessorInfo&gt; bciToBlockSuccessorIndex = EconomicMap.create(Equivalence.DEFAULT);
4984         for (int i = 0; i &lt; currentBlock.getSuccessorCount(); i++) {
4985             assert !bciToBlockSuccessorIndex.containsKey(currentBlock.getSuccessor(i).startBci);
4986             bciToBlockSuccessorIndex.put(currentBlock.getSuccessor(i).startBci, new SuccessorInfo(i));
4987         }
4988 
4989         ArrayList&lt;BciBlock&gt; actualSuccessors = new ArrayList&lt;&gt;();
4990         int[] keys = new int[nofCases];
4991         int[] keySuccessors = new int[nofCasesPlusDefault];
4992         int deoptSuccessorIndex = SWITCH_DEOPT_UNSEEN;
4993         int nextSuccessorIndex = 0;
4994         boolean constantValue = value.isConstant();
4995         for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
4996             if (i &lt; nofCases) {
4997                 keys[i] = bs.keyAt(i);
4998             }
4999             if (!constantValue &amp;&amp; isNeverExecutedCode(keyProbabilities[i])) {
5000                 deoptSuccessorIndex = SWITCH_DEOPT_SEEN;
5001                 keySuccessors[i] = SWITCH_DEOPT_SEEN;
5002             } else {
5003                 int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
5004                 SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
5005                 if (info.actualIndex &lt; 0) {
5006                     info.actualIndex = nextSuccessorIndex++;
5007                     actualSuccessors.add(currentBlock.getSuccessor(info.blockIndex));
5008                 }
5009                 keySuccessors[i] = info.actualIndex;
5010             }
5011         }
5012         /*
5013          * When the profile indicates a case is never taken, the above code will cause the case to
5014          * deopt should it be subsequently encountered. However, the case may share code with
5015          * another case that is taken according to the profile.
5016          *
5017          * For example:
5018          * // @formatter:off
5019          * switch (opcode) {
5020          *     case GOTO:
5021          *     case GOTO_W: {
5022          *         // emit goto code
5023          *         break;
5024          *     }
5025          * }
5026          * // @formatter:on
5027          *
5028          * The profile may indicate the GOTO_W case is never taken, and thus a deoptimization stub
5029          * will be emitted. There might be optimization opportunity if additional branching based
5030          * on opcode is within the case block. Specially, if there is only single case that
5031          * reaches a target, we have better chance cutting out unused branches. Otherwise,
5032          * it might be beneficial routing to the same code instead of deopting.
5033          *
5034          * The following code rewires deoptimization stub to existing resolved branch target if
5035          * the target is connected by more than 1 cases.
5036          *
5037          * If this operation rewires every deoptimization seen to an existing branch, care is
5038          * taken that we do not spawn a branch that will never be taken.
5039          */
5040         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {
5041             int[] connectedCases = new int[nextSuccessorIndex + 1];
5042             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
5043                 connectedCases[keySuccessors[i] + 1]++;
5044             }
5045 
5046             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
5047                 if (keySuccessors[i] == SWITCH_DEOPT_SEEN) {
5048                     int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
5049                     SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
5050                     int rewiredIndex = info.actualIndex;
5051                     if (rewiredIndex &gt;= 0 &amp;&amp; connectedCases[rewiredIndex + 1] &gt; 1) {
5052                         // Rewire
5053                         keySuccessors[i] = info.actualIndex;
5054                     } else {
5055                         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {
5056                             // Spawn deopt successor if needed.
5057                             deoptSuccessorIndex = nextSuccessorIndex++;
5058                             actualSuccessors.add(null);
5059                         }
5060                         keySuccessors[i] = deoptSuccessorIndex;
5061                     }
5062                 }
5063             }
5064         }
5065 
5066         genIntegerSwitch(value, actualSuccessors, keys, keyProbabilities, keySuccessors);
5067 
5068     }
5069 
5070     protected boolean isNeverExecutedCode(double probability) {
5071         return probability == 0 &amp;&amp; optimisticOpts.removeNeverExecutedCode(getOptions());
5072     }
5073 
5074     private double clampProbability(double probability) {
5075         if (!optimisticOpts.removeNeverExecutedCode(getOptions())) {
5076             if (probability == 0) {
5077                 return LUDICROUSLY_SLOW_PATH_PROBABILITY;
5078             } else if (probability == 1) {
5079                 return LUDICROUSLY_FAST_PATH_PROBABILITY;
5080             }
5081         }
5082         return probability;
5083     }
5084 
5085     private boolean assertAtIfBytecode() {
5086         int bytecode = stream.currentBC();
5087         switch (bytecode) {
5088             case IFEQ:
5089             case IFNE:
5090             case IFLT:
5091             case IFGE:
5092             case IFGT:
5093             case IFLE:
5094             case IF_ICMPEQ:
5095             case IF_ICMPNE:
5096             case IF_ICMPLT:
5097             case IF_ICMPGE:
5098             case IF_ICMPGT:
5099             case IF_ICMPLE:
5100             case IF_ACMPEQ:
5101             case IF_ACMPNE:
5102             case IFNULL:
5103             case IFNONNULL:
5104                 return true;
5105         }
5106         assert false : String.format(&quot;%x is not an if bytecode&quot;, bytecode);
5107         return true;
5108     }
5109 
5110     public final void processBytecode(int bci, int opcode) {
5111         int cpi;
5112 
5113         // @formatter:off
5114         // Checkstyle: stop
5115         switch (opcode) {
5116             case NOP            : /* nothing to do */ break;
5117             case ACONST_NULL    : frameState.push(JavaKind.Object, appendConstant(JavaConstant.NULL_POINTER)); break;
5118             case ICONST_M1      : // fall through
5119             case ICONST_0       : // fall through
5120             case ICONST_1       : // fall through
5121             case ICONST_2       : // fall through
5122             case ICONST_3       : // fall through
5123             case ICONST_4       : // fall through
5124             case ICONST_5       : frameState.push(JavaKind.Int, appendConstant(JavaConstant.forInt(opcode - ICONST_0))); break;
5125             case LCONST_0       : // fall through
5126             case LCONST_1       : frameState.push(JavaKind.Long, appendConstant(JavaConstant.forLong(opcode - LCONST_0))); break;
5127             case FCONST_0       : // fall through
5128             case FCONST_1       : // fall through
5129             case FCONST_2       : frameState.push(JavaKind.Float, appendConstant(JavaConstant.forFloat(opcode - FCONST_0))); break;
5130             case DCONST_0       : // fall through
5131             case DCONST_1       : frameState.push(JavaKind.Double, appendConstant(JavaConstant.forDouble(opcode - DCONST_0))); break;
5132             case BIPUSH         : frameState.push(JavaKind.Int, appendConstant(JavaConstant.forInt(stream.readByte()))); break;
5133             case SIPUSH         : frameState.push(JavaKind.Int, appendConstant(JavaConstant.forInt(stream.readShort()))); break;
5134             case LDC            : // fall through
5135             case LDC_W          : // fall through
5136             case LDC2_W         : genLoadConstant(stream.readCPI(), opcode); break;
5137             case ILOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Int); break;
5138             case LLOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Long); break;
5139             case FLOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Float); break;
5140             case DLOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Double); break;
5141             case ALOAD          : loadLocalObject(stream.readLocalIndex()); break;
5142             case ILOAD_0        : // fall through
5143             case ILOAD_1        : // fall through
5144             case ILOAD_2        : // fall through
5145             case ILOAD_3        : loadLocal(opcode - ILOAD_0, JavaKind.Int); break;
5146             case LLOAD_0        : // fall through
5147             case LLOAD_1        : // fall through
5148             case LLOAD_2        : // fall through
5149             case LLOAD_3        : loadLocal(opcode - LLOAD_0, JavaKind.Long); break;
5150             case FLOAD_0        : // fall through
5151             case FLOAD_1        : // fall through
5152             case FLOAD_2        : // fall through
5153             case FLOAD_3        : loadLocal(opcode - FLOAD_0, JavaKind.Float); break;
5154             case DLOAD_0        : // fall through
5155             case DLOAD_1        : // fall through
5156             case DLOAD_2        : // fall through
5157             case DLOAD_3        : loadLocal(opcode - DLOAD_0, JavaKind.Double); break;
5158             case ALOAD_0        : // fall through
5159             case ALOAD_1        : // fall through
5160             case ALOAD_2        : // fall through
5161             case ALOAD_3        : loadLocalObject(opcode - ALOAD_0); break;
5162             case IALOAD         : genLoadIndexed(JavaKind.Int   ); break;
5163             case LALOAD         : genLoadIndexed(JavaKind.Long  ); break;
5164             case FALOAD         : genLoadIndexed(JavaKind.Float ); break;
5165             case DALOAD         : genLoadIndexed(JavaKind.Double); break;
5166             case AALOAD         : genLoadIndexed(JavaKind.Object); break;
5167             case BALOAD         : genLoadIndexed(JavaKind.Byte  ); break;
5168             case CALOAD         : genLoadIndexed(JavaKind.Char  ); break;
5169             case SALOAD         : genLoadIndexed(JavaKind.Short ); break;
5170             case ISTORE         : storeLocal(JavaKind.Int, stream.readLocalIndex()); break;
5171             case LSTORE         : storeLocal(JavaKind.Long, stream.readLocalIndex()); break;
5172             case FSTORE         : storeLocal(JavaKind.Float, stream.readLocalIndex()); break;
5173             case DSTORE         : storeLocal(JavaKind.Double, stream.readLocalIndex()); break;
5174             case ASTORE         : storeLocal(JavaKind.Object, stream.readLocalIndex()); break;
5175             case ISTORE_0       : // fall through
5176             case ISTORE_1       : // fall through
5177             case ISTORE_2       : // fall through
5178             case ISTORE_3       : storeLocal(JavaKind.Int, opcode - ISTORE_0); break;
5179             case LSTORE_0       : // fall through
5180             case LSTORE_1       : // fall through
5181             case LSTORE_2       : // fall through
5182             case LSTORE_3       : storeLocal(JavaKind.Long, opcode - LSTORE_0); break;
5183             case FSTORE_0       : // fall through
5184             case FSTORE_1       : // fall through
5185             case FSTORE_2       : // fall through
5186             case FSTORE_3       : storeLocal(JavaKind.Float, opcode - FSTORE_0); break;
5187             case DSTORE_0       : // fall through
5188             case DSTORE_1       : // fall through
5189             case DSTORE_2       : // fall through
5190             case DSTORE_3       : storeLocal(JavaKind.Double, opcode - DSTORE_0); break;
5191             case ASTORE_0       : // fall through
5192             case ASTORE_1       : // fall through
5193             case ASTORE_2       : // fall through
5194             case ASTORE_3       : storeLocal(JavaKind.Object, opcode - ASTORE_0); break;
5195             case IASTORE        : genStoreIndexed(JavaKind.Int   ); break;
5196             case LASTORE        : genStoreIndexed(JavaKind.Long  ); break;
5197             case FASTORE        : genStoreIndexed(JavaKind.Float ); break;
5198             case DASTORE        : genStoreIndexed(JavaKind.Double); break;
5199             case AASTORE        : genStoreIndexed(JavaKind.Object); break;
5200             case BASTORE        : genStoreIndexed(JavaKind.Byte  ); break;
5201             case CASTORE        : genStoreIndexed(JavaKind.Char  ); break;
5202             case SASTORE        : genStoreIndexed(JavaKind.Short ); break;
5203             case POP            : // fall through
5204             case POP2           : // fall through
5205             case DUP            : // fall through
5206             case DUP_X1         : // fall through
5207             case DUP_X2         : // fall through
5208             case DUP2           : // fall through
5209             case DUP2_X1        : // fall through
5210             case DUP2_X2        : // fall through
5211             case SWAP           : frameState.stackOp(opcode); break;
5212             case IADD           : // fall through
5213             case ISUB           : // fall through
5214             case IMUL           : genArithmeticOp(JavaKind.Int, opcode); break;
5215             case IDIV           : // fall through
5216             case IREM           : genIntegerDivOp(JavaKind.Int, opcode); break;
5217             case LADD           : // fall through
5218             case LSUB           : // fall through
5219             case LMUL           : genArithmeticOp(JavaKind.Long, opcode); break;
5220             case LDIV           : // fall through
5221             case LREM           : genIntegerDivOp(JavaKind.Long, opcode); break;
5222             case FADD           : // fall through
5223             case FSUB           : // fall through
5224             case FMUL           : // fall through
5225             case FDIV           : // fall through
5226             case FREM           : genArithmeticOp(JavaKind.Float, opcode); break;
5227             case DADD           : // fall through
5228             case DSUB           : // fall through
5229             case DMUL           : // fall through
5230             case DDIV           : // fall through
5231             case DREM           : genArithmeticOp(JavaKind.Double, opcode); break;
5232             case INEG           : genNegateOp(JavaKind.Int); break;
5233             case LNEG           : genNegateOp(JavaKind.Long); break;
5234             case FNEG           : genNegateOp(JavaKind.Float); break;
5235             case DNEG           : genNegateOp(JavaKind.Double); break;
5236             case ISHL           : // fall through
5237             case ISHR           : // fall through
5238             case IUSHR          : genShiftOp(JavaKind.Int, opcode); break;
5239             case IAND           : // fall through
5240             case IOR            : // fall through
5241             case IXOR           : genLogicOp(JavaKind.Int, opcode); break;
5242             case LSHL           : // fall through
5243             case LSHR           : // fall through
5244             case LUSHR          : genShiftOp(JavaKind.Long, opcode); break;
5245             case LAND           : // fall through
5246             case LOR            : // fall through
5247             case LXOR           : genLogicOp(JavaKind.Long, opcode); break;
5248             case IINC           : genIncrement(); break;
5249             case I2F            : genFloatConvert(FloatConvert.I2F, JavaKind.Int, JavaKind.Float); break;
5250             case I2D            : genFloatConvert(FloatConvert.I2D, JavaKind.Int, JavaKind.Double); break;
5251             case L2F            : genFloatConvert(FloatConvert.L2F, JavaKind.Long, JavaKind.Float); break;
5252             case L2D            : genFloatConvert(FloatConvert.L2D, JavaKind.Long, JavaKind.Double); break;
5253             case F2I            : genFloatConvert(FloatConvert.F2I, JavaKind.Float, JavaKind.Int); break;
5254             case F2L            : genFloatConvert(FloatConvert.F2L, JavaKind.Float, JavaKind.Long); break;
5255             case F2D            : genFloatConvert(FloatConvert.F2D, JavaKind.Float, JavaKind.Double); break;
5256             case D2I            : genFloatConvert(FloatConvert.D2I, JavaKind.Double, JavaKind.Int); break;
5257             case D2L            : genFloatConvert(FloatConvert.D2L, JavaKind.Double, JavaKind.Long); break;
5258             case D2F            : genFloatConvert(FloatConvert.D2F, JavaKind.Double, JavaKind.Float); break;
5259             case L2I            : genNarrow(JavaKind.Long, JavaKind.Int); break;
5260             case I2L            : genSignExtend(JavaKind.Int, JavaKind.Long); break;
5261             case I2B            : genSignExtend(JavaKind.Byte, JavaKind.Int); break;
5262             case I2S            : genSignExtend(JavaKind.Short, JavaKind.Int); break;
5263             case I2C            : genZeroExtend(JavaKind.Char, JavaKind.Int); break;
5264             case LCMP           : genIntegerCompareOp(JavaKind.Long); break;
5265             case FCMPL          : genFloatCompareOp(JavaKind.Float, true); break;
5266             case FCMPG          : genFloatCompareOp(JavaKind.Float, false); break;
5267             case DCMPL          : genFloatCompareOp(JavaKind.Double, true); break;
5268             case DCMPG          : genFloatCompareOp(JavaKind.Double, false); break;
5269             case IFEQ           : genIfZero(Condition.EQ); break;
5270             case IFNE           : genIfZero(Condition.NE); break;
5271             case IFLT           : genIfZero(Condition.LT); break;
5272             case IFGE           : genIfZero(Condition.GE); break;
5273             case IFGT           : genIfZero(Condition.GT); break;
5274             case IFLE           : genIfZero(Condition.LE); break;
5275             case IF_ICMPEQ      : genIfSame(JavaKind.Int, Condition.EQ); break;
5276             case IF_ICMPNE      : genIfSame(JavaKind.Int, Condition.NE); break;
5277             case IF_ICMPLT      : genIfSame(JavaKind.Int, Condition.LT); break;
5278             case IF_ICMPGE      : genIfSame(JavaKind.Int, Condition.GE); break;
5279             case IF_ICMPGT      : genIfSame(JavaKind.Int, Condition.GT); break;
5280             case IF_ICMPLE      : genIfSame(JavaKind.Int, Condition.LE); break;
5281             case IF_ACMPEQ      : genIfSame(JavaKind.Object, Condition.EQ); break;
5282             case IF_ACMPNE      : genIfSame(JavaKind.Object, Condition.NE); break;
5283             case GOTO           : genGoto(); break;
5284             case JSR            : genJsr(stream.readBranchDest()); break;
5285             case RET            : genRet(stream.readLocalIndex()); break;
5286             case TABLESWITCH    : genSwitch(new BytecodeTableSwitch(getStream(), bci())); break;
5287             case LOOKUPSWITCH   : genSwitch(new BytecodeLookupSwitch(getStream(), bci())); break;
5288             case IRETURN        : genReturn(frameState.pop(JavaKind.Int), JavaKind.Int); break;
5289             case LRETURN        : genReturn(frameState.pop(JavaKind.Long), JavaKind.Long); break;
5290             case FRETURN        : genReturn(frameState.pop(JavaKind.Float), JavaKind.Float); break;
5291             case DRETURN        : genReturn(frameState.pop(JavaKind.Double), JavaKind.Double); break;
5292             case ARETURN        : genReturn(frameState.pop(JavaKind.Object), JavaKind.Object); break;
5293             case RETURN         : genReturn(null, JavaKind.Void); break;
5294             case GETSTATIC      : cpi = stream.readCPI(); genGetStatic(cpi, opcode); break;
5295             case PUTSTATIC      : cpi = stream.readCPI(); genPutStatic(cpi, opcode); break;
5296             case GETFIELD       : cpi = stream.readCPI(); genGetField(cpi, opcode); break;
5297             case PUTFIELD       : cpi = stream.readCPI(); genPutField(cpi, opcode); break;
5298             case INVOKEVIRTUAL  : cpi = stream.readCPI(); genInvokeVirtual(cpi, opcode); break;
5299             case INVOKESPECIAL  : cpi = stream.readCPI(); genInvokeSpecial(cpi, opcode); break;
5300             case INVOKESTATIC   : cpi = stream.readCPI(); genInvokeStatic(cpi, opcode); break;
5301             case INVOKEINTERFACE: cpi = stream.readCPI(); genInvokeInterface(cpi, opcode); break;
5302             case INVOKEDYNAMIC  : cpi = stream.readCPI4(); genInvokeDynamic(cpi, opcode); break;
5303             case NEW            : genNewInstance(stream.readCPI()); break;
5304             case NEWARRAY       : genNewPrimitiveArray(stream.readLocalIndex()); break;
5305             case ANEWARRAY      : genNewObjectArray(stream.readCPI()); break;
5306             case ARRAYLENGTH    : genArrayLength(); break;
5307             case ATHROW         : genThrow(); break;
5308             case CHECKCAST      : genCheckCast(stream.readCPI()); break;
5309             case INSTANCEOF     : genInstanceOf(stream.readCPI()); break;
5310             case MONITORENTER   : genMonitorEnter(frameState.pop(JavaKind.Object), stream.nextBCI()); break;
5311             case MONITOREXIT    : genMonitorExit(frameState.pop(JavaKind.Object), null, stream.nextBCI()); break;
5312             case MULTIANEWARRAY : genNewMultiArray(stream.readCPI()); break;
5313             case IFNULL         : genIfNull(Condition.EQ); break;
5314             case IFNONNULL      : genIfNull(Condition.NE); break;
5315             case GOTO_W         : genGoto(); break;
5316             case JSR_W          : genJsr(stream.readBranchDest()); break;
5317             case BREAKPOINT     : throw new PermanentBailoutException(&quot;concurrent setting of breakpoint&quot;);
5318             default             : throw new PermanentBailoutException(&quot;Unsupported opcode %d (%s) [bci=%d]&quot;, opcode, nameOf(opcode), bci);
5319         }
5320         // @formatter:on
5321         // Checkstyle: resume
5322     }
5323 
5324     private void genArrayLength() {
5325         ValueNode array = maybeEmitExplicitNullCheck(frameState.pop(JavaKind.Object));
5326         frameState.push(JavaKind.Int, append(genArrayLength(array)));
5327     }
5328 
5329     @Override
5330     public ResolvedJavaMethod getMethod() {
5331         return method;
5332     }
5333 
5334     @Override
5335     public Bytecode getCode() {
5336         return code;
5337     }
5338 
5339     public FrameStateBuilder getFrameStateBuilder() {
5340         return frameState;
5341     }
5342 
5343     private boolean firstTraceEmitted;
5344 
5345     protected void traceInstruction(int bci, int opcode, boolean blockStart) {
5346         String indent = new String(new char[getDepth() * 2]).replace(&#39;\0&#39;, &#39; &#39;);
5347         StringBuilder sb = new StringBuilder(40);
5348         String nl = System.lineSeparator();
5349         if (!firstTraceEmitted) {
5350             sb.append(indent).append(method.format(&quot;Parsing %H.%n(%p)%r&quot;)).append(nl);
5351             if (traceLevel &gt;= TRACELEVEL_BLOCKMAP) {
5352                 sb.append(indent).append(&quot;Blocks:&quot;).append(nl);
5353                 String bm = blockMap.toString().replace(nl, nl + indent + &quot;  &quot;);
5354                 sb.append(indent).append(&quot;  &quot;).append(bm).append(nl);
5355             }
5356             firstTraceEmitted = true;
5357         }
5358         if (traceLevel &gt;= TRACELEVEL_STATE) {
5359             sb.append(indent).append(frameState).append(nl);
5360         }
5361         sb.append(indent);
5362         sb.append(blockStart ? &#39;+&#39; : &#39;|&#39;);
5363         if (bci &lt; 10) {
5364             sb.append(&quot;  &quot;);
5365         } else if (bci &lt; 100) {
5366             sb.append(&#39; &#39;);
5367         }
5368         sb.append(bci).append(&quot;: &quot;).append(Bytecodes.nameOf(opcode));
5369         for (int i = bci + 1; i &lt; stream.nextBCI(); ++i) {
5370             sb.append(&#39; &#39;).append(stream.readUByte(i));
5371         }
5372         if (!currentBlock.getJsrScope().isEmpty()) {
5373             sb.append(&#39; &#39;).append(currentBlock.getJsrScope());
5374         }
5375         TTY.println(&quot;%s&quot;, sb);
5376     }
5377 
5378     @Override
5379     public boolean parsingIntrinsic() {
5380         return intrinsicContext != null;
5381     }
5382 
5383     @Override
5384     public BytecodeParser getNonIntrinsicAncestor() {
5385         BytecodeParser ancestor = parent;
5386         while (ancestor != null &amp;&amp; ancestor.parsingIntrinsic()) {
5387             ancestor = ancestor.parent;
5388         }
5389         return ancestor;
5390     }
5391 
5392     static String nSpaces(int n) {
5393         return n == 0 ? &quot;&quot; : format(&quot;%&quot; + n + &quot;s&quot;, &quot;&quot;);
5394     }
5395 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
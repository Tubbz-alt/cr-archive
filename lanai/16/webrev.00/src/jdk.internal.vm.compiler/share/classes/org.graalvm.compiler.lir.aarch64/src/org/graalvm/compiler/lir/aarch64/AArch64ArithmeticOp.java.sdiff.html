<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ArithmeticOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.jtt/src/org/graalvm/compiler/jtt/reflect/Field_set02.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64BitManipulationOp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64ArithmeticOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 55     MUL,
 56     MULVS,
 57     MNEG,
 58     DIV,
 59     SMULH,
 60     UMULH,
 61     SMULL,
 62     SMNEGL,
 63     MADD,
 64     MSUB,
 65     FMADD,
 66     SMADDL,
 67     SMSUBL,
 68     REM,
 69     UDIV,
 70     UREM,
 71     AND(LOGICAL),
 72     ANDS(LOGICAL),
 73     OR(LOGICAL),
 74     XOR(LOGICAL),



 75     SHL(SHIFT),
 76     LSHR(SHIFT),
 77     ASHR(SHIFT),


 78     ABS,
<span class="line-removed"> 79 </span>
 80     FADD,
 81     FSUB,
 82     FMUL,
 83     FDIV,
 84     FREM,
 85     FNEG,
 86     FABS,
 87     FRINTM,
 88     FRINTN,
 89     FRINTP,
 90     SQRT;
 91 
 92     /**
 93      * Specifies what constants can be used directly without having to be loaded into a register
 94      * with the given instruction.
 95      */
 96     public enum ARMv8ConstantCategory {
 97         NONE,
 98         LOGICAL,
 99         ARITHMETIC,
</pre>
<hr />
<pre>
216                     }
217                     break;
218                 case ANDS:
219                     masm.ands(size, dst, src, b.asLong());
220                     break;
221                 case OR:
222                     masm.or(size, dst, src, b.asLong());
223                     break;
224                 case XOR:
225                     masm.eor(size, dst, src, b.asLong());
226                     break;
227                 case SHL:
228                     masm.shl(size, dst, src, b.asLong());
229                     break;
230                 case LSHR:
231                     masm.lshr(size, dst, src, b.asLong());
232                     break;
233                 case ASHR:
234                     masm.ashr(size, dst, src, b.asLong());
235                     break;



236                 default:
237                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + op.name());
238             }
239         }
240     }
241 
242     public static class BinaryOp extends AArch64LIRInstruction {
243         private static final LIRInstructionClass&lt;BinaryOp&gt; TYPE = LIRInstructionClass.create(BinaryOp.class);
244 
245         @Opcode private final AArch64ArithmeticOp op;
246         @Def({REG}) protected AllocatableValue result;
247         @Use({REG}) protected AllocatableValue a;
248         @Use({REG}) protected AllocatableValue b;
249 
250         public BinaryOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue a, AllocatableValue b) {
251             super(TYPE);
252             this.op = op;
253             this.result = result;
254             this.a = a;
255             this.b = b;
</pre>
<hr />
<pre>
293                     masm.smnegl(size, dst, src1, src2);
294                     break;
295                 case DIV:
296                     masm.sdiv(size, dst, src1, src2);
297                     break;
298                 case UDIV:
299                     masm.udiv(size, dst, src1, src2);
300                     break;
301                 case AND:
302                     masm.and(size, dst, src1, src2);
303                     break;
304                 case ANDS:
305                     masm.ands(size, dst, src1, src2);
306                     break;
307                 case OR:
308                     masm.or(size, dst, src1, src2);
309                     break;
310                 case XOR:
311                     masm.eor(size, dst, src1, src2);
312                     break;









313                 case SHL:
314                     masm.shl(size, dst, src1, src2);
315                     break;
316                 case LSHR:
317                     masm.lshr(size, dst, src1, src2);
318                     break;
319                 case ASHR:
320                     masm.ashr(size, dst, src1, src2);
321                     break;



322                 case FADD:
323                     masm.fadd(size, dst, src1, src2);
324                     break;
325                 case FSUB:
326                     masm.fsub(size, dst, src1, src2);
327                     break;
328                 case FMUL:
329                     masm.fmul(size, dst, src1, src2);
330                     break;
331                 case FDIV:
332                     masm.fdiv(size, dst, src1, src2);
333                     break;
334                 case MULVS:
335                     masm.mulvs(size, dst, src1, src2);
336                     break;
337                 default:
338                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + op.name());
339             }
340         }
341     }
</pre>
<hr />
<pre>
376                     masm.urem(size, dst, src1, src2);
377                     break;
378                 case FREM:
379                     masm.frem(size, dst, src1, src2);
380                     break;
381                 default:
382                     throw GraalError.shouldNotReachHere();
383             }
384         }
385     }
386 
387     public static class BinaryShiftOp extends AArch64LIRInstruction {
388         private static final LIRInstructionClass&lt;BinaryShiftOp&gt; TYPE = LIRInstructionClass.create(BinaryShiftOp.class);
389 
390         @Opcode private final AArch64ArithmeticOp op;
391         @Def(REG) protected AllocatableValue result;
392         @Use(REG) protected AllocatableValue src1;
393         @Use(REG) protected AllocatableValue src2;
394         private final AArch64MacroAssembler.ShiftType shiftType;
395         private final int shiftAmt;
<span class="line-removed">396         private final boolean isShiftNot;</span>
397 
398         /**
<span class="line-removed">399          * If shiftNot: Computes &lt;code&gt;result = src1 &lt;op&gt; ~(src2 &lt;shiftType&gt; &lt;shiftAmt&gt;)&lt;/code&gt;</span>
<span class="line-removed">400          * (Only for logic ops). else: Computes</span>
401          * &lt;code&gt;result = src1 &lt;op&gt; src2 &lt;shiftType&gt; &lt;shiftAmt&gt;&lt;/code&gt;.
402          */
403         public BinaryShiftOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue src1, AllocatableValue src2,
<span class="line-modified">404                         AArch64MacroAssembler.ShiftType shiftType, int shiftAmt, boolean isShiftNot) {</span>
405             super(TYPE);
<span class="line-removed">406             assert op == ADD || op == SUB || op == AND || op == OR || op == XOR;</span>
407             this.op = op;
408             this.result = result;
409             this.src1 = src1;
410             this.src2 = src2;
411             this.shiftType = shiftType;
412             this.shiftAmt = shiftAmt;
<span class="line-removed">413             this.isShiftNot = isShiftNot;</span>
414         }
415 
416         @Override
417         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
418             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
419             switch (op) {
420                 case ADD:
421                     masm.add(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
422                     break;
423                 case SUB:
424                     masm.sub(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
425                     break;
426                 case AND:
<span class="line-modified">427                     if (!isShiftNot) {</span>
<span class="line-removed">428                         masm.and(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-removed">429                     } else {</span>
<span class="line-removed">430                         masm.bic(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-removed">431                     }</span>
432                     break;
433                 case OR:
<span class="line-modified">434                     if (!isShiftNot) {</span>
<span class="line-removed">435                         masm.or(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-removed">436                     } else {</span>
<span class="line-removed">437                         masm.orn(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-removed">438                     }</span>
439                     break;
440                 case XOR:
<span class="line-modified">441                     if (!isShiftNot) {</span>
<span class="line-modified">442                         masm.eor(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-modified">443                     } else {</span>
<span class="line-modified">444                         masm.eon(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-modified">445                     }</span>





446                     break;
447                 default:
<span class="line-modified">448                     throw GraalError.shouldNotReachHere();</span>
449             }
450         }
451     }
452 
453     public static class ExtendedAddShiftOp extends AArch64LIRInstruction {
454         private static final LIRInstructionClass&lt;ExtendedAddShiftOp&gt; TYPE = LIRInstructionClass.create(ExtendedAddShiftOp.class);
455         @Def(REG) protected AllocatableValue result;
456         @Use(REG) protected AllocatableValue src1;
457         @Use(REG) protected AllocatableValue src2;
458         private final AArch64Assembler.ExtendType extendType;
459         private final int shiftAmt;
460 
461         /**
462          * Computes &lt;code&gt;result = src1 + extendType(src2) &lt;&lt; shiftAmt&lt;/code&gt;.
463          *
464          * @param extendType defines how src2 is extended to the same size as src1.
465          * @param shiftAmt must be in range 0 to 4.
466          */
467         public ExtendedAddShiftOp(AllocatableValue result, AllocatableValue src1, AllocatableValue src2, AArch64Assembler.ExtendType extendType, int shiftAmt) {
468             super(TYPE);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 55     MUL,
 56     MULVS,
 57     MNEG,
 58     DIV,
 59     SMULH,
 60     UMULH,
 61     SMULL,
 62     SMNEGL,
 63     MADD,
 64     MSUB,
 65     FMADD,
 66     SMADDL,
 67     SMSUBL,
 68     REM,
 69     UDIV,
 70     UREM,
 71     AND(LOGICAL),
 72     ANDS(LOGICAL),
 73     OR(LOGICAL),
 74     XOR(LOGICAL),
<span class="line-added"> 75     BIC,</span>
<span class="line-added"> 76     ORN,</span>
<span class="line-added"> 77     EON,</span>
 78     SHL(SHIFT),
 79     LSHR(SHIFT),
 80     ASHR(SHIFT),
<span class="line-added"> 81     ROR(SHIFT),</span>
<span class="line-added"> 82     RORV(SHIFT),</span>
 83     ABS,

 84     FADD,
 85     FSUB,
 86     FMUL,
 87     FDIV,
 88     FREM,
 89     FNEG,
 90     FABS,
 91     FRINTM,
 92     FRINTN,
 93     FRINTP,
 94     SQRT;
 95 
 96     /**
 97      * Specifies what constants can be used directly without having to be loaded into a register
 98      * with the given instruction.
 99      */
100     public enum ARMv8ConstantCategory {
101         NONE,
102         LOGICAL,
103         ARITHMETIC,
</pre>
<hr />
<pre>
220                     }
221                     break;
222                 case ANDS:
223                     masm.ands(size, dst, src, b.asLong());
224                     break;
225                 case OR:
226                     masm.or(size, dst, src, b.asLong());
227                     break;
228                 case XOR:
229                     masm.eor(size, dst, src, b.asLong());
230                     break;
231                 case SHL:
232                     masm.shl(size, dst, src, b.asLong());
233                     break;
234                 case LSHR:
235                     masm.lshr(size, dst, src, b.asLong());
236                     break;
237                 case ASHR:
238                     masm.ashr(size, dst, src, b.asLong());
239                     break;
<span class="line-added">240                 case ROR:</span>
<span class="line-added">241                     masm.ror(size, dst, src, (int) b.asLong());</span>
<span class="line-added">242                     break;</span>
243                 default:
244                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + op.name());
245             }
246         }
247     }
248 
249     public static class BinaryOp extends AArch64LIRInstruction {
250         private static final LIRInstructionClass&lt;BinaryOp&gt; TYPE = LIRInstructionClass.create(BinaryOp.class);
251 
252         @Opcode private final AArch64ArithmeticOp op;
253         @Def({REG}) protected AllocatableValue result;
254         @Use({REG}) protected AllocatableValue a;
255         @Use({REG}) protected AllocatableValue b;
256 
257         public BinaryOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue a, AllocatableValue b) {
258             super(TYPE);
259             this.op = op;
260             this.result = result;
261             this.a = a;
262             this.b = b;
</pre>
<hr />
<pre>
300                     masm.smnegl(size, dst, src1, src2);
301                     break;
302                 case DIV:
303                     masm.sdiv(size, dst, src1, src2);
304                     break;
305                 case UDIV:
306                     masm.udiv(size, dst, src1, src2);
307                     break;
308                 case AND:
309                     masm.and(size, dst, src1, src2);
310                     break;
311                 case ANDS:
312                     masm.ands(size, dst, src1, src2);
313                     break;
314                 case OR:
315                     masm.or(size, dst, src1, src2);
316                     break;
317                 case XOR:
318                     masm.eor(size, dst, src1, src2);
319                     break;
<span class="line-added">320                 case BIC:</span>
<span class="line-added">321                     masm.bic(size, dst, src1, src2);</span>
<span class="line-added">322                     break;</span>
<span class="line-added">323                 case ORN:</span>
<span class="line-added">324                     masm.orn(size, dst, src1, src2);</span>
<span class="line-added">325                     break;</span>
<span class="line-added">326                 case EON:</span>
<span class="line-added">327                     masm.eon(size, dst, src1, src2);</span>
<span class="line-added">328                     break;</span>
329                 case SHL:
330                     masm.shl(size, dst, src1, src2);
331                     break;
332                 case LSHR:
333                     masm.lshr(size, dst, src1, src2);
334                     break;
335                 case ASHR:
336                     masm.ashr(size, dst, src1, src2);
337                     break;
<span class="line-added">338                 case RORV:</span>
<span class="line-added">339                     masm.rorv(size, dst, src1, src2);</span>
<span class="line-added">340                     break;</span>
341                 case FADD:
342                     masm.fadd(size, dst, src1, src2);
343                     break;
344                 case FSUB:
345                     masm.fsub(size, dst, src1, src2);
346                     break;
347                 case FMUL:
348                     masm.fmul(size, dst, src1, src2);
349                     break;
350                 case FDIV:
351                     masm.fdiv(size, dst, src1, src2);
352                     break;
353                 case MULVS:
354                     masm.mulvs(size, dst, src1, src2);
355                     break;
356                 default:
357                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + op.name());
358             }
359         }
360     }
</pre>
<hr />
<pre>
395                     masm.urem(size, dst, src1, src2);
396                     break;
397                 case FREM:
398                     masm.frem(size, dst, src1, src2);
399                     break;
400                 default:
401                     throw GraalError.shouldNotReachHere();
402             }
403         }
404     }
405 
406     public static class BinaryShiftOp extends AArch64LIRInstruction {
407         private static final LIRInstructionClass&lt;BinaryShiftOp&gt; TYPE = LIRInstructionClass.create(BinaryShiftOp.class);
408 
409         @Opcode private final AArch64ArithmeticOp op;
410         @Def(REG) protected AllocatableValue result;
411         @Use(REG) protected AllocatableValue src1;
412         @Use(REG) protected AllocatableValue src2;
413         private final AArch64MacroAssembler.ShiftType shiftType;
414         private final int shiftAmt;

415 
416         /**


417          * &lt;code&gt;result = src1 &lt;op&gt; src2 &lt;shiftType&gt; &lt;shiftAmt&gt;&lt;/code&gt;.
418          */
419         public BinaryShiftOp(AArch64ArithmeticOp op, AllocatableValue result, AllocatableValue src1, AllocatableValue src2,
<span class="line-modified">420                         AArch64MacroAssembler.ShiftType shiftType, int shiftAmt) {</span>
421             super(TYPE);

422             this.op = op;
423             this.result = result;
424             this.src1 = src1;
425             this.src2 = src2;
426             this.shiftType = shiftType;
427             this.shiftAmt = shiftAmt;

428         }
429 
430         @Override
431         public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {
432             int size = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;
433             switch (op) {
434                 case ADD:
435                     masm.add(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
436                     break;
437                 case SUB:
438                     masm.sub(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);
439                     break;
440                 case AND:
<span class="line-modified">441                     masm.and(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>




442                     break;
443                 case OR:
<span class="line-modified">444                     masm.or(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>




445                     break;
446                 case XOR:
<span class="line-modified">447                     masm.eor(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-modified">448                     break;</span>
<span class="line-modified">449                 case BIC:</span>
<span class="line-modified">450                     masm.bic(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-modified">451                     break;</span>
<span class="line-added">452                 case ORN:</span>
<span class="line-added">453                     masm.orn(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
<span class="line-added">454                     break;</span>
<span class="line-added">455                 case EON:</span>
<span class="line-added">456                     masm.eon(size, asRegister(result), asRegister(src1), asRegister(src2), shiftType, shiftAmt);</span>
457                     break;
458                 default:
<span class="line-modified">459                     throw GraalError.shouldNotReachHere(&quot;op=&quot; + op.name());</span>
460             }
461         }
462     }
463 
464     public static class ExtendedAddShiftOp extends AArch64LIRInstruction {
465         private static final LIRInstructionClass&lt;ExtendedAddShiftOp&gt; TYPE = LIRInstructionClass.create(ExtendedAddShiftOp.class);
466         @Def(REG) protected AllocatableValue result;
467         @Use(REG) protected AllocatableValue src1;
468         @Use(REG) protected AllocatableValue src2;
469         private final AArch64Assembler.ExtendType extendType;
470         private final int shiftAmt;
471 
472         /**
473          * Computes &lt;code&gt;result = src1 + extendType(src2) &lt;&lt; shiftAmt&lt;/code&gt;.
474          *
475          * @param extendType defines how src2 is extended to the same size as src1.
476          * @param shiftAmt must be in range 0 to 4.
477          */
478         public ExtendedAddShiftOp(AllocatableValue result, AllocatableValue src1, AllocatableValue src2, AArch64Assembler.ExtendType extendType, int shiftAmt) {
479             super(TYPE);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.jtt/src/org/graalvm/compiler/jtt/reflect/Field_set02.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64BitManipulationOp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/word/MetaspacePointer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.word;
 26 
 27 import static org.graalvm.compiler.hotspot.word.HotSpotOperation.HotspotOpcode.FROM_POINTER;
 28 import static org.graalvm.compiler.hotspot.word.HotSpotOperation.HotspotOpcode.IS_NULL;
 29 
 30 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;
 31 import org.graalvm.compiler.word.Word;
 32 import org.graalvm.compiler.word.Word.Opcode;
 33 import org.graalvm.compiler.word.Word.Operation;
 34 import jdk.internal.vm.compiler.word.LocationIdentity;
 35 import jdk.internal.vm.compiler.word.SignedWord;
 36 import jdk.internal.vm.compiler.word.UnsignedWord;
 37 import jdk.internal.vm.compiler.word.WordBase;
 38 
 39 /**
 40  * Marker type for a metaspace pointer.
 41  */
 42 public abstract class MetaspacePointer {
 43 
 44     @HotSpotOperation(opcode = IS_NULL)
 45     public abstract boolean isNull();
 46 
 47     @HotSpotOperation(opcode = FROM_POINTER)
 48     public abstract Word asWord();
 49 
 50     /**
 51      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 52      * bytes.
 53      * &lt;p&gt;
 54      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 55      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 56      * knows that the highest-order bit of the unsigned value is never used).
 57      *
 58      * @param offset the signed offset for the memory access
 59      * @param locationIdentity the identity of the read
 60      * @return the result of the memory access
 61      */
 62     @Operation(opcode = Opcode.READ_POINTER)
 63     public abstract byte readByte(WordBase offset, LocationIdentity locationIdentity);
 64 
 65     /**
 66      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 67      * bytes.
 68      * &lt;p&gt;
 69      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 70      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 71      * knows that the highest-order bit of the unsigned value is never used).
 72      *
 73      * @param offset the signed offset for the memory access
 74      * @param locationIdentity the identity of the read
 75      * @return the result of the memory access
 76      */
 77     @Operation(opcode = Opcode.READ_POINTER)
 78     public abstract char readChar(WordBase offset, LocationIdentity locationIdentity);
 79 
 80     /**
 81      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 82      * bytes.
 83      * &lt;p&gt;
 84      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 85      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 86      * knows that the highest-order bit of the unsigned value is never used).
 87      *
 88      * @param offset the signed offset for the memory access
 89      * @param locationIdentity the identity of the read
 90      * @return the result of the memory access
 91      */
 92     @Operation(opcode = Opcode.READ_POINTER)
 93     public abstract short readShort(WordBase offset, LocationIdentity locationIdentity);
 94 
 95     /**
 96      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 97      * bytes.
 98      * &lt;p&gt;
 99      * The offset is always treated as a {@link SignedWord} value. However, the static type is
100      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
101      * knows that the highest-order bit of the unsigned value is never used).
102      *
103      * @param offset the signed offset for the memory access
104      * @param locationIdentity the identity of the read
105      * @return the result of the memory access
106      */
107     @Operation(opcode = Opcode.READ_POINTER)
108     public abstract int readInt(WordBase offset, LocationIdentity locationIdentity);
109 
110     /**
111      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
112      * bytes.
113      * &lt;p&gt;
114      * The offset is always treated as a {@link SignedWord} value. However, the static type is
115      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
116      * knows that the highest-order bit of the unsigned value is never used).
117      *
118      * @param offset the signed offset for the memory access
119      * @param locationIdentity the identity of the read
120      * @return the result of the memory access
121      */
122     @Operation(opcode = Opcode.READ_POINTER)
123     public abstract long readLong(WordBase offset, LocationIdentity locationIdentity);
124 
125     /**
126      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
127      * bytes.
128      * &lt;p&gt;
129      * The offset is always treated as a {@link SignedWord} value. However, the static type is
130      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
131      * knows that the highest-order bit of the unsigned value is never used).
132      *
133      * @param offset the signed offset for the memory access
134      * @param locationIdentity the identity of the read
135      * @return the result of the memory access
136      */
137     @Operation(opcode = Opcode.READ_POINTER)
138     public abstract float readFloat(WordBase offset, LocationIdentity locationIdentity);
139 
140     /**
141      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
142      * bytes.
143      * &lt;p&gt;
144      * The offset is always treated as a {@link SignedWord} value. However, the static type is
145      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
146      * knows that the highest-order bit of the unsigned value is never used).
147      *
148      * @param offset the signed offset for the memory access
149      * @param locationIdentity the identity of the read
150      * @return the result of the memory access
151      */
152     @Operation(opcode = Opcode.READ_POINTER)
153     public abstract double readDouble(WordBase offset, LocationIdentity locationIdentity);
154 
155     /**
156      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
157      * bytes.
158      * &lt;p&gt;
159      * The offset is always treated as a {@link SignedWord} value. However, the static type is
160      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
161      * knows that the highest-order bit of the unsigned value is never used).
162      *
163      * @param offset the signed offset for the memory access
164      * @param locationIdentity the identity of the read
165      * @return the result of the memory access
166      */
167     @Operation(opcode = Opcode.READ_POINTER)
168     public abstract Word readWord(WordBase offset, LocationIdentity locationIdentity);
169 
170     /**
171      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
172      * bytes.
173      * &lt;p&gt;
174      * The offset is always treated as a {@link SignedWord} value. However, the static type is
175      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
176      * knows that the highest-order bit of the unsigned value is never used).
177      *
178      * @param offset the signed offset for the memory access
179      * @param locationIdentity the identity of the read
180      * @return the result of the memory access
181      */
182     @Operation(opcode = Opcode.READ_POINTER)
183     public abstract Object readObject(WordBase offset, LocationIdentity locationIdentity);
184 
185     /**
186      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
187      * bytes.
188      *
189      * @param offset the signed offset for the memory access
190      * @param locationIdentity the identity of the read
191      * @return the result of the memory access
192      */
193     @Operation(opcode = Opcode.READ_POINTER)
194     public abstract byte readByte(int offset, LocationIdentity locationIdentity);
195 
196     /**
197      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
198      * bytes.
199      *
200      * @param offset the signed offset for the memory access
201      * @param locationIdentity the identity of the read
202      * @return the result of the memory access
203      */
204     @Operation(opcode = Opcode.READ_POINTER)
205     public abstract char readChar(int offset, LocationIdentity locationIdentity);
206 
207     /**
208      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
209      * bytes.
210      *
211      * @param offset the signed offset for the memory access
212      * @param locationIdentity the identity of the read
213      * @return the result of the memory access
214      */
215     @Operation(opcode = Opcode.READ_POINTER)
216     public abstract short readShort(int offset, LocationIdentity locationIdentity);
217 
218     /**
219      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
220      * bytes.
221      *
222      * @param offset the signed offset for the memory access
223      * @param locationIdentity the identity of the read
224      * @return the result of the memory access
225      */
226     @Operation(opcode = Opcode.READ_POINTER)
227     public abstract int readInt(int offset, LocationIdentity locationIdentity);
228 
229     /**
230      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
231      * bytes.
232      *
233      * @param offset the signed offset for the memory access
234      * @param locationIdentity the identity of the read
235      * @return the result of the memory access
236      */
237     @Operation(opcode = Opcode.READ_POINTER)
238     public abstract long readLong(int offset, LocationIdentity locationIdentity);
239 
240     /**
241      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
242      * bytes.
243      *
244      * @param offset the signed offset for the memory access
245      * @param locationIdentity the identity of the read
246      * @return the result of the memory access
247      */
248     @Operation(opcode = Opcode.READ_POINTER)
249     public abstract float readFloat(int offset, LocationIdentity locationIdentity);
250 
251     /**
252      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
253      * bytes.
254      *
255      * @param offset the signed offset for the memory access
256      * @param locationIdentity the identity of the read
257      * @return the result of the memory access
258      */
259     @Operation(opcode = Opcode.READ_POINTER)
260     public abstract double readDouble(int offset, LocationIdentity locationIdentity);
261 
262     /**
263      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
264      * bytes.
265      *
266      * @param offset the signed offset for the memory access
267      * @param locationIdentity the identity of the read
268      * @return the result of the memory access
269      */
270     @Operation(opcode = Opcode.READ_POINTER)
271     public abstract Word readWord(int offset, LocationIdentity locationIdentity);
272 
273     /**
274      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
275      * bytes.
276      *
277      * @param offset the signed offset for the memory access
278      * @param locationIdentity the identity of the read
279      * @return the result of the memory access
280      */
281     @Operation(opcode = Opcode.READ_POINTER)
282     public abstract Object readObject(int offset, LocationIdentity locationIdentity);
283 
284     /**
285      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
286      * bytes.
287      * &lt;p&gt;
288      * The offset is always treated as a {@link SignedWord} value. However, the static type is
289      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
290      * knows that the highest-order bit of the unsigned value is never used).
291      *
292      * @param offset the signed offset for the memory access
293      * @param locationIdentity the identity of the write
294      * @param val the value to be written to memory
295      */
296     @Operation(opcode = Opcode.WRITE_POINTER)
297     public abstract void writeByte(WordBase offset, byte val, LocationIdentity locationIdentity);
298 
299     /**
300      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
301      * bytes.
302      * &lt;p&gt;
303      * The offset is always treated as a {@link SignedWord} value. However, the static type is
304      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
305      * knows that the highest-order bit of the unsigned value is never used).
306      *
307      * @param offset the signed offset for the memory access
308      * @param locationIdentity the identity of the write
309      * @param val the value to be written to memory
310      */
311     @Operation(opcode = Opcode.WRITE_POINTER)
312     public abstract void writeChar(WordBase offset, char val, LocationIdentity locationIdentity);
313 
314     /**
315      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
316      * bytes.
317      * &lt;p&gt;
318      * The offset is always treated as a {@link SignedWord} value. However, the static type is
319      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
320      * knows that the highest-order bit of the unsigned value is never used).
321      *
322      * @param offset the signed offset for the memory access
323      * @param locationIdentity the identity of the write
324      * @param val the value to be written to memory
325      */
326     @Operation(opcode = Opcode.WRITE_POINTER)
327     public abstract void writeShort(WordBase offset, short val, LocationIdentity locationIdentity);
328 
329     /**
330      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
331      * bytes.
332      * &lt;p&gt;
333      * The offset is always treated as a {@link SignedWord} value. However, the static type is
334      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
335      * knows that the highest-order bit of the unsigned value is never used).
336      *
337      * @param offset the signed offset for the memory access
338      * @param locationIdentity the identity of the write
339      * @param val the value to be written to memory
340      */
341     @Operation(opcode = Opcode.WRITE_POINTER)
342     public abstract void writeInt(WordBase offset, int val, LocationIdentity locationIdentity);
343 
344     /**
345      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
346      * bytes.
347      * &lt;p&gt;
348      * The offset is always treated as a {@link SignedWord} value. However, the static type is
349      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
350      * knows that the highest-order bit of the unsigned value is never used).
351      *
352      * @param offset the signed offset for the memory access
353      * @param locationIdentity the identity of the write
354      * @param val the value to be written to memory
355      */
356     @Operation(opcode = Opcode.WRITE_POINTER)
357     public abstract void writeLong(WordBase offset, long val, LocationIdentity locationIdentity);
358 
359     /**
360      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
361      * bytes.
362      * &lt;p&gt;
363      * The offset is always treated as a {@link SignedWord} value. However, the static type is
364      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
365      * knows that the highest-order bit of the unsigned value is never used).
366      *
367      * @param offset the signed offset for the memory access
368      * @param locationIdentity the identity of the write
369      * @param val the value to be written to memory
370      */
371     @Operation(opcode = Opcode.WRITE_POINTER)
372     public abstract void writeFloat(WordBase offset, float val, LocationIdentity locationIdentity);
373 
374     /**
375      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
376      * bytes.
377      * &lt;p&gt;
378      * The offset is always treated as a {@link SignedWord} value. However, the static type is
379      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
380      * knows that the highest-order bit of the unsigned value is never used).
381      *
382      * @param offset the signed offset for the memory access
383      * @param locationIdentity the identity of the write
384      * @param val the value to be written to memory
385      */
386     @Operation(opcode = Opcode.WRITE_POINTER)
387     public abstract void writeDouble(WordBase offset, double val, LocationIdentity locationIdentity);
388 
389     /**
390      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
391      * bytes.
392      * &lt;p&gt;
393      * The offset is always treated as a {@link SignedWord} value. However, the static type is
394      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
395      * knows that the highest-order bit of the unsigned value is never used).
396      *
397      * @param offset the signed offset for the memory access
398      * @param locationIdentity the identity of the write
399      * @param val the value to be written to memory
400      */
401     @Operation(opcode = Opcode.WRITE_POINTER)
402     public abstract void writeWord(WordBase offset, WordBase val, LocationIdentity locationIdentity);
403 
404     /**
405      * Initializes the memory at address {@code (this + offset)}. Both the base address and offset
406      * are in bytes. The memory must be uninitialized or zero prior to this operation.
407      * &lt;p&gt;
408      * The offset is always treated as a {@link SignedWord} value. However, the static type is
409      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
410      * knows that the highest-order bit of the unsigned value is never used).
411      *
412      * @param offset the signed offset for the memory access
413      * @param locationIdentity the identity of the write
414      * @param val the value to be written to memory
415      */
416     @Operation(opcode = Opcode.INITIALIZE)
417     public abstract void initializeLong(WordBase offset, long val, LocationIdentity locationIdentity);
418 
419     /**
420      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
421      * bytes.
422      * &lt;p&gt;
423      * The offset is always treated as a {@link SignedWord} value. However, the static type is
424      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
425      * knows that the highest-order bit of the unsigned value is never used).
426      *
427      * @param offset the signed offset for the memory access
428      * @param locationIdentity the identity of the write
429      * @param val the value to be written to memory
430      */
431     @Operation(opcode = Opcode.WRITE_POINTER)
432     public abstract void writeObject(WordBase offset, Object val, LocationIdentity locationIdentity);
433 
434     /**
435      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
436      * bytes.
437      *
438      * @param offset the signed offset for the memory access
439      * @param locationIdentity the identity of the write
440      * @param val the value to be written to memory
441      */
442     @Operation(opcode = Opcode.WRITE_POINTER)
443     public abstract void writeByte(int offset, byte val, LocationIdentity locationIdentity);
444 
445     /**
446      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
447      * bytes.
448      *
449      * @param offset the signed offset for the memory access
450      * @param locationIdentity the identity of the write
451      * @param val the value to be written to memory
452      */
453     @Operation(opcode = Opcode.WRITE_POINTER)
454     public abstract void writeChar(int offset, char val, LocationIdentity locationIdentity);
455 
456     /**
457      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
458      * bytes.
459      *
460      * @param offset the signed offset for the memory access
461      * @param locationIdentity the identity of the write
462      * @param val the value to be written to memory
463      */
464     @Operation(opcode = Opcode.WRITE_POINTER)
465     public abstract void writeShort(int offset, short val, LocationIdentity locationIdentity);
466 
467     /**
468      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
469      * bytes.
470      *
471      * @param offset the signed offset for the memory access
472      * @param locationIdentity the identity of the write
473      * @param val the value to be written to memory
474      */
475     @Operation(opcode = Opcode.WRITE_POINTER)
476     public abstract void writeInt(int offset, int val, LocationIdentity locationIdentity);
477 
478     /**
479      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
480      * bytes.
481      *
482      * @param offset the signed offset for the memory access
483      * @param locationIdentity the identity of the write
484      * @param val the value to be written to memory
485      */
486     @Operation(opcode = Opcode.WRITE_POINTER)
487     public abstract void writeLong(int offset, long val, LocationIdentity locationIdentity);
488 
489     /**
490      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
491      * bytes.
492      *
493      * @param offset the signed offset for the memory access
494      * @param locationIdentity the identity of the write
495      * @param val the value to be written to memory
496      */
497     @Operation(opcode = Opcode.WRITE_POINTER)
498     public abstract void writeFloat(int offset, float val, LocationIdentity locationIdentity);
499 
500     /**
501      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
502      * bytes.
503      *
504      * @param offset the signed offset for the memory access
505      * @param locationIdentity the identity of the write
506      * @param val the value to be written to memory
507      */
508     @Operation(opcode = Opcode.WRITE_POINTER)
509     public abstract void writeDouble(int offset, double val, LocationIdentity locationIdentity);
510 
511     /**
512      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
513      * bytes.
514      *
515      * @param offset the signed offset for the memory access
516      * @param locationIdentity the identity of the write
517      * @param val the value to be written to memory
518      */
519     @Operation(opcode = Opcode.WRITE_POINTER)
520     public abstract void writeWord(int offset, WordBase val, LocationIdentity locationIdentity);
521 
522     /**
523      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
524      * bytes.
525      *
526      * @param offset the signed offset for the memory access
527      * @param locationIdentity the identity of the write
528      * @param val the value to be written to memory
529      */
530     @Operation(opcode = Opcode.WRITE_POINTER)
531     public abstract void writeObject(int offset, Object val, LocationIdentity locationIdentity);
532 
533     /**
534      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
535      * bytes.
536      * &lt;p&gt;
537      * The offset is always treated as a {@link SignedWord} value. However, the static type is
538      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
539      * knows that the highest-order bit of the unsigned value is never used).
540      *
541      * @param offset the signed offset for the memory access
542      * @return the result of the memory access
543      */
544     @Operation(opcode = Opcode.READ_POINTER)
545     public abstract byte readByte(WordBase offset);
546 
547     /**
548      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
549      * bytes.
550      * &lt;p&gt;
551      * The offset is always treated as a {@link SignedWord} value. However, the static type is
552      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
553      * knows that the highest-order bit of the unsigned value is never used).
554      *
555      * @param offset the signed offset for the memory access
556      * @return the result of the memory access
557      */
558     @Operation(opcode = Opcode.READ_POINTER)
559     public abstract char readChar(WordBase offset);
560 
561     /**
562      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
563      * bytes.
564      * &lt;p&gt;
565      * The offset is always treated as a {@link SignedWord} value. However, the static type is
566      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
567      * knows that the highest-order bit of the unsigned value is never used).
568      *
569      * @param offset the signed offset for the memory access
570      * @return the result of the memory access
571      */
572     @Operation(opcode = Opcode.READ_POINTER)
573     public abstract short readShort(WordBase offset);
574 
575     /**
576      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
577      * bytes.
578      * &lt;p&gt;
579      * The offset is always treated as a {@link SignedWord} value. However, the static type is
580      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
581      * knows that the highest-order bit of the unsigned value is never used).
582      *
583      * @param offset the signed offset for the memory access
584      * @return the result of the memory access
585      */
586     @Operation(opcode = Opcode.READ_POINTER)
587     public abstract int readInt(WordBase offset);
588 
589     /**
590      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
591      * bytes.
592      * &lt;p&gt;
593      * The offset is always treated as a {@link SignedWord} value. However, the static type is
594      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
595      * knows that the highest-order bit of the unsigned value is never used).
596      *
597      * @param offset the signed offset for the memory access
598      * @return the result of the memory access
599      */
600     @Operation(opcode = Opcode.READ_POINTER)
601     public abstract long readLong(WordBase offset);
602 
603     /**
604      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
605      * bytes.
606      * &lt;p&gt;
607      * The offset is always treated as a {@link SignedWord} value. However, the static type is
608      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
609      * knows that the highest-order bit of the unsigned value is never used).
610      *
611      * @param offset the signed offset for the memory access
612      * @return the result of the memory access
613      */
614     @Operation(opcode = Opcode.READ_POINTER)
615     public abstract float readFloat(WordBase offset);
616 
617     /**
618      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
619      * bytes.
620      * &lt;p&gt;
621      * The offset is always treated as a {@link SignedWord} value. However, the static type is
622      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
623      * knows that the highest-order bit of the unsigned value is never used).
624      *
625      * @param offset the signed offset for the memory access
626      * @return the result of the memory access
627      */
628     @Operation(opcode = Opcode.READ_POINTER)
629     public abstract double readDouble(WordBase offset);
630 
631     /**
632      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
633      * bytes.
634      * &lt;p&gt;
635      * The offset is always treated as a {@link SignedWord} value. However, the static type is
636      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
637      * knows that the highest-order bit of the unsigned value is never used).
638      *
639      * @param offset the signed offset for the memory access
640      * @return the result of the memory access
641      */
642     @Operation(opcode = Opcode.READ_POINTER)
643     public abstract Word readWord(WordBase offset);
644 
645     /**
646      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
647      * bytes.
648      * &lt;p&gt;
649      * The offset is always treated as a {@link SignedWord} value. However, the static type is
650      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
651      * knows that the highest-order bit of the unsigned value is never used).
652      *
653      * @param offset the signed offset for the memory access
654      * @return the result of the memory access
655      */
656     @Operation(opcode = Opcode.READ_POINTER)
657     public abstract Object readObject(WordBase offset);
658 
659     /**
660      * Reads the memory at address {@code (this + offset)}. This access will decompress the oop if
661      * the VM uses compressed oops, and it can be parameterized to allow read barriers (G1 referent
662      * field).
663      * &lt;p&gt;
664      * The offset is always treated as a {@link SignedWord} value. However, the static type is
665      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
666      * knows that the highest-order bit of the unsigned value is never used).
667      *
668      * @param offset the signed offset for the memory access
669      * @param barrierType the type of the read barrier to be added
670      * @return the result of the memory access
671      */
672     @Operation(opcode = Opcode.READ_POINTER)
673     public abstract Object readObject(WordBase offset, BarrierType barrierType);
674 
675     /**
676      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
677      * bytes.
678      *
679      * @param offset the signed offset for the memory access
680      * @return the result of the memory access
681      */
682     @Operation(opcode = Opcode.READ_POINTER)
683     public abstract byte readByte(int offset);
684 
685     /**
686      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
687      * bytes.
688      *
689      * @param offset the signed offset for the memory access
690      * @return the result of the memory access
691      */
692     @Operation(opcode = Opcode.READ_POINTER)
693     public abstract char readChar(int offset);
694 
695     /**
696      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
697      * bytes.
698      *
699      * @param offset the signed offset for the memory access
700      * @return the result of the memory access
701      */
702     @Operation(opcode = Opcode.READ_POINTER)
703     public abstract short readShort(int offset);
704 
705     /**
706      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
707      * bytes.
708      *
709      * @param offset the signed offset for the memory access
710      * @return the result of the memory access
711      */
712     @Operation(opcode = Opcode.READ_POINTER)
713     public abstract int readInt(int offset);
714 
715     /**
716      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
717      * bytes.
718      *
719      * @param offset the signed offset for the memory access
720      * @return the result of the memory access
721      */
722     @Operation(opcode = Opcode.READ_POINTER)
723     public abstract long readLong(int offset);
724 
725     /**
726      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
727      * bytes.
728      *
729      * @param offset the signed offset for the memory access
730      * @return the result of the memory access
731      */
732     @Operation(opcode = Opcode.READ_POINTER)
733     public abstract float readFloat(int offset);
734 
735     /**
736      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
737      * bytes.
738      *
739      * @param offset the signed offset for the memory access
740      * @return the result of the memory access
741      */
742     @Operation(opcode = Opcode.READ_POINTER)
743     public abstract double readDouble(int offset);
744 
745     /**
746      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
747      * bytes.
748      *
749      * @param offset the signed offset for the memory access
750      * @return the result of the memory access
751      */
752     @Operation(opcode = Opcode.READ_POINTER)
753     public abstract Word readWord(int offset);
754 
755     /**
756      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
757      * bytes.
758      *
759      * @param offset the signed offset for the memory access
760      * @return the result of the memory access
761      */
762     @Operation(opcode = Opcode.READ_POINTER)
763     public abstract Object readObject(int offset);
764 
765     /**
766      * Reads the memory at address {@code (this + offset)}. This access will decompress the oop if
767      * the VM uses compressed oops, and it can be parameterized to allow read barriers (G1 referent
768      * field).
769      *
770      * @param offset the signed offset for the memory access
771      * @param barrierType the type of the read barrier to be added
772      * @return the result of the memory access
773      */
774     @Operation(opcode = Opcode.READ_POINTER)
775     public abstract Object readObject(int offset, BarrierType barrierType);
776 
777     /**
778      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
779      * bytes.
780      * &lt;p&gt;
781      * The offset is always treated as a {@link SignedWord} value. However, the static type is
782      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
783      * knows that the highest-order bit of the unsigned value is never used).
784      *
785      * @param offset the signed offset for the memory access
786      * @param val the value to be written to memory
787      */
788     @Operation(opcode = Opcode.WRITE_POINTER)
789     public abstract void writeByte(WordBase offset, byte val);
790 
791     /**
792      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
793      * bytes.
794      * &lt;p&gt;
795      * The offset is always treated as a {@link SignedWord} value. However, the static type is
796      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
797      * knows that the highest-order bit of the unsigned value is never used).
798      *
799      * @param offset the signed offset for the memory access
800      * @param val the value to be written to memory
801      */
802     @Operation(opcode = Opcode.WRITE_POINTER)
803     public abstract void writeChar(WordBase offset, char val);
804 
805     /**
806      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
807      * bytes.
808      * &lt;p&gt;
809      * The offset is always treated as a {@link SignedWord} value. However, the static type is
810      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
811      * knows that the highest-order bit of the unsigned value is never used).
812      *
813      * @param offset the signed offset for the memory access
814      * @param val the value to be written to memory
815      */
816     @Operation(opcode = Opcode.WRITE_POINTER)
817     public abstract void writeShort(WordBase offset, short val);
818 
819     /**
820      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
821      * bytes.
822      * &lt;p&gt;
823      * The offset is always treated as a {@link SignedWord} value. However, the static type is
824      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
825      * knows that the highest-order bit of the unsigned value is never used).
826      *
827      * @param offset the signed offset for the memory access
828      * @param val the value to be written to memory
829      */
830     @Operation(opcode = Opcode.WRITE_POINTER)
831     public abstract void writeInt(WordBase offset, int val);
832 
833     /**
834      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
835      * bytes.
836      * &lt;p&gt;
837      * The offset is always treated as a {@link SignedWord} value. However, the static type is
838      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
839      * knows that the highest-order bit of the unsigned value is never used).
840      *
841      * @param offset the signed offset for the memory access
842      * @param val the value to be written to memory
843      */
844     @Operation(opcode = Opcode.WRITE_POINTER)
845     public abstract void writeLong(WordBase offset, long val);
846 
847     /**
848      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
849      * bytes.
850      * &lt;p&gt;
851      * The offset is always treated as a {@link SignedWord} value. However, the static type is
852      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
853      * knows that the highest-order bit of the unsigned value is never used).
854      *
855      * @param offset the signed offset for the memory access
856      * @param val the value to be written to memory
857      */
858     @Operation(opcode = Opcode.WRITE_POINTER)
859     public abstract void writeFloat(WordBase offset, float val);
860 
861     /**
862      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
863      * bytes.
864      * &lt;p&gt;
865      * The offset is always treated as a {@link SignedWord} value. However, the static type is
866      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
867      * knows that the highest-order bit of the unsigned value is never used).
868      *
869      * @param offset the signed offset for the memory access
870      * @param val the value to be written to memory
871      */
872     @Operation(opcode = Opcode.WRITE_POINTER)
873     public abstract void writeDouble(WordBase offset, double val);
874 
875     /**
876      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
877      * bytes.
878      * &lt;p&gt;
879      * The offset is always treated as a {@link SignedWord} value. However, the static type is
880      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
881      * knows that the highest-order bit of the unsigned value is never used).
882      *
883      * @param offset the signed offset for the memory access
884      * @param val the value to be written to memory
885      */
886     @Operation(opcode = Opcode.WRITE_POINTER)
887     public abstract void writeWord(WordBase offset, WordBase val);
888 
889     /**
890      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
891      * bytes.
892      * &lt;p&gt;
893      * The offset is always treated as a {@link SignedWord} value. However, the static type is
894      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
895      * knows that the highest-order bit of the unsigned value is never used).
896      *
897      * @param offset the signed offset for the memory access
898      * @param val the value to be written to memory
899      */
900     @Operation(opcode = Opcode.WRITE_POINTER)
901     public abstract void writeObject(WordBase offset, Object val);
902 
903     /**
904      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
905      * bytes.
906      *
907      * @param offset the signed offset for the memory access
908      * @param val the value to be written to memory
909      */
910     @Operation(opcode = Opcode.WRITE_POINTER)
911     public abstract void writeByte(int offset, byte val);
912 
913     /**
914      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
915      * bytes.
916      *
917      * @param offset the signed offset for the memory access
918      * @param val the value to be written to memory
919      */
920     @Operation(opcode = Opcode.WRITE_POINTER)
921     public abstract void writeChar(int offset, char val);
922 
923     /**
924      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
925      * bytes.
926      *
927      * @param offset the signed offset for the memory access
928      * @param val the value to be written to memory
929      */
930     @Operation(opcode = Opcode.WRITE_POINTER)
931     public abstract void writeShort(int offset, short val);
932 
933     /**
934      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
935      * bytes.
936      *
937      * @param offset the signed offset for the memory access
938      * @param val the value to be written to memory
939      */
940     @Operation(opcode = Opcode.WRITE_POINTER)
941     public abstract void writeInt(int offset, int val);
942 
943     /**
944      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
945      * bytes.
946      *
947      * @param offset the signed offset for the memory access
948      * @param val the value to be written to memory
949      */
950     @Operation(opcode = Opcode.WRITE_POINTER)
951     public abstract void writeLong(int offset, long val);
952 
953     /**
954      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
955      * bytes.
956      *
957      * @param offset the signed offset for the memory access
958      * @param val the value to be written to memory
959      */
960     @Operation(opcode = Opcode.WRITE_POINTER)
961     public abstract void writeFloat(int offset, float val);
962 
963     /**
964      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
965      * bytes.
966      *
967      * @param offset the signed offset for the memory access
968      * @param val the value to be written to memory
969      */
970     @Operation(opcode = Opcode.WRITE_POINTER)
971     public abstract void writeDouble(int offset, double val);
972 
973     /**
974      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
975      * bytes.
976      *
977      * @param offset the signed offset for the memory access
978      * @param val the value to be written to memory
979      */
980     @Operation(opcode = Opcode.WRITE_POINTER)
981     public abstract void writeWord(int offset, WordBase val);
982 
983     /**
984      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
985      * bytes.
986      *
987      * @param offset the signed offset for the memory access
988      * @param val the value to be written to memory
989      */
990     @Operation(opcode = Opcode.WRITE_POINTER)
991     public abstract void writeObject(int offset, Object val);
992 }
    </pre>
  </body>
</html>
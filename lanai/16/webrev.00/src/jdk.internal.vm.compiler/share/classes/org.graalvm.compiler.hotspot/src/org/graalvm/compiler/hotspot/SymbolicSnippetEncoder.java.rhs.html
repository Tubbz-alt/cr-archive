<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot;
  26 
  27 import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  28 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  30 import static org.graalvm.compiler.core.common.GraalOptions.UseEncodedGraphs;
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
  32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
  33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collections;
<a name="2" id="anc2"></a>
  38 import java.util.HashSet;
  39 import java.util.List;
<a name="3" id="anc3"></a>
  40 import java.util.Objects;
  41 import java.util.Set;
<a name="4" id="anc4"></a>
  42 
<a name="5" id="anc5"></a><span class="line-added">  43 import jdk.internal.vm.compiler.collections.EconomicMap;</span>
<span class="line-added">  44 import jdk.internal.vm.compiler.collections.EconomicSet;</span>
<span class="line-added">  45 import jdk.internal.vm.compiler.collections.MapCursor;</span>
<span class="line-added">  46 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;</span>
  47 import org.graalvm.compiler.api.replacements.Fold;
  48 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  49 import org.graalvm.compiler.api.replacements.Snippet;
  50 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  51 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  52 import org.graalvm.compiler.api.runtime.GraalRuntime;
  53 import org.graalvm.compiler.bytecode.BytecodeProvider;
  54 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  55 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  56 import org.graalvm.compiler.core.common.type.Stamp;
  57 import org.graalvm.compiler.core.common.type.StampPair;
  58 import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  59 import org.graalvm.compiler.debug.DebugContext;
  60 import org.graalvm.compiler.debug.GraalError;
  61 import org.graalvm.compiler.graph.Node;
  62 import org.graalvm.compiler.graph.NodeClass;
  63 import org.graalvm.compiler.graph.NodeMap;
  64 import org.graalvm.compiler.graph.NodeSourcePosition;
  65 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
  66 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  67 import org.graalvm.compiler.java.BytecodeParser;
  68 import org.graalvm.compiler.java.GraphBuilderPhase;
  69 import org.graalvm.compiler.nodeinfo.Verbosity;
  70 import org.graalvm.compiler.nodes.CallTargetNode;
  71 import org.graalvm.compiler.nodes.Cancellable;
  72 import org.graalvm.compiler.nodes.ConstantNode;
  73 import org.graalvm.compiler.nodes.EncodedGraph;
  74 import org.graalvm.compiler.nodes.FrameState;
  75 import org.graalvm.compiler.nodes.FullInfopointNode;
  76 import org.graalvm.compiler.nodes.GraphEncoder;
  77 import org.graalvm.compiler.nodes.ParameterNode;
  78 import org.graalvm.compiler.nodes.ProxyNode;
  79 import org.graalvm.compiler.nodes.StructuredGraph;
  80 import org.graalvm.compiler.nodes.ValueNode;
  81 import org.graalvm.compiler.nodes.cfg.Block;
  82 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
  83 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  84 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  85 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
  86 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  88 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  89 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  90 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
  91 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  92 import org.graalvm.compiler.nodes.java.AccessFieldNode;
  93 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  94 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  95 import org.graalvm.compiler.options.OptionValues;
  96 import org.graalvm.compiler.phases.OptimisticOptimizations;
  97 import org.graalvm.compiler.phases.schedule.SchedulePhase;
  98 import org.graalvm.compiler.phases.util.Providers;
  99 import org.graalvm.compiler.replacements.ConstantBindingParameterPlugin;
 100 import org.graalvm.compiler.replacements.PEGraphDecoder;
 101 import org.graalvm.compiler.replacements.ReplacementsImpl;
 102 import org.graalvm.compiler.replacements.SnippetCounter;
 103 import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
 104 
 105 import jdk.vm.ci.code.TargetDescription;
 106 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 107 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
 108 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 109 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 110 import jdk.vm.ci.hotspot.HotSpotSignature;
 111 import jdk.vm.ci.meta.Constant;
 112 import jdk.vm.ci.meta.ConstantReflectionProvider;
 113 import jdk.vm.ci.meta.JavaConstant;
 114 import jdk.vm.ci.meta.JavaKind;
 115 import jdk.vm.ci.meta.MemoryAccessProvider;
 116 import jdk.vm.ci.meta.MethodHandleAccessProvider;
 117 import jdk.vm.ci.meta.ResolvedJavaField;
 118 import jdk.vm.ci.meta.ResolvedJavaMethod;
 119 import jdk.vm.ci.meta.ResolvedJavaType;
 120 import jdk.vm.ci.meta.UnresolvedJavaField;
 121 import jdk.vm.ci.meta.UnresolvedJavaMethod;
 122 import jdk.vm.ci.meta.UnresolvedJavaType;
 123 
 124 /**
 125  * This class performs graph encoding using {@link GraphEncoder} but also converts JVMCI type and
 126  * method references into a symbolic form that can be resolved at graph decode time using
 127  * {@link SymbolicJVMCIReference}.
 128  */
 129 public class SymbolicSnippetEncoder {
 130 
 131     /**
 132      * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
 133      * substitutions for graph encoding.
 134      */
 135     private final HotSpotSnippetReplacementsImpl snippetReplacements;
 136 
 137     /**
 138      * The set of all snippet methods that have been encoded.
 139      */
 140     private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
 141 
 142     /**
 143      * A mapping from the method substitution method to the original method name. The string key and
 144      * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
 145      */
<a name="6" id="anc6"></a><span class="line-modified"> 146     private final EconomicMap&lt;String, String&gt; originalMethods = EconomicMap.create();</span>
 147 
 148     private final HotSpotReplacementsImpl originalReplacements;
 149 
 150     /**
 151      * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
 152      * encoding.
 153      */
 154     private int encodedGraphs = 0;
 155 
 156     /**
 157      * All the graphs parsed so far.
 158      */
<a name="7" id="anc7"></a><span class="line-modified"> 159     private EconomicMap&lt;String, StructuredGraph&gt; preparedSnippetGraphs = EconomicMap.create();</span>
 160 
<a name="8" id="anc8"></a><span class="line-modified"> 161     private EconomicSet&lt;MethodSubstitutionPlugin&gt; knownPlugins = EconomicSet.create();</span>
 162 
<a name="9" id="anc9"></a><span class="line-modified"> 163     private EconomicSet&lt;InvocationPlugin&gt; conditionalPlugins = EconomicSet.create();</span>
 164 
 165     private int preparedPlugins = 0;
 166 
 167     /**
 168      * The invocation plugins which were delayed during graph preparation.
 169      */
 170     private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
 171 
 172     void addDelayedInvocationPluginMethod(ResolvedJavaMethod method) {
 173         delayedInvocationPluginMethods.add(method);
 174     }
 175 
 176     Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
 177         return snippetMethods;
 178     }
 179 
 180     protected class SnippetInlineInvokePlugin implements InlineInvokePlugin {
 181 
 182         @Override
 183         public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
 184             if (method.getAnnotation(Fold.class) != null) {
 185                 delayedInvocationPluginMethods.add(method);
 186                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 187             }
 188 
 189             if (snippetReplacements.getIntrinsifyingPlugin(method) != null) {
 190                 delayedInvocationPluginMethods.add(method);
 191                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 192             }
 193 
 194             // Force inlining when parsing replacements
 195             return createIntrinsicInlineInfo(method, snippetReplacements.getDefaultReplacementBytecodeProvider());
 196         }
 197 
 198         @Override
 199         public void notifyAfterInline(ResolvedJavaMethod methodToInline) {
 200             assert methodToInline.getAnnotation(Fold.class) == null : methodToInline;
 201         }
 202     }
 203 
 204     public static class SnippetInvocationPlugins extends InvocationPlugins {
 205 
 206         SnippetInvocationPlugins(InvocationPlugins invocationPlugins) {
 207             super(invocationPlugins);
 208         }
 209 
 210         @Override
 211         public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
 212             if (method.getAnnotation(Fold.class) != null) {
 213                 return null;
 214             }
 215             return super.lookupInvocation(method);
 216         }
 217     }
 218 
 219     /**
 220      * This plugin disables the snippet counter machinery.
 221      */
 222     private class SnippetCounterPlugin implements NodePlugin {
 223         String snippetCounterName = &#39;L&#39; + SnippetCounter.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 224         String snippetIntegerHistogramName = &#39;L&#39; + SnippetIntegerHistogram.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 225 
 226         @Override
 227         public boolean handleLoadField(GraphBuilderContext b, ValueNode object, ResolvedJavaField field) {
 228             if (field.getName().equals(&quot;group&quot;) &amp;&amp; field.getDeclaringClass().getName().equals(snippetCounterName)) {
 229                 b.addPush(JavaKind.Object, ConstantNode.forConstant(JavaConstant.NULL_POINTER, b.getMetaAccess()));
 230                 return true;
 231             }
 232             if (field.getType().getName().equals(snippetCounterName)) {
 233                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetCounter.DISABLED_COUNTER), b.getMetaAccess()));
 234                 return true;
 235             }
 236 
 237             if (field.getType().getName().equals(snippetIntegerHistogramName)) {
 238                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetIntegerHistogram.DISABLED_COUNTER), b.getMetaAccess()));
 239                 return true;
 240             }
 241             return false;
 242         }
 243     }
 244 
 245     /**
 246      * Generate a String name for a method including all type information. Used as a symbolic key
 247      * for lookup.
 248      */
 249     private static String methodKey(ResolvedJavaMethod method) {
 250         return method.format(&quot;%H.%n(%P)&quot;);
 251     }
 252 
 253     SymbolicSnippetEncoder(HotSpotReplacementsImpl replacements) {
 254         this.originalReplacements = replacements;
 255         GraphBuilderConfiguration.Plugins plugins = replacements.getGraphBuilderPlugins();
 256         SnippetInvocationPlugins invocationPlugins = new SnippetInvocationPlugins(plugins.getInvocationPlugins());
 257         GraphBuilderConfiguration.Plugins copy = new GraphBuilderConfiguration.Plugins(plugins, invocationPlugins);
 258         copy.clearInlineInvokePlugins();
 259         copy.appendInlineInvokePlugin(new SnippetInlineInvokePlugin());
 260         copy.appendNodePlugin(new SnippetCounterPlugin());
 261         HotSpotProviders providers = (HotSpotProviders) replacements.getProviders().copyWith(new HotSpotSubstrateConstantReflectionProvider(replacements.getProviders().getConstantReflection()));
 262         this.snippetReplacements = new HotSpotSnippetReplacementsImpl(replacements, providers.copyWith(copy));
 263         this.snippetReplacements.setGraphBuilderPlugins(copy);
 264     }
 265 
 266     synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {
 267         knownPlugins.add(plugin);
 268     }
 269 
 270     void registerConditionalPlugin(InvocationPlugin plugin) {
 271         conditionalPlugins.add(plugin);
 272     }
 273 
 274     synchronized void checkRegistered(MethodSubstitutionPlugin plugin) {
 275         if (!knownPlugins.contains(plugin)) {
 276             throw new GraalError(&quot;missing plugin should have been registered during construction&quot;);
 277         }
 278     }
 279 
 280     /**
 281      * Compiles the snippet and stores the graph.
 282      */
 283     private synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context, OptionValues options) {
 284         ResolvedJavaMethod method = plugin.getSubstitute(snippetReplacements.getProviders().getMetaAccess());
 285         assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
 286         String originalMethodString = plugin.originalMethodAsString();
 287         StructuredGraph subst = buildGraph(method, original, originalMethodString, null, true, false, context, options);
 288         snippetMethods.add(method);
 289         originalMethods.put(methodKey(method), originalMethodString);
 290         preparedSnippetGraphs.put(plugin.toString() + context, subst);
 291     }
 292 
<a name="10" id="anc10"></a><span class="line-modified"> 293     public static class EncodedSnippets {</span>
<span class="line-modified"> 294         private final byte[] snippetEncoding;</span>
<span class="line-modified"> 295         private final Object[] snippetObjects;</span>
<span class="line-modified"> 296         private final NodeClass&lt;?&gt;[] snippetNodeClasses;</span>
<span class="line-modified"> 297         private final UnmodifiableEconomicMap&lt;String, Integer&gt; snippetStartOffsets;</span>
<span class="line-modified"> 298         private final UnmodifiableEconomicMap&lt;String, String&gt; originalMethods;</span>
 299 
<a name="11" id="anc11"></a><span class="line-modified"> 300         EncodedSnippets(byte[] snippetEncoding, Object[] snippetObjects, NodeClass&lt;?&gt;[] snippetNodeClasses, UnmodifiableEconomicMap&lt;String, Integer&gt; snippetStartOffsets,</span>
<span class="line-added"> 301                         UnmodifiableEconomicMap&lt;String, String&gt; originalMethods) {</span>
 302             this.snippetEncoding = snippetEncoding;
 303             this.snippetObjects = snippetObjects;
 304             this.snippetNodeClasses = snippetNodeClasses;
 305             this.snippetStartOffsets = snippetStartOffsets;
 306             this.originalMethods = originalMethods;
 307         }
 308 
<a name="12" id="anc12"></a><span class="line-added"> 309         public byte[] getSnippetEncoding() {</span>
<span class="line-added"> 310             return snippetEncoding;</span>
<span class="line-added"> 311         }</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313         public NodeClass&lt;?&gt;[] getSnippetNodeClasses() {</span>
<span class="line-added"> 314             return snippetNodeClasses;</span>
<span class="line-added"> 315         }</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317         public UnmodifiableEconomicMap&lt;String, Integer&gt; getSnippetStartOffsets() {</span>
<span class="line-added"> 318             return snippetStartOffsets;</span>
<span class="line-added"> 319         }</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321         public UnmodifiableEconomicMap&lt;String, String&gt; getOriginalMethods() {</span>
<span class="line-added"> 322             return originalMethods;</span>
<span class="line-added"> 323         }</span>
<span class="line-added"> 324 </span>
 325         StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements, IntrinsicContext.CompilationContext context,
 326                         StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {
 327             IntrinsicContext.CompilationContext contextToUse = context;
 328             if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {
 329                 contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
 330             }
 331             Integer startOffset = snippetStartOffsets.get(plugin.toString() + contextToUse);
 332             if (startOffset == null) {
 333                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin + &quot; with &quot; + contextToUse);
 334             }
 335 
 336             ResolvedJavaType accessingClass = replacements.getProviders().getMetaAccess().lookupJavaType(plugin.getDeclaringClass());
 337             return decodeGraph(original, accessingClass, startOffset, replacements, contextToUse, allowAssumptions, cancellable, options);
 338         }
 339 
 340         @SuppressWarnings(&quot;try&quot;)
 341         private StructuredGraph decodeGraph(ResolvedJavaMethod method,
 342                         ResolvedJavaType accessingClass,
 343                         int startOffset,
 344                         ReplacementsImpl replacements,
 345                         IntrinsicContext.CompilationContext context,
 346                         StructuredGraph.AllowAssumptions allowAssumptions,
 347                         Cancellable cancellable,
 348                         OptionValues options) {
 349             Providers providers = replacements.getProviders();
 350             EncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,
 351                             methodKey(method), accessingClass, method.getDeclaringClass());
 352             try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {
 353                 StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions).cancellable(cancellable).method(method).setIsSubstitution(true).build();
 354                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, null, method, context, encodedGraph);
 355 
 356                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 357 
 358                 assert result.verify();
 359                 return result;
 360             }
 361         }
 362 
 363         StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args, StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {
 364             Integer startOffset = null;
 365             if (snippetStartOffsets != null) {
 366                 startOffset = snippetStartOffsets.get(methodKey(method));
 367             }
 368             if (startOffset == null) {
 369                 if (IS_IN_NATIVE_IMAGE) {
 370                     throw GraalError.shouldNotReachHere(&quot;snippet not found: &quot; + method.format(&quot;%H.%n(%p)&quot;));
 371                 } else {
 372                     return null;
 373                 }
 374             }
 375 
 376             SymbolicEncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,
 377                             originalMethods.get(methodKey(method)), method.getDeclaringClass());
 378             return decodeSnippetGraph(encodedGraph, method, replacements, args, allowAssumptions, options);
 379         }
 380 
 381     }
 382 
 383     private static class SubstitutionGraphDecoder extends PEGraphDecoder {
 384         private final ResolvedJavaMethod method;
 385         private final EncodedGraph encodedGraph;
 386         private IntrinsicContext intrinsic;
 387 
 388         SubstitutionGraphDecoder(Providers providers, StructuredGraph result, ReplacementsImpl replacements, ParameterPlugin parameterPlugin, ResolvedJavaMethod method,
 389                         IntrinsicContext.CompilationContext context, EncodedGraph encodedGraph) {
 390             super(providers.getCodeCache().getTarget().arch, result, providers, null,
 391                             replacements.getGraphBuilderPlugins().getInvocationPlugins(), new InlineInvokePlugin[0], parameterPlugin,
 392                             null, null, null, null);
 393             this.method = method;
 394             this.encodedGraph = encodedGraph;
 395             intrinsic = new IntrinsicContext(method, null, replacements.getDefaultReplacementBytecodeProvider(), context, false);
 396         }
 397 
 398         @Override
 399         protected EncodedGraph lookupEncodedGraph(ResolvedJavaMethod lookupMethod,
 400                         MethodSubstitutionPlugin plugin,
 401                         BytecodeProvider intrinsicBytecodeProvider,
 402                         boolean isSubstitution,
 403                         boolean trackNodeSourcePosition) {
 404             if (lookupMethod.equals(method)) {
 405                 return encodedGraph;
 406             } else {
 407                 throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));
 408             }
 409         }
 410 
 411         @Override
 412         protected IntrinsicContext getIntrinsic() {
 413             return intrinsic;
 414         }
 415     }
 416 
 417     private StructuredGraph buildGraph(ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, Object receiver, boolean requireInlining, boolean trackNodeSourcePosition,
 418                     IntrinsicContext.CompilationContext context, OptionValues options) {
 419         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
 420         Object[] args = null;
 421         if (receiver != null) {
 422             args = new Object[method.getSignature().getParameterCount(true)];
 423             args[0] = receiver;
 424         }
 425         // To get dumping out from this context during image building, it&#39;s necessary to pass the
 426         // dumping options directly to the VM, otherwise they aren&#39;t available during initialization
 427         // of the backend. Use this:
 428         //
 429         // -J-Dgraal.Dump=SymbolicSnippetEncoder_:2 -J-Dgraal.PrintGraph=File
 430         // -J-Dgraal.DebugStubsAndSnippets=true
 431         IntrinsicContext.CompilationContext contextToUse = context;
 432         if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {
 433             contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
 434         }
 435         try (DebugContext debug = openDebugContext(&quot;SymbolicSnippetEncoder_&quot;, method, options)) {
 436             StructuredGraph graph = snippetReplacements.makeGraph(debug, snippetReplacements.getDefaultReplacementBytecodeProvider(), method, args, original, trackNodeSourcePosition, null,
 437                             contextToUse);
 438 
 439             // Check if all methods which should be inlined are really inlined.
 440             for (MethodCallTargetNode callTarget : graph.getNodes(MethodCallTargetNode.TYPE)) {
 441                 ResolvedJavaMethod callee = callTarget.targetMethod();
 442                 if (requireInlining &amp;&amp; !delayedInvocationPluginMethods.contains(callee) &amp;&amp; !Objects.equals(callee, original)) {
 443                     throw GraalError.shouldNotReachHere(&quot;method &quot; + callee.format(&quot;%H.%n&quot;) + &quot; not inlined in snippet &quot; + method.getName() + &quot; (maybe not final?)&quot;);
 444                 }
 445             }
 446             assert verifySnippetEncodeDecode(debug, method, original, originalMethodString, trackNodeSourcePosition, graph);
 447             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;After buildGraph&quot;);
 448             return graph;
 449         }
 450     }
 451 
 452     @SuppressWarnings(&quot;try&quot;)
 453     private static StructuredGraph decodeSnippetGraph(SymbolicEncodedGraph encodedGraph, ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args,
 454                     StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {
 455         Providers providers = replacements.getProviders();
 456         ParameterPlugin parameterPlugin = null;
 457         if (args != null) {
 458             parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), replacements.snippetReflection);
 459         }
 460 
 461         try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {
 462             // @formatter:off
 463             StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions)
 464                     .method(method)
 465                     .trackNodeSourcePosition(encodedGraph.trackNodeSourcePosition())
 466                     .setIsSubstitution(true)
 467                     .build();
 468             // @formatter:on
 469             try (DebugContext.Scope scope = debug.scope(&quot;DecodeSnippetGraph&quot;, result)) {
 470                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, parameterPlugin, method, INLINE_AFTER_PARSING, encodedGraph);
 471 
 472                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 473                 debug.dump(DebugContext.VERBOSE_LEVEL, result, &quot;After decoding&quot;);
 474 
 475                 assert result.verify();
 476                 return result;
 477             } catch (Throwable t) {
 478                 throw debug.handle(t);
 479             }
 480         }
 481     }
 482 
 483     @SuppressWarnings(&quot;try&quot;)
 484     private boolean verifySnippetEncodeDecode(DebugContext debug, ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, boolean trackNodeSourcePosition,
 485                     StructuredGraph graph) {
 486         // Verify the encoding and decoding process
 487         EncodedGraph encodedGraph = GraphEncoder.encodeSingleGraph(graph, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);
 488 
 489         HotSpotProviders originalProvider = (HotSpotProviders) snippetReplacements.getProviders();
 490 
 491         SnippetReflectionProvider snippetReflection = originalProvider.getSnippetReflection();
 492         SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider constantReflection = new SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider(
 493                         originalProvider.getConstantReflection());
 494         HotSpotProviders newProviders = new HotSpotProviders(originalProvider.getMetaAccess(), originalProvider.getCodeCache(), constantReflection,
 495                         originalProvider.getConstantFieldProvider(), originalProvider.getForeignCalls(), originalProvider.getLowerer(), null, originalProvider.getSuites(),
<a name="13" id="anc13"></a><span class="line-modified"> 496                         originalProvider.getRegisters(), snippetReflection, originalProvider.getWordTypes(), originalProvider.getGraphBuilderPlugins(),</span>
<span class="line-added"> 497                         originalProvider.getPlatformConfigurationProvider());</span>
 498         HotSpotSnippetReplacementsImpl filteringReplacements = new HotSpotSnippetReplacementsImpl(newProviders, snippetReflection,
 499                         originalProvider.getReplacements().getDefaultReplacementBytecodeProvider(), originalProvider.getCodeCache().getTarget());
 500         filteringReplacements.setGraphBuilderPlugins(originalProvider.getReplacements().getGraphBuilderPlugins());
 501         try (DebugContext.Scope scaope = debug.scope(&quot;VerifySnippetEncodeDecode&quot;, graph)) {
 502             for (int i = 0; i &lt; encodedGraph.getNumObjects(); i++) {
 503                 filterSnippetObject(encodedGraph.getObject(i));
 504             }
 505             StructuredGraph snippet = filteringReplacements.makeGraph(debug, filteringReplacements.getDefaultReplacementBytecodeProvider(), method, null, original,
 506                             trackNodeSourcePosition, null);
 507             SymbolicEncodedGraph symbolicGraph = new SymbolicEncodedGraph(encodedGraph, method.getDeclaringClass(), originalMethodString);
 508             StructuredGraph decodedSnippet = decodeSnippetGraph(symbolicGraph, original != null ? original : method, originalReplacements, null,
 509                             StructuredGraph.AllowAssumptions.ifNonNull(graph.getAssumptions()), graph.getOptions());
 510             String snippetString = getCanonicalGraphString(snippet, true, false);
 511             String decodedSnippetString = getCanonicalGraphString(decodedSnippet, true, false);
 512             if (snippetString.equals(decodedSnippetString)) {
 513                 debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);
 514                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 515             } else {
 516                 debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);
 517                 debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));
 518                 debug.dump(DebugContext.VERBOSE_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);
 519                 debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Encoded snippet graph for %s&quot;, method);
 520                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 521             }
 522         } catch (Throwable t) {
 523             throw debug.handle(t);
 524         }
 525         return true;
 526     }
 527 
 528     /**
 529      * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
 530      */
 531     @SuppressWarnings(&quot;try&quot;)
 532     private synchronized EncodedSnippets maybeEncodeSnippets(OptionValues options) {
<a name="14" id="anc14"></a><span class="line-modified"> 533         EconomicSet&lt;MethodSubstitutionPlugin&gt; plugins = this.knownPlugins;</span>
 534         if (preparedPlugins != plugins.size()) {
 535             for (MethodSubstitutionPlugin plugin : plugins) {
 536                 ResolvedJavaMethod original = plugin.getOriginalMethod(originalReplacements.getProviders().getMetaAccess());
 537                 registerMethodSubstitution(plugin, original, INLINE_AFTER_PARSING, options);
 538                 if (!original.isNative()) {
 539                     registerMethodSubstitution(plugin, original, ROOT_COMPILATION_ENCODING, options);
 540                 }
 541             }
 542             preparedPlugins = plugins.size();
 543         }
<a name="15" id="anc15"></a><span class="line-modified"> 544         EconomicMap&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;</span>
 545         if (encodedGraphs != graphs.size()) {
 546             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null, options);
 547             try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
 548                 encodedGraphs = graphs.size();
<a name="16" id="anc16"></a><span class="line-modified"> 549                 for (StructuredGraph graph : graphs.getValues()) {</span>
 550                     for (Node node : graph.getNodes()) {
 551                         node.setNodeSourcePosition(null);
 552                     }
 553                 }
 554                 return encodeSnippets(debug);
 555             }
 556         }
 557         return null;
<a name="17" id="anc17"></a><span class="line-added"> 558 </span>
 559     }
 560 
 561     synchronized void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {
 562         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {
 563             assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
 564             String key = methodKey(method);
 565             if (!preparedSnippetGraphs.containsKey(key)) {
 566                 if (original != null) {
 567                     originalMethods.put(key, methodKey(original));
 568                 }
 569                 StructuredGraph snippet = buildGraph(method, original, null, receiver, true, trackNodeSourcePosition, INLINE_AFTER_PARSING, options);
 570                 snippetMethods.add(method);
 571                 preparedSnippetGraphs.put(key, snippet);
 572             }
 573         }
 574 
 575     }
 576 
 577     private synchronized EncodedSnippets encodeSnippets(DebugContext debug) {
 578         GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
<a name="18" id="anc18"></a><span class="line-modified"> 579         for (StructuredGraph graph : preparedSnippetGraphs.getValues()) {</span>
 580             encoder.prepare(graph);
 581         }
 582         encoder.finishPrepare();
 583 
 584         byte[] snippetEncoding;
 585         Object[] snippetObjects;
 586         NodeClass&lt;?&gt;[] snippetNodeClasses;
<a name="19" id="anc19"></a><span class="line-modified"> 587         EconomicMap&lt;String, Integer&gt; snippetStartOffsets;</span>
 588 
<a name="20" id="anc20"></a><span class="line-modified"> 589         snippetStartOffsets = EconomicMap.create();</span>
<span class="line-modified"> 590         MapCursor&lt;String, StructuredGraph&gt; cursor = preparedSnippetGraphs.getEntries();</span>
<span class="line-modified"> 591         while (cursor.advance()) {</span>
<span class="line-added"> 592             snippetStartOffsets.put(cursor.getKey(), encoder.encode(cursor.getValue()));</span>
 593         }
 594         snippetEncoding = encoder.getEncoding();
 595         snippetObjects = encoder.getObjects();
 596         snippetNodeClasses = encoder.getNodeClasses();
 597         for (int i = 0; i &lt; snippetObjects.length; i++) {
 598             Object o = filterSnippetObject(snippetObjects[i]);
 599             debug.log(&quot;snippetObjects[%d] = %s -&gt; %s&quot;, i, o != null ? o.getClass().getSimpleName() : null, o);
 600             snippetObjects[i] = o;
 601         }
 602         debug.log(&quot;Encoded %d snippet preparedSnippetGraphs using %d bytes with %d objects&quot;, snippetStartOffsets.size(), snippetEncoding.length, snippetObjects.length);
 603         return new EncodedSnippets(snippetEncoding, snippetObjects, snippetNodeClasses, snippetStartOffsets, originalMethods);
 604     }
 605 
 606     /**
 607      * Encode any outstanding graphs and return true if any work was done.
 608      */
 609     @SuppressWarnings(&quot;try&quot;)
 610     public boolean encode(OptionValues options) {
 611         EncodedSnippets encodedSnippets = maybeEncodeSnippets(options);
 612         if (encodedSnippets != null) {
 613             HotSpotReplacementsImpl.setEncodedSnippets(encodedSnippets);
 614             return true;
 615         }
 616         return false;
 617     }
 618 
 619     private DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {
 620         return snippetReplacements.openDebugContext(idPrefix, method, options);
 621     }
 622 
 623     static class SymbolicEncodedGraph extends EncodedGraph {
 624 
 625         private final ResolvedJavaType[] accessingClasses;
 626         private final String originalMethod;
 627 
 628         SymbolicEncodedGraph(byte[] encoding, int startOffset, Object[] objects, NodeClass&lt;?&gt;[] types, String originalMethod, ResolvedJavaType... accessingClasses) {
 629             super(encoding, startOffset, objects, types, null, null, null, false, false);
 630             this.accessingClasses = accessingClasses;
 631             this.originalMethod = originalMethod;
 632         }
 633 
 634         SymbolicEncodedGraph(EncodedGraph encodedGraph, ResolvedJavaType declaringClass, String originalMethod) {
 635             this(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), encodedGraph.getObjects(), encodedGraph.getNodeClasses(),
 636                             originalMethod, declaringClass);
 637         }
 638 
 639         @Override
 640         public Object getObject(int i) {
 641             Object o = objects[i];
 642             Object replacement = null;
 643             if (o instanceof SymbolicJVMCIReference) {
 644                 for (ResolvedJavaType type : accessingClasses) {
 645                     try {
 646                         replacement = ((SymbolicJVMCIReference&lt;?&gt;) o).resolve(type);
 647                         break;
 648                     } catch (NoClassDefFoundError e) {
 649                     }
 650                 }
 651             } else if (o instanceof UnresolvedJavaType) {
 652                 for (ResolvedJavaType type : accessingClasses) {
 653                     try {
 654                         replacement = ((UnresolvedJavaType) o).resolve(type);
 655                         break;
 656                     } catch (NoClassDefFoundError e) {
 657                     }
 658                 }
 659             } else if (o instanceof UnresolvedJavaMethod) {
 660                 throw new InternalError(o.toString());
 661             } else if (o instanceof UnresolvedJavaField) {
 662                 for (ResolvedJavaType type : accessingClasses) {
 663                     try {
 664                         replacement = ((UnresolvedJavaField) o).resolve(type);
 665                         break;
 666                     } catch (NoClassDefFoundError e) {
 667                     }
 668                 }
 669             } else if (o instanceof GraalCapability) {
 670                 replacement = ((GraalCapability) o).resolve(((GraalJVMCICompiler) getRuntime().getCompiler()).getGraalRuntime());
 671             } else {
 672                 return o;
 673             }
 674             if (replacement != null) {
 675                 objects[i] = o = replacement;
 676             } else {
 677                 throw new GraalError(&quot;Can&#39;t resolve &quot; + o);
 678             }
 679             return o;
 680         }
 681 
 682         @Override
 683         public boolean isCallToOriginal(ResolvedJavaMethod callTarget) {
 684             if (originalMethod != null &amp;&amp; originalMethod.equals(methodKey(callTarget))) {
 685                 return true;
 686             }
 687             return super.isCallToOriginal(callTarget);
 688         }
 689     }
 690 
 691     /**
 692      * Symbolic reference to an object which can be retrieved from
 693      * {@link GraalRuntime#getCapability(Class)}.
 694      */
 695     static class GraalCapability {
 696         final Class&lt;?&gt; capabilityClass;
 697 
 698         GraalCapability(Class&lt;?&gt; capabilityClass) {
 699             this.capabilityClass = capabilityClass;
 700         }
 701 
 702         public Object resolve(GraalRuntime runtime) {
 703             Object capability = runtime.getCapability(this.capabilityClass);
 704             if (capability != null) {
 705                 assert capability.getClass() == capabilityClass;
 706                 return capability;
 707             }
 708             throw new InternalError(this.capabilityClass.getName());
 709         }
 710     }
 711 
 712     static class SymbolicResolvedJavaMethod implements SymbolicJVMCIReference&lt;ResolvedJavaMethod&gt; {
 713         final UnresolvedJavaType type;
 714         final String methodName;
 715         final String signature;
 716 
 717         SymbolicResolvedJavaMethod(ResolvedJavaMethod method) {
 718             this.type = UnresolvedJavaType.create(method.getDeclaringClass().getName());
 719             this.methodName = method.getName();
 720             this.signature = method.getSignature().toMethodDescriptor();
 721         }
 722 
 723         @Override
 724         public String toString() {
 725             return &quot;SymbolicResolvedJavaMethod{&quot; +
 726                             &quot;declaringType=&#39;&quot; + type.getName() + &#39;\&#39;&#39; +
 727                             &quot;, methodName=&#39;&quot; + methodName + &#39;\&#39;&#39; +
 728                             &quot;, signature=&#39;&quot; + signature + &#39;\&#39;&#39; +
 729                             &#39;}&#39;;
 730         }
 731 
 732         @Override
 733         public ResolvedJavaMethod resolve(ResolvedJavaType accessingClass) {
 734             ResolvedJavaType resolvedType = type.resolve(accessingClass);
 735             if (resolvedType == null) {
 736                 throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 737             }
 738             for (ResolvedJavaMethod method : methodName.equals(&quot;&lt;init&gt;&quot;) ? resolvedType.getDeclaredConstructors() : resolvedType.getDeclaredMethods()) {
 739                 if (method.getName().equals(methodName) &amp;&amp; method.getSignature().toMethodDescriptor().equals(signature)) {
 740                     return method;
 741                 }
 742             }
 743             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 744         }
 745     }
 746 
 747     static class SymbolicResolvedJavaField implements SymbolicJVMCIReference&lt;ResolvedJavaField&gt; {
 748         final UnresolvedJavaType declaringType;
 749         final String name;
 750         final UnresolvedJavaType signature;
 751         private final boolean isStatic;
 752 
 753         SymbolicResolvedJavaField(ResolvedJavaField field) {
 754             this.declaringType = UnresolvedJavaType.create(field.getDeclaringClass().getName());
 755             this.name = field.getName();
 756             this.signature = UnresolvedJavaType.create(field.getType().getName());
 757             this.isStatic = field.isStatic();
 758         }
 759 
 760         @Override
 761         public ResolvedJavaField resolve(ResolvedJavaType accessingClass) {
 762             ResolvedJavaType resolvedType = declaringType.resolve(accessingClass);
 763             ResolvedJavaType resolvedFieldType = signature.resolve(accessingClass);
 764             ResolvedJavaField[] fields = isStatic ? resolvedType.getStaticFields() : resolvedType.getInstanceFields(true);
 765             for (ResolvedJavaField field : fields) {
 766                 if (field.getName().equals(name)) {
 767                     if (field.getType().equals(resolvedFieldType)) {
 768                         return field;
 769                     }
 770                 }
 771             }
 772             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 773         }
 774 
 775         @Override
 776         public String toString() {
 777             return &quot;SymbolicResolvedJavaField{&quot; +
 778                             signature.getName() + &#39; &#39; +
 779                             declaringType.getName() + &#39;.&#39; +
 780                             name +
 781                             &#39;}&#39;;
 782         }
 783     }
 784 
 785     static class SymbolicResolvedJavaMethodBytecode implements SymbolicJVMCIReference&lt;ResolvedJavaMethodBytecode&gt; {
 786         SymbolicResolvedJavaMethod method;
 787 
 788         SymbolicResolvedJavaMethodBytecode(ResolvedJavaMethodBytecode bytecode) {
 789             method = new SymbolicResolvedJavaMethod(bytecode.getMethod());
 790         }
 791 
 792         @Override
 793         public ResolvedJavaMethodBytecode resolve(ResolvedJavaType accessingClass) {
 794             return new ResolvedJavaMethodBytecode(method.resolve(accessingClass));
 795         }
 796     }
 797 
 798     static class SymbolicStampPair implements SymbolicJVMCIReference&lt;StampPair&gt; {
 799         Object trustedStamp;
 800         Object uncheckdStamp;
 801 
 802         SymbolicStampPair(StampPair stamp) {
 803             this.trustedStamp = maybeMakeSymbolic(stamp.getTrustedStamp());
 804             this.uncheckdStamp = maybeMakeSymbolic(stamp.getUncheckedStamp());
 805         }
 806 
 807         @Override
 808         public StampPair resolve(ResolvedJavaType accessingClass) {
 809             return StampPair.create(resolveStamp(accessingClass, trustedStamp), resolveStamp(accessingClass, uncheckdStamp));
 810         }
 811     }
 812 
 813     private static Object maybeMakeSymbolic(Stamp trustedStamp) {
 814         if (trustedStamp != null) {
 815             SymbolicJVMCIReference&lt;?&gt; symbolicJVMCIReference = trustedStamp.makeSymbolic();
 816             if (symbolicJVMCIReference != null) {
 817                 return symbolicJVMCIReference;
 818             }
 819         }
 820         return trustedStamp;
 821     }
 822 
 823     private static Stamp resolveStamp(ResolvedJavaType accessingClass, Object stamp) {
 824         if (stamp == null) {
 825             return null;
 826         }
 827         if (stamp instanceof Stamp) {
 828             return (Stamp) stamp;
 829         }
 830         return (Stamp) ((SymbolicJVMCIReference&lt;?&gt;) stamp).resolve(accessingClass);
 831     }
 832 
 833     public static class HotSpotSubstrateConstantReflectionProvider implements ConstantReflectionProvider {
 834 
 835         private final ConstantReflectionProvider constantReflection;
 836 
 837         HotSpotSubstrateConstantReflectionProvider(ConstantReflectionProvider constantReflection) {
 838             this.constantReflection = constantReflection;
 839         }
 840 
 841         HashSet&lt;JavaConstant&gt; safeConstants = new HashSet&lt;&gt;();
 842 
 843         @Override
 844         public Boolean constantEquals(Constant x, Constant y) {
 845             return constantReflection.constantEquals(x, y);
 846         }
 847 
 848         @Override
 849         public Integer readArrayLength(JavaConstant array) {
 850             return constantReflection.readArrayLength(array);
 851         }
 852 
 853         @Override
 854         public JavaConstant readArrayElement(JavaConstant array, int index) {
 855             return constantReflection.readArrayElement(array, index);
 856         }
 857 
 858         @Override
 859         public JavaConstant readFieldValue(ResolvedJavaField field, JavaConstant receiver) {
 860             JavaConstant javaConstant = constantReflection.readFieldValue(field, receiver);
 861             if (!safeConstants.contains(receiver) &amp;&amp;
 862                             !field.getDeclaringClass().getName().contains(&quot;graalvm&quot;) &amp;&amp;
 863                             !field.getDeclaringClass().getName().contains(&quot;jdk/vm/ci/&quot;) &amp;&amp;
 864                             !field.getDeclaringClass().getName().contains(&quot;jdk/internal/vm/compiler&quot;) &amp;&amp;
 865 
 866                             !field.getName().equals(&quot;TYPE&quot;)) {
 867                 // Only permit constant reflection on compiler classes. This is necessary primarily
 868                 // because of the boxing snippets which are compiled as snippets but are really just
 869                 // regular JDK java sources that are being compiled like a snippet. These shouldn&#39;t
 870                 // permit constant folding during graph preparation as that embeds constants from
 871                 // the runtime into a compiler graph.
 872                 return null;
 873             }
 874             if (javaConstant.getJavaKind() == JavaKind.Object) {
 875                 safeConstants.add(javaConstant);
 876             }
 877             return javaConstant;
 878         }
 879 
 880         @Override
 881         public JavaConstant boxPrimitive(JavaConstant source) {
 882             return constantReflection.boxPrimitive(source);
 883         }
 884 
 885         @Override
 886         public JavaConstant unboxPrimitive(JavaConstant source) {
 887             return constantReflection.unboxPrimitive(source);
 888         }
 889 
 890         @Override
 891         public JavaConstant forString(String value) {
 892             return constantReflection.forString(value);
 893         }
 894 
 895         @Override
 896         public ResolvedJavaType asJavaType(Constant constant) {
 897             return constantReflection.asJavaType(constant);
 898         }
 899 
 900         @Override
 901         public MethodHandleAccessProvider getMethodHandleAccess() {
 902             return constantReflection.getMethodHandleAccess();
 903         }
 904 
 905         @Override
 906         public MemoryAccessProvider getMemoryAccessProvider() {
 907             return constantReflection.getMemoryAccessProvider();
 908         }
 909 
 910         @Override
 911         public JavaConstant asJavaClass(ResolvedJavaType type) {
 912             return constantReflection.asJavaClass(type);
 913         }
 914 
 915         @Override
 916         public Constant asObjectHub(ResolvedJavaType type) {
 917             return constantReflection.asObjectHub(type);
 918         }
 919     }
 920 
 921     /**
 922      * Objects embedded in encoded graphs might need to converted into a symbolic form so convert
 923      * the object or pass it through.
 924      */
 925     private static Object filterSnippetObject(Object o) {
 926         if (o instanceof HotSpotResolvedJavaMethod) {
 927             return new SymbolicResolvedJavaMethod((HotSpotResolvedJavaMethod) o);
 928         } else if (o instanceof HotSpotResolvedJavaField) {
 929             return new SymbolicResolvedJavaField((HotSpotResolvedJavaField) o);
 930         } else if (o instanceof HotSpotResolvedJavaType) {
 931             return UnresolvedJavaType.create(((ResolvedJavaType) o).getName());
 932         } else if (o instanceof NodeSourcePosition) {
 933             // Filter these out for now. These can&#39;t easily be handled because these positions
 934             // description snippet methods which might not be available in the runtime.
 935             return null;
 936         } else if (o instanceof HotSpotForeignCallsProvider || o instanceof GraalHotSpotVMConfig) {
 937             return new GraalCapability(o.getClass());
 938         } else if (o instanceof Stamp) {
 939             SymbolicJVMCIReference&lt;?&gt; ref = ((Stamp) o).makeSymbolic();
 940             if (ref != null) {
 941                 return ref;
 942             }
 943             return o;
 944         } else if (o instanceof StampPair) {
 945             if (((StampPair) o).getTrustedStamp() instanceof AbstractObjectStamp) {
 946                 return new SymbolicStampPair((StampPair) o);
 947             }
 948         } else if (o instanceof ResolvedJavaMethodBytecode) {
 949             return new SymbolicResolvedJavaMethodBytecode((ResolvedJavaMethodBytecode) o);
 950         } else if (o instanceof HotSpotSignature) {
 951             throw new GraalError(o.toString());
 952         }
 953         return o;
 954     }
 955 
 956     private static String compareGraphStrings(StructuredGraph expectedGraph, String expectedString, StructuredGraph actualGraph, String actualString) {
 957         if (!expectedString.equals(actualString)) {
 958             String[] expectedLines = expectedString.split(&quot;\n&quot;);
 959             String[] actualLines = actualString.split(&quot;\n&quot;);
 960             int diffIndex = -1;
 961             int limit = Math.min(actualLines.length, expectedLines.length);
 962             String marker = &quot; &lt;&lt;&lt;&quot;;
 963             for (int i = 0; i &lt; limit; i++) {
 964                 if (!expectedLines[i].equals(actualLines[i])) {
 965                     diffIndex = i;
 966                     break;
 967                 }
 968             }
 969             if (diffIndex == -1) {
 970                 // Prefix is the same so add some space after the prefix
 971                 diffIndex = limit;
 972                 if (actualLines.length == limit) {
 973                     actualLines = Arrays.copyOf(actualLines, limit + 1);
 974                     actualLines[diffIndex] = &quot;&quot;;
 975                 } else {
 976                     assert expectedLines.length == limit;
 977                     expectedLines = Arrays.copyOf(expectedLines, limit + 1);
 978                     expectedLines[diffIndex] = &quot;&quot;;
 979                 }
 980             }
 981             // Place a marker next to the first line that differs
 982             expectedLines[diffIndex] = expectedLines[diffIndex] + marker;
 983             actualLines[diffIndex] = actualLines[diffIndex] + marker;
 984             String ediff = String.join(&quot;\n&quot;, expectedLines);
 985             String adiff = String.join(&quot;\n&quot;, actualLines);
 986             return &quot;mismatch in preparedSnippetGraphs:\n========= expected (&quot; + expectedGraph + &quot;) =========\n&quot; + ediff + &quot;\n\n========= actual (&quot; + actualGraph + &quot;) =========\n&quot; + adiff;
 987         } else {
 988             return &quot;mismatch in preparedSnippetGraphs&quot;;
 989         }
 990     }
 991 
 992     private static String getCanonicalGraphString(StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {
 993         SchedulePhase schedule = new SchedulePhase(SchedulePhase.SchedulingStrategy.EARLIEST);
 994         schedule.apply(graph);
 995         StructuredGraph.ScheduleResult scheduleResult = graph.getLastSchedule();
 996 
 997         NodeMap&lt;Integer&gt; canonicalId = graph.createNodeMap();
 998         int nextId = 0;
 999 
1000         List&lt;String&gt; constantsLines = new ArrayList&lt;&gt;();
1001 
1002         StringBuilder result = new StringBuilder();
1003         for (Block block : scheduleResult.getCFG().getBlocks()) {
1004             result.append(&quot;Block &quot;).append(block).append(&#39; &#39;);
1005             if (block == scheduleResult.getCFG().getStartBlock()) {
1006                 result.append(&quot;* &quot;);
1007             }
1008             result.append(&quot;-&gt; &quot;);
1009             for (Block succ : block.getSuccessors()) {
1010                 result.append(succ).append(&#39; &#39;);
1011             }
1012             result.append(&#39;\n&#39;);
1013             for (Node node : scheduleResult.getBlockToNodesMap().get(block)) {
1014                 if (node instanceof ValueNode &amp;&amp; node.isAlive()) {
1015                     if (!excludeVirtual || !(node instanceof VirtualObjectNode || node instanceof ProxyNode || node instanceof FullInfopointNode || node instanceof ParameterNode)) {
1016                         if (node instanceof ConstantNode) {
1017                             if (checkConstants) {
1018                                 String name = node.toString(Verbosity.Name);
1019                                 if (excludeVirtual) {
1020                                     constantsLines.add(name);
1021                                 } else {
1022                                     constantsLines.add(name + &quot;    (&quot; + filteredUsageCount(node) + &quot;)&quot;);
1023                                 }
1024                             }
1025                         } else {
1026                             int id;
1027                             if (canonicalId.get(node) != null) {
1028                                 id = canonicalId.get(node);
1029                             } else {
1030                                 id = nextId++;
1031                                 canonicalId.set(node, id);
1032                             }
1033                             String name = node.getClass().getSimpleName();
1034                             result.append(&quot;  &quot;).append(id).append(&#39;|&#39;).append(name);
1035                             if (node instanceof AccessFieldNode) {
1036                                 result.append(&#39;#&#39;);
1037                                 result.append(((AccessFieldNode) node).field());
1038                             }
1039                             if (!excludeVirtual) {
1040                                 result.append(&quot;    (&quot;);
1041                                 result.append(filteredUsageCount(node));
1042                                 result.append(&#39;)&#39;);
1043                             }
1044                             result.append(&#39;\n&#39;);
1045                         }
1046                     }
1047                 }
1048             }
1049         }
1050 
1051         StringBuilder constantsLinesResult = new StringBuilder();
1052         if (checkConstants) {
1053             constantsLinesResult.append(constantsLines.size()).append(&quot; constants:\n&quot;);
1054         }
1055         Collections.sort(constantsLines);
1056         for (String s : constantsLines) {
1057             constantsLinesResult.append(s);
1058             constantsLinesResult.append(&#39;\n&#39;);
1059         }
1060 
1061         return constantsLinesResult.toString() + result.toString();
1062     }
1063 
1064     private static int filteredUsageCount(Node node) {
1065         return node.usages().filter(n -&gt; !(n instanceof FrameState)).count();
1066     }
1067 
1068     /**
1069      * This horror show of classes exists solely get {@link HotSpotSnippetBytecodeParser} to be used
1070      * as the parser for these snippets.
1071      */
1072     class HotSpotSnippetReplacementsImpl extends HotSpotReplacementsImpl {
1073         HotSpotSnippetReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {
1074             super(replacements, providers);
1075         }
1076 
1077         HotSpotSnippetReplacementsImpl(Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {
1078             super(providers, snippetReflection, bytecodeProvider, target);
1079         }
1080 
1081         @Override
1082         protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
1083             return new SnippetGraphMaker(this, substitute, original);
1084         }
1085     }
1086 
1087     class SnippetGraphMaker extends ReplacementsImpl.GraphMaker {
1088         SnippetGraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
1089             super(replacements, substitute, substitutedMethod);
1090         }
1091 
1092         @Override
1093         protected GraphBuilderPhase.Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts,
1094                         IntrinsicContext initialIntrinsicContext) {
1095             return new HotSpotSnippetGraphBuilderPhase(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);
1096         }
1097     }
1098 
1099     class HotSpotSnippetGraphBuilderPhase extends GraphBuilderPhase.Instance {
1100         HotSpotSnippetGraphBuilderPhase(Providers theProviders, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {
1101             super(theProviders, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);
1102         }
1103 
1104         @Override
1105         protected BytecodeParser createBytecodeParser(StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI, IntrinsicContext intrinsicContext) {
1106             return new HotSpotSnippetBytecodeParser(this, graph, parent, method, entryBCI, intrinsicContext);
1107         }
1108     }
1109 
1110     class HotSpotSnippetBytecodeParser extends BytecodeParser {
1111         HotSpotSnippetBytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI,
1112                         IntrinsicContext intrinsicContext) {
1113             super(graphBuilderInstance, graph, parent, method, entryBCI, intrinsicContext);
1114         }
1115 
1116         @Override
1117         public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
1118             // Fold is always deferred but NodeIntrinsics may have to wait if all their arguments
1119             // aren&#39;t constant yet.
1120             return plugin.isGeneratedFromFoldOrNodeIntrinsic();
1121         }
1122 
1123         @Override
1124         protected boolean canInlinePartialIntrinsicExit() {
1125             return false;
1126         }
1127 
1128         @Override
1129         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
1130             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1131                 return false;
1132             }
1133             if (targetMethod.getAnnotation(Fold.class) != null) {
1134                 // Always defer Fold until decode time but NodeIntrinsics may fold if they are able.
1135                 return false;
1136             }
1137             InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
<a name="21" id="anc21"></a><span class="line-modified">1138             if (plugin != null &amp;&amp; conditionalPlugins.contains(plugin)) {</span>
1139                 // Because supporting arbitrary plugins in the context of encoded graphs is complex
1140                 // we disallow it. This limitation can be worked around through the use of method
1141                 // substitutions.
1142                 throw new GraalError(&quot;conditional plugins are unsupported in snippets and method substitutions: &quot; + targetMethod + &quot; &quot; + plugin);
1143             }
1144             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType);
1145         }
1146     }
1147 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
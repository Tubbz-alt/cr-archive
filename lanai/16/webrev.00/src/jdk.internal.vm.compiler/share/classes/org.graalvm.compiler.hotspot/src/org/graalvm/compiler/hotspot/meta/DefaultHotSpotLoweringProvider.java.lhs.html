<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.AlwaysInlineVTableStubs;
 29 import static org.graalvm.compiler.core.common.GraalOptions.InlineVTableStubs;
 30 import static org.graalvm.compiler.core.common.GraalOptions.OmitHotExceptionStacktrace;
 31 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.OSR_MIGRATION_END;
 32 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_KLASS_LOCATION;
 33 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_MIRROR_HANDLE_LOCATION;
 34 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_MIRROR_LOCATION;
 35 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.COMPRESSED_HUB_LOCATION;
 36 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.DISPLACED_MARK_WORD_LOCATION;
 37 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_LOCATION;
 38 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
 39 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.KLASS_LAYOUT_HELPER_LOCATION;
 40 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION;
 41 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
 42 
<a name="2" id="anc2"></a><span class="line-removed"> 43 import java.lang.ref.Reference;</span>
 44 import java.util.EnumMap;
 45 
 46 import org.graalvm.compiler.api.directives.GraalDirectives;
 47 import org.graalvm.compiler.core.common.CompressEncoding;
 48 import org.graalvm.compiler.core.common.GraalOptions;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 50 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 51 import org.graalvm.compiler.core.common.type.ObjectStamp;
 52 import org.graalvm.compiler.core.common.type.Stamp;
 53 import org.graalvm.compiler.core.common.type.StampFactory;
 54 import org.graalvm.compiler.core.common.type.StampPair;
 55 import org.graalvm.compiler.debug.DebugCloseable;
 56 import org.graalvm.compiler.debug.DebugHandlersFactory;
 57 import org.graalvm.compiler.debug.GraalError;
 58 import org.graalvm.compiler.graph.Node;
 59 import org.graalvm.compiler.graph.NodeInputList;
 60 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 61 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 62 import org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode;
 63 import org.graalvm.compiler.hotspot.nodes.HotSpotCompressionNode;
 64 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 65 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 66 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;
 67 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 68 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 69 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 70 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 71 import org.graalvm.compiler.hotspot.nodes.profiling.ProfileNode;
 72 import org.graalvm.compiler.hotspot.nodes.type.HotSpotNarrowOopStamp;
 73 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 74 import org.graalvm.compiler.hotspot.nodes.type.MethodPointerStamp;
 75 import org.graalvm.compiler.hotspot.replacements.AssertionSnippets;
 76 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 77 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 78 import org.graalvm.compiler.hotspot.replacements.HashCodeSnippets;
<a name="3" id="anc3"></a>
 79 import org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets;
 80 import org.graalvm.compiler.hotspot.replacements.HotSpotSerialWriteBarrierSnippets;
 81 import org.graalvm.compiler.hotspot.replacements.HubGetClassNode;
 82 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 83 import org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets;
 84 import org.graalvm.compiler.hotspot.replacements.KlassLayoutHelperNode;
 85 import org.graalvm.compiler.hotspot.replacements.LoadExceptionObjectSnippets;
 86 import org.graalvm.compiler.hotspot.replacements.MonitorSnippets;
<a name="4" id="anc4"></a><span class="line-removed"> 87 import org.graalvm.compiler.hotspot.replacements.NewObjectSnippets;</span>
 88 import org.graalvm.compiler.hotspot.replacements.ObjectCloneSnippets;
 89 import org.graalvm.compiler.hotspot.replacements.ObjectSnippets;
 90 import org.graalvm.compiler.hotspot.replacements.StringToBytesSnippets;
 91 import org.graalvm.compiler.hotspot.replacements.UnsafeCopyMemoryNode;
<a name="5" id="anc5"></a><span class="line-removed"> 92 import org.graalvm.compiler.hotspot.replacements.UnsafeLoadSnippets;</span>
 93 import org.graalvm.compiler.hotspot.replacements.UnsafeSnippets;
 94 import org.graalvm.compiler.hotspot.replacements.aot.ResolveConstantSnippets;
 95 import org.graalvm.compiler.hotspot.replacements.arraycopy.HotSpotArraycopySnippets;
 96 import org.graalvm.compiler.hotspot.replacements.profiling.ProfileSnippets;
 97 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets;
 98 import org.graalvm.compiler.hotspot.word.KlassPointer;
 99 import org.graalvm.compiler.nodes.AbstractBeginNode;
100 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
101 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
102 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
103 import org.graalvm.compiler.nodes.ConstantNode;
104 import org.graalvm.compiler.nodes.FixedNode;
105 import org.graalvm.compiler.nodes.GetObjectAddressNode;
106 import org.graalvm.compiler.nodes.Invoke;
107 import org.graalvm.compiler.nodes.LogicNode;
108 import org.graalvm.compiler.nodes.LoweredCallTargetNode;
109 import org.graalvm.compiler.nodes.NodeView;
110 import org.graalvm.compiler.nodes.ParameterNode;
111 import org.graalvm.compiler.nodes.SafepointNode;
112 import org.graalvm.compiler.nodes.StartNode;
113 import org.graalvm.compiler.nodes.StructuredGraph;
114 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
115 import org.graalvm.compiler.nodes.UnwindNode;
116 import org.graalvm.compiler.nodes.ValueNode;
117 import org.graalvm.compiler.nodes.calc.AddNode;
118 import org.graalvm.compiler.nodes.calc.FloatingNode;
119 import org.graalvm.compiler.nodes.calc.IntegerDivRemNode;
120 import org.graalvm.compiler.nodes.calc.IsNullNode;
121 import org.graalvm.compiler.nodes.calc.RemNode;
122 import org.graalvm.compiler.nodes.debug.StringToBytesNode;
123 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
124 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
125 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
126 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
127 import org.graalvm.compiler.nodes.extended.GetClassNode;
128 import org.graalvm.compiler.nodes.extended.LoadHubNode;
129 import org.graalvm.compiler.nodes.extended.LoadMethodNode;
130 import org.graalvm.compiler.nodes.extended.OSRLocalNode;
131 import org.graalvm.compiler.nodes.extended.OSRLockNode;
132 import org.graalvm.compiler.nodes.extended.OSRMonitorEnterNode;
133 import org.graalvm.compiler.nodes.extended.OSRStartNode;
134 import org.graalvm.compiler.nodes.extended.StoreHubNode;
135 import org.graalvm.compiler.nodes.gc.G1ArrayRangePostWriteBarrier;
136 import org.graalvm.compiler.nodes.gc.G1ArrayRangePreWriteBarrier;
137 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;
138 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;
139 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;
140 import org.graalvm.compiler.nodes.gc.SerialArrayRangeWriteBarrier;
141 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;
142 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
143 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
144 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
145 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
146 import org.graalvm.compiler.nodes.java.InstanceOfNode;
147 import org.graalvm.compiler.nodes.java.LoadExceptionObjectNode;
148 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
149 import org.graalvm.compiler.nodes.java.MonitorExitNode;
150 import org.graalvm.compiler.nodes.java.MonitorIdNode;
151 import org.graalvm.compiler.nodes.java.NewArrayNode;
152 import org.graalvm.compiler.nodes.java.NewInstanceNode;
153 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
154 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
155 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
<a name="6" id="anc6"></a><span class="line-modified">156 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>
157 import org.graalvm.compiler.nodes.memory.ReadNode;
158 import org.graalvm.compiler.nodes.memory.WriteNode;
159 import org.graalvm.compiler.nodes.memory.address.AddressNode;
160 import org.graalvm.compiler.nodes.spi.LoweringProvider;
161 import org.graalvm.compiler.nodes.spi.LoweringTool;
<a name="7" id="anc7"></a>
162 import org.graalvm.compiler.nodes.spi.StampProvider;
163 import org.graalvm.compiler.nodes.type.StampTool;
164 import org.graalvm.compiler.nodes.util.GraphUtil;
165 import org.graalvm.compiler.options.OptionValues;
166 import org.graalvm.compiler.replacements.DefaultJavaLoweringProvider;
167 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
168 import org.graalvm.compiler.replacements.arraycopy.ArrayCopySnippets;
169 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyWithDelayedLoweringNode;
170 import org.graalvm.compiler.replacements.nodes.AssertionNode;
171 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
172 import jdk.internal.vm.compiler.word.LocationIdentity;
173 
174 import jdk.vm.ci.code.TargetDescription;
175 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
176 import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
177 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
178 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
179 import jdk.vm.ci.meta.JavaConstant;
180 import jdk.vm.ci.meta.JavaKind;
181 import jdk.vm.ci.meta.JavaType;
182 import jdk.vm.ci.meta.MetaAccessProvider;
183 import jdk.vm.ci.meta.ResolvedJavaField;
184 import jdk.vm.ci.meta.ResolvedJavaType;
185 
186 /**
187  * HotSpot implementation of {@link LoweringProvider}.
188  */
189 public abstract class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {
190 
191     protected final HotSpotGraalRuntimeProvider runtime;
192     protected final HotSpotRegistersProvider registers;
193     protected final HotSpotConstantReflectionProvider constantReflection;
194 
195     protected InstanceOfSnippets.Templates instanceofSnippets;
<a name="8" id="anc8"></a><span class="line-modified">196     protected NewObjectSnippets.Templates newObjectSnippets;</span>
197     protected MonitorSnippets.Templates monitorSnippets;
198     protected HotSpotSerialWriteBarrierSnippets.Templates serialWriteBarrierSnippets;
199     protected HotSpotG1WriteBarrierSnippets.Templates g1WriteBarrierSnippets;
200     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
<a name="9" id="anc9"></a><span class="line-removed">201     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;</span>
202     protected AssertionSnippets.Templates assertionSnippets;
203     protected ArrayCopySnippets.Templates arraycopySnippets;
204     protected StringToBytesSnippets.Templates stringToBytesSnippets;
205     protected HashCodeSnippets.Templates hashCodeSnippets;
206     protected ResolveConstantSnippets.Templates resolveConstantSnippets;
207     protected ProfileSnippets.Templates profileSnippets;
208     protected ObjectSnippets.Templates objectSnippets;
209     protected UnsafeSnippets.Templates unsafeSnippets;
210     protected ObjectCloneSnippets.Templates objectCloneSnippets;
211     protected ForeignCallSnippets.Templates foreignCallSnippets;
212 
213     public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,
<a name="10" id="anc10"></a><span class="line-modified">214                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {</span>
<span class="line-modified">215         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);</span>
216         this.runtime = runtime;
217         this.registers = registers;
218         this.constantReflection = constantReflection;
219 
220     }
221 
222     @Override
223     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
224         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
225 
226         assert target == providers.getCodeCache().getTarget();
227         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
<a name="11" id="anc11"></a><span class="line-modified">228         newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);</span>
229         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
230         g1WriteBarrierSnippets = new HotSpotG1WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
231         serialWriteBarrierSnippets = new HotSpotSerialWriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
232         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
<a name="12" id="anc12"></a><span class="line-removed">233         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);</span>
234         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
235         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
236         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
237         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
238         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);
239         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
240         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);
241         objectSnippets = new ObjectSnippets.Templates(options, factories, providers, target);
242         unsafeSnippets = new UnsafeSnippets.Templates(options, factories, providers, target);
243         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
244             // AOT only introduced in JDK 9
245             profileSnippets = null;
246         } else {
247             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);
248         }
249     }
250 
251     public ArrayCopySnippets.Templates getArraycopySnippets() {
252         return arraycopySnippets;
253     }
254 
255     public MonitorSnippets.Templates getMonitorSnippets() {
256         return monitorSnippets;
257     }
258 
259     @Override
260     @SuppressWarnings(&quot;try&quot;)
261     public void lower(Node n, LoweringTool tool) {
262         StructuredGraph graph = (StructuredGraph) n.graph();
263         try (DebugCloseable context = n.withNodeSourcePosition()) {
264             if (n instanceof Invoke) {
265                 lowerInvoke((Invoke) n, tool, graph);
266             } else if (n instanceof LoadMethodNode) {
267                 lowerLoadMethodNode((LoadMethodNode) n);
268             } else if (n instanceof GetClassNode) {
269                 lowerGetClassNode((GetClassNode) n, tool, graph);
270             } else if (n instanceof StoreHubNode) {
271                 lowerStoreHubNode((StoreHubNode) n, graph);
272             } else if (n instanceof OSRStartNode) {
273                 lowerOSRStartNode((OSRStartNode) n);
274             } else if (n instanceof BytecodeExceptionNode) {
275                 lowerBytecodeExceptionNode((BytecodeExceptionNode) n);
276             } else if (n instanceof InstanceOfNode) {
277                 InstanceOfNode instanceOfNode = (InstanceOfNode) n;
278                 if (graph.getGuardsStage().areDeoptsFixed()) {
279                     instanceofSnippets.lower(instanceOfNode, tool);
280                 } else {
281                     if (instanceOfNode.allowsNull()) {
282                         ValueNode object = instanceOfNode.getValue();
283                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(InstanceOfNode.create(instanceOfNode.type(), object, instanceOfNode.profile(), instanceOfNode.getAnchor()));
284                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
285                         instanceOfNode.replaceAndDelete(newNode);
286                     }
287                 }
288             } else if (n instanceof InstanceOfDynamicNode) {
289                 InstanceOfDynamicNode instanceOfDynamicNode = (InstanceOfDynamicNode) n;
290                 if (graph.getGuardsStage().areDeoptsFixed()) {
291                     instanceofSnippets.lower(instanceOfDynamicNode, tool);
292                 } else {
293                     ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();
294                     if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {
295                         ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));
296                         instanceOfDynamicNode.setMirror(classGetHub);
297                     }
298 
299                     if (instanceOfDynamicNode.allowsNull()) {
300                         ValueNode object = instanceOfDynamicNode.getObject();
301                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(
302                                         InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));
303                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
304                         instanceOfDynamicNode.replaceAndDelete(newNode);
305                     }
306                 }
307             } else if (n instanceof ClassIsAssignableFromNode) {
308                 if (graph.getGuardsStage().areDeoptsFixed()) {
309                     instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);
310                 }
311             } else if (n instanceof NewInstanceNode) {
312                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<a name="13" id="anc13"></a><span class="line-modified">313                     newObjectSnippets.lower((NewInstanceNode) n, registers, tool);</span>
314                 }
315             } else if (n instanceof DynamicNewInstanceNode) {
316                 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;
317                 if (newInstanceNode.getClassClass() == null) {
318                     JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));
319                     ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);
320                     newInstanceNode.setClassClass(classClass);
321                 }
322                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<a name="14" id="anc14"></a><span class="line-modified">323                     newObjectSnippets.lower(newInstanceNode, registers, tool);</span>
324                 }
325             } else if (n instanceof NewArrayNode) {
326                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<a name="15" id="anc15"></a><span class="line-modified">327                     newObjectSnippets.lower((NewArrayNode) n, registers, tool);</span>
328                 }
329             } else if (n instanceof DynamicNewArrayNode) {
330                 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;
331                 if (dynamicNewArrayNode.getVoidClass() == null) {
332                     JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));
333                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
334                     dynamicNewArrayNode.setVoidClass(voidClass);
335                 }
336                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<a name="16" id="anc16"></a><span class="line-modified">337                     newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);</span>
338                 }
339             } else if (n instanceof VerifyHeapNode) {
340                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<a name="17" id="anc17"></a><span class="line-modified">341                     newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);</span>
342                 }
343             } else if (n instanceof RawMonitorEnterNode) {
344                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
345                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
346                 }
347             } else if (n instanceof MonitorExitNode) {
348                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
349                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);
350                 }
351             } else if (n instanceof ArrayCopyNode) {
352                 arraycopySnippets.lower((ArrayCopyNode) n, tool);
353             } else if (n instanceof ArrayCopyWithDelayedLoweringNode) {
354                 arraycopySnippets.lower((ArrayCopyWithDelayedLoweringNode) n, tool);
355             } else if (n instanceof G1PreWriteBarrier) {
356                 g1WriteBarrierSnippets.lower((G1PreWriteBarrier) n, tool);
357             } else if (n instanceof G1PostWriteBarrier) {
358                 g1WriteBarrierSnippets.lower((G1PostWriteBarrier) n, tool);
359             } else if (n instanceof G1ReferentFieldReadBarrier) {
360                 g1WriteBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, tool);
361             } else if (n instanceof SerialWriteBarrier) {
362                 serialWriteBarrierSnippets.lower((SerialWriteBarrier) n, tool);
363             } else if (n instanceof SerialArrayRangeWriteBarrier) {
364                 serialWriteBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);
365             } else if (n instanceof G1ArrayRangePreWriteBarrier) {
366                 g1WriteBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, tool);
367             } else if (n instanceof G1ArrayRangePostWriteBarrier) {
368                 g1WriteBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, tool);
369             } else if (n instanceof NewMultiArrayNode) {
370                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<a name="18" id="anc18"></a><span class="line-modified">371                     newObjectSnippets.lower((NewMultiArrayNode) n, tool);</span>
372                 }
373             } else if (n instanceof LoadExceptionObjectNode) {
374                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
375             } else if (n instanceof AssertionNode) {
376                 assertionSnippets.lower((AssertionNode) n, tool);
377             } else if (n instanceof StringToBytesNode) {
378                 if (graph.getGuardsStage().areDeoptsFixed()) {
379                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);
380                 }
381             } else if (n instanceof IntegerDivRemNode) {
382                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by
383                 // zero and the MIN_VALUE / -1 cases.
384             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
385                 /* No lowering, we generate LIR directly for these nodes. */
386             } else if (n instanceof ClassGetHubNode) {
387                 lowerClassGetHubNode((ClassGetHubNode) n, tool);
388             } else if (n instanceof HubGetClassNode) {
389                 lowerHubGetClassNode((HubGetClassNode) n, tool);
390             } else if (n instanceof KlassLayoutHelperNode) {
391                 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);
392             } else if (n instanceof ComputeObjectAddressNode) {
393                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
394                     lowerComputeObjectAddressNode((ComputeObjectAddressNode) n);
395                 }
396             } else if (n instanceof IdentityHashCodeNode) {
397                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
398             } else if (n instanceof ResolveDynamicConstantNode) {
399                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
400                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
401                 }
402             } else if (n instanceof ResolveConstantNode) {
403                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
404                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
405                 }
406             } else if (n instanceof ResolveMethodAndLoadCountersNode) {
407                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
408                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
409                 }
410             } else if (n instanceof InitializeKlassNode) {
411                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
412                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
413                 }
414             } else if (n instanceof ProfileNode) {
415                 profileSnippets.lower((ProfileNode) n, tool);
416             } else if (n instanceof KlassBeingInitializedCheckNode) {
<a name="19" id="anc19"></a><span class="line-modified">417                 newObjectSnippets.lower((KlassBeingInitializedCheckNode) n, registers, tool);</span>
418             } else if (n instanceof FastNotifyNode) {
419                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
420                     objectSnippets.lower(n, tool);
421                 }
422             } else if (n instanceof UnsafeCopyMemoryNode) {
423                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
424                     unsafeSnippets.lower((UnsafeCopyMemoryNode) n, tool);
425                 }
426             } else {
427                 super.lower(n, tool);
428             }
429         }
430 
431     }
432 
433     private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
434         /*
435          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it&#39;s below any
436          * potential safepoints and above it&#39;s uses.
437          */
438         for (Node use : n.usages().snapshot()) {
439             if (use instanceof FixedNode) {
440                 FixedNode fixed = (FixedNode) use;
441                 StructuredGraph graph = n.graph();
442                 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));
443                 graph.addBeforeFixed(fixed, address);
444                 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));
445                 use.replaceFirstInput(n, add);
446             } else {
447                 throw GraalError.shouldNotReachHere(&quot;Unexpected floating use of ComputeObjectAddressNode &quot; + n);
448             }
449         }
450         GraphUtil.unlinkFixedNode(n);
451         n.safeDelete();
452     }
453 
454     private void lowerKlassLayoutHelperNode(KlassLayoutHelperNode n, LoweringTool tool) {
455         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
456             return;
457         }
458         StructuredGraph graph = n.graph();
459         assert !n.getHub().isConstant();
460         AddressNode address = createOffsetAddress(graph, n.getHub(), runtime.getVMConfig().klassLayoutHelperOffset);
461         n.replaceAtUsagesAndDelete(graph.unique(new FloatingReadNode(address, KLASS_LAYOUT_HELPER_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE)));
462     }
463 
464     private void lowerHubGetClassNode(HubGetClassNode n, LoweringTool tool) {
465         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
466             return;
467         }
468 
469         ValueNode hub = n.getHub();
470         GraalHotSpotVMConfig vmConfig = runtime.getVMConfig();
471         StructuredGraph graph = n.graph();
472         assert !hub.isConstant() || GraalOptions.ImmutableCode.getValue(graph.getOptions());
473         AddressNode mirrorAddress = createOffsetAddress(graph, hub, vmConfig.classMirrorOffset);
474         FloatingReadNode read = graph.unique(
475                         new FloatingReadNode(mirrorAddress, CLASS_MIRROR_LOCATION, null, vmConfig.classMirrorIsHandle ? StampFactory.forKind(target.wordJavaKind) : n.stamp(NodeView.DEFAULT),
476                                         null, BarrierType.NONE));
477         if (vmConfig.classMirrorIsHandle) {
478             AddressNode address = createOffsetAddress(graph, read, 0);
479             read = graph.unique(new FloatingReadNode(address, CLASS_MIRROR_HANDLE_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
480         }
481         n.replaceAtUsagesAndDelete(read);
482     }
483 
484     private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {
485         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
486             return;
487         }
488 
489         StructuredGraph graph = n.graph();
490         assert !n.getValue().isConstant();
491         AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);
492         FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
493         n.replaceAtUsagesAndDelete(read);
494     }
495 
496     private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {
497         if (invoke.callTarget() instanceof MethodCallTargetNode) {
498             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
499             NodeInputList&lt;ValueNode&gt; parameters = callTarget.arguments();
500             ValueNode receiver = parameters.isEmpty() ? null : parameters.get(0);
501 
502             if (!callTarget.isStatic()) {
503                 assert receiver != null : &quot;non-static call must have a receiver&quot;;
504                 if (receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp &amp;&amp; !StampTool.isPointerNonNull(receiver)) {
505                     ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);
506                     parameters.set(0, nonNullReceiver);
507                     receiver = nonNullReceiver;
508                 }
509             }
510             JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());
511 
512             LoweredCallTargetNode loweredCallTarget = null;
513             OptionValues options = graph.getOptions();
514             if (InlineVTableStubs.getValue(options) &amp;&amp; callTarget.invokeKind().isIndirect() &amp;&amp; (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {
515                 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
516                 ResolvedJavaType receiverType = invoke.getReceiverType();
517                 if (hsMethod.isInVirtualMethodTable(receiverType)) {
518                     JavaKind wordKind = runtime.getTarget().wordJavaKind;
519                     ValueNode hub = createReadHub(graph, receiver, tool);
520 
521                     ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);
522                     // We use LocationNode.ANY_LOCATION for the reads that access the
523                     // compiled code entry as HotSpot does not guarantee they are final
524                     // values.
525                     int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;
526                     AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);
527                     ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));
528 
529                     loweredCallTarget = graph.add(new HotSpotIndirectCallTargetNode(metaspaceMethod, compiledEntry, parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),
530                                     signature, callTarget.targetMethod(),
531                                     HotSpotCallingConventionType.JavaCall, callTarget.invokeKind()));
532 
533                     graph.addBeforeFixed(invoke.asNode(), metaspaceMethod);
534                     graph.addAfterFixed(metaspaceMethod, compiledEntry);
535                 }
536             }
537 
538             if (loweredCallTarget == null) {
539                 loweredCallTarget = graph.add(new HotSpotDirectCallTargetNode(parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),
540                                 signature, callTarget.targetMethod(),
541                                 HotSpotCallingConventionType.JavaCall,
542                                 callTarget.invokeKind()));
543             }
544             callTarget.replaceAndDelete(loweredCallTarget);
545         }
546     }
547 
548     private CompressEncoding getOopEncoding() {
549         return runtime.getVMConfig().getOopEncoding();
550     }
551 
552     @Override
553     protected Stamp loadCompressedStamp(ObjectStamp stamp) {
554         return HotSpotNarrowOopStamp.compressed(stamp, getOopEncoding());
555     }
556 
557     @Override
558     protected ValueNode newCompressionNode(CompressionOp op, ValueNode value) {
559         return new HotSpotCompressionNode(op, value, getOopEncoding());
560     }
561 
562     @Override
563     public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {
564         HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;
565         JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());
566         return ConstantNode.forConstant(base, metaAccess, graph);
567     }
568 
569     @Override
570     protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {
571         /*
572          * Anchor the read of the element klass to the cfg, because it is only valid when arrayClass
573          * is an object class, which might not be the case in other parts of the compiled method.
574          */
575         AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);
576         return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));
577     }
578 
579     private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {
580         StructuredGraph graph = loadMethodNode.graph();
581         HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();
582         ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());
583         graph.replaceFixed(loadMethodNode, metaspaceMethod);
584     }
585 
586     private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {
587         StampProvider stampProvider = tool.getStampProvider();
588         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));
589         HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));
590         getClass.replaceAtUsagesAndDelete(hubGetClass);
591         hub.lower(tool);
592         hubGetClass.lower(tool);
593     }
594 
595     private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {
596         WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());
597         graph.replaceFixed(storeHub, hub);
598     }
599 
600     private void lowerOSRStartNode(OSRStartNode osrStart) {
601         StructuredGraph graph = osrStart.graph();
602         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
603             StartNode newStart = graph.add(new StartNode());
604             ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));
605             ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));
606             migrationEnd.setStateAfter(osrStart.stateAfter());
607             newStart.setNext(migrationEnd);
608             FixedNode next = osrStart.next();
609             osrStart.setNext(null);
610             migrationEnd.setNext(next);
611             graph.setStart(newStart);
612 
613             final int wordSize = target.wordSize;
614 
615             // @formatter:off
616             // taken from c2 locals_addr = osr_buf + (max_locals-1)*wordSize)
617             // @formatter:on
618             int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;
619             for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {
620                 int size = osrLocal.getStackKind().getSlotCount();
621                 int offset = localsOffset - (osrLocal.index() + size - 1) * wordSize;
622                 AddressNode address = createOffsetAddress(graph, buffer, offset);
623                 ReadNode load = graph.add(new ReadNode(address, any(), osrLocal.stamp(NodeView.DEFAULT), BarrierType.NONE));
624                 osrLocal.replaceAndDelete(load);
625                 graph.addBeforeFixed(migrationEnd, load);
626             }
627 
628             // @formatter:off
629             // taken from c2 monitors_addr = osr_buf + (max_locals+mcnt*2-1)*wordSize);
630             // @formatter:on
631             final int lockCount = osrStart.stateAfter().locksSize();
632             final int locksOffset = (graph.method().getMaxLocals() + lockCount * 2 - 1) * wordSize;
633 
634             // first initialize the lock slots for all enters with the displaced marks read from the
635             // buffer
636             for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {
637                 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();
638                 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();
639                 final int index = lock.index();
640 
641                 final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;
642                 final int offsetLockObject = locksOffset - index * 2 * wordSize;
643 
644                 // load the displaced mark from the osr buffer
645                 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);
646                 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
647                 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);
648 
649                 // we need to initialize the stack slot for the lock
650                 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));
651                 graph.addBeforeFixed(migrationEnd, beginLockScope);
652 
653                 // write the displaced mark to the correct stack slot
654                 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);
655                 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE, false));
656                 graph.addBeforeFixed(migrationEnd, writeStackSlot);
657 
658                 // load the lock object from the osr buffer
659                 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);
660                 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
661                 lock.replaceAndDelete(loadObject);
662                 graph.addBeforeFixed(migrationEnd, loadObject);
663             }
664 
665             osrStart.replaceAtUsagesAndDelete(newStart);
666         }
667     }
668 
669     static final class Exceptions {
670         protected static final EnumMap&lt;BytecodeExceptionKind, RuntimeException&gt; cachedExceptions;
671 
672         static {
673             cachedExceptions = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
674             cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));
675             cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));
676             cachedExceptions.put(BytecodeExceptionKind.CLASS_CAST, clearStackTrace(new ClassCastException()));
677             cachedExceptions.put(BytecodeExceptionKind.ARRAY_STORE, clearStackTrace(new ArrayStoreException()));
678             cachedExceptions.put(BytecodeExceptionKind.DIVISION_BY_ZERO, clearStackTrace(new ArithmeticException()));
679         }
680 
681         private static RuntimeException clearStackTrace(RuntimeException ex) {
682             ex.setStackTrace(new StackTraceElement[0]);
683             return ex;
684         }
685     }
686 
687     public static final class RuntimeCalls {
688         public static final EnumMap&lt;BytecodeExceptionKind, ForeignCallDescriptor&gt; runtimeCalls;
689 
690         static {
691             runtimeCalls = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
692             runtimeCalls.put(BytecodeExceptionKind.ARRAY_STORE, new ForeignCallDescriptor(&quot;createArrayStoreException&quot;, ArrayStoreException.class, Object.class));
693             runtimeCalls.put(BytecodeExceptionKind.CLASS_CAST, new ForeignCallDescriptor(&quot;createClassCastException&quot;, ClassCastException.class, Object.class, KlassPointer.class));
694             runtimeCalls.put(BytecodeExceptionKind.NULL_POINTER, new ForeignCallDescriptor(&quot;createNullPointerException&quot;, NullPointerException.class));
695             runtimeCalls.put(BytecodeExceptionKind.OUT_OF_BOUNDS, new ForeignCallDescriptor(&quot;createOutOfBoundsException&quot;, ArrayIndexOutOfBoundsException.class, int.class, int.class));
696             runtimeCalls.put(BytecodeExceptionKind.DIVISION_BY_ZERO, new ForeignCallDescriptor(&quot;createDivisionByZeroException&quot;, ArithmeticException.class));
697             runtimeCalls.put(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createIntegerExactOverflowException&quot;, ArithmeticException.class));
698             runtimeCalls.put(BytecodeExceptionKind.LONG_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createLongExactOverflowException&quot;, ArithmeticException.class));
699         }
700     }
701 
702     private void throwCachedException(BytecodeExceptionNode node) {
703         if (IS_IN_NATIVE_IMAGE) {
704             throw new InternalError(&quot;Can&#39;t throw exception from SVM object&quot;);
705         }
706         Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());
707         assert exception != null;
708 
709         StructuredGraph graph = node.graph();
710         FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);
711         graph.replaceFixedWithFloating(node, exceptionNode);
712     }
713 
714     private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {
715         if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {
716             throwCachedException(node);
717             return;
718         }
719 
720         ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());
721         assert descriptor != null;
722 
723         StructuredGraph graph = node.graph();
724         ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));
725         /*
726          * The original BytecodeExceptionNode has a rethrowException FrameState which isn&#39;t suitable
727          * for deopt because the exception to be thrown come from this call so it&#39;s not available in
728          * the debug info. The foreign call needs a stateDuring instead so it can deopt with a
729          * pending exception.
730          */
731         foreignCallNode.setStateAfter(node.createStateDuring());
732         graph.replaceFixedWithFixed(node, foreignCallNode);
733     }
734 
735     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {
736         return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));
737     }
738 
739     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {
740         assert vtableEntryOffset &gt; 0;
741         // We use LocationNode.ANY_LOCATION for the reads that access the vtable
742         // entry as HotSpot does not guarantee that this is a final value.
743         Stamp methodStamp = MethodPointerStamp.methodNonNull();
744         AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);
745         ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));
746         return metaspaceMethod;
747     }
748 
749     @Override
750     protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {
751         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
752             return graph.unique(new LoadHubNode(tool.getStampProvider(), object));
753         }
754         assert !object.isConstant() || object.isNullConstant();
755 
756         KlassPointerStamp hubStamp = KlassPointerStamp.klassNonNull();
757         if (runtime.getVMConfig().useCompressedClassPointers) {
758             hubStamp = hubStamp.compressed(runtime.getVMConfig().getKlassEncoding());
759         }
760 
761         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
762         LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;
763         FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));
764         if (runtime.getVMConfig().useCompressedClassPointers) {
765             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
766         } else {
767             return memoryRead;
768         }
769     }
770 
771     private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
772         assert !object.isConstant() || object.asConstant().isDefaultForKind();
773 
774         ValueNode writeValue = value;
775         if (runtime.getVMConfig().useCompressedClassPointers) {
776             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
777         }
778 
779         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
780         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE, false));
781     }
782 
<a name="20" id="anc20"></a><span class="line-removed">783     @Override</span>
<span class="line-removed">784     protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {</span>
<span class="line-removed">785         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;</span>
<span class="line-removed">786         if (loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;</span>
<span class="line-removed">787                         loadField.getName().equals(&quot;referent&quot;)) {</span>
<span class="line-removed">788             return BarrierType.WEAK_FIELD;</span>
<span class="line-removed">789         }</span>
<span class="line-removed">790         return super.fieldLoadBarrierType(f);</span>
<span class="line-removed">791     }</span>
<span class="line-removed">792 </span>
793     @Override
794     public int fieldOffset(ResolvedJavaField f) {
795         return f.getOffset();
796     }
797 
798     @Override
799     public int arrayLengthOffset() {
800         return runtime.getVMConfig().arrayOopDescLengthOffset();
801     }
802 
803     @Override
<a name="21" id="anc21"></a><span class="line-modified">804     protected final JavaKind getStorageKind(ResolvedJavaField field) {</span>
805         return field.getJavaKind();
806     }
807 
808     @Override
809     public ObjectCloneSnippets.Templates getObjectCloneSnippets() {
810         return objectCloneSnippets;
811     }
812 
813     @Override
814     public ForeignCallSnippets.Templates getForeignCallSnippets() {
815         return foreignCallSnippets;
816     }
817 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
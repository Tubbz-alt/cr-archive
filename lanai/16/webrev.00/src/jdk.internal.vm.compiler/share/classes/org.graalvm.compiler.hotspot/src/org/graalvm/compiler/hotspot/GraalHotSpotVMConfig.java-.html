<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot;
 26 
 27 import java.lang.reflect.Field;
 28 import java.lang.reflect.Modifier;
 29 import java.util.List;
 30 
 31 import org.graalvm.compiler.core.common.CompressEncoding;
 32 import org.graalvm.compiler.hotspot.nodes.GraalHotSpotVMConfigNode;
 33 
 34 import jdk.vm.ci.common.JVMCIError;
 35 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 36 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 37 import jdk.vm.ci.meta.ResolvedJavaMethod;
 38 
 39 /**
 40  * Used to access native configuration details.
 41  */
 42 public class GraalHotSpotVMConfig extends GraalHotSpotVMConfigBase {
 43 
 44     GraalHotSpotVMConfig(HotSpotVMConfigStore store) {
 45         super(store);
 46 
 47         assert narrowKlassShift &lt;= logKlassAlignment;
 48         assert narrowOopShift &lt;= logMinObjAlignment();
 49         oopEncoding = new CompressEncoding(narrowOopBase, narrowOopShift);
 50         klassEncoding = new CompressEncoding(narrowKlassBase, narrowKlassShift);
 51 
 52         assert check();
 53     }
 54 
 55     private final CompressEncoding oopEncoding;
 56     private final CompressEncoding klassEncoding;
 57     private final String markWord = versioned.markWordFieldType;
 58 
 59     public CompressEncoding getOopEncoding() {
 60         return oopEncoding;
 61     }
 62 
 63     public CompressEncoding getKlassEncoding() {
 64         return klassEncoding;
 65     }
 66 
 67     public final boolean cAssertions = getConstant(&quot;ASSERT&quot;, Boolean.class);
 68 
 69     public final int codeEntryAlignment = getFlag(&quot;CodeEntryAlignment&quot;, Integer.class);
 70     public final boolean enableContended = getFlag(&quot;EnableContended&quot;, Boolean.class);
 71     public final boolean restrictContended = getFlag(&quot;RestrictContended&quot;, Boolean.class);
 72     public final int contendedPaddingWidth = getFlag(&quot;ContendedPaddingWidth&quot;, Integer.class);
 73     public final boolean verifyOops = getFlag(&quot;VerifyOops&quot;, Boolean.class);
 74     public final boolean ciTime = getFlag(&quot;CITime&quot;, Boolean.class);
 75     public final boolean ciTimeEach = getFlag(&quot;CITimeEach&quot;, Boolean.class);
 76     public final boolean dontCompileHugeMethods = getFlag(&quot;DontCompileHugeMethods&quot;, Boolean.class);
 77     public final int hugeMethodLimit = getFlag(&quot;HugeMethodLimit&quot;, Integer.class);
 78     public final boolean printInlining = getFlag(&quot;PrintInlining&quot;, Boolean.class);
 79     public final boolean inline = getFlag(&quot;Inline&quot;, Boolean.class);
 80     public final boolean inlineNotify = versioned.inlineNotify;
 81     public final boolean useFastLocking = getFlag(&quot;JVMCIUseFastLocking&quot;, Boolean.class);
 82     public final boolean forceUnreachable = getFlag(&quot;ForceUnreachable&quot;, Boolean.class);
 83     public final int codeSegmentSize = getFlag(&quot;CodeCacheSegmentSize&quot;, Integer.class);
 84     public final boolean foldStableValues = getFlag(&quot;FoldStableValues&quot;, Boolean.class);
 85     public final int maxVectorSize = getFlag(&quot;MaxVectorSize&quot;, Integer.class);
 86 
 87     public final boolean verifyBeforeGC = getFlag(&quot;VerifyBeforeGC&quot;, Boolean.class);
 88     public final boolean verifyAfterGC = getFlag(&quot;VerifyAfterGC&quot;, Boolean.class);
 89 
 90     public final boolean useTLAB = getFlag(&quot;UseTLAB&quot;, Boolean.class);
 91     public final boolean useBiasedLocking = getFlag(&quot;UseBiasedLocking&quot;, Boolean.class);
 92     public final boolean usePopCountInstruction = getFlag(&quot;UsePopCountInstruction&quot;, Boolean.class);
 93     public final boolean useAESIntrinsics = getFlag(&quot;UseAESIntrinsics&quot;, Boolean.class);
 94     public final boolean useAESCTRIntrinsics = getFlag(&quot;UseAESCTRIntrinsics&quot;, Boolean.class, false);
 95     public final boolean useCRC32Intrinsics = getFlag(&quot;UseCRC32Intrinsics&quot;, Boolean.class);
 96     public final boolean useCRC32CIntrinsics = versioned.useCRC32CIntrinsics;
 97     public final boolean threadLocalHandshakes = versioned.threadLocalHandshakes;
 98 
 99     private final boolean useMultiplyToLenIntrinsic = getFlag(&quot;UseMultiplyToLenIntrinsic&quot;, Boolean.class);
100     private final boolean useSHA1Intrinsics = getFlag(&quot;UseSHA1Intrinsics&quot;, Boolean.class);
101     private final boolean useSHA256Intrinsics = getFlag(&quot;UseSHA256Intrinsics&quot;, Boolean.class);
102     private final boolean useSHA512Intrinsics = getFlag(&quot;UseSHA512Intrinsics&quot;, Boolean.class);
103     private final boolean useGHASHIntrinsics = getFlag(&quot;UseGHASHIntrinsics&quot;, Boolean.class, false);
104     private final boolean useBase64Intrinsics = getFlag(&quot;UseBASE64Intrinsics&quot;, Boolean.class, false);
105     private final boolean useMontgomeryMultiplyIntrinsic = getFlag(&quot;UseMontgomeryMultiplyIntrinsic&quot;, Boolean.class, false);
106     private final boolean useMontgomerySquareIntrinsic = getFlag(&quot;UseMontgomerySquareIntrinsic&quot;, Boolean.class, false);
107     private final boolean useMulAddIntrinsic = getFlag(&quot;UseMulAddIntrinsic&quot;, Boolean.class, false);
108     private final boolean useSquareToLenIntrinsic = getFlag(&quot;UseSquareToLenIntrinsic&quot;, Boolean.class, false);
109     public final boolean useVectorizedMismatchIntrinsic = getFlag(&quot;UseVectorizedMismatchIntrinsic&quot;, Boolean.class, false);
110     public final boolean useFMAIntrinsics = getFlag(&quot;UseFMA&quot;, Boolean.class, false);
111 
112     public final boolean preserveFramePointer = getFlag(&quot;PreserveFramePointer&quot;, Boolean.class, false);
113 
114     /*
115      * These are methods because in some JDKs the flags are visible but the stubs themselves haven&#39;t
116      * been exported so we have to check both if the flag is on and if we have the stub.
117      */
118     public boolean useMultiplyToLenIntrinsic() {
119         return useMultiplyToLenIntrinsic &amp;&amp; multiplyToLen != 0;
120     }
121 
122     public boolean useSHA1Intrinsics() {
123         return useSHA1Intrinsics &amp;&amp; sha1ImplCompress != 0 &amp;&amp; sha1ImplCompressMultiBlock != 0;
124     }
125 
126     public boolean useSHA256Intrinsics() {
127         return useSHA256Intrinsics &amp;&amp; sha256ImplCompress != 0 &amp;&amp; sha256ImplCompressMultiBlock != 0;
128     }
129 
130     public boolean useSHA512Intrinsics() {
131         return useSHA512Intrinsics &amp;&amp; sha512ImplCompress != 0 &amp;&amp; sha512ImplCompressMultiBlock != 0;
132     }
133 
134     public boolean useGHASHIntrinsics() {
135         return useGHASHIntrinsics &amp;&amp; ghashProcessBlocks != 0;
136     }
137 
138     public boolean useBase64Intrinsics() {
139         return useBase64Intrinsics &amp;&amp; base64EncodeBlock != 0;
140     }
141 
142     public boolean useMontgomeryMultiplyIntrinsic() {
143         return useMontgomeryMultiplyIntrinsic &amp;&amp; montgomeryMultiply != 0;
144     }
145 
146     public boolean useMontgomerySquareIntrinsic() {
147         return useMontgomerySquareIntrinsic &amp;&amp; montgomerySquare != 0;
148     }
149 
150     public boolean useMulAddIntrinsic() {
151         return useMulAddIntrinsic &amp;&amp; mulAdd != 0;
152     }
153 
154     public boolean useSquareToLenIntrinsic() {
155         return useSquareToLenIntrinsic &amp;&amp; squareToLen != 0;
156     }
157 
158     public boolean inlineNotify() {
159         return inlineNotify &amp;&amp; notifyAddress != 0;
160     }
161 
162     public boolean inlineNotifyAll() {
163         return inlineNotify &amp;&amp; notifyAllAddress != 0;
164     }
165 
166     public final boolean useG1GC = getFlag(&quot;UseG1GC&quot;, Boolean.class);
167     public final boolean useCMSGC = getFlag(&quot;UseConcMarkSweepGC&quot;, Boolean.class, false);
168 
169     public final int allocatePrefetchStyle = getFlag(&quot;AllocatePrefetchStyle&quot;, Integer.class);
170     public final int allocatePrefetchInstr = getFlag(&quot;AllocatePrefetchInstr&quot;, Integer.class);
171     public final int allocatePrefetchLines = getFlag(&quot;AllocatePrefetchLines&quot;, Integer.class);
172     public final int allocateInstancePrefetchLines = getFlag(&quot;AllocateInstancePrefetchLines&quot;, Integer.class);
173     public final int allocatePrefetchStepSize = getFlag(&quot;AllocatePrefetchStepSize&quot;, Integer.class);
174     public final int allocatePrefetchDistance = getFlag(&quot;AllocatePrefetchDistance&quot;, Integer.class);
175 
176     private final long universeCollectedHeap = getFieldValue(&quot;CompilerToVM::Data::Universe_collectedHeap&quot;, Long.class, &quot;CollectedHeap*&quot;);
177     private final int collectedHeapTotalCollectionsOffset = getFieldOffset(&quot;CollectedHeap::_total_collections&quot;, Integer.class, &quot;unsigned int&quot;);
178 
179     public long gcTotalCollectionsAddress() {
180         return universeCollectedHeap + collectedHeapTotalCollectionsOffset;
181     }
182 
183     public final boolean useDeferredInitBarriers = getFlag(&quot;ReduceInitialCardMarks&quot;, Boolean.class);
184 
185     // Compressed Oops related values.
186     public final boolean useCompressedOops = getFlag(&quot;UseCompressedOops&quot;, Boolean.class);
187     public final boolean useCompressedClassPointers = getFlag(&quot;UseCompressedClassPointers&quot;, Boolean.class);
188 
189     public final long narrowOopBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_oop_base&quot;, Long.class, &quot;address&quot;);
190     public final int narrowOopShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_oop_shift&quot;, Integer.class, &quot;int&quot;);
191     public final int objectAlignment = getFlag(&quot;ObjectAlignmentInBytes&quot;, Integer.class);
192 
193     public final int minObjAlignment() {
194         return objectAlignment / heapWordSize;
195     }
196 
197     public final int logMinObjAlignment() {
198         return (int) (Math.log(objectAlignment) / Math.log(2));
199     }
200 
201     public final int narrowKlassSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_narrowKlass&quot;, Integer.class, &quot;int&quot;);
202     public final long narrowKlassBase = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_base&quot;, Long.class, &quot;address&quot;);
203     public final int narrowKlassShift = getFieldValue(&quot;CompilerToVM::Data::Universe_narrow_klass_shift&quot;, Integer.class, &quot;int&quot;);
204     public final int logKlassAlignment = getConstant(&quot;LogKlassAlignmentInBytes&quot;, Integer.class);
205 
206     public final int stackShadowPages = getFlag(&quot;StackShadowPages&quot;, Integer.class);
207     public final int stackReservedPages = getFlag(&quot;StackReservedPages&quot;, Integer.class, 0);
208     public final boolean useStackBanging = getFlag(&quot;UseStackBanging&quot;, Boolean.class);
209     public final int stackBias = getConstant(&quot;STACK_BIAS&quot;, Integer.class);
210     public final int vmPageSize = getFieldValue(&quot;CompilerToVM::Data::vm_page_size&quot;, Integer.class, &quot;int&quot;);
211 
212     public final int markOffset = getFieldOffset(&quot;oopDesc::_mark&quot;, Integer.class, markWord);
213     public final int hubOffset = getFieldOffset(&quot;oopDesc::_metadata._klass&quot;, Integer.class, &quot;Klass*&quot;);
214 
215     public final int prototypeMarkWordOffset = getFieldOffset(&quot;Klass::_prototype_header&quot;, Integer.class, markWord);
216     public final int subklassOffset = getFieldOffset(&quot;Klass::_subklass&quot;, Integer.class, &quot;Klass*&quot;);
217     public final int nextSiblingOffset = getFieldOffset(&quot;Klass::_next_sibling&quot;, Integer.class, &quot;Klass*&quot;);
218     public final int superCheckOffsetOffset = getFieldOffset(&quot;Klass::_super_check_offset&quot;, Integer.class, &quot;juint&quot;);
219     public final int secondarySuperCacheOffset = getFieldOffset(&quot;Klass::_secondary_super_cache&quot;, Integer.class, &quot;Klass*&quot;);
220     public final int secondarySupersOffset = getFieldOffset(&quot;Klass::_secondary_supers&quot;, Integer.class, &quot;Array&lt;Klass*&gt;*&quot;);
221 
222     public final boolean classMirrorIsHandle = versioned.classMirrorIsHandle;
223     public final int classMirrorOffset = versioned.classMirrorOffset;
224 
225     public final int klassSuperKlassOffset = getFieldOffset(&quot;Klass::_super&quot;, Integer.class, &quot;Klass*&quot;);
226     public final int klassModifierFlagsOffset = getFieldOffset(&quot;Klass::_modifier_flags&quot;, Integer.class, &quot;jint&quot;);
227     public final int klassAccessFlagsOffset = getFieldOffset(&quot;Klass::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
228     public final int klassLayoutHelperOffset = getFieldOffset(&quot;Klass::_layout_helper&quot;, Integer.class, &quot;jint&quot;);
229 
230     public final int klassLayoutHelperNeutralValue = getConstant(&quot;Klass::_lh_neutral_value&quot;, Integer.class);
231     public final int layoutHelperLog2ElementSizeShift = getConstant(&quot;Klass::_lh_log2_element_size_shift&quot;, Integer.class);
232     public final int layoutHelperLog2ElementSizeMask = getConstant(&quot;Klass::_lh_log2_element_size_mask&quot;, Integer.class);
233     public final int layoutHelperElementTypeShift = getConstant(&quot;Klass::_lh_element_type_shift&quot;, Integer.class);
234     public final int layoutHelperElementTypeMask = getConstant(&quot;Klass::_lh_element_type_mask&quot;, Integer.class);
235     public final int layoutHelperHeaderSizeShift = getConstant(&quot;Klass::_lh_header_size_shift&quot;, Integer.class);
236     public final int layoutHelperHeaderSizeMask = getConstant(&quot;Klass::_lh_header_size_mask&quot;, Integer.class);
237     public final int layoutHelperArrayTagShift = getConstant(&quot;Klass::_lh_array_tag_shift&quot;, Integer.class);
238     public final int layoutHelperArrayTagTypeValue = getConstant(&quot;Klass::_lh_array_tag_type_value&quot;, Integer.class);
239     public final int layoutHelperArrayTagObjectValue = getConstant(&quot;Klass::_lh_array_tag_obj_value&quot;, Integer.class);
240 
241     /**
242      * This filters out the bit that differentiates a type array from an object array.
243      */
244     public int layoutHelperElementTypePrimitiveInPlace() {
245         return (layoutHelperArrayTagTypeValue &amp; ~layoutHelperArrayTagObjectValue) &lt;&lt; layoutHelperArrayTagShift;
246     }
247 
248     public final int vtableEntrySize = getFieldValue(&quot;CompilerToVM::Data::sizeof_vtableEntry&quot;, Integer.class, &quot;int&quot;);
249     public final int vtableEntryMethodOffset = getFieldOffset(&quot;vtableEntry::_method&quot;, Integer.class, &quot;Method*&quot;);
250 
251     public final int instanceKlassInitStateOffset = getFieldOffset(&quot;InstanceKlass::_init_state&quot;, Integer.class, &quot;u1&quot;);
252     public final int instanceKlassInitThreadOffset = getFieldOffset(&quot;InstanceKlass::_init_thread&quot;, Integer.class, &quot;Thread*&quot;, -1);
253     public final int instanceKlassConstantsOffset = getFieldOffset(&quot;InstanceKlass::_constants&quot;, Integer.class, &quot;ConstantPool*&quot;);
254     public final int instanceKlassFieldsOffset = getFieldOffset(&quot;InstanceKlass::_fields&quot;, Integer.class, &quot;Array&lt;u2&gt;*&quot;);
255     public final int klassVtableStartOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_start_offset&quot;, Integer.class, &quot;int&quot;);
256     public final int klassVtableLengthOffset = getFieldValue(&quot;CompilerToVM::Data::Klass_vtable_length_offset&quot;, Integer.class, &quot;int&quot;);
257 
258     public final int instanceKlassStateLinked = getConstant(&quot;InstanceKlass::linked&quot;, Integer.class);
259     public final int instanceKlassStateBeingInitialized = getConstant(&quot;InstanceKlass::being_initialized&quot;, Integer.class, -1);
260     public final int instanceKlassStateFullyInitialized = getConstant(&quot;InstanceKlass::fully_initialized&quot;, Integer.class);
261 
262     public final int arrayOopDescSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_arrayOopDesc&quot;, Integer.class, &quot;int&quot;);
263 
264     /**
265      * The offset of the array length word in an array object&#39;s header.
266      *
267      * See {@code arrayOopDesc::length_offset_in_bytes()}.
268      */
269     public final int arrayOopDescLengthOffset() {
270         return useCompressedClassPointers ? hubOffset + narrowKlassSize : arrayOopDescSize;
271     }
272 
273     public final int arrayU1LengthOffset = getFieldOffset(&quot;Array&lt;int&gt;::_length&quot;, Integer.class, &quot;int&quot;);
274     public final int arrayU1DataOffset = getFieldOffset(&quot;Array&lt;u1&gt;::_data&quot;, Integer.class);
275     public final int arrayU2DataOffset = getFieldOffset(&quot;Array&lt;u2&gt;::_data&quot;, Integer.class);
276     public final int metaspaceArrayLengthOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_length&quot;, Integer.class, &quot;int&quot;);
277     public final int metaspaceArrayBaseOffset = getFieldOffset(&quot;Array&lt;Klass*&gt;::_data[0]&quot;, Integer.class, &quot;Klass*&quot;);
278 
279     public final int arrayClassElementOffset = getFieldOffset(&quot;ObjArrayKlass::_element_klass&quot;, Integer.class, &quot;Klass*&quot;);
280 
281     public final int fieldInfoAccessFlagsOffset = getConstant(&quot;FieldInfo::access_flags_offset&quot;, Integer.class);
282     public final int fieldInfoNameIndexOffset = getConstant(&quot;FieldInfo::name_index_offset&quot;, Integer.class);
283     public final int fieldInfoSignatureIndexOffset = getConstant(&quot;FieldInfo::signature_index_offset&quot;, Integer.class);
284     public final int fieldInfoInitvalIndexOffset = getConstant(&quot;FieldInfo::initval_index_offset&quot;, Integer.class);
285     public final int fieldInfoLowPackedOffset = getConstant(&quot;FieldInfo::low_packed_offset&quot;, Integer.class);
286     public final int fieldInfoHighPackedOffset = getConstant(&quot;FieldInfo::high_packed_offset&quot;, Integer.class);
287     public final int fieldInfoFieldSlots = getConstant(&quot;FieldInfo::field_slots&quot;, Integer.class);
288 
289     public final int fieldInfoTagSize = getConstant(&quot;FIELDINFO_TAG_SIZE&quot;, Integer.class);
290 
291     public final int jvmAccMonitorMatch = getConstant(&quot;JVM_ACC_MONITOR_MATCH&quot;, Integer.class);
292     public final int jvmAccHasMonitorBytecodes = getConstant(&quot;JVM_ACC_HAS_MONITOR_BYTECODES&quot;, Integer.class);
293     public final int jvmAccHasFinalizer = getConstant(&quot;JVM_ACC_HAS_FINALIZER&quot;, Integer.class);
294     public final int jvmAccFieldInternal = getConstant(&quot;JVM_ACC_FIELD_INTERNAL&quot;, Integer.class);
295     public final int jvmAccFieldStable = getConstant(&quot;JVM_ACC_FIELD_STABLE&quot;, Integer.class);
296     public final int jvmAccFieldHasGenericSignature = getConstant(&quot;JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE&quot;, Integer.class);
297     public final int jvmAccWrittenFlags = getConstant(&quot;JVM_ACC_WRITTEN_FLAGS&quot;, Integer.class);
298     public final int jvmAccSynthetic = getConstant(&quot;JVM_ACC_SYNTHETIC&quot;, Integer.class);
299 
300     public final int jvmciCompileStateCanPostOnExceptionsOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_post_on_exceptions&quot;);
301     public final int jvmciCompileStateCanPopFrameOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_pop_frame&quot;);
302     public final int jvmciCompileStateCanAccessLocalVariablesOffset = getJvmciJvmtiCapabilityOffset(&quot;_jvmti_can_access_local_variables&quot;);
303 
304     // Integer.MIN_VALUE if not available
305     private int getJvmciJvmtiCapabilityOffset(String name) {
306         int offset = getFieldOffset(&quot;JVMCICompileState::&quot; + name, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);
307         if (offset == Integer.MIN_VALUE) {
308             // JDK 12
309             offset = getFieldOffset(&quot;JVMCIEnv::&quot; + name, Integer.class, &quot;jbyte&quot;, Integer.MIN_VALUE);
310         }
311         return offset;
312     }
313 
314     public final int threadTlabOffset = getFieldOffset(&quot;Thread::_tlab&quot;, Integer.class, &quot;ThreadLocalAllocBuffer&quot;);
315     public final int javaThreadAnchorOffset = getFieldOffset(&quot;JavaThread::_anchor&quot;, Integer.class, &quot;JavaFrameAnchor&quot;);
316     public final int javaThreadShouldPostOnExceptionsFlagOffset = getFieldOffset(&quot;JavaThread::_should_post_on_exceptions_flag&quot;, Integer.class, &quot;int&quot;, Integer.MIN_VALUE);
317     public final int threadObjectOffset = getFieldOffset(&quot;JavaThread::_threadObj&quot;, Integer.class, &quot;oop&quot;);
318     public final int osThreadOffset = getFieldOffset(&quot;JavaThread::_osthread&quot;, Integer.class, &quot;OSThread*&quot;, Integer.MAX_VALUE);
319     public final int threadIsMethodHandleReturnOffset = getFieldOffset(&quot;JavaThread::_is_method_handle_return&quot;, Integer.class, &quot;int&quot;);
320     public final int threadObjectResultOffset = getFieldOffset(&quot;JavaThread::_vm_result&quot;, Integer.class, &quot;oop&quot;);
321     public final int jvmciCountersThreadOffset = getFieldOffset(&quot;JavaThread::_jvmci_counters&quot;, Integer.class, &quot;jlong*&quot;);
322     public final int doingUnsafeAccessOffset = getFieldOffset(&quot;JavaThread::_doing_unsafe_access&quot;, Integer.class, &quot;bool&quot;, Integer.MAX_VALUE);
323     public final int javaThreadReservedStackActivationOffset = versioned.javaThreadReservedStackActivationOffset;
324     public final int jniEnvironmentOffset = getFieldOffset(&quot;JavaThread::_jni_environment&quot;, Integer.class, &quot;JNIEnv&quot;, Integer.MIN_VALUE);
325 
326     public boolean requiresReservedStackCheck(List&lt;ResolvedJavaMethod&gt; methods) {
327         if (enableStackReservedZoneAddress != 0 &amp;&amp; methods != null) {
328             for (ResolvedJavaMethod method : methods) {
329                 if (((HotSpotResolvedJavaMethod) method).hasReservedStackAccess()) {
330                     return true;
331                 }
332             }
333         }
334         return false;
335     }
336 
337     /**
338      * An invalid value for {@link #rtldDefault}.
339      */
340     public static final long INVALID_RTLD_DEFAULT_HANDLE = 0xDEADFACE;
341 
342     /**
343      * Address of the library lookup routine. The C signature of this routine is:
344      *
345      * &lt;pre&gt;
346      *     void* (const char *filename, char *ebuf, int ebuflen)
347      * &lt;/pre&gt;
348      */
349     public final long dllLoad = getAddress(&quot;os::dll_load&quot;);
350 
351     /**
352      * Address of the library lookup routine. The C signature of this routine is:
353      *
354      * &lt;pre&gt;
355      *     void* (void* handle, const char* name)
356      * &lt;/pre&gt;
357      */
358     public final long dllLookup = getAddress(&quot;os::dll_lookup&quot;);
359 
360     /**
361      * A pseudo-handle which when used as the first argument to {@link #dllLookup} means lookup will
362      * return the first occurrence of the desired symbol using the default library search order. If
363      * this field is {@value #INVALID_RTLD_DEFAULT_HANDLE}, then this capability is not supported on
364      * the current platform.
365      */
366     public final long rtldDefault = getAddress(&quot;RTLD_DEFAULT&quot;, osName.equals(&quot;bsd&quot;) || osName.equals(&quot;linux&quot;) ? null : INVALID_RTLD_DEFAULT_HANDLE);
367 
368     /**
369      * This field is used to pass exception objects into and out of the runtime system during
370      * exception handling for compiled code.
371      */
372     public final int threadExceptionOopOffset = getFieldOffset(&quot;JavaThread::_exception_oop&quot;, Integer.class, &quot;oop&quot;);
373     public final int threadExceptionPcOffset = getFieldOffset(&quot;JavaThread::_exception_pc&quot;, Integer.class, &quot;address&quot;);
374     public final int pendingExceptionOffset = getFieldOffset(&quot;ThreadShadow::_pending_exception&quot;, Integer.class, &quot;oop&quot;);
375 
376     public final int pendingDeoptimizationOffset = getFieldOffset(&quot;JavaThread::_pending_deoptimization&quot;, Integer.class, &quot;int&quot;);
377     public final int pendingTransferToInterpreterOffset = getFieldOffset(&quot;JavaThread::_pending_transfer_to_interpreter&quot;, Integer.class, &quot;bool&quot;);
378 
379     private final int javaFrameAnchorLastJavaSpOffset = getFieldOffset(&quot;JavaFrameAnchor::_last_Java_sp&quot;, Integer.class, &quot;intptr_t*&quot;);
380     private final int javaFrameAnchorLastJavaPcOffset = getFieldOffset(&quot;JavaFrameAnchor::_last_Java_pc&quot;, Integer.class, &quot;address&quot;);
381 
382     public final int pendingFailedSpeculationOffset;
383     {
384         String name = &quot;JavaThread::_pending_failed_speculation&quot;;
385         int offset = -1;
386         try {
387             offset = getFieldOffset(name, Integer.class, &quot;jlong&quot;);
388         } catch (JVMCIError e) {
389             try {
390                 offset = getFieldOffset(name, Integer.class, &quot;long&quot;);
391             } catch (JVMCIError e2) {
392             }
393         }
394         if (offset == -1) {
395             throw new JVMCIError(&quot;cannot get offset of field &quot; + name + &quot; with type long or jlong&quot;);
396         }
397         pendingFailedSpeculationOffset = offset;
398     }
399 
400     public int threadLastJavaSpOffset() {
401         return javaThreadAnchorOffset + javaFrameAnchorLastJavaSpOffset;
402     }
403 
404     public int threadLastJavaPcOffset() {
405         return javaThreadAnchorOffset + javaFrameAnchorLastJavaPcOffset;
406     }
407 
408     public int threadLastJavaFpOffset() {
409         assert osArch.equals(&quot;aarch64&quot;) || osArch.equals(&quot;amd64&quot;);
410         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_last_Java_fp&quot;, Integer.class, &quot;intptr_t*&quot;);
411     }
412 
413     public int threadJavaFrameAnchorFlagsOffset() {
414         assert osArch.equals(&quot;sparc&quot;);
415         return javaThreadAnchorOffset + getFieldOffset(&quot;JavaFrameAnchor::_flags&quot;, Integer.class, &quot;int&quot;);
416     }
417 
418     public final int runtimeCallStackSize = getConstant(&quot;frame::arg_reg_save_area_bytes&quot;, Integer.class, intRequiredOnAMD64);
419     public final int frameInterpreterFrameSenderSpOffset = getConstant(&quot;frame::interpreter_frame_sender_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
420     public final int frameInterpreterFrameLastSpOffset = getConstant(&quot;frame::interpreter_frame_last_sp_offset&quot;, Integer.class, intRequiredOnAMD64);
421 
422     public final int osThreadInterruptedOffset = getFieldOffset(&quot;OSThread::_interrupted&quot;, Integer.class, &quot;jint&quot;, Integer.MAX_VALUE);
423 
424     public final long markWordHashShift = getConstant(markWordField(&quot;hash_shift&quot;), Long.class);
425 
426     public final int biasedLockMaskInPlace = getConstant(markWordField(&quot;biased_lock_mask_in_place&quot;), Integer.class);
427     public final int ageMaskInPlace = getConstant(markWordField(&quot;age_mask_in_place&quot;), Integer.class);
428     public final int epochMaskInPlace = getConstant(markWordField(&quot;epoch_mask_in_place&quot;), Integer.class);
429     public final long markWordHashMask = getConstant(markWordField(&quot;hash_mask&quot;), Long.class);
430     public final long markWordHashMaskInPlace = getConstant(markWordField(&quot;hash_mask_in_place&quot;), Long.class);
431 
432     public final int unlockedMask = getConstant(markWordField(&quot;unlocked_value&quot;), Integer.class);
433     public final int monitorMask = getConstant(markWordField(&quot;monitor_value&quot;), Integer.class, -1);
434     public final int biasedLockPattern = getConstant(markWordField(&quot;biased_lock_pattern&quot;), Integer.class);
435 
436     // This field has no type in vmStructs.cpp
437     public final int objectMonitorOwner = getFieldOffset(&quot;ObjectMonitor::_owner&quot;, Integer.class, null, -1);
438     public final int objectMonitorRecursions = getFieldOffset(&quot;ObjectMonitor::_recursions&quot;, Integer.class, &quot;intptr_t&quot;, -1);
439     public final int objectMonitorCxq = getFieldOffset(&quot;ObjectMonitor::_cxq&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
440     public final int objectMonitorEntryList = getFieldOffset(&quot;ObjectMonitor::_EntryList&quot;, Integer.class, &quot;ObjectWaiter*&quot;, -1);
441     public final int objectMonitorSucc = getFieldOffset(&quot;ObjectMonitor::_succ&quot;, Integer.class, &quot;Thread*&quot;, -1);
442 
443     public final int markWordNoHashInPlace = getConstant(markWordField(&quot;no_hash_in_place&quot;), Integer.class);
444     public final int markWordNoLockInPlace = getConstant(markWordField(&quot;no_lock_in_place&quot;), Integer.class);
445 
446     /**
447      * See {@code markOopDesc::prototype()}/{@code markWord::prototype()}.
448      */
449     public long arrayPrototypeMarkWord() {
450         return markWordNoHashInPlace | markWordNoLockInPlace;
451     }
452 
453     /**
454      * See {@code markOopDesc::copy_set_hash()}/{@code markWord::copy_set_hash()}.
455      */
456     public long tlabIntArrayMarkWord() {
457         long tmp = arrayPrototypeMarkWord() &amp; (~markWordHashMaskInPlace);
458         tmp |= ((0x2 &amp; markWordHashMask) &lt;&lt; markWordHashShift);
459         return tmp;
460     }
461 
462     private String markWordField(String simpleName) {
463         return versioned.markWordClassName + &quot;::&quot; + simpleName;
464     }
465 
466     /**
467      * Mark word right shift to get identity hash code.
468      */
469     public final int identityHashCodeShift = getConstant(markWordField(&quot;hash_shift&quot;), Integer.class);
470 
471     /**
472      * Identity hash code value when uninitialized.
473      */
474     public final int uninitializedIdentityHashCodeValue = getConstant(markWordField(&quot;no_hash&quot;), Integer.class);
475 
476     public final int methodAccessFlagsOffset = getFieldOffset(&quot;Method::_access_flags&quot;, Integer.class, &quot;AccessFlags&quot;);
477     public final int methodConstMethodOffset = getFieldOffset(&quot;Method::_constMethod&quot;, Integer.class, &quot;ConstMethod*&quot;);
478     public final int methodIntrinsicIdOffset = versioned.methodIntrinsicIdOffset;
479     public final int methodFlagsOffset = versioned.methodFlagsOffset;
480     public final int methodVtableIndexOffset = getFieldOffset(&quot;Method::_vtable_index&quot;, Integer.class, &quot;int&quot;);
481 
482     public final int methodCountersOffset = getFieldOffset(&quot;Method::_method_counters&quot;, Integer.class, &quot;MethodCounters*&quot;);
483     public final int methodDataOffset = getFieldOffset(&quot;Method::_method_data&quot;, Integer.class, &quot;MethodData*&quot;);
484     public final int methodCompiledEntryOffset = getFieldOffset(&quot;Method::_from_compiled_entry&quot;, Integer.class, &quot;address&quot;);
485     public final int methodCodeOffset = versioned.methodCodeOffset;
486 
487     public final int methodFlagsCallerSensitive = getConstant(&quot;Method::_caller_sensitive&quot;, Integer.class);
488     public final int methodFlagsForceInline = getConstant(&quot;Method::_force_inline&quot;, Integer.class);
489     public final int methodFlagsDontInline = getConstant(&quot;Method::_dont_inline&quot;, Integer.class);
490     public final int methodFlagsHidden = getConstant(&quot;Method::_hidden&quot;, Integer.class);
491     public final int nonvirtualVtableIndex = getConstant(&quot;Method::nonvirtual_vtable_index&quot;, Integer.class);
492     public final int invalidVtableIndex = getConstant(&quot;Method::invalid_vtable_index&quot;, Integer.class);
493 
494     public final int invocationCounterOffset = getFieldOffset(&quot;MethodCounters::_invocation_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
495     public final int backedgeCounterOffset = getFieldOffset(&quot;MethodCounters::_backedge_counter&quot;, Integer.class, &quot;InvocationCounter&quot;);
496     public final int invocationCounterIncrement = versioned.invocationCounterIncrement;
497     public final int invocationCounterShift = versioned.invocationCounterShift;
498 
499     public final int nmethodEntryOffset = getFieldOffset(&quot;nmethod::_verified_entry_point&quot;,
500                     Integer.class, &quot;address&quot;);
501     public final int compilationLevelFullOptimization = getConstant(&quot;CompLevel_full_optimization&quot;,
502                     Integer.class);
503 
504     public final int constantPoolSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_ConstantPool&quot;, Integer.class, &quot;int&quot;);
505     public final int constantPoolLengthOffset = getFieldOffset(&quot;ConstantPool::_length&quot;,
506                     Integer.class, &quot;int&quot;);
507 
508     public final int heapWordSize = getConstant(&quot;HeapWordSize&quot;, Integer.class);
509 
510     /**
511      * Bit pattern that represents a non-oop. Neither the high bits nor the low bits of this value
512      * are allowed to look like (respectively) the high or low bits of a real oop.
513      */
514     public final long nonOopBits = getFieldValue(&quot;CompilerToVM::Data::Universe_non_oop_bits&quot;, Long.class, &quot;void*&quot;);
515 
516     public final long verifyOopCounterAddress = getFieldAddress(&quot;StubRoutines::_verify_oop_count&quot;, &quot;jint&quot;);
517     public final long verifyOopMask = getFieldValue(&quot;CompilerToVM::Data::Universe_verify_oop_mask&quot;, Long.class, &quot;uintptr_t&quot;);
518     public final long verifyOopBits = getFieldValue(&quot;CompilerToVM::Data::Universe_verify_oop_bits&quot;, Long.class, &quot;uintptr_t&quot;);
519 
520     public final int logOfHRGrainBytes = getFieldValue(&quot;HeapRegion::LogOfHRGrainBytes&quot;, Integer.class, &quot;int&quot;);
521 
522     public final long cardtableStartAddress = getFieldValue(&quot;CompilerToVM::Data::cardtable_start_address&quot;, Long.class, &quot;jbyte*&quot;);
523     public final int cardtableShift = getFieldValue(&quot;CompilerToVM::Data::cardtable_shift&quot;, Integer.class, &quot;int&quot;);
524 
525     /**
526      * This is the largest stack offset encodeable in an OopMapValue. Offsets larger than this will
527      * throw an exception during code installation.
528      */
529     public final int maxOopMapStackOffset = getFieldValue(&quot;CompilerToVM::Data::_max_oop_map_stack_offset&quot;, Integer.class, &quot;int&quot;);
530 
531     public final long safepointPollingAddress = getFieldValue(&quot;os::_polling_page&quot;, Long.class, &quot;address&quot;);
532 
533     // G1 Collector Related Values.
534 
535     public final byte dirtyCardValue = versioned.dirtyCardValue;
536     public final byte g1YoungCardValue = versioned.g1YoungCardValue;
537 
538     public final int g1SATBQueueMarkingOffset = versioned.g1SATBQueueMarkingOffset;
539     public final int g1SATBQueueIndexOffset = versioned.g1SATBQueueIndexOffset;
540     public final int g1SATBQueueBufferOffset = versioned.g1SATBQueueBufferOffset;
541     public final int g1CardQueueIndexOffset = versioned.g1CardQueueIndexOffset;
542     public final int g1CardQueueBufferOffset = versioned.g1CardQueueBufferOffset;
543 
544     public final int klassOffset = getFieldValue(&quot;java_lang_Class::_klass_offset&quot;, Integer.class, &quot;int&quot;);
545     public final int arrayKlassOffset = getFieldValue(&quot;java_lang_Class::_array_klass_offset&quot;, Integer.class, &quot;int&quot;);
546 
547     public final int basicLockSize = getFieldValue(&quot;CompilerToVM::Data::sizeof_BasicLock&quot;, Integer.class, &quot;int&quot;);
548     public final int basicLockDisplacedHeaderOffset = getFieldOffset(&quot;BasicLock::_displaced_header&quot;, Integer.class, markWord);
549 
550     public final int threadPollingPageOffset = getFieldOffset(&quot;Thread::_polling_page&quot;, Integer.class, &quot;address&quot;, -1);
551     public final int threadAllocatedBytesOffset = getFieldOffset(&quot;Thread::_allocated_bytes&quot;, Integer.class, &quot;jlong&quot;);
552 
553     public final int tlabRefillWasteIncrement = getFlag(&quot;TLABWasteIncrement&quot;, Integer.class);
554 
555     private final int threadLocalAllocBufferStartOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_start&quot;, Integer.class, &quot;HeapWord*&quot;);
556     private final int threadLocalAllocBufferEndOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_end&quot;, Integer.class, &quot;HeapWord*&quot;);
557     private final int threadLocalAllocBufferTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_top&quot;, Integer.class, &quot;HeapWord*&quot;);
558     private final int threadLocalAllocBufferPfTopOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_pf_top&quot;, Integer.class, &quot;HeapWord*&quot;);
559     private final int threadLocalAllocBufferSlowAllocationsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_slow_allocations&quot;, Integer.class, &quot;unsigned&quot;);
560     private final int threadLocalAllocBufferFastRefillWasteOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_fast_refill_waste&quot;, Integer.class, &quot;unsigned&quot;);
561     private final int threadLocalAllocBufferNumberOfRefillsOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_number_of_refills&quot;, Integer.class, &quot;unsigned&quot;);
562     private final int threadLocalAllocBufferRefillWasteLimitOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_refill_waste_limit&quot;, Integer.class, &quot;size_t&quot;);
563     private final int threadLocalAllocBufferDesiredSizeOffset = getFieldOffset(&quot;ThreadLocalAllocBuffer::_desired_size&quot;, Integer.class, &quot;size_t&quot;);
564 
565     public int tlabSlowAllocationsOffset() {
566         return threadTlabOffset + threadLocalAllocBufferSlowAllocationsOffset;
567     }
568 
569     public int tlabFastRefillWasteOffset() {
570         return threadTlabOffset + threadLocalAllocBufferFastRefillWasteOffset;
571     }
572 
573     public int tlabNumberOfRefillsOffset() {
574         return threadTlabOffset + threadLocalAllocBufferNumberOfRefillsOffset;
575     }
576 
577     public int tlabRefillWasteLimitOffset() {
578         return threadTlabOffset + threadLocalAllocBufferRefillWasteLimitOffset;
579     }
580 
581     public int threadTlabSizeOffset() {
582         return threadTlabOffset + threadLocalAllocBufferDesiredSizeOffset;
583     }
584 
585     public int threadTlabStartOffset() {
586         return threadTlabOffset + threadLocalAllocBufferStartOffset;
587     }
588 
589     public int threadTlabEndOffset() {
590         return threadTlabOffset + threadLocalAllocBufferEndOffset;
591     }
592 
593     public int threadTlabTopOffset() {
594         return threadTlabOffset + threadLocalAllocBufferTopOffset;
595     }
596 
597     public int threadTlabPfTopOffset() {
598         return threadTlabOffset + threadLocalAllocBufferPfTopOffset;
599     }
600 
601     public final int tlabAlignmentReserve = getFieldValue(&quot;CompilerToVM::Data::ThreadLocalAllocBuffer_alignment_reserve&quot;, Integer.class, &quot;size_t&quot;);
602 
603     public final boolean tlabStats = getFlag(&quot;TLABStats&quot;, Boolean.class);
604 
605     // We set 0x10 as default value to disable DC ZVA if this field is not present in HotSpot.
606     // ARMv8-A architecture reference manual D12.2.35 Data Cache Zero ID register says:
607     // * BS, bits [3:0] indicate log2 of the DC ZVA block size in (4-byte) words.
608     // * DZP, bit [4] of indicates whether use of DC ZVA instruction is prohibited.
609     public final int psrInfoDczidValue = getFieldValue(&quot;VM_Version::_psr_info.dczid_el0&quot;, Integer.class, &quot;uint32_t&quot;, 0x10);
610 
611     // FIXME This is only temporary until the GC code is changed.
612     public final boolean inlineContiguousAllocationSupported = getFieldValue(&quot;CompilerToVM::Data::_supports_inline_contig_alloc&quot;, Boolean.class);
613     public final long heapEndAddress = getFieldValue(&quot;CompilerToVM::Data::_heap_end_addr&quot;, Long.class, &quot;HeapWord**&quot;);
614     public final long heapTopAddress = versioned.heapTopAddress;
615 
616     public final boolean cmsIncrementalMode = getFlag(&quot;CMSIncrementalMode&quot;, Boolean.class, false);
617 
618     public final long inlineCacheMissStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;, Long.class, &quot;address&quot;);
619     public final long handleWrongMethodStub = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;, Long.class, &quot;address&quot;);
620 
621     public final long deoptBlobUnpack = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;, Long.class, &quot;address&quot;);
622     public final long deoptBlobUnpackWithExceptionInTLS = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls&quot;, Long.class, &quot;address&quot;, 0L);
623     public final long deoptBlobUncommonTrap = getFieldValue(&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;, Long.class, &quot;address&quot;);
624 
625     public final long codeCacheLowBound = versioned.codeCacheLowBound;
626     public final long codeCacheHighBound = versioned.codeCacheHighBound;
627 
628     public final long aescryptEncryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_encryptBlock&quot;, Long.class, &quot;address&quot;);
629     public final long aescryptDecryptBlockStub = getFieldValue(&quot;StubRoutines::_aescrypt_decryptBlock&quot;, Long.class, &quot;address&quot;);
630     public final long cipherBlockChainingEncryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, Long.class, &quot;address&quot;);
631     public final long cipherBlockChainingDecryptAESCryptStub = getFieldValue(&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, Long.class, &quot;address&quot;);
632     public final long updateBytesCRC32Stub = getFieldValue(&quot;StubRoutines::_updateBytesCRC32&quot;, Long.class, &quot;address&quot;);
633     public final long crcTableAddress = getFieldValue(&quot;StubRoutines::_crc_table_adr&quot;, Long.class, &quot;address&quot;);
634 
635     public final long sha1ImplCompress = getFieldValue(&quot;StubRoutines::_sha1_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
636     public final long sha1ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha1_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
637     public final long sha256ImplCompress = getFieldValue(&quot;StubRoutines::_sha256_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
638     public final long sha256ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha256_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
639     public final long sha512ImplCompress = getFieldValue(&quot;StubRoutines::_sha512_implCompress&quot;, Long.class, &quot;address&quot;, 0L);
640     public final long sha512ImplCompressMultiBlock = getFieldValue(&quot;StubRoutines::_sha512_implCompressMB&quot;, Long.class, &quot;address&quot;, 0L);
641     public final long multiplyToLen = getFieldValue(&quot;StubRoutines::_multiplyToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
642 
643     public final long counterModeAESCrypt = getFieldValue(&quot;StubRoutines::_counterMode_AESCrypt&quot;, Long.class, &quot;address&quot;, 0L);
644     public final long ghashProcessBlocks = getFieldValue(&quot;StubRoutines::_ghash_processBlocks&quot;, Long.class, &quot;address&quot;, 0L);
645     public final long base64EncodeBlock = getFieldValue(&quot;StubRoutines::_base64_encodeBlock&quot;, Long.class, &quot;address&quot;, 0L);
646     public final long crc32cTableTddr = getFieldValue(&quot;StubRoutines::_crc32c_table_addr&quot;, Long.class, &quot;address&quot;, 0L);
647     public final long updateBytesCRC32C = getFieldValue(&quot;StubRoutines::_updateBytesCRC32C&quot;, Long.class, &quot;address&quot;, 0L);
648     public final long updateBytesAdler32 = getFieldValue(&quot;StubRoutines::_updateBytesAdler32&quot;, Long.class, &quot;address&quot;, 0L);
649     public final long squareToLen = getFieldValue(&quot;StubRoutines::_squareToLen&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
650     public final long mulAdd = getFieldValue(&quot;StubRoutines::_mulAdd&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
651     public final long montgomeryMultiply = getFieldValue(&quot;StubRoutines::_montgomeryMultiply&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
652     public final long montgomerySquare = getFieldValue(&quot;StubRoutines::_montgomerySquare&quot;, Long.class, &quot;address&quot;, longRequiredOnAMD64);
653     public final long vectorizedMismatch = getFieldValue(&quot;StubRoutines::_vectorizedMismatch&quot;, Long.class, &quot;address&quot;, 0L);
654 
655     public final long throwDelayedStackOverflowErrorEntry = versioned.throwDelayedStackOverflowErrorEntry;
656 
657     public final long jbyteArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
658     public final long jshortArraycopy = getFieldValue(&quot;StubRoutines::_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
659     public final long jintArraycopy = getFieldValue(&quot;StubRoutines::_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
660     public final long jlongArraycopy = getFieldValue(&quot;StubRoutines::_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
661     public final long oopArraycopy = getFieldValue(&quot;StubRoutines::_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
662     public final long oopArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
663     public final long jbyteDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
664     public final long jshortDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
665     public final long jintDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
666     public final long jlongDisjointArraycopy = getFieldValue(&quot;StubRoutines::_jlong_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
667     public final long oopDisjointArraycopy = getFieldValue(&quot;StubRoutines::_oop_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
668     public final long oopDisjointArraycopyUninit = getFieldValue(&quot;StubRoutines::_oop_disjoint_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
669     public final long jbyteAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jbyte_arraycopy&quot;, Long.class, &quot;address&quot;);
670     public final long jshortAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jshort_arraycopy&quot;, Long.class, &quot;address&quot;);
671     public final long jintAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jint_arraycopy&quot;, Long.class, &quot;address&quot;);
672     public final long jlongAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jlong_arraycopy&quot;, Long.class, &quot;address&quot;);
673     public final long oopAlignedArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_oop_arraycopy&quot;, Long.class, &quot;address&quot;);
674     public final long oopAlignedArraycopyUninit = getFieldValue(&quot;StubRoutines::_arrayof_oop_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
675     public final long jbyteAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jbyte_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
676     public final long jshortAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jshort_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
677     public final long jintAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jint_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
678     public final long jlongAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_jlong_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
679     public final long oopAlignedDisjointArraycopy = getFieldValue(&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy&quot;, Long.class, &quot;address&quot;);
680     public final long oopAlignedDisjointArraycopyUninit = getFieldValue(&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
681     public final long checkcastArraycopy = getFieldValue(&quot;StubRoutines::_checkcast_arraycopy&quot;, Long.class, &quot;address&quot;);
682     public final long checkcastArraycopyUninit = getFieldValue(&quot;StubRoutines::_checkcast_arraycopy_uninit&quot;, Long.class, &quot;address&quot;);
683     public final long unsafeArraycopy = getFieldValue(&quot;StubRoutines::_unsafe_arraycopy&quot;, Long.class, &quot;address&quot;);
684     public final long genericArraycopy = getFieldValue(&quot;StubRoutines::_generic_arraycopy&quot;, Long.class, &quot;address&quot;);
685 
686     // Allocation stubs that throw an exception when allocation fails
687     public final long newInstanceAddress = getAddress(&quot;JVMCIRuntime::new_instance&quot;);
688     public final long newArrayAddress = getAddress(&quot;JVMCIRuntime::new_array&quot;);
689     public final long newMultiArrayAddress = getAddress(&quot;JVMCIRuntime::new_multi_array&quot;);
690     public final long dynamicNewInstanceAddress = getAddress(&quot;JVMCIRuntime::dynamic_new_instance&quot;);
691 
692     // Allocation stubs that return null when allocation fails
693     public final long newInstanceOrNullAddress = getAddress(&quot;JVMCIRuntime::new_instance_or_null&quot;, 0L);
694     public final long newArrayOrNullAddress = getAddress(&quot;JVMCIRuntime::new_array_or_null&quot;, 0L);
695     public final long newMultiArrayOrNullAddress = getAddress(&quot;JVMCIRuntime::new_multi_array_or_null&quot;, 0L);
696     public final long dynamicNewInstanceOrNullAddress = getAddress(&quot;JVMCIRuntime::dynamic_new_instance_or_null&quot;, 0L);
697 
698     public boolean areNullAllocationStubsAvailable() {
699         return newInstanceOrNullAddress != 0L;
700     }
701 
702     /**
703      * Checks that HotSpot implements all or none of the allocate-or-null stubs.
704      */
705     private boolean checkNullAllocationStubs() {
706         if (newInstanceOrNullAddress == 0L) {
707             assert newArrayOrNullAddress == 0L;
708             assert newMultiArrayOrNullAddress == 0L;
709             assert dynamicNewInstanceOrNullAddress == 0L;
710         } else {
711             assert newArrayOrNullAddress != 0L;
712             assert newMultiArrayOrNullAddress != 0L;
713             assert dynamicNewInstanceOrNullAddress != 0L;
714         }
715         return true;
716     }
717 
718     public final long vmMessageAddress = getAddress(&quot;JVMCIRuntime::vm_message&quot;);
719     public final long identityHashCodeAddress = getAddress(&quot;JVMCIRuntime::identity_hash_code&quot;);
720     public final long exceptionHandlerForPcAddress = getAddress(&quot;JVMCIRuntime::exception_handler_for_pc&quot;);
721     public final long monitorenterAddress = getAddress(&quot;JVMCIRuntime::monitorenter&quot;);
722     public final long monitorexitAddress = getAddress(&quot;JVMCIRuntime::monitorexit&quot;);
723     public final long notifyAddress = getAddress(&quot;JVMCIRuntime::object_notify&quot;, 0L);
724     public final long notifyAllAddress = getAddress(&quot;JVMCIRuntime::object_notifyAll&quot;, 0L);
725     public final long throwAndPostJvmtiExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_and_post_jvmti_exception&quot;);
726     public final long throwKlassExternalNameExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_klass_external_name_exception&quot;);
727     public final long throwClassCastExceptionAddress = getAddress(&quot;JVMCIRuntime::throw_class_cast_exception&quot;);
728     public final long logPrimitiveAddress = getAddress(&quot;JVMCIRuntime::log_primitive&quot;);
729     public final long logObjectAddress = getAddress(&quot;JVMCIRuntime::log_object&quot;);
730     public final long logPrintfAddress = getAddress(&quot;JVMCIRuntime::log_printf&quot;);
731     public final long vmErrorAddress = getAddress(&quot;JVMCIRuntime::vm_error&quot;);
732     public final long loadAndClearExceptionAddress = getAddress(&quot;JVMCIRuntime::load_and_clear_exception&quot;);
733     public final long writeBarrierPreAddress = getAddress(&quot;JVMCIRuntime::write_barrier_pre&quot;);
734     public final long writeBarrierPostAddress = getAddress(&quot;JVMCIRuntime::write_barrier_post&quot;);
735     public final long validateObject = getAddress(&quot;JVMCIRuntime::validate_object&quot;);
736 
737     public final long testDeoptimizeCallInt = getAddress(&quot;JVMCIRuntime::test_deoptimize_call_int&quot;);
738 
739     public final long registerFinalizerAddress = getAddress(&quot;SharedRuntime::register_finalizer&quot;);
740     public final long exceptionHandlerForReturnAddressAddress = getAddress(&quot;SharedRuntime::exception_handler_for_return_address&quot;);
741     public final long osrMigrationEndAddress = getAddress(&quot;SharedRuntime::OSR_migration_end&quot;);
742     public final long enableStackReservedZoneAddress = versioned.enableStackReservedZoneAddress;
743 
744     public final long javaTimeMillisAddress = getAddress(&quot;os::javaTimeMillis&quot;);
745     public final long javaTimeNanosAddress = getAddress(&quot;os::javaTimeNanos&quot;);
746     public final long arithmeticSinAddress = getFieldValue(&quot;CompilerToVM::Data::dsin&quot;, Long.class, &quot;address&quot;);
747     public final long arithmeticCosAddress = getFieldValue(&quot;CompilerToVM::Data::dcos&quot;, Long.class, &quot;address&quot;);
748     public final long arithmeticTanAddress = getFieldValue(&quot;CompilerToVM::Data::dtan&quot;, Long.class, &quot;address&quot;);
749     public final long arithmeticExpAddress = getFieldValue(&quot;CompilerToVM::Data::dexp&quot;, Long.class, &quot;address&quot;);
750     public final long arithmeticLogAddress = getFieldValue(&quot;CompilerToVM::Data::dlog&quot;, Long.class, &quot;address&quot;);
751     public final long arithmeticLog10Address = getFieldValue(&quot;CompilerToVM::Data::dlog10&quot;, Long.class, &quot;address&quot;);
752     public final long arithmeticPowAddress = getFieldValue(&quot;CompilerToVM::Data::dpow&quot;, Long.class, &quot;address&quot;);
753 
754     public final long fremAddress = getAddress(&quot;SharedRuntime::frem&quot;);
755     public final long dremAddress = getAddress(&quot;SharedRuntime::drem&quot;);
756 
757     public final int jvmciCountersSize = getFlag(&quot;JVMCICounterSize&quot;, Integer.class);
758 
759     public final long deoptimizationFetchUnrollInfo = getAddress(&quot;Deoptimization::fetch_unroll_info&quot;);
760     public final long deoptimizationUncommonTrap = getAddress(&quot;Deoptimization::uncommon_trap&quot;);
761     public final long deoptimizationUnpackFrames = getAddress(&quot;Deoptimization::unpack_frames&quot;);
762 
763     public final int deoptimizationUnpackDeopt = getConstant(&quot;Deoptimization::Unpack_deopt&quot;, Integer.class);
764     public final int deoptimizationUnpackException = getConstant(&quot;Deoptimization::Unpack_exception&quot;, Integer.class);
765     public final int deoptimizationUnpackUncommonTrap = getConstant(&quot;Deoptimization::Unpack_uncommon_trap&quot;, Integer.class);
766     public final int deoptimizationUnpackReexecute = getConstant(&quot;Deoptimization::Unpack_reexecute&quot;, Integer.class);
767 
768     public final int deoptimizationUnrollBlockSizeOfDeoptimizedFrameOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_size_of_deoptimized_frame&quot;, Integer.class, &quot;int&quot;);
769     public final int deoptimizationUnrollBlockCallerAdjustmentOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_caller_adjustment&quot;, Integer.class, &quot;int&quot;);
770     public final int deoptimizationUnrollBlockNumberOfFramesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_number_of_frames&quot;, Integer.class, &quot;int&quot;);
771     public final int deoptimizationUnrollBlockTotalFrameSizesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_total_frame_sizes&quot;, Integer.class, &quot;int&quot;);
772     public final int deoptimizationUnrollBlockUnpackKindOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_unpack_kind&quot;, Integer.class, &quot;int&quot;);
773     public final int deoptimizationUnrollBlockFrameSizesOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_frame_sizes&quot;, Integer.class, &quot;intptr_t*&quot;);
774     public final int deoptimizationUnrollBlockFramePcsOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_frame_pcs&quot;, Integer.class, &quot;address*&quot;);
775     public final int deoptimizationUnrollBlockInitialInfoOffset = getFieldOffset(&quot;Deoptimization::UnrollBlock::_initial_info&quot;, Integer.class, &quot;intptr_t&quot;);
776 
777     // Checkstyle: stop
778     public final int MARKID_VERIFIED_ENTRY = getConstant(&quot;CodeInstaller::VERIFIED_ENTRY&quot;, Integer.class);
779     public final int MARKID_UNVERIFIED_ENTRY = getConstant(&quot;CodeInstaller::UNVERIFIED_ENTRY&quot;, Integer.class);
780     public final int MARKID_OSR_ENTRY = getConstant(&quot;CodeInstaller::OSR_ENTRY&quot;, Integer.class);
781     public final int MARKID_EXCEPTION_HANDLER_ENTRY = getConstant(&quot;CodeInstaller::EXCEPTION_HANDLER_ENTRY&quot;, Integer.class);
782     public final int MARKID_DEOPT_HANDLER_ENTRY = getConstant(&quot;CodeInstaller::DEOPT_HANDLER_ENTRY&quot;, Integer.class);
783     public final int MARKID_INVOKEINTERFACE = getConstant(&quot;CodeInstaller::INVOKEINTERFACE&quot;, Integer.class);
784     public final int MARKID_INVOKEVIRTUAL = getConstant(&quot;CodeInstaller::INVOKEVIRTUAL&quot;, Integer.class);
785     public final int MARKID_INVOKESTATIC = getConstant(&quot;CodeInstaller::INVOKESTATIC&quot;, Integer.class);
786     public final int MARKID_INVOKESPECIAL = getConstant(&quot;CodeInstaller::INVOKESPECIAL&quot;, Integer.class);
787     public final int MARKID_INLINE_INVOKE = getConstant(&quot;CodeInstaller::INLINE_INVOKE&quot;, Integer.class);
788     public final int MARKID_POLL_NEAR = getConstant(&quot;CodeInstaller::POLL_NEAR&quot;, Integer.class);
789     public final int MARKID_POLL_RETURN_NEAR = getConstant(&quot;CodeInstaller::POLL_RETURN_NEAR&quot;, Integer.class);
790     public final int MARKID_POLL_FAR = getConstant(&quot;CodeInstaller::POLL_FAR&quot;, Integer.class);
791     public final int MARKID_POLL_RETURN_FAR = getConstant(&quot;CodeInstaller::POLL_RETURN_FAR&quot;, Integer.class);
792     public final int MARKID_CARD_TABLE_SHIFT = getConstant(&quot;CodeInstaller::CARD_TABLE_SHIFT&quot;, Integer.class);
793     public final int MARKID_CARD_TABLE_ADDRESS = getConstant(&quot;CodeInstaller::CARD_TABLE_ADDRESS&quot;, Integer.class);
794     public final int MARKID_INVOKE_INVALID = getConstant(&quot;CodeInstaller::INVOKE_INVALID&quot;, Integer.class);
795 
796     /**
797      * The following constants are given default values here since they are missing in the native
798      * JVMCI-8 code but are still required for {@link GraalHotSpotVMConfigNode#canonical} to work in
799      * a JDK8 environment.
800      */
801     public final int MARKID_HEAP_TOP_ADDRESS = getConstant(&quot;CodeInstaller::HEAP_TOP_ADDRESS&quot;, Integer.class, 17);
802     public final int MARKID_HEAP_END_ADDRESS = getConstant(&quot;CodeInstaller::HEAP_END_ADDRESS&quot;, Integer.class, 18);
803     public final int MARKID_NARROW_KLASS_BASE_ADDRESS = getConstant(&quot;CodeInstaller::NARROW_KLASS_BASE_ADDRESS&quot;, Integer.class, 19);
804     public final int MARKID_NARROW_OOP_BASE_ADDRESS = getConstant(&quot;CodeInstaller::NARROW_OOP_BASE_ADDRESS&quot;, Integer.class, 20);
805     public final int MARKID_CRC_TABLE_ADDRESS = getConstant(&quot;CodeInstaller::CRC_TABLE_ADDRESS&quot;, Integer.class, 21);
806     public final int MARKID_LOG_OF_HEAP_REGION_GRAIN_BYTES = getConstant(&quot;CodeInstaller::LOG_OF_HEAP_REGION_GRAIN_BYTES&quot;, Integer.class, 22);
807     public final int MARKID_INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED = getConstant(&quot;CodeInstaller::INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED&quot;, Integer.class, 23);
808 
809     // Checkstyle: resume
810 
811     protected boolean check() {
812         for (Field f : getClass().getDeclaredFields()) {
813             int modifiers = f.getModifiers();
814             if (Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isStatic(modifiers)) {
815                 assert Modifier.isFinal(modifiers) : &quot;field should be final: &quot; + f;
816             }
817         }
818 
819         assert codeEntryAlignment &gt; 0 : codeEntryAlignment;
820         assert checkNullAllocationStubs();
821         return true;
822     }
823 }
    </pre>
  </body>
</html>
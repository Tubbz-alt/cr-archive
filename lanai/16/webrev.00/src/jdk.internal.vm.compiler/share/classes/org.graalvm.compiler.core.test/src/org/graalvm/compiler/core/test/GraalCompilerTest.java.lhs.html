<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/GraalCompilerTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.core.test;
  26 
  27 import static java.lang.reflect.Modifier.isStatic;
  28 import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  29 import static org.graalvm.compiler.nodes.ConstantNode.getConstantNodes;
  30 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION;
  32 
  33 import java.lang.annotation.ElementType;
  34 import java.lang.annotation.Retention;
  35 import java.lang.annotation.RetentionPolicy;
  36 import java.lang.annotation.Target;
  37 import java.lang.reflect.Constructor;
  38 import java.lang.reflect.Executable;
  39 import java.lang.reflect.InvocationTargetException;
  40 import java.lang.reflect.Method;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collection;
  44 import java.util.Collections;
  45 import java.util.EnumMap;
  46 import java.util.HashMap;
  47 import java.util.List;
  48 import java.util.ListIterator;
  49 import java.util.Map;
  50 import java.util.Set;
  51 import java.util.concurrent.ConcurrentHashMap;
  52 import java.util.function.Supplier;
  53 
  54 import org.graalvm.compiler.api.directives.GraalDirectives;
  55 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  56 import org.graalvm.compiler.api.test.Graal;
  57 import org.graalvm.compiler.api.test.ModuleSupport;
  58 import org.graalvm.compiler.code.CompilationResult;
  59 import org.graalvm.compiler.core.CompilationPrinter;
  60 import org.graalvm.compiler.core.GraalCompiler;
  61 import org.graalvm.compiler.core.GraalCompiler.Request;
  62 import org.graalvm.compiler.core.common.CompilationIdentifier;
  63 import org.graalvm.compiler.core.common.type.StampFactory;
  64 import org.graalvm.compiler.core.target.Backend;
  65 import org.graalvm.compiler.debug.DebugContext;
  66 import org.graalvm.compiler.debug.DebugDumpHandler;
  67 import org.graalvm.compiler.debug.DebugHandlersFactory;
  68 import org.graalvm.compiler.debug.GraalError;
  69 import org.graalvm.compiler.debug.TTY;
  70 import org.graalvm.compiler.graph.Node;
  71 import org.graalvm.compiler.graph.NodeClass;
  72 import org.graalvm.compiler.graph.NodeMap;
  73 import org.graalvm.compiler.java.BytecodeParser;
  74 import org.graalvm.compiler.java.ComputeLoopFrequenciesClosure;
  75 import org.graalvm.compiler.java.GraphBuilderPhase;
  76 import org.graalvm.compiler.lir.asm.CompilationResultBuilderFactory;
  77 import org.graalvm.compiler.lir.phases.LIRSuites;
  78 import org.graalvm.compiler.loop.phases.ConvertDeoptimizeToGuardPhase;
  79 import org.graalvm.compiler.nodeinfo.NodeInfo;
  80 import org.graalvm.compiler.nodeinfo.NodeSize;
  81 import org.graalvm.compiler.nodeinfo.Verbosity;
  82 import org.graalvm.compiler.nodes.BreakpointNode;
  83 import org.graalvm.compiler.nodes.Cancellable;
  84 import org.graalvm.compiler.nodes.ConstantNode;
  85 import org.graalvm.compiler.nodes.FixedWithNextNode;
  86 import org.graalvm.compiler.nodes.FrameState;
  87 import org.graalvm.compiler.nodes.FullInfopointNode;
  88 import org.graalvm.compiler.nodes.Invoke;
  89 import org.graalvm.compiler.nodes.InvokeNode;
  90 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  91 import org.graalvm.compiler.nodes.ParameterNode;
  92 import org.graalvm.compiler.nodes.ProxyNode;
  93 import org.graalvm.compiler.nodes.ReturnNode;
  94 import org.graalvm.compiler.nodes.StructuredGraph;
  95 import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;
  96 import org.graalvm.compiler.nodes.StructuredGraph.Builder;
  97 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  98 import org.graalvm.compiler.nodes.ValueNode;
  99 import org.graalvm.compiler.nodes.cfg.Block;
 100 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 101 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 102 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 103 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 104 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 105 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 106 import org.graalvm.compiler.nodes.java.AccessFieldNode;
 107 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 108 import org.graalvm.compiler.nodes.spi.Replacements;
 109 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 110 import org.graalvm.compiler.options.OptionValues;
 111 import org.graalvm.compiler.phases.BasePhase;
 112 import org.graalvm.compiler.phases.OptimisticOptimizations;
 113 import org.graalvm.compiler.phases.Phase;
 114 import org.graalvm.compiler.phases.PhaseSuite;
 115 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 116 import org.graalvm.compiler.phases.common.inlining.InliningPhase;
 117 import org.graalvm.compiler.phases.common.inlining.info.InlineInfo;
 118 import org.graalvm.compiler.phases.common.inlining.policy.GreedyInliningPolicy;
 119 import org.graalvm.compiler.phases.schedule.SchedulePhase;
 120 import org.graalvm.compiler.phases.schedule.SchedulePhase.SchedulingStrategy;
 121 import org.graalvm.compiler.phases.tiers.HighTierContext;
 122 import org.graalvm.compiler.phases.tiers.MidTierContext;
 123 import org.graalvm.compiler.phases.tiers.Suites;
 124 import org.graalvm.compiler.phases.tiers.TargetProvider;
 125 import org.graalvm.compiler.phases.util.Providers;
 126 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 127 import org.graalvm.compiler.runtime.RuntimeProvider;
 128 import org.graalvm.compiler.test.AddExports;
 129 import org.graalvm.compiler.test.GraalTest;
 130 import org.junit.After;
 131 import org.junit.Assert;
 132 import org.junit.BeforeClass;
 133 import org.junit.Test;
 134 import org.junit.internal.AssumptionViolatedException;
 135 
 136 import jdk.vm.ci.code.Architecture;
 137 import jdk.vm.ci.code.BailoutException;
 138 import jdk.vm.ci.code.CodeCacheProvider;
 139 import jdk.vm.ci.code.InstalledCode;
 140 import jdk.vm.ci.code.TargetDescription;
 141 import jdk.vm.ci.meta.Assumptions.Assumption;
 142 import jdk.vm.ci.meta.ConstantReflectionProvider;
 143 import jdk.vm.ci.meta.DeoptimizationReason;
 144 import jdk.vm.ci.meta.JavaConstant;
 145 import jdk.vm.ci.meta.JavaKind;
 146 import jdk.vm.ci.meta.JavaType;
 147 import jdk.vm.ci.meta.MetaAccessProvider;
 148 import jdk.vm.ci.meta.ProfilingInfo;
 149 import jdk.vm.ci.meta.ResolvedJavaMethod;
 150 import jdk.vm.ci.meta.ResolvedJavaType;
 151 import jdk.vm.ci.meta.SpeculationLog;
 152 
 153 /**
 154  * Base class for compiler unit tests.
 155  * &lt;p&gt;
 156  * White box tests for compiler transformations use this pattern:
 157  * &lt;ol&gt;
 158  * &lt;li&gt;Create a graph by {@linkplain #parseEager parsing} a method.&lt;/li&gt;
 159  * &lt;li&gt;Manually modify the graph (e.g. replace a parameter node with a constant).&lt;/li&gt;
 160  * &lt;li&gt;Apply a transformation to the graph.&lt;/li&gt;
 161  * &lt;li&gt;Assert that the transformed graph is equal to an expected graph.&lt;/li&gt;
 162  * &lt;/ol&gt;
 163  * &lt;p&gt;
 164  * See {@link InvokeHintsTest} as an example of a white box test.
 165  * &lt;p&gt;
 166  * Black box tests use the {@link #test(String, Object...)} or
 167  * {@link #testN(int, String, Object...)} to execute some method in the interpreter and compare its
 168  * result against that produced by a Graal compiled version of the method.
 169  * &lt;p&gt;
 170  * These tests will be run by the {@code mx unittest} command.
 171  */
 172 @AddExports({&quot;java.base/jdk.internal.org.objectweb.asm&quot;, &quot;java.base/jdk.internal.org.objectweb.asm.tree&quot;})
 173 public abstract class GraalCompilerTest extends GraalTest {
 174 
 175     /**
 176      * Gets the initial option values provided by the Graal runtime. These are option values
 177      * typically parsed from the command line.
 178      */
 179     public static OptionValues getInitialOptions() {
 180         return Graal.getRequiredCapability(OptionValues.class);
 181     }
 182 
 183     private static final int BAILOUT_RETRY_LIMIT = 1;
 184     private final Providers providers;
 185     private final Backend backend;
 186 
 187     /**
 188      * Representative class for the {@code java.base} module.
 189      */
 190     public static final Class&lt;?&gt; JAVA_BASE = Class.class;
 191 
 192     /**
 193      * Exports the package named {@code packageName} declared in {@code moduleMember}&#39;s module to
 194      * this object&#39;s module. This must be called before accessing packages that are no longer public
 195      * as of JDK 9.
 196      */
 197     protected final void exportPackage(Class&lt;?&gt; moduleMember, String packageName) {
 198         ModuleSupport.exportPackageTo(moduleMember, packageName, getClass());
 199     }
 200 
 201     /**
 202      * Denotes a test method that must be inlined by the {@link BytecodeParser}.
 203      */
 204     @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
 205     @Retention(RetentionPolicy.RUNTIME)
 206     public @interface BytecodeParserForceInline {
 207     }
 208 
 209     /**
 210      * Denotes a test method that must never be inlined by the {@link BytecodeParser}.
 211      */
 212     @Retention(RetentionPolicy.RUNTIME)
 213     @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})
 214     public @interface BytecodeParserNeverInline {
 215         /**
 216          * Specifies if the call should be implemented with {@link InvokeWithExceptionNode} instead
 217          * of {@link InvokeNode}.
 218          */
 219         boolean invokeWithException() default false;
 220     }
 221 
 222     /**
 223      * Can be overridden by unit tests to verify properties of the graph.
 224      *
 225      * @param graph the graph at the end of HighTier
 226      * @throws AssertionError if the verification fails
 227      */
 228     protected void checkHighTierGraph(StructuredGraph graph) {
 229     }
 230 
 231     /**
 232      * Can be overridden by unit tests to verify properties of the graph.
 233      *
 234      * @param graph the graph at the end of MidTier
 235      * @throws AssertionError if the verification fails
 236      */
 237     protected void checkMidTierGraph(StructuredGraph graph) {
 238     }
 239 
 240     /**
 241      * Can be overridden by unit tests to verify properties of the graph.
 242      *
 243      * @param graph the graph at the end of LowTier
 244      * @throws AssertionError if the verification fails
 245      */
 246     protected void checkLowTierGraph(StructuredGraph graph) {
 247     }
 248 
 249     protected static void breakpoint() {
 250     }
 251 
 252     @SuppressWarnings(&quot;unused&quot;)
 253     protected static void breakpoint(int arg0) {
 254     }
 255 
 256     protected static void shouldBeOptimizedAway() {
 257     }
 258 
 259     protected Suites createSuites(OptionValues opts) {
 260         Suites ret = backend.getSuites().getDefaultSuites(opts).copy();
 261         ListIterator&lt;BasePhase&lt;? super HighTierContext&gt;&gt; iter = ret.getHighTier().findPhase(ConvertDeoptimizeToGuardPhase.class, true);
 262         if (iter == null) {
 263             /*
 264              * in the economy configuration, we don&#39;t have the ConvertDeoptimizeToGuard phase, so we
 265              * just select the first CanonicalizerPhase in HighTier
 266              */
 267             iter = ret.getHighTier().findPhase(CanonicalizerPhase.class);
 268         }
 269         iter.add(new Phase() {
 270 
 271             @Override
 272             protected void run(StructuredGraph graph) {
 273                 ComputeLoopFrequenciesClosure.compute(graph);
 274             }
 275 
 276             @Override
 277             public float codeSizeIncrease() {
 278                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 279             }
 280 
 281             @Override
 282             protected CharSequence getName() {
 283                 return &quot;ComputeLoopFrequenciesPhase&quot;;
 284             }
 285         });
 286         ret.getHighTier().appendPhase(new Phase() {
 287 
 288             @Override
 289             protected void run(StructuredGraph graph) {
 290                 checkHighTierGraph(graph);
 291             }
 292 
 293             @Override
 294             public float codeSizeIncrease() {
 295                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 296             }
 297 
 298             @Override
 299             protected CharSequence getName() {
 300                 return &quot;CheckGraphPhase&quot;;
 301             }
 302         });
 303         ret.getMidTier().appendPhase(new Phase() {
 304 
 305             @Override
 306             protected void run(StructuredGraph graph) {
 307                 checkMidTierGraph(graph);
 308             }
 309 
 310             @Override
 311             public float codeSizeIncrease() {
 312                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 313             }
 314 
 315             @Override
 316             protected CharSequence getName() {
 317                 return &quot;CheckGraphPhase&quot;;
 318             }
 319         });
 320         ret.getLowTier().appendPhase(new Phase() {
 321 
 322             @Override
 323             protected void run(StructuredGraph graph) {
 324                 checkLowTierGraph(graph);
 325             }
 326 
 327             @Override
 328             public float codeSizeIncrease() {
 329                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
 330             }
 331 
 332             @Override
 333             protected CharSequence getName() {
 334                 return &quot;CheckGraphPhase&quot;;
 335             }
 336         });
 337         return ret;
 338     }
 339 
 340     protected LIRSuites createLIRSuites(OptionValues opts) {
 341         LIRSuites ret = backend.getSuites().getDefaultLIRSuites(opts).copy();
 342         return ret;
 343     }
 344 
 345     private static final ThreadLocal&lt;HashMap&lt;ResolvedJavaMethod, InstalledCode&gt;&gt; cache = ThreadLocal.withInitial(HashMap::new);
 346 
 347     @BeforeClass
 348     public static void resetCache() {
 349         cache.get().clear();
 350     }
 351 
 352     public GraalCompilerTest() {
 353         this.backend = Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend();
 354         this.providers = getBackend().getProviders();
 355     }
 356 
 357     /**
 358      * Set up a test for a non-default backend. The test should check (via {@link #getBackend()} )
 359      * whether the desired backend is available.
 360      *
 361      * @param arch the name of the desired backend architecture
 362      */
 363     public GraalCompilerTest(Class&lt;? extends Architecture&gt; arch) {
 364         RuntimeProvider runtime = Graal.getRequiredCapability(RuntimeProvider.class);
 365         Backend b = runtime.getBackend(arch);
 366         if (b != null) {
 367             this.backend = b;
 368         } else {
 369             // Fall back to the default/host backend
 370             this.backend = runtime.getHostBackend();
 371         }
 372         this.providers = backend.getProviders();
 373     }
 374 
 375     /**
 376      * Set up a test for a non-default backend.
 377      *
 378      * @param backend the desired backend
 379      */
 380     public GraalCompilerTest(Backend backend) {
 381         this.backend = backend;
 382         this.providers = backend.getProviders();
 383     }
 384 
 385     @Override
 386     @After
 387     public void afterTest() {
 388         if (invocationPluginExtensions != null) {
 389             synchronized (this) {
 390                 if (invocationPluginExtensions != null) {
 391                     extendedInvocationPlugins.removeTestPlugins(invocationPluginExtensions);
 392                     extendedInvocationPlugins = null;
 393                     invocationPluginExtensions = null;
 394                 }
 395             }
 396         }
 397         super.afterTest();
 398     }
 399 
 400     /**
 401      * Gets a {@link DebugContext} object corresponding to {@code options}, creating a new one if
 402      * none currently exists. Debug contexts created by this method will have their
 403      * {@link DebugDumpHandler}s closed in {@link #afterTest()}.
 404      */
 405     protected DebugContext getDebugContext() {
 406         return getDebugContext(getInitialOptions(), null, null);
 407     }
 408 
 409     @Override
 410     protected Collection&lt;DebugHandlersFactory&gt; getDebugHandlersFactories() {
 411         return Collections.singletonList(new GraalDebugHandlersFactory(getSnippetReflection()));
 412     }
 413 
 414     protected void assertEquals(StructuredGraph expected, StructuredGraph graph) {
 415         assertEquals(expected, graph, false, true);
 416     }
 417 
 418     protected int countUnusedConstants(StructuredGraph graph) {
 419         int total = 0;
 420         for (ConstantNode node : getConstantNodes(graph)) {
 421             if (node.hasNoUsages()) {
 422                 total++;
 423             }
 424         }
 425         return total;
 426     }
 427 
 428     protected int getNodeCountExcludingUnusedConstants(StructuredGraph graph) {
 429         return graph.getNodeCount() - countUnusedConstants(graph);
 430     }
 431 
 432     protected void assertEquals(StructuredGraph expected, StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {
 433         String expectedString = getCanonicalGraphString(expected, excludeVirtual, checkConstants);
 434         String actualString = getCanonicalGraphString(graph, excludeVirtual, checkConstants);
 435         String mismatchString = compareGraphStrings(expected, expectedString, graph, actualString);
 436 
 437         if (!excludeVirtual &amp;&amp; getNodeCountExcludingUnusedConstants(expected) != getNodeCountExcludingUnusedConstants(graph)) {
 438             expected.getDebug().dump(DebugContext.BASIC_LEVEL, expected, &quot;Node count not matching - expected&quot;);
 439             graph.getDebug().dump(DebugContext.BASIC_LEVEL, graph, &quot;Node count not matching - actual&quot;);
 440             Assert.fail(&quot;Graphs do not have the same number of nodes: &quot; + expected.getNodeCount() + &quot; vs. &quot; + graph.getNodeCount() + &quot;\n&quot; + mismatchString);
 441         }
 442         if (!expectedString.equals(actualString)) {
 443             expected.getDebug().dump(DebugContext.BASIC_LEVEL, expected, &quot;mismatching graphs - expected&quot;);
 444             graph.getDebug().dump(DebugContext.BASIC_LEVEL, graph, &quot;mismatching graphs - actual&quot;);
 445             Assert.fail(mismatchString);
 446         }
 447     }
 448 
 449     private static String compareGraphStrings(StructuredGraph expectedGraph, String expectedString, StructuredGraph actualGraph, String actualString) {
 450         if (!expectedString.equals(actualString)) {
 451             String[] expectedLines = expectedString.split(&quot;\n&quot;);
 452             String[] actualLines = actualString.split(&quot;\n&quot;);
 453             int diffIndex = -1;
 454             int limit = Math.min(actualLines.length, expectedLines.length);
 455             String marker = &quot; &lt;&lt;&lt;&quot;;
 456             for (int i = 0; i &lt; limit; i++) {
 457                 if (!expectedLines[i].equals(actualLines[i])) {
 458                     diffIndex = i;
 459                     break;
 460                 }
 461             }
 462             if (diffIndex == -1) {
 463                 // Prefix is the same so add some space after the prefix
 464                 diffIndex = limit;
 465                 if (actualLines.length == limit) {
 466                     actualLines = Arrays.copyOf(actualLines, limit + 1);
 467                     actualLines[diffIndex] = &quot;&quot;;
 468                 } else {
 469                     assert expectedLines.length == limit;
 470                     expectedLines = Arrays.copyOf(expectedLines, limit + 1);
 471                     expectedLines[diffIndex] = &quot;&quot;;
 472                 }
 473             }
 474             // Place a marker next to the first line that differs
 475             expectedLines[diffIndex] = expectedLines[diffIndex] + marker;
 476             actualLines[diffIndex] = actualLines[diffIndex] + marker;
 477             String ediff = String.join(&quot;\n&quot;, expectedLines);
 478             String adiff = String.join(&quot;\n&quot;, actualLines);
 479             return &quot;mismatch in graphs:\n========= expected (&quot; + expectedGraph + &quot;) =========\n&quot; + ediff + &quot;\n\n========= actual (&quot; + actualGraph + &quot;) =========\n&quot; + adiff;
 480         } else {
 481             return &quot;mismatch in graphs&quot;;
 482         }
 483     }
 484 
 485     protected void assertOptimizedAway(StructuredGraph g) {
 486         Assert.assertEquals(0, g.getNodes().filter(NotOptimizedNode.class).count());
 487     }
 488 
 489     protected void assertConstantReturn(StructuredGraph graph, int value) {
 490         String graphString = getCanonicalGraphString(graph, false, true);
 491         Assert.assertEquals(&quot;unexpected number of ReturnNodes: &quot; + graphString, graph.getNodes(ReturnNode.TYPE).count(), 1);
 492         ValueNode result = graph.getNodes(ReturnNode.TYPE).first().result();
 493         Assert.assertTrue(&quot;unexpected ReturnNode result node: &quot; + graphString, result.isConstant());
 494         Assert.assertEquals(&quot;unexpected ReturnNode result kind: &quot; + graphString, result.asJavaConstant().getJavaKind(), JavaKind.Int);
 495         Assert.assertEquals(&quot;unexpected ReturnNode result: &quot; + graphString, result.asJavaConstant().asInt(), value);
 496     }
 497 
 498     protected static String getCanonicalGraphString(StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {
 499         SchedulePhase schedule = new SchedulePhase(SchedulingStrategy.EARLIEST);
 500         schedule.apply(graph);
 501         ScheduleResult scheduleResult = graph.getLastSchedule();
 502 
 503         NodeMap&lt;Integer&gt; canonicalId = graph.createNodeMap();
 504         int nextId = 0;
 505 
 506         List&lt;String&gt; constantsLines = new ArrayList&lt;&gt;();
 507 
 508         StringBuilder result = new StringBuilder();
 509         for (Block block : scheduleResult.getCFG().getBlocks()) {
 510             result.append(&quot;Block &quot;).append(block).append(&#39; &#39;);
 511             if (block == scheduleResult.getCFG().getStartBlock()) {
 512                 result.append(&quot;* &quot;);
 513             }
 514             result.append(&quot;-&gt; &quot;);
 515             for (Block succ : block.getSuccessors()) {
 516                 result.append(succ).append(&#39; &#39;);
 517             }
 518             result.append(&#39;\n&#39;);
 519             for (Node node : scheduleResult.getBlockToNodesMap().get(block)) {
 520                 if (node instanceof ValueNode &amp;&amp; node.isAlive()) {
 521                     if (!excludeVirtual || !(node instanceof VirtualObjectNode || node instanceof ProxyNode || node instanceof FullInfopointNode || node instanceof ParameterNode)) {
 522                         if (node instanceof ConstantNode) {
 523                             String name = checkConstants ? node.toString(Verbosity.Name) : node.getClass().getSimpleName();
 524                             if (excludeVirtual) {
 525                                 constantsLines.add(name);
 526                             } else {
 527                                 constantsLines.add(name + &quot;    (&quot; + filteredUsageCount(node) + &quot;)&quot;);
 528                             }
 529                         } else {
 530                             int id;
 531                             if (canonicalId.get(node) != null) {
 532                                 id = canonicalId.get(node);
 533                             } else {
 534                                 id = nextId++;
 535                                 canonicalId.set(node, id);
 536                             }
 537                             String name = node.getClass().getSimpleName();
 538                             result.append(&quot;  &quot;).append(id).append(&#39;|&#39;).append(name);
 539                             if (node instanceof AccessFieldNode) {
 540                                 result.append(&#39;#&#39;);
 541                                 result.append(((AccessFieldNode) node).field());
 542                             }
 543                             if (!excludeVirtual) {
 544                                 result.append(&quot;    (&quot;);
 545                                 result.append(filteredUsageCount(node));
 546                                 result.append(&#39;)&#39;);
 547                             }
 548                             result.append(&#39;\n&#39;);
 549                         }
 550                     }
 551                 }
 552             }
 553         }
 554 
 555         StringBuilder constantsLinesResult = new StringBuilder();
 556         constantsLinesResult.append(constantsLines.size()).append(&quot; constants:\n&quot;);
 557         Collections.sort(constantsLines);
 558         for (String s : constantsLines) {
 559             constantsLinesResult.append(s);
 560             constantsLinesResult.append(&#39;\n&#39;);
 561         }
 562 
 563         return constantsLinesResult.toString() + result.toString();
 564     }
 565 
 566     /**
 567      * @return usage count excluding {@link FrameState} usages
 568      */
 569     private static int filteredUsageCount(Node node) {
 570         return node.usages().filter(n -&gt; !(n instanceof FrameState)).count();
 571     }
 572 
 573     /**
 574      * @param graph
 575      * @return a scheduled textual dump of {@code graph} .
 576      */
 577     protected static String getScheduledGraphString(StructuredGraph graph) {
 578         SchedulePhase schedule = new SchedulePhase(SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER);
 579         schedule.apply(graph);
 580         ScheduleResult scheduleResult = graph.getLastSchedule();
 581 
 582         StringBuilder result = new StringBuilder();
 583         Block[] blocks = scheduleResult.getCFG().getBlocks();
 584         for (Block block : blocks) {
 585             result.append(&quot;Block &quot;).append(block).append(&#39; &#39;);
 586             if (block == scheduleResult.getCFG().getStartBlock()) {
 587                 result.append(&quot;* &quot;);
 588             }
 589             result.append(&quot;-&gt; &quot;);
 590             for (Block succ : block.getSuccessors()) {
 591                 result.append(succ).append(&#39; &#39;);
 592             }
 593             result.append(&#39;\n&#39;);
 594             for (Node node : scheduleResult.getBlockToNodesMap().get(block)) {
 595                 result.append(String.format(&quot;%1S\n&quot;, node));
 596             }
 597         }
 598         return result.toString();
 599     }
 600 
 601     protected Backend getBackend() {
 602         return backend;
 603     }
 604 
 605     protected final Providers getProviders() {
 606         return providers;
 607     }
 608 
 609     /**
 610      * Override the {@link OptimisticOptimizations} settings used for the test. This is called for
 611      * all the paths where the value is set so it is the proper place for a test override. Setting
 612      * it in other places can result in inconsistent values being used in other parts of the
 613      * compiler.
 614      */
 615     protected OptimisticOptimizations getOptimisticOptimizations() {
 616         return OptimisticOptimizations.ALL;
 617     }
 618 
 619     protected final HighTierContext getDefaultHighTierContext() {
 620         return new HighTierContext(getProviders(), getDefaultGraphBuilderSuite(), getOptimisticOptimizations());
 621     }
 622 
 623     protected final MidTierContext getDefaultMidTierContext() {
 624         return new MidTierContext(getProviders(), getTargetProvider(), getOptimisticOptimizations(), null);
 625     }
 626 
 627     protected SnippetReflectionProvider getSnippetReflection() {
 628         return Graal.getRequiredCapability(SnippetReflectionProvider.class);
 629     }
 630 
 631     protected TargetDescription getTarget() {
 632         return getTargetProvider().getTarget();
 633     }
 634 
 635     protected TargetProvider getTargetProvider() {
 636         return getBackend();
 637     }
 638 
 639     protected CodeCacheProvider getCodeCache() {
 640         return getProviders().getCodeCache();
 641     }
 642 
 643     protected ConstantReflectionProvider getConstantReflection() {
 644         return getProviders().getConstantReflection();
 645     }
 646 
 647     protected MetaAccessProvider getMetaAccess() {
 648         return getProviders().getMetaAccess();
 649     }
 650 
 651     protected LoweringProvider getLowerer() {
 652         return getProviders().getLowerer();
 653     }
 654 
 655     protected final BasePhase&lt;HighTierContext&gt; createInliningPhase() {
 656         return createInliningPhase(this.createCanonicalizerPhase());
 657     }
 658 
 659     protected BasePhase&lt;HighTierContext&gt; createInliningPhase(CanonicalizerPhase canonicalizer) {
 660         return createInliningPhase(null, canonicalizer);
 661     }
 662 
 663     static class GreedyTestInliningPolicy extends GreedyInliningPolicy {
 664         GreedyTestInliningPolicy(Map&lt;Invoke, Double&gt; hints) {
 665             super(hints);
 666         }
 667 
 668         @Override
 669         protected int previousLowLevelGraphSize(InlineInfo info) {
 670             // Ignore previous compiles for tests
 671             return 0;
 672         }
 673     }
 674 
 675     protected BasePhase&lt;HighTierContext&gt; createInliningPhase(Map&lt;Invoke, Double&gt; hints, CanonicalizerPhase canonicalizer) {
 676         return new InliningPhase(new GreedyTestInliningPolicy(hints), canonicalizer);
 677     }
 678 
 679     protected CompilationIdentifier getCompilationId(ResolvedJavaMethod method) {
 680         return getBackend().getCompilationIdentifier(method);
 681     }
 682 
 683     protected CompilationIdentifier getOrCreateCompilationId(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph) {
 684         if (graph != null) {
 685             return graph.compilationId();
 686         }
 687         return getCompilationId(installedCodeOwner);
 688     }
 689 
 690     protected void testN(int n, final String name, final Object... args) {
 691         final List&lt;Throwable&gt; errors = new ArrayList&lt;&gt;(n);
 692         Thread[] threads = new Thread[n];
 693         for (int i = 0; i &lt; n; i++) {
 694             Thread t = new Thread(i + &quot;:&quot; + name) {
 695 
 696                 @Override
 697                 public void run() {
 698                     try {
 699                         test(name, args);
 700                     } catch (Throwable e) {
 701                         errors.add(e);
 702                     }
 703                 }
 704             };
 705             threads[i] = t;
 706             t.start();
 707         }
 708         for (int i = 0; i &lt; n; i++) {
 709             try {
 710                 threads[i].join();
 711             } catch (InterruptedException e) {
 712                 errors.add(e);
 713             }
 714         }
 715         if (!errors.isEmpty()) {
 716             throw new MultiCauseAssertionError(errors.size() + &quot; failures&quot;, errors.toArray(new Throwable[errors.size()]));
 717         }
 718     }
 719 
 720     protected Object referenceInvoke(ResolvedJavaMethod method, Object receiver, Object... args)
 721                     throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException {
 722         return invoke(method, receiver, args);
 723     }
 724 
 725     public static class Result {
 726 
 727         public final Object returnValue;
 728         public final Throwable exception;
 729 
 730         public Result(Object returnValue, Throwable exception) {
 731             this.returnValue = returnValue;
 732             this.exception = exception;
 733         }
 734 
 735         @Override
 736         public String toString() {
 737             return exception == null ? returnValue == null ? &quot;null&quot; : returnValue.toString() : &quot;!&quot; + exception;
 738         }
 739     }
 740 
 741     /**
 742      * Called before a test is executed.
 743      */
 744     protected void before(@SuppressWarnings(&quot;unused&quot;) ResolvedJavaMethod method) {
 745     }
 746 
 747     /**
 748      * Called after a test is executed.
 749      */
 750     protected void after() {
 751     }
 752 
 753     protected Result executeExpected(ResolvedJavaMethod method, Object receiver, Object... args) {
 754         before(method);
 755         try {
 756             // This gives us both the expected return value as well as ensuring that the method to
 757             // be compiled is fully resolved
 758             return new Result(referenceInvoke(method, receiver, args), null);
 759         } catch (InvocationTargetException e) {
 760             return new Result(null, e.getTargetException());
 761         } catch (Exception e) {
 762             throw new RuntimeException(e);
 763         } finally {
 764             after();
 765         }
 766     }
 767 
 768     protected Result executeActual(ResolvedJavaMethod method, Object receiver, Object... args) {
 769         return executeActual(getInitialOptions(), method, receiver, args);
 770     }
 771 
 772     protected Result executeActual(OptionValues options, ResolvedJavaMethod method, Object receiver, Object... args) {
 773         before(method);
 774         Object[] executeArgs = argsWithReceiver(receiver, args);
 775 
 776         checkArgs(method, executeArgs);
 777 
 778         InstalledCode compiledMethod = getCode(method, options);
 779         try {
 780             return new Result(compiledMethod.executeVarargs(executeArgs), null);
 781         } catch (Throwable e) {
 782             return new Result(null, e);
 783         } finally {
 784             after();
 785         }
 786     }
 787 
 788     protected void checkArgs(ResolvedJavaMethod method, Object[] args) {
 789         JavaType[] sig = method.toParameterTypes();
 790         Assert.assertEquals(sig.length, args.length);
 791         for (int i = 0; i &lt; args.length; i++) {
 792             JavaType javaType = sig[i];
 793             JavaKind kind = javaType.getJavaKind();
 794             Object arg = args[i];
 795             if (kind == JavaKind.Object) {
 796                 if (arg != null &amp;&amp; javaType instanceof ResolvedJavaType) {
 797                     ResolvedJavaType resolvedJavaType = (ResolvedJavaType) javaType;
 798                     Assert.assertTrue(resolvedJavaType + &quot; from &quot; + getMetaAccess().lookupJavaType(arg.getClass()), resolvedJavaType.isAssignableFrom(getMetaAccess().lookupJavaType(arg.getClass())));
 799                 }
 800             } else {
 801                 Assert.assertNotNull(arg);
 802                 Assert.assertEquals(kind.toBoxedJavaClass(), arg.getClass());
 803             }
 804         }
 805     }
 806 
 807     /**
 808      * Prepends a non-null receiver argument to a given list or args.
 809      *
 810      * @param receiver the receiver argument to prepend if it is non-null
 811      */
 812     protected Object[] argsWithReceiver(Object receiver, Object... args) {
 813         Object[] executeArgs;
 814         if (receiver == null) {
 815             executeArgs = args;
 816         } else {
 817             executeArgs = new Object[args.length + 1];
 818             executeArgs[0] = receiver;
 819             for (int i = 0; i &lt; args.length; i++) {
 820                 executeArgs[i + 1] = args[i];
 821             }
 822         }
 823         return applyArgSuppliers(executeArgs);
 824     }
 825 
 826     protected final Result test(String name, Object... args) {
 827         return test(getInitialOptions(), name, args);
 828     }
 829 
 830     protected final Result test(OptionValues options, String name, Object... args) {
 831         try {
 832             ResolvedJavaMethod method = getResolvedJavaMethod(name);
 833             Object receiver = method.isStatic() ? null : this;
 834             return test(options, method, receiver, args);
 835         } catch (AssumptionViolatedException e) {
 836             // Suppress so that subsequent calls to this method within the
 837             // same Junit @Test annotated method can proceed.
 838             return null;
 839         }
 840     }
 841 
 842     /**
 843      * Type denoting a lambda that supplies a fresh value each time it is called. This is useful
 844      * when supplying an argument to {@link GraalCompilerTest#test(String, Object...)} where the
 845      * test modifies the state of the argument (e.g., updates a field).
 846      */
 847     @FunctionalInterface
 848     public interface ArgSupplier extends Supplier&lt;Object&gt; {
 849     }
 850 
 851     /**
 852      * Convenience method for using an {@link ArgSupplier} lambda in a varargs list.
 853      */
 854     public static Object supply(ArgSupplier supplier) {
 855         return supplier;
 856     }
 857 
 858     protected Result test(ResolvedJavaMethod method, Object receiver, Object... args) {
 859         return test(getInitialOptions(), method, receiver, args);
 860     }
 861 
 862     protected Result test(OptionValues options, ResolvedJavaMethod method, Object receiver, Object... args) {
 863         Result expect = executeExpected(method, receiver, args);
 864         if (getCodeCache() != null) {
 865             testAgainstExpected(options, method, expect, receiver, args);
 866         }
 867         return expect;
 868     }
 869 
 870     /**
 871      * Process a given set of arguments, converting any {@link ArgSupplier} argument to the argument
 872      * it supplies.
 873      */
 874     protected Object[] applyArgSuppliers(Object... args) {
 875         Object[] res = args;
 876         for (int i = 0; i &lt; args.length; i++) {
 877             if (args[i] instanceof ArgSupplier) {
 878                 if (res == args) {
 879                     res = args.clone();
 880                 }
 881                 res[i] = ((ArgSupplier) args[i]).get();
 882             }
 883         }
 884         return res;
 885     }
 886 
 887     protected final void testAgainstExpected(ResolvedJavaMethod method, Result expect, Object receiver, Object... args) {
 888         testAgainstExpected(getInitialOptions(), method, expect, Collections.&lt;DeoptimizationReason&gt; emptySet(), receiver, args);
 889     }
 890 
 891     protected void testAgainstExpected(ResolvedJavaMethod method, Result expect, Set&lt;DeoptimizationReason&gt; shouldNotDeopt, Object receiver, Object... args) {
 892         testAgainstExpected(getInitialOptions(), method, expect, shouldNotDeopt, receiver, args);
 893     }
 894 
 895     protected final void testAgainstExpected(OptionValues options, ResolvedJavaMethod method, Result expect, Object receiver, Object... args) {
 896         testAgainstExpected(options, method, expect, Collections.&lt;DeoptimizationReason&gt; emptySet(), receiver, args);
 897     }
 898 
 899     protected void testAgainstExpected(OptionValues options, ResolvedJavaMethod method, Result expect, Set&lt;DeoptimizationReason&gt; shouldNotDeopt, Object receiver, Object... args) {
 900         Result actual = executeActualCheckDeopt(options, method, shouldNotDeopt, receiver, args);
 901         assertEquals(expect, actual);
 902     }
 903 
 904     protected Result executeActualCheckDeopt(OptionValues options, ResolvedJavaMethod method, Set&lt;DeoptimizationReason&gt; shouldNotDeopt, Object receiver, Object... args) {
 905         Map&lt;DeoptimizationReason, Integer&gt; deoptCounts = new EnumMap&lt;&gt;(DeoptimizationReason.class);
 906         ProfilingInfo profile = method.getProfilingInfo();
 907         for (DeoptimizationReason reason : shouldNotDeopt) {
 908             deoptCounts.put(reason, profile.getDeoptimizationCount(reason));
 909         }
 910         Result actual = executeActual(options, method, receiver, args);
 911         profile = method.getProfilingInfo(); // profile can change after execution
 912         for (DeoptimizationReason reason : shouldNotDeopt) {
 913             Assert.assertEquals(&quot;wrong number of deopt counts for &quot; + reason, (int) deoptCounts.get(reason), profile.getDeoptimizationCount(reason));
 914         }
 915         return actual;
 916     }
 917 
 918     private static final List&lt;Class&lt;?&gt;&gt; C2_OMIT_STACK_TRACE_IN_FAST_THROW_EXCEPTIONS = Arrays.asList(
 919                     ArithmeticException.class,
 920                     ArrayIndexOutOfBoundsException.class,
 921                     ArrayStoreException.class,
 922                     ClassCastException.class,
 923                     NullPointerException.class);
 924 
 925     protected void assertEquals(Result expect, Result actual) {
 926         if (expect.exception != null) {
 927             Assert.assertTrue(&quot;expected &quot; + expect.exception, actual.exception != null);
 928             Assert.assertEquals(&quot;Exception class&quot;, expect.exception.getClass(), actual.exception.getClass());
 929             // C2 can optimize out the stack trace and message in some cases
 930             if (expect.exception.getMessage() != null || !C2_OMIT_STACK_TRACE_IN_FAST_THROW_EXCEPTIONS.contains(expect.exception.getClass())) {
 931                 Assert.assertEquals(&quot;Exception message&quot;, expect.exception.getMessage(), actual.exception.getMessage());
 932             }
 933         } else {
 934             if (actual.exception != null) {
 935                 throw new AssertionError(&quot;expected &quot; + expect.returnValue + &quot; but got an exception&quot;, actual.exception);
 936             }
 937             assertDeepEquals(expect.returnValue, actual.returnValue);
 938         }
 939     }
 940 
 941     /**
 942      * Gets installed code for a given method, compiling it first if necessary. The graph is parsed
 943      * {@link #parseEager eagerly}.
 944      */
 945     protected final InstalledCode getCode(ResolvedJavaMethod method) {
 946         return getCode(method, null, false, false, getInitialOptions());
 947     }
 948 
 949     protected final InstalledCode getCode(ResolvedJavaMethod method, OptionValues options) {
 950         return getCode(method, null, false, false, options);
 951     }
 952 
 953     /**
 954      * Gets installed code for a given method, compiling it first if necessary.
 955      *
 956      * @param installedCodeOwner the method the compiled code will be associated with when installed
 957      * @param graph the graph to be compiled. If null, a graph will be obtained from
 958      *            {@code installedCodeOwner} via {@link #parseForCompile(ResolvedJavaMethod)}.
 959      */
 960     protected final InstalledCode getCode(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph) {
 961         return getCode(installedCodeOwner, graph, false, false, graph == null ? getInitialOptions() : graph.getOptions());
 962     }
 963 
 964     /**
 965      * Gets installed code for a given method and graph, compiling it first if necessary.
 966      *
 967      * @param installedCodeOwner the method the compiled code will be associated with when installed
 968      * @param graph the graph to be compiled. If null, a graph will be obtained from
 969      *            {@code installedCodeOwner} via {@link #parseForCompile(ResolvedJavaMethod)}.
 970      * @param forceCompile specifies whether to ignore any previous code cached for the (method,
 971      *            key) pair
 972      */
 973     protected final InstalledCode getCode(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile) {
 974         return getCode(installedCodeOwner, graph, forceCompile, false, graph == null ? getInitialOptions() : graph.getOptions());
 975     }
 976 
 977     /**
 978      * Gets installed code for a given method and graph, compiling it first if necessary.
 979      *
 980      * @param installedCodeOwner the method the compiled code will be associated with when installed
 981      * @param graph the graph to be compiled. If null, a graph will be obtained from
 982      *            {@code installedCodeOwner} via {@link #parseForCompile(ResolvedJavaMethod)}.
 983      * @param forceCompile specifies whether to ignore any previous code cached for the (method,
 984      *            key) pair
 985      * @param installAsDefault specifies whether to install as the default implementation
 986      * @param options the options that will be used in {@link #parseForCompile(ResolvedJavaMethod)}
 987      */
 988     @SuppressWarnings(&quot;try&quot;)
 989     protected InstalledCode getCode(final ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, boolean forceCompile, boolean installAsDefault, OptionValues options) {
 990         boolean useCache = !forceCompile &amp;&amp; getArgumentToBind() == null;
 991         if (useCache &amp;&amp; graph == null) {
 992             InstalledCode cached = cache.get().get(installedCodeOwner);
 993             if (cached != null) {
 994                 if (cached.isValid()) {
 995                     return cached;
 996                 }
 997             }
 998         }
 999         // loop for retrying compilation
1000         for (int retry = 0; retry &lt;= BAILOUT_RETRY_LIMIT; retry++) {
1001             final CompilationIdentifier id = getOrCreateCompilationId(installedCodeOwner, graph);
1002 
1003             InstalledCode installedCode = null;
1004             StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, id, options) : graph;
1005             DebugContext debug = graphToCompile.getDebug();
1006 
1007             try (AllocSpy spy = AllocSpy.open(installedCodeOwner); DebugContext.Scope ds = debug.scope(&quot;Compiling&quot;, graph)) {
1008                 CompilationPrinter printer = CompilationPrinter.begin(options, id, installedCodeOwner, INVOCATION_ENTRY_BCI);
1009                 CompilationResult compResult = compile(installedCodeOwner, graphToCompile, new CompilationResult(graphToCompile.compilationId()), id, options);
1010                 printer.finish(compResult);
1011 
1012                 try (DebugContext.Scope s = debug.scope(&quot;CodeInstall&quot;, getCodeCache(), installedCodeOwner, compResult);
1013                                 DebugContext.Activation a = debug.activate()) {
1014                     try {
1015                         if (installAsDefault) {
1016                             installedCode = addDefaultMethod(debug, installedCodeOwner, compResult);
1017                         } else {
1018                             installedCode = addMethod(debug, installedCodeOwner, compResult);
1019                         }
1020                         if (installedCode == null) {
1021                             throw new GraalError(&quot;Could not install code for &quot; + installedCodeOwner.format(&quot;%H.%n(%p)&quot;));
1022                         }
1023                     } catch (BailoutException e) {
1024                         if (retry &lt; BAILOUT_RETRY_LIMIT &amp;&amp; graph == null &amp;&amp; !e.isPermanent()) {
1025                             // retry (if there is no predefined graph)
1026                             TTY.println(String.format(&quot;Restart compilation %s (%s) due to a non-permanent bailout!&quot;, installedCodeOwner, id));
1027                             continue;
1028                         }
1029                         throw e;
1030                     }
1031                 } catch (Throwable e) {
1032                     throw debug.handle(e);
1033                 }
1034             } catch (Throwable e) {
1035                 throw debug.handle(e);
1036             }
1037 
1038             if (useCache) {
1039                 cache.get().put(installedCodeOwner, installedCode);
1040             }
1041             return installedCode;
1042         }
1043         throw GraalError.shouldNotReachHere();
1044     }
1045 
1046     /**
1047      * Used to produce a graph for a method about to be compiled by
1048      * {@link #compile(ResolvedJavaMethod, StructuredGraph)} if the second parameter to that method
1049      * is null.
1050      *
1051      * The default implementation in {@link GraalCompilerTest} is to call {@link #parseEager}.
1052      */
1053     protected StructuredGraph parseForCompile(ResolvedJavaMethod method, OptionValues options) {
1054         return parseEager(method, AllowAssumptions.YES, getCompilationId(method), options);
1055     }
1056 
1057     protected final StructuredGraph parseForCompile(ResolvedJavaMethod method, DebugContext debug) {
1058         return parseEager(method, AllowAssumptions.YES, debug);
1059     }
1060 
1061     protected final StructuredGraph parseForCompile(ResolvedJavaMethod method) {
1062         return parseEager(method, AllowAssumptions.YES, getCompilationId(method), getInitialOptions());
1063     }
1064 
1065     protected StructuredGraph parseForCompile(ResolvedJavaMethod method, CompilationIdentifier compilationId, OptionValues options) {
1066         return parseEager(method, AllowAssumptions.YES, compilationId, options);
1067     }
1068 
1069     /**
1070      * Compiles a given method.
1071      *
1072      * @param installedCodeOwner the method the compiled code will be associated with when installed
1073      * @param graph the graph to be compiled for {@code installedCodeOwner}. If null, a graph will
1074      *            be obtained from {@code installedCodeOwner} via
1075      *            {@link #parseForCompile(ResolvedJavaMethod)}.
1076      */
1077     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph) {
1078         OptionValues options = graph == null ? getInitialOptions() : graph.getOptions();
1079         CompilationIdentifier compilationId = getOrCreateCompilationId(installedCodeOwner, graph);
1080         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1081     }
1082 
1083     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, CompilationIdentifier compilationId) {
1084         OptionValues options = graph == null ? getInitialOptions() : graph.getOptions();
1085         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1086     }
1087 
1088     protected final CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, OptionValues options) {
1089         assert graph == null || graph.getOptions() == options;
1090         CompilationIdentifier compilationId = getOrCreateCompilationId(installedCodeOwner, graph);
1091         return compile(installedCodeOwner, graph, new CompilationResult(compilationId), compilationId, options);
1092     }
1093 
1094     /**
1095      * Compiles a given method.
1096      *
1097      * @param installedCodeOwner the method the compiled code will be associated with when installed
1098      * @param graph the graph to be compiled for {@code installedCodeOwner}. If null, a graph will
1099      *            be obtained from {@code installedCodeOwner} via
1100      *            {@link #parseForCompile(ResolvedJavaMethod)}.
1101      * @param compilationId
1102      */
1103     @SuppressWarnings(&quot;try&quot;)
1104     protected CompilationResult compile(ResolvedJavaMethod installedCodeOwner, StructuredGraph graph, CompilationResult compilationResult, CompilationIdentifier compilationId, OptionValues options) {
1105         StructuredGraph graphToCompile = graph == null ? parseForCompile(installedCodeOwner, compilationId, options) : graph;
1106         lastCompiledGraph = graphToCompile;
1107         DebugContext debug = graphToCompile.getDebug();
1108         try (DebugContext.Scope s = debug.scope(&quot;Compile&quot;, graphToCompile)) {
1109             assert options != null;
1110             Request&lt;CompilationResult&gt; request = new Request&lt;&gt;(graphToCompile, installedCodeOwner, getProviders(), getBackend(), getDefaultGraphBuilderSuite(), getOptimisticOptimizations(),
1111                             graphToCompile.getProfilingInfo(), createSuites(options), createLIRSuites(options), compilationResult, CompilationResultBuilderFactory.Default, true);
1112             return GraalCompiler.compile(request);
1113         } catch (Throwable e) {
1114             throw debug.handle(e);
1115         }
1116     }
1117 
1118     protected StructuredGraph getFinalGraph(String method) {
1119         return getFinalGraph(getResolvedJavaMethod(method));
1120     }
1121 
1122     protected StructuredGraph getFinalGraph(ResolvedJavaMethod method) {
1123         StructuredGraph graph = parseForCompile(method);
1124         applyFrontEnd(graph);
1125         return graph;
1126     }
1127 
1128     protected StructuredGraph getFinalGraph(ResolvedJavaMethod method, OptionValues options) {
1129         StructuredGraph graph = parseForCompile(method, options);
1130         applyFrontEnd(graph);
1131         return graph;
1132     }
1133 
1134     @SuppressWarnings(&quot;try&quot;)
1135     protected void applyFrontEnd(StructuredGraph graph) {
1136         DebugContext debug = graph.getDebug();
1137         try (DebugContext.Scope s = debug.scope(&quot;FrontEnd&quot;, graph)) {
1138             GraalCompiler.emitFrontEnd(getProviders(), getBackend(), graph, getDefaultGraphBuilderSuite(), getOptimisticOptimizations(), graph.getProfilingInfo(), createSuites(graph.getOptions()));
1139         } catch (Throwable e) {
1140             throw debug.handle(e);
1141         }
1142     }
1143 
1144     protected StructuredGraph lastCompiledGraph;
1145 
1146     protected SpeculationLog getSpeculationLog() {
1147         return null;
1148     }
1149 
1150     protected InstalledCode addMethod(DebugContext debug, final ResolvedJavaMethod method, final CompilationResult compilationResult) {
1151         return backend.addInstalledCode(debug, method, null, compilationResult);
1152     }
1153 
1154     protected InstalledCode addDefaultMethod(DebugContext debug, final ResolvedJavaMethod method, final CompilationResult compilationResult) {
1155         return backend.createDefaultInstalledCode(debug, method, compilationResult);
1156     }
1157 
1158     private final Map&lt;ResolvedJavaMethod, Executable&gt; methodMap = new ConcurrentHashMap&lt;&gt;();
1159 
1160     /**
1161      * Converts a reflection {@link Method} to a {@link ResolvedJavaMethod}.
1162      */
1163     protected ResolvedJavaMethod asResolvedJavaMethod(Executable method) {
1164         ResolvedJavaMethod javaMethod = getMetaAccess().lookupJavaMethod(method);
1165         methodMap.put(javaMethod, method);
1166         return javaMethod;
1167     }
1168 
1169     protected ResolvedJavaMethod getResolvedJavaMethod(String methodName) {
1170         return asResolvedJavaMethod(getMethod(methodName));
1171     }
1172 
1173     protected ResolvedJavaMethod getResolvedJavaMethod(Class&lt;?&gt; clazz, String methodName) {
1174         return asResolvedJavaMethod(getMethod(clazz, methodName));
1175     }
1176 
1177     protected ResolvedJavaMethod getResolvedJavaMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
1178         return asResolvedJavaMethod(getMethod(clazz, methodName, parameterTypes));
1179     }
1180 
1181     /**
1182      * Gets the reflection {@link Method} from which a given {@link ResolvedJavaMethod} was created
1183      * or null if {@code javaMethod} does not correspond to a reflection method.
1184      */
1185     protected Executable lookupMethod(ResolvedJavaMethod javaMethod) {
1186         return methodMap.get(javaMethod);
1187     }
1188 
1189     @SuppressWarnings(&quot;deprecation&quot;)
1190     protected Object invoke(ResolvedJavaMethod javaMethod, Object receiver, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException {
1191         Executable method = lookupMethod(javaMethod);
1192         Assert.assertTrue(method != null);
1193         if (!method.isAccessible()) {
1194             method.setAccessible(true);
1195         }
1196         if (method instanceof Method) {
1197             return ((Method) method).invoke(receiver, applyArgSuppliers(args));
1198         }
1199         assert receiver == null : &quot;no receiver for constructor invokes&quot;;
1200         return ((Constructor&lt;?&gt;) method).newInstance(applyArgSuppliers(args));
1201     }
1202 
1203     /**
1204      * Parses a Java method in {@linkplain GraphBuilderConfiguration#getDefault default} mode to
1205      * produce a graph.
1206      *
1207      * @param methodName the name of the method in {@code this.getClass()} to be parsed
1208      * @param allowAssumptions specifies if {@link Assumption}s can be made compiling the graph
1209      */
1210     protected final StructuredGraph parseProfiled(String methodName, AllowAssumptions allowAssumptions) {
1211         ResolvedJavaMethod method = getResolvedJavaMethod(methodName);
1212         return parse(builder(method, allowAssumptions), getDefaultGraphBuilderSuite());
1213     }
1214 
1215     /**
1216      * Parses a Java method in {@linkplain GraphBuilderConfiguration#getDefault default} mode to
1217      * produce a graph.
1218      *
1219      * @param method the method to be parsed
1220      * @param allowAssumptions specifies if {@link Assumption}s can be made compiling the graph
1221      */
1222     protected final StructuredGraph parseProfiled(ResolvedJavaMethod method, AllowAssumptions allowAssumptions) {
1223         return parse(builder(method, allowAssumptions), getDefaultGraphBuilderSuite());
1224     }
1225 
1226     /**
1227      * Parses a Java method with {@linkplain GraphBuilderConfiguration#withEagerResolving(boolean)}
1228      * set to true to produce a graph.
1229      *
1230      * @param methodName the name of the method in {@code this.getClass()} to be parsed
1231      * @param allowAssumptions specifies if {@link Assumption}s can be made compiling the graph
1232      */
1233     protected final StructuredGraph parseEager(String methodName, AllowAssumptions allowAssumptions) {
1234         ResolvedJavaMethod method = getResolvedJavaMethod(methodName);
1235         return parse(builder(method, allowAssumptions), getEagerGraphBuilderSuite());
1236     }
1237 
1238     /**
1239      * Parses a Java method with {@linkplain GraphBuilderConfiguration#withEagerResolving(boolean)}
1240      * set to true to produce a graph.
1241      *
1242      * @param methodName the name of the method in {@code this.getClass()} to be parsed
1243      * @param allowAssumptions specifies if {@link Assumption}s can be made compiling the graph
1244      * @param options the option values to be used when compiling the graph
1245      */
1246     protected final StructuredGraph parseEager(String methodName, AllowAssumptions allowAssumptions, OptionValues options) {
1247         ResolvedJavaMethod method = getResolvedJavaMethod(methodName);
1248         return parse(builder(method, allowAssumptions, options), getEagerGraphBuilderSuite());
1249     }
1250 
1251     protected final StructuredGraph parseEager(String methodName, AllowAssumptions allowAssumptions, DebugContext debug) {
1252         ResolvedJavaMethod method = getResolvedJavaMethod(methodName);
1253         return parse(builder(method, allowAssumptions, debug), getEagerGraphBuilderSuite());
1254     }
1255 
1256     /**
1257      * Parses a Java method with {@linkplain GraphBuilderConfiguration#withEagerResolving(boolean)}
1258      * set to true to produce a graph.
1259      *
1260      * @param method the method to be parsed
1261      * @param allowAssumptions specifies if {@link Assumption}s can be made compiling the graph
1262      */
1263     protected final StructuredGraph parseEager(ResolvedJavaMethod method, AllowAssumptions allowAssumptions) {
1264         return parse(builder(method, allowAssumptions), getEagerGraphBuilderSuite());
1265     }
1266 
1267     protected final StructuredGraph parseEager(ResolvedJavaMethod method, AllowAssumptions allowAssumptions, DebugContext debug) {
1268         return parse(builder(method, allowAssumptions, debug), getEagerGraphBuilderSuite());
1269     }
1270 
1271     /**
1272      * Parses a Java method with {@linkplain GraphBuilderConfiguration#withEagerResolving(boolean)}
1273      * set to true to produce a graph.
1274      *
1275      * @param method the method to be parsed
1276      * @param allowAssumptions specifies if {@link Assumption}s can be made compiling the graph
1277      * @param options the option values to be used when compiling the graph
1278      */
1279     protected final StructuredGraph parseEager(ResolvedJavaMethod method, AllowAssumptions allowAssumptions, OptionValues options) {
1280         return parse(builder(method, allowAssumptions, options), getEagerGraphBuilderSuite());
1281     }
1282 
1283     /**
1284      * Parses a Java method with {@linkplain GraphBuilderConfiguration#withEagerResolving(boolean)}
1285      * set to true to produce a graph.
1286      *
1287      * @param method the method to be parsed
1288      * @param allowAssumptions specifies if {@link Assumption}s can be made compiling the graph
1289      * @param compilationId the compilation identifier to be associated with the graph
1290      * @param options the option values to be used when compiling the graph
1291      */
1292     protected final StructuredGraph parseEager(ResolvedJavaMethod method, AllowAssumptions allowAssumptions, CompilationIdentifier compilationId, OptionValues options) {
1293         return parse(builder(method, allowAssumptions, compilationId, options), getEagerGraphBuilderSuite());
1294     }
1295 
1296     protected final Builder builder(ResolvedJavaMethod method, AllowAssumptions allowAssumptions, DebugContext debug) {
1297         OptionValues options = debug.getOptions();
1298         return new Builder(options, debug, allowAssumptions).method(method).compilationId(getCompilationId(method));
1299     }
1300 
1301     protected final Builder builder(ResolvedJavaMethod method, AllowAssumptions allowAssumptions) {
1302         OptionValues options = getInitialOptions();
1303         return new Builder(options, getDebugContext(options, null, method), allowAssumptions).method(method).compilationId(getCompilationId(method));
1304     }
1305 
1306     protected final Builder builder(ResolvedJavaMethod method, AllowAssumptions allowAssumptions, CompilationIdentifier compilationId, OptionValues options) {
1307         return new Builder(options, getDebugContext(options, compilationId.toString(CompilationIdentifier.Verbosity.ID), method), allowAssumptions).method(method).compilationId(compilationId);
1308     }
1309 
1310     protected final Builder builder(ResolvedJavaMethod method, AllowAssumptions allowAssumptions, OptionValues options) {
1311         return new Builder(options, getDebugContext(options, null, method), allowAssumptions).method(method).compilationId(getCompilationId(method));
1312     }
1313 
1314     protected PhaseSuite&lt;HighTierContext&gt; getDebugGraphBuilderSuite() {
1315         return getCustomGraphBuilderSuite(GraphBuilderConfiguration.getDefault(getDefaultGraphBuilderPlugins()).withFullInfopoints(true));
1316     }
1317 
1318     @SuppressWarnings(&quot;try&quot;)
1319     protected StructuredGraph parse(StructuredGraph.Builder builder, PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite) {
1320         ResolvedJavaMethod javaMethod = builder.getMethod();
1321         builder.speculationLog(getSpeculationLog());
1322         if (builder.getCancellable() == null) {
1323             builder.cancellable(getCancellable(javaMethod));
1324         }
1325         assert javaMethod.getAnnotation(Test.class) == null : &quot;shouldn&#39;t parse method with @Test annotation: &quot; + javaMethod;
1326         StructuredGraph graph = builder.build();
1327         DebugContext debug = graph.getDebug();
1328         try (DebugContext.Scope ds = debug.scope(&quot;Parsing&quot;, javaMethod, graph)) {
1329             graphBuilderSuite.apply(graph, getDefaultHighTierContext());
1330             Object[] args = getArgumentToBind();
1331             if (args != null) {
1332                 bindArguments(graph, args);
1333             }
1334             return graph;
1335         } catch (Throwable e) {
1336             throw debug.handle(e);
1337         }
1338     }
1339 
1340     protected static final Object NO_BIND = new Object();
1341 
1342     protected void bindArguments(StructuredGraph graph, Object[] argsToBind) {
1343         ResolvedJavaMethod m = graph.method();
1344         Object receiver = isStatic(m.getModifiers()) ? null : this;
1345         Object[] args = argsWithReceiver(receiver, argsToBind);
1346         JavaType[] parameterTypes = m.toParameterTypes();
1347         assert parameterTypes.length == args.length;
1348         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
1349             Object arg = args[param.index()];
1350             if (arg != NO_BIND) {
1351                 JavaConstant c = getSnippetReflection().forBoxed(parameterTypes[param.index()].getJavaKind(), arg);
1352                 ConstantNode replacement = ConstantNode.forConstant(c, getMetaAccess(), graph);
1353                 param.replaceAtUsages(replacement);
1354             }
1355         }
1356     }
1357 
1358     protected Object[] getArgumentToBind() {
1359         return null;
1360     }
1361 
1362     protected PhaseSuite&lt;HighTierContext&gt; getEagerGraphBuilderSuite() {
1363         return getCustomGraphBuilderSuite(GraphBuilderConfiguration.getDefault(getDefaultGraphBuilderPlugins()).withEagerResolving(true).withUnresolvedIsError(true));
1364     }
1365 
1366     /**
1367      * Gets the cancellable that should be associated with a graph being created by any of the
1368      * {@code parse...()} methods.
1369      *
1370      * @param method the method being parsed into a graph
1371      */
1372     protected Cancellable getCancellable(ResolvedJavaMethod method) {
1373         return null;
1374     }
1375 
1376     protected Plugins getDefaultGraphBuilderPlugins() {
1377         PhaseSuite&lt;HighTierContext&gt; suite = backend.getSuites().getDefaultGraphBuilderSuite();
1378         Plugins defaultPlugins = ((GraphBuilderPhase) suite.findPhase(GraphBuilderPhase.class).previous()).getGraphBuilderConfig().getPlugins();
1379         // defensive copying
1380         return new Plugins(defaultPlugins);
1381     }
1382 
1383     protected PhaseSuite&lt;HighTierContext&gt; getDefaultGraphBuilderSuite() {
1384         // defensive copying
1385         return backend.getSuites().getDefaultGraphBuilderSuite().copy();
1386     }
1387 
1388     /**
1389      * Registers extra invocation plugins for this test. The extra plugins are removed in the
1390      * {@link #afterTest()} method.
1391      *
1392      * Subclasses overriding this method should always call the same method on the super class in
1393      * case it wants to register plugins.
1394      *
1395      * @param invocationPlugins
1396      */
1397     protected void registerInvocationPlugins(InvocationPlugins invocationPlugins) {
1398         invocationPlugins.register(new InvocationPlugin() {
1399             @Override
1400             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1401                 b.add(new BreakpointNode());
1402                 return true;
1403             }
1404         }, GraalCompilerTest.class, &quot;breakpoint&quot;);
1405         invocationPlugins.register(new InvocationPlugin() {
1406             @Override
1407             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg0) {
1408                 b.add(new BreakpointNode(arg0));
1409                 return true;
1410             }
1411         }, GraalCompilerTest.class, &quot;breakpoint&quot;, int.class);
1412         invocationPlugins.register(new InvocationPlugin() {
1413             @Override
1414             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1415                 b.add(new NotOptimizedNode());
1416                 return true;
1417             }
1418         }, GraalCompilerTest.class, &quot;shouldBeOptimizedAway&quot;);
1419     }
1420 
1421     /**
1422      * The {@link #testN(int, String, Object...)} method means multiple threads trying to initialize
1423      * this field.
1424      */
1425     private volatile InvocationPlugins invocationPluginExtensions;
1426 
1427     private InvocationPlugins extendedInvocationPlugins;
1428 
1429     protected PhaseSuite&lt;HighTierContext&gt; getCustomGraphBuilderSuite(GraphBuilderConfiguration gbConf) {
1430         PhaseSuite&lt;HighTierContext&gt; suite = getDefaultGraphBuilderSuite();
1431         ListIterator&lt;BasePhase&lt;? super HighTierContext&gt;&gt; iterator = suite.findPhase(GraphBuilderPhase.class);
1432         initializeInvocationPluginExtensions();
1433         GraphBuilderConfiguration gbConfCopy = editGraphBuilderConfiguration(gbConf.copy());
1434         iterator.remove();
1435         iterator.add(new GraphBuilderPhase(gbConfCopy));
1436         return suite;
1437     }
1438 
1439     private void initializeInvocationPluginExtensions() {
1440         if (invocationPluginExtensions == null) {
1441             synchronized (this) {
1442                 if (invocationPluginExtensions == null) {
1443                     InvocationPlugins invocationPlugins = new InvocationPlugins();
1444                     registerInvocationPlugins(invocationPlugins);
1445                     extendedInvocationPlugins = getReplacements().getGraphBuilderPlugins().getInvocationPlugins();
1446                     extendedInvocationPlugins.addTestPlugins(invocationPlugins, null);
1447                     invocationPluginExtensions = invocationPlugins;
1448                 }
1449             }
1450         }
1451     }
1452 
1453     protected GraphBuilderConfiguration editGraphBuilderConfiguration(GraphBuilderConfiguration conf) {
1454         conf.getPlugins().prependInlineInvokePlugin(new InlineInvokePlugin() {
1455 
1456             @Override
1457             public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
1458                 BytecodeParserNeverInline neverInline = method.getAnnotation(BytecodeParserNeverInline.class);
1459                 if (neverInline != null) {
1460                     return neverInline.invokeWithException() ? DO_NOT_INLINE_WITH_EXCEPTION : DO_NOT_INLINE_NO_EXCEPTION;
1461                 }
1462                 if (method.getAnnotation(BytecodeParserForceInline.class) != null) {
1463                     return InlineInfo.createStandardInlineInfo(method);
1464                 }
1465                 return bytecodeParserShouldInlineInvoke(b, method, args);
1466             }
1467         });
1468         return conf;
1469     }
1470 
1471     /**
1472      * Supplements {@link BytecodeParserForceInline} and {@link BytecodeParserNeverInline} in terms
1473      * of allowing a test to influence the inlining decision made during bytecode parsing.
1474      *
1475      * @see InlineInvokePlugin#shouldInlineInvoke(GraphBuilderContext, ResolvedJavaMethod,
1476      *      ValueNode[])
1477      */
1478     @SuppressWarnings(&quot;unused&quot;)
1479     protected InlineInvokePlugin.InlineInfo bytecodeParserShouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
1480         return null;
1481     }
1482 
1483     @NodeInfo
1484     public static class NotOptimizedNode extends FixedWithNextNode {
1485         private static final NodeClass&lt;NotOptimizedNode&gt; TYPE = NodeClass.create(NotOptimizedNode.class);
1486 
1487         protected NotOptimizedNode() {
1488             super(TYPE, StampFactory.forVoid());
1489         }
1490 
1491     }
1492 
1493     protected Replacements getReplacements() {
1494         return getProviders().getReplacements();
1495     }
1496 
1497     /**
1498      * Inject a probability for a branch condition into the profiling information of this test case.
1499      *
1500      * @param p the probability that cond is true
1501      * @param cond the condition of the branch
1502      * @return cond
1503      */
1504     protected static boolean branchProbability(double p, boolean cond) {
1505         return GraalDirectives.injectBranchProbability(p, cond);
1506     }
1507 
1508     /**
1509      * Inject an iteration count for a loop condition into the profiling information of this test
1510      * case.
1511      *
1512      * @param i the iteration count of the loop
1513      * @param cond the condition of the loop
1514      * @return cond
1515      */
1516     protected static boolean iterationCount(double i, boolean cond) {
1517         return GraalDirectives.injectIterationCount(i, cond);
1518     }
1519 
1520     /**
1521      * Test if the current test runs on the given platform. The name must match the name given in
1522      * the {@link Architecture#getName()}.
1523      *
1524      * @param name The name to test
1525      * @return true if we run on the architecture given by name
1526      */
1527     protected boolean isArchitecture(String name) {
1528         return name.equals(backend.getTarget().arch.getName());
1529     }
1530 
1531     protected CanonicalizerPhase createCanonicalizerPhase() {
1532         return CanonicalizerPhase.create();
1533     }
1534 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
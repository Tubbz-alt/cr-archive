<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64AddressLoweringByUse.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64MembarOpTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64ArithmeticLIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64AddressLoweringByUse.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2017, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 
 27 package org.graalvm.compiler.core.aarch64;
 28 
<span class="line-modified"> 29 import org.graalvm.compiler.asm.aarch64.AArch64Address;</span>
 30 import org.graalvm.compiler.core.common.LIRKind;
 31 import org.graalvm.compiler.core.common.NumUtil;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.nodes.ValueNode;
 34 import org.graalvm.compiler.nodes.calc.AddNode;


 35 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 36 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 37 import org.graalvm.compiler.phases.common.AddressLoweringByUsePhase;
 38 
 39 import jdk.vm.ci.aarch64.AArch64Kind;
 40 import jdk.vm.ci.meta.JavaConstant;
 41 
 42 public class AArch64AddressLoweringByUse extends AddressLoweringByUsePhase.AddressLoweringByUse {
 43     private AArch64LIRKindTool kindtool;

 44 
 45     public AArch64AddressLoweringByUse(AArch64LIRKindTool kindtool) {




 46         this.kindtool = kindtool;

 47     }
 48 
 49     @Override
 50     public AddressNode lower(ValueNode use, Stamp stamp, AddressNode address) {
 51         if (address instanceof OffsetAddressNode) {
 52             OffsetAddressNode offsetAddress = (OffsetAddressNode) address;
 53             return doLower(stamp, offsetAddress.getBase(), offsetAddress.getOffset());
 54         } else {
 55             // must be an already transformed AArch64AddressNode
 56             return address;
 57         }
 58     }
 59 
 60     @Override
 61     public AddressNode lower(AddressNode address) {
 62         return lower(null, null, address);
 63     }
 64 
 65     private AddressNode doLower(Stamp stamp, ValueNode base, ValueNode index) {
 66         AArch64AddressNode ret = new AArch64AddressNode(base, index);
 67         AArch64Kind aarch64Kind = (stamp == null ? null : getAArch64Kind(stamp));
 68 
 69         // improve the address as much as possible
 70         boolean changed;
 71         do {
 72             changed = improve(aarch64Kind, ret);
 73         } while (changed);
 74 
 75         // avoid duplicates
 76         return base.graph().unique(ret);
 77     }
 78 
<span class="line-modified"> 79     protected boolean improve(AArch64Kind kind, AArch64AddressNode ret) {</span>
<span class="line-modified"> 80         AArch64Address.AddressingMode mode = ret.getAddressingMode();</span>
 81         // if we have already set a displacement or set to base only mode then we are done
 82         if (isDisplacementMode(mode) || isBaseOnlyMode(mode)) {
 83             return false;
 84         }
 85         ValueNode base = ret.getBase();
 86         ValueNode index = ret.getIndex();
 87 
 88         // avoid a constant or null base if possible
 89         if (base == null) {
 90             ret.setBase(index);
 91             ret.setIndex(base);
 92             return true;
 93         }
 94         // make sure any integral JavaConstant
 95         // is the index rather than the base
 96         // strictly we don&#39;t need the conditions on index
 97         // as we ought not to see two JavaConstant values
 98         if (base.isJavaConstant() &amp;&amp; base.asJavaConstant().getJavaKind().isNumericInteger() &amp;&amp;
 99                         index != null &amp;&amp; !index.isJavaConstant()) {
100             ret.setBase(index);
</pre>
<hr />
<pre>
111         }
112 
113         // we can try to fold a JavaConstant index into a displacement
114         if (index != null &amp;&amp; index.isJavaConstant()) {
115             JavaConstant javaConstant = index.asJavaConstant();
116             if (javaConstant.getJavaKind().isNumericInteger()) {
117                 long disp = javaConstant.asLong();
118                 mode = immediateMode(kind, disp);
119                 if (isDisplacementMode(mode)) {
120                     index = null;
121                     // we can fold this in as a displacement
122                     // but first see if we can pull up any additional
123                     // constants added into the base
124                     boolean tryNextBase = (base instanceof AddNode);
125                     while (tryNextBase) {
126                         AddNode add = (AddNode) base;
127                         tryNextBase = false;
128                         ValueNode child = add.getX();
129                         if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
130                             long newDisp = disp + child.asJavaConstant().asLong();
<span class="line-modified">131                             AArch64Address.AddressingMode newMode = immediateMode(kind, newDisp);</span>
<span class="line-modified">132                             if (newMode != AArch64Address.AddressingMode.REGISTER_OFFSET) {</span>
133                                 disp = newDisp;
134                                 mode = newMode;
135                                 base = add.getY();
136                                 ret.setBase(base);
137                                 tryNextBase = (base instanceof AddNode);
138                             }
139                         } else {
140                             child = add.getY();
141                             if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
142                                 long newDisp = disp + child.asJavaConstant().asLong();
<span class="line-modified">143                                 AArch64Address.AddressingMode newMode = immediateMode(kind, newDisp);</span>
<span class="line-modified">144                                 if (newMode != AArch64Address.AddressingMode.REGISTER_OFFSET) {</span>
145                                     disp = newDisp;
146                                     mode = newMode;
147                                     base = add.getX();
148                                     ret.setBase(base);
149                                     tryNextBase = (base instanceof AddNode);
150                                 }
151                             }
152                         }
153                     }
154                     if (disp != 0) {
155                         // ok now set the displacement in place of an index
156                         ret.setIndex(null);
157                         int scaleFactor = computeScaleFactor(kind, mode);
158                         ret.setDisplacement(disp, scaleFactor, mode);
159                     } else {
160                         // reset to base register only
161                         ret.setIndex(null);
<span class="line-modified">162                         ret.setDisplacement(0, 1, AArch64Address.AddressingMode.BASE_REGISTER_ONLY);</span>
163                     }
164                     return true;
165                 }
166             }
167         }










































168         // nope cannot improve this any more
169         return false;
170     }
171 
172     private AArch64Kind getAArch64Kind(Stamp stamp) {
173         LIRKind lirKind = stamp.getLIRKind(kindtool);
174         if (!lirKind.isValue()) {
175             if (!lirKind.isReference(0) || lirKind.getReferenceCount() != 1) {
176                 return null;
177             }
178         }
179 
180         return (AArch64Kind) lirKind.getPlatformKind();
181     }
182 
<span class="line-modified">183     private static AArch64Address.AddressingMode immediateMode(AArch64Kind kind, long value) {</span>
184         if (kind != null) {
185             int size = kind.getSizeInBytes();
186             // this next test should never really fail
187             if ((value &amp; (size - 1)) == 0) {
188                 long encodedValue = value / size;
189                 // assert value % size == 0
190                 // we can try for a 12 bit scaled offset
191                 if (NumUtil.isUnsignedNbit(12, encodedValue)) {
<span class="line-modified">192                     return AArch64Address.AddressingMode.IMMEDIATE_SCALED;</span>
193                 }
194             }
195         }
196 
197         // we can try for a 9 bit unscaled offset
198         if (NumUtil.isSignedNbit(9, value)) {
<span class="line-modified">199             return AArch64Address.AddressingMode.IMMEDIATE_UNSCALED;</span>
200         }
201 
202         // nope this index needs to be passed via offset register
<span class="line-modified">203         return AArch64Address.AddressingMode.REGISTER_OFFSET;</span>
204     }
205 
<span class="line-modified">206     private static int computeScaleFactor(AArch64Kind kind, AArch64Address.AddressingMode mode) {</span>
<span class="line-modified">207         if (mode == AArch64Address.AddressingMode.IMMEDIATE_SCALED) {</span>
208             return kind.getSizeInBytes();
209         }
210         return 1;
211     }
212 
<span class="line-modified">213     boolean isBaseOnlyMode(AArch64Address.AddressingMode addressingMode) {</span>
<span class="line-modified">214         return addressingMode == AArch64Address.AddressingMode.BASE_REGISTER_ONLY;</span>
215     }
216 
<span class="line-modified">217     private static boolean isDisplacementMode(AArch64Address.AddressingMode addressingMode) {</span>
218         switch (addressingMode) {
219             case IMMEDIATE_POST_INDEXED:
220             case IMMEDIATE_PRE_INDEXED:
221             case IMMEDIATE_SCALED:
222             case IMMEDIATE_UNSCALED:
223                 return true;
224         }
225         return false;
226     }
227 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2017, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 
 27 package org.graalvm.compiler.core.aarch64;
 28 
<span class="line-modified"> 29 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;</span>
 30 import org.graalvm.compiler.core.common.LIRKind;
 31 import org.graalvm.compiler.core.common.NumUtil;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.nodes.ValueNode;
 34 import org.graalvm.compiler.nodes.calc.AddNode;
<span class="line-added"> 35 import org.graalvm.compiler.nodes.calc.LeftShiftNode;</span>
<span class="line-added"> 36 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;</span>
 37 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 38 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 39 import org.graalvm.compiler.phases.common.AddressLoweringByUsePhase;
 40 
 41 import jdk.vm.ci.aarch64.AArch64Kind;
 42 import jdk.vm.ci.meta.JavaConstant;
 43 
 44 public class AArch64AddressLoweringByUse extends AddressLoweringByUsePhase.AddressLoweringByUse {
 45     private AArch64LIRKindTool kindtool;
<span class="line-added"> 46     private boolean supportsDerivedReference;</span>
 47 
 48     public AArch64AddressLoweringByUse(AArch64LIRKindTool kindtool) {
<span class="line-added"> 49         this(kindtool, true);</span>
<span class="line-added"> 50     }</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52     public AArch64AddressLoweringByUse(AArch64LIRKindTool kindtool, boolean supportsDerivedReference) {</span>
 53         this.kindtool = kindtool;
<span class="line-added"> 54         this.supportsDerivedReference = supportsDerivedReference;</span>
 55     }
 56 
 57     @Override
 58     public AddressNode lower(ValueNode use, Stamp stamp, AddressNode address) {
 59         if (address instanceof OffsetAddressNode) {
 60             OffsetAddressNode offsetAddress = (OffsetAddressNode) address;
 61             return doLower(stamp, offsetAddress.getBase(), offsetAddress.getOffset());
 62         } else {
 63             // must be an already transformed AArch64AddressNode
 64             return address;
 65         }
 66     }
 67 
 68     @Override
 69     public AddressNode lower(AddressNode address) {
 70         return lower(null, null, address);
 71     }
 72 
 73     private AddressNode doLower(Stamp stamp, ValueNode base, ValueNode index) {
 74         AArch64AddressNode ret = new AArch64AddressNode(base, index);
 75         AArch64Kind aarch64Kind = (stamp == null ? null : getAArch64Kind(stamp));
 76 
 77         // improve the address as much as possible
 78         boolean changed;
 79         do {
 80             changed = improve(aarch64Kind, ret);
 81         } while (changed);
 82 
 83         // avoid duplicates
 84         return base.graph().unique(ret);
 85     }
 86 
<span class="line-modified"> 87     private boolean improve(AArch64Kind kind, AArch64AddressNode ret) {</span>
<span class="line-modified"> 88         AddressingMode mode = ret.getAddressingMode();</span>
 89         // if we have already set a displacement or set to base only mode then we are done
 90         if (isDisplacementMode(mode) || isBaseOnlyMode(mode)) {
 91             return false;
 92         }
 93         ValueNode base = ret.getBase();
 94         ValueNode index = ret.getIndex();
 95 
 96         // avoid a constant or null base if possible
 97         if (base == null) {
 98             ret.setBase(index);
 99             ret.setIndex(base);
100             return true;
101         }
102         // make sure any integral JavaConstant
103         // is the index rather than the base
104         // strictly we don&#39;t need the conditions on index
105         // as we ought not to see two JavaConstant values
106         if (base.isJavaConstant() &amp;&amp; base.asJavaConstant().getJavaKind().isNumericInteger() &amp;&amp;
107                         index != null &amp;&amp; !index.isJavaConstant()) {
108             ret.setBase(index);
</pre>
<hr />
<pre>
119         }
120 
121         // we can try to fold a JavaConstant index into a displacement
122         if (index != null &amp;&amp; index.isJavaConstant()) {
123             JavaConstant javaConstant = index.asJavaConstant();
124             if (javaConstant.getJavaKind().isNumericInteger()) {
125                 long disp = javaConstant.asLong();
126                 mode = immediateMode(kind, disp);
127                 if (isDisplacementMode(mode)) {
128                     index = null;
129                     // we can fold this in as a displacement
130                     // but first see if we can pull up any additional
131                     // constants added into the base
132                     boolean tryNextBase = (base instanceof AddNode);
133                     while (tryNextBase) {
134                         AddNode add = (AddNode) base;
135                         tryNextBase = false;
136                         ValueNode child = add.getX();
137                         if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
138                             long newDisp = disp + child.asJavaConstant().asLong();
<span class="line-modified">139                             AddressingMode newMode = immediateMode(kind, newDisp);</span>
<span class="line-modified">140                             if (newMode != AddressingMode.REGISTER_OFFSET) {</span>
141                                 disp = newDisp;
142                                 mode = newMode;
143                                 base = add.getY();
144                                 ret.setBase(base);
145                                 tryNextBase = (base instanceof AddNode);
146                             }
147                         } else {
148                             child = add.getY();
149                             if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
150                                 long newDisp = disp + child.asJavaConstant().asLong();
<span class="line-modified">151                                 AddressingMode newMode = immediateMode(kind, newDisp);</span>
<span class="line-modified">152                                 if (newMode != AddressingMode.REGISTER_OFFSET) {</span>
153                                     disp = newDisp;
154                                     mode = newMode;
155                                     base = add.getX();
156                                     ret.setBase(base);
157                                     tryNextBase = (base instanceof AddNode);
158                                 }
159                             }
160                         }
161                     }
162                     if (disp != 0) {
163                         // ok now set the displacement in place of an index
164                         ret.setIndex(null);
165                         int scaleFactor = computeScaleFactor(kind, mode);
166                         ret.setDisplacement(disp, scaleFactor, mode);
167                     } else {
168                         // reset to base register only
169                         ret.setIndex(null);
<span class="line-modified">170                         ret.setDisplacement(0, 1, AddressingMode.BASE_REGISTER_ONLY);</span>
171                     }
172                     return true;
173                 }
174             }
175         }
<span class="line-added">176 </span>
<span class="line-added">177         // We try to convert (OffsetAddress base (Add (LeftShift (Ext i) k) #imm))</span>
<span class="line-added">178         // to (AArch64AddressNode (AArch64PointerAdd (base (LeftShift (Ext i) k)) #imm)</span>
<span class="line-added">179         if (supportsDerivedReference &amp;&amp; index != null &amp;&amp; index instanceof AddNode &amp;&amp; index.getStackKind().isNumericInteger()) {</span>
<span class="line-added">180             ValueNode x = ((AddNode) index).getX();</span>
<span class="line-added">181             ValueNode y = ((AddNode) index).getY();</span>
<span class="line-added">182             ValueNode objHeadOffset = null;</span>
<span class="line-added">183             ValueNode scaledIndex = null;</span>
<span class="line-added">184             if (x.isConstant()) {</span>
<span class="line-added">185                 objHeadOffset = x;</span>
<span class="line-added">186                 scaledIndex = y;</span>
<span class="line-added">187             } else if (y.isConstant()) {</span>
<span class="line-added">188                 objHeadOffset = y;</span>
<span class="line-added">189                 scaledIndex = x;</span>
<span class="line-added">190             }</span>
<span class="line-added">191 </span>
<span class="line-added">192             if (scaledIndex == null || objHeadOffset == null) {</span>
<span class="line-added">193                 return false;</span>
<span class="line-added">194             }</span>
<span class="line-added">195 </span>
<span class="line-added">196             ZeroExtendNode wordIndex = null;</span>
<span class="line-added">197             if (scaledIndex instanceof LeftShiftNode) {</span>
<span class="line-added">198                 ValueNode var = ((LeftShiftNode) scaledIndex).getX();</span>
<span class="line-added">199                 ValueNode amount = ((LeftShiftNode) scaledIndex).getY();</span>
<span class="line-added">200                 if (amount.isConstant() &amp;&amp; var instanceof ZeroExtendNode) {</span>
<span class="line-added">201                     int s = amount.asJavaConstant().asInt();</span>
<span class="line-added">202                     if (s &gt;= 0 &amp;&amp; s &lt;= 4) {</span>
<span class="line-added">203                         wordIndex = (ZeroExtendNode) var;</span>
<span class="line-added">204                     }</span>
<span class="line-added">205                 }</span>
<span class="line-added">206             } else if (scaledIndex instanceof ZeroExtendNode) {</span>
<span class="line-added">207                 wordIndex = (ZeroExtendNode) scaledIndex;</span>
<span class="line-added">208             }</span>
<span class="line-added">209 </span>
<span class="line-added">210             if (wordIndex != null) {</span>
<span class="line-added">211                 AArch64PointerAddNode addP = base.graph().unique(new AArch64PointerAddNode(base, scaledIndex));</span>
<span class="line-added">212                 ret.setBase(addP);</span>
<span class="line-added">213                 ret.setIndex(objHeadOffset);</span>
<span class="line-added">214                 return true;</span>
<span class="line-added">215             }</span>
<span class="line-added">216         }</span>
<span class="line-added">217 </span>
218         // nope cannot improve this any more
219         return false;
220     }
221 
222     private AArch64Kind getAArch64Kind(Stamp stamp) {
223         LIRKind lirKind = stamp.getLIRKind(kindtool);
224         if (!lirKind.isValue()) {
225             if (!lirKind.isReference(0) || lirKind.getReferenceCount() != 1) {
226                 return null;
227             }
228         }
229 
230         return (AArch64Kind) lirKind.getPlatformKind();
231     }
232 
<span class="line-modified">233     private static AddressingMode immediateMode(AArch64Kind kind, long value) {</span>
234         if (kind != null) {
235             int size = kind.getSizeInBytes();
236             // this next test should never really fail
237             if ((value &amp; (size - 1)) == 0) {
238                 long encodedValue = value / size;
239                 // assert value % size == 0
240                 // we can try for a 12 bit scaled offset
241                 if (NumUtil.isUnsignedNbit(12, encodedValue)) {
<span class="line-modified">242                     return AddressingMode.IMMEDIATE_SCALED;</span>
243                 }
244             }
245         }
246 
247         // we can try for a 9 bit unscaled offset
248         if (NumUtil.isSignedNbit(9, value)) {
<span class="line-modified">249             return AddressingMode.IMMEDIATE_UNSCALED;</span>
250         }
251 
252         // nope this index needs to be passed via offset register
<span class="line-modified">253         return AddressingMode.REGISTER_OFFSET;</span>
254     }
255 
<span class="line-modified">256     private static int computeScaleFactor(AArch64Kind kind, AddressingMode mode) {</span>
<span class="line-modified">257         if (mode == AddressingMode.IMMEDIATE_SCALED) {</span>
258             return kind.getSizeInBytes();
259         }
260         return 1;
261     }
262 
<span class="line-modified">263     boolean isBaseOnlyMode(AddressingMode addressingMode) {</span>
<span class="line-modified">264         return addressingMode == AddressingMode.BASE_REGISTER_ONLY;</span>
265     }
266 
<span class="line-modified">267     private static boolean isDisplacementMode(AddressingMode addressingMode) {</span>
268         switch (addressingMode) {
269             case IMMEDIATE_POST_INDEXED:
270             case IMMEDIATE_PRE_INDEXED:
271             case IMMEDIATE_SCALED:
272             case IMMEDIATE_UNSCALED:
273                 return true;
274         }
275         return false;
276     }
277 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64MembarOpTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AArch64ArithmeticLIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
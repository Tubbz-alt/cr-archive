<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64AddressLoweringByUse.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2017, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 
 27 package org.graalvm.compiler.core.aarch64;
 28 
 29 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
 30 import org.graalvm.compiler.core.common.LIRKind;
 31 import org.graalvm.compiler.core.common.NumUtil;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.nodes.ValueNode;
 34 import org.graalvm.compiler.nodes.calc.AddNode;
 35 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 36 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 37 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 38 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 39 import org.graalvm.compiler.phases.common.AddressLoweringByUsePhase;
 40 
 41 import jdk.vm.ci.aarch64.AArch64Kind;
 42 import jdk.vm.ci.meta.JavaConstant;
 43 
 44 public class AArch64AddressLoweringByUse extends AddressLoweringByUsePhase.AddressLoweringByUse {
 45     private AArch64LIRKindTool kindtool;
 46     private boolean supportsDerivedReference;
 47 
 48     public AArch64AddressLoweringByUse(AArch64LIRKindTool kindtool) {
 49         this(kindtool, true);
 50     }
 51 
 52     public AArch64AddressLoweringByUse(AArch64LIRKindTool kindtool, boolean supportsDerivedReference) {
 53         this.kindtool = kindtool;
 54         this.supportsDerivedReference = supportsDerivedReference;
 55     }
 56 
 57     @Override
 58     public AddressNode lower(ValueNode use, Stamp stamp, AddressNode address) {
 59         if (address instanceof OffsetAddressNode) {
 60             OffsetAddressNode offsetAddress = (OffsetAddressNode) address;
 61             return doLower(stamp, offsetAddress.getBase(), offsetAddress.getOffset());
 62         } else {
 63             // must be an already transformed AArch64AddressNode
 64             return address;
 65         }
 66     }
 67 
 68     @Override
 69     public AddressNode lower(AddressNode address) {
 70         return lower(null, null, address);
 71     }
 72 
 73     private AddressNode doLower(Stamp stamp, ValueNode base, ValueNode index) {
 74         AArch64AddressNode ret = new AArch64AddressNode(base, index);
 75         AArch64Kind aarch64Kind = (stamp == null ? null : getAArch64Kind(stamp));
 76 
 77         // improve the address as much as possible
 78         boolean changed;
 79         do {
 80             changed = improve(aarch64Kind, ret);
 81         } while (changed);
 82 
 83         // avoid duplicates
 84         return base.graph().unique(ret);
 85     }
 86 
 87     private boolean improve(AArch64Kind kind, AArch64AddressNode ret) {
 88         AddressingMode mode = ret.getAddressingMode();
 89         // if we have already set a displacement or set to base only mode then we are done
 90         if (isDisplacementMode(mode) || isBaseOnlyMode(mode)) {
 91             return false;
 92         }
 93         ValueNode base = ret.getBase();
 94         ValueNode index = ret.getIndex();
 95 
 96         // avoid a constant or null base if possible
 97         if (base == null) {
 98             ret.setBase(index);
 99             ret.setIndex(base);
100             return true;
101         }
102         // make sure any integral JavaConstant
103         // is the index rather than the base
104         // strictly we don&#39;t need the conditions on index
105         // as we ought not to see two JavaConstant values
106         if (base.isJavaConstant() &amp;&amp; base.asJavaConstant().getJavaKind().isNumericInteger() &amp;&amp;
107                         index != null &amp;&amp; !index.isJavaConstant()) {
108             ret.setBase(index);
109             ret.setIndex(base);
110             return true;
111         }
112 
113         // if the base is an add then move it up
114         if (index == null &amp;&amp; base instanceof AddNode) {
115             AddNode add = (AddNode) base;
116             ret.setBase(add.getX());
117             ret.setIndex(add.getY());
118             return true;
119         }
120 
121         // we can try to fold a JavaConstant index into a displacement
122         if (index != null &amp;&amp; index.isJavaConstant()) {
123             JavaConstant javaConstant = index.asJavaConstant();
124             if (javaConstant.getJavaKind().isNumericInteger()) {
125                 long disp = javaConstant.asLong();
126                 mode = immediateMode(kind, disp);
127                 if (isDisplacementMode(mode)) {
128                     index = null;
129                     // we can fold this in as a displacement
130                     // but first see if we can pull up any additional
131                     // constants added into the base
132                     boolean tryNextBase = (base instanceof AddNode);
133                     while (tryNextBase) {
134                         AddNode add = (AddNode) base;
135                         tryNextBase = false;
136                         ValueNode child = add.getX();
137                         if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
138                             long newDisp = disp + child.asJavaConstant().asLong();
139                             AddressingMode newMode = immediateMode(kind, newDisp);
140                             if (newMode != AddressingMode.REGISTER_OFFSET) {
141                                 disp = newDisp;
142                                 mode = newMode;
143                                 base = add.getY();
144                                 ret.setBase(base);
145                                 tryNextBase = (base instanceof AddNode);
146                             }
147                         } else {
148                             child = add.getY();
149                             if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
150                                 long newDisp = disp + child.asJavaConstant().asLong();
151                                 AddressingMode newMode = immediateMode(kind, newDisp);
152                                 if (newMode != AddressingMode.REGISTER_OFFSET) {
153                                     disp = newDisp;
154                                     mode = newMode;
155                                     base = add.getX();
156                                     ret.setBase(base);
157                                     tryNextBase = (base instanceof AddNode);
158                                 }
159                             }
160                         }
161                     }
162                     if (disp != 0) {
163                         // ok now set the displacement in place of an index
164                         ret.setIndex(null);
165                         int scaleFactor = computeScaleFactor(kind, mode);
166                         ret.setDisplacement(disp, scaleFactor, mode);
167                     } else {
168                         // reset to base register only
169                         ret.setIndex(null);
170                         ret.setDisplacement(0, 1, AddressingMode.BASE_REGISTER_ONLY);
171                     }
172                     return true;
173                 }
174             }
175         }
176 
177         // We try to convert (OffsetAddress base (Add (LeftShift (Ext i) k) #imm))
178         // to (AArch64AddressNode (AArch64PointerAdd (base (LeftShift (Ext i) k)) #imm)
179         if (supportsDerivedReference &amp;&amp; index != null &amp;&amp; index instanceof AddNode &amp;&amp; index.getStackKind().isNumericInteger()) {
180             ValueNode x = ((AddNode) index).getX();
181             ValueNode y = ((AddNode) index).getY();
182             ValueNode objHeadOffset = null;
183             ValueNode scaledIndex = null;
184             if (x.isConstant()) {
185                 objHeadOffset = x;
186                 scaledIndex = y;
187             } else if (y.isConstant()) {
188                 objHeadOffset = y;
189                 scaledIndex = x;
190             }
191 
192             if (scaledIndex == null || objHeadOffset == null) {
193                 return false;
194             }
195 
196             ZeroExtendNode wordIndex = null;
197             if (scaledIndex instanceof LeftShiftNode) {
198                 ValueNode var = ((LeftShiftNode) scaledIndex).getX();
199                 ValueNode amount = ((LeftShiftNode) scaledIndex).getY();
200                 if (amount.isConstant() &amp;&amp; var instanceof ZeroExtendNode) {
201                     int s = amount.asJavaConstant().asInt();
202                     if (s &gt;= 0 &amp;&amp; s &lt;= 4) {
203                         wordIndex = (ZeroExtendNode) var;
204                     }
205                 }
206             } else if (scaledIndex instanceof ZeroExtendNode) {
207                 wordIndex = (ZeroExtendNode) scaledIndex;
208             }
209 
210             if (wordIndex != null) {
211                 AArch64PointerAddNode addP = base.graph().unique(new AArch64PointerAddNode(base, scaledIndex));
212                 ret.setBase(addP);
213                 ret.setIndex(objHeadOffset);
214                 return true;
215             }
216         }
217 
218         // nope cannot improve this any more
219         return false;
220     }
221 
222     private AArch64Kind getAArch64Kind(Stamp stamp) {
223         LIRKind lirKind = stamp.getLIRKind(kindtool);
224         if (!lirKind.isValue()) {
225             if (!lirKind.isReference(0) || lirKind.getReferenceCount() != 1) {
226                 return null;
227             }
228         }
229 
230         return (AArch64Kind) lirKind.getPlatformKind();
231     }
232 
233     private static AddressingMode immediateMode(AArch64Kind kind, long value) {
234         if (kind != null) {
235             int size = kind.getSizeInBytes();
236             // this next test should never really fail
237             if ((value &amp; (size - 1)) == 0) {
238                 long encodedValue = value / size;
239                 // assert value % size == 0
240                 // we can try for a 12 bit scaled offset
241                 if (NumUtil.isUnsignedNbit(12, encodedValue)) {
242                     return AddressingMode.IMMEDIATE_SCALED;
243                 }
244             }
245         }
246 
247         // we can try for a 9 bit unscaled offset
248         if (NumUtil.isSignedNbit(9, value)) {
249             return AddressingMode.IMMEDIATE_UNSCALED;
250         }
251 
252         // nope this index needs to be passed via offset register
253         return AddressingMode.REGISTER_OFFSET;
254     }
255 
256     private static int computeScaleFactor(AArch64Kind kind, AddressingMode mode) {
257         if (mode == AddressingMode.IMMEDIATE_SCALED) {
258             return kind.getSizeInBytes();
259         }
260         return 1;
261     }
262 
263     boolean isBaseOnlyMode(AddressingMode addressingMode) {
264         return addressingMode == AddressingMode.BASE_REGISTER_ONLY;
265     }
266 
267     private static boolean isDisplacementMode(AddressingMode addressingMode) {
268         switch (addressingMode) {
269             case IMMEDIATE_POST_INDEXED:
270             case IMMEDIATE_PRE_INDEXED:
271             case IMMEDIATE_SCALED:
272             case IMMEDIATE_UNSCALED:
273                 return true;
274         }
275         return false;
276     }
277 }
    </pre>
  </body>
</html>
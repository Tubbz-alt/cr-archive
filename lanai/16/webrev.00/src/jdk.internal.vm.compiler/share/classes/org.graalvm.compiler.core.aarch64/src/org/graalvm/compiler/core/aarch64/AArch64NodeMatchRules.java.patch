diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,23 +23,22 @@
 
 
 
 package org.graalvm.compiler.core.aarch64;
 
-import jdk.vm.ci.aarch64.AArch64Kind;
-import jdk.vm.ci.code.CodeUtil;
-import jdk.vm.ci.meta.AllocatableValue;
-import jdk.vm.ci.meta.JavaKind;
-import jdk.vm.ci.meta.Value;
 import jdk.internal.vm.compiler.collections.EconomicMap;
 import jdk.internal.vm.compiler.collections.Equivalence;
+import org.graalvm.compiler.asm.aarch64.AArch64Assembler.ExtendType;
 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;
 import org.graalvm.compiler.core.common.LIRKind;
 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
+import org.graalvm.compiler.core.common.calc.FloatConvert;
 import org.graalvm.compiler.core.gen.NodeMatchRules;
 import org.graalvm.compiler.core.match.ComplexMatchResult;
 import org.graalvm.compiler.core.match.MatchRule;
+import org.graalvm.compiler.core.match.MatchableNode;
+import org.graalvm.compiler.debug.GraalError;
 import org.graalvm.compiler.lir.LIRFrameState;
 import org.graalvm.compiler.lir.LabelRef;
 import org.graalvm.compiler.lir.Variable;
 import org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;
 import org.graalvm.compiler.lir.aarch64.AArch64BitFieldOp;
@@ -52,28 +51,39 @@
 import org.graalvm.compiler.nodes.NodeView;
 import org.graalvm.compiler.nodes.ValueNode;
 import org.graalvm.compiler.nodes.calc.AddNode;
 import org.graalvm.compiler.nodes.calc.AndNode;
 import org.graalvm.compiler.nodes.calc.BinaryNode;
+import org.graalvm.compiler.nodes.calc.FloatConvertNode;
 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 import org.graalvm.compiler.nodes.calc.MulNode;
 import org.graalvm.compiler.nodes.calc.NarrowNode;
 import org.graalvm.compiler.nodes.calc.NegateNode;
 import org.graalvm.compiler.nodes.calc.NotNode;
 import org.graalvm.compiler.nodes.calc.OrNode;
 import org.graalvm.compiler.nodes.calc.RightShiftNode;
+import org.graalvm.compiler.nodes.calc.SignExtendNode;
 import org.graalvm.compiler.nodes.calc.SubNode;
 import org.graalvm.compiler.nodes.calc.UnaryNode;
 import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
 import org.graalvm.compiler.nodes.calc.XorNode;
-import org.graalvm.compiler.nodes.memory.Access;
+import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
+import org.graalvm.compiler.nodes.memory.MemoryAccess;
 
+import jdk.vm.ci.aarch64.AArch64Kind;
+import jdk.vm.ci.code.CodeUtil;
+import jdk.vm.ci.meta.AllocatableValue;
+import jdk.vm.ci.meta.JavaKind;
+import jdk.vm.ci.meta.Value;
+
+@MatchableNode(nodeClass = AArch64PointerAddNode.class, inputs = {"base", "offset"})
 public class AArch64NodeMatchRules extends NodeMatchRules {
     private static final EconomicMap<Class<? extends BinaryNode>, AArch64ArithmeticOp> binaryOpMap;
     private static final EconomicMap<Class<? extends BinaryNode>, AArch64BitFieldOp.BitFieldOpCode> bitFieldOpMap;
     private static final EconomicMap<Class<? extends BinaryNode>, AArch64MacroAssembler.ShiftType> shiftTypeMap;
+    private static final EconomicMap<Class<? extends BinaryNode>, AArch64ArithmeticOp> logicalNotOpMap;
 
     static {
         binaryOpMap = EconomicMap.create(Equivalence.IDENTITY, 9);
         binaryOpMap.put(AddNode.class, AArch64ArithmeticOp.ADD);
         binaryOpMap.put(SubNode.class, AArch64ArithmeticOp.SUB);
@@ -87,29 +97,50 @@
 
         bitFieldOpMap = EconomicMap.create(Equivalence.IDENTITY, 2);
         bitFieldOpMap.put(UnsignedRightShiftNode.class, AArch64BitFieldOp.BitFieldOpCode.UBFX);
         bitFieldOpMap.put(LeftShiftNode.class, AArch64BitFieldOp.BitFieldOpCode.UBFIZ);
 
+        logicalNotOpMap = EconomicMap.create(Equivalence.IDENTITY, 3);
+        logicalNotOpMap.put(AndNode.class, AArch64ArithmeticOp.BIC);
+        logicalNotOpMap.put(OrNode.class, AArch64ArithmeticOp.ORN);
+        logicalNotOpMap.put(XorNode.class, AArch64ArithmeticOp.EON);
+
         shiftTypeMap = EconomicMap.create(Equivalence.IDENTITY, 3);
         shiftTypeMap.put(LeftShiftNode.class, AArch64MacroAssembler.ShiftType.LSL);
         shiftTypeMap.put(RightShiftNode.class, AArch64MacroAssembler.ShiftType.ASR);
         shiftTypeMap.put(UnsignedRightShiftNode.class, AArch64MacroAssembler.ShiftType.LSR);
     }
 
     public AArch64NodeMatchRules(LIRGeneratorTool gen) {
         super(gen);
     }
 
-    protected LIRFrameState getState(Access access) {
+    protected LIRFrameState getState(MemoryAccess access) {
         if (access instanceof DeoptimizingNode) {
             return state((DeoptimizingNode) access);
         }
         return null;
     }
 
-    protected AArch64Kind getMemoryKind(Access access) {
-        return (AArch64Kind) gen.getLIRKind(access.asNode().stamp(NodeView.DEFAULT)).getPlatformKind();
+    protected AArch64Kind getMemoryKind(MemoryAccess access) {
+        return (AArch64Kind) gen.getLIRKind(((ValueNode) access).stamp(NodeView.DEFAULT)).getPlatformKind();
+    }
+
+    private static ExtendType getZeroExtendType(int fromBits) {
+        switch (fromBits) {
+            case Byte.SIZE:
+                return ExtendType.UXTB;
+            case Short.SIZE:
+                return ExtendType.UXTH;
+            case Integer.SIZE:
+                return ExtendType.UXTW;
+            case Long.SIZE:
+                return ExtendType.UXTX;
+            default:
+                GraalError.shouldNotReachHere("extended from " + fromBits + "bits is not supported!");
+                return null;
+        }
     }
 
     private AllocatableValue moveSp(AllocatableValue value) {
         return getLIRGeneratorTool().moveSp(value);
     }
@@ -125,12 +156,11 @@
             gen.append(new AArch64BitFieldOp(op, result, src, lsb, width));
             return result;
         };
     }
 
-    private ComplexMatchResult emitBinaryShift(AArch64ArithmeticOp op, ValueNode value, BinaryNode shift,
-                    boolean isShiftNot) {
+    private ComplexMatchResult emitBinaryShift(AArch64ArithmeticOp op, ValueNode value, BinaryNode shift) {
         AArch64MacroAssembler.ShiftType shiftType = shiftTypeMap.get(shift.getClass());
         assert shiftType != null;
         assert value.getStackKind().isNumericInteger();
         assert shift.getX().getStackKind().isNumericInteger();
         assert shift.getY() instanceof ConstantNode;
@@ -140,11 +170,11 @@
             Value b = operand(shift.getX());
             Variable result = gen.newVariable(LIRKind.combine(a, b));
             AllocatableValue x = moveSp(gen.asAllocatable(a));
             AllocatableValue y = moveSp(gen.asAllocatable(b));
             int shiftAmount = shift.getY().asJavaConstant().asInt();
-            gen.append(new AArch64ArithmeticOp.BinaryShiftOp(op, result, x, y, shiftType, shiftAmount, isShiftNot));
+            gen.append(new AArch64ArithmeticOp.BinaryShiftOp(op, result, x, y, shiftType, shiftAmount));
             return result;
         };
     }
 
     private ComplexMatchResult emitBitTestAndBranch(FixedNode trueSuccessor, FixedNode falseSuccessor,
@@ -161,10 +191,50 @@
 
     private static boolean isNarrowingLongToInt(NarrowNode narrow) {
         return narrow.getInputBits() == 64 && narrow.getResultBits() == 32;
     }
 
+    @MatchRule("(AArch64PointerAdd=addP base ZeroExtend)")
+    @MatchRule("(AArch64PointerAdd=addP base (LeftShift ZeroExtend Constant))")
+    public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {
+        ValueNode offset = addP.getOffset();
+        ZeroExtendNode zeroExtend;
+        int shiftNum;
+        if (offset instanceof ZeroExtendNode) {
+            zeroExtend = (ZeroExtendNode) offset;
+            shiftNum = 0;
+        } else {
+            LeftShiftNode shift = (LeftShiftNode) offset;
+            zeroExtend = (ZeroExtendNode) shift.getX();
+            shiftNum = shift.getY().asJavaConstant().asInt();
+        }
+
+        int fromBits = zeroExtend.getInputBits();
+        int toBits = zeroExtend.getResultBits();
+        if (toBits != 64) {
+            return null;
+        }
+        assert fromBits <= toBits;
+        ExtendType extendType = getZeroExtendType(fromBits);
+
+        if (shiftNum >= 0 && shiftNum <= 4) {
+            ValueNode base = addP.getBase();
+            return builder -> {
+                AllocatableValue x = gen.asAllocatable(operand(base));
+                AllocatableValue y = gen.asAllocatable(operand(zeroExtend.getValue()));
+                AllocatableValue baseReference = LIRKind.derivedBaseFromValue(x);
+                LIRKind kind = LIRKind.combineDerived(gen.getLIRKind(addP.stamp(NodeView.DEFAULT)),
+                                baseReference, null);
+                Variable result = gen.newVariable(kind);
+                gen.append(new AArch64ArithmeticOp.ExtendedAddShiftOp(result, x, moveSp(y),
+                                extendType, shiftNum));
+                return result;
+            };
+        }
+        return null;
+    }
+
     @MatchRule("(And (UnsignedRightShift=shift a Constant=b) Constant=c)")
     @MatchRule("(LeftShift=shift (And a Constant=c) Constant=b)")
     public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {
         JavaKind srcKind = a.getStackKind();
         assert srcKind.isNumericInteger();
@@ -195,20 +265,74 @@
             return null;
         }
         return emitBitField(op, a, distance, width);
     }
 
+    @MatchRule("(Or=op (LeftShift=x src Constant=shiftAmt1) (UnsignedRightShift src Constant=shiftAmt2))")
+    @MatchRule("(Or=op (UnsignedRightShift=x src Constant=shiftAmt1) (LeftShift src Constant=shiftAmt2))")
+    @MatchRule("(Add=op (LeftShift=x src Constant=shiftAmt1) (UnsignedRightShift src Constant=shiftAmt2))")
+    @MatchRule("(Add=op (UnsignedRightShift=x src Constant=shiftAmt1) (LeftShift src Constant=shiftAmt2))")
+    public ComplexMatchResult rotationConstant(ValueNode op, ValueNode x, ValueNode src, ConstantNode shiftAmt1, ConstantNode shiftAmt2) {
+        assert src.getStackKind().isNumericInteger();
+        assert shiftAmt1.getStackKind().getBitCount() == 32;
+        assert shiftAmt2.getStackKind().getBitCount() == 32;
+
+        int shift1 = shiftAmt1.asJavaConstant().asInt();
+        int shift2 = shiftAmt2.asJavaConstant().asInt();
+        if (op instanceof AddNode && (0 == shift1 || 0 == shift2)) {
+            return null;
+        }
+        if ((0 == shift1 + shift2) || (src.getStackKind().getBitCount() == shift1 + shift2)) {
+            return builder -> {
+                Value a = operand(src);
+                Value b = x instanceof LeftShiftNode ? operand(shiftAmt2) : operand(shiftAmt1);
+                return getArithmeticLIRGenerator().emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.ROR, false, a, b);
+            };
+        }
+        return null;
+    }
+
+    @MatchRule("(Or (LeftShift=x src shiftAmount) (UnsignedRightShift src (Sub=y Constant shiftAmount)))")
+    @MatchRule("(Or (UnsignedRightShift=x src shiftAmount) (LeftShift src (Sub=y Constant shiftAmount)))")
+    @MatchRule("(Or (LeftShift=x src (Negate shiftAmount)) (UnsignedRightShift src (Add=y Constant shiftAmount)))")
+    @MatchRule("(Or (UnsignedRightShift=x src (Negate shiftAmount)) (LeftShift src (Add=y Constant shiftAmount)))")
+    @MatchRule("(Or (LeftShift=x src shiftAmount) (UnsignedRightShift src (Negate=y shiftAmount)))")
+    @MatchRule("(Or (UnsignedRightShift=x src shiftAmount) (LeftShift src (Negate=y shiftAmount)))")
+    public ComplexMatchResult rotationExpander(ValueNode src, ValueNode shiftAmount, ValueNode x, ValueNode y) {
+        assert src.getStackKind().isNumericInteger();
+        assert shiftAmount.getStackKind().getBitCount() == 32;
+
+        if (y instanceof SubNode || y instanceof AddNode) {
+            BinaryNode binary = (BinaryNode) y;
+            ConstantNode delta = (ConstantNode) (binary.getX() instanceof ConstantNode ? binary.getX() : binary.getY());
+            if (delta.asJavaConstant().asInt() != src.getStackKind().getBitCount()) {
+                return null;
+            }
+        }
+
+        return builder -> {
+            Value a = operand(src);
+            Value b;
+            if (y instanceof AddNode) {
+                b = x instanceof LeftShiftNode ? operand(shiftAmount) : getArithmeticLIRGenerator().emitNegate(operand(shiftAmount));
+            } else {
+                b = x instanceof LeftShiftNode ? getArithmeticLIRGenerator().emitNegate(operand(shiftAmount)) : operand(shiftAmount);
+            }
+            return getArithmeticLIRGenerator().emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.RORV, false, a, b);
+        };
+    }
+
     @MatchRule("(Add=binary a (LeftShift=shift b Constant))")
     @MatchRule("(Add=binary a (RightShift=shift b Constant))")
     @MatchRule("(Add=binary a (UnsignedRightShift=shift b Constant))")
     @MatchRule("(Sub=binary a (LeftShift=shift b Constant))")
     @MatchRule("(Sub=binary a (RightShift=shift b Constant))")
     @MatchRule("(Sub=binary a (UnsignedRightShift=shift b Constant))")
     public ComplexMatchResult addSubShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
         AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());
         assert op != null;
-        return emitBinaryShift(op, a, shift, false);
+        return emitBinaryShift(op, a, shift);
     }
 
     @MatchRule("(And=binary a (LeftShift=shift b Constant))")
     @MatchRule("(And=binary a (RightShift=shift b Constant))")
     @MatchRule("(And=binary a (UnsignedRightShift=shift b Constant))")
@@ -226,15 +350,48 @@
     @MatchRule("(Or=binary a (Not (UnsignedRightShift=shift b Constant)))")
     @MatchRule("(Xor=binary a (Not (LeftShift=shift b Constant)))")
     @MatchRule("(Xor=binary a (Not (RightShift=shift b Constant)))")
     @MatchRule("(Xor=binary a (Not (UnsignedRightShift=shift b Constant)))")
     public ComplexMatchResult logicShift(BinaryNode binary, ValueNode a, BinaryNode shift) {
-        AArch64ArithmeticOp op = binaryOpMap.get(binary.getClass());
-        assert op != null;
+        AArch64ArithmeticOp op;
         ValueNode operand = binary.getX() == a ? binary.getY() : binary.getX();
-        boolean isShiftNot = operand instanceof NotNode;
-        return emitBinaryShift(op, a, shift, isShiftNot);
+        if (operand instanceof NotNode) {
+            op = logicalNotOpMap.get(binary.getClass());
+        } else {
+            op = binaryOpMap.get(binary.getClass());
+        }
+        assert op != null;
+        return emitBinaryShift(op, a, shift);
+    }
+
+    @MatchRule("(And=logic value1 (Not=not value2))")
+    @MatchRule("(Or=logic value1 (Not=not value2))")
+    @MatchRule("(Xor=logic value1 (Not=not value2))")
+    public ComplexMatchResult bitwiseLogicNot(BinaryNode logic, NotNode not) {
+        assert logic.getStackKind().isNumericInteger();
+        AArch64ArithmeticOp op = logicalNotOpMap.get(logic.getClass());
+        assert op != null;
+        ValueNode src1 = logic.getX() == not ? logic.getY() : logic.getX();
+        ValueNode src2 = not.getValue();
+        return builder -> {
+            Value a = operand(src1);
+            Value b = operand(src2);
+            LIRKind resultKind = LIRKind.combine(a, b);
+            return getArithmeticLIRGenerator().emitBinary(resultKind, op, false, a, b);
+        };
+    }
+
+    @MatchRule("(Not=not (Xor value1 value2))")
+    public ComplexMatchResult bitwiseNotXor(NotNode not) {
+        assert not.getStackKind().isNumericInteger();
+        return builder -> {
+            XorNode xor = (XorNode) not.getValue();
+            Value a = operand(xor.getX());
+            Value b = operand(xor.getY());
+            LIRKind resultKind = LIRKind.combine(a, b);
+            return getArithmeticLIRGenerator().emitBinary(resultKind, AArch64ArithmeticOp.EON, false, a, b);
+        };
     }
 
     @MatchRule("(Add=binary (Mul (SignExtend a) (SignExtend b)) c)")
     @MatchRule("(Sub=binary c (Mul (SignExtend a) (SignExtend b)))")
     public ComplexMatchResult signedMultiplyAddSubLong(BinaryNode binary, ValueNode a, ValueNode b, ValueNode c) {
@@ -383,10 +540,32 @@
                             1.0 - root.getTrueSuccessorProbability(), xKind.getBitCount() - 1);
         }
         return null;
     }
 
+    @MatchRule("(FloatConvert=a (Sqrt (FloatConvert=b c)))")
+    public ComplexMatchResult floatSqrt(FloatConvertNode a, FloatConvertNode b, ValueNode c) {
+        if (c.getStackKind().isNumericFloat() && a.getStackKind().isNumericFloat()) {
+            if (a.getFloatConvert() == FloatConvert.D2F && b.getFloatConvert() == FloatConvert.F2D) {
+                return builder -> getArithmeticLIRGenerator().emitMathSqrt(operand(c));
+            }
+        }
+        return null;
+    }
+
+    @MatchRule("(SignExtend=extend (Narrow value))")
+    @MatchRule("(ZeroExtend=extend (Narrow value))")
+    public ComplexMatchResult mergeNarrowExtend(UnaryNode extend, ValueNode value) {
+        if (extend instanceof SignExtendNode) {
+            SignExtendNode sxt = (SignExtendNode) extend;
+            return builder -> getArithmeticLIRGenerator().emitSignExtend(operand(value), sxt.getInputBits(), sxt.getResultBits());
+        }
+        assert extend instanceof ZeroExtendNode;
+        ZeroExtendNode zxt = (ZeroExtendNode) extend;
+        return builder -> getArithmeticLIRGenerator().emitZeroExtend(operand(value), zxt.getInputBits(), zxt.getResultBits());
+    }
+
     @Override
     public AArch64LIRGenerator getLIRGeneratorTool() {
         return (AArch64LIRGenerator) gen;
     }
 

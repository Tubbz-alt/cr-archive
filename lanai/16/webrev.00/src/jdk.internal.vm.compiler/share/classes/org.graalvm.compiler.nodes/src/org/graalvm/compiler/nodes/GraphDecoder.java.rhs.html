<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
  29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
  30 
  31 import java.util.ArrayDeque;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.BitSet;
  35 import java.util.Deque;
  36 import java.util.Iterator;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.SortedMap;
  40 import java.util.TreeMap;
  41 
  42 import jdk.internal.vm.compiler.collections.EconomicMap;
  43 import jdk.internal.vm.compiler.collections.EconomicSet;
  44 import jdk.internal.vm.compiler.collections.Equivalence;
  45 import org.graalvm.compiler.core.common.Fields;
  46 import org.graalvm.compiler.core.common.PermanentBailoutException;
  47 import org.graalvm.compiler.core.common.util.TypeReader;
  48 import org.graalvm.compiler.core.common.util.UnsafeArrayTypeReader;
  49 import org.graalvm.compiler.debug.DebugContext;
  50 import org.graalvm.compiler.debug.GraalError;
  51 import org.graalvm.compiler.graph.Edges;
  52 import org.graalvm.compiler.graph.Graph;
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.NodeBitMap;
  55 import org.graalvm.compiler.graph.NodeClass;
  56 import org.graalvm.compiler.graph.NodeInputList;
  57 import org.graalvm.compiler.graph.NodeList;
  58 import org.graalvm.compiler.graph.NodeSourcePosition;
  59 import org.graalvm.compiler.graph.NodeSuccessorList;
  60 import org.graalvm.compiler.graph.spi.Canonicalizable;
  61 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
  62 import org.graalvm.compiler.nodeinfo.InputType;
  63 import org.graalvm.compiler.nodeinfo.NodeInfo;
  64 import org.graalvm.compiler.nodes.GraphDecoder.MethodScope;
  65 import org.graalvm.compiler.nodes.GraphDecoder.ProxyPlaceholder;
  66 import org.graalvm.compiler.nodes.calc.FloatingNode;
  67 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  68 import org.graalvm.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind;
  69 import org.graalvm.compiler.options.OptionValues;
  70 
  71 import jdk.vm.ci.code.Architecture;
  72 import jdk.vm.ci.meta.DeoptimizationAction;
  73 import jdk.vm.ci.meta.DeoptimizationReason;
  74 import jdk.vm.ci.meta.JavaConstant;
  75 import jdk.vm.ci.meta.JavaKind;
  76 import jdk.vm.ci.meta.PrimitiveConstant;
  77 import jdk.vm.ci.meta.ResolvedJavaType;
  78 
  79 /**
  80  * Decoder for {@link EncodedGraph encoded graphs} produced by {@link GraphEncoder}. Support for
  81  * loop explosion during decoding is built into this class, because it requires many interactions
  82  * with the decoding process. Subclasses can provide canonicalization and simplification of nodes
  83  * during decoding, as well as method inlining during decoding.
  84  */
  85 public class GraphDecoder {
  86 
  87     /** Decoding state maintained for each encoded graph. */
  88     protected class MethodScope {
  89         /** The loop that contains the call. Only non-null during method inlining. */
  90         public final LoopScope callerLoopScope;
  91         /**
  92          * Mark for nodes that were present before the decoding of this method started. Note that
  93          * nodes that were decoded after the mark can still be part of an outer method, since
  94          * floating nodes of outer methods are decoded lazily.
  95          */
  96         public final Graph.Mark methodStartMark;
  97         /** The encode graph that is decoded. */
  98         public final EncodedGraph encodedGraph;
  99         /** The highest node order id that a fixed node has in the EncodedGraph. */
 100         public final int maxFixedNodeOrderId;
 101         /** Access to the encoded graph. */
 102         public final TypeReader reader;
 103         /** The kind of loop explosion to be performed during decoding. */
 104         public final LoopExplosionKind loopExplosion;
 105 
 106         /** All return nodes encountered during decoding. */
 107         public final List&lt;ControlSinkNode&gt; returnAndUnwindNodes;
 108 
 109         /** All merges created during loop explosion. */
 110         public final EconomicSet&lt;Node&gt; loopExplosionMerges;
 111 
 112         /**
 113          * The start of explosion, and the merge point for when irreducible loops are detected. Only
 114          * used when {@link MethodScope#loopExplosion} is {@link LoopExplosionKind#MERGE_EXPLODE}.
 115          */
 116         public MergeNode loopExplosionHead;
 117 
 118         protected MethodScope(LoopScope callerLoopScope, StructuredGraph graph, EncodedGraph encodedGraph, LoopExplosionKind loopExplosion) {
 119             this.callerLoopScope = callerLoopScope;
 120             this.methodStartMark = graph.getMark();
 121             this.encodedGraph = encodedGraph;
 122             this.loopExplosion = loopExplosion;
 123             this.returnAndUnwindNodes = new ArrayList&lt;&gt;(2);
 124 
 125             if (encodedGraph != null) {
 126                 reader = UnsafeArrayTypeReader.create(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), architecture.supportsUnalignedMemoryAccess());
 127                 maxFixedNodeOrderId = reader.getUVInt();
 128                 if (encodedGraph.nodeStartOffsets == null) {
 129                     int nodeCount = reader.getUVInt();
 130                     int[] nodeStartOffsets = new int[nodeCount];
 131                     for (int i = 0; i &lt; nodeCount; i++) {
 132                         nodeStartOffsets[i] = encodedGraph.getStartOffset() - reader.getUVInt();
 133                     }
 134                     encodedGraph.nodeStartOffsets = nodeStartOffsets;
 135                     graph.setGuardsStage((StructuredGraph.GuardsStage) readObject(this));
 136                 }
 137             } else {
 138                 reader = null;
 139                 maxFixedNodeOrderId = 0;
 140             }
 141 
 142             if (loopExplosion.useExplosion()) {
 143                 loopExplosionMerges = EconomicSet.create(Equivalence.IDENTITY);
 144             } else {
 145                 loopExplosionMerges = null;
 146             }
 147         }
 148 
 149         public boolean isInlinedMethod() {
 150             return false;
 151         }
 152 
 153         public NodeSourcePosition getCallerBytecodePosition() {
 154             return getCallerBytecodePosition(null);
 155         }
 156 
 157         public NodeSourcePosition getCallerBytecodePosition(NodeSourcePosition position) {
 158             return position;
 159         }
 160 
 161     }
 162 
 163     /**
 164      * Marker to distinguish the reasons for the creation of a loop scope during partial evaluation.
 165      */
 166     public enum LoopScopeTrigger {
 167         /**
 168          * Start loop scope: creation triggered manually at the beginning of partial evaluation.
 169          */
 170         START,
 171 
 172         /**
 173          * Loop scope created for the next iteration of a loop if unrolling is enabled in the loop
 174          * explosion mode. See {@link LoopExplosionKind#unrollLoops()} for details. Loop unrolling
 175          * will merge loop end nodes for each iteration of the original loop.
 176          */
 177         LOOP_BEGIN_UNROLLING,
 178 
 179         /**
 180          * Loop scope created for the next iteration of a loop along a particular loop end node if
 181          * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled and loops are exploded. This
 182          * means for every loop end we duplicate the next loop iteration of the original loop.
 183          */
 184         LOOP_END_DUPLICATION,
 185 
 186         /**
 187          * Loop scope created for a loop exit node if {@link LoopExplosionKind#duplicateLoopExits()}
 188          * is enabled, i.e., code after a loop exit is duplicated per loop exit node.
 189          *
 190          * Special case nested loops: For compilation units with nested loops where inner loops
 191          * continue loops at a level n -1 the partial evaluation algorithm will merge outer loops to
 192          * avoid loop explosion along loop end nodes (which would be the same as
 193          * {@link #LOOP_END_DUPLICATION}.
 194          */
 195         LOOP_EXIT_DUPLICATION
 196     }
 197 
 198     /** Decoding state maintained for each loop in the encoded graph. */
 199     protected static class LoopScope {
 200         public final MethodScope methodScope;
 201         public final LoopScope outer;
 202         public final int loopDepth;
 203         public final int loopIteration;
 204 
 205         /**
 206          * Creation trigger of this particular loop scope, i.e., the reason it was created.
 207          */
 208         final LoopScopeTrigger trigger;
 209         /**
 210          * Upcoming, not yet processed, loop iterations created in the context of code duplication
 211          * along loop exits. Only used when {@link MethodScope#loopExplosion} has
 212          * {@link LoopExplosionKind#duplicateLoopExits()} enabled.
 213          */
 214         public Deque&lt;LoopScope&gt; nextIterationFromLoopExitDuplication;
 215         /**
 216          * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations
 217          * have been created because the duplication of loop ends
 218          * {@link LoopExplosionKind#duplicateLoopEnds()} is enabled.
 219          */
 220         public Deque&lt;LoopScope&gt; nextIterationFromLoopEndDuplication;
 221         /**
 222          * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations
 223          * have been created because the unrolling of a loop with constant iteration count
 224          * {@link LoopExplosionKind#unrollLoops()} is enabled.
 225          */
 226         public Deque&lt;LoopScope&gt; nextIterationsFromUnrolling;
 227         /**
 228          * Information about already processed loop iterations for state merging during loop
 229          * explosion. Only used when {@link MethodScope#loopExplosion} is
 230          * {@link LoopExplosionKind#MERGE_EXPLODE}.
 231          */
 232         public final EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates;
 233         public final int loopBeginOrderId;
 234         /**
 235          * The worklist of fixed nodes to process. Since we already the correct processing order
 236          * from the orderId, we just set the orderId bit in the bitset when a node is ready for
 237          * processing. The lowest set bit is the next node to process.
 238          */
 239         public final BitSet nodesToProcess;
 240         /** Nodes that have been created, indexed by the orderId. */
 241         public final Node[] createdNodes;
 242         /**
 243          * Nodes that have been created in outer loop scopes and existed before starting to process
 244          * this loop, indexed by the orderId. Only used when {@link MethodScope#loopExplosion} is
 245          * not {@link LoopExplosionKind#NONE}.
 246          */
 247         public final Node[] initialCreatedNodes;
 248 
 249         protected LoopScope(MethodScope methodScope) {
 250             this.methodScope = methodScope;
 251             this.outer = null;
 252             this.nextIterationFromLoopExitDuplication = methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque&lt;&gt;(2) : null;
 253             this.nextIterationFromLoopEndDuplication = methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque&lt;&gt;(2) : null;
 254             this.nextIterationsFromUnrolling = methodScope.loopExplosion.unrollLoops() ? new ArrayDeque&lt;&gt;(2) : null;
 255             this.loopDepth = 0;
 256             this.loopIteration = 0;
 257             this.iterationStates = null;
 258             this.loopBeginOrderId = -1;
 259             int nodeCount = methodScope.encodedGraph.nodeStartOffsets.length;
 260             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
 261             this.createdNodes = new Node[nodeCount];
 262             this.initialCreatedNodes = null;
 263             this.trigger = LoopScopeTrigger.START;
 264         }
 265 
 266         protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, LoopScopeTrigger trigger, Node[] initialCreatedNodes, Node[] createdNodes,
 267                         Deque&lt;LoopScope&gt; nextIterationFromLoopExitDuplication,
 268                         Deque&lt;LoopScope&gt; nextIterationFromLoopEndDuplication,
 269                         Deque&lt;LoopScope&gt; nextIterationsFromUnrolling, EconomicMap&lt;LoopExplosionState, LoopExplosionState&gt; iterationStates) {
 270             this.methodScope = methodScope;
 271             this.outer = outer;
 272             this.loopDepth = loopDepth;
 273             this.loopIteration = loopIteration;
 274             this.trigger = trigger;
 275             this.nextIterationFromLoopExitDuplication = nextIterationFromLoopExitDuplication;
 276             this.nextIterationFromLoopEndDuplication = nextIterationFromLoopEndDuplication;
 277             this.nextIterationsFromUnrolling = nextIterationsFromUnrolling;
 278             this.iterationStates = iterationStates;
 279             this.loopBeginOrderId = loopBeginOrderId;
 280             this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);
 281             this.initialCreatedNodes = initialCreatedNodes;
 282             this.createdNodes = createdNodes;
 283         }
 284 
 285         @Override
 286         public String toString() {
 287             return loopDepth + &quot;,&quot; + loopIteration + (loopBeginOrderId == -1 ? &quot;&quot; : &quot;#&quot; + loopBeginOrderId) + &quot; triggered by &quot; + trigger;
 288         }
 289 
 290         /**
 291          * Determines if iterations generated when decoding this loop have yet to be processed.
 292          *
 293          * @return {@code true} if there are iterations to be decoded, {@code false} else
 294          */
 295         public boolean hasIterationsToProcess() {
 296             return nextIterationFromLoopEndDuplication != null &amp;&amp; !nextIterationFromLoopEndDuplication.isEmpty() ||
 297                             nextIterationFromLoopExitDuplication != null &amp;&amp; !nextIterationFromLoopExitDuplication.isEmpty() ||
 298                             nextIterationsFromUnrolling != null &amp;&amp; !nextIterationsFromUnrolling.isEmpty();
 299         }
 300 
 301         /**
 302          * Return the next iteration yet to be processed that has been created in the context of
 303          * decoding this loop scope.
 304          *
 305          * @param remove determines if the query of the next iteration should remove it from the
 306          *            list of iterations to be processed
 307          * @return the next {@link LoopScope} to be processed that has been created in the context
 308          *         of decoding this loop scope. Note that the order is not necessarily reflecting
 309          *         the number of loop iterations.
 310          */
 311         public LoopScope getNextIterationToProcess(boolean remove) {
 312             if (nextIterationFromLoopEndDuplication != null &amp;&amp; !nextIterationFromLoopEndDuplication.isEmpty()) {
 313                 return remove ? nextIterationFromLoopEndDuplication.removeFirst() : nextIterationFromLoopEndDuplication.peekFirst();
 314             }
 315             if (nextIterationFromLoopExitDuplication != null &amp;&amp; !nextIterationFromLoopExitDuplication.isEmpty()) {
 316                 return remove ? nextIterationFromLoopExitDuplication.removeFirst() : nextIterationFromLoopExitDuplication.peekFirst();
 317             }
 318             if (nextIterationsFromUnrolling != null &amp;&amp; !nextIterationsFromUnrolling.isEmpty()) {
 319                 return remove ? nextIterationsFromUnrolling.removeFirst() : nextIterationsFromUnrolling.peekFirst();
 320             }
 321             return null;
 322         }
 323     }
 324 
 325     protected static class LoopExplosionState {
 326         public final FrameState state;
 327         public final MergeNode merge;
 328         public final int hashCode;
 329 
 330         protected LoopExplosionState(FrameState state, MergeNode merge) {
 331             this.state = state;
 332             this.merge = merge;
 333 
 334             int h = 0;
 335             for (ValueNode value : state.values()) {
 336                 if (value == null) {
 337                     h = h * 31 + 1234;
 338                 } else {
 339                     h = h * 31 + ProxyPlaceholder.unwrap(value).hashCode();
 340                 }
 341             }
 342             this.hashCode = h;
 343         }
 344 
 345         @Override
 346         public boolean equals(Object obj) {
 347             if (!(obj instanceof LoopExplosionState)) {
 348                 return false;
 349             }
 350 
 351             FrameState otherState = ((LoopExplosionState) obj).state;
 352             FrameState thisState = state;
 353             assert thisState.outerFrameState() == otherState.outerFrameState();
 354 
 355             Iterator&lt;ValueNode&gt; thisIter = thisState.values().iterator();
 356             Iterator&lt;ValueNode&gt; otherIter = otherState.values().iterator();
 357             while (thisIter.hasNext() &amp;&amp; otherIter.hasNext()) {
 358                 ValueNode thisValue = ProxyPlaceholder.unwrap(thisIter.next());
 359                 ValueNode otherValue = ProxyPlaceholder.unwrap(otherIter.next());
 360                 if (thisValue != otherValue) {
 361                     return false;
 362                 }
 363             }
 364             return thisIter.hasNext() == otherIter.hasNext();
 365         }
 366 
 367         @Override
 368         public int hashCode() {
 369             return hashCode;
 370         }
 371     }
 372 
 373     /**
 374      * Additional information encoded for {@link Invoke} nodes to allow method inlining without
 375      * decoding the frame state and successors beforehand.
 376      */
 377     protected static class InvokeData {
 378         public final Invoke invoke;
 379         public final ResolvedJavaType contextType;
 380         public final int invokeOrderId;
 381         public final int callTargetOrderId;
 382         public final int stateAfterOrderId;
 383         public final int nextOrderId;
 384 
 385         public final int nextNextOrderId;
 386         public final int exceptionOrderId;
 387         public final int exceptionStateOrderId;
 388         public final int exceptionNextOrderId;
 389         public JavaConstant constantReceiver;
 390 
 391         protected InvokeData(Invoke invoke, ResolvedJavaType contextType, int invokeOrderId, int callTargetOrderId, int stateAfterOrderId, int nextOrderId, int nextNextOrderId, int exceptionOrderId,
 392                         int exceptionStateOrderId, int exceptionNextOrderId) {
 393             this.invoke = invoke;
 394             this.contextType = contextType;
 395             this.invokeOrderId = invokeOrderId;
 396             this.callTargetOrderId = callTargetOrderId;
 397             this.stateAfterOrderId = stateAfterOrderId;
 398             this.nextOrderId = nextOrderId;
 399             this.nextNextOrderId = nextNextOrderId;
 400             this.exceptionOrderId = exceptionOrderId;
 401             this.exceptionStateOrderId = exceptionStateOrderId;
 402             this.exceptionNextOrderId = exceptionNextOrderId;
 403         }
 404     }
 405 
 406     /**
 407      * A node that is created during {@link LoopExplosionKind#MERGE_EXPLODE loop explosion} that can
 408      * later be replaced by a ProxyNode if {@link LoopDetector loop detection} finds out that the
 409      * value is defined in the loop, but used outside the loop.
 410      */
 411     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 412     protected static final class ProxyPlaceholder extends FloatingNode implements Canonicalizable {
 413         public static final NodeClass&lt;ProxyPlaceholder&gt; TYPE = NodeClass.create(ProxyPlaceholder.class);
 414 
 415         @Input ValueNode value;
 416         @Input(InputType.Association) Node proxyPoint;
 417 
 418         public ProxyPlaceholder(ValueNode value, MergeNode proxyPoint) {
 419             super(TYPE, value.stamp(NodeView.DEFAULT));
 420             this.value = value;
 421             this.proxyPoint = proxyPoint;
 422         }
 423 
 424         void setValue(ValueNode value) {
 425             updateUsages(this.value, value);
 426             this.value = value;
 427         }
 428 
 429         @Override
 430         public Node canonical(CanonicalizerTool tool) {
 431             if (tool.allUsagesAvailable()) {
 432                 /* The node is always unnecessary after graph decoding. */
 433                 return value;
 434             } else {
 435                 return this;
 436             }
 437         }
 438 
 439         public static ValueNode unwrap(ValueNode value) {
 440             ValueNode result = value;
 441             while (result instanceof ProxyPlaceholder) {
 442                 result = ((ProxyPlaceholder) result).value;
 443             }
 444             return result;
 445         }
 446     }
 447 
 448     protected final Architecture architecture;
 449     /** The target graph where decoded nodes are added to. */
 450     protected final StructuredGraph graph;
 451     protected final OptionValues options;
 452     protected final DebugContext debug;
 453 
 454     private final EconomicMap&lt;NodeClass&lt;?&gt;, ArrayDeque&lt;Node&gt;&gt; reusableFloatingNodes;
 455 
 456     public GraphDecoder(Architecture architecture, StructuredGraph graph) {
 457         this.architecture = architecture;
 458         this.graph = graph;
 459         this.options = graph.getOptions();
 460         this.debug = graph.getDebug();
 461         reusableFloatingNodes = EconomicMap.create(Equivalence.IDENTITY);
 462     }
 463 
 464     @SuppressWarnings(&quot;try&quot;)
 465     public final void decode(EncodedGraph encodedGraph) {
 466         try (DebugContext.Scope scope = debug.scope(&quot;GraphDecoder&quot;, graph)) {
 467             MethodScope methodScope = new MethodScope(null, graph, encodedGraph, LoopExplosionKind.NONE);
 468             decode(createInitialLoopScope(methodScope, null));
 469             cleanupGraph(methodScope);
 470             assert graph.verify();
 471         } catch (Throwable ex) {
 472             debug.handle(ex);
 473         }
 474     }
 475 
 476     protected final LoopScope createInitialLoopScope(MethodScope methodScope, FixedWithNextNode startNode) {
 477         LoopScope loopScope = new LoopScope(methodScope);
 478         FixedNode firstNode;
 479         if (startNode != null) {
 480             /*
 481              * The start node of a graph can be referenced as the guard for a GuardedNode. We
 482              * register the previous block node, so that such guards are correctly anchored when
 483              * doing inlining during graph decoding.
 484              */
 485             registerNode(loopScope, GraphEncoder.START_NODE_ORDER_ID, AbstractBeginNode.prevBegin(startNode), false, false);
 486 
 487             firstNode = makeStubNode(methodScope, loopScope, GraphEncoder.FIRST_NODE_ORDER_ID);
 488             startNode.setNext(firstNode);
 489             loopScope.nodesToProcess.set(GraphEncoder.FIRST_NODE_ORDER_ID);
 490         } else {
 491             firstNode = graph.start();
 492             registerNode(loopScope, GraphEncoder.START_NODE_ORDER_ID, firstNode, false, false);
 493             loopScope.nodesToProcess.set(GraphEncoder.START_NODE_ORDER_ID);
 494         }
 495         return loopScope;
 496     }
 497 
 498     protected final void decode(LoopScope initialLoopScope) {
 499         LoopScope loopScope = initialLoopScope;
 500         /* Process (inlined) methods. */
 501         while (loopScope != null) {
 502             MethodScope methodScope = loopScope.methodScope;
 503 
 504             /* Process loops of method. */
 505             while (loopScope != null) {
 506                 /* Process nodes of loop. */
 507                 while (!loopScope.nodesToProcess.isEmpty()) {
 508                     loopScope = processNextNode(methodScope, loopScope);
 509                     methodScope = loopScope.methodScope;
 510                     /*
 511                      * We can have entered a new loop, and we can have entered a new inlined method.
 512                      */
 513                 }
 514 
 515                 /* Finished with a loop. */
 516                 if (loopScope.hasIterationsToProcess()) {
 517                     loopScope = loopScope.getNextIterationToProcess(true);
 518                 } else {
 519                     propagateCreatedNodes(loopScope);
 520                     loopScope = loopScope.outer;
 521                 }
 522             }
 523 
 524             /*
 525              * Finished with an inlined method. Perform end-of-method cleanup tasks.
 526              */
 527             if (methodScope.loopExplosion.mergeLoops()) {
 528                 LoopDetector loopDetector = new LoopDetector(graph, methodScope);
 529                 loopDetector.run();
 530             }
 531             if (methodScope.isInlinedMethod()) {
 532                 finishInlining(methodScope);
 533             }
 534 
 535             /* continue with the caller */
 536             loopScope = methodScope.callerLoopScope;
 537         }
 538     }
 539 
 540     protected void finishInlining(@SuppressWarnings(&quot;unused&quot;) MethodScope inlineScope) {
 541     }
 542 
 543     private static void propagateCreatedNodes(LoopScope loopScope) {
 544         if (loopScope.outer == null || loopScope.createdNodes != loopScope.outer.createdNodes) {
 545             return;
 546         }
 547 
 548         /* Register nodes that were created while decoding the loop to the outside scope. */
 549         for (int i = 0; i &lt; loopScope.createdNodes.length; i++) {
 550             if (loopScope.outer.createdNodes[i] == null) {
 551                 loopScope.outer.createdNodes[i] = loopScope.createdNodes[i];
 552             }
 553         }
 554     }
 555 
 556     public static final boolean DUMP_DURING_FIXED_NODE_PROCESSING = false;
 557 
 558     protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope) {
 559         int nodeOrderId = loopScope.nodesToProcess.nextSetBit(0);
 560         loopScope.nodesToProcess.clear(nodeOrderId);
 561 
 562         FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);
 563 
 564         if (node.isDeleted()) {
 565             return loopScope;
 566         }
 567         if (DUMP_DURING_FIXED_NODE_PROCESSING) {
 568             if (node != null) {
 569                 try {
 570                     debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processing node %s&quot;, node);
 571                 } catch (Throwable t) {
 572                     // swallow here, dumping uninitialized nodes can cause problems
 573                 }
 574             }
 575         }
 576         if ((node instanceof MergeNode ||
 577                         (node instanceof LoopBeginNode &amp;&amp; (methodScope.loopExplosion.unrollLoops() &amp;&amp;
 578                                         !methodScope.loopExplosion.mergeLoops()))) &amp;&amp;
 579                         ((AbstractMergeNode) node).forwardEndCount() == 1) {
 580             /*
 581              * In case node is a loop begin and we are unrolling loops we remove the loop begin
 582              * since the loop will be gone after PE.
 583              */
 584             AbstractMergeNode merge = (AbstractMergeNode) node;
 585             EndNode singleEnd = merge.forwardEndAt(0);
 586 
 587             /* Nodes that would use this merge as the guard need to use the previous block. */
 588             registerNode(loopScope, nodeOrderId, AbstractBeginNode.prevBegin(singleEnd), true, false);
 589 
 590             FixedNode next = makeStubNode(methodScope, loopScope, nodeOrderId + GraphEncoder.BEGIN_NEXT_ORDER_ID_OFFSET);
 591             singleEnd.replaceAtPredecessor(next);
 592 
 593             merge.safeDelete();
 594             singleEnd.safeDelete();
 595             return loopScope;
 596         }
 597 
 598         LoopScope successorAddScope = loopScope;
 599         boolean updatePredecessors = true;
 600         if (node instanceof LoopExitNode) {
 601             if (methodScope.loopExplosion.duplicateLoopExits() || (methodScope.loopExplosion.mergeLoops() &amp;&amp; loopScope.loopDepth &gt; 1)) {
 602                 /*
 603                  * We do not want to merge loop exits of inner loops. Instead, we want to keep
 604                  * exploding the outer loop separately for every loop exit and then merge the outer
 605                  * loop. Therefore, we create a new LoopScope of the outer loop for every loop exit
 606                  * of the inner loop.
 607                  */
 608                 LoopScope outerScope = loopScope.outer;
 609                 int nextIterationNumber = outerScope.nextIterationFromLoopExitDuplication.isEmpty() ? outerScope.loopIteration + 1
 610                                 : outerScope.nextIterationFromLoopExitDuplication.getLast().loopIteration + 1;
 611                 successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId, LoopScopeTrigger.LOOP_EXIT_DUPLICATION,
 612                                 outerScope.initialCreatedNodes == null ? null : Arrays.copyOf(outerScope.initialCreatedNodes, outerScope.initialCreatedNodes.length),
 613                                 Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
 614                                 outerScope.nextIterationFromLoopExitDuplication,
 615                                 outerScope.nextIterationFromLoopEndDuplication,
 616                                 outerScope.nextIterationsFromUnrolling,
 617                                 outerScope.iterationStates);
 618                 checkLoopExplosionIteration(methodScope, successorAddScope);
 619 
 620                 /*
 621                  * Nodes that are still unprocessed in the outer scope might be merge nodes that are
 622                  * also reachable from the new exploded scope. Clearing them ensures that we do not
 623                  * merge, but instead keep exploding.
 624                  */
 625                 for (int id = outerScope.nodesToProcess.nextSetBit(0); id &gt;= 0; id = outerScope.nodesToProcess.nextSetBit(id + 1)) {
 626                     successorAddScope.createdNodes[id] = null;
 627                 }
 628 
 629                 outerScope.nextIterationFromLoopExitDuplication.addLast(successorAddScope);
 630             } else {
 631                 successorAddScope = loopScope.outer;
 632             }
 633             updatePredecessors = methodScope.loopExplosion.isNoExplosion();
 634         }
 635 
 636         methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
 637         int typeId = methodScope.reader.getUVInt();
 638         assert node.getNodeClass() == methodScope.encodedGraph.getNodeClasses()[typeId];
 639         makeFixedNodeInputs(methodScope, loopScope, node);
 640         readProperties(methodScope, node);
 641         makeSuccessorStubs(methodScope, successorAddScope, node, updatePredecessors);
 642 
 643         LoopScope resultScope = loopScope;
 644         if (node instanceof LoopBeginNode) {
 645             if (methodScope.loopExplosion.useExplosion()) {
 646                 handleLoopExplosionBegin(methodScope, loopScope, (LoopBeginNode) node);
 647             }
 648 
 649         } else if (node instanceof LoopExitNode) {
 650             if (methodScope.loopExplosion.useExplosion()) {
 651                 handleLoopExplosionProxyNodes(methodScope, loopScope, successorAddScope, (LoopExitNode) node, nodeOrderId);
 652             } else {
 653                 handleProxyNodes(methodScope, loopScope, (LoopExitNode) node);
 654             }
 655 
 656         } else if (node instanceof MergeNode) {
 657             handleMergeNode(((MergeNode) node));
 658         } else if (node instanceof AbstractEndNode) {
 659             LoopScope phiInputScope = loopScope;
 660             LoopScope phiNodeScope = loopScope;
 661             int mergeOrderId = readOrderId(methodScope);
 662 
 663             boolean requiresMergeOfOuterLoop = methodScope.loopExplosion.unrollLoops() &amp;&amp;
 664                             methodScope.loopExplosion.duplicateLoopExits() &amp;&amp;
 665                             (!methodScope.loopExplosion.duplicateLoopEnds()) &amp;&amp;
 666                             (!methodScope.loopExplosion.mergeLoops()) &amp;&amp;
 667                             node instanceof LoopEndNode &amp;&amp;
 668                             loopScope.trigger == LoopScopeTrigger.LOOP_EXIT_DUPLICATION;
 669 
 670             if (requiresMergeOfOuterLoop) {
 671                 EndNode replacementNode = graph.add(new EndNode());
 672                 node.replaceAtPredecessor(replacementNode);
 673                 node.safeDelete();
 674                 node = replacementNode;
 675                 /*
 676                  * We are in a loop exit duplicated loop scope and see a loop end node, this can
 677                  * only happen if we have a loop end to an outer loop. When duplicating over loop
 678                  * exits we have to merge outer loops for nested inner loops.
 679                  *
 680                  * Therefore, we create a correct outer loop iteration and check if there is already
 681                  * one, if not we create it else we re-use it.
 682                  */
 683                 if (loopScope.nextIterationsFromUnrolling.isEmpty()) {
 684                     // create it
 685                     int nextIterationNumber = loopScope.nextIterationsFromUnrolling.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterationsFromUnrolling.getLast().loopIteration + 1;
 686                     LoopScope outerLoopMergeScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,
 687                                     LoopScopeTrigger.LOOP_BEGIN_UNROLLING,
 688                                     Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
 689                                     Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
 690                                     loopScope.nextIterationFromLoopExitDuplication,
 691                                     loopScope.nextIterationFromLoopEndDuplication,
 692                                     loopScope.nextIterationsFromUnrolling,
 693                                     loopScope.iterationStates);
 694                     checkLoopExplosionIteration(methodScope, outerLoopMergeScope);
 695                     loopScope.nextIterationsFromUnrolling.addLast(outerLoopMergeScope);
 696                     registerNode(outerLoopMergeScope, loopScope.loopBeginOrderId, null, true, true);
 697                     makeStubNode(methodScope, outerLoopMergeScope, loopScope.loopBeginOrderId);
 698                     phiNodeScope = outerLoopMergeScope;
 699                 } else {
 700                     // re-use it
 701                     phiNodeScope = loopScope.nextIterationsFromUnrolling.getLast();
 702                 }
 703 
 704             } else if (methodScope.loopExplosion.useExplosion() &amp;&amp; node instanceof LoopEndNode) {
 705                 EndNode replacementNode = graph.add(new EndNode());
 706                 node.replaceAtPredecessor(replacementNode);
 707                 node.safeDelete();
 708                 node = replacementNode;
 709                 LoopScopeTrigger trigger = handleLoopExplosionEnd(methodScope, loopScope);
 710                 Deque&lt;LoopScope&gt; phiScope = loopScope.nextIterationsFromUnrolling;
 711                 if (trigger == LoopScopeTrigger.LOOP_END_DUPLICATION) {
 712                     phiScope = loopScope.nextIterationFromLoopEndDuplication;
 713                 }
 714                 phiNodeScope = phiScope.getLast();
 715             }
 716             AbstractMergeNode merge = (AbstractMergeNode) lookupNode(phiNodeScope, mergeOrderId);
 717             if (merge == null) {
 718                 merge = (AbstractMergeNode) makeStubNode(methodScope, phiNodeScope, mergeOrderId);
 719                 if (merge instanceof LoopBeginNode) {
 720                     /*
 721                      * In contrast to the LoopScopeTrigger.START created at the beginning of every
 722                      * PE, we see a real loop here and create the first real loop scope associated
 723                      * with a loop.
 724                      *
 725                      * Creation of a loop scope if we reach a loop begin node. We process a loop
 726                      * begin node (always before encountering a loop end associated with the loop
 727                      * begin) and simply create a normal loop scope. This does not imply an advanced
 728                      * unrolling strategy (however it can later if we see duplicate over loop end or
 729                      * exits). Therefore, we still use the start marker here, we could also use the
 730                      * unrolling marker.
 731                      *
 732                      * If we unroll loops we will later remove the loop begin node and replace it
 733                      * with its forward end (since we do not need to create a loop begin node if we
 734                      * unroll the entire loop and it has a constant trip count).
 735                      */
 736                     assert phiNodeScope == phiInputScope &amp;&amp; phiNodeScope == loopScope;
 737                     resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId, LoopScopeTrigger.START,
 738                                     methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,
 739                                     methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //
 740                                     methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque&lt;&gt;(2) : null,
 741                                     methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque&lt;&gt;(2) : null,
 742                                     methodScope.loopExplosion.unrollLoops() ? new ArrayDeque&lt;&gt;(2) : null, //
 743                                     methodScope.loopExplosion.mergeLoops() ? EconomicMap.create(Equivalence.DEFAULT) : null);
 744                     phiInputScope = resultScope;
 745                     phiNodeScope = resultScope;
 746 
 747                     if (methodScope.loopExplosion.useExplosion()) {
 748                         registerNode(loopScope, mergeOrderId, null, true, true);
 749                     }
 750                     loopScope.nodesToProcess.clear(mergeOrderId);
 751                     resultScope.nodesToProcess.set(mergeOrderId);
 752                 }
 753             }
 754             handlePhiFunctions(methodScope, phiInputScope, phiNodeScope, (AbstractEndNode) node, merge);
 755         } else if (node instanceof Invoke) {
 756             InvokeData invokeData = readInvokeData(methodScope, nodeOrderId, (Invoke) node);
 757             resultScope = handleInvoke(methodScope, loopScope, invokeData);
 758         } else if (node instanceof ReturnNode || node instanceof UnwindNode) {
 759             methodScope.returnAndUnwindNodes.add((ControlSinkNode) node);
 760         } else {
 761             handleFixedNode(methodScope, loopScope, nodeOrderId, node);
 762         }
 763         if (DUMP_DURING_FIXED_NODE_PROCESSING) {
 764             if (node != null) {
 765                 try {
 766                     debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processing node %s&quot;, node);
 767                 } catch (Throwable t) {
 768                     // swallow here, dumping uninitialized nodes can cause problems
 769                 }
 770             }
 771         }
 772         return resultScope;
 773     }
 774 
 775     protected InvokeData readInvokeData(MethodScope methodScope, int invokeOrderId, Invoke invoke) {
 776         ResolvedJavaType contextType = (ResolvedJavaType) readObject(methodScope);
 777         int callTargetOrderId = readOrderId(methodScope);
 778         int stateAfterOrderId = readOrderId(methodScope);
 779         int nextOrderId = readOrderId(methodScope);
 780 
 781         if (invoke instanceof InvokeWithExceptionNode) {
 782             int nextNextOrderId = readOrderId(methodScope);
 783             int exceptionOrderId = readOrderId(methodScope);
 784             int exceptionStateOrderId = readOrderId(methodScope);
 785             int exceptionNextOrderId = readOrderId(methodScope);
 786             return new InvokeData(invoke, contextType, invokeOrderId, callTargetOrderId, stateAfterOrderId, nextOrderId, nextNextOrderId, exceptionOrderId, exceptionStateOrderId,
 787                             exceptionNextOrderId);
 788         } else {
 789             return new InvokeData(invoke, contextType, invokeOrderId, callTargetOrderId, stateAfterOrderId, nextOrderId, -1, -1, -1, -1);
 790         }
 791     }
 792 
 793     /**
 794      * {@link Invoke} nodes do not have the {@link CallTargetNode}, {@link FrameState}, and
 795      * successors encoded. Instead, this information is provided separately to allow method inlining
 796      * without decoding and adding them to the graph upfront. For non-inlined methods, this method
 797      * restores the normal state. Subclasses can override it to perform method inlining.
 798      *
 799      * The return value is the loop scope where decoding should continue. When method inlining
 800      * should be performed, the returned loop scope must be a new loop scope for the inlined method.
 801      * Without inlining, the original loop scope must be returned.
 802      */
 803     protected LoopScope handleInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData) {
 804         assert invokeData.invoke.callTarget() == null : &quot;callTarget edge is ignored during decoding of Invoke&quot;;
 805         CallTargetNode callTarget = (CallTargetNode) ensureNodeCreated(methodScope, loopScope, invokeData.callTargetOrderId);
 806         appendInvoke(methodScope, loopScope, invokeData, callTarget);
 807         return loopScope;
 808     }
 809 
 810     protected void appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget) {
 811         if (invokeData.invoke instanceof InvokeWithExceptionNode) {
 812             ((InvokeWithExceptionNode) invokeData.invoke).setCallTarget(callTarget);
 813         } else {
 814             ((InvokeNode) invokeData.invoke).setCallTarget(callTarget);
 815         }
 816 
 817         assert invokeData.invoke.stateAfter() == null &amp;&amp; invokeData.invoke.stateDuring() == null : &quot;FrameState edges are ignored during decoding of Invoke&quot;;
 818         invokeData.invoke.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, invokeData.stateAfterOrderId));
 819 
 820         invokeData.invoke.setNext(makeStubNode(methodScope, loopScope, invokeData.nextOrderId));
 821         if (invokeData.invoke instanceof InvokeWithExceptionNode) {
 822             ((InvokeWithExceptionNode) invokeData.invoke).setExceptionEdge((AbstractBeginNode) makeStubNode(methodScope, loopScope, invokeData.exceptionOrderId));
 823         }
 824     }
 825 
 826     /**
 827      * Hook for subclasses to perform simplifications for a non-loop-header control flow merge.
 828      *
 829      * @param merge The control flow merge.
 830      */
 831     protected void handleMergeNode(MergeNode merge) {
 832     }
 833 
 834     protected void handleLoopExplosionBegin(MethodScope methodScope, LoopScope loopScope, LoopBeginNode loopBegin) {
 835         checkLoopExplosionIteration(methodScope, loopScope);
 836 
 837         List&lt;EndNode&gt; predecessors = loopBegin.forwardEnds().snapshot();
 838         FixedNode successor = loopBegin.next();
 839         FrameState frameState = loopBegin.stateAfter();
 840 
 841         if (methodScope.loopExplosion.mergeLoops()) {
 842             LoopExplosionState queryState = new LoopExplosionState(frameState, null);
 843             LoopExplosionState existingState = loopScope.iterationStates.get(queryState);
 844             if (existingState != null) {
 845                 loopBegin.replaceAtUsagesAndDelete(existingState.merge);
 846                 successor.safeDelete();
 847                 for (EndNode predecessor : predecessors) {
 848                     existingState.merge.addForwardEnd(predecessor);
 849                 }
 850                 return;
 851             }
 852         }
 853 
 854         MergeNode merge = graph.add(new MergeNode());
 855         methodScope.loopExplosionMerges.add(merge);
 856 
 857         if (methodScope.loopExplosion.mergeLoops()) {
 858             if (loopScope.iterationStates.size() == 0 &amp;&amp; loopScope.loopDepth == 1) {
 859                 if (methodScope.loopExplosionHead != null) {
 860                     throw new PermanentBailoutException(&quot;Graal implementation restriction: Method with %s loop explosion must not have more than one top-level loop&quot;, LoopExplosionKind.MERGE_EXPLODE);
 861                 }
 862                 methodScope.loopExplosionHead = merge;
 863             }
 864 
 865             List&lt;ValueNode&gt; newFrameStateValues = new ArrayList&lt;&gt;();
 866             for (ValueNode frameStateValue : frameState.values) {
 867                 if (frameStateValue == null || frameStateValue.isConstant() || !graph.isNew(methodScope.methodStartMark, frameStateValue)) {
 868                     newFrameStateValues.add(frameStateValue);
 869 
 870                 } else {
 871                     ProxyPlaceholder newFrameStateValue = graph.unique(new ProxyPlaceholder(frameStateValue, merge));
 872                     newFrameStateValues.add(newFrameStateValue);
 873 
 874                     /*
 875                      * We do not have the orderID of the value anymore, so we need to search through
 876                      * the complete list of nodes to find a match.
 877                      */
 878                     for (int i = 0; i &lt; loopScope.createdNodes.length; i++) {
 879                         if (loopScope.createdNodes[i] == frameStateValue) {
 880                             loopScope.createdNodes[i] = newFrameStateValue;
 881                         }
 882                     }
 883 
 884                     if (loopScope.initialCreatedNodes != null) {
 885                         for (int i = 0; i &lt; loopScope.initialCreatedNodes.length; i++) {
 886                             if (loopScope.initialCreatedNodes[i] == frameStateValue) {
 887                                 loopScope.initialCreatedNodes[i] = newFrameStateValue;
 888                             }
 889                         }
 890                     }
 891                 }
 892             }
 893 
 894             FrameState newFrameState = graph.add(new FrameState(frameState.outerFrameState(), frameState.getCode(), frameState.bci, newFrameStateValues, frameState.localsSize(),
 895                             frameState.stackSize(), frameState.rethrowException(), frameState.duringCall(), frameState.monitorIds(), frameState.virtualObjectMappings()));
 896 
 897             frameState.replaceAtUsagesAndDelete(newFrameState);
 898             frameState = newFrameState;
 899         }
 900 
 901         loopBegin.replaceAtUsagesAndDelete(merge);
 902         merge.setStateAfter(frameState);
 903         merge.setNext(successor);
 904         for (EndNode predecessor : predecessors) {
 905             merge.addForwardEnd(predecessor);
 906         }
 907 
 908         if (methodScope.loopExplosion.mergeLoops()) {
 909             LoopExplosionState explosionState = new LoopExplosionState(frameState, merge);
 910             loopScope.iterationStates.put(explosionState, explosionState);
 911         }
 912     }
 913 
 914     /**
 915      * Hook for subclasses.
 916      *
 917      * @param methodScope The current method.
 918      * @param loopScope The current loop.
 919      */
 920     protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope) {
 921         throw shouldNotReachHere(&quot;when subclass uses loop explosion, it needs to implement this method&quot;);
 922     }
 923 
 924     protected LoopScopeTrigger handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope) {
 925         /*
 926          * This method is only called if we reach a loop end and we use some kind of loop explosion,
 927          * i.e., we unroll loops or explode along loop ends.
 928          */
 929         LoopScopeTrigger trigger = null;
 930         Deque&lt;LoopScope&gt; nextIterations = null;
 931         if (methodScope.loopExplosion.duplicateLoopEnds()) {
 932             /*
 933              * Loop explosion along loop ends: We see a loop end, however we do not merge all loop
 934              * ends at a common merge node but rather duplicate the rest of the loop for every loop
 935              * end.
 936              */
 937             trigger = LoopScopeTrigger.LOOP_END_DUPLICATION;
 938             nextIterations = loopScope.nextIterationFromLoopEndDuplication;
 939         } else if (loopScope.nextIterationsFromUnrolling.isEmpty()) {
 940             /*
 941              * Regular loop unrolling, i.e., we reach a loop end node of a loop that should be
 942              * unrolled: We create a new successor scope.
 943              */
 944             trigger = LoopScopeTrigger.LOOP_BEGIN_UNROLLING;
 945             nextIterations = loopScope.nextIterationsFromUnrolling;
 946         }
 947         if (trigger != null) {
 948             int nextIterationNumber = nextIterations.isEmpty() ? loopScope.loopIteration + 1 : nextIterations.getLast().loopIteration + 1;
 949             LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId, trigger,
 950                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
 951                             Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),
 952                             loopScope.nextIterationFromLoopExitDuplication,
 953                             loopScope.nextIterationFromLoopEndDuplication,
 954                             loopScope.nextIterationsFromUnrolling,
 955                             loopScope.iterationStates);
 956             checkLoopExplosionIteration(methodScope, nextIterationScope);
 957             nextIterations.addLast(nextIterationScope);
 958             registerNode(nextIterationScope, loopScope.loopBeginOrderId, null, true, true);
 959             makeStubNode(methodScope, nextIterationScope, loopScope.loopBeginOrderId);
 960         }
 961         return trigger;
 962     }
 963 
 964     /**
 965      * Hook for subclasses.
 966      *
 967      * @param methodScope The current method.
 968      * @param loopScope The current loop.
 969      * @param nodeOrderId The orderId of the node.
 970      * @param node The node to be simplified.
 971      */
 972     protected void handleFixedNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId, FixedNode node) {
 973     }
 974 
 975     protected void handleProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopExitNode loopExit) {
 976         assert loopExit.stateAfter() == null;
 977         int stateAfterOrderId = readOrderId(methodScope);
 978         loopExit.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));
 979 
 980         int numProxies = methodScope.reader.getUVInt();
 981         for (int i = 0; i &lt; numProxies; i++) {
 982             int proxyOrderId = readOrderId(methodScope);
 983             ProxyNode proxy = (ProxyNode) ensureNodeCreated(methodScope, loopScope, proxyOrderId);
 984             /*
 985              * The ProxyNode transports a value from the loop to the outer scope. We therefore
 986              * register it in the outer scope.
 987              */
 988             if (loopScope.outer.createdNodes != loopScope.createdNodes) {
 989                 registerNode(loopScope.outer, proxyOrderId, proxy, false, false);
 990             }
 991         }
 992     }
 993 
 994     protected void handleLoopExplosionProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopScope outerScope, LoopExitNode loopExit, int loopExitOrderId) {
 995         assert loopExit.stateAfter() == null;
 996         int stateAfterOrderId = readOrderId(methodScope);
 997 
 998         BeginNode begin = graph.add(new BeginNode());
 999 
1000         FixedNode loopExitSuccessor = loopExit.next();
1001         loopExit.replaceAtPredecessor(begin);
1002 
1003         MergeNode loopExitPlaceholder = null;
1004         if (methodScope.loopExplosion.mergeLoops() &amp;&amp; loopScope.loopDepth == 1) {
1005             /*
1006              * This exit might end up as a loop exit of a loop detected after partial evaluation. We
1007              * need to be able to create a FrameState and the necessary proxy nodes in this case.
1008              */
1009             loopExitPlaceholder = graph.add(new MergeNode());
1010             methodScope.loopExplosionMerges.add(loopExitPlaceholder);
1011 
1012             EndNode end = graph.add(new EndNode());
1013             begin.setNext(end);
1014             loopExitPlaceholder.addForwardEnd(end);
1015 
1016             begin = graph.add(new BeginNode());
1017             loopExitPlaceholder.setNext(begin);
1018         }
1019 
1020         /*
1021          * In the original graph, the loop exit is not a merge node. Multiple exploded loop
1022          * iterations now take the same loop exit, so we have to introduce a new merge node to
1023          * handle the merge.
1024          */
1025         MergeNode merge = null;
1026         Node existingExit = lookupNode(outerScope, loopExitOrderId);
1027         if (existingExit == null) {
1028             /* First loop iteration that exits. No merge necessary yet. */
1029             registerNode(outerScope, loopExitOrderId, begin, false, false);
1030             begin.setNext(loopExitSuccessor);
1031 
1032         } else if (existingExit instanceof BeginNode) {
1033             /* Second loop iteration that exits. Create the merge. */
1034             merge = graph.add(new MergeNode());
1035             registerNode(outerScope, loopExitOrderId, merge, true, false);
1036             /* Add the first iteration. */
1037             EndNode firstEnd = graph.add(new EndNode());
1038             ((BeginNode) existingExit).setNext(firstEnd);
1039             merge.addForwardEnd(firstEnd);
1040             merge.setNext(loopExitSuccessor);
1041 
1042         } else {
1043             /* Subsequent loop iteration. Merge already created. */
1044             merge = (MergeNode) existingExit;
1045         }
1046 
1047         if (merge != null) {
1048             EndNode end = graph.add(new EndNode());
1049             begin.setNext(end);
1050             merge.addForwardEnd(end);
1051         }
1052 
1053         /*
1054          * Possibly create phi nodes for the original proxy nodes that flow out of the loop. Note
1055          * that we definitely do not need a proxy node itself anymore, since the loop was exploded
1056          * and is no longer present.
1057          */
1058         int numProxies = methodScope.reader.getUVInt();
1059         boolean phiCreated = false;
1060         for (int i = 0; i &lt; numProxies; i++) {
1061             int proxyOrderId = readOrderId(methodScope);
1062             ProxyNode proxy = (ProxyNode) ensureNodeCreated(methodScope, loopScope, proxyOrderId);
1063             ValueNode phiInput = proxy.value();
1064 
1065             if (loopExitPlaceholder != null) {
1066                 if (!phiInput.isConstant()) {
1067                     phiInput = graph.unique(new ProxyPlaceholder(phiInput, loopExitPlaceholder));
1068                 }
1069                 registerNode(loopScope, proxyOrderId, phiInput, true, false);
1070             }
1071 
1072             ValueNode replacement;
1073             ValueNode existing = (ValueNode) outerScope.createdNodes[proxyOrderId];
1074             if (existing == null || existing == phiInput) {
1075                 /*
1076                  * We are at the first loop exit, or the proxy carries the same value for all exits.
1077                  * We do not need a phi node yet.
1078                  */
1079                 registerNode(outerScope, proxyOrderId, phiInput, true, false);
1080                 replacement = phiInput;
1081 
1082             } else {
1083                 // Fortify: Suppress Null Dereference false positive
1084                 assert merge != null;
1085 
1086                 if (!merge.isPhiAtMerge(existing)) {
1087                     /* Now we have two different values, so we need to create a phi node. */
1088                     PhiNode phi = proxy.createPhi(merge);
1089                     /* Add the inputs from all previous exits. */
1090                     for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {
1091                         phi.addInput(existing);
1092                     }
1093                     /* Add the input from this exit. */
1094                     phi.addInput(phiInput);
1095                     registerNode(outerScope, proxyOrderId, phi, true, false);
1096                     replacement = phi;
1097                     phiCreated = true;
1098 
1099                 } else {
1100                     /* Phi node has been created before, so just add the new input. */
1101                     PhiNode phi = (PhiNode) existing;
1102                     phi.addInput(phiInput);
1103                     replacement = phi;
1104                 }
1105             }
1106             proxy.replaceAtUsagesAndDelete(replacement);
1107         }
1108 
1109         if (loopExitPlaceholder != null) {
1110             registerNode(loopScope, stateAfterOrderId, null, true, true);
1111             loopExitPlaceholder.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));
1112         }
1113 
1114         if (merge != null &amp;&amp; (merge.stateAfter() == null || phiCreated)) {
1115             FrameState oldStateAfter = merge.stateAfter();
1116             registerNode(outerScope, stateAfterOrderId, null, true, true);
1117             merge.setStateAfter((FrameState) ensureNodeCreated(methodScope, outerScope, stateAfterOrderId));
1118             if (oldStateAfter != null) {
1119                 oldStateAfter.safeDelete();
1120             }
1121         }
1122         loopExit.safeDelete();
1123         assert loopExitSuccessor.predecessor() == null;
1124         if (merge != null) {
1125             merge.getNodeClass().getSuccessorEdges().update(merge, null, loopExitSuccessor);
1126         } else {
1127             begin.getNodeClass().getSuccessorEdges().update(begin, null, loopExitSuccessor);
1128         }
1129     }
1130 
1131     protected void handlePhiFunctions(MethodScope methodScope, LoopScope phiInputScope, LoopScope phiNodeScope, AbstractEndNode end, AbstractMergeNode merge) {
1132 
1133         if (end instanceof LoopEndNode) {
1134             /*
1135              * Fix the loop end index and the number of loop ends. When we do canonicalization
1136              * during decoding, we can end up with fewer ends than the encoded graph had. And the
1137              * order of loop ends can be different.
1138              */
1139             int numEnds = ((LoopBeginNode) merge).loopEnds().count();
1140             ((LoopBeginNode) merge).nextEndIndex = numEnds;
1141             ((LoopEndNode) end).endIndex = numEnds - 1;
1142 
1143         } else {
1144             if (merge.ends == null) {
1145                 merge.ends = new NodeInputList&lt;&gt;(merge);
1146             }
1147             merge.addForwardEnd((EndNode) end);
1148         }
1149 
1150         /*
1151          * We create most phi functions lazily. Canonicalization and simplification during decoding
1152          * can lead to dead branches that are not decoded, so we might not need all phi functions
1153          * that the original graph contained. Since we process all predecessors before actually
1154          * processing the merge node, we have the final phi function when processing the merge node.
1155          * The only exception are loop headers of non-exploded loops: since backward branches are
1156          * not processed yet when processing the loop body, we need to create all phi functions
1157          * upfront.
1158          */
1159         boolean lazyPhi = allowLazyPhis() &amp;&amp; (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion.useExplosion());
1160         int numPhis = methodScope.reader.getUVInt();
1161         for (int i = 0; i &lt; numPhis; i++) {
1162             int phiInputOrderId = readOrderId(methodScope);
1163             int phiNodeOrderId = readOrderId(methodScope);
1164 
1165             ValueNode phiInput = (ValueNode) ensureNodeCreated(methodScope, phiInputScope, phiInputOrderId);
1166             ValueNode existing = (ValueNode) lookupNode(phiNodeScope, phiNodeOrderId);
1167 
1168             if (existing != null &amp;&amp; merge.phiPredecessorCount() == 1) {
1169                 /*
1170                  * When exploding loops and the code after the loop (FULL_EXPLODE_UNTIL_RETURN),
1171                  * then an existing value can already be registered: Parsing of the code before the
1172                  * loop registers it when preparing for the later merge. The code after the loop,
1173                  * which starts with a clone of the values that were created before the loop, sees
1174                  * the stale value when processing the merge the first time. We can safely ignore
1175                  * the stale value because it will never be needed to be merged (we are exploding
1176                  * until we hit a return).
1177                  */
1178                 assert methodScope.loopExplosion.duplicateLoopExits() &amp;&amp; phiNodeScope.loopIteration &gt; 0;
1179                 existing = null;
1180             }
1181 
1182             if (lazyPhi &amp;&amp; (existing == null || existing == phiInput)) {
1183                 /* Phi function not yet necessary. */
1184                 registerNode(phiNodeScope, phiNodeOrderId, phiInput, true, false);
1185 
1186             } else if (!merge.isPhiAtMerge(existing)) {
1187                 /*
1188                  * Phi function is necessary. Create it and fill it with existing inputs as well as
1189                  * the new input.
1190                  */
1191                 registerNode(phiNodeScope, phiNodeOrderId, null, true, true);
1192                 PhiNode phi = (PhiNode) ensureNodeCreated(methodScope, phiNodeScope, phiNodeOrderId);
1193 
1194                 phi.setMerge(merge);
1195                 for (int j = 0; j &lt; merge.phiPredecessorCount() - 1; j++) {
1196                     phi.addInput(existing);
1197                 }
1198                 phi.addInput(phiInput);
1199 
1200             } else {
1201                 /* Phi node has been created before, so just add the new input. */
1202                 PhiNode phi = (PhiNode) existing;
1203                 phi.addInput(phiInput);
1204             }
1205         }
1206     }
1207 
1208     protected boolean allowLazyPhis() {
1209         /* We need to exactly reproduce the encoded graph, including unnecessary phi functions. */
1210         return false;
1211     }
1212 
1213     protected void readProperties(MethodScope methodScope, Node node) {
1214         NodeSourcePosition position = (NodeSourcePosition) readObject(methodScope);
1215         Fields fields = node.getNodeClass().getData();
1216         for (int pos = 0; pos &lt; fields.getCount(); pos++) {
1217             if (fields.getType(pos).isPrimitive()) {
1218                 long primitive = methodScope.reader.getSV();
1219                 fields.setRawPrimitive(node, pos, primitive);
1220             } else {
1221                 Object value = readObject(methodScope);
1222                 fields.putObject(node, pos, value);
1223             }
1224         }
1225         if (graph.trackNodeSourcePosition() &amp;&amp; position != null) {
1226             NodeSourcePosition callerBytecodePosition = methodScope.getCallerBytecodePosition(position);
1227             node.setNodeSourcePosition(callerBytecodePosition);
1228             if (node instanceof DeoptimizingGuard) {
1229                 ((DeoptimizingGuard) node).addCallerToNoDeoptSuccessorPosition(callerBytecodePosition.getCaller());
1230             }
1231         }
1232     }
1233 
1234     /**
1235      * Process the input edges of a node. Input nodes that have not yet been created must be
1236      * non-fixed nodes (because fixed nodes are processed in reverse postorder. Such non-fixed nodes
1237      * are created on demand (recursively since they can themselves reference not yet created
1238      * nodes).
1239      */
1240     protected void makeFixedNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node) {
1241         Edges edges = node.getNodeClass().getInputEdges();
1242         for (int index = 0; index &lt; edges.getDirectCount(); index++) {
1243             if (skipDirectEdge(node, edges, index)) {
1244                 continue;
1245             }
1246             int orderId = readOrderId(methodScope);
1247             Node value = ensureNodeCreated(methodScope, loopScope, orderId);
1248             edges.initializeNode(node, index, value);
1249             if (value != null &amp;&amp; !value.isDeleted()) {
1250                 edges.update(node, null, value);
1251 
1252             }
1253         }
1254 
1255         if (node instanceof AbstractMergeNode) {
1256             /* The ends of merge nodes are filled manually when the ends are processed. */
1257             assert edges.getCount() - edges.getDirectCount() == 1 : &quot;MergeNode has one variable size input (the ends)&quot;;
1258             assert Edges.getNodeList(node, edges.getOffsets(), edges.getDirectCount()) != null : &quot;Input list must have been already created&quot;;
1259         } else {
1260             for (int index = edges.getDirectCount(); index &lt; edges.getCount(); index++) {
1261                 int size = methodScope.reader.getSVInt();
1262                 if (size != -1) {
1263                     NodeList&lt;Node&gt; nodeList = new NodeInputList&lt;&gt;(node, size);
1264                     edges.initializeList(node, index, nodeList);
1265                     for (int idx = 0; idx &lt; size; idx++) {
1266                         int orderId = readOrderId(methodScope);
1267                         Node value = ensureNodeCreated(methodScope, loopScope, orderId);
1268                         nodeList.initialize(idx, value);
1269                         if (value != null &amp;&amp; !value.isDeleted()) {
1270                             edges.update(node, null, value);
1271                         }
1272                     }
1273                 }
1274             }
1275         }
1276     }
1277 
1278     protected void makeFloatingNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node) {
1279         Edges edges = node.getNodeClass().getInputEdges();
1280         if (node instanceof PhiNode) {
1281             /*
1282              * The inputs of phi functions are filled manually when the end nodes are processed.
1283              * However, the values must not be null, so initialize them with an empty list.
1284              */
1285             assert edges.getDirectCount() == 1 : &quot;PhiNode has one direct input (the MergeNode)&quot;;
1286             assert edges.getCount() - edges.getDirectCount() == 1 : &quot;PhiNode has one variable size input (the values)&quot;;
1287             edges.initializeList(node, edges.getDirectCount(), new NodeInputList&lt;&gt;(node));
1288         } else {
1289             for (int index = 0; index &lt; edges.getDirectCount(); index++) {
1290                 int orderId = readOrderId(methodScope);
1291                 Node value = ensureNodeCreated(methodScope, loopScope, orderId);
1292                 edges.initializeNode(node, index, value);
1293             }
1294             for (int index = edges.getDirectCount(); index &lt; edges.getCount(); index++) {
1295                 int size = methodScope.reader.getSVInt();
1296                 if (size != -1) {
1297                     NodeList&lt;Node&gt; nodeList = new NodeInputList&lt;&gt;(node, size);
1298                     edges.initializeList(node, index, nodeList);
1299                     for (int idx = 0; idx &lt; size; idx++) {
1300                         int orderId = readOrderId(methodScope);
1301                         Node value = ensureNodeCreated(methodScope, loopScope, orderId);
1302                         nodeList.initialize(idx, value);
1303                     }
1304                 }
1305             }
1306         }
1307     }
1308 
1309     protected Node ensureNodeCreated(MethodScope methodScope, LoopScope loopScope, int nodeOrderId) {
1310         if (nodeOrderId == GraphEncoder.NULL_ORDER_ID) {
1311             return null;
1312         }
1313         Node node = lookupNode(loopScope, nodeOrderId);
1314         if (node != null) {
1315             return node;
1316         }
1317 
1318         node = decodeFloatingNode(methodScope, loopScope, nodeOrderId);
1319         if (node instanceof ProxyNode || node instanceof PhiNode) {
1320             /*
1321              * We need these nodes as they were in the original graph, without any canonicalization
1322              * or value numbering.
1323              */
1324             node = graph.addWithoutUnique(node);
1325         } else {
1326             /* Allow subclasses to canonicalize and intercept nodes. */
1327             Node newNode = handleFloatingNodeBeforeAdd(methodScope, loopScope, node);
1328             if (newNode != node) {
1329                 releaseFloatingNode(node);
1330             }
1331 
1332             if (!newNode.isAlive()) {
1333                 newNode = addFloatingNode(methodScope, newNode);
1334             }
1335             node = handleFloatingNodeAfterAdd(methodScope, loopScope, newNode);
1336         }
1337         registerNode(loopScope, nodeOrderId, node, false, false);
1338         return node;
1339     }
1340 
1341     protected Node addFloatingNode(@SuppressWarnings(&quot;unused&quot;) MethodScope methodScope, Node node) {
1342         /*
1343          * We want to exactly reproduce the encoded graph. Even though nodes should be unique in the
1344          * encoded graph, this is not always guaranteed.
1345          */
1346         return graph.addWithoutUnique(node);
1347     }
1348 
1349     /**
1350      * Decodes a non-fixed node, but does not do any post-processing and does not register it.
1351      */
1352     protected Node decodeFloatingNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId) {
1353         long readerByteIndex = methodScope.reader.getByteIndex();
1354 
1355         methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
1356         NodeClass&lt;?&gt; nodeClass = methodScope.encodedGraph.getNodeClasses()[methodScope.reader.getUVInt()];
1357         Node node = allocateFloatingNode(nodeClass);
1358         if (node instanceof FixedNode) {
1359             /*
1360              * This is a severe error that will lead to a corrupted graph, so it is better not to
1361              * continue decoding at all.
1362              */
1363             throw shouldNotReachHere(&quot;Not a floating node: &quot; + node.getClass().getName());
1364         }
1365 
1366         /* Read the inputs of the node, possibly creating them recursively. */
1367         makeFloatingNodeInputs(methodScope, loopScope, node);
1368 
1369         /* Read the properties of the node. */
1370         readProperties(methodScope, node);
1371         /* There must not be any successors to read, since it is a non-fixed node. */
1372         assert node.getNodeClass().getEdges(Edges.Type.Successors).getCount() == 0;
1373 
1374         methodScope.reader.setByteIndex(readerByteIndex);
1375         return node;
1376     }
1377 
1378     private Node allocateFloatingNode(NodeClass&lt;?&gt; nodeClass) {
1379         ArrayDeque&lt;? extends Node&gt; cachedNodes = reusableFloatingNodes.get(nodeClass);
1380         if (cachedNodes != null) {
1381             Node node = cachedNodes.poll();
1382             if (node != null) {
1383                 return node;
1384             }
1385         }
1386         return nodeClass.allocateInstance();
1387     }
1388 
1389     private void releaseFloatingNode(Node node) {
1390         ArrayDeque&lt;Node&gt; cachedNodes = reusableFloatingNodes.get(node.getNodeClass());
1391         if (cachedNodes == null) {
1392             cachedNodes = new ArrayDeque&lt;&gt;(2);
1393             reusableFloatingNodes.put(node.getNodeClass(), cachedNodes);
1394         }
1395         cachedNodes.push(node);
1396     }
1397 
1398     /**
1399      * Hook for subclasses to process a non-fixed node before it is added to the graph.
1400      *
1401      * @param methodScope The current method.
1402      * @param loopScope The current loop.
1403      * @param node The node to be canonicalized.
1404      * @return The replacement for the node, or the node itself.
1405      */
1406     protected Node handleFloatingNodeBeforeAdd(MethodScope methodScope, LoopScope loopScope, Node node) {
1407         return node;
1408     }
1409 
1410     /**
1411      * Hook for subclasses to process a non-fixed node after it is added to the graph.
1412      *
1413      * If this method replaces a node with another node, it must update its source position if the
1414      * original node has the source position set.
1415      *
1416      * @param methodScope The current method.
1417      * @param loopScope The current loop.
1418      * @param node The node to be canonicalized.
1419      * @return The replacement for the node, or the node itself.
1420      */
1421     protected Node handleFloatingNodeAfterAdd(MethodScope methodScope, LoopScope loopScope, Node node) {
1422         return node;
1423     }
1424 
1425     /**
1426      * Process successor edges of a node. We create the successor nodes so that we can fill the
1427      * successor list, but no properties or edges are loaded yet. That is done when the successor is
1428      * on top of the worklist in {@link #processNextNode}.
1429      */
1430     protected void makeSuccessorStubs(MethodScope methodScope, LoopScope loopScope, Node node, boolean updatePredecessors) {
1431         Edges edges = node.getNodeClass().getSuccessorEdges();
1432         for (int index = 0; index &lt; edges.getDirectCount(); index++) {
1433             if (skipDirectEdge(node, edges, index)) {
1434                 continue;
1435             }
1436             int orderId = readOrderId(methodScope);
1437             Node value = makeStubNode(methodScope, loopScope, orderId);
1438             edges.initializeNode(node, index, value);
1439             if (updatePredecessors &amp;&amp; value != null) {
1440                 edges.update(node, null, value);
1441             }
1442         }
1443         for (int index = edges.getDirectCount(); index &lt; edges.getCount(); index++) {
1444             int size = methodScope.reader.getSVInt();
1445             if (size != -1) {
1446                 NodeList&lt;Node&gt; nodeList = new NodeSuccessorList&lt;&gt;(node, size);
1447                 edges.initializeList(node, index, nodeList);
1448                 for (int idx = 0; idx &lt; size; idx++) {
1449                     int orderId = readOrderId(methodScope);
1450                     Node value = makeStubNode(methodScope, loopScope, orderId);
1451                     nodeList.initialize(idx, value);
1452                     if (updatePredecessors &amp;&amp; value != null) {
1453                         edges.update(node, null, value);
1454                     }
1455                 }
1456             }
1457         }
1458     }
1459 
1460     protected FixedNode makeStubNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId) {
1461         if (nodeOrderId == GraphEncoder.NULL_ORDER_ID) {
1462             return null;
1463         }
1464         FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);
1465         if (node != null) {
1466             return node;
1467         }
1468 
1469         long readerByteIndex = methodScope.reader.getByteIndex();
1470         methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);
1471         NodeClass&lt;?&gt; nodeClass = methodScope.encodedGraph.getNodeClasses()[methodScope.reader.getUVInt()];
1472         Node stubNode = nodeClass.allocateInstance();
1473         if (graph.trackNodeSourcePosition()) {
1474             stubNode.setNodeSourcePosition(NodeSourcePosition.placeholder(graph.method()));
1475         }
1476         node = (FixedNode) graph.add(stubNode);
1477         /* Properties and edges are not filled yet, the node remains uninitialized. */
1478         methodScope.reader.setByteIndex(readerByteIndex);
1479 
1480         registerNode(loopScope, nodeOrderId, node, false, false);
1481         loopScope.nodesToProcess.set(nodeOrderId);
1482         return node;
1483     }
1484 
1485     protected static boolean skipDirectEdge(Node node, Edges edges, int index) {
1486         if (node instanceof Invoke) {
1487             assert node instanceof InvokeNode || node instanceof InvokeWithExceptionNode : &quot;The only two Invoke node classes. Got &quot; + node.getClass();
1488             if (edges.type() == Edges.Type.Successors) {
1489                 assert edges.getCount() == (node instanceof InvokeWithExceptionNode ? 2 : 1) : &quot;InvokeNode has one successor (next); InvokeWithExceptionNode has two successors (next, exceptionEdge)&quot;;
1490                 return true;
1491             } else {
1492                 assert edges.type() == Edges.Type.Inputs;
1493                 if (edges.getType(index) == CallTargetNode.class) {
1494                     return true;
1495                 } else if (edges.getType(index) == FrameState.class) {
1496                     assert edges.get(node, index) == null || edges.get(node, index) == ((Invoke) node).stateAfter() : &quot;Only stateAfter can be a FrameState during encoding&quot;;
1497                     return true;
1498                 }
1499             }
1500         } else if (node instanceof LoopExitNode &amp;&amp; edges.type() == Edges.Type.Inputs &amp;&amp; edges.getType(index) == FrameState.class) {
1501             /* The stateAfter of the loop exit is filled manually. */
1502             return true;
1503 
1504         }
1505         return false;
1506     }
1507 
1508     protected Node lookupNode(LoopScope loopScope, int nodeOrderId) {
1509         return loopScope.createdNodes[nodeOrderId];
1510     }
1511 
1512     protected void registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull) {
1513         assert node == null || node.isAlive();
1514         assert allowNull || node != null;
1515         assert allowOverwrite || lookupNode(loopScope, nodeOrderId) == null;
1516         loopScope.createdNodes[nodeOrderId] = node;
1517     }
1518 
1519     protected int readOrderId(MethodScope methodScope) {
1520         return methodScope.reader.getUVInt();
1521     }
1522 
1523     protected Object readObject(MethodScope methodScope) {
1524         return methodScope.encodedGraph.getObject(methodScope.reader.getUVInt());
1525     }
1526 
1527     /**
1528      * Removes unnecessary nodes from the graph after decoding.
1529      *
1530      * @param methodScope The current method.
1531      */
1532     protected void cleanupGraph(MethodScope methodScope) {
1533         for (MergeNode merge : graph.getNodes(MergeNode.TYPE)) {
1534             for (ProxyPlaceholder placeholder : merge.usages().filter(ProxyPlaceholder.class).snapshot()) {
1535                 placeholder.replaceAndDelete(placeholder.value);
1536             }
1537         }
1538         assert verifyEdges();
1539     }
1540 
1541     protected boolean verifyEdges() {
1542         for (Node node : graph.getNodes()) {
1543             assert node.isAlive();
1544             for (Node i : node.inputs()) {
1545                 assert i.isAlive();
1546                 assert i.usages().contains(node);
1547             }
1548             for (Node s : node.successors()) {
1549                 assert s.isAlive();
1550                 assert s.predecessor() == node;
1551             }
1552 
1553             for (Node usage : node.usages()) {
1554                 assert usage.isAlive();
1555                 assert usage.inputs().contains(node) : node + &quot; / &quot; + usage + &quot; / &quot; + usage.inputs().count();
1556             }
1557             if (node.predecessor() != null) {
1558                 assert node.predecessor().isAlive();
1559                 assert node.predecessor().successors().contains(node);
1560             }
1561         }
1562         return true;
1563     }
1564 }
1565 
1566 class LoopDetector implements Runnable {
1567 
1568     /**
1569      * Information about loops before the actual loop nodes are inserted.
1570      */
1571     static class Loop {
1572         /**
1573          * The header, i.e., the target of backward branches.
1574          */
1575         MergeNode header;
1576         /**
1577          * The ends, i.e., the source of backward branches. The {@link EndNode#successors successor}
1578          * is the {@link #header loop header}.
1579          */
1580         List&lt;EndNode&gt; ends = new ArrayList&lt;&gt;(2);
1581         /**
1582          * Exits of the loop. The successor is a {@link MergeNode} marked in
1583          * {@link MethodScope#loopExplosionMerges}.
1584          */
1585         List&lt;AbstractEndNode&gt; exits = new ArrayList&lt;&gt;();
1586         /**
1587          * Set to true when the loop is irreducible, i.e., has multiple entries. See
1588          * {@link #handleIrreducibleLoop} for details on the handling.
1589          */
1590         boolean irreducible;
1591     }
1592 
1593     private final StructuredGraph graph;
1594     private final MethodScope methodScope;
1595 
1596     private Loop irreducibleLoopHandler;
1597     private IntegerSwitchNode irreducibleLoopSwitch;
1598 
1599     protected LoopDetector(StructuredGraph graph, MethodScope methodScope) {
1600         this.graph = graph;
1601         this.methodScope = methodScope;
1602     }
1603 
1604     @Override
1605     public void run() {
1606         DebugContext debug = graph.getDebug();
1607         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before loop detection&quot;);
1608 
1609         if (methodScope.loopExplosionHead == null) {
1610             /*
1611              * The to-be-exploded loop was not reached during partial evaluation (e.g., because
1612              * there was a deoptimization beforehand), or the method might not even contain a loop.
1613              * This is an uncommon case, but not an error.
1614              */
1615             return;
1616         }
1617 
1618         List&lt;Loop&gt; orderedLoops = findLoops();
1619         assert orderedLoops.get(orderedLoops.size() - 1) == irreducibleLoopHandler : &quot;outermost loop must be the last element in the list&quot;;
1620 
1621         for (Loop loop : orderedLoops) {
1622             if (loop.ends.isEmpty()) {
1623                 assert loop == irreducibleLoopHandler;
1624                 continue;
1625             }
1626 
1627             /*
1628              * The algorithm to find loop exits requires that inner loops have already been
1629              * processed. Therefore, we need to iterate the loops in order (inner loops before outer
1630              * loops), and we cannot find the exits for all loops before we start inserting nodes.
1631              */
1632             findLoopExits(loop);
1633 
1634             if (loop.irreducible) {
1635                 handleIrreducibleLoop(loop);
1636             } else {
1637                 insertLoopNodes(loop);
1638             }
1639             debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;After handling of loop %s&quot;, loop.header);
1640         }
1641 
1642         logIrreducibleLoops();
1643         debug.dump(DebugContext.DETAILED_LEVEL, graph, &quot;After loop detection&quot;);
1644     }
1645 
1646     private List&lt;Loop&gt; findLoops() {
1647         /* Mapping from the loop header node to additional loop information. */
1648         EconomicMap&lt;MergeNode, Loop&gt; unorderedLoops = EconomicMap.create(Equivalence.IDENTITY);
1649         /* Loops in reverse order of, i.e., inner loops before outer loops. */
1650         List&lt;Loop&gt; orderedLoops = new ArrayList&lt;&gt;();
1651 
1652         /*
1653          * Ensure we have an outermost loop that we can use to eliminate irreducible loops. This
1654          * loop can remain empty (no ends), in which case it is ignored.
1655          */
1656         irreducibleLoopHandler = findOrCreateLoop(unorderedLoops, methodScope.loopExplosionHead);
1657 
1658         NodeBitMap visited = graph.createNodeBitMap();
1659         NodeBitMap active = graph.createNodeBitMap();
1660         Deque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();
1661         visited.mark(methodScope.loopExplosionHead);
1662         stack.push(methodScope.loopExplosionHead);
1663 
1664         while (!stack.isEmpty()) {
1665             Node current = stack.peek();
1666             assert visited.isMarked(current);
1667 
1668             if (active.isMarked(current)) {
1669                 /* We are back-tracking, i.e., all successor nodes have been processed. */
1670                 stack.pop();
1671                 active.clear(current);
1672 
1673                 if (current instanceof MergeNode) {
1674                     Loop loop = unorderedLoops.get((MergeNode) current);
1675                     if (loop != null) {
1676                         /*
1677                          * Since nodes are popped in reverse order that they were pushed, we add
1678                          * inner loops before outer loops here.
1679                          */
1680                         assert !orderedLoops.contains(loop);
1681                         orderedLoops.add(loop);
1682                     }
1683                 }
1684 
1685             } else {
1686                 /*
1687                  * Process the node. Note that we do not remove the node from the stack, i.e., we
1688                  * will peek it again. But the next time the node is marked as active, so we do not
1689                  * execute this code again.
1690                  */
1691                 active.mark(current);
1692                 for (Node successor : current.cfgSuccessors()) {
1693                     if (active.isMarked(successor)) {
1694                         /* Detected a cycle, i.e., a backward branch of a loop. */
1695                         Loop loop = findOrCreateLoop(unorderedLoops, (MergeNode) successor);
1696                         assert !loop.ends.contains(current);
1697                         loop.ends.add((EndNode) current);
1698 
1699                     } else if (visited.isMarked(successor)) {
1700                         /* Forward merge into a branch we are already exploring. */
1701 
1702                     } else {
1703                         /* Forward branch to a node we have not seen yet. */
1704                         visited.mark(successor);
1705                         stack.push(successor);
1706                     }
1707                 }
1708             }
1709         }
1710         return orderedLoops;
1711     }
1712 
1713     private Loop findOrCreateLoop(EconomicMap&lt;MergeNode, Loop&gt; unorderedLoops, MergeNode loopHeader) {
1714         assert methodScope.loopExplosionMerges.contains(loopHeader) : loopHeader;
1715         Loop loop = unorderedLoops.get(loopHeader);
1716         if (loop == null) {
1717             loop = new Loop();
1718             loop.header = loopHeader;
1719             unorderedLoops.put(loopHeader, loop);
1720         }
1721         return loop;
1722     }
1723 
1724     private void findLoopExits(Loop loop) {
1725         /*
1726          * Backward marking of loop nodes: Starting with the known loop ends, we mark all nodes that
1727          * are reachable until we hit the loop begin. All successors of loop nodes that are not
1728          * marked as loop nodes themselves are exits of the loop. We mark all successors, and then
1729          * subtract the loop nodes, to find the exits.
1730          */
1731 
1732         List&lt;Node&gt; possibleExits = new ArrayList&lt;&gt;();
1733         NodeBitMap visited = graph.createNodeBitMap();
1734         Deque&lt;Node&gt; stack = new ArrayDeque&lt;&gt;();
1735         for (EndNode loopEnd : loop.ends) {
1736             stack.push(loopEnd);
1737             visited.mark(loopEnd);
1738         }
1739 
1740         while (!stack.isEmpty()) {
1741             Node current = stack.pop();
1742             if (current == loop.header) {
1743                 continue;
1744             }
1745             if (!graph.isNew(methodScope.methodStartMark, current)) {
1746                 /*
1747                  * The current node is before the method that contains the exploded loop. The loop
1748                  * must have a second entry point, i.e., it is an irreducible loop.
1749                  */
1750                 loop.irreducible = true;
1751                 return;
1752             }
1753 
1754             for (Node predecessor : current.cfgPredecessors()) {
1755                 if (predecessor instanceof LoopExitNode) {
1756                     /*
1757                      * Inner loop. We do not need to mark every node of it, instead we just continue
1758                      * marking at the loop header.
1759                      */
1760                     LoopBeginNode innerLoopBegin = ((LoopExitNode) predecessor).loopBegin();
1761                     if (!visited.isMarked(innerLoopBegin)) {
1762                         stack.push(innerLoopBegin);
1763                         visited.mark(innerLoopBegin);
1764 
1765                         /*
1766                          * All loop exits of the inner loop possibly need a LoopExit of our loop.
1767                          * Because we are processing inner loops first, we are guaranteed to already
1768                          * have all exits of the inner loop.
1769                          */
1770                         for (LoopExitNode exit : innerLoopBegin.loopExits()) {
1771                             possibleExits.add(exit);
1772                         }
1773                     }
1774 
1775                 } else if (!visited.isMarked(predecessor)) {
1776                     stack.push(predecessor);
1777                     visited.mark(predecessor);
1778 
1779                     if (predecessor instanceof ControlSplitNode) {
1780                         for (Node succ : predecessor.cfgSuccessors()) {
1781                             /*
1782                              * We would not need to mark the current node, and would not need to
1783                              * mark visited nodes. But it is easier to just mark everything, since
1784                              * we subtract all visited nodes in the end anyway. Note that at this
1785                              * point we do not have the complete visited information, so we would
1786                              * always mark too many possible exits.
1787                              */
1788                             possibleExits.add(succ);
1789                         }
1790                     }
1791                 }
1792             }
1793         }
1794 
1795         /*
1796          * Now we know all the actual loop exits. Ideally, we would insert LoopExit nodes for them.
1797          * However, a LoopExit needs a valid FrameState that captures the state at the point where
1798          * we exit the loop. During graph decoding, we create a FrameState for every exploded loop
1799          * iteration. We need to do a forward marking until we hit the next such point. This puts
1800          * some nodes into the loop that are actually not part of the loop.
1801          *
1802          * In some cases, we did not create a FrameState during graph decoding: when there was no
1803          * LoopExit in the original loop that we exploded. This happens for code paths that lead
1804          * immediately to a DeoptimizeNode.
1805          *
1806          * Both cases mimic the behavior of the BytecodeParser, which also puts more nodes than
1807          * necessary into a loop because it computes loop information based on bytecodes, before the
1808          * actual parsing.
1809          */
1810         for (Node succ : possibleExits) {
1811             if (!visited.contains(succ)) {
1812                 stack.push(succ);
1813                 visited.mark(succ);
1814                 assert !methodScope.loopExplosionMerges.contains(succ);
1815             }
1816         }
1817 
1818         while (!stack.isEmpty()) {
1819             Node current = stack.pop();
1820             assert visited.isMarked(current);
1821             assert current instanceof ControlSinkNode || current instanceof LoopEndNode || current.cfgSuccessors().iterator().hasNext() : &quot;Must not reach a node that has not been decoded yet&quot;;
1822 
1823             for (Node successor : current.cfgSuccessors()) {
1824                 if (visited.isMarked(successor)) {
1825                     /* Already processed this successor. */
1826 
1827                 } else if (methodScope.loopExplosionMerges.contains(successor)) {
1828                     /*
1829                      * We have a FrameState for the successor. The LoopExit will be inserted between
1830                      * the current node and the successor node. Since the successor node is a
1831                      * MergeNode, the current node mus be a AbstractEndNode with only that MergeNode
1832                      * as the successor.
1833                      */
1834                     assert successor instanceof MergeNode;
1835                     assert !loop.exits.contains(current);
1836                     loop.exits.add((AbstractEndNode) current);
1837 
1838                 } else {
1839                     /* Node we have not seen yet. */
1840                     visited.mark(successor);
1841                     stack.push(successor);
1842                 }
1843             }
1844         }
1845     }
1846 
1847     private void insertLoopNodes(Loop loop) {
1848         MergeNode merge = loop.header;
1849         FrameState stateAfter = merge.stateAfter().duplicate();
1850         FixedNode afterMerge = merge.next();
1851         merge.setNext(null);
1852         EndNode preLoopEnd = graph.add(new EndNode());
1853         LoopBeginNode loopBegin = graph.add(new LoopBeginNode());
1854 
1855         merge.setNext(preLoopEnd);
1856         /* Add the single non-loop predecessor of the loop header. */
1857         loopBegin.addForwardEnd(preLoopEnd);
1858         loopBegin.setNext(afterMerge);
1859         loopBegin.setStateAfter(stateAfter);
1860 
1861         /*
1862          * Phi functions of the original merge need to be split: inputs that come from forward edges
1863          * remain with the original phi function; inputs that come from backward edges are added to
1864          * new phi functions.
1865          */
1866         List&lt;PhiNode&gt; mergePhis = merge.phis().snapshot();
1867         List&lt;PhiNode&gt; loopBeginPhis = new ArrayList&lt;&gt;(mergePhis.size());
1868         for (int i = 0; i &lt; mergePhis.size(); i++) {
1869             PhiNode mergePhi = mergePhis.get(i);
1870             PhiNode loopBeginPhi = graph.addWithoutUnique(new ValuePhiNode(mergePhi.stamp(NodeView.DEFAULT), loopBegin));
1871             mergePhi.replaceAtUsages(loopBeginPhi);
1872             /*
1873              * The first input of the new phi function is the original phi function, for the one
1874              * forward edge of the LoopBeginNode.
1875              */
1876             loopBeginPhi.addInput(mergePhi);
1877             loopBeginPhis.add(loopBeginPhi);
1878         }
1879 
1880         for (EndNode endNode : loop.ends) {
1881             for (int i = 0; i &lt; mergePhis.size(); i++) {
1882                 PhiNode mergePhi = mergePhis.get(i);
1883                 PhiNode loopBeginPhi = loopBeginPhis.get(i);
1884                 loopBeginPhi.addInput(mergePhi.valueAt(endNode));
1885             }
1886 
1887             merge.removeEnd(endNode);
1888             LoopEndNode loopEnd = graph.add(new LoopEndNode(loopBegin));
1889             endNode.replaceAndDelete(loopEnd);
1890         }
1891 
1892         /*
1893          * Insert the LoopExit nodes (the easy part) and compute the FrameState for the new exits
1894          * (the difficult part).
1895          */
1896         for (AbstractEndNode exit : loop.exits) {
1897             AbstractMergeNode loopExplosionMerge = exit.merge();
1898             assert methodScope.loopExplosionMerges.contains(loopExplosionMerge);
1899 
1900             LoopExitNode loopExit = graph.add(new LoopExitNode(loopBegin));
1901             exit.replaceAtPredecessor(loopExit);
1902             loopExit.setNext(exit);
1903             assignLoopExitState(loopExit, loopExplosionMerge, exit);
1904         }
1905     }
1906 
1907     /**
1908      * During graph decoding, we create a FrameState for every exploded loop iteration. This is
1909      * mostly the state that we want, we only need to tweak it a little bit: we need to insert the
1910      * appropriate ProxyNodes for all values that are created inside the loop and that flow out of
1911      * the loop.
1912      */
1913     private void assignLoopExitState(LoopExitNode loopExit, AbstractMergeNode loopExplosionMerge, AbstractEndNode loopExplosionEnd) {
1914         FrameState oldState = loopExplosionMerge.stateAfter();
1915 
1916         /* Collect all nodes that are in the FrameState at the LoopBegin. */
1917         EconomicSet&lt;Node&gt; loopBeginValues = EconomicSet.create(Equivalence.IDENTITY);
1918         for (FrameState state = loopExit.loopBegin().stateAfter(); state != null; state = state.outerFrameState()) {
1919             for (ValueNode value : state.values()) {
1920                 if (value != null &amp;&amp; !value.isConstant() &amp;&amp; !loopExit.loopBegin().isPhiAtMerge(value)) {
1921                     loopBeginValues.add(ProxyPlaceholder.unwrap(value));
1922                 }
1923             }
1924         }
1925 
1926         List&lt;ValueNode&gt; newValues = new ArrayList&lt;&gt;(oldState.values().size());
1927         for (ValueNode v : oldState.values()) {
1928             ValueNode value = v;
1929             ValueNode realValue = ProxyPlaceholder.unwrap(value);
1930 
1931             /*
1932              * The LoopExit is inserted before the existing merge, i.e., separately for every branch
1933              * that leads to the merge. So for phi functions of the merge, we need to take the input
1934              * that corresponds to our branch.
1935              */
1936             if (realValue instanceof PhiNode &amp;&amp; loopExplosionMerge.isPhiAtMerge(realValue)) {
1937                 value = ((PhiNode) realValue).valueAt(loopExplosionEnd);
1938                 realValue = ProxyPlaceholder.unwrap(value);
1939             }
1940 
1941             if (realValue == null || realValue.isConstant() || loopBeginValues.contains(realValue) || !graph.isNew(methodScope.methodStartMark, realValue)) {
1942                 newValues.add(realValue);
1943             } else {
1944                 /*
1945                  * The node is not in the FrameState of the LoopBegin, i.e., it is a value computed
1946                  * inside the loop.
1947                  */
1948                 GraalError.guarantee(value instanceof ProxyPlaceholder &amp;&amp; ((ProxyPlaceholder) value).proxyPoint == loopExplosionMerge,
1949                                 &quot;Value flowing out of loop, but we are not prepared to insert a ProxyNode&quot;);
1950 
1951                 ProxyPlaceholder proxyPlaceholder = (ProxyPlaceholder) value;
1952                 ValueProxyNode proxy = ProxyNode.forValue(proxyPlaceholder.value, loopExit);
1953                 proxyPlaceholder.setValue(proxy);
1954                 newValues.add(proxy);
1955             }
1956         }
1957 
1958         FrameState newState = new FrameState(oldState.outerFrameState(), oldState.getCode(), oldState.bci, newValues, oldState.localsSize(), oldState.stackSize(), oldState.rethrowException(),
1959                         oldState.duringCall(), oldState.monitorIds(), oldState.virtualObjectMappings());
1960 
1961         assert loopExit.stateAfter() == null;
1962         loopExit.setStateAfter(graph.add(newState));
1963     }
1964 
1965     /**
1966      * Graal does not support irreducible loops (loops with more than one entry point). There are
1967      * two ways to make them reducible: 1) duplicate nodes (peel a loop iteration starting at the
1968      * second entry point until we reach the first entry point), or 2) insert a big outer loop
1969      * covering the whole method and build a state machine for the different loop entry points.
1970      * Since node duplication can lead to an exponential explosion of nodes in the worst case, we
1971      * use the second approach.
1972      *
1973      * We already did some preparations to insert a big outer loop:
1974      * {@link MethodScope#loopExplosionHead} is the loop header for the outer loop, and we ensured
1975      * that we have a {@link Loop} data object for it in {@link #irreducibleLoopHandler}.
1976      *
1977      * Now we need to insert the state machine. We have several implementation restrictions to make
1978      * that efficient:
1979      * &lt;ul&gt;
1980      * &lt;li&gt;There must be only one loop variable, i.e., one value that is different in the
1981      * {@link FrameState} of the different loop headers.&lt;/li&gt;
1982      * &lt;li&gt;The loop variable must use the primitive {@code int} type, because Graal only has a
1983      * {@link IntegerSwitchNode switch node} for {@code int}.&lt;/li&gt;
1984      * &lt;li&gt;The values of the loop variable that are merged are {@link PrimitiveConstant compile time
1985      * constants}.&lt;/li&gt;
1986      * &lt;/ul&gt;
1987      */
1988     private void handleIrreducibleLoop(Loop loop) {
1989         assert loop != irreducibleLoopHandler;
1990 
1991         FrameState loopState = loop.header.stateAfter();
1992         FrameState explosionHeadState = irreducibleLoopHandler.header.stateAfter();
1993         assert loopState.outerFrameState() == explosionHeadState.outerFrameState();
1994         NodeInputList&lt;ValueNode&gt; loopValues = loopState.values();
1995         NodeInputList&lt;ValueNode&gt; explosionHeadValues = explosionHeadState.values();
1996         assert loopValues.size() == explosionHeadValues.size();
1997 
1998         /*
1999          * Find the loop variable, and the value of the loop variable for our loop and the outermost
2000          * loop. There must be exactly one loop variable.
2001          */
2002         int loopVariableIndex = -1;
2003         ValueNode loopValue = null;
2004         ValueNode explosionHeadValue = null;
2005         for (int i = 0; i &lt; loopValues.size(); i++) {
2006             ValueNode curLoopValue = loopValues.get(i);
2007             ValueNode curExplosionHeadValue = explosionHeadValues.get(i);
2008 
2009             if (curLoopValue != curExplosionHeadValue) {
2010                 if (loopVariableIndex != -1) {
2011                     throw bailout(&quot;must have only one variable that is changed in loop. &quot; + loopValue + &quot; != &quot; + explosionHeadValue + &quot; and &quot; + curLoopValue + &quot; != &quot; + curExplosionHeadValue);
2012                 }
2013 
2014                 loopVariableIndex = i;
2015                 loopValue = curLoopValue;
2016                 explosionHeadValue = curExplosionHeadValue;
2017             }
2018         }
2019         assert loopVariableIndex != -1;
2020         assert explosionHeadValue != null;
2021 
2022         ValuePhiNode loopVariablePhi;
2023         SortedMap&lt;Integer, AbstractBeginNode&gt; dispatchTable = new TreeMap&lt;&gt;();
2024         AbstractBeginNode unreachableDefaultSuccessor;
2025         if (irreducibleLoopSwitch == null) {
2026             /*
2027              * This is the first irreducible loop. We need to build the initial state machine
2028              * (dispatch for the loop header of the outermost loop).
2029              */
2030             assert !irreducibleLoopHandler.header.isPhiAtMerge(explosionHeadValue);
2031             assert irreducibleLoopHandler.header.phis().isEmpty();
2032 
2033             /* The new phi function for the loop variable. */
2034             loopVariablePhi = graph.addWithoutUnique(new ValuePhiNode(explosionHeadValue.stamp(NodeView.DEFAULT).unrestricted(), irreducibleLoopHandler.header));
2035             for (int i = 0; i &lt; irreducibleLoopHandler.header.phiPredecessorCount(); i++) {
2036                 loopVariablePhi.addInput(explosionHeadValue);
2037             }
2038 
2039             /*
2040              * Build the new FrameState for the loop header. There is only once change in comparison
2041              * to the old FrameState: the loop variable is replaced with the phi function.
2042              */
2043             FrameState oldFrameState = explosionHeadState;
2044             List&lt;ValueNode&gt; newFrameStateValues = new ArrayList&lt;&gt;(explosionHeadValues.size());
2045             for (int i = 0; i &lt; explosionHeadValues.size(); i++) {
2046                 if (i == loopVariableIndex) {
2047                     newFrameStateValues.add(loopVariablePhi);
2048                 } else {
2049                     newFrameStateValues.add(explosionHeadValues.get(i));
2050                 }
2051             }
2052 
2053             FrameState newFrameState = graph.add(
2054                             new FrameState(oldFrameState.outerFrameState(), oldFrameState.getCode(), oldFrameState.bci, newFrameStateValues, oldFrameState.localsSize(),
2055                                             oldFrameState.stackSize(), oldFrameState.rethrowException(), oldFrameState.duringCall(), oldFrameState.monitorIds(),
2056                                             oldFrameState.virtualObjectMappings()));
2057             oldFrameState.replaceAtUsages(newFrameState);
2058 
2059             /*
2060              * Disconnect the outermost loop header from its loop body, so that we can later on
2061              * insert the switch node. Collect dispatch information for the outermost loop.
2062              */
2063             FixedNode handlerNext = irreducibleLoopHandler.header.next();
2064             irreducibleLoopHandler.header.setNext(null);
2065             BeginNode handlerBegin = graph.add(new BeginNode());
2066             handlerBegin.setNext(handlerNext);
2067             dispatchTable.put(asInt(explosionHeadValue), handlerBegin);
2068 
2069             /*
2070              * We know that there will always be a matching key in the switch. But Graal always
2071              * wants a default successor, so we build a dummy block that just deoptimizes.
2072              */
2073             unreachableDefaultSuccessor = graph.add(new BeginNode());
2074             DeoptimizeNode deopt = graph.add(new DeoptimizeNode(DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.UnreachedCode));
2075             unreachableDefaultSuccessor.setNext(deopt);
2076 
2077         } else {
2078             /*
2079              * This is the second or a subsequent irreducible loop, i.e., we already inserted a
2080              * switch node before. We re-create the dispatch state machine of that switch, so that
2081              * we can extend it with one more branch.
2082              */
2083             assert irreducibleLoopHandler.header.isPhiAtMerge(explosionHeadValue);
2084             assert irreducibleLoopHandler.header.phis().count() == 1 &amp;&amp; irreducibleLoopHandler.header.phis().first() == explosionHeadValue;
2085             assert irreducibleLoopSwitch.value() == explosionHeadValue;
2086 
2087             /* We can modify the phi function used by the old switch node. */
2088             loopVariablePhi = (ValuePhiNode) explosionHeadValue;
2089 
2090             /*
2091              * We cannot modify the old switch node. Insert all information from the old switch node
2092              * into our temporary data structures for the new, larger, switch node.
2093              */
2094             for (int i = 0; i &lt; irreducibleLoopSwitch.keyCount(); i++) {
2095                 int key = irreducibleLoopSwitch.keyAt(i).asInt();
2096                 dispatchTable.put(key, irreducibleLoopSwitch.successorAtKey(key));
2097             }
2098             unreachableDefaultSuccessor = irreducibleLoopSwitch.defaultSuccessor();
2099 
2100             /* Unlink and delete the old switch node, we do not need it anymore. */
2101             assert irreducibleLoopHandler.header.next() == irreducibleLoopSwitch;
2102             irreducibleLoopHandler.header.setNext(null);
2103             irreducibleLoopSwitch.clearSuccessors();
2104             irreducibleLoopSwitch.safeDelete();
2105         }
2106 
2107         /* Insert our loop into the dispatch state machine. */
2108         assert loop.header.phis().isEmpty();
2109         BeginNode dispatchBegin = graph.add(new BeginNode());
2110         EndNode dispatchEnd = graph.add(new EndNode());
2111         dispatchBegin.setNext(dispatchEnd);
2112         loop.header.addForwardEnd(dispatchEnd);
2113         int intLoopValue = asInt(loopValue);
2114         assert !dispatchTable.containsKey(intLoopValue);
2115         dispatchTable.put(intLoopValue, dispatchBegin);
2116 
2117         /* Disconnect the ends of our loop and re-connect them to the outermost loop header. */
2118         for (EndNode end : loop.ends) {
2119             loop.header.removeEnd(end);
2120             irreducibleLoopHandler.ends.add(end);
2121             irreducibleLoopHandler.header.addForwardEnd(end);
2122             loopVariablePhi.addInput(loopValue);
2123         }
2124 
2125         /* Build and insert the switch node. */
2126         irreducibleLoopSwitch = graph.add(createSwitch(loopVariablePhi, dispatchTable, unreachableDefaultSuccessor));
2127         irreducibleLoopHandler.header.setNext(irreducibleLoopSwitch);
2128     }
2129 
2130     private static int asInt(ValueNode node) {
2131         if (!node.isConstant() || node.asJavaConstant().getJavaKind() != JavaKind.Int) {
2132             throw bailout(&quot;must have a loop variable of type int. &quot; + node);
2133         }
2134         return node.asJavaConstant().asInt();
2135     }
2136 
2137     private static RuntimeException bailout(String msg) {
2138         throw new PermanentBailoutException(&quot;Graal implementation restriction: Method with %s loop explosion %s&quot;, LoopExplosionKind.MERGE_EXPLODE, msg);
2139     }
2140 
2141     private static IntegerSwitchNode createSwitch(ValuePhiNode switchedValue, SortedMap&lt;Integer, AbstractBeginNode&gt; dispatchTable, AbstractBeginNode defaultSuccessor) {
2142         int numKeys = dispatchTable.size();
2143         int numSuccessors = numKeys + 1;
2144 
2145         AbstractBeginNode[] switchSuccessors = new AbstractBeginNode[numSuccessors];
2146         int[] switchKeys = new int[numKeys];
2147         double[] switchKeyProbabilities = new double[numSuccessors];
2148         int[] switchKeySuccessors = new int[numSuccessors];
2149 
2150         int idx = 0;
2151         for (Map.Entry&lt;Integer, AbstractBeginNode&gt; entry : dispatchTable.entrySet()) {
2152             switchSuccessors[idx] = entry.getValue();
2153             switchKeys[idx] = entry.getKey();
2154             switchKeyProbabilities[idx] = 1d / numKeys;
2155             switchKeySuccessors[idx] = idx;
2156             idx++;
2157         }
2158         switchSuccessors[idx] = defaultSuccessor;
2159         /* We know the default branch is never going to be executed. */
2160         switchKeyProbabilities[idx] = 0;
2161         switchKeySuccessors[idx] = idx;
2162 
2163         return new IntegerSwitchNode(switchedValue, switchSuccessors, switchKeys, switchKeyProbabilities, switchKeySuccessors);
2164     }
2165 
2166     /**
2167      * Print information about irreducible loops, when enabled with -Dgraal.Log=IrreducibleLoops.
2168      */
2169     @SuppressWarnings(&quot;try&quot;)
2170     private void logIrreducibleLoops() {
2171         DebugContext debug = graph.getDebug();
2172         try (DebugContext.Scope s = debug.scope(&quot;IrreducibleLoops&quot;)) {
2173             if (debug.isLogEnabled(DebugContext.BASIC_LEVEL) &amp;&amp; irreducibleLoopSwitch != null) {
2174                 StringBuilder msg = new StringBuilder(&quot;Inserted state machine to remove irreducible loops. Dispatching to the following states: &quot;);
2175                 String sep = &quot;&quot;;
2176                 for (int i = 0; i &lt; irreducibleLoopSwitch.keyCount(); i++) {
2177                     msg.append(sep).append(irreducibleLoopSwitch.keyAt(i).asInt());
2178                     sep = &quot;, &quot;;
2179                 }
2180                 debug.log(DebugContext.BASIC_LEVEL, &quot;%s&quot;, msg);
2181             }
2182         }
2183     }
2184 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
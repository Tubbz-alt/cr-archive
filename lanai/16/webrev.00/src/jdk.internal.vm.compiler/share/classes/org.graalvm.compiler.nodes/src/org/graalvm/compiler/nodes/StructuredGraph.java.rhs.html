<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/StructuredGraph.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import java.util.ArrayList;
  28 import java.util.Collections;
  29 import java.util.Iterator;
  30 import java.util.List;
  31 import java.util.SortedSet;
  32 import java.util.TreeSet;
  33 import java.util.concurrent.atomic.AtomicLong;
  34 import java.util.function.Consumer;
  35 import java.util.stream.Collectors;
  36 
  37 import jdk.internal.vm.compiler.collections.EconomicMap;
  38 import jdk.internal.vm.compiler.collections.EconomicSet;
  39 import jdk.internal.vm.compiler.collections.Equivalence;
  40 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  41 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  42 import org.graalvm.compiler.api.replacements.Snippet;
  43 import org.graalvm.compiler.core.common.CancellationBailoutException;
  44 import org.graalvm.compiler.core.common.CompilationIdentifier;
  45 import org.graalvm.compiler.core.common.GraalOptions;
  46 import org.graalvm.compiler.core.common.cfg.BlockMap;
  47 import org.graalvm.compiler.core.common.type.Stamp;
  48 import org.graalvm.compiler.debug.DebugContext;
  49 import org.graalvm.compiler.debug.JavaMethodContext;
  50 import org.graalvm.compiler.debug.TTY;
  51 import org.graalvm.compiler.graph.Graph;
  52 import org.graalvm.compiler.graph.Node;
  53 import org.graalvm.compiler.graph.NodeMap;
  54 import org.graalvm.compiler.graph.NodeSourcePosition;
  55 import org.graalvm.compiler.nodes.calc.FloatingNode;
  56 import org.graalvm.compiler.nodes.cfg.Block;
  57 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  58 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  59 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  60 import org.graalvm.compiler.nodes.util.GraphUtil;
  61 import org.graalvm.compiler.options.OptionValues;
  62 
  63 import jdk.vm.ci.code.BytecodeFrame;
  64 import jdk.vm.ci.meta.Assumptions;
  65 import jdk.vm.ci.meta.Assumptions.Assumption;
  66 import jdk.vm.ci.meta.DefaultProfilingInfo;
  67 import jdk.vm.ci.meta.JavaMethod;
  68 import jdk.vm.ci.meta.ProfilingInfo;
  69 import jdk.vm.ci.meta.ResolvedJavaField;
  70 import jdk.vm.ci.meta.ResolvedJavaMethod;
  71 import jdk.vm.ci.meta.SpeculationLog;
  72 import jdk.vm.ci.meta.TriState;
  73 import jdk.vm.ci.runtime.JVMCICompiler;
  74 
  75 /**
  76  * A graph that contains at least one distinguished node : the {@link #start() start} node. This
  77  * node is the start of the control flow of the graph.
  78  */
  79 public final class StructuredGraph extends Graph implements JavaMethodContext {
  80 
  81     /**
  82      * The different stages of the compilation of a {@link Graph} regarding the status of
  83      * {@link GuardNode guards}, {@link DeoptimizingNode deoptimizations} and {@link FrameState
  84      * framestates}. The stage of a graph progresses monotonously.
  85      *
  86      */
  87     public enum GuardsStage {
  88         /**
  89          * During this stage, there can be {@link FloatingNode floating} {@link DeoptimizingNode}
  90          * such as {@link GuardNode GuardNodes}. New {@link DeoptimizingNode DeoptimizingNodes} can
  91          * be introduced without constraints. {@link FrameState} nodes are associated with
  92          * {@link StateSplit} nodes.
  93          */
  94         FLOATING_GUARDS,
  95         /**
  96          * During this stage, all {@link DeoptimizingNode DeoptimizingNodes} must be
  97          * {@link FixedNode fixed} but new {@link DeoptimizingNode DeoptimizingNodes} can still be
  98          * introduced. {@link FrameState} nodes are still associated with {@link StateSplit} nodes.
  99          */
 100         FIXED_DEOPTS,
 101         /**
 102          * During this stage, all {@link DeoptimizingNode DeoptimizingNodes} must be
 103          * {@link FixedNode fixed}. New {@link DeoptimizingNode DeoptimizingNodes} can not be
 104          * introduced any more. {@link FrameState} nodes are now associated with
 105          * {@link DeoptimizingNode} nodes.
 106          */
 107         AFTER_FSA;
 108 
 109         public boolean allowsFloatingGuards() {
 110             return this == FLOATING_GUARDS;
 111         }
 112 
 113         public boolean allowsGuardInsertion() {
 114             return this.ordinal() &lt;= FIXED_DEOPTS.ordinal();
 115         }
 116 
 117         public boolean areFrameStatesAtDeopts() {
 118             return this == AFTER_FSA;
 119         }
 120 
 121         public boolean areFrameStatesAtSideEffects() {
 122             return !this.areFrameStatesAtDeopts();
 123         }
 124 
 125         public boolean areDeoptsFixed() {
 126             return this.ordinal() &gt;= FIXED_DEOPTS.ordinal();
 127         }
 128 
 129         public boolean requiresValueProxies() {
 130             return this != AFTER_FSA;
 131         }
 132     }
 133 
 134     /**
 135      * Constants denoting whether or not {@link Assumption}s can be made while processing a graph.
 136      */
 137     public enum AllowAssumptions {
 138         YES,
 139         NO;
<a name="2" id="anc2"></a><span class="line-added"> 140 </span>
 141         public static AllowAssumptions ifTrue(boolean flag) {
 142             return flag ? YES : NO;
 143         }
 144 
 145         public static AllowAssumptions ifNonNull(Assumptions assumptions) {
 146             return assumptions != null ? YES : NO;
 147         }
 148     }
 149 
 150     public static class ScheduleResult {
 151         private final ControlFlowGraph cfg;
 152         private final NodeMap&lt;Block&gt; nodeToBlockMap;
 153         private final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap;
 154 
 155         public ScheduleResult(ControlFlowGraph cfg, NodeMap&lt;Block&gt; nodeToBlockMap, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap) {
 156             this.cfg = cfg;
 157             this.nodeToBlockMap = nodeToBlockMap;
 158             this.blockToNodesMap = blockToNodesMap;
 159         }
 160 
 161         public ControlFlowGraph getCFG() {
 162             return cfg;
 163         }
 164 
 165         public NodeMap&lt;Block&gt; getNodeToBlockMap() {
 166             return nodeToBlockMap;
 167         }
 168 
 169         public BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodesMap() {
 170             return blockToNodesMap;
 171         }
 172 
 173         public List&lt;Node&gt; nodesFor(Block block) {
 174             return blockToNodesMap.get(block);
 175         }
 176     }
 177 
 178     /**
 179      * Object used to create a {@link StructuredGraph}.
 180      */
 181     public static class Builder {
 182         private String name;
 183         private final Assumptions assumptions;
 184         private SpeculationLog speculationLog;
 185         private ResolvedJavaMethod rootMethod;
 186         private CompilationIdentifier compilationId = CompilationIdentifier.INVALID_COMPILATION_ID;
 187         private int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
 188         private boolean useProfilingInfo = true;
 189         private boolean recordInlinedMethods = true;
 190         private boolean trackNodeSourcePosition;
 191         private final OptionValues options;
 192         private Cancellable cancellable = null;
 193         private final DebugContext debug;
 194         private NodeSourcePosition callerContext;
 195         private boolean isSubstitution;
 196 
 197         /**
 198          * Creates a builder for a graph.
 199          */
 200         public Builder(OptionValues options, DebugContext debug, AllowAssumptions allowAssumptions) {
 201             this.options = options;
 202             this.debug = debug;
 203             this.assumptions = allowAssumptions == AllowAssumptions.YES ? new Assumptions() : null;
 204             this.trackNodeSourcePosition = Graph.trackNodeSourcePositionDefault(options, debug);
 205         }
 206 
 207         /**
 208          * Creates a builder for a graph that does not support {@link Assumptions}.
 209          */
 210         public Builder(OptionValues options, DebugContext debug) {
 211             this.options = options;
 212             this.debug = debug;
 213             this.assumptions = null;
 214             this.trackNodeSourcePosition = Graph.trackNodeSourcePositionDefault(options, debug);
 215         }
 216 
 217         public String getName() {
 218             return name;
 219         }
 220 
 221         public Builder name(String s) {
 222             this.name = s;
 223             return this;
 224         }
 225 
 226         /**
 227          * @see StructuredGraph#isSubstitution
 228          */
 229         public Builder setIsSubstitution(boolean flag) {
 230             this.isSubstitution = flag;
 231             return this;
 232         }
 233 
 234         public ResolvedJavaMethod getMethod() {
 235             return rootMethod;
 236         }
 237 
 238         public Builder method(ResolvedJavaMethod method) {
 239             this.rootMethod = method;
 240             return this;
 241         }
 242 
 243         public DebugContext getDebug() {
 244             return debug;
 245         }
 246 
 247         public SpeculationLog getSpeculationLog() {
 248             return speculationLog;
 249         }
 250 
 251         public Builder speculationLog(SpeculationLog log) {
 252             this.speculationLog = log;
 253             return this;
 254         }
 255 
 256         public CompilationIdentifier getCompilationId() {
 257             return compilationId;
 258         }
 259 
 260         public Builder compilationId(CompilationIdentifier id) {
 261             this.compilationId = id;
 262             return this;
 263         }
 264 
 265         public Cancellable getCancellable() {
 266             return cancellable;
 267         }
 268 
 269         public Builder cancellable(Cancellable cancel) {
 270             this.cancellable = cancel;
 271             return this;
 272         }
 273 
 274         public int getEntryBCI() {
 275             return entryBCI;
 276         }
 277 
 278         public Builder entryBCI(int bci) {
 279             this.entryBCI = bci;
 280             return this;
 281         }
 282 
 283         public boolean getUseProfilingInfo() {
 284             return useProfilingInfo;
 285         }
 286 
 287         public Builder useProfilingInfo(boolean flag) {
 288             this.useProfilingInfo = flag;
 289             return this;
 290         }
 291 
 292         public boolean getRecordInlinedMethods() {
 293             return recordInlinedMethods;
 294         }
 295 
 296         public Builder recordInlinedMethods(boolean flag) {
 297             this.recordInlinedMethods = flag;
 298             return this;
 299         }
 300 
 301         public Builder trackNodeSourcePosition(boolean flag) {
 302             if (flag) {
 303                 this.trackNodeSourcePosition = true;
 304             }
 305             return this;
 306         }
 307 
 308         public Builder callerContext(NodeSourcePosition context) {
 309             this.callerContext = context;
 310             return this;
 311         }
 312 
 313         public StructuredGraph build() {
 314             List&lt;ResolvedJavaMethod&gt; inlinedMethods = recordInlinedMethods ? new ArrayList&lt;&gt;() : null;
 315             // @formatter:off
 316             return new StructuredGraph(name,
 317                             rootMethod,
 318                             entryBCI,
 319                             assumptions,
 320                             speculationLog,
 321                             useProfilingInfo,
 322                             isSubstitution,
 323                             inlinedMethods,
 324                             trackNodeSourcePosition,
 325                             compilationId,
 326                             options,
 327                             debug,
 328                             cancellable,
 329                             callerContext);
 330             // @formatter:on
 331         }
 332     }
 333 
 334     public static final long INVALID_GRAPH_ID = -1;
 335     private static final AtomicLong uniqueGraphIds = new AtomicLong();
 336 
 337     private StartNode start;
 338     private ResolvedJavaMethod rootMethod;
 339     private final long graphId;
 340     private final CompilationIdentifier compilationId;
 341     private final int entryBCI;
 342     private GuardsStage guardsStage = GuardsStage.FLOATING_GUARDS;
 343     private boolean isAfterFloatingReadPhase = false;
 344     private boolean isAfterFixedReadPhase = false;
 345     private boolean hasValueProxies = true;
 346     private boolean isAfterExpandLogic = false;
 347     private final boolean useProfilingInfo;
 348     private final Cancellable cancellable;
 349     private final boolean isSubstitution;
 350 
 351     /**
 352      * The assumptions made while constructing and transforming this graph.
 353      */
 354     private final Assumptions assumptions;
 355 
 356     private SpeculationLog speculationLog;
 357 
 358     private ScheduleResult lastSchedule;
 359 
 360     private final InliningLog inliningLog;
 361 
 362     /**
 363      * Call stack (context) leading to construction of this graph.
 364      */
 365     private final NodeSourcePosition callerContext;
 366 
 367     /**
 368      * Records the methods that were used while constructing this graph, one entry for each time a
 369      * specific method is used. This will be {@code null} if recording of inlined methods is
 370      * disabled for the graph.
 371      */
 372     private final List&lt;ResolvedJavaMethod&gt; methods;
 373 
 374     /**
 375      * Records the fields that were accessed while constructing this graph.
 376      */
 377     private EconomicSet&lt;ResolvedJavaField&gt; fields = null;
 378 
 379     private enum UnsafeAccessState {
 380         NO_ACCESS,
 381         HAS_ACCESS,
 382         DISABLED
 383     }
 384 
 385     private UnsafeAccessState hasUnsafeAccess = UnsafeAccessState.NO_ACCESS;
 386 
 387     public static final boolean USE_PROFILING_INFO = true;
 388 
 389     public static final boolean NO_PROFILING_INFO = false;
 390 
 391     private StructuredGraph(String name,
 392                     ResolvedJavaMethod method,
 393                     int entryBCI,
 394                     Assumptions assumptions,
 395                     SpeculationLog speculationLog,
 396                     boolean useProfilingInfo,
 397                     boolean isSubstitution,
 398                     List&lt;ResolvedJavaMethod&gt; methods,
 399                     boolean trackNodeSourcePosition,
 400                     CompilationIdentifier compilationId,
 401                     OptionValues options,
 402                     DebugContext debug,
 403                     Cancellable cancellable,
 404                     NodeSourcePosition context) {
 405         super(name, options, debug, trackNodeSourcePosition);
 406         this.setStart(add(new StartNode()));
 407         this.rootMethod = method;
 408         this.graphId = uniqueGraphIds.incrementAndGet();
 409         this.compilationId = compilationId;
 410         this.entryBCI = entryBCI;
 411         this.assumptions = assumptions;
 412         this.methods = methods;
 413         this.speculationLog = speculationLog;
 414         this.useProfilingInfo = useProfilingInfo;
 415         this.isSubstitution = isSubstitution;
 416         assert checkIsSubstitutionInvariants(method, isSubstitution);
 417         this.cancellable = cancellable;
 418         this.inliningLog = new InliningLog(rootMethod, GraalOptions.TraceInlining.getValue(options));
 419         this.callerContext = context;
 420     }
 421 
 422     private static boolean checkIsSubstitutionInvariants(ResolvedJavaMethod method, boolean isSubstitution) {
 423         if (method != null) {
 424             if (method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null) {
 425                 assert isSubstitution : &quot;Graph for method &quot; + method.format(&quot;%H.%n(%p)&quot;) +
 426                                 &quot; annotated by &quot; + Snippet.class.getName() + &quot; or &quot; +
 427                                 MethodSubstitution.class.getName() +
 428                                 &quot; must have its `isSubstitution` field set to true&quot;;
 429             }
 430         }
 431         return true;
 432     }
 433 
 434     public void setLastSchedule(ScheduleResult result) {
 435         lastSchedule = result;
 436     }
 437 
 438     public ScheduleResult getLastSchedule() {
 439         return lastSchedule;
 440     }
 441 
 442     public void clearLastSchedule() {
 443         setLastSchedule(null);
 444     }
 445 
 446     @Override
 447     public boolean maybeCompress() {
 448         if (super.maybeCompress()) {
 449             /*
 450              * The schedule contains a NodeMap which is unusable after compression.
 451              */
 452             clearLastSchedule();
 453             return true;
 454         }
 455         return false;
 456     }
 457 
 458     public Stamp getReturnStamp() {
 459         Stamp returnStamp = null;
 460         for (ReturnNode returnNode : getNodes(ReturnNode.TYPE)) {
 461             ValueNode result = returnNode.result();
 462             if (result != null) {
 463                 if (returnStamp == null) {
 464                     returnStamp = result.stamp(NodeView.DEFAULT);
 465                 } else {
 466                     returnStamp = returnStamp.meet(result.stamp(NodeView.DEFAULT));
 467                 }
 468             }
 469         }
 470         return returnStamp;
 471     }
 472 
 473     @Override
 474     public String toString() {
 475         StringBuilder buf = new StringBuilder(getClass().getSimpleName() + &quot;:&quot; + graphId);
 476         String sep = &quot;{&quot;;
 477         if (name != null) {
 478             buf.append(sep);
 479             buf.append(name);
 480             sep = &quot;, &quot;;
 481         }
 482         if (method() != null) {
 483             buf.append(sep);
 484             buf.append(method());
 485             sep = &quot;, &quot;;
 486         }
 487 
 488         if (!sep.equals(&quot;{&quot;)) {
 489             buf.append(&quot;}&quot;);
 490         }
 491         return buf.toString();
 492     }
 493 
 494     public StartNode start() {
 495         return start;
 496     }
 497 
 498     /**
 499      * Gets the root method from which this graph was built.
 500      *
 501      * @return null if this method was not built from a method or the method is not available
 502      */
 503     public ResolvedJavaMethod method() {
 504         return rootMethod;
 505     }
 506 
 507     public int getEntryBCI() {
 508         return entryBCI;
 509     }
 510 
 511     public Cancellable getCancellable() {
 512         return cancellable;
 513     }
 514 
 515     public void checkCancellation() {
 516         if (cancellable != null &amp;&amp; cancellable.isCancelled()) {
 517             CancellationBailoutException.cancelCompilation();
 518         }
 519     }
 520 
 521     public boolean isOSR() {
 522         return entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
 523     }
 524 
 525     public long graphId() {
 526         return graphId;
 527     }
 528 
 529     /**
 530      * @see CompilationIdentifier
 531      */
 532     public CompilationIdentifier compilationId() {
 533         return compilationId;
 534     }
 535 
 536     public void setStart(StartNode start) {
 537         this.start = start;
 538     }
 539 
 540     public InliningLog getInliningLog() {
 541         return inliningLog;
 542     }
 543 
 544     public void logInliningTree() {
 545         if (GraalOptions.TraceInlining.getValue(getOptions())) {
 546             String formattedTree = getInliningLog().formatAsTree(true);
 547             if (formattedTree != null) {
 548                 TTY.println(formattedTree);
 549             }
 550         }
 551     }
 552 
 553     /**
 554      * Creates a copy of this graph.
 555      *
<a name="3" id="anc3"></a><span class="line-added"> 556      * If a node contains an array of objects, only shallow copy of the field is applied.</span>
<span class="line-added"> 557      *</span>
 558      * @param newName the name of the copy, used for debugging purposes (can be null)
 559      * @param duplicationMapCallback consumer of the duplication map created during the copying
 560      * @param debugForCopy the debug context for the graph copy. This must not be the debug for this
 561      *            graph if this graph can be accessed from multiple threads (e.g., it&#39;s in a cache
 562      *            accessed by multiple threads).
 563      */
 564     @Override
 565     protected Graph copy(String newName, Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicationMapCallback, DebugContext debugForCopy) {
 566         return copy(newName, duplicationMapCallback, compilationId, debugForCopy);
 567     }
 568 
 569     @SuppressWarnings(&quot;try&quot;)
 570     private StructuredGraph copy(String newName, Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicationMapCallback, CompilationIdentifier newCompilationId, DebugContext debugForCopy) {
 571         AllowAssumptions allowAssumptions = AllowAssumptions.ifNonNull(assumptions);
 572         StructuredGraph copy = new StructuredGraph(newName,
 573                         method(),
 574                         entryBCI,
 575                         assumptions == null ? null : new Assumptions(),
 576                         speculationLog,
 577                         useProfilingInfo,
 578                         isSubstitution,
 579                         methods != null ? new ArrayList&lt;&gt;(methods) : null,
 580                         trackNodeSourcePosition,
 581                         newCompilationId,
 582                         getOptions(), debugForCopy, null, callerContext);
 583         if (allowAssumptions == AllowAssumptions.YES &amp;&amp; assumptions != null) {
 584             copy.assumptions.record(assumptions);
 585         }
 586         copy.hasUnsafeAccess = hasUnsafeAccess;
 587         copy.setGuardsStage(getGuardsStage());
 588         copy.isAfterFloatingReadPhase = isAfterFloatingReadPhase;
 589         copy.hasValueProxies = hasValueProxies;
 590         copy.isAfterExpandLogic = isAfterExpandLogic;
 591         copy.trackNodeSourcePosition = trackNodeSourcePosition;
 592         if (fields != null) {
 593             copy.fields = createFieldSet(fields);
 594         }
 595         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);
 596         replacements.put(start, copy.start);
 597         UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
 598         try (InliningLog.UpdateScope scope = copy.getInliningLog().openDefaultUpdateScope()) {
 599             duplicates = copy.addDuplicates(getNodes(), this, this.getNodeCount(), replacements);
 600             if (scope != null) {
 601                 copy.getInliningLog().replaceLog(duplicates, this.getInliningLog());
 602             }
 603         }
 604         if (duplicationMapCallback != null) {
 605             duplicationMapCallback.accept(duplicates);
 606         }
 607         return copy;
 608     }
 609 
 610     /**
 611      * @param debugForCopy the debug context for the graph copy. This must not be the debug for this
 612      *            graph if this graph can be accessed from multiple threads (e.g., it&#39;s in a cache
 613      *            accessed by multiple threads).
 614      */
 615     public StructuredGraph copyWithIdentifier(CompilationIdentifier newCompilationId, DebugContext debugForCopy) {
 616         return copy(name, null, newCompilationId, debugForCopy);
 617     }
 618 
 619     public ParameterNode getParameter(int index) {
 620         for (ParameterNode param : getNodes(ParameterNode.TYPE)) {
 621             if (param.index() == index) {
 622                 return param;
 623             }
 624         }
 625         return null;
 626     }
 627 
 628     public Iterable&lt;Invoke&gt; getInvokes() {
 629         final Iterator&lt;MethodCallTargetNode&gt; callTargets = getNodes(MethodCallTargetNode.TYPE).iterator();
 630         return new Iterable&lt;Invoke&gt;() {
 631 
 632             private Invoke next;
 633 
 634             @Override
 635             public Iterator&lt;Invoke&gt; iterator() {
 636                 return new Iterator&lt;Invoke&gt;() {
 637 
 638                     @Override
 639                     public boolean hasNext() {
 640                         if (next == null) {
 641                             while (callTargets.hasNext()) {
 642                                 Invoke i = callTargets.next().invoke();
 643                                 if (i != null) {
 644                                     next = i;
 645                                     return true;
 646                                 }
 647                             }
 648                             return false;
 649                         } else {
 650                             return true;
 651                         }
 652                     }
 653 
 654                     @Override
 655                     public Invoke next() {
 656                         try {
 657                             return next;
 658                         } finally {
 659                             next = null;
 660                         }
 661                     }
 662 
 663                     @Override
 664                     public void remove() {
 665                         throw new UnsupportedOperationException();
 666                     }
 667                 };
 668             }
 669         };
 670     }
 671 
 672     public boolean hasLoops() {
 673         return hasNode(LoopBeginNode.TYPE);
 674     }
 675 
 676     /**
 677      * Unlinks a node from all its control flow neighbors and then removes it from its graph. The
 678      * node must have no {@linkplain Node#usages() usages}.
 679      *
 680      * @param node the node to be unlinked and removed
 681      */
 682     @SuppressWarnings(&quot;static-method&quot;)
 683     public void removeFixed(FixedWithNextNode node) {
 684         assert node != null;
 685         if (node instanceof AbstractBeginNode) {
 686             ((AbstractBeginNode) node).prepareDelete();
 687         }
 688         assert node.hasNoUsages() : node + &quot; &quot; + node.getUsageCount() + &quot;, &quot; + node.usages().first();
 689         GraphUtil.unlinkFixedNode(node);
 690         node.safeDelete();
 691     }
 692 
 693     public void replaceFixed(FixedWithNextNode node, Node replacement) {
 694         if (replacement instanceof FixedWithNextNode) {
 695             replaceFixedWithFixed(node, (FixedWithNextNode) replacement);
 696         } else {
 697             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 698             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 699             replaceFixedWithFloating(node, (FloatingNode) replacement);
 700         }
 701     }
 702 
 703     public void replaceFixedWithFixed(FixedWithNextNode node, FixedWithNextNode replacement) {
 704         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 705         FixedNode next = node.next();
 706         node.setNext(null);
 707         replacement.setNext(next);
 708         node.replaceAndDelete(replacement);
 709         if (node == start) {
 710             setStart((StartNode) replacement);
 711         }
 712     }
 713 
 714     @SuppressWarnings(&quot;static-method&quot;)
 715     public void replaceFixedWithFloating(FixedWithNextNode node, ValueNode replacement) {
 716         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 717         GraphUtil.unlinkFixedNode(node);
 718         node.replaceAtUsagesAndDelete(replacement);
 719     }
 720 
 721     @SuppressWarnings(&quot;static-method&quot;)
 722     public void removeSplit(ControlSplitNode node, AbstractBeginNode survivingSuccessor) {
 723         assert node != null;
 724         assert node.hasNoUsages();
 725         assert survivingSuccessor != null;
 726         node.clearSuccessors();
 727         node.replaceAtPredecessor(survivingSuccessor);
 728         node.safeDelete();
 729     }
 730 
 731     @SuppressWarnings(&quot;static-method&quot;)
 732     public void removeSplitPropagate(ControlSplitNode node, AbstractBeginNode survivingSuccessor) {
 733         assert node != null;
 734         assert node.hasNoUsages();
 735         assert survivingSuccessor != null;
 736         List&lt;Node&gt; snapshot = node.successors().snapshot();
 737         node.clearSuccessors();
 738         node.replaceAtPredecessor(survivingSuccessor);
 739         node.safeDelete();
 740         for (Node successor : snapshot) {
 741             if (successor != null &amp;&amp; successor.isAlive()) {
 742                 if (successor != survivingSuccessor) {
 743                     GraphUtil.killCFG((FixedNode) successor);
 744                 }
 745             }
 746         }
 747     }
 748 
 749     public void replaceSplit(ControlSplitNode node, Node replacement, AbstractBeginNode survivingSuccessor) {
 750         if (replacement instanceof FixedWithNextNode) {
 751             replaceSplitWithFixed(node, (FixedWithNextNode) replacement, survivingSuccessor);
 752         } else {
 753             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 754             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 755             replaceSplitWithFloating(node, (FloatingNode) replacement, survivingSuccessor);
 756         }
 757     }
 758 
 759     @SuppressWarnings(&quot;static-method&quot;)
 760     public void replaceSplitWithFixed(ControlSplitNode node, FixedWithNextNode replacement, AbstractBeginNode survivingSuccessor) {
 761         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 762         assert survivingSuccessor != null;
 763         node.clearSuccessors();
 764         replacement.setNext(survivingSuccessor);
 765         node.replaceAndDelete(replacement);
 766     }
 767 
 768     @SuppressWarnings(&quot;static-method&quot;)
 769     public void replaceSplitWithFloating(ControlSplitNode node, FloatingNode replacement, AbstractBeginNode survivingSuccessor) {
 770         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 771         assert survivingSuccessor != null;
 772         node.clearSuccessors();
 773         node.replaceAtPredecessor(survivingSuccessor);
 774         node.replaceAtUsagesAndDelete(replacement);
 775     }
 776 
 777     @SuppressWarnings(&quot;static-method&quot;)
 778     public void addAfterFixed(FixedWithNextNode node, FixedNode newNode) {
 779         assert node != null &amp;&amp; newNode != null &amp;&amp; node.isAlive() &amp;&amp; newNode.isAlive() : &quot;cannot add &quot; + newNode + &quot; after &quot; + node;
 780         FixedNode next = node.next();
 781         node.setNext(newNode);
 782         if (next != null) {
 783             assert newNode instanceof FixedWithNextNode;
 784             FixedWithNextNode newFixedWithNext = (FixedWithNextNode) newNode;
 785             assert newFixedWithNext.next() == null;
 786             newFixedWithNext.setNext(next);
 787         }
 788     }
 789 
 790     @SuppressWarnings(&quot;static-method&quot;)
 791     public void addBeforeFixed(FixedNode node, FixedWithNextNode newNode) {
 792         assert node != null &amp;&amp; newNode != null &amp;&amp; node.isAlive() &amp;&amp; newNode.isAlive() : &quot;cannot add &quot; + newNode + &quot; before &quot; + node;
 793         assert node.predecessor() != null &amp;&amp; node.predecessor() instanceof FixedWithNextNode : &quot;cannot add &quot; + newNode + &quot; before &quot; + node;
 794         assert newNode.next() == null : newNode;
 795         assert !(node instanceof AbstractMergeNode);
 796         FixedWithNextNode pred = (FixedWithNextNode) node.predecessor();
 797         pred.setNext(newNode);
 798         newNode.setNext(node);
 799     }
 800 
 801     public void reduceDegenerateLoopBegin(LoopBeginNode begin) {
 802         assert begin.loopEnds().isEmpty() : &quot;Loop begin still has backedges&quot;;
 803         if (begin.forwardEndCount() == 1) { // bypass merge and remove
 804             reduceTrivialMerge(begin);
 805         } else { // convert to merge
 806             AbstractMergeNode merge = this.add(new MergeNode());
 807             for (EndNode end : begin.forwardEnds()) {
 808                 merge.addForwardEnd(end);
 809             }
 810             this.replaceFixedWithFixed(begin, merge);
 811         }
 812     }
 813 
 814     @SuppressWarnings(&quot;static-method&quot;)
 815     public void reduceTrivialMerge(AbstractMergeNode merge) {
 816         assert merge.forwardEndCount() == 1;
 817         assert !(merge instanceof LoopBeginNode) || ((LoopBeginNode) merge).loopEnds().isEmpty();
 818         for (PhiNode phi : merge.phis().snapshot()) {
 819             assert phi.valueCount() == 1;
 820             ValueNode singleValue = phi.valueAt(0);
 821             if (phi.hasUsages()) {
 822                 phi.replaceAtUsagesAndDelete(singleValue);
 823             } else {
 824                 phi.safeDelete();
 825                 if (singleValue != null) {
 826                     GraphUtil.tryKillUnused(singleValue);
 827                 }
 828             }
 829         }
 830         // remove loop exits
 831         if (merge instanceof LoopBeginNode) {
 832             ((LoopBeginNode) merge).removeExits();
 833         }
 834         AbstractEndNode singleEnd = merge.forwardEndAt(0);
 835         FixedNode sux = merge.next();
 836         FrameState stateAfter = merge.stateAfter();
 837         // evacuateGuards
 838         merge.prepareDelete((FixedNode) singleEnd.predecessor());
 839         merge.safeDelete();
 840         if (stateAfter != null) {
 841             GraphUtil.tryKillUnused(stateAfter);
 842         }
 843         if (sux == null) {
 844             singleEnd.replaceAtPredecessor(null);
 845             singleEnd.safeDelete();
 846         } else {
 847             singleEnd.replaceAndDelete(sux);
 848         }
 849     }
 850 
 851     public GuardsStage getGuardsStage() {
 852         return guardsStage;
 853     }
 854 
 855     public void setGuardsStage(GuardsStage guardsStage) {
 856         assert guardsStage.ordinal() &gt;= this.guardsStage.ordinal();
 857         this.guardsStage = guardsStage;
 858     }
 859 
 860     public boolean isAfterFloatingReadPhase() {
 861         return isAfterFloatingReadPhase;
 862     }
 863 
 864     public boolean isAfterFixedReadPhase() {
 865         return isAfterFixedReadPhase;
 866     }
 867 
 868     public void setAfterFloatingReadPhase(boolean state) {
 869         assert state : &quot;cannot &#39;unapply&#39; floating read phase on graph&quot;;
 870         isAfterFloatingReadPhase = state;
 871     }
 872 
 873     public void setAfterFixReadPhase(boolean state) {
 874         assert state : &quot;cannot &#39;unapply&#39; fix reads phase on graph&quot;;
 875         isAfterFixedReadPhase = state;
 876     }
 877 
 878     public boolean hasValueProxies() {
 879         return hasValueProxies;
 880     }
 881 
 882     public void setHasValueProxies(boolean state) {
 883         assert !state : &quot;cannot &#39;unapply&#39; value proxy removal on graph&quot;;
 884         hasValueProxies = state;
 885     }
 886 
 887     public boolean isAfterExpandLogic() {
 888         return isAfterExpandLogic;
 889     }
 890 
 891     public void setAfterExpandLogic() {
 892         isAfterExpandLogic = true;
 893     }
 894 
 895     /**
 896      * Determines if {@link ProfilingInfo} is used during construction of this graph.
 897      */
 898     public boolean useProfilingInfo() {
 899         return useProfilingInfo;
 900     }
 901 
 902     /**
 903      * Returns true if this graph is built without parsing the {@linkplain #method() root method} or
 904      * if the root method is annotated by {@link Snippet} or {@link MethodSubstitution}. This is
 905      * preferred over querying annotations directly as querying annotations can cause class loading.
 906      */
 907     public boolean isSubstitution() {
 908         return isSubstitution;
 909     }
 910 
 911     /**
 912      * Gets the profiling info for the {@linkplain #method() root method} of this graph.
 913      */
 914     public ProfilingInfo getProfilingInfo() {
 915         return getProfilingInfo(method());
 916     }
 917 
 918     /**
 919      * Gets the profiling info for a given method that is or will be part of this graph, taking into
 920      * account {@link #useProfilingInfo()}.
 921      */
 922     public ProfilingInfo getProfilingInfo(ResolvedJavaMethod m) {
 923         if (useProfilingInfo &amp;&amp; m != null) {
 924             return m.getProfilingInfo();
 925         } else {
 926             return DefaultProfilingInfo.get(TriState.UNKNOWN);
 927         }
 928     }
 929 
 930     /**
 931      * Gets the object for recording assumptions while constructing of this graph.
 932      *
 933      * @return {@code null} if assumptions cannot be made for this graph
 934      */
 935     public Assumptions getAssumptions() {
 936         return assumptions;
 937     }
 938 
 939     /**
 940      * Checks that any method referenced from a {@link FrameState} is also in the set of methods
 941      * parsed while building this graph.
 942      */
 943     private boolean checkFrameStatesAgainstInlinedMethods() {
 944         for (FrameState fs : getNodes(FrameState.TYPE)) {
 945             if (!BytecodeFrame.isPlaceholderBci(fs.bci)) {
 946                 ResolvedJavaMethod m = fs.code.getMethod();
 947                 if (!m.equals(rootMethod) &amp;&amp; !methods.contains(m)) {
 948                     SortedSet&lt;String&gt; haystack = new TreeSet&lt;&gt;();
 949                     if (!methods.contains(rootMethod)) {
 950                         haystack.add(rootMethod.format(&quot;%H.%n(%p)&quot;));
 951                     }
 952                     for (ResolvedJavaMethod e : methods) {
 953                         haystack.add(e.format(&quot;%H.%n(%p)&quot;));
 954                     }
 955                     throw new AssertionError(String.format(&quot;Could not find %s from %s in set(%s)&quot;, m.format(&quot;%H.%n(%p)&quot;), fs, haystack.stream().collect(Collectors.joining(System.lineSeparator()))));
 956                 }
 957             }
 958         }
 959         return true;
 960     }
 961 
 962     private static EconomicSet&lt;ResolvedJavaField&gt; createFieldSet(EconomicSet&lt;ResolvedJavaField&gt; init) {
 963         // Multiple ResolvedJavaField objects can represent the same field so they
 964         // need to be compared with equals().
 965         if (init != null) {
 966             return EconomicSet.create(Equivalence.DEFAULT, init);
 967         }
 968         return EconomicSet.create(Equivalence.DEFAULT);
 969     }
 970 
 971     /**
 972      * Gets an unmodifiable view of the methods that were inlined while constructing this graph.
 973      */
 974     public List&lt;ResolvedJavaMethod&gt; getMethods() {
 975         if (methods != null) {
 976             assert isSubstitution || checkFrameStatesAgainstInlinedMethods();
 977             return Collections.unmodifiableList(methods);
 978         }
 979         return Collections.emptyList();
 980     }
 981 
 982     /**
 983      * Records that {@code method} was used to build this graph.
 984      */
 985     public void recordMethod(ResolvedJavaMethod method) {
 986         if (methods != null) {
 987             methods.add(method);
 988         }
 989     }
 990 
 991     /**
 992      * Updates the {@linkplain #getMethods() methods} used to build this graph with the methods used
 993      * to build another graph.
 994      */
 995     public void updateMethods(StructuredGraph other) {
 996         if (methods != null) {
 997             if (other.rootMethod != null) {
 998                 methods.add(other.rootMethod);
 999             }
1000             for (ResolvedJavaMethod m : other.methods) {
1001                 methods.add(m);
1002             }
1003         }
1004     }
1005 
1006     /**
1007      * Gets an unmodifiable view of the fields that were accessed while constructing this graph.
1008      *
1009      * @return {@code null} if no field accesses were recorded
1010      */
1011     public EconomicSet&lt;ResolvedJavaField&gt; getFields() {
1012         return fields;
1013     }
1014 
1015     /**
1016      * Records that {@code field} was accessed in this graph.
1017      */
1018     public void recordField(ResolvedJavaField field) {
1019         assert GraalOptions.GeneratePIC.getValue(getOptions());
1020         if (this.fields == null) {
1021             this.fields = createFieldSet(null);
1022         }
1023         fields.add(field);
1024     }
1025 
1026     /**
1027      * Updates the {@linkplain #getFields() fields} of this graph with the accessed fields of
1028      * another graph.
1029      */
1030     public void updateFields(StructuredGraph other) {
1031         assert this != other;
1032         assert GraalOptions.GeneratePIC.getValue(getOptions());
1033         if (other.fields != null) {
1034             if (this.fields == null) {
1035                 this.fields = createFieldSet(null);
1036             }
1037             this.fields.addAll(other.fields);
1038         }
1039     }
1040 
1041     /**
1042      * Gets the input bytecode {@linkplain ResolvedJavaMethod#getCodeSize() size} from which this
1043      * graph is constructed. This ignores how many bytecodes in each constituent method are actually
1044      * parsed (which may be none for methods whose IR is retrieved from a cache or less than the
1045      * full amount for any given method due to profile guided branch pruning).
1046      */
1047     public int getBytecodeSize() {
1048         int res = 0;
1049         if (rootMethod != null) {
1050             res += rootMethod.getCodeSize();
1051         }
1052         if (methods != null) {
1053             for (ResolvedJavaMethod e : methods) {
1054                 res += e.getCodeSize();
1055             }
1056         }
1057         return res;
1058     }
1059 
1060     @Override
1061     public JavaMethod asJavaMethod() {
1062         return method();
1063     }
1064 
1065     public boolean hasUnsafeAccess() {
1066         return hasUnsafeAccess == UnsafeAccessState.HAS_ACCESS;
1067     }
1068 
1069     public void markUnsafeAccess() {
1070         if (hasUnsafeAccess == UnsafeAccessState.DISABLED) {
1071             return;
1072         }
1073         hasUnsafeAccess = UnsafeAccessState.HAS_ACCESS;
1074     }
1075 
1076     public void disableUnsafeAccessTracking() {
1077         hasUnsafeAccess = UnsafeAccessState.DISABLED;
1078     }
1079 
1080     public boolean isUnsafeAccessTrackingEnabled() {
1081         return hasUnsafeAccess != UnsafeAccessState.DISABLED;
1082     }
1083 
1084     public SpeculationLog getSpeculationLog() {
1085         return speculationLog;
1086     }
1087 
1088     public void clearAllStateAfter() {
1089         for (Node node : getNodes()) {
1090             if (node instanceof StateSplit) {
1091                 FrameState stateAfter = ((StateSplit) node).stateAfter();
1092                 if (stateAfter != null) {
1093                     ((StateSplit) node).setStateAfter(null);
1094                     // 2 nodes referencing the same framestate
1095                     if (stateAfter.isAlive()) {
1096                         GraphUtil.killWithUnusedFloatingInputs(stateAfter);
1097                     }
1098                 }
1099             }
1100         }
1101     }
1102 
1103     public boolean hasVirtualizableAllocation() {
1104         for (Node n : getNodes()) {
1105             if (n instanceof VirtualizableAllocation) {
1106                 return true;
1107             }
1108         }
1109         return false;
1110     }
1111 
1112     @Override
1113     protected void afterRegister(Node node) {
1114         assert hasValueProxies() || !(node instanceof ValueProxyNode);
1115         if (GraalOptions.TraceInlining.getValue(getOptions())) {
1116             if (node instanceof Invokable) {
1117                 ((Invokable) node).updateInliningLogAfterRegister(this);
1118             }
1119         }
1120     }
1121 
1122     public NodeSourcePosition getCallerContext() {
1123         return callerContext;
1124     }
1125 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
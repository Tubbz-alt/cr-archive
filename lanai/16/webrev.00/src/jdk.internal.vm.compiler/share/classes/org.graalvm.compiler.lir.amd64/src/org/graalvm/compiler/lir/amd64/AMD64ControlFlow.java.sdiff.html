<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ControlFlow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64Call.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64FrameMap.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ControlFlow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.lir.amd64;
  26 
  27 import static jdk.vm.ci.code.ValueUtil.asRegister;
  28 import static jdk.vm.ci.code.ValueUtil.isRegister;





  29 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;
  30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
  31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
  32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
  33 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
  34 



  35 import org.graalvm.compiler.asm.Label;
  36 import org.graalvm.compiler.asm.amd64.AMD64Address;
  37 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
  38 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;

  39 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  40 import org.graalvm.compiler.code.CompilationResult.JumpTable;
  41 import org.graalvm.compiler.core.common.NumUtil;
  42 import org.graalvm.compiler.core.common.calc.Condition;
  43 import org.graalvm.compiler.debug.GraalError;

  44 import org.graalvm.compiler.lir.LIRInstructionClass;
  45 import org.graalvm.compiler.lir.LabelRef;
  46 import org.graalvm.compiler.lir.Opcode;
  47 import org.graalvm.compiler.lir.StandardOp;
  48 import org.graalvm.compiler.lir.StandardOp.BlockEndOp;

  49 import org.graalvm.compiler.lir.SwitchStrategy;
  50 import org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure;
  51 import org.graalvm.compiler.lir.Variable;
  52 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  53 
  54 import jdk.vm.ci.amd64.AMD64;
  55 import jdk.vm.ci.amd64.AMD64.CPUFeature;
  56 import jdk.vm.ci.amd64.AMD64Kind;
  57 import jdk.vm.ci.code.Register;
  58 import jdk.vm.ci.meta.AllocatableValue;
  59 import jdk.vm.ci.meta.Constant;
  60 import jdk.vm.ci.meta.JavaConstant;

  61 import jdk.vm.ci.meta.Value;
  62 
  63 public class AMD64ControlFlow {
  64 
  65     public static final class ReturnOp extends AMD64BlockEndOp implements BlockEndOp {
  66         public static final LIRInstructionClass&lt;ReturnOp&gt; TYPE = LIRInstructionClass.create(ReturnOp.class);
  67         @Use({REG, ILLEGAL}) protected Value x;
  68 
  69         public ReturnOp(Value x) {
  70             super(TYPE);
  71             this.x = x;
  72         }
  73 
  74         @Override
  75         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
  76             crb.frameContext.leave(crb);
  77             /*
  78              * We potentially return to the interpreter, and that&#39;s an AVX-SSE transition. The only
  79              * live value at this point should be the return value in either rax, or in xmm0 with
  80              * the upper half of the register unused, so we don&#39;t destroy any value here.
  81              */
  82             if (masm.supports(CPUFeature.AVX)) {
  83                 masm.vzeroupper();
  84             }
  85             masm.ret(0);
  86         }
  87     }
  88 
  89     public static class BranchOp extends AMD64BlockEndOp implements StandardOp.BranchOp {
  90         public static final LIRInstructionClass&lt;BranchOp&gt; TYPE = LIRInstructionClass.create(BranchOp.class);
  91         protected final ConditionFlag condition;
  92         protected final LabelRef trueDestination;
  93         protected final LabelRef falseDestination;
  94 
<span class="line-modified">  95         private final double trueDestinationProbability;</span>
  96 
  97         public BranchOp(Condition condition, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
  98             this(intCond(condition), trueDestination, falseDestination, trueDestinationProbability);
  99         }
 100 
 101         public BranchOp(ConditionFlag condition, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
 102             this(TYPE, condition, trueDestination, falseDestination, trueDestinationProbability);
 103         }
 104 
 105         protected BranchOp(LIRInstructionClass&lt;? extends BranchOp&gt; c, ConditionFlag condition, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
 106             super(c);
 107             this.condition = condition;
 108             this.trueDestination = trueDestination;
 109             this.falseDestination = falseDestination;
 110             this.trueDestinationProbability = trueDestinationProbability;
 111         }
 112 
 113         @Override
 114         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
<span class="line-removed"> 115             boolean isNegated = false;</span>
<span class="line-removed"> 116             int jccPos = masm.position();</span>
 117             /*
 118              * The strategy for emitting jumps is: If either trueDestination or falseDestination is
 119              * the successor block, assume the block scheduler did the correct thing and jcc to the
 120              * other. Otherwise, we need a jcc followed by a jmp. Use the branch probability to make
 121              * sure it is more likely to branch on the jcc (= less likely to execute both the jcc
 122              * and the jmp instead of just the jcc). In the case of loops, that means the jcc is the
 123              * back-edge.
 124              */
 125             if (crb.isSuccessorEdge(trueDestination)) {
 126                 jcc(masm, true, falseDestination);
<span class="line-removed"> 127                 isNegated = true;</span>
 128             } else if (crb.isSuccessorEdge(falseDestination)) {
 129                 jcc(masm, false, trueDestination);
 130             } else if (trueDestinationProbability &lt; 0.5) {
 131                 jcc(masm, true, falseDestination);
 132                 masm.jmp(trueDestination.label());
<span class="line-removed"> 133                 isNegated = true;</span>
 134             } else {
 135                 jcc(masm, false, trueDestination);
 136                 masm.jmp(falseDestination.label());
 137             }
<span class="line-removed"> 138             crb.recordBranch(jccPos, isNegated);</span>
 139         }
 140 
 141         protected void jcc(AMD64MacroAssembler masm, boolean negate, LabelRef target) {
 142             masm.jcc(negate ? condition.negate() : condition, target.label());
 143         }
 144     }
 145 


















































































































































































































































































































































































































 146     public static final class FloatBranchOp extends BranchOp {
 147         public static final LIRInstructionClass&lt;FloatBranchOp&gt; TYPE = LIRInstructionClass.create(FloatBranchOp.class);
 148         protected boolean unorderedIsTrue;
 149 
 150         public FloatBranchOp(Condition condition, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
 151             super(TYPE, floatCond(condition), trueDestination, falseDestination, trueDestinationProbability);
 152             this.unorderedIsTrue = unorderedIsTrue;
 153         }
 154 
 155         @Override
 156         protected void jcc(AMD64MacroAssembler masm, boolean negate, LabelRef target) {
<span class="line-modified"> 157             floatJcc(masm, negate ? condition.negate() : condition, negate ? !unorderedIsTrue : unorderedIsTrue, target.label());</span>










 158         }
 159     }
 160 
 161     public static class StrategySwitchOp extends AMD64BlockEndOp {
 162         public static final LIRInstructionClass&lt;StrategySwitchOp&gt; TYPE = LIRInstructionClass.create(StrategySwitchOp.class);
 163         protected final Constant[] keyConstants;
 164         private final LabelRef[] keyTargets;
 165         private LabelRef defaultTarget;
 166         @Alive({REG}) protected Value key;
 167         @Temp({REG, ILLEGAL}) protected Value scratch;
 168         protected final SwitchStrategy strategy;
 169 
 170         public StrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Value key, Value scratch) {
 171             this(TYPE, strategy, keyTargets, defaultTarget, key, scratch);
 172         }
 173 
 174         protected StrategySwitchOp(LIRInstructionClass&lt;? extends StrategySwitchOp&gt; c, SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Value key, Value scratch) {
 175             super(c);
 176             this.strategy = strategy;
 177             this.keyConstants = strategy.getKeyConstants();
</pre>
<hr />
<pre>
 336         @Override
 337         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 338             Register valueReg = asRegister(value, AMD64Kind.DWORD);
 339             Register indexReg = asRegister(hash, AMD64Kind.DWORD);
 340             Register scratchReg = asRegister(scratch, AMD64Kind.QWORD);
 341             Register entryScratchReg = asRegister(entryScratch, AMD64Kind.QWORD);
 342 
 343             // Set scratch to address of jump table
 344             masm.leaq(scratchReg, new AMD64Address(AMD64.rip, 0));
 345             final int afterLea = masm.position();
 346 
 347             // When the default target is set, the jump table contains entries with two DWORDS:
 348             // the original key before hashing and the label jump address
 349             if (defaultTarget != null) {
 350 
 351                 // Move the table entry (two DWORDs) into a QWORD
 352                 masm.movq(entryScratchReg, new AMD64Address(scratchReg, indexReg, Scale.Times8, 0));
 353 
 354                 // Jump to the default target if the first DWORD (original key) doesn&#39;t match the
 355                 // current key. Accounts for hash collisions with unknown keys
<span class="line-modified"> 356                 masm.cmpl(entryScratchReg, valueReg);</span>
<span class="line-removed"> 357                 masm.jcc(ConditionFlag.NotEqual, defaultTarget.label());</span>
 358 
 359                 // Shift to the second DWORD
 360                 masm.sarq(entryScratchReg, 32);
 361             } else {
 362 
 363                 // The jump table has a single DWORD with the label address if there&#39;s no
 364                 // default target
 365                 masm.movslq(entryScratchReg, new AMD64Address(scratchReg, indexReg, Scale.Times4, 0));
 366             }
 367             masm.addq(scratchReg, entryScratchReg);
 368             masm.jmp(scratchReg);
 369 
 370             // Inserting padding so that jump the table address is aligned
 371             if (defaultTarget != null) {
 372                 masm.align(8);
 373             } else {
 374                 masm.align(4);
 375             }
 376 
 377             // Patch LEA instruction above now that we know the position of the jump table
</pre>
<hr />
<pre>
 470         @Alive({REG}) protected Value trueValue;
 471         @Alive({REG}) protected Value falseValue;
 472         private final ConditionFlag condition;
 473         private final boolean unorderedIsTrue;
 474 
 475         public FloatCondMoveOp(Variable result, Condition condition, boolean unorderedIsTrue, Variable trueValue, Variable falseValue) {
 476             super(TYPE);
 477             this.result = result;
 478             this.condition = floatCond(condition);
 479             this.unorderedIsTrue = unorderedIsTrue;
 480             this.trueValue = trueValue;
 481             this.falseValue = falseValue;
 482         }
 483 
 484         @Override
 485         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 486             cmove(crb, masm, result, true, condition, unorderedIsTrue, trueValue, falseValue);
 487         }
 488     }
 489 
<span class="line-removed"> 490     private static void floatJcc(AMD64MacroAssembler masm, ConditionFlag condition, boolean unorderedIsTrue, Label label) {</span>
<span class="line-removed"> 491         Label endLabel = new Label();</span>
<span class="line-removed"> 492         if (unorderedIsTrue &amp;&amp; !trueOnUnordered(condition)) {</span>
<span class="line-removed"> 493             masm.jcc(ConditionFlag.Parity, label);</span>
<span class="line-removed"> 494         } else if (!unorderedIsTrue &amp;&amp; trueOnUnordered(condition)) {</span>
<span class="line-removed"> 495             masm.jccb(ConditionFlag.Parity, endLabel);</span>
<span class="line-removed"> 496         }</span>
<span class="line-removed"> 497         masm.jcc(condition, label);</span>
<span class="line-removed"> 498         masm.bind(endLabel);</span>
<span class="line-removed"> 499     }</span>
<span class="line-removed"> 500 </span>
 501     private static void cmove(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, boolean isFloat, ConditionFlag condition, boolean unorderedIsTrue, Value trueValue,
 502                     Value falseValue) {
 503         // check that we don&#39;t overwrite an input operand before it is used.
 504         assert !result.equals(trueValue);
 505 
 506         AMD64Move.move(crb, masm, result, falseValue);
 507         cmove(crb, masm, result, condition, trueValue);
 508 
 509         if (isFloat) {
 510             if (unorderedIsTrue &amp;&amp; !trueOnUnordered(condition)) {
 511                 cmove(crb, masm, result, ConditionFlag.Parity, trueValue);
 512             } else if (!unorderedIsTrue &amp;&amp; trueOnUnordered(condition)) {
 513                 cmove(crb, masm, result, ConditionFlag.Parity, falseValue);
 514             }
 515         }
 516     }
 517 
 518     private static void cmove(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, ConditionFlag cond, Value other) {
 519         if (isRegister(other)) {
 520             assert !asRegister(other).equals(asRegister(result)) : &quot;other already overwritten by previous move&quot;;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.lir.amd64;
  26 
  27 import static jdk.vm.ci.code.ValueUtil.asRegister;
  28 import static jdk.vm.ci.code.ValueUtil.isRegister;
<span class="line-added">  29 import static jdk.vm.ci.code.ValueUtil.isStackSlot;</span>
<span class="line-added">  30 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;</span>
<span class="line-added">  31 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;</span>
<span class="line-added">  32 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.WORD;</span>
<span class="line-added">  33 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;</span>
  34 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;
  35 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
  36 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
  37 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
  38 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
  39 
<span class="line-added">  40 import java.util.function.IntConsumer;</span>
<span class="line-added">  41 import java.util.function.Supplier;</span>
<span class="line-added">  42 </span>
  43 import org.graalvm.compiler.asm.Label;
  44 import org.graalvm.compiler.asm.amd64.AMD64Address;
  45 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
  46 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
<span class="line-added">  47 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;</span>
  48 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  49 import org.graalvm.compiler.code.CompilationResult.JumpTable;
  50 import org.graalvm.compiler.core.common.NumUtil;
  51 import org.graalvm.compiler.core.common.calc.Condition;
  52 import org.graalvm.compiler.debug.GraalError;
<span class="line-added">  53 import org.graalvm.compiler.lir.LIRFrameState;</span>
  54 import org.graalvm.compiler.lir.LIRInstructionClass;
  55 import org.graalvm.compiler.lir.LabelRef;
  56 import org.graalvm.compiler.lir.Opcode;
  57 import org.graalvm.compiler.lir.StandardOp;
  58 import org.graalvm.compiler.lir.StandardOp.BlockEndOp;
<span class="line-added">  59 import org.graalvm.compiler.lir.StandardOp.ImplicitNullCheck;</span>
  60 import org.graalvm.compiler.lir.SwitchStrategy;
  61 import org.graalvm.compiler.lir.SwitchStrategy.BaseSwitchClosure;
  62 import org.graalvm.compiler.lir.Variable;
  63 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  64 
  65 import jdk.vm.ci.amd64.AMD64;
  66 import jdk.vm.ci.amd64.AMD64.CPUFeature;
  67 import jdk.vm.ci.amd64.AMD64Kind;
  68 import jdk.vm.ci.code.Register;
  69 import jdk.vm.ci.meta.AllocatableValue;
  70 import jdk.vm.ci.meta.Constant;
  71 import jdk.vm.ci.meta.JavaConstant;
<span class="line-added">  72 import jdk.vm.ci.meta.VMConstant;</span>
  73 import jdk.vm.ci.meta.Value;
  74 
  75 public class AMD64ControlFlow {
  76 
  77     public static final class ReturnOp extends AMD64BlockEndOp implements BlockEndOp {
  78         public static final LIRInstructionClass&lt;ReturnOp&gt; TYPE = LIRInstructionClass.create(ReturnOp.class);
  79         @Use({REG, ILLEGAL}) protected Value x;
  80 
  81         public ReturnOp(Value x) {
  82             super(TYPE);
  83             this.x = x;
  84         }
  85 
  86         @Override
  87         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
  88             crb.frameContext.leave(crb);
  89             /*
  90              * We potentially return to the interpreter, and that&#39;s an AVX-SSE transition. The only
  91              * live value at this point should be the return value in either rax, or in xmm0 with
  92              * the upper half of the register unused, so we don&#39;t destroy any value here.
  93              */
  94             if (masm.supports(CPUFeature.AVX)) {
  95                 masm.vzeroupper();
  96             }
  97             masm.ret(0);
  98         }
  99     }
 100 
 101     public static class BranchOp extends AMD64BlockEndOp implements StandardOp.BranchOp {
 102         public static final LIRInstructionClass&lt;BranchOp&gt; TYPE = LIRInstructionClass.create(BranchOp.class);
 103         protected final ConditionFlag condition;
 104         protected final LabelRef trueDestination;
 105         protected final LabelRef falseDestination;
 106 
<span class="line-modified"> 107         protected final double trueDestinationProbability;</span>
 108 
 109         public BranchOp(Condition condition, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
 110             this(intCond(condition), trueDestination, falseDestination, trueDestinationProbability);
 111         }
 112 
 113         public BranchOp(ConditionFlag condition, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
 114             this(TYPE, condition, trueDestination, falseDestination, trueDestinationProbability);
 115         }
 116 
 117         protected BranchOp(LIRInstructionClass&lt;? extends BranchOp&gt; c, ConditionFlag condition, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
 118             super(c);
 119             this.condition = condition;
 120             this.trueDestination = trueDestination;
 121             this.falseDestination = falseDestination;
 122             this.trueDestinationProbability = trueDestinationProbability;
 123         }
 124 
 125         @Override
 126         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {


 127             /*
 128              * The strategy for emitting jumps is: If either trueDestination or falseDestination is
 129              * the successor block, assume the block scheduler did the correct thing and jcc to the
 130              * other. Otherwise, we need a jcc followed by a jmp. Use the branch probability to make
 131              * sure it is more likely to branch on the jcc (= less likely to execute both the jcc
 132              * and the jmp instead of just the jcc). In the case of loops, that means the jcc is the
 133              * back-edge.
 134              */
 135             if (crb.isSuccessorEdge(trueDestination)) {
 136                 jcc(masm, true, falseDestination);

 137             } else if (crb.isSuccessorEdge(falseDestination)) {
 138                 jcc(masm, false, trueDestination);
 139             } else if (trueDestinationProbability &lt; 0.5) {
 140                 jcc(masm, true, falseDestination);
 141                 masm.jmp(trueDestination.label());

 142             } else {
 143                 jcc(masm, false, trueDestination);
 144                 masm.jmp(falseDestination.label());
 145             }

 146         }
 147 
 148         protected void jcc(AMD64MacroAssembler masm, boolean negate, LabelRef target) {
 149             masm.jcc(negate ? condition.negate() : condition, target.label());
 150         }
 151     }
 152 
<span class="line-added"> 153     public static class TestByteBranchOp extends BranchOp {</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155         public static final LIRInstructionClass&lt;TestByteBranchOp&gt; TYPE = LIRInstructionClass.create(TestByteBranchOp.class);</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157         @Use({REG}) protected AllocatableValue x;</span>
<span class="line-added"> 158         @Use({REG, STACK}) protected AllocatableValue y;</span>
<span class="line-added"> 159 </span>
<span class="line-added"> 160         public TestByteBranchOp(AllocatableValue x, AllocatableValue y, Condition cond, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {</span>
<span class="line-added"> 161             super(TYPE, intCond(cond), trueDestination, falseDestination, trueDestinationProbability);</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163             this.x = x;</span>
<span class="line-added"> 164             this.y = y;</span>
<span class="line-added"> 165         }</span>
<span class="line-added"> 166 </span>
<span class="line-added"> 167         @Override</span>
<span class="line-added"> 168         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-added"> 169             if (isRegister(y)) {</span>
<span class="line-added"> 170                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 171                     masm.testbAndJcc(asRegister(x), asRegister(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 172                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 173                     masm.testbAndJcc(asRegister(x), asRegister(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 174                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 175                     masm.testbAndJcc(asRegister(x), asRegister(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 176                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 177                 } else {</span>
<span class="line-added"> 178                     masm.testbAndJcc(asRegister(x), asRegister(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 179                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 180                 }</span>
<span class="line-added"> 181             } else {</span>
<span class="line-added"> 182                 assert isStackSlot(y);</span>
<span class="line-added"> 183                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 184                     masm.testbAndJcc(asRegister(x), (AMD64Address) crb.asAddress(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 185                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 186                     masm.testbAndJcc(asRegister(x), (AMD64Address) crb.asAddress(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 187                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 188                     masm.testbAndJcc(asRegister(x), (AMD64Address) crb.asAddress(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 189                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 190                 } else {</span>
<span class="line-added"> 191                     masm.testbAndJcc(asRegister(x), (AMD64Address) crb.asAddress(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 192                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 193                 }</span>
<span class="line-added"> 194             }</span>
<span class="line-added"> 195         }</span>
<span class="line-added"> 196     }</span>
<span class="line-added"> 197 </span>
<span class="line-added"> 198     public static class TestBranchOp extends BranchOp implements ImplicitNullCheck {</span>
<span class="line-added"> 199 </span>
<span class="line-added"> 200         public static final LIRInstructionClass&lt;TestBranchOp&gt; TYPE = LIRInstructionClass.create(TestBranchOp.class);</span>
<span class="line-added"> 201 </span>
<span class="line-added"> 202         private final OperandSize size;</span>
<span class="line-added"> 203 </span>
<span class="line-added"> 204         @Use({REG}) protected AllocatableValue x;</span>
<span class="line-added"> 205         @Use({REG, STACK, COMPOSITE}) protected Value y;</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207         @State protected LIRFrameState state;</span>
<span class="line-added"> 208 </span>
<span class="line-added"> 209         public TestBranchOp(OperandSize size, AllocatableValue x, Value y, LIRFrameState state, Condition cond, LabelRef trueDestination, LabelRef falseDestination,</span>
<span class="line-added"> 210                         double trueDestinationProbability) {</span>
<span class="line-added"> 211             super(TYPE, intCond(cond), trueDestination, falseDestination, trueDestinationProbability);</span>
<span class="line-added"> 212             assert size == WORD || size == DWORD || size == QWORD;</span>
<span class="line-added"> 213             this.size = size;</span>
<span class="line-added"> 214 </span>
<span class="line-added"> 215             this.x = x;</span>
<span class="line-added"> 216             this.y = y;</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218             this.state = state;</span>
<span class="line-added"> 219         }</span>
<span class="line-added"> 220 </span>
<span class="line-added"> 221         @Override</span>
<span class="line-added"> 222         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-added"> 223             if (isRegister(y)) {</span>
<span class="line-added"> 224                 assert state == null;</span>
<span class="line-added"> 225                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 226                     masm.testAndJcc(size, asRegister(x), asRegister(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 227                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 228                     masm.testAndJcc(size, asRegister(x), asRegister(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 229                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 230                     masm.testAndJcc(size, asRegister(x), asRegister(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 231                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 232                 } else {</span>
<span class="line-added"> 233                     masm.testAndJcc(size, asRegister(x), asRegister(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 234                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 235                 }</span>
<span class="line-added"> 236                 return;</span>
<span class="line-added"> 237             }</span>
<span class="line-added"> 238             IntConsumer applyBeforeFusedPair = state == null ? null : pos -&gt; crb.recordImplicitException(pos, state);</span>
<span class="line-added"> 239             if (isStackSlot(y)) {</span>
<span class="line-added"> 240                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 241                     masm.testAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 242                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 243                     masm.testAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 244                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 245                     masm.testAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 246                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 247                 } else {</span>
<span class="line-added"> 248                     masm.testAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 249                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 250                 }</span>
<span class="line-added"> 251             } else {</span>
<span class="line-added"> 252                 AMD64AddressValue yAddress = (AMD64AddressValue) y;</span>
<span class="line-added"> 253                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 254                     masm.testAndJcc(size, asRegister(x), yAddress.toAddress(), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 255                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 256                     masm.testAndJcc(size, asRegister(x), yAddress.toAddress(), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 257                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 258                     masm.testAndJcc(size, asRegister(x), yAddress.toAddress(), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 259                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 260                 } else {</span>
<span class="line-added"> 261                     masm.testAndJcc(size, asRegister(x), yAddress.toAddress(), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 262                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 263                 }</span>
<span class="line-added"> 264             }</span>
<span class="line-added"> 265         }</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267         @Override</span>
<span class="line-added"> 268         public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {</span>
<span class="line-added"> 269             if (state == null &amp;&amp; y instanceof AMD64AddressValue &amp;&amp; ((AMD64AddressValue) y).isValidImplicitNullCheckFor(value, implicitNullCheckLimit)) {</span>
<span class="line-added"> 270                 state = nullCheckState;</span>
<span class="line-added"> 271                 return true;</span>
<span class="line-added"> 272             }</span>
<span class="line-added"> 273             return false;</span>
<span class="line-added"> 274         }</span>
<span class="line-added"> 275     }</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277     public static class TestConstBranchOp extends BranchOp implements ImplicitNullCheck {</span>
<span class="line-added"> 278 </span>
<span class="line-added"> 279         public static final LIRInstructionClass&lt;TestConstBranchOp&gt; TYPE = LIRInstructionClass.create(TestConstBranchOp.class);</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281         private final OperandSize size;</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283         @Use({REG, STACK, COMPOSITE}) protected Value x;</span>
<span class="line-added"> 284         private final int y;</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286         @State protected LIRFrameState state;</span>
<span class="line-added"> 287 </span>
<span class="line-added"> 288         public TestConstBranchOp(OperandSize size, Value x, int y, LIRFrameState state, Condition cond, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {</span>
<span class="line-added"> 289             super(TYPE, intCond(cond), trueDestination, falseDestination, trueDestinationProbability);</span>
<span class="line-added"> 290             assert size == DWORD || size == QWORD;</span>
<span class="line-added"> 291             this.size = size;</span>
<span class="line-added"> 292 </span>
<span class="line-added"> 293             this.x = x;</span>
<span class="line-added"> 294             this.y = y;</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296             this.state = state;</span>
<span class="line-added"> 297         }</span>
<span class="line-added"> 298 </span>
<span class="line-added"> 299         @Override</span>
<span class="line-added"> 300         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-added"> 301             if (isRegister(x)) {</span>
<span class="line-added"> 302                 assert state == null;</span>
<span class="line-added"> 303                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 304                     masm.testAndJcc(size, asRegister(x), y, condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 305                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 306                     masm.testAndJcc(size, asRegister(x), y, condition, trueDestination.label(), false);</span>
<span class="line-added"> 307                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 308                     masm.testAndJcc(size, asRegister(x), y, condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 309                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 310                 } else {</span>
<span class="line-added"> 311                     masm.testAndJcc(size, asRegister(x), y, condition, trueDestination.label(), false);</span>
<span class="line-added"> 312                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 313                 }</span>
<span class="line-added"> 314                 return;</span>
<span class="line-added"> 315             }</span>
<span class="line-added"> 316             IntConsumer applyBeforeFusedPair = state == null ? null : pos -&gt; crb.recordImplicitException(pos, state);</span>
<span class="line-added"> 317             if (isStackSlot(x)) {</span>
<span class="line-added"> 318                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 319                     masm.testAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 320                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 321                     masm.testAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 322                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 323                     masm.testAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 324                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 325                 } else {</span>
<span class="line-added"> 326                     masm.testAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 327                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 328                 }</span>
<span class="line-added"> 329             } else {</span>
<span class="line-added"> 330                 AMD64AddressValue xAddress = (AMD64AddressValue) x;</span>
<span class="line-added"> 331                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 332                     masm.testAndJcc(size, xAddress.toAddress(), y, condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 333                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 334                     masm.testAndJcc(size, xAddress.toAddress(), y, condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 335                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 336                     masm.testAndJcc(size, xAddress.toAddress(), y, condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 337                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 338                 } else {</span>
<span class="line-added"> 339                     masm.testAndJcc(size, xAddress.toAddress(), y, condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 340                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 341                 }</span>
<span class="line-added"> 342             }</span>
<span class="line-added"> 343         }</span>
<span class="line-added"> 344 </span>
<span class="line-added"> 345         @Override</span>
<span class="line-added"> 346         public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {</span>
<span class="line-added"> 347             if (state == null &amp;&amp; x instanceof AMD64AddressValue &amp;&amp; ((AMD64AddressValue) x).isValidImplicitNullCheckFor(value, implicitNullCheckLimit)) {</span>
<span class="line-added"> 348                 state = nullCheckState;</span>
<span class="line-added"> 349                 return true;</span>
<span class="line-added"> 350             }</span>
<span class="line-added"> 351             return false;</span>
<span class="line-added"> 352         }</span>
<span class="line-added"> 353     }</span>
<span class="line-added"> 354 </span>
<span class="line-added"> 355     public static class CmpBranchOp extends BranchOp implements ImplicitNullCheck {</span>
<span class="line-added"> 356 </span>
<span class="line-added"> 357         public static final LIRInstructionClass&lt;CmpBranchOp&gt; TYPE = LIRInstructionClass.create(CmpBranchOp.class);</span>
<span class="line-added"> 358 </span>
<span class="line-added"> 359         private final OperandSize size;</span>
<span class="line-added"> 360 </span>
<span class="line-added"> 361         @Use({REG}) protected AllocatableValue x;</span>
<span class="line-added"> 362         @Use({REG, STACK, COMPOSITE}) protected Value y;</span>
<span class="line-added"> 363 </span>
<span class="line-added"> 364         @State protected LIRFrameState state;</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366         public CmpBranchOp(OperandSize size, AllocatableValue x, Value y, LIRFrameState state, Condition cond, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {</span>
<span class="line-added"> 367             super(TYPE, intCond(cond), trueDestination, falseDestination, trueDestinationProbability);</span>
<span class="line-added"> 368             this.size = size;</span>
<span class="line-added"> 369 </span>
<span class="line-added"> 370             this.x = x;</span>
<span class="line-added"> 371             this.y = y;</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373             this.state = state;</span>
<span class="line-added"> 374         }</span>
<span class="line-added"> 375 </span>
<span class="line-added"> 376         @Override</span>
<span class="line-added"> 377         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-added"> 378             if (isRegister(y)) {</span>
<span class="line-added"> 379                 assert state == null;</span>
<span class="line-added"> 380                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 381                     masm.cmpAndJcc(size, asRegister(x), asRegister(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 382                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 383                     masm.cmpAndJcc(size, asRegister(x), asRegister(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 384                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 385                     masm.cmpAndJcc(size, asRegister(x), asRegister(y), condition.negate(), falseDestination.label(), false);</span>
<span class="line-added"> 386                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 387                 } else {</span>
<span class="line-added"> 388                     masm.cmpAndJcc(size, asRegister(x), asRegister(y), condition, trueDestination.label(), false);</span>
<span class="line-added"> 389                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 390                 }</span>
<span class="line-added"> 391                 return;</span>
<span class="line-added"> 392             }</span>
<span class="line-added"> 393             IntConsumer applyBeforeFusedPair = state == null ? null : pos -&gt; crb.recordImplicitException(pos, state);</span>
<span class="line-added"> 394             if (isStackSlot(y)) {</span>
<span class="line-added"> 395                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 396                     masm.cmpAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 397                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 398                     masm.cmpAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 399                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 400                     masm.cmpAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 401                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 402                 } else {</span>
<span class="line-added"> 403                     masm.cmpAndJcc(size, asRegister(x), (AMD64Address) crb.asAddress(y), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 404                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 405                 }</span>
<span class="line-added"> 406             } else {</span>
<span class="line-added"> 407                 AMD64AddressValue yAddress = (AMD64AddressValue) y;</span>
<span class="line-added"> 408                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 409                     masm.cmpAndJcc(size, asRegister(x), yAddress.toAddress(), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 410                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 411                     masm.cmpAndJcc(size, asRegister(x), yAddress.toAddress(), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 412                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 413                     masm.cmpAndJcc(size, asRegister(x), yAddress.toAddress(), condition.negate(), falseDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 414                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 415                 } else {</span>
<span class="line-added"> 416                     masm.cmpAndJcc(size, asRegister(x), yAddress.toAddress(), condition, trueDestination.label(), false, applyBeforeFusedPair);</span>
<span class="line-added"> 417                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 418                 }</span>
<span class="line-added"> 419             }</span>
<span class="line-added"> 420         }</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422         @Override</span>
<span class="line-added"> 423         public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {</span>
<span class="line-added"> 424             if (state == null &amp;&amp; y instanceof AMD64AddressValue &amp;&amp; ((AMD64AddressValue) y).isValidImplicitNullCheckFor(value, implicitNullCheckLimit)) {</span>
<span class="line-added"> 425                 state = nullCheckState;</span>
<span class="line-added"> 426                 return true;</span>
<span class="line-added"> 427             }</span>
<span class="line-added"> 428             return false;</span>
<span class="line-added"> 429         }</span>
<span class="line-added"> 430     }</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432     public static class CmpConstBranchOp extends BranchOp {</span>
<span class="line-added"> 433 </span>
<span class="line-added"> 434         public static final LIRInstructionClass&lt;CmpConstBranchOp&gt; TYPE = LIRInstructionClass.create(CmpConstBranchOp.class);</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436         private final OperandSize size;</span>
<span class="line-added"> 437 </span>
<span class="line-added"> 438         @Use({REG, STACK, COMPOSITE}) protected Value x;</span>
<span class="line-added"> 439         private final int y;</span>
<span class="line-added"> 440         private final VMConstant inlinedY;</span>
<span class="line-added"> 441 </span>
<span class="line-added"> 442         @State protected LIRFrameState state;</span>
<span class="line-added"> 443 </span>
<span class="line-added"> 444         public CmpConstBranchOp(OperandSize size, Value x, int y, LIRFrameState state, Condition cond, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {</span>
<span class="line-added"> 445             super(TYPE, intCond(cond), trueDestination, falseDestination, trueDestinationProbability);</span>
<span class="line-added"> 446             this.size = size;</span>
<span class="line-added"> 447 </span>
<span class="line-added"> 448             this.x = x;</span>
<span class="line-added"> 449             this.y = y;</span>
<span class="line-added"> 450             this.inlinedY = null;</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452             this.state = state;</span>
<span class="line-added"> 453         }</span>
<span class="line-added"> 454 </span>
<span class="line-added"> 455         public CmpConstBranchOp(OperandSize size, Value x, VMConstant y, LIRFrameState state, Condition cond, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {</span>
<span class="line-added"> 456             super(TYPE, intCond(cond), trueDestination, falseDestination, trueDestinationProbability);</span>
<span class="line-added"> 457             this.size = size;</span>
<span class="line-added"> 458 </span>
<span class="line-added"> 459             this.x = x;</span>
<span class="line-added"> 460             this.y = 0xDEADDEAD;</span>
<span class="line-added"> 461             this.inlinedY = y;</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463             this.state = state;</span>
<span class="line-added"> 464         }</span>
<span class="line-added"> 465 </span>
<span class="line-added"> 466         @Override</span>
<span class="line-added"> 467         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-added"> 468             final boolean inlineDataInCode = inlinedY != null;</span>
<span class="line-added"> 469             IntConsumer applyBeforeFusedPair = null;</span>
<span class="line-added"> 470             if (inlineDataInCode) {</span>
<span class="line-added"> 471                 applyBeforeFusedPair = pos -&gt; crb.recordInlineDataInCode(inlinedY);</span>
<span class="line-added"> 472             }</span>
<span class="line-added"> 473             if (isRegister(x)) {</span>
<span class="line-added"> 474                 assert state == null;</span>
<span class="line-added"> 475                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 476                     masm.cmpAndJcc(size, asRegister(x), y, condition.negate(), falseDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 477                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 478                     masm.cmpAndJcc(size, asRegister(x), y, condition, trueDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 479                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 480                     masm.cmpAndJcc(size, asRegister(x), y, condition.negate(), falseDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 481                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 482                 } else {</span>
<span class="line-added"> 483                     masm.cmpAndJcc(size, asRegister(x), y, condition, trueDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 484                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 485                 }</span>
<span class="line-added"> 486                 return;</span>
<span class="line-added"> 487             }</span>
<span class="line-added"> 488             if (state != null) {</span>
<span class="line-added"> 489                 IntConsumer implicitException = pos -&gt; crb.recordImplicitException(pos, state);</span>
<span class="line-added"> 490                 applyBeforeFusedPair = applyBeforeFusedPair == null ? implicitException : applyBeforeFusedPair.andThen(implicitException);</span>
<span class="line-added"> 491             }</span>
<span class="line-added"> 492             if (isStackSlot(x)) {</span>
<span class="line-added"> 493                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 494                     masm.cmpAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition.negate(), falseDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 495                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 496                     masm.cmpAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition, trueDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 497                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 498                     masm.cmpAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition.negate(), falseDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 499                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 500                 } else {</span>
<span class="line-added"> 501                     masm.cmpAndJcc(size, (AMD64Address) crb.asAddress(x), y, condition, trueDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 502                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 503                 }</span>
<span class="line-added"> 504             } else {</span>
<span class="line-added"> 505                 AMD64AddressValue xAddress = (AMD64AddressValue) x;</span>
<span class="line-added"> 506                 if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 507                     masm.cmpAndJcc(size, xAddress.toAddress(), y, condition.negate(), falseDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 508                 } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 509                     masm.cmpAndJcc(size, xAddress.toAddress(), y, condition, trueDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 510                 } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 511                     masm.cmpAndJcc(size, xAddress.toAddress(), y, condition.negate(), falseDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 512                     masm.jmp(trueDestination.label());</span>
<span class="line-added"> 513                 } else {</span>
<span class="line-added"> 514                     masm.cmpAndJcc(size, xAddress.toAddress(), y, condition, trueDestination.label(), false, inlineDataInCode, applyBeforeFusedPair);</span>
<span class="line-added"> 515                     masm.jmp(falseDestination.label());</span>
<span class="line-added"> 516                 }</span>
<span class="line-added"> 517             }</span>
<span class="line-added"> 518         }</span>
<span class="line-added"> 519     }</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521     public static class CmpDataBranchOp extends BranchOp {</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523         public static final LIRInstructionClass&lt;CmpDataBranchOp&gt; TYPE = LIRInstructionClass.create(CmpDataBranchOp.class);</span>
<span class="line-added"> 524 </span>
<span class="line-added"> 525         private final OperandSize size;</span>
<span class="line-added"> 526 </span>
<span class="line-added"> 527         @Use({REG}) protected AllocatableValue x;</span>
<span class="line-added"> 528         private final Constant y;</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530         public CmpDataBranchOp(OperandSize size, AllocatableValue x, Constant y, Condition cond, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {</span>
<span class="line-added"> 531             super(TYPE, intCond(cond), trueDestination, falseDestination, trueDestinationProbability);</span>
<span class="line-added"> 532             this.size = size;</span>
<span class="line-added"> 533 </span>
<span class="line-added"> 534             this.x = x;</span>
<span class="line-added"> 535             this.y = y;</span>
<span class="line-added"> 536         }</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538         @Override</span>
<span class="line-added"> 539         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-added"> 540             Supplier&lt;AMD64Address&gt; applyBeforeConsumer = () -&gt; (AMD64Address) crb.recordDataReferenceInCode(y, size.getBytes());</span>
<span class="line-added"> 541             if (crb.isSuccessorEdge(trueDestination)) {</span>
<span class="line-added"> 542                 masm.cmpAndJcc(size, asRegister(x), applyBeforeConsumer, condition.negate(), falseDestination.label());</span>
<span class="line-added"> 543             } else if (crb.isSuccessorEdge(falseDestination)) {</span>
<span class="line-added"> 544                 masm.cmpAndJcc(size, asRegister(x), applyBeforeConsumer, condition, trueDestination.label());</span>
<span class="line-added"> 545             } else if (trueDestinationProbability &lt; 0.5) {</span>
<span class="line-added"> 546                 masm.cmpAndJcc(size, asRegister(x), applyBeforeConsumer, condition.negate(), falseDestination.label());</span>
<span class="line-added"> 547                 masm.jmp(trueDestination.label());</span>
<span class="line-added"> 548             } else {</span>
<span class="line-added"> 549                 masm.cmpAndJcc(size, asRegister(x), applyBeforeConsumer, condition, trueDestination.label());</span>
<span class="line-added"> 550                 masm.jmp(falseDestination.label());</span>
<span class="line-added"> 551             }</span>
<span class="line-added"> 552         }</span>
<span class="line-added"> 553     }</span>
<span class="line-added"> 554 </span>
 555     public static final class FloatBranchOp extends BranchOp {
 556         public static final LIRInstructionClass&lt;FloatBranchOp&gt; TYPE = LIRInstructionClass.create(FloatBranchOp.class);
 557         protected boolean unorderedIsTrue;
 558 
 559         public FloatBranchOp(Condition condition, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
 560             super(TYPE, floatCond(condition), trueDestination, falseDestination, trueDestinationProbability);
 561             this.unorderedIsTrue = unorderedIsTrue;
 562         }
 563 
 564         @Override
 565         protected void jcc(AMD64MacroAssembler masm, boolean negate, LabelRef target) {
<span class="line-modified"> 566             ConditionFlag condition1 = negate ? condition.negate() : condition;</span>
<span class="line-added"> 567             boolean unorderedIsTrue1 = negate ? !unorderedIsTrue : unorderedIsTrue;</span>
<span class="line-added"> 568             Label label = target.label();</span>
<span class="line-added"> 569             Label endLabel = new Label();</span>
<span class="line-added"> 570             if (unorderedIsTrue1 &amp;&amp; !trueOnUnordered(condition1)) {</span>
<span class="line-added"> 571                 masm.jcc(ConditionFlag.Parity, label);</span>
<span class="line-added"> 572             } else if (!unorderedIsTrue1 &amp;&amp; trueOnUnordered(condition1)) {</span>
<span class="line-added"> 573                 masm.jccb(ConditionFlag.Parity, endLabel);</span>
<span class="line-added"> 574             }</span>
<span class="line-added"> 575             masm.jcc(condition1, label);</span>
<span class="line-added"> 576             masm.bind(endLabel);</span>
 577         }
 578     }
 579 
 580     public static class StrategySwitchOp extends AMD64BlockEndOp {
 581         public static final LIRInstructionClass&lt;StrategySwitchOp&gt; TYPE = LIRInstructionClass.create(StrategySwitchOp.class);
 582         protected final Constant[] keyConstants;
 583         private final LabelRef[] keyTargets;
 584         private LabelRef defaultTarget;
 585         @Alive({REG}) protected Value key;
 586         @Temp({REG, ILLEGAL}) protected Value scratch;
 587         protected final SwitchStrategy strategy;
 588 
 589         public StrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Value key, Value scratch) {
 590             this(TYPE, strategy, keyTargets, defaultTarget, key, scratch);
 591         }
 592 
 593         protected StrategySwitchOp(LIRInstructionClass&lt;? extends StrategySwitchOp&gt; c, SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Value key, Value scratch) {
 594             super(c);
 595             this.strategy = strategy;
 596             this.keyConstants = strategy.getKeyConstants();
</pre>
<hr />
<pre>
 755         @Override
 756         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 757             Register valueReg = asRegister(value, AMD64Kind.DWORD);
 758             Register indexReg = asRegister(hash, AMD64Kind.DWORD);
 759             Register scratchReg = asRegister(scratch, AMD64Kind.QWORD);
 760             Register entryScratchReg = asRegister(entryScratch, AMD64Kind.QWORD);
 761 
 762             // Set scratch to address of jump table
 763             masm.leaq(scratchReg, new AMD64Address(AMD64.rip, 0));
 764             final int afterLea = masm.position();
 765 
 766             // When the default target is set, the jump table contains entries with two DWORDS:
 767             // the original key before hashing and the label jump address
 768             if (defaultTarget != null) {
 769 
 770                 // Move the table entry (two DWORDs) into a QWORD
 771                 masm.movq(entryScratchReg, new AMD64Address(scratchReg, indexReg, Scale.Times8, 0));
 772 
 773                 // Jump to the default target if the first DWORD (original key) doesn&#39;t match the
 774                 // current key. Accounts for hash collisions with unknown keys
<span class="line-modified"> 775                 masm.cmplAndJcc(entryScratchReg, valueReg, ConditionFlag.NotEqual, defaultTarget.label(), false);</span>

 776 
 777                 // Shift to the second DWORD
 778                 masm.sarq(entryScratchReg, 32);
 779             } else {
 780 
 781                 // The jump table has a single DWORD with the label address if there&#39;s no
 782                 // default target
 783                 masm.movslq(entryScratchReg, new AMD64Address(scratchReg, indexReg, Scale.Times4, 0));
 784             }
 785             masm.addq(scratchReg, entryScratchReg);
 786             masm.jmp(scratchReg);
 787 
 788             // Inserting padding so that jump the table address is aligned
 789             if (defaultTarget != null) {
 790                 masm.align(8);
 791             } else {
 792                 masm.align(4);
 793             }
 794 
 795             // Patch LEA instruction above now that we know the position of the jump table
</pre>
<hr />
<pre>
 888         @Alive({REG}) protected Value trueValue;
 889         @Alive({REG}) protected Value falseValue;
 890         private final ConditionFlag condition;
 891         private final boolean unorderedIsTrue;
 892 
 893         public FloatCondMoveOp(Variable result, Condition condition, boolean unorderedIsTrue, Variable trueValue, Variable falseValue) {
 894             super(TYPE);
 895             this.result = result;
 896             this.condition = floatCond(condition);
 897             this.unorderedIsTrue = unorderedIsTrue;
 898             this.trueValue = trueValue;
 899             this.falseValue = falseValue;
 900         }
 901 
 902         @Override
 903         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 904             cmove(crb, masm, result, true, condition, unorderedIsTrue, trueValue, falseValue);
 905         }
 906     }
 907 











 908     private static void cmove(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, boolean isFloat, ConditionFlag condition, boolean unorderedIsTrue, Value trueValue,
 909                     Value falseValue) {
 910         // check that we don&#39;t overwrite an input operand before it is used.
 911         assert !result.equals(trueValue);
 912 
 913         AMD64Move.move(crb, masm, result, falseValue);
 914         cmove(crb, masm, result, condition, trueValue);
 915 
 916         if (isFloat) {
 917             if (unorderedIsTrue &amp;&amp; !trueOnUnordered(condition)) {
 918                 cmove(crb, masm, result, ConditionFlag.Parity, trueValue);
 919             } else if (!unorderedIsTrue &amp;&amp; trueOnUnordered(condition)) {
 920                 cmove(crb, masm, result, ConditionFlag.Parity, falseValue);
 921             }
 922         }
 923     }
 924 
 925     private static void cmove(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, ConditionFlag cond, Value other) {
 926         if (isRegister(other)) {
 927             assert !asRegister(other).equals(asRegister(result)) : &quot;other already overwritten by previous move&quot;;
</pre>
</td>
</tr>
</table>
<center><a href="AMD64Call.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64FrameMap.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
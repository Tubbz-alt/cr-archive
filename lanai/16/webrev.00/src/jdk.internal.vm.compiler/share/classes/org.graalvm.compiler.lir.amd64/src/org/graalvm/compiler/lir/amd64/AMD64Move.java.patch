diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -42,10 +42,11 @@
 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 
 import org.graalvm.compiler.asm.Label;
 import org.graalvm.compiler.asm.amd64.AMD64Address;
+import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp;
 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 import org.graalvm.compiler.core.common.CompressEncoding;
@@ -587,11 +588,11 @@
                 break;
             case DOUBLE:
                 masm.movdbl(asRegister(result, AMD64Kind.DOUBLE), asRegister(input, AMD64Kind.DOUBLE));
                 break;
             default:
-                throw GraalError.shouldNotReachHere("kind=" + kind);
+                throw GraalError.shouldNotReachHere("kind=" + kind + " input=" + input + " result=" + result);
         }
     }
 
     public static void reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input) {
         AMD64Address dest = (AMD64Address) crb.asAddress(result);
@@ -613,11 +614,11 @@
                 break;
             case DOUBLE:
                 masm.movsd(dest, input);
                 break;
             default:
-                throw GraalError.shouldNotReachHere();
+                throw GraalError.shouldNotReachHere("kind=" + kind + " input=" + input + " result=" + result);
         }
     }
 
     public static void stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input) {
         AMD64Address src = (AMD64Address) crb.asAddress(input);
@@ -639,11 +640,11 @@
                 break;
             case DOUBLE:
                 masm.movdbl(result, src);
                 break;
             default:
-                throw GraalError.shouldNotReachHere();
+                throw GraalError.shouldNotReachHere("kind=" + kind + " input=" + input + " result=" + result);
         }
     }
 
     public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind) {
         /*
@@ -809,12 +810,17 @@
 
         @Def({REG, HINT}) private AllocatableValue result;
         @Use({REG, CONST}) private Value input;
         @Alive({REG, ILLEGAL, UNINITIALIZED}) private AllocatableValue baseRegister;
 
-        protected PointerCompressionOp(LIRInstructionClass<? extends PointerCompressionOp> type, AllocatableValue result, Value input,
-                        AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
+        protected PointerCompressionOp(LIRInstructionClass<? extends PointerCompressionOp> type,
+                        AllocatableValue result,
+                        Value input,
+                        AllocatableValue baseRegister,
+                        CompressEncoding encoding,
+                        boolean nonNull,
+                        LIRKindTool lirKindTool) {
 
             super(type);
             this.result = result;
             this.input = input;
             this.baseRegister = baseRegister;
@@ -845,13 +851,47 @@
 
         protected final int getShift() {
             return encoding.getShift();
         }
 
+        /**
+         * Emits code to move {@linkplain #getInput input} to {@link #getResult result}.
+         */
         protected final void move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm) {
             AMD64Move.move((AMD64Kind) kind.getPlatformKind(), crb, masm, result, input);
         }
+
+        /**
+         * Emits code to uncompress the compressed oop in {@code inputAndResultReg} by left shifting
+         * it {@code shift} bits, adding it to {@code baseReg} and storing the result back in
+         * {@code inputAndResultReg}.
+         */
+        public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register inputAndResultReg, Register baseReg, int shift, boolean preserveFlagsRegister) {
+            emitUncompressWithBaseRegister(masm, inputAndResultReg, baseReg, inputAndResultReg, shift, preserveFlagsRegister);
+        }
+
+        /**
+         * Emits code to uncompress the compressed oop in {@code inputReg} by left shifting it
+         * {@code shift} bits, adding it to {@code baseReg} and storing the result in
+         * {@code resultReg}.
+         */
+        public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister) {
+            assert !baseReg.equals(Register.None) || shift != 0 : "compression not enabled";
+            if (Scale.isScaleShiftSupported(shift)) {
+                AMD64Address.Scale scale = AMD64Address.Scale.fromShift(shift);
+                masm.leaq(resultReg, new AMD64Address(baseReg, inputReg, scale));
+            } else {
+                if (preserveFlagsRegister) {
+                    throw GraalError.shouldNotReachHere("No valid flag-effect-free instruction available to uncompress oop");
+                }
+                if (!resultReg.equals(inputReg)) {
+                    masm.movq(resultReg, inputReg);
+                }
+                masm.shlq(resultReg, shift);
+                masm.addq(resultReg, baseReg);
+            }
+        }
     }
 
     public static class CompressPointerOp extends PointerCompressionOp {
         public static final LIRInstructionClass<CompressPointerOp> TYPE = LIRInstructionClass.create(CompressPointerOp.class);
 
@@ -899,29 +939,27 @@
         }
 
         @Override
         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
             Register baseReg = getBaseRegister(crb);
+            int shift = getShift();
+            Register resReg = getResultRegister();
             if (nonNull && !baseReg.equals(Register.None) && getInput() instanceof RegisterValue) {
                 Register inputReg = ((RegisterValue) getInput()).getRegister();
-                if (!inputReg.equals(getResultRegister())) {
-                    masm.leaq(getResultRegister(), new AMD64Address(baseReg, inputReg, AMD64Address.Scale.fromShift(getShift())));
+                if (!inputReg.equals(resReg)) {
+                    emitUncompressWithBaseRegister(masm, resReg, baseReg, inputReg, shift, false);
                     return;
                 }
             }
             move(lirKindTool.getNarrowOopKind(), crb, masm);
-            emitUncompressCode(masm, getResultRegister(), getShift(), baseReg, nonNull);
+            emitUncompressCode(masm, resReg, shift, baseReg, nonNull);
         }
 
         public static void emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull) {
             if (nonNull) {
                 if (!baseReg.equals(Register.None)) {
-                    if (shift != 0) {
-                        masm.leaq(resReg, new AMD64Address(baseReg, resReg, AMD64Address.Scale.fromShift(shift)));
-                    } else {
-                        masm.addq(resReg, baseReg);
-                    }
+                    emitUncompressWithBaseRegister(masm, resReg, baseReg, shift, false);
                 } else if (shift != 0) {
                     masm.shlq(resReg, shift);
                 }
             } else {
                 if (shift != 0) {
@@ -972,13 +1010,12 @@
         }
 
         @Override
         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {
             if (inputRegister.equals(resultRegister)) {
-                masm.subq(inputRegister, nullRegister);
                 Label done = new Label();
-                masm.jccb(Equal, done);
+                masm.subqAndJcc(inputRegister, nullRegister, Equal, done, true);
                 masm.addq(inputRegister, nullRegister);
                 masm.bind(done);
             } else {
                 masm.subq(resultRegister, resultRegister);
                 masm.cmpq(inputRegister, nullRegister);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Call.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64CCall.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ControlFlow.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Call.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asRegister;
 28 import static jdk.vm.ci.code.ValueUtil.isRegister;
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
 31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
 33 import static org.graalvm.compiler.lir.LIRValueUtil.differentRegisters;
 34 
<span class="line-removed"> 35 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;</span>
 36 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 37 import org.graalvm.compiler.core.common.LIRKind;
 38 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 39 import org.graalvm.compiler.lir.LIRFrameState;
 40 import org.graalvm.compiler.lir.LIRInstructionClass;
 41 import org.graalvm.compiler.lir.Opcode;
 42 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 43 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapRegistersAfterInstruction;
 44 
 45 import jdk.vm.ci.amd64.AMD64;
 46 import jdk.vm.ci.amd64.AMD64Kind;
 47 import jdk.vm.ci.code.Register;
 48 import jdk.vm.ci.code.RegisterValue;
 49 import jdk.vm.ci.meta.AllocatableValue;
 50 import jdk.vm.ci.meta.InvokeTarget;
 51 import jdk.vm.ci.meta.ResolvedJavaMethod;
 52 import jdk.vm.ci.meta.Value;
 53 
 54 public class AMD64Call {
 55 
</pre>
<hr />
<pre>
 88 
 89     }
 90 
 91     @Opcode(&quot;CALL_DIRECT&quot;)
 92     public static class DirectCallOp extends MethodCallOp {
 93         public static final LIRInstructionClass&lt;DirectCallOp&gt; TYPE = LIRInstructionClass.create(DirectCallOp.class);
 94 
 95         public DirectCallOp(ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
 96             this(TYPE, callTarget, result, parameters, temps, state);
 97         }
 98 
 99         protected DirectCallOp(LIRInstructionClass&lt;? extends DirectCallOp&gt; c, ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
100             super(c, callTarget, result, parameters, temps, state);
101         }
102 
103         @Override
104         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
105             directCall(crb, masm, callTarget, null, true, state);
106         }
107 
<span class="line-modified">108         public int emitCall(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-modified">109             return directCall(crb, masm, callTarget, null, true, state);</span>
110         }
111     }
112 
113     @Opcode(&quot;CALL_INDIRECT&quot;)
114     public static class IndirectCallOp extends MethodCallOp {
115         public static final LIRInstructionClass&lt;IndirectCallOp&gt; TYPE = LIRInstructionClass.create(IndirectCallOp.class);
116 
117         @Use({REG}) protected Value targetAddress;
118 
119         public IndirectCallOp(ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, Value targetAddress, LIRFrameState state) {
120             this(TYPE, callTarget, result, parameters, temps, targetAddress, state);
121         }
122 
123         protected IndirectCallOp(LIRInstructionClass&lt;? extends IndirectCallOp&gt; c, ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, Value targetAddress,
124                         LIRFrameState state) {
125             super(c, callTarget, result, parameters, temps, state);
126             this.targetAddress = targetAddress;
127         }
128 
129         @Override
</pre>
<hr />
<pre>
178         public static final LIRInstructionClass&lt;DirectFarForeignCallOp&gt; TYPE = LIRInstructionClass.create(DirectFarForeignCallOp.class);
179 
180         @Temp({REG}) protected AllocatableValue callTemp;
181 
182         public DirectFarForeignCallOp(ForeignCallLinkage callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
183             super(TYPE, callTarget, result, parameters, temps, state);
184             /*
185              * The register allocator does not support virtual registers that are used at the call
186              * site, so use a fixed register.
187              */
188             callTemp = AMD64.rax.asValue(LIRKind.value(AMD64Kind.QWORD));
189             assert differentRegisters(parameters, callTemp);
190         }
191 
192         @Override
193         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
194             directCall(crb, masm, callTarget, ((RegisterValue) callTemp).getRegister(), false, state);
195         }
196     }
197 
<span class="line-modified">198     public static int directCall(CompilationResultBuilder crb, AMD64MacroAssembler masm, InvokeTarget callTarget, Register scratch, boolean align, LIRFrameState info) {</span>
<span class="line-modified">199         if (align) {</span>
<span class="line-removed">200             emitAlignmentForDirectCall(crb, masm);</span>
<span class="line-removed">201         }</span>
<span class="line-removed">202         int before = masm.position();</span>
<span class="line-removed">203         int callPCOffset;</span>
204         if (scratch != null &amp;&amp; !GeneratePIC.getValue(crb.getOptions())) {

205             // offset might not fit a 32-bit immediate, generate an
206             // indirect call with a 64-bit immediate
<span class="line-modified">207             masm.movq(scratch, 0L);</span>
<span class="line-modified">208             callPCOffset = masm.position();</span>
<span class="line-modified">209             masm.call(scratch);</span>

210         } else {
<span class="line-modified">211             callPCOffset = masm.position();</span>
<span class="line-removed">212             masm.call();</span>
213         }
214         int after = masm.position();
215         crb.recordDirectCall(before, after, callTarget, info);
216         crb.recordExceptionHandlers(after, info);
217         masm.ensureUniquePC();
<span class="line-removed">218         return callPCOffset;</span>
<span class="line-removed">219     }</span>
<span class="line-removed">220 </span>
<span class="line-removed">221     protected static void emitAlignmentForDirectCall(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-removed">222         // make sure that the displacement word of the call ends up word aligned</span>
<span class="line-removed">223         int offset = masm.position();</span>
<span class="line-removed">224         offset += crb.target.arch.getMachineCodeCallDisplacementOffset();</span>
<span class="line-removed">225         int modulus = crb.target.wordSize;</span>
<span class="line-removed">226         if (offset % modulus != 0) {</span>
<span class="line-removed">227             masm.nop(modulus - offset % modulus);</span>
<span class="line-removed">228         }</span>
229     }
230 
<span class="line-modified">231     public static int directJmp(CompilationResultBuilder crb, AMD64MacroAssembler masm, InvokeTarget target) {</span>
<span class="line-modified">232         return directJmp(crb, masm, target, null);</span>
<span class="line-removed">233     }</span>
<span class="line-removed">234 </span>
<span class="line-removed">235     public static int directJmp(CompilationResultBuilder crb, AMD64MacroAssembler masm, InvokeTarget target, Register scratch) {</span>
<span class="line-removed">236         int before = masm.position();</span>
<span class="line-removed">237         int callPCOffset;</span>
238         if (scratch != null &amp;&amp; !GeneratePIC.getValue(crb.getOptions())) {
239             // offset might not fit a 32-bit immediate, generate an
240             // indirect call with a 64-bit immediate
<span class="line-modified">241             masm.movq(scratch, 0L);</span>
<span class="line-removed">242             callPCOffset = masm.position();</span>
<span class="line-removed">243             masm.jmp(scratch);</span>
244         } else {
<span class="line-modified">245             callPCOffset = masm.position();</span>
<span class="line-removed">246             masm.jmp(0, true);</span>
247         }
<span class="line-modified">248         int after = masm.position();</span>
<span class="line-removed">249         crb.recordDirectCall(before, after, target, null);</span>
<span class="line-removed">250         masm.ensureUniquePC();</span>
<span class="line-removed">251         return callPCOffset;</span>
252     }
253 
<span class="line-modified">254     public static void directConditionalJmp(CompilationResultBuilder crb, AMD64MacroAssembler masm, InvokeTarget target, ConditionFlag cond) {</span>
<span class="line-modified">255         int before = masm.position();</span>
<span class="line-removed">256         masm.jcc(cond, 0, true);</span>
<span class="line-removed">257         int after = masm.position();</span>
<span class="line-removed">258         crb.recordDirectCall(before, after, target, null);</span>
259         masm.ensureUniquePC();
260     }
261 
<span class="line-modified">262     public static int indirectCall(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register dst, InvokeTarget callTarget, LIRFrameState info) {</span>
<span class="line-modified">263         int before = masm.position();</span>
<span class="line-removed">264         masm.call(dst);</span>
265         int after = masm.position();
266         crb.recordIndirectCall(before, after, callTarget, info);
267         crb.recordExceptionHandlers(after, info);
268         masm.ensureUniquePC();
<span class="line-removed">269         return before;</span>
270     }

271 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.amd64;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asRegister;
 28 import static jdk.vm.ci.code.ValueUtil.isRegister;
 29 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 30 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
 31 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
 33 import static org.graalvm.compiler.lir.LIRValueUtil.differentRegisters;
 34 

 35 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 36 import org.graalvm.compiler.core.common.LIRKind;
 37 import org.graalvm.compiler.core.common.spi.ForeignCallLinkage;
 38 import org.graalvm.compiler.lir.LIRFrameState;
 39 import org.graalvm.compiler.lir.LIRInstructionClass;
 40 import org.graalvm.compiler.lir.Opcode;
 41 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 42 import org.graalvm.compiler.lir.gen.DiagnosticLIRGeneratorTool.ZapRegistersAfterInstruction;
 43 
 44 import jdk.vm.ci.amd64.AMD64;
 45 import jdk.vm.ci.amd64.AMD64Kind;
 46 import jdk.vm.ci.code.Register;
 47 import jdk.vm.ci.code.RegisterValue;
 48 import jdk.vm.ci.meta.AllocatableValue;
 49 import jdk.vm.ci.meta.InvokeTarget;
 50 import jdk.vm.ci.meta.ResolvedJavaMethod;
 51 import jdk.vm.ci.meta.Value;
 52 
 53 public class AMD64Call {
 54 
</pre>
<hr />
<pre>
 87 
 88     }
 89 
 90     @Opcode(&quot;CALL_DIRECT&quot;)
 91     public static class DirectCallOp extends MethodCallOp {
 92         public static final LIRInstructionClass&lt;DirectCallOp&gt; TYPE = LIRInstructionClass.create(DirectCallOp.class);
 93 
 94         public DirectCallOp(ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
 95             this(TYPE, callTarget, result, parameters, temps, state);
 96         }
 97 
 98         protected DirectCallOp(LIRInstructionClass&lt;? extends DirectCallOp&gt; c, ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
 99             super(c, callTarget, result, parameters, temps, state);
100         }
101 
102         @Override
103         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
104             directCall(crb, masm, callTarget, null, true, state);
105         }
106 
<span class="line-modified">107         public void emitCall(CompilationResultBuilder crb, AMD64MacroAssembler masm) {</span>
<span class="line-modified">108             directCall(crb, masm, callTarget, null, true, state);</span>
109         }
110     }
111 
112     @Opcode(&quot;CALL_INDIRECT&quot;)
113     public static class IndirectCallOp extends MethodCallOp {
114         public static final LIRInstructionClass&lt;IndirectCallOp&gt; TYPE = LIRInstructionClass.create(IndirectCallOp.class);
115 
116         @Use({REG}) protected Value targetAddress;
117 
118         public IndirectCallOp(ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, Value targetAddress, LIRFrameState state) {
119             this(TYPE, callTarget, result, parameters, temps, targetAddress, state);
120         }
121 
122         protected IndirectCallOp(LIRInstructionClass&lt;? extends IndirectCallOp&gt; c, ResolvedJavaMethod callTarget, Value result, Value[] parameters, Value[] temps, Value targetAddress,
123                         LIRFrameState state) {
124             super(c, callTarget, result, parameters, temps, state);
125             this.targetAddress = targetAddress;
126         }
127 
128         @Override
</pre>
<hr />
<pre>
177         public static final LIRInstructionClass&lt;DirectFarForeignCallOp&gt; TYPE = LIRInstructionClass.create(DirectFarForeignCallOp.class);
178 
179         @Temp({REG}) protected AllocatableValue callTemp;
180 
181         public DirectFarForeignCallOp(ForeignCallLinkage callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState state) {
182             super(TYPE, callTarget, result, parameters, temps, state);
183             /*
184              * The register allocator does not support virtual registers that are used at the call
185              * site, so use a fixed register.
186              */
187             callTemp = AMD64.rax.asValue(LIRKind.value(AMD64Kind.QWORD));
188             assert differentRegisters(parameters, callTemp);
189         }
190 
191         @Override
192         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
193             directCall(crb, masm, callTarget, ((RegisterValue) callTemp).getRegister(), false, state);
194         }
195     }
196 
<span class="line-modified">197     public static void directCall(CompilationResultBuilder crb, AMD64MacroAssembler masm, InvokeTarget callTarget, Register scratch, boolean align, LIRFrameState info) {</span>
<span class="line-modified">198         int before;</span>




199         if (scratch != null &amp;&amp; !GeneratePIC.getValue(crb.getOptions())) {
<span class="line-added">200             assert !align;</span>
201             // offset might not fit a 32-bit immediate, generate an
202             // indirect call with a 64-bit immediate
<span class="line-modified">203             // This is an implicit contract between the backend and the jvmci code installer. The</span>
<span class="line-modified">204             // latter expects a mov instruction immediately preceding a call instruction. The jcc</span>
<span class="line-modified">205             // erratum padding should be inserted before the mov instruction.</span>
<span class="line-added">206             before = masm.directCall(0L, scratch);</span>
207         } else {
<span class="line-modified">208             before = masm.directCall(align, crb.target.arch.getMachineCodeCallDisplacementOffset(), crb.target.wordSize);</span>

209         }
210         int after = masm.position();
211         crb.recordDirectCall(before, after, callTarget, info);
212         crb.recordExceptionHandlers(after, info);
213         masm.ensureUniquePC();











214     }
215 
<span class="line-modified">216     public static void directJmp(CompilationResultBuilder crb, AMD64MacroAssembler masm, InvokeTarget target, Register scratch) {</span>
<span class="line-modified">217         int before;</span>





218         if (scratch != null &amp;&amp; !GeneratePIC.getValue(crb.getOptions())) {
219             // offset might not fit a 32-bit immediate, generate an
220             // indirect call with a 64-bit immediate
<span class="line-modified">221             before = masm.directJmp(0L, scratch);</span>


222         } else {
<span class="line-modified">223             before = masm.jmp(0, true);</span>

224         }
<span class="line-modified">225         recordDirectCall(crb, masm, target, before);</span>



226     }
227 
<span class="line-modified">228     public static void recordDirectCall(CompilationResultBuilder crb, AMD64MacroAssembler masm, InvokeTarget target, int before) {</span>
<span class="line-modified">229         crb.recordDirectCall(before, masm.position(), target, null);</span>



230         masm.ensureUniquePC();
231     }
232 
<span class="line-modified">233     public static void indirectCall(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register dst, InvokeTarget callTarget, LIRFrameState info) {</span>
<span class="line-modified">234         int before = masm.indirectCall(dst);</span>

235         int after = masm.position();
236         crb.recordIndirectCall(before, after, callTarget, info);
237         crb.recordExceptionHandlers(after, info);
238         masm.ensureUniquePC();

239     }
<span class="line-added">240 </span>
241 }
</pre>
</td>
</tr>
</table>
<center><a href="AMD64CCall.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ControlFlow.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
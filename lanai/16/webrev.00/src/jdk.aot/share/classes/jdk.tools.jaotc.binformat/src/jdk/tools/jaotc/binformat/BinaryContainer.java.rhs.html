<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.aot/share/classes/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc.binformat;
 27 
 28 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 29 
 30 import java.io.ByteArrayOutputStream;
 31 import java.io.DataOutputStream;
 32 import java.io.IOException;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 
 39 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 40 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 41 import org.graalvm.compiler.options.OptionValues;
 42 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 43 
 44 import jdk.tools.jaotc.binformat.Symbol.Binding;
 45 import jdk.tools.jaotc.binformat.Symbol.Kind;
 46 import jdk.tools.jaotc.binformat.elf.JELFRelocObject;
 47 import jdk.tools.jaotc.binformat.macho.JMachORelocObject;
 48 import jdk.tools.jaotc.binformat.pecoff.JPECoffRelocObject;
 49 
 50 /**
 51  * A format-agnostic container class that holds various components of a binary.
 52  *
 53  * &lt;p&gt;
 54  * This class holds information necessary to create platform-specific binary containers such as
 55  * ELFContainer for Linux and Solaris operating systems or MachOContainer for Mac OS or PEContainer
 56  * for MS Windows operating systems.
 57  *
 58  * &lt;p&gt;
 59  * Method APIs provided by this class are used to construct and populate platform-independent
 60  * contents of a binary as the first step to create a binary representation of code generated by a
 61  * compiler backend such as Graal.
 62  *
 63  * &lt;p&gt;
 64  * Methods to record and access code section contents, symbols and relocations are provided.
 65  */
 66 public final class BinaryContainer implements SymbolTable {
 67     private final OptionValues graalOptions;
 68 
 69     private final int codeSegmentSize;
 70 
 71     private final int codeEntryAlignment;
 72 
 73     private final boolean threadLocalHandshakes;
 74 
 75     /**
 76      * Container holding code bits and any other related information.
 77      */
 78     private final CodeContainer codeContainer;
 79 
 80     /**
 81      * Container holding global offset data for hotspot linkage.
 82      */
 83     private final ByteContainer extLinkageGOTContainer;
 84 
 85     /**
 86      * Patched by HotSpot, contains Klass pointers.
 87      */
 88     private final ByteContainer klassesGotContainer;
 89 
 90     /**
 91      * Patched by HotSpot, contains MethodCounters pointers.
 92      */
 93     private final ByteContainer countersGotContainer;
 94 
 95     /**
 96      * Patched lazily by hotspot, contains klass/method pointers.
 97      */
 98     private final ByteContainer metadataGotContainer;
 99 
100     /**
101      * BSS container, contains method state array.
102      */
103     private final ByteContainer methodStateContainer;
104 
105     /**
106      * Patched by hotspot, contains java object pointers.
107      */
108     private final ByteContainer oopGotContainer;
109 
110     // Containers holding read-only data
111     private final ReadOnlyDataContainer configContainer;
112     private final ReadOnlyDataContainer metaspaceNamesContainer;
113     private final ReadOnlyDataContainer methodsOffsetsContainer;
114     private final ReadOnlyDataContainer klassesOffsetsContainer;
115     private final ReadOnlyDataContainer klassesDependenciesContainer;
116     private final HeaderContainer headerContainer;
117     private final ReadOnlyDataContainer stubsOffsetsContainer;
118     private final ReadOnlyDataContainer codeSegmentsContainer;
119 
120     // This cannot be read only since we need to patch the metadata at runtime..
121     private final ReadOnlyDataContainer methodMetadataContainer;
122 
123     /**
124      * Container containing constant data used by code.
125      */
126     private final ReadOnlyDataContainer constantDataContainer;
127 
128     /**
129      * Map holding the Strings table.
130      */
131     private final Map&lt;String, Integer&gt; offsetStringTable = new HashMap&lt;&gt;();
132 
133     private final Map&lt;String, Integer&gt; metaspaceNames = new HashMap&lt;&gt;();
134 
135     // List of relocation table entries - (symbolName, relocationInfo)
136     private final Map&lt;String, Symbol&gt; symbolTable = new HashMap&lt;&gt;();
137     private final Map&lt;Symbol, List&lt;Relocation&gt;&gt; relocationTable = new HashMap&lt;&gt;();
138     private final Map&lt;Symbol, Relocation&gt; uniqueRelocationTable = new HashMap&lt;&gt;();
139 
140     /**
141      * Mapping of local VM function names to known global symbols generated in the output binary.
142      */
143     private static final HashMap&lt;String, String&gt; functionNamesToAOTSymbols = new HashMap&lt;&gt;();
144 
145     //@formatter:off
146     private static final String[][] map = {
147         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;,         &quot;_aot_deopt_blob_unpack&quot;},
148         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;,  &quot;_aot_deopt_blob_uncommon_trap&quot;},
149         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls&quot;,  &quot;_aot_deopt_blob_unpack_with_exception_in_tls&quot;},
150         {&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;,              &quot;_aot_ic_miss_stub&quot;},
151         {&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;,  &quot;_aot_handle_wrong_method_stub&quot;},
152         {&quot;SharedRuntime::exception_handler_for_return_address&quot;,         &quot;_aot_exception_handler_for_return_address&quot;},
153         {&quot;SharedRuntime::register_finalizer&quot;,                           &quot;_aot_register_finalizer&quot;},
154         {&quot;SharedRuntime::OSR_migration_end&quot;,                            &quot;_aot_OSR_migration_end&quot;},
155         {&quot;SharedRuntime::enable_stack_reserved_zone&quot;,                   &quot;_aot_enable_stack_reserved_zone&quot;},
156         {&quot;CompilerRuntime::resolve_dynamic_invoke&quot;,                     &quot;_aot_resolve_dynamic_invoke&quot;},
157         {&quot;CompilerRuntime::resolve_string_by_symbol&quot;,                   &quot;_aot_resolve_string_by_symbol&quot;},
158         {&quot;CompilerRuntime::resolve_klass_by_symbol&quot;,                    &quot;_aot_resolve_klass_by_symbol&quot;},
159         {&quot;CompilerRuntime::resolve_method_by_symbol_and_load_counters&quot;, &quot;_aot_resolve_method_by_symbol_and_load_counters&quot;},
160         {&quot;CompilerRuntime::initialize_klass_by_symbol&quot;,                 &quot;_aot_initialize_klass_by_symbol&quot;},
161         {&quot;CompilerRuntime::invocation_event&quot;,                           &quot;_aot_invocation_event&quot;},
162         {&quot;CompilerRuntime::backedge_event&quot;,                             &quot;_aot_backedge_event&quot;},
163 
164         {&quot;CompilerToVM::Data::dpow&quot;, &quot;_aot_shared_runtime_dpow&quot;},
165         {&quot;CompilerToVM::Data::dexp&quot;, &quot;_aot_shared_runtime_dexp&quot;},
166         {&quot;CompilerToVM::Data::dcos&quot;, &quot;_aot_shared_runtime_dcos&quot;},
167         {&quot;CompilerToVM::Data::dsin&quot;, &quot;_aot_shared_runtime_dsin&quot;},
168         {&quot;CompilerToVM::Data::dtan&quot;, &quot;_aot_shared_runtime_dtan&quot;},
169         {&quot;CompilerToVM::Data::dlog&quot;, &quot;_aot_shared_runtime_dlog&quot;},
170         {&quot;CompilerToVM::Data::dlog10&quot;, &quot;_aot_shared_runtime_dlog10&quot;},
171 
172         {&quot;StubRoutines::_jbyte_arraycopy&quot;, &quot;_aot_stub_routines_jbyte_arraycopy&quot;},
173         {&quot;StubRoutines::_jshort_arraycopy&quot;, &quot;_aot_stub_routines_jshort_arraycopy&quot;},
174         {&quot;StubRoutines::_jint_arraycopy&quot;, &quot;_aot_stub_routines_jint_arraycopy&quot;},
175         {&quot;StubRoutines::_jlong_arraycopy&quot;, &quot;_aot_stub_routines_jlong_arraycopy&quot;},
176         {&quot;StubRoutines::_oop_arraycopy&quot;, &quot;_aot_stub_routines_oop_arraycopy&quot;},
177         {&quot;StubRoutines::_oop_arraycopy_uninit&quot;, &quot;_aot_stub_routines_oop_arraycopy_uninit&quot;},
178 
179         {&quot;StubRoutines::_jbyte_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_jbyte_disjoint_arraycopy&quot;},
180         {&quot;StubRoutines::_jshort_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_jshort_disjoint_arraycopy&quot;},
181         {&quot;StubRoutines::_jint_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_jint_disjoint_arraycopy&quot;},
182         {&quot;StubRoutines::_jlong_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_jlong_disjoint_arraycopy&quot;},
183         {&quot;StubRoutines::_oop_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_oop_disjoint_arraycopy&quot;},
184         {&quot;StubRoutines::_oop_disjoint_arraycopy_uninit&quot;, &quot;_aot_stub_routines_oop_disjoint_arraycopy_uninit&quot;},
185 
186         {&quot;StubRoutines::_arrayof_jbyte_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jbyte_arraycopy&quot;},
187         {&quot;StubRoutines::_arrayof_jshort_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jshort_arraycopy&quot;},
188         {&quot;StubRoutines::_arrayof_jint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jint_arraycopy&quot;},
189         {&quot;StubRoutines::_arrayof_jlong_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jlong_arraycopy&quot;},
190         {&quot;StubRoutines::_arrayof_oop_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_oop_arraycopy&quot;},
191         {&quot;StubRoutines::_arrayof_oop_arraycopy_uninit&quot;, &quot;_aot_stub_routines_arrayof_oop_arraycopy_uninit&quot;},
192 
193         {&quot;StubRoutines::_arrayof_jbyte_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy&quot;},
194         {&quot;StubRoutines::_arrayof_jshort_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jshort_disjoint_arraycopy&quot;},
195         {&quot;StubRoutines::_arrayof_jint_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jint_disjoint_arraycopy&quot;},
196         {&quot;StubRoutines::_arrayof_jlong_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jlong_disjoint_arraycopy&quot;},
197         {&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy&quot;},
198         {&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit&quot;, &quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit&quot;},
199 
200         {&quot;StubRoutines::_unsafe_arraycopy&quot;, &quot;_aot_stub_routines_unsafe_arraycopy&quot;},
201 
202         {&quot;StubRoutines::_checkcast_arraycopy&quot;, &quot;_aot_stub_routines_checkcast_arraycopy&quot;},
203 
204         {&quot;StubRoutines::_generic_arraycopy&quot;, &quot;_aot_stub_routines_generic_arraycopy&quot;},
205 
206         {&quot;StubRoutines::_aescrypt_encryptBlock&quot;, &quot;_aot_stub_routines_aescrypt_encryptBlock&quot;},
207         {&quot;StubRoutines::_aescrypt_decryptBlock&quot;, &quot;_aot_stub_routines_aescrypt_decryptBlock&quot;},
208         {&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, &quot;_aot_stub_routines_cipherBlockChaining_encryptAESCrypt&quot;},
209         {&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, &quot;_aot_stub_routines_cipherBlockChaining_decryptAESCrypt&quot;},
210         {&quot;StubRoutines::_electronicCodeBook_encryptAESCrypt&quot;, &quot;_aot_stub_routines_electronicCodeBook_encryptAESCrypt&quot;},
211         {&quot;StubRoutines::_electronicCodeBook_decryptAESCrypt&quot;, &quot;_aot_stub_routines_electronicCodeBook_decryptAESCrypt&quot;},
212         {&quot;StubRoutines::_updateBytesCRC32&quot;, &quot;_aot_stub_routines_update_bytes_crc32&quot;},
213         {&quot;StubRoutines::_crc_table_adr&quot;, &quot;_aot_stub_routines_crc_table_adr&quot;},
214 
215         {&quot;StubRoutines::_sha1_implCompress&quot;, &quot;_aot_stub_routines_sha1_implCompress&quot; },
216         {&quot;StubRoutines::_sha1_implCompressMB&quot;, &quot;_aot_stub_routines_sha1_implCompressMB&quot; },
217         {&quot;StubRoutines::_sha256_implCompress&quot;, &quot;_aot_stub_routines_sha256_implCompress&quot; },
218         {&quot;StubRoutines::_sha256_implCompressMB&quot;, &quot;_aot_stub_routines_sha256_implCompressMB&quot; },
219         {&quot;StubRoutines::_sha512_implCompress&quot;, &quot;_aot_stub_routines_sha512_implCompress&quot; },
220         {&quot;StubRoutines::_sha512_implCompressMB&quot;, &quot;_aot_stub_routines_sha512_implCompressMB&quot; },
221         {&quot;StubRoutines::_multiplyToLen&quot;, &quot;_aot_stub_routines_multiplyToLen&quot; },
222 
223         {&quot;StubRoutines::_counterMode_AESCrypt&quot;, &quot;_aot_stub_routines_counterMode_AESCrypt&quot; },
224         {&quot;StubRoutines::_ghash_processBlocks&quot;, &quot;_aot_stub_routines_ghash_processBlocks&quot; },
225         {&quot;StubRoutines::_base64_encodeBlock&quot;, &quot;_aot_stub_routines_base64_encodeBlock&quot; },
226         {&quot;StubRoutines::_crc32c_table_addr&quot;, &quot;_aot_stub_routines_crc32c_table_addr&quot; },
227         {&quot;StubRoutines::_updateBytesCRC32C&quot;, &quot;_aot_stub_routines_updateBytesCRC32C&quot; },
228         {&quot;StubRoutines::_updateBytesAdler32&quot;, &quot;_aot_stub_routines_updateBytesAdler32&quot; },
229         {&quot;StubRoutines::_squareToLen&quot;, &quot;_aot_stub_routines_squareToLen&quot; },
230         {&quot;StubRoutines::_mulAdd&quot;, &quot;_aot_stub_routines_mulAdd&quot; },
231         {&quot;StubRoutines::_montgomeryMultiply&quot;, &quot;_aot_stub_routines_montgomeryMultiply&quot; },
232         {&quot;StubRoutines::_montgomerySquare&quot;, &quot;_aot_stub_routines_montgomerySquare&quot; },
233         {&quot;StubRoutines::_vectorizedMismatch&quot;, &quot;_aot_stub_routines_vectorizedMismatch&quot; },
234         {&quot;StubRoutines::_bigIntegerRightShiftWorker&quot;, &quot;_aot_stub_routines_bigIntegerRightShiftWorker&quot; },
235         {&quot;StubRoutines::_bigIntegerLeftShiftWorker&quot;, &quot;_aot_stub_routines_bigIntegerLeftShiftWorker&quot; },
236 
237         {&quot;StubRoutines::_throw_delayed_StackOverflowError_entry&quot;, &quot;_aot_stub_routines_throw_delayed_StackOverflowError_entry&quot; },
238 
239 
240         {&quot;os::javaTimeMillis&quot;, &quot;_aot_os_javaTimeMillis&quot;},
241         {&quot;os::javaTimeNanos&quot;, &quot;_aot_os_javaTimeNanos&quot;},
242 
243         {&quot;JVMCIRuntime::monitorenter&quot;, &quot;_aot_jvmci_runtime_monitorenter&quot;},
244         {&quot;JVMCIRuntime::monitorexit&quot;, &quot;_aot_jvmci_runtime_monitorexit&quot;},
245         {&quot;JVMCIRuntime::object_notify&quot;, &quot;_aot_object_notify&quot;},
246         {&quot;JVMCIRuntime::object_notifyAll&quot;, &quot;_aot_object_notifyAll&quot;},
247         {&quot;JVMCIRuntime::log_object&quot;, &quot;_aot_jvmci_runtime_log_object&quot;},
248         {&quot;JVMCIRuntime::log_printf&quot;, &quot;_aot_jvmci_runtime_log_printf&quot;},
249         {&quot;JVMCIRuntime::vm_message&quot;, &quot;_aot_jvmci_runtime_vm_message&quot;},
250         {&quot;JVMCIRuntime::new_instance&quot;, &quot;_aot_jvmci_runtime_new_instance&quot;},
251         {&quot;JVMCIRuntime::new_array&quot;, &quot;_aot_jvmci_runtime_new_array&quot;},
252         {&quot;JVMCIRuntime::new_multi_array&quot;, &quot;_aot_jvmci_runtime_new_multi_array&quot;},
253         {&quot;JVMCIRuntime::dynamic_new_instance&quot;, &quot;_aot_jvmci_runtime_dynamic_new_instance&quot;},
254         {&quot;JVMCIRuntime::dynamic_new_array&quot;, &quot;_aot_jvmci_runtime_dynamic_new_array&quot;},
255         {&quot;JVMCIRuntime::new_instance_or_null&quot;, &quot;_aot_jvmci_runtime_new_instance_or_null&quot;},
256         {&quot;JVMCIRuntime::new_array_or_null&quot;, &quot;_aot_jvmci_runtime_new_array_or_null&quot;},
257         {&quot;JVMCIRuntime::new_multi_array_or_null&quot;, &quot;_aot_jvmci_runtime_new_multi_array_or_null&quot;},
258         {&quot;JVMCIRuntime::dynamic_new_instance_or_null&quot;, &quot;_aot_jvmci_runtime_dynamic_new_instance_or_null&quot;},
259         {&quot;JVMCIRuntime::dynamic_new_array_or_null&quot;, &quot;_aot_jvmci_runtime_dynamic_new_array_or_null&quot;},
260         {&quot;JVMCIRuntime::log_primitive&quot;, &quot;_aot_jvmci_runtime_log_primitive&quot;},
261         {&quot;JVMCIRuntime::validate_object&quot;, &quot;_aot_jvmci_runtime_validate_object&quot;},
262         {&quot;JVMCIRuntime::write_barrier_pre&quot;, &quot;_aot_jvmci_runtime_write_barrier_pre&quot;},
263         {&quot;JVMCIRuntime::identity_hash_code&quot;, &quot;_aot_jvmci_runtime_identity_hash_code&quot;},
264         {&quot;JVMCIRuntime::write_barrier_post&quot;, &quot;_aot_jvmci_runtime_write_barrier_post&quot;},
265         {&quot;JVMCIRuntime::thread_is_interrupted&quot;, &quot;_aot_jvmci_runtime_thread_is_interrupted&quot;},
266         {&quot;JVMCIRuntime::exception_handler_for_pc&quot;, &quot;_aot_jvmci_runtime_exception_handler_for_pc&quot;},
267         {&quot;JVMCIRuntime::test_deoptimize_call_int&quot;, &quot;_aot_jvmci_runtime_test_deoptimize_call_int&quot;},
268 
269         {&quot;JVMCIRuntime::throw_and_post_jvmti_exception&quot;,      &quot;_aot_jvmci_runtime_throw_and_post_jvmti_exception&quot;},
270         {&quot;JVMCIRuntime::throw_klass_external_name_exception&quot;, &quot;_aot_jvmci_runtime_throw_klass_external_name_exception&quot;},
271         {&quot;JVMCIRuntime::throw_class_cast_exception&quot;,          &quot;_aot_jvmci_runtime_throw_class_cast_exception&quot;},
272 
273         {&quot;JVMCIRuntime::vm_error&quot;, &quot;_aot_jvmci_runtime_vm_error&quot;}
274     };
275     //@formatter:on
276 
277     static {
278         for (String[] entry : map) {
279             functionNamesToAOTSymbols.put(entry[0], entry[1]);
280         }
281     }
282 
283     /**
284      * Allocates a {@code BinaryContainer} object whose content will be generated in a file with the
285      * prefix {@code prefix}. It also initializes internal code container, symbol table and
286      * relocation tables.
287      *
288      * @param graalOptions
289      */
290     public BinaryContainer(OptionValues graalOptions, GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc, String jvmVersion) {
291         this.graalOptions = graalOptions;
292 
293         this.codeSegmentSize = graalHotSpotVMConfig.codeSegmentSize;
294         if (codeSegmentSize &lt; 1 || codeSegmentSize &gt; 1024) {
295             throw new InternalError(&quot;codeSegmentSize is not in range [1, 1024] bytes: (&quot; + codeSegmentSize + &quot;), update JPECoffRelocObject&quot;);
296         }
297         if ((codeSegmentSize &amp; (codeSegmentSize - 1)) != 0) {
298             throw new InternalError(&quot;codeSegmentSize is not power of 2: (&quot; + codeSegmentSize + &quot;), update JPECoffRelocObject&quot;);
299         }
300 
301         this.codeEntryAlignment = graalHotSpotVMConfig.codeEntryAlignment;
302 
303         this.threadLocalHandshakes = graalHotSpotVMConfig.threadLocalHandshakes;
304 
305         // Section unique name is limited to 8 characters due to limitation on Windows.
306         // Name could be longer but only first 8 characters are stored on Windows.
307 
308         // read only, code
309         codeContainer = new CodeContainer(&quot;.text&quot;, this);
310 
311         // read only, info
312         headerContainer = new HeaderContainer(jvmVersion, new ReadOnlyDataContainer(&quot;.header&quot;, this));
313         configContainer = new ReadOnlyDataContainer(&quot;.config&quot;, this);
314         metaspaceNamesContainer = new ReadOnlyDataContainer(&quot;.meta.names&quot;, this);
315         methodsOffsetsContainer = new ReadOnlyDataContainer(&quot;.meth.offsets&quot;, this);
316         klassesOffsetsContainer = new ReadOnlyDataContainer(&quot;.kls.offsets&quot;, this);
317         klassesDependenciesContainer = new ReadOnlyDataContainer(&quot;.kls.dependencies&quot;, this);
318 
319         stubsOffsetsContainer = new ReadOnlyDataContainer(&quot;.stubs.offsets&quot;, this);
320         codeSegmentsContainer = new ReadOnlyDataContainer(&quot;.code.segments&quot;, this);
321         constantDataContainer = new ReadOnlyDataContainer(&quot;.meth.constdata&quot;, this);
322         methodMetadataContainer = new ReadOnlyDataContainer(&quot;.meth.metadata&quot;, this);
323 
324         // writable sections
325         oopGotContainer = new ByteContainer(&quot;.oop.got&quot;, this);
326         klassesGotContainer = new ByteContainer(&quot;.kls.got&quot;, this);
327         countersGotContainer = new ByteContainer(&quot;.cnt.got&quot;, this);
328         metadataGotContainer = new ByteContainer(&quot;.meta.got&quot;, this);
329         methodStateContainer = new ByteContainer(&quot;.meth.state&quot;, this);
330         extLinkageGOTContainer = new ByteContainer(&quot;.got.linkage&quot;, this);
331 
332         addGlobalSymbols();
333 
334         recordConfiguration(graalHotSpotVMConfig, graphBuilderConfig, gc);
335     }
336 
337     private void recordConfiguration(GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc) {
338         // @Checkstyle: stop
339         // @formatter:off
<a name="1" id="anc1"></a><span class="line-modified">340         ArrayList&lt;Boolean&gt; booleanFlagsList = new ArrayList&lt;&gt;();</span>
<span class="line-modified">341 </span>
<span class="line-modified">342         booleanFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.cAssertions, // Debug VM</span>
<span class="line-modified">343                                               graalHotSpotVMConfig.useCompressedOops,</span>
<span class="line-modified">344                                               graalHotSpotVMConfig.useCompressedClassPointers));</span>
<span class="line-modified">345         if (JavaVersionUtil.JAVA_SPEC &lt; 15) {</span>
<span class="line-modified">346             // See JDK-8236224. FieldsAllocationStyle and CompactFields flags were removed in JDK15.</span>
<span class="line-modified">347             booleanFlagsList.add(graalHotSpotVMConfig.compactFields);</span>
<span class="line-modified">348         }</span>
<span class="line-modified">349         booleanFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.useTLAB,</span>
<span class="line-modified">350                                               graalHotSpotVMConfig.useBiasedLocking,</span>
<span class="line-modified">351                                               TieredAOT.getValue(graalOptions),</span>
<span class="line-modified">352                                               graalHotSpotVMConfig.enableContended,</span>
<span class="line-modified">353                                               graalHotSpotVMConfig.restrictContended,</span>
<span class="line-modified">354                                               graphBuilderConfig.omitAssertions()));</span>






355         if (JavaVersionUtil.JAVA_SPEC &lt; 14) {
356             // See JDK-8220049. Thread local handshakes are on by default since JDK14, the command line option has been removed.
<a name="2" id="anc2"></a><span class="line-modified">357             booleanFlagsList.add(graalHotSpotVMConfig.threadLocalHandshakes);</span>

358         }
359 
<a name="3" id="anc3"></a><span class="line-modified">360         ArrayList&lt;Integer&gt; intFlagsList = new ArrayList&lt;&gt;();</span>
<span class="line-added">361         intFlagsList.addAll(Arrays.asList(graalHotSpotVMConfig.getOopEncoding().getShift(),</span>
<span class="line-added">362                                           graalHotSpotVMConfig.getKlassEncoding().getShift(),</span>
<span class="line-added">363                                           graalHotSpotVMConfig.contendedPaddingWidth));</span>
<span class="line-added">364         if (JavaVersionUtil.JAVA_SPEC &lt; 15) {</span>
<span class="line-added">365             // See JDK-8236224. FieldsAllocationStyle and CompactFields flags were removed in JDK15.</span>
<span class="line-added">366             intFlagsList.add(graalHotSpotVMConfig.fieldsAllocationStyle);</span>
<span class="line-added">367         }</span>
<span class="line-added">368         intFlagsList.addAll(Arrays.asList(1 &lt;&lt; graalHotSpotVMConfig.logMinObjAlignment(),</span>
<span class="line-added">369                                           graalHotSpotVMConfig.codeSegmentSize,</span>
<span class="line-added">370                                           gc));</span>
<span class="line-added">371 </span>
<span class="line-added">372         // @formatter:on</span>
<span class="line-added">373         // @Checkstyle: resume</span>
<span class="line-added">374 </span>
<span class="line-added">375         byte[] booleanFlagsAsBytes = booleanListToByteArray(booleanFlagsList);</span>
<span class="line-added">376         int[] intFlags = intFlagsList.stream().mapToInt(i -&gt; i).toArray();</span>
377         int size0 = configContainer.getByteStreamSize();
378 
379         // @formatter:off
380         int computedSize = booleanFlagsAsBytes.length * Byte.BYTES    + // size of boolean flags
381                            intFlags.length            * Integer.BYTES + // size of int flags
382                            Integer.BYTES;                               // size of the &quot;computedSize&quot;
383 
384         configContainer.appendInt(computedSize).
385                         appendInts(intFlags).
386                         appendBytes(booleanFlagsAsBytes);
387         // @formatter:on
388 
389         int size = configContainer.getByteStreamSize() - size0;
390         assert size == computedSize;
391     }
392 
<a name="4" id="anc4"></a><span class="line-modified">393     private static byte[] booleanListToByteArray(ArrayList&lt;Boolean&gt; list) {</span>
<span class="line-modified">394         byte[] byteArray = new byte[list.size()];</span>
<span class="line-modified">395         for (int i = 0; i &lt; list.size(); ++i) {</span>
<span class="line-modified">396             byteArray[i] = boolToByte(list.get(i));</span>
397         }
398         return byteArray;
399     }
400 
401     private static byte boolToByte(boolean flag) {
402         return (byte) (flag ? 1 : 0);
403     }
404 
405     /**
406      * Free some memory.
407      */
408     public void freeMemory() {
409         offsetStringTable.clear();
410         metaspaceNames.clear();
411     }
412 
413     /*
414      * Global symbol names in generated DSO corresponding to VM&#39;s symbols. VM needs to look up this
415      * symbol in DSO and link it with VM&#39;s corresponding symbol: store VM&#39;s symbol address or value
416      * in the named GOT cell.
417      */
418 
419     public static String getCardTableAddressSymbolName() {
420         return &quot;_aot_card_table_address&quot;;
421     }
422 
423     public static String getHeapTopAddressSymbolName() {
424         return &quot;_aot_heap_top_address&quot;;
425     }
426 
427     public static String getHeapEndAddressSymbolName() {
428         return &quot;_aot_heap_end_address&quot;;
429     }
430 
431     public static String getCrcTableAddressSymbolName() {
432         return &quot;_aot_stub_routines_crc_table_adr&quot;;
433     }
434 
435     public static String getPollingPageSymbolName() {
436         return &quot;_aot_polling_page&quot;;
437     }
438 
439     public static String getResolveStaticEntrySymbolName() {
440         return &quot;_resolve_static_entry&quot;;
441     }
442 
443     public static String getResolveVirtualEntrySymbolName() {
444         return &quot;_resolve_virtual_entry&quot;;
445     }
446 
447     public static String getResolveOptVirtualEntrySymbolName() {
448         return &quot;_resolve_opt_virtual_entry&quot;;
449     }
450 
451     public static String getNarrowKlassBaseAddressSymbolName() {
452         return &quot;_aot_narrow_klass_base_address&quot;;
453     }
454 
455     public static String getNarrowOopBaseAddressSymbolName() {
456         return &quot;_aot_narrow_oop_base_address&quot;;
457     }
458 
459     public static String getLogOfHeapRegionGrainBytesSymbolName() {
460         return &quot;_aot_log_of_heap_region_grain_bytes&quot;;
461     }
462 
463     public static String getInlineContiguousAllocationSupportedSymbolName() {
464         return &quot;_aot_inline_contiguous_allocation_supported&quot;;
465     }
466 
467     public int getCodeSegmentSize() {
468         return codeSegmentSize;
469     }
470 
471     public int getCodeEntryAlignment() {
472         return codeEntryAlignment;
473     }
474 
475     public boolean getThreadLocalHandshakes() {
476         return threadLocalHandshakes;
477     }
478 
479     /**
480      * Gets the global AOT symbol associated with the function name.
481      *
482      * @param functionName function name
483      * @return AOT symbol for the given function name, or null if there is no mapping.
484      */
485     public static String getAOTSymbolForVMFunctionName(String functionName) {
486         return functionNamesToAOTSymbols.get(functionName);
487     }
488 
489     private void addGlobalSymbols() {
490         // Create global symbols for all containers.
491         createContainerSymbol(codeContainer);
492         createContainerSymbol(configContainer);
493         createContainerSymbol(methodsOffsetsContainer);
494         createContainerSymbol(klassesOffsetsContainer);
495         createContainerSymbol(klassesDependenciesContainer);
496         createContainerSymbol(klassesGotContainer);
497         createContainerSymbol(countersGotContainer);
498         createContainerSymbol(metadataGotContainer);
499         createContainerSymbol(methodStateContainer);
500         createContainerSymbol(oopGotContainer);
501         createContainerSymbol(metaspaceNamesContainer);
502         createContainerSymbol(methodMetadataContainer);
503         createContainerSymbol(stubsOffsetsContainer);
504         createContainerSymbol(headerContainer.getContainer());
505         createContainerSymbol(codeSegmentsContainer);
506 
507         createGotSymbol(getResolveStaticEntrySymbolName());
508         createGotSymbol(getResolveVirtualEntrySymbolName());
509         createGotSymbol(getResolveOptVirtualEntrySymbolName());
510         createGotSymbol(getCardTableAddressSymbolName());
511         createGotSymbol(getHeapTopAddressSymbolName());
512         createGotSymbol(getHeapEndAddressSymbolName());
513         createGotSymbol(getNarrowKlassBaseAddressSymbolName());
514         createGotSymbol(getNarrowOopBaseAddressSymbolName());
515         createGotSymbol(getPollingPageSymbolName());
516         createGotSymbol(getLogOfHeapRegionGrainBytesSymbolName());
517         createGotSymbol(getInlineContiguousAllocationSupportedSymbolName());
518 
519         for (HashMap.Entry&lt;String, String&gt; entry : functionNamesToAOTSymbols.entrySet()) {
520             createGotSymbol(entry.getValue());
521         }
522     }
523 
524     /**
525      * Creates a global symbol of the form {@code &quot;A&quot; + container name}. Note, linker on Windows
526      * does not allow names which start with &#39;.&#39;
527      *
528      * @param container container to create a symbol for
529      */
530     private static void createContainerSymbol(ByteContainer container) {
531         container.createSymbol(0, Kind.OBJECT, Binding.GLOBAL, 0, &quot;A&quot; + container.getContainerName());
532     }
533 
534     /**
535      * Creates a global GOT symbol of the form {@code &quot;got.&quot; + name}.
536      *
537      * @param name name for the GOT symbol
538      */
539     private void createGotSymbol(String name) {
540         String s = &quot;got.&quot; + name;
541         Symbol gotSymbol = extLinkageGOTContainer.createGotSymbol(s);
542         extLinkageGOTContainer.createSymbol(gotSymbol.getOffset(), Kind.OBJECT, Binding.GLOBAL, 8, name);
543     }
544 
545     /**
546      * Create a platform-specific binary file representing the content of the
547      * {@code BinaryContainer} object.
548      *
549      * This method is called after creating and performing any necessary changes to the contents of
550      * code stream, symbol tables and relocation tables is completely finalized
551      *
552      * @param outputFileName name of output file
553      *
554      * @throws IOException in case of file creation failure
555      */
556     public void createBinary(String outputFileName) throws IOException {
557         String osName = System.getProperty(&quot;os.name&quot;);
558         switch (osName) {
559             case &quot;Linux&quot;:
560             case &quot;SunOS&quot;:
561                 JELFRelocObject elfobj = JELFRelocObject.newInstance(this, outputFileName);
562                 elfobj.createELFRelocObject(relocationTable, symbolTable.values());
563                 break;
564             case &quot;Mac OS X&quot;:
565                 JMachORelocObject machobj = new JMachORelocObject(this, outputFileName);
566                 machobj.createMachORelocObject(relocationTable, symbolTable.values());
567                 break;
568             default:
569                 if (osName.startsWith(&quot;Windows&quot;)) {
570                     JPECoffRelocObject pecoffobj = new JPECoffRelocObject(this, outputFileName);
571                     pecoffobj.createPECoffRelocObject(relocationTable, symbolTable.values());
572                     break;
573                 } else {
574                     throw new InternalError(&quot;Unsupported platform: &quot; + osName);
575                 }
576         }
577     }
578 
579     /**
580      * Add symbol to the symbol table. If the existing symbol is undefined and the specified symbol
581      * is not undefined, replace the existing symbol information with that specified.
582      *
583      * @param symInfo symbol information to be added
584      */
585     @Override
586     public void addSymbol(Symbol symInfo) {
587         if (symInfo.getName().startsWith(&quot;got.&quot;) &amp;&amp; !(symInfo instanceof GotSymbol)) {
588             throw new InternalError(&quot;adding got. without being GotSymbol&quot;);
589         }
590         if (symbolTable.containsKey(symInfo.getName())) {
591             throw new InternalError(&quot;Symbol: &quot; + symInfo.getName() + &quot; already exists in SymbolTable&quot;);
592         } else {
593             // System.out.println(&quot;# Symbol [&quot; + name + &quot;] [&quot; + symInfo.getValue() + &quot;] [&quot; +
594             // symInfo.getSection().getContainerName() + &quot;] [&quot; + symInfo.getSize() + &quot;]&quot;);
595             symbolTable.put(symInfo.getName(), symInfo);
596         }
597     }
598 
599     public boolean addStringOffset(String name, Integer offset) {
600         offsetStringTable.put(name, offset);
601         return true;
602     }
603 
604     /**
605      * Add relocation entry for {@code symName}. Multiple relocation entries for a given symbol may
606      * exist.
607      *
608      * @param info relocation information to be added
609      */
610     public void addRelocation(Relocation info) {
611         // System.out.println(&quot;# Relocation [&quot; + info.getSymbol() + &quot;] [&quot; + info.getOffset() + &quot;] [&quot;
612         // +
613         // info.getSection().getContainerName() + &quot;] [&quot; + info.getSymbol().getName() + &quot;] [&quot; +
614         // info.getSymbol().getOffset() + &quot; @ &quot; + info.getSymbol().getSection().getContainerName() +
615         // &quot;]&quot;);
616         if (relocationTable.containsKey(info.getSymbol())) {
617             relocationTable.get(info.getSymbol()).add(info);
618         } else if (uniqueRelocationTable.containsKey(info.getSymbol())) {
619             // promote
620             ArrayList&lt;Relocation&gt; list = new ArrayList&lt;&gt;(2);
621             list.add(uniqueRelocationTable.get(info.getSymbol()));
622             list.add(info);
623             relocationTable.put(info.getSymbol(), list);
624             uniqueRelocationTable.remove(info.getSymbol());
625         } else {
626             uniqueRelocationTable.put(info.getSymbol(), info);
627         }
628     }
629 
630     /**
631      * Get symbol with name {@code symName}.
632      *
633      * @param symName name of symbol for which symbol table information is being queried
634      * @return success or failure of insertion operation
635      */
636     @Override
637     public Symbol getSymbol(String symName) {
638         return symbolTable.get(symName);
639     }
640 
641     @Override
642     public Symbol createSymbol(int offset, Kind kind, Binding binding, int size, String name) {
643         if (kind != Kind.NATIVE_FUNCTION) {
644             throw new UnsupportedOperationException(&quot;Must be external functions: &quot; + name);
645         }
646         Symbol symbol = new Symbol(offset, kind, binding, null, size, name);
647         addSymbol(symbol);
648         return symbol;
649     }
650 
651     /**
652      * Get offset in got section with name {@code symName}.
653      *
654      * @param name for which String table information is being queried
655      * @return success or failure of insertion operation
656      */
657     public Integer getStringOffset(String name) {
658         return offsetStringTable.get(name);
659     }
660 
661     /**
662      * Insert {@code targetCode} to code stream with {@code size} at {@code offset}.
663      *
664      * @param targetCode byte array of native code
665      * @param offset offset at which {@code targetCode} is to be inserted
666      * @param size size of {@code targetCode}
667      */
668     private static void appendBytes(ByteContainer byteContainer, byte[] targetCode, int offset, int size) {
669         byteContainer.appendBytes(targetCode, offset, size);
670     }
671 
672     public void appendCodeBytes(byte[] targetCode, int offset, int size) {
673         appendBytes(codeContainer, targetCode, offset, size);
674     }
675 
676     public void appendIntToCode(int value) {
677         codeContainer.appendInt(value);
678     }
679 
680     public int appendExtLinkageGotBytes(byte[] bytes, int offset, int size) {
681         int startOffset = extLinkageGOTContainer.getByteStreamSize();
682         appendBytes(extLinkageGOTContainer, bytes, offset, size);
683         return startOffset;
684     }
685 
686     public void addMetadataGotEntry(int offset) {
687         metadataGotContainer.appendLong(offset);
688     }
689 
690     public int addMetaspaceName(String name) {
691         Integer value = metaspaceNames.get(name);
692         if (value != null) {
693             return value.intValue();
694         }
695         // Get the current length of the stubsNameContainer
696         // align on 8-byte boundary
697         int nameOffset = alignUp(metaspaceNamesContainer, 8);
698 
699         try {
700             // Add the name of the symbol to the .stubs.names section
701             // Modify them to sequence of utf8 strings with length:
702             // &quot;&lt;u2_size&gt;Ljava/lang/ThreadGroup;&lt;u2_size&gt;addUnstarted&lt;u2_size&gt;()V&quot;
703             ByteArrayOutputStream bout = new ByteArrayOutputStream();
704             DataOutputStream out = new DataOutputStream(bout);
705             int len = name.length();
706             if (name.startsWith(&quot;Stub&quot;)) { // Stub
707                 out.writeUTF(name);
708             } else { // Method or Klass
709                 int parenthesesIndex = name.lastIndexOf(&#39;(&#39;, len - 1);
710                 if (parenthesesIndex &gt; 0) {  // Method name
711                     int dotIndex = name.lastIndexOf(&#39;.&#39;, parenthesesIndex - 1);
712                     assert dotIndex &gt; 0 : &quot;method&#39;s full name should have &#39;.&#39; : &quot; + name;
713                     String klassName = name.substring(0, dotIndex);
714                     out.writeUTF(klassName);
715                     String methodName = name.substring(dotIndex + 1, parenthesesIndex);
716                     out.writeUTF(methodName);
717                     String signature = name.substring(parenthesesIndex, len);
718                     out.writeUTF(signature);
719                 } else {
720                     out.writeUTF(name); // Klass
721                 }
722             }
723             out.writeShort(0); // Terminate by 0.
724             byte[] b = bout.toByteArray();
725             metaspaceNamesContainer.appendBytes(b, 0, b.length);
726 
727             metaspaceNames.put(name, nameOffset);
728             return nameOffset;
729         } catch (IOException e) {
730             throw new InternalError(&quot;Failed to append bytes to stubs sections&quot;, e);
731         }
732     }
733 
734     /**
735      * Add oop symbol by as follows. Extend the oop.got section with another slot for the VM to
736      * patch.
737      *
738      * @param oopName name of the oop symbol
739      */
740     public Integer addOopSymbol(String oopName) {
741         Integer oopGotOffset = getStringOffset(oopName);
742         if (oopGotOffset != null) {
743             return oopGotOffset;
744         }
745         return newOopSymbol(oopName);
746     }
747 
748     private Integer newOopSymbol(String oopName) {
749         // Reference to String resolution (ldc).
750         int offset = oopGotContainer.getByteStreamSize();
751         String gotName = &quot;got.ldc.&quot; + offset;
752         Symbol relocationSymbol = oopGotContainer.createGotSymbol(gotName);
753 
754         if (offset != relocationSymbol.getOffset()) {
755             throw new InternalError(&quot;offset must equal! (&quot; + offset + &quot; vs &quot; + relocationSymbol.getOffset());
756         }
757 
758         addStringOffset(oopName, relocationSymbol.getOffset());
759         return relocationSymbol.getOffset();
760     }
761 
762     public int addCountersSymbol(String metaspaceName) {
763         String gotName = &quot;got.&quot; + metaspaceName;
764         Symbol relocationSymbol = getGotSymbol(gotName);
765         int metaspaceOffset = -1;
766         if (relocationSymbol == null) {
767             // Add slots when asked in the .metaspace.got section:
768             countersGotContainer.createGotSymbol(gotName);
769         }
770         return metaspaceOffset;
771     }
772 
773     public Symbol getGotSymbol(String name) {
774         assert name.startsWith(&quot;got.&quot;);
775         return symbolTable.get(name);
776     }
777 
778     /**
779      * Add klass symbol by as follows. - Adding the symbol name to the metaspace.names section - Add
780      * the offset of the name in metaspace.names to metaspace.offsets - Extend the klasses.got
781      * section with another slot for the VM to patch
782      *
783      * @param klassName name of the metaspace symbol
784      * @return the got offset in the klasses.got of the metaspace symbol
785      */
786     public int addTwoSlotKlassSymbol(String klassName) {
787         String gotName = &quot;got.&quot; + klassName;
788         Symbol previous = getGotSymbol(gotName);
789         assert previous == null : &quot;should be called only once for: &quot; + klassName;
790         // Add slots when asked in the .metaspace.got section:
791         // First slot
792         String gotInitName = &quot;got.init.&quot; + klassName;
793         GotSymbol slot1Symbol = klassesGotContainer.createGotSymbol(gotInitName);
794         GotSymbol slot2Symbol = klassesGotContainer.createGotSymbol(gotName);
795 
796         slot1Symbol.getIndex(); // check alignment and ignore result
797         // Get the index (offset/8) to the got in the .metaspace.got section
798         return slot2Symbol.getIndex();
799     }
800 
801     public static int addMethodsCount(int count, ReadOnlyDataContainer container) {
802         return appendInt(count, container);
803     }
804 
805     private static int appendInt(int count, ReadOnlyDataContainer container) {
806         int offset = container.getByteStreamSize();
807         container.appendInt(count);
808         return offset;
809     }
810 
811     /**
812      * Add constant data as follows. - Adding the data to the meth.constdata section
813      *
814      * @param data
815      * @param alignment
816      * @return the offset in the meth.constdata of the data
817      */
818     public int addConstantData(byte[] data, int alignment) {
819         // Get the current length of the metaspaceNameContainer
820         int constantDataOffset = alignUp(constantDataContainer, alignment);
821         constantDataContainer.appendBytes(data, 0, data.length);
822         alignUp(constantDataContainer, alignment); // Post alignment
823         return constantDataOffset;
824     }
825 
826     public static int alignUp(ByteContainer container, int alignment) {
827         if (Integer.bitCount(alignment) != 1) {
828             throw new IllegalArgumentException(&quot;Must be a power of 2&quot;);
829         }
830         int offset = container.getByteStreamSize();
831         int aligned = (offset + (alignment - 1)) &amp; -alignment;
832         if (aligned &lt; offset || (aligned &amp; (alignment - 1)) != 0) {
833             throw new RuntimeException(&quot;Error aligning: &quot; + offset + &quot; -&gt; &quot; + aligned);
834         }
835         if (aligned != offset) {
836             int nullArraySz = aligned - offset;
837             byte[] nullArray = new byte[nullArraySz];
838             container.appendBytes(nullArray, 0, nullArraySz);
839             offset = aligned;
840         }
841         return offset;
842     }
843 
844     public void addCodeSegments(int start, int end) {
845         assert (start % codeSegmentSize) == 0 : &quot;not aligned code&quot;;
846         int currentOffset = codeSegmentsContainer.getByteStreamSize();
847         int offset = start / codeSegmentSize;
848         int emptySize = offset - currentOffset;
849         // add empty segments if needed
850         if (emptySize &gt; 0) {
851             byte[] emptyArray = new byte[emptySize];
852             for (int i = 0; i &lt; emptySize; i++) {
853                 emptyArray[i] = (byte) 0xff;
854             }
855             appendBytes(codeSegmentsContainer, emptyArray, 0, emptySize);
856         }
857         int alignedEnd = (end + (codeSegmentSize - 1)) &amp; -codeSegmentSize;
858         int segmentsCount = (alignedEnd / codeSegmentSize) - offset;
859         byte[] segments = new byte[segmentsCount];
860         int idx = 0;
861         for (int i = 0; i &lt; segmentsCount; i++) {
862             segments[i] = (byte) idx;
863             idx = (idx == 0xfe) ? 1 : (idx + 1);
864         }
865         appendBytes(codeSegmentsContainer, segments, 0, segmentsCount);
866     }
867 
868     public ByteContainer getExtLinkageGOTContainer() {
869         return extLinkageGOTContainer;
870     }
871 
872     public ReadOnlyDataContainer getMethodMetadataContainer() {
873         return methodMetadataContainer;
874     }
875 
876     public ReadOnlyDataContainer getMetaspaceNamesContainer() {
877         return metaspaceNamesContainer;
878     }
879 
880     public ReadOnlyDataContainer getMethodsOffsetsContainer() {
881         return methodsOffsetsContainer;
882     }
883 
884     public ReadOnlyDataContainer getKlassesOffsetsContainer() {
885         return klassesOffsetsContainer;
886     }
887 
888     public ReadOnlyDataContainer getKlassesDependenciesContainer() {
889         return klassesDependenciesContainer;
890     }
891 
892     public ReadOnlyDataContainer getStubsOffsetsContainer() {
893         return stubsOffsetsContainer;
894     }
895 
896     public ReadOnlyDataContainer getCodeSegmentsContainer() {
897         return codeSegmentsContainer;
898     }
899 
900     public ReadOnlyDataContainer getConstantDataContainer() {
901         return constantDataContainer;
902     }
903 
904     public ByteContainer getKlassesGotContainer() {
905         return klassesGotContainer;
906     }
907 
908     public ByteContainer getCountersGotContainer() {
909         return countersGotContainer;
910     }
911 
912     public ByteContainer getMetadataGotContainer() {
913         return metadataGotContainer;
914     }
915 
916     public ByteContainer getMethodStateContainer() {
917         return methodStateContainer;
918     }
919 
920     public ByteContainer getOopGotContainer() {
921         return oopGotContainer;
922     }
923 
924     public CodeContainer getCodeContainer() {
925         return codeContainer;
926     }
927 
928     public ReadOnlyDataContainer getConfigContainer() {
929         return configContainer;
930     }
931 
932     public Map&lt;Symbol, Relocation&gt; getUniqueRelocationTable() {
933         return uniqueRelocationTable;
934     }
935 
936     public HeaderContainer getHeaderContainer() {
937         return headerContainer;
938     }
939 
940 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/launcher/LauncherHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.launcher;
  27 
  28 /*
  29  *
  30  *  &lt;p&gt;&lt;b&gt;This is NOT part of any API supported by Sun Microsystems.
  31  *  If you write code that depends on this, you do so at your own
  32  *  risk.  This code and its internal interfaces are subject to change
  33  *  or deletion without notice.&lt;/b&gt;
  34  *
  35  */
  36 
  37 /**
  38  * A utility package for the java(1), javaw(1) launchers.
  39  * The following are helper methods that the native launcher uses
  40  * to perform checks etc. using JNI, see src/share/bin/java.c
  41  */
  42 import java.io.File;
  43 import java.io.IOException;
  44 import java.io.PrintStream;
  45 import java.io.UnsupportedEncodingException;
  46 import java.lang.module.Configuration;
  47 import java.lang.module.ModuleDescriptor;
  48 import java.lang.module.ModuleDescriptor.Requires;
  49 import java.lang.module.ModuleDescriptor.Exports;
  50 import java.lang.module.ModuleDescriptor.Opens;
  51 import java.lang.module.ModuleDescriptor.Provides;
  52 import java.lang.module.ModuleFinder;
  53 import java.lang.module.ModuleReference;
  54 import java.lang.module.ResolvedModule;
  55 import java.lang.reflect.InvocationTargetException;
  56 import java.lang.reflect.Method;
  57 import java.lang.reflect.Modifier;
  58 import java.math.BigDecimal;
  59 import java.math.RoundingMode;
  60 import java.net.URI;
  61 import java.nio.charset.Charset;
  62 import java.nio.file.DirectoryStream;
  63 import java.nio.file.Files;
  64 import java.nio.file.Path;
  65 import java.text.Normalizer;
  66 import java.text.MessageFormat;
  67 import java.util.ArrayList;
  68 import java.util.Collections;
  69 import java.util.Comparator;
  70 import java.util.Iterator;
  71 import java.util.List;
  72 import java.util.Locale;
  73 import java.util.Locale.Category;
  74 import java.util.Optional;
  75 import java.util.Properties;
  76 import java.util.ResourceBundle;
  77 import java.util.Set;
  78 import java.util.TreeSet;
  79 import java.util.jar.Attributes;
  80 import java.util.jar.JarFile;
  81 import java.util.jar.Manifest;
  82 import java.util.stream.Collectors;
  83 import java.util.stream.Stream;
  84 
  85 import jdk.internal.misc.VM;
  86 import jdk.internal.module.ModuleBootstrap;
  87 import jdk.internal.module.Modules;
  88 import jdk.internal.platform.Container;
  89 import jdk.internal.platform.Metrics;
  90 
  91 
  92 public final class LauncherHelper {
  93 
  94     // No instantiation
  95     private LauncherHelper() {}
  96 
  97     // used to identify JavaFX applications
  98     private static final String JAVAFX_APPLICATION_MARKER =
  99             &quot;JavaFX-Application-Class&quot;;
 100     private static final String JAVAFX_APPLICATION_CLASS_NAME =
 101             &quot;javafx.application.Application&quot;;
 102     private static final String JAVAFX_FXHELPER_CLASS_NAME_SUFFIX =
 103             &quot;sun.launcher.LauncherHelper$FXHelper&quot;;
 104     private static final String LAUNCHER_AGENT_CLASS = &quot;Launcher-Agent-Class&quot;;
 105     private static final String MAIN_CLASS = &quot;Main-Class&quot;;
 106     private static final String ADD_EXPORTS = &quot;Add-Exports&quot;;
 107     private static final String ADD_OPENS = &quot;Add-Opens&quot;;
 108 
 109     private static StringBuilder outBuf = new StringBuilder();
 110 
 111     private static final String INDENT = &quot;    &quot;;
 112     private static final String VM_SETTINGS     = &quot;VM settings:&quot;;
 113     private static final String PROP_SETTINGS   = &quot;Property settings:&quot;;
 114     private static final String LOCALE_SETTINGS = &quot;Locale settings:&quot;;
 115 
 116     // sync with java.c and jdk.internal.misc.VM
 117     private static final String diagprop = &quot;sun.java.launcher.diag&quot;;
 118     static final boolean trace = VM.getSavedProperty(diagprop) != null;
 119 
 120     private static final String defaultBundleName =
 121             &quot;sun.launcher.resources.launcher&quot;;
 122     private static class ResourceBundleHolder {
 123         private static final ResourceBundle RB =
 124                 ResourceBundle.getBundle(defaultBundleName);
 125     }
 126     private static PrintStream ostream;
 127     private static Class&lt;?&gt; appClass; // application class, for GUI/reporting purposes
 128 
 129     /*
 130      * A method called by the launcher to print out the standard settings,
 131      * by default -XshowSettings is equivalent to -XshowSettings:all,
 132      * Specific information may be gotten by using suboptions with possible
 133      * values vm, properties and locale.
 134      *
 135      * printToStderr: choose between stdout and stderr
 136      *
 137      * optionFlag: specifies which options to print default is all other
 138      *    possible values are vm, properties, locale.
 139      *
 140      * initialHeapSize: in bytes, as set by the launcher, a zero-value indicates
 141      *    this code should determine this value, using a suitable method or
 142      *    the line could be omitted.
 143      *
 144      * maxHeapSize: in bytes, as set by the launcher, a zero-value indicates
 145      *    this code should determine this value, using a suitable method.
 146      *
 147      * stackSize: in bytes, as set by the launcher, a zero-value indicates
 148      *    this code determine this value, using a suitable method or omit the
 149      *    line entirely.
 150      */
 151     @SuppressWarnings(&quot;fallthrough&quot;)
 152     static void showSettings(boolean printToStderr, String optionFlag,
 153             long initialHeapSize, long maxHeapSize, long stackSize) {
 154 
 155         initOutput(printToStderr);
 156         String opts[] = optionFlag.split(&quot;:&quot;);
 157         String optStr = (opts.length &gt; 1 &amp;&amp; opts[1] != null)
 158                 ? opts[1].trim()
 159                 : &quot;all&quot;;
 160         switch (optStr) {
 161             case &quot;vm&quot;:
 162                 printVmSettings(initialHeapSize, maxHeapSize, stackSize);
 163                 break;
 164             case &quot;properties&quot;:
 165                 printProperties();
 166                 break;
 167             case &quot;locale&quot;:
 168                 printLocale();
 169                 break;
 170             case &quot;system&quot;:
 171                 if (System.getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;)) {
 172                     printSystemMetrics();
 173                     break;
 174                 }
 175             default:
 176                 printVmSettings(initialHeapSize, maxHeapSize, stackSize);
 177                 printProperties();
 178                 printLocale();
 179                 if (System.getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;)) {
 180                     printSystemMetrics();
 181                 }
 182                 break;
 183         }
 184     }
 185 
 186     /*
 187      * prints the main vm settings subopt/section
 188      */
 189     private static void printVmSettings(
 190             long initialHeapSize, long maxHeapSize,
 191             long stackSize) {
 192 
 193         ostream.println(VM_SETTINGS);
 194         if (stackSize != 0L) {
 195             ostream.println(INDENT + &quot;Stack Size: &quot; +
 196                     SizePrefix.scaleValue(stackSize));
 197         }
 198         if (initialHeapSize != 0L) {
 199              ostream.println(INDENT + &quot;Min. Heap Size: &quot; +
 200                     SizePrefix.scaleValue(initialHeapSize));
 201         }
 202         if (maxHeapSize != 0L) {
 203             ostream.println(INDENT + &quot;Max. Heap Size: &quot; +
 204                     SizePrefix.scaleValue(maxHeapSize));
 205         } else {
 206             ostream.println(INDENT + &quot;Max. Heap Size (Estimated): &quot;
 207                     + SizePrefix.scaleValue(Runtime.getRuntime().maxMemory()));
 208         }
 209         ostream.println(INDENT + &quot;Using VM: &quot;
 210                 + System.getProperty(&quot;java.vm.name&quot;));
 211         ostream.println();
 212     }
 213 
 214     /*
 215      * prints the properties subopt/section
 216      */
 217     private static void printProperties() {
 218         Properties p = System.getProperties();
 219         ostream.println(PROP_SETTINGS);
 220         List&lt;String&gt; sortedPropertyKeys = new ArrayList&lt;&gt;();
 221         sortedPropertyKeys.addAll(p.stringPropertyNames());
 222         Collections.sort(sortedPropertyKeys);
 223         for (String x : sortedPropertyKeys) {
 224             printPropertyValue(x, p.getProperty(x));
 225         }
 226         ostream.println();
 227     }
 228 
 229     private static boolean isPath(String key) {
 230         return key.endsWith(&quot;.dirs&quot;) || key.endsWith(&quot;.path&quot;);
 231     }
 232 
 233     private static void printPropertyValue(String key, String value) {
 234         ostream.print(INDENT + key + &quot; = &quot;);
 235         if (key.equals(&quot;line.separator&quot;)) {
 236             for (byte b : value.getBytes()) {
 237                 switch (b) {
 238                     case 0xd:
 239                         ostream.print(&quot;\\r &quot;);
 240                         break;
 241                     case 0xa:
 242                         ostream.print(&quot;\\n &quot;);
 243                         break;
 244                     default:
 245                         // print any bizzare line separators in hex, but really
 246                         // shouldn&#39;t happen.
 247                         ostream.printf(&quot;0x%02X&quot;, b &amp; 0xff);
 248                         break;
 249                 }
 250             }
 251             ostream.println();
 252             return;
 253         }
 254         if (!isPath(key)) {
 255             ostream.println(value);
 256             return;
 257         }
 258         String[] values = value.split(System.getProperty(&quot;path.separator&quot;));
 259         boolean first = true;
 260         for (String s : values) {
 261             if (first) { // first line treated specially
 262                 ostream.println(s);
 263                 first = false;
 264             } else { // following lines prefix with indents
 265                 ostream.println(INDENT + INDENT + s);
 266             }
 267         }
 268     }
 269 
 270     /*
 271      * prints the locale subopt/section
 272      */
 273     private static void printLocale() {
 274         Locale locale = Locale.getDefault();
 275         ostream.println(LOCALE_SETTINGS);
 276         ostream.println(INDENT + &quot;default locale = &quot; +
 277                 locale.getDisplayName());
 278         ostream.println(INDENT + &quot;default display locale = &quot; +
 279                 Locale.getDefault(Category.DISPLAY).getDisplayName());
 280         ostream.println(INDENT + &quot;default format locale = &quot; +
 281                 Locale.getDefault(Category.FORMAT).getDisplayName());
 282         printLocales();
 283         ostream.println();
 284     }
 285 
 286     private static void printLocales() {
 287         Locale[] tlocales = Locale.getAvailableLocales();
 288         final int len = tlocales == null ? 0 : tlocales.length;
 289         if (len &lt; 1 ) {
 290             return;
 291         }
 292         // Locale does not implement Comparable so we convert it to String
 293         // and sort it for pretty printing.
 294         Set&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();
 295         for (Locale l : tlocales) {
 296             sortedSet.add(l.toString());
 297         }
 298 
 299         ostream.print(INDENT + &quot;available locales = &quot;);
 300         Iterator&lt;String&gt; iter = sortedSet.iterator();
 301         final int last = len - 1;
 302         for (int i = 0 ; iter.hasNext() ; i++) {
 303             String s = iter.next();
 304             ostream.print(s);
 305             if (i != last) {
 306                 ostream.print(&quot;, &quot;);
 307             }
 308             // print columns of 8
 309             if ((i + 1) % 8 == 0) {
 310                 ostream.println();
 311                 ostream.print(INDENT + INDENT);
 312             }
 313         }
 314     }
 315 
 316     public static void printSystemMetrics() {
 317         Metrics c = Container.metrics();
 318 
 319         ostream.println(&quot;Operating System Metrics:&quot;);
 320 
 321         if (c == null) {
 322             ostream.println(INDENT + &quot;No metrics available for this platform&quot;);
 323             return;
 324         }
 325 
 326         ostream.println(INDENT + &quot;Provider: &quot; + c.getProvider());
 327         ostream.println(INDENT + &quot;Effective CPU Count: &quot; + c.getEffectiveCpuCount());
 328         ostream.println(INDENT + &quot;CPU Period: &quot; + c.getCpuPeriod() +
 329                (c.getCpuPeriod() == -1 ? &quot;&quot; : &quot;us&quot;));
 330         ostream.println(INDENT + &quot;CPU Quota: &quot; + c.getCpuQuota() +
 331                (c.getCpuQuota() == -1 ? &quot;&quot; : &quot;us&quot;));
 332         ostream.println(INDENT + &quot;CPU Shares: &quot; + c.getCpuShares());
 333 
 334         int cpus[] = c.getCpuSetCpus();
 335         ostream.println(INDENT + &quot;List of Processors, &quot;
 336                 + cpus.length + &quot; total: &quot;);
 337 
 338         ostream.print(INDENT);
 339         for (int i = 0; i &lt; cpus.length; i++) {
 340             ostream.print(cpus[i] + &quot; &quot;);
 341         }
 342         if (cpus.length &gt; 0) {
 343             ostream.println(&quot;&quot;);
 344         }
 345 
 346         cpus = c.getEffectiveCpuSetCpus();
 347         ostream.println(INDENT + &quot;List of Effective Processors, &quot;
 348                 + cpus.length + &quot; total: &quot;);
 349 
 350         ostream.print(INDENT);
 351         for (int i = 0; i &lt; cpus.length; i++) {
 352             ostream.print(cpus[i] + &quot; &quot;);
 353         }
 354         if (cpus.length &gt; 0) {
 355             ostream.println(&quot;&quot;);
 356         }
 357 
 358         int mems[] = c.getCpuSetMems();
 359         ostream.println(INDENT + &quot;List of Memory Nodes, &quot;
 360                 + mems.length + &quot; total: &quot;);
 361 
 362         ostream.print(INDENT);
 363         for (int i = 0; i &lt; mems.length; i++) {
 364             ostream.print(mems[i] + &quot; &quot;);
 365         }
 366         if (mems.length &gt; 0) {
 367             ostream.println(&quot;&quot;);
 368         }
 369 
 370         mems = c.getEffectiveCpuSetMems();
 371         ostream.println(INDENT + &quot;List of Available Memory Nodes, &quot;
 372                 + mems.length + &quot; total: &quot;);
 373 
 374         ostream.print(INDENT);
 375         for (int i = 0; i &lt; mems.length; i++) {
 376             ostream.print(mems[i] + &quot; &quot;);
 377         }
 378         if (mems.length &gt; 0) {
 379             ostream.println(&quot;&quot;);
 380         }
 381 
 382         ostream.println(INDENT + &quot;CPUSet Memory Pressure Enabled: &quot;
 383                 + c.isCpuSetMemoryPressureEnabled());
 384 
 385         long limit = c.getMemoryLimit();
 386         ostream.println(INDENT + &quot;Memory Limit: &quot; +
 387                 ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
 388 
 389         limit = c.getMemorySoftLimit();
 390         ostream.println(INDENT + &quot;Memory Soft Limit: &quot; +
 391                 ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
 392 
 393         limit = c.getMemoryAndSwapLimit();
 394         ostream.println(INDENT + &quot;Memory &amp; Swap Limit: &quot; +
 395                 ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
 396 
 397         limit = c.getKernelMemoryLimit();
 398         ostream.println(INDENT + &quot;Kernel Memory Limit: &quot; +
 399                 ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
 400 
 401         limit = c.getTcpMemoryLimit();
 402         ostream.println(INDENT + &quot;TCP Memory Limit: &quot; +
 403                 ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
 404 
 405         ostream.println(INDENT + &quot;Out Of Memory Killer Enabled: &quot;
 406                 + c.isMemoryOOMKillEnabled());
 407 
 408         ostream.println(&quot;&quot;);
 409     }
 410 
 411     private enum SizePrefix {
 412 
 413         KILO(1024, &quot;K&quot;),
 414         MEGA(1024 * 1024, &quot;M&quot;),
 415         GIGA(1024 * 1024 * 1024, &quot;G&quot;),
 416         TERA(1024L * 1024L * 1024L * 1024L, &quot;T&quot;);
 417         long size;
 418         String abbrev;
 419 
 420         SizePrefix(long size, String abbrev) {
 421             this.size = size;
 422             this.abbrev = abbrev;
 423         }
 424 
 425         private static String scale(long v, SizePrefix prefix) {
 426             return BigDecimal.valueOf(v).divide(BigDecimal.valueOf(prefix.size),
 427                     2, RoundingMode.HALF_EVEN).toPlainString() + prefix.abbrev;
 428         }
 429         /*
 430          * scale the incoming values to a human readable form, represented as
 431          * K, M, G and T, see java.c parse_size for the scaled values and
 432          * suffixes. The lowest possible scaled value is Kilo.
 433          */
 434         static String scaleValue(long v) {
 435             if (v &lt; MEGA.size) {
 436                 return scale(v, KILO);
 437             } else if (v &lt; GIGA.size) {
 438                 return scale(v, MEGA);
 439             } else if (v &lt; TERA.size) {
 440                 return scale(v, GIGA);
 441             } else {
 442                 return scale(v, TERA);
 443             }
 444         }
 445     }
 446 
 447     /**
 448      * A private helper method to get a localized message and also
 449      * apply any arguments that we might pass.
 450      */
 451     private static String getLocalizedMessage(String key, Object... args) {
 452         String msg = ResourceBundleHolder.RB.getString(key);
 453         return (args != null) ? MessageFormat.format(msg, args) : msg;
 454     }
 455 
 456     /**
 457      * The java -help message is split into 3 parts, an invariant, followed
 458      * by a set of platform dependent variant messages, finally an invariant
 459      * set of lines.
 460      * This method initializes the help message for the first time, and also
 461      * assembles the invariant header part of the message.
 462      */
 463     static void initHelpMessage(String progname) {
 464         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.header&quot;,
 465                 (progname == null) ? &quot;java&quot; : progname ));
 466     }
 467 
 468     /**
 469      * Appends the vm selection messages to the header, already created.
 470      * initHelpSystem must already be called.
 471      */
 472     static void appendVmSelectMessage(String vm1, String vm2) {
 473         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.vmselect&quot;,
 474                 vm1, vm2));
 475     }
 476 
 477     /**
 478      * Appends the vm synoym message to the header, already created.
 479      * initHelpSystem must be called before using this method.
 480      */
 481     static void appendVmSynonymMessage(String vm1, String vm2) {
 482         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.hotspot&quot;,
 483                 vm1, vm2));
 484     }
 485 
 486     /**
 487      * Appends the last invariant part to the previously created messages,
 488      * and finishes up the printing to the desired output stream.
 489      * initHelpSystem must be called before using this method.
 490      */
 491     static void printHelpMessage(boolean printToStderr) {
 492         initOutput(printToStderr);
 493         outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.footer&quot;,
 494                 File.pathSeparator));
 495         ostream.println(outBuf.toString());
 496     }
 497 
 498     /**
 499      * Prints the Xusage text to the desired output stream.
 500      */
 501     static void printXUsageMessage(boolean printToStderr) {
 502         initOutput(printToStderr);
 503         ostream.println(getLocalizedMessage(&quot;java.launcher.X.usage&quot;,
 504                 File.pathSeparator));
 505         if (System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;)) {
 506             ostream.println(getLocalizedMessage(&quot;java.launcher.X.macosx.usage&quot;,
 507                         File.pathSeparator));
 508         }
 509     }
 510 
 511     static void initOutput(boolean printToStderr) {
 512         ostream =  (printToStderr) ? System.err : System.out;
 513     }
 514 
 515     static void initOutput(PrintStream ps) {
 516         ostream = ps;
 517     }
 518 
 519     static String getMainClassFromJar(String jarname) {
 520         String mainValue;
 521         try (JarFile jarFile = new JarFile(jarname)) {
 522             Manifest manifest = jarFile.getManifest();
 523             if (manifest == null) {
 524                 abort(null, &quot;java.launcher.jar.error2&quot;, jarname);
 525             }
 526             Attributes mainAttrs = manifest.getMainAttributes();
 527             if (mainAttrs == null) {
 528                 abort(null, &quot;java.launcher.jar.error3&quot;, jarname);
 529             }
 530 
 531             // Main-Class
 532             mainValue = mainAttrs.getValue(MAIN_CLASS);
 533             if (mainValue == null) {
 534                 abort(null, &quot;java.launcher.jar.error3&quot;, jarname);
 535             }
 536 
 537             // Launcher-Agent-Class (only check for this when Main-Class present)
 538             String agentClass = mainAttrs.getValue(LAUNCHER_AGENT_CLASS);
 539             if (agentClass != null) {
 540                 ModuleLayer.boot().findModule(&quot;java.instrument&quot;).ifPresent(m -&gt; {
 541                     try {
 542                         String cn = &quot;sun.instrument.InstrumentationImpl&quot;;
 543                         Class&lt;?&gt; clazz = Class.forName(cn, false, null);
 544                         Method loadAgent = clazz.getMethod(&quot;loadAgent&quot;, String.class);
 545                         loadAgent.invoke(null, jarname);
 546                     } catch (Throwable e) {
 547                         if (e instanceof InvocationTargetException) e = e.getCause();
 548                         abort(e, &quot;java.launcher.jar.error4&quot;, jarname);
 549                     }
 550                 });
 551             }
 552 
 553             // Add-Exports and Add-Opens
 554             String exports = mainAttrs.getValue(ADD_EXPORTS);
 555             if (exports != null) {
 556                 addExportsOrOpens(exports, false);
 557             }
 558             String opens = mainAttrs.getValue(ADD_OPENS);
 559             if (opens != null) {
 560                 addExportsOrOpens(opens, true);
 561             }
 562 
 563             /*
 564              * Hand off to FXHelper if it detects a JavaFX application
 565              * This must be done after ensuring a Main-Class entry
 566              * exists to enforce compliance with the jar specification
 567              */
 568             if (mainAttrs.containsKey(
 569                     new Attributes.Name(JAVAFX_APPLICATION_MARKER))) {
 570                 FXHelper.setFXLaunchParameters(jarname, LM_JAR);
 571                 return FXHelper.class.getName();
 572             }
 573 
 574             return mainValue.trim();
 575         } catch (IOException ioe) {
 576             abort(ioe, &quot;java.launcher.jar.error1&quot;, jarname);
 577         }
 578         return null;
 579     }
 580 
 581     /**
 582      * Process the Add-Exports or Add-Opens value. The value is
 583      * {@code &lt;module&gt;/&lt;package&gt; ( &lt;module&gt;/&lt;package&gt;)*}.
 584      */
 585     static void addExportsOrOpens(String value, boolean open) {
 586         for (String moduleAndPackage : value.split(&quot; &quot;)) {
 587             String[] s = moduleAndPackage.trim().split(&quot;/&quot;);
 588             if (s.length == 2) {
 589                 String mn = s[0];
 590                 String pn = s[1];
 591                 ModuleLayer.boot()
 592                     .findModule(mn)
 593                     .filter(m -&gt; m.getDescriptor().packages().contains(pn))
 594                     .ifPresent(m -&gt; {
 595                         if (open) {
 596                             Modules.addOpensToAllUnnamed(m, pn);
 597                         } else {
 598                             Modules.addExportsToAllUnnamed(m, pn);
 599                         }
 600                     });
 601             }
 602         }
 603     }
 604 
 605     // From src/share/bin/java.c:
 606     //   enum LaunchMode { LM_UNKNOWN = 0, LM_CLASS, LM_JAR, LM_MODULE, LM_SOURCE }
 607 
 608     private static final int LM_UNKNOWN = 0;
 609     private static final int LM_CLASS   = 1;
 610     private static final int LM_JAR     = 2;
 611     private static final int LM_MODULE  = 3;
 612     private static final int LM_SOURCE  = 4;
 613 
 614     static void abort(Throwable t, String msgKey, Object... args) {
 615         if (msgKey != null) {
 616             ostream.println(getLocalizedMessage(msgKey, args));
 617         }
 618         if (trace) {
 619             if (t != null) {
 620                 t.printStackTrace();
 621             } else {
 622                 Thread.dumpStack();
 623             }
 624         }
 625         System.exit(1);
 626     }
 627 
 628     /**
 629      * This method:
 630      * 1. Loads the main class from the module or class path
 631      * 2. Checks the public static void main method.
 632      * 3. If the main class extends FX Application then call on FXHelper to
 633      * perform the launch.
 634      *
 635      * @param printToStderr if set, all output will be routed to stderr
 636      * @param mode LaunchMode as determined by the arguments passed on the
 637      *             command line
 638      * @param what the module name[/class], JAR file, or the main class
 639      *             depending on the mode
 640      *
 641      * @return the application&#39;s main class
 642      */
 643     @SuppressWarnings(&quot;fallthrough&quot;)
 644     public static Class&lt;?&gt; checkAndLoadMain(boolean printToStderr,
 645                                             int mode,
 646                                             String what) {
 647         initOutput(printToStderr);
 648 
 649         Class&lt;?&gt; mainClass = null;
 650         switch (mode) {
 651             case LM_MODULE: case LM_SOURCE:
 652                 mainClass = loadModuleMainClass(what);
 653                 break;
 654             default:
 655                 mainClass = loadMainClass(mode, what);
 656                 break;
 657         }
 658 
 659         // record the real main class for UI purposes
 660         // neither method above can return null, they will abort()
 661         appClass = mainClass;
 662 
 663         /*
 664          * Check if FXHelper can launch it using the FX launcher. In an FX app,
 665          * the main class may or may not have a main method, so do this before
 666          * validating the main class.
 667          */
 668         if (JAVAFX_FXHELPER_CLASS_NAME_SUFFIX.equals(mainClass.getName()) ||
 669             doesExtendFXApplication(mainClass)) {
 670             // Will abort() if there are problems with FX runtime
 671             FXHelper.setFXLaunchParameters(what, mode);
 672             mainClass = FXHelper.class;
 673         }
 674 
 675         validateMainClass(mainClass);
 676         return mainClass;
 677     }
 678 
 679     /**
 680      * Returns the main class for a module. The query is either a module name
 681      * or module-name/main-class. For the former then the module&#39;s main class
 682      * is obtained from the module descriptor (MainClass attribute).
 683      */
 684     private static Class&lt;?&gt; loadModuleMainClass(String what) {
 685         int i = what.indexOf(&#39;/&#39;);
 686         String mainModule;
 687         String mainClass;
 688         if (i == -1) {
 689             mainModule = what;
 690             mainClass = null;
 691         } else {
 692             mainModule = what.substring(0, i);
 693             mainClass = what.substring(i+1);
 694         }
 695 
 696         // main module is in the boot layer
 697         ModuleLayer layer = ModuleLayer.boot();
 698         Optional&lt;Module&gt; om = layer.findModule(mainModule);
 699         if (!om.isPresent()) {
 700             // should not happen
 701             throw new InternalError(&quot;Module &quot; + mainModule + &quot; not in boot Layer&quot;);
 702         }
 703         Module m = om.get();
 704 
 705         // get main class
 706         if (mainClass == null) {
 707             Optional&lt;String&gt; omc = m.getDescriptor().mainClass();
 708             if (!omc.isPresent()) {
 709                 abort(null, &quot;java.launcher.module.error1&quot;, mainModule);
 710             }
 711             mainClass = omc.get();
 712         }
 713 
 714         // load the class from the module
 715         Class&lt;?&gt; c = null;
 716         try {
 717             c = Class.forName(m, mainClass);
 718             if (c == null &amp;&amp; System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
 719                     &amp;&amp; Normalizer.isNormalized(mainClass, Normalizer.Form.NFD)) {
 720 
 721                 String cn = Normalizer.normalize(mainClass, Normalizer.Form.NFC);
 722                 c = Class.forName(m, cn);
 723             }
 724         } catch (LinkageError le) {
 725             abort(null, &quot;java.launcher.module.error3&quot;, mainClass, m.getName(),
 726                     le.getClass().getName() + &quot;: &quot; + le.getLocalizedMessage());
 727         }
 728         if (c == null) {
 729             abort(null, &quot;java.launcher.module.error2&quot;, mainClass, mainModule);
 730         }
 731 
 732         System.setProperty(&quot;jdk.module.main.class&quot;, c.getName());
 733         return c;
 734     }
 735 
 736     /**
 737      * Loads the main class from the class path (LM_CLASS or LM_JAR).
 738      */
 739     private static Class&lt;?&gt; loadMainClass(int mode, String what) {
 740         // get the class name
 741         String cn;
 742         switch (mode) {
 743             case LM_CLASS:
 744                 cn = what;
 745                 break;
 746             case LM_JAR:
 747                 cn = getMainClassFromJar(what);
 748                 break;
 749             default:
 750                 // should never happen
 751                 throw new InternalError(&quot;&quot; + mode + &quot;: Unknown launch mode&quot;);
 752         }
 753 
 754         // load the main class
 755         cn = cn.replace(&#39;/&#39;, &#39;.&#39;);
 756         Class&lt;?&gt; mainClass = null;
 757         ClassLoader scl = ClassLoader.getSystemClassLoader();
 758         try {
 759             try {
 760                 mainClass = Class.forName(cn, false, scl);
 761             } catch (NoClassDefFoundError | ClassNotFoundException cnfe) {
 762                 if (System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
 763                         &amp;&amp; Normalizer.isNormalized(cn, Normalizer.Form.NFD)) {
 764                     try {
 765                         // On Mac OS X since all names with diacritical marks are
 766                         // given as decomposed it is possible that main class name
 767                         // comes incorrectly from the command line and we have
 768                         // to re-compose it
 769                         String ncn = Normalizer.normalize(cn, Normalizer.Form.NFC);
 770                         mainClass = Class.forName(ncn, false, scl);
 771                     } catch (NoClassDefFoundError | ClassNotFoundException cnfe1) {
 772                         abort(cnfe1, &quot;java.launcher.cls.error1&quot;, cn,
 773                                 cnfe1.getClass().getCanonicalName(), cnfe1.getMessage());
 774                     }
 775                 } else {
 776                     abort(cnfe, &quot;java.launcher.cls.error1&quot;, cn,
 777                             cnfe.getClass().getCanonicalName(), cnfe.getMessage());
 778                 }
 779             }
 780         } catch (LinkageError le) {
 781             abort(le, &quot;java.launcher.cls.error6&quot;, cn,
 782                     le.getClass().getName() + &quot;: &quot; + le.getLocalizedMessage());
 783         }
 784         return mainClass;
 785     }
 786 
 787     /*
 788      * Accessor method called by the launcher after getting the main class via
 789      * checkAndLoadMain(). The &quot;application class&quot; is the class that is finally
 790      * executed to start the application and in this case is used to report
 791      * the correct application name, typically for UI purposes.
 792      */
 793     public static Class&lt;?&gt; getApplicationClass() {
 794         return appClass;
 795     }
 796 
 797     /*
 798      * Check if the given class is a JavaFX Application class. This is done
 799      * in a way that does not cause the Application class to load or throw
 800      * ClassNotFoundException if the JavaFX runtime is not available.
 801      */
 802     private static boolean doesExtendFXApplication(Class&lt;?&gt; mainClass) {
 803         for (Class&lt;?&gt; sc = mainClass.getSuperclass(); sc != null;
 804                 sc = sc.getSuperclass()) {
 805             if (sc.getName().equals(JAVAFX_APPLICATION_CLASS_NAME)) {
 806                 return true;
 807             }
 808         }
 809         return false;
 810     }
 811 
 812     // Check the existence and signature of main and abort if incorrect
 813     static void validateMainClass(Class&lt;?&gt; mainClass) {
 814         Method mainMethod = null;
 815         try {
 816             mainMethod = mainClass.getMethod(&quot;main&quot;, String[].class);
 817         } catch (NoSuchMethodException nsme) {
 818             // invalid main or not FX application, abort with an error
 819             abort(null, &quot;java.launcher.cls.error4&quot;, mainClass.getName(),
 820                   JAVAFX_APPLICATION_CLASS_NAME);
 821         } catch (Throwable e) {
 822             if (mainClass.getModule().isNamed()) {
 823                 abort(e, &quot;java.launcher.module.error5&quot;,
 824                       mainClass.getName(), mainClass.getModule().getName(),
 825                       e.getClass().getName(), e.getLocalizedMessage());
 826             } else {
 827                 abort(e, &quot;java.launcher.cls.error7&quot;, mainClass.getName(),
 828                       e.getClass().getName(), e.getLocalizedMessage());
 829             }
 830         }
 831 
 832         /*
 833          * getMethod (above) will choose the correct method, based
 834          * on its name and parameter type, however, we still have to
 835          * ensure that the method is static and returns a void.
 836          */
 837         int mod = mainMethod.getModifiers();
 838         if (!Modifier.isStatic(mod)) {
 839             abort(null, &quot;java.launcher.cls.error2&quot;, &quot;static&quot;,
 840                   mainMethod.getDeclaringClass().getName());
 841         }
 842         if (mainMethod.getReturnType() != java.lang.Void.TYPE) {
 843             abort(null, &quot;java.launcher.cls.error3&quot;,
 844                   mainMethod.getDeclaringClass().getName());
 845         }
 846     }
 847 
 848     private static final String encprop = &quot;sun.jnu.encoding&quot;;
 849     private static String encoding = null;
 850     private static boolean isCharsetSupported = false;
 851 
 852     /*
 853      * converts a c or a byte array to a platform specific string,
 854      * previously implemented as a native method in the launcher.
 855      */
 856     static String makePlatformString(boolean printToStderr, byte[] inArray) {
 857         initOutput(printToStderr);
 858         if (encoding == null) {
 859             encoding = System.getProperty(encprop);
 860             isCharsetSupported = Charset.isSupported(encoding);
 861         }
 862         try {
 863             String out = isCharsetSupported
 864                     ? new String(inArray, encoding)
 865                     : new String(inArray);
 866             return out;
 867         } catch (UnsupportedEncodingException uee) {
 868             abort(uee, null);
 869         }
 870         return null; // keep the compiler happy
 871     }
 872 
 873     static String[] expandArgs(String[] argArray) {
 874         List&lt;StdArg&gt; aList = new ArrayList&lt;&gt;();
 875         for (String x : argArray) {
 876             aList.add(new StdArg(x));
 877         }
 878         return expandArgs(aList);
 879     }
 880 
 881     static String[] expandArgs(List&lt;StdArg&gt; argList) {
 882         ArrayList&lt;String&gt; out = new ArrayList&lt;&gt;();
 883         if (trace) {
 884             System.err.println(&quot;Incoming arguments:&quot;);
 885         }
 886         for (StdArg a : argList) {
 887             if (trace) {
 888                 System.err.println(a);
 889             }
 890             if (a.needsExpansion) {
 891                 File x = new File(a.arg);
 892                 File parent = x.getParentFile();
 893                 String glob = x.getName();
 894                 if (parent == null) {
 895                     parent = new File(&quot;.&quot;);
 896                 }
 897                 try (DirectoryStream&lt;Path&gt; dstream =
 898                         Files.newDirectoryStream(parent.toPath(), glob)) {
 899                     int entries = 0;
 900                     for (Path p : dstream) {
 901                         out.add(p.normalize().toString());
 902                         entries++;
 903                     }
 904                     if (entries == 0) {
 905                         out.add(a.arg);
 906                     }
 907                 } catch (Exception e) {
 908                     out.add(a.arg);
 909                     if (trace) {
 910                         System.err.println(&quot;Warning: passing argument as-is &quot; + a);
 911                         System.err.print(e);
 912                     }
 913                 }
 914             } else {
 915                 out.add(a.arg);
 916             }
 917         }
 918         String[] oarray = new String[out.size()];
 919         out.toArray(oarray);
 920 
 921         if (trace) {
 922             System.err.println(&quot;Expanded arguments:&quot;);
 923             for (String x : oarray) {
 924                 System.err.println(x);
 925             }
 926         }
 927         return oarray;
 928     }
 929 
 930     /* duplicate of the native StdArg struct */
 931     private static class StdArg {
 932         final String arg;
 933         final boolean needsExpansion;
 934         StdArg(String arg, boolean expand) {
 935             this.arg = arg;
 936             this.needsExpansion = expand;
 937         }
 938         // protocol: first char indicates whether expansion is required
 939         // &#39;T&#39; = true ; needs expansion
 940         // &#39;F&#39; = false; needs no expansion
 941         StdArg(String in) {
 942             this.arg = in.substring(1);
 943             needsExpansion = in.charAt(0) == &#39;T&#39;;
 944         }
 945         public String toString() {
 946             return &quot;StdArg{&quot; + &quot;arg=&quot; + arg + &quot;, needsExpansion=&quot; + needsExpansion + &#39;}&#39;;
 947         }
 948     }
 949 
 950     static final class FXHelper {
 951 
 952         private static final String JAVAFX_GRAPHICS_MODULE_NAME =
 953                 &quot;javafx.graphics&quot;;
 954 
 955         private static final String JAVAFX_LAUNCHER_CLASS_NAME =
 956                 &quot;com.sun.javafx.application.LauncherImpl&quot;;
 957 
 958         /*
 959          * The launch method used to invoke the JavaFX launcher. These must
 960          * match the strings used in the launchApplication method.
 961          *
 962          * Command line                 JavaFX-App-Class  Launch mode  FX Launch mode
 963          * java -cp fxapp.jar FXClass   N/A               LM_CLASS     &quot;LM_CLASS&quot;
 964          * java -cp somedir FXClass     N/A               LM_CLASS     &quot;LM_CLASS&quot;
 965          * java -jar fxapp.jar          Present           LM_JAR       &quot;LM_JAR&quot;
 966          * java -jar fxapp.jar          Not Present       LM_JAR       &quot;LM_JAR&quot;
 967          * java -m module/class [1]     N/A               LM_MODULE    &quot;LM_MODULE&quot;
 968          * java -m module               N/A               LM_MODULE    &quot;LM_MODULE&quot;
 969          *
 970          * [1] - JavaFX-Application-Class is ignored when modular args are used, even
 971          * if present in a modular jar
 972          */
 973         private static final String JAVAFX_LAUNCH_MODE_CLASS = &quot;LM_CLASS&quot;;
 974         private static final String JAVAFX_LAUNCH_MODE_JAR = &quot;LM_JAR&quot;;
 975         private static final String JAVAFX_LAUNCH_MODE_MODULE = &quot;LM_MODULE&quot;;
 976 
 977         /*
 978          * FX application launcher and launch method, so we can launch
 979          * applications with no main method.
 980          */
 981         private static String fxLaunchName = null;
 982         private static String fxLaunchMode = null;
 983 
 984         private static Class&lt;?&gt; fxLauncherClass    = null;
 985         private static Method   fxLauncherMethod   = null;
 986 
 987         /*
 988          * Set the launch params according to what was passed to LauncherHelper
 989          * so we can use the same launch mode for FX. Abort if there is any
 990          * issue with loading the FX runtime or with the launcher method.
 991          */
 992         private static void setFXLaunchParameters(String what, int mode) {
 993 
 994             // find the module with the FX launcher
 995             Optional&lt;Module&gt; om = ModuleLayer.boot().findModule(JAVAFX_GRAPHICS_MODULE_NAME);
 996             if (!om.isPresent()) {
 997                 abort(null, &quot;java.launcher.cls.error5&quot;);
 998             }
 999 
1000             // load the FX launcher class
1001             fxLauncherClass = Class.forName(om.get(), JAVAFX_LAUNCHER_CLASS_NAME);
1002             if (fxLauncherClass == null) {
1003                 abort(null, &quot;java.launcher.cls.error5&quot;);
1004             }
1005 
1006             try {
1007                 /*
1008                  * signature must be:
1009                  * public static void launchApplication(String launchName,
1010                  *     String launchMode, String[] args);
1011                  */
1012                 fxLauncherMethod = fxLauncherClass.getMethod(&quot;launchApplication&quot;,
1013                         String.class, String.class, String[].class);
1014 
1015                 // verify launcher signature as we do when validating the main method
1016                 int mod = fxLauncherMethod.getModifiers();
1017                 if (!Modifier.isStatic(mod)) {
1018                     abort(null, &quot;java.launcher.javafx.error1&quot;);
1019                 }
1020                 if (fxLauncherMethod.getReturnType() != java.lang.Void.TYPE) {
1021                     abort(null, &quot;java.launcher.javafx.error1&quot;);
1022                 }
1023             } catch (NoSuchMethodException ex) {
1024                 abort(ex, &quot;java.launcher.cls.error5&quot;, ex);
1025             }
1026 
1027             fxLaunchName = what;
1028             switch (mode) {
1029                 case LM_CLASS:
1030                     fxLaunchMode = JAVAFX_LAUNCH_MODE_CLASS;
1031                     break;
1032                 case LM_JAR:
1033                     fxLaunchMode = JAVAFX_LAUNCH_MODE_JAR;
1034                     break;
1035                 case LM_MODULE:
1036                     fxLaunchMode = JAVAFX_LAUNCH_MODE_MODULE;
1037                     break;
1038                 default:
1039                     // should not have gotten this far...
1040                     throw new InternalError(mode + &quot;: Unknown launch mode&quot;);
1041             }
1042         }
1043 
1044         public static void main(String... args) throws Exception {
1045             if (fxLauncherMethod == null
1046                     || fxLaunchMode == null
1047                     || fxLaunchName == null) {
1048                 throw new RuntimeException(&quot;Invalid JavaFX launch parameters&quot;);
1049             }
1050             // launch appClass via fxLauncherMethod
1051             fxLauncherMethod.invoke(null,
1052                     new Object[] {fxLaunchName, fxLaunchMode, args});
1053         }
1054     }
1055 
1056     /**
1057      * Called by the launcher to list the observable modules.
1058      */
1059     static void listModules() {
1060         initOutput(System.out);
1061 
1062         ModuleBootstrap.limitedFinder().findAll().stream()
1063             .sorted(new JrtFirstComparator())
1064             .forEach(LauncherHelper::showModule);
1065     }
1066 
1067     /**
1068      * Called by the launcher to show the resolved modules
1069      */
1070     static void showResolvedModules() {
1071         initOutput(System.out);
1072 
1073         ModuleLayer bootLayer = ModuleLayer.boot();
1074         Configuration cf = bootLayer.configuration();
1075 
1076         cf.modules().stream()
1077             .map(ResolvedModule::reference)
1078             .sorted(new JrtFirstComparator())
1079             .forEach(LauncherHelper::showModule);
1080     }
1081 
1082     /**
1083      * Called by the launcher to describe a module
1084      */
1085     static void describeModule(String moduleName) {
1086         initOutput(System.out);
1087 
1088         ModuleFinder finder = ModuleBootstrap.limitedFinder();
1089         ModuleReference mref = finder.find(moduleName).orElse(null);
1090         if (mref == null) {
1091             abort(null, &quot;java.launcher.module.error4&quot;, moduleName);
1092         }
1093         ModuleDescriptor md = mref.descriptor();
1094 
1095         // one-line summary
1096         showModule(mref);
1097 
1098         // unqualified exports (sorted by package)
1099         md.exports().stream()
1100             .filter(e -&gt; !e.isQualified())
1101             .sorted(Comparator.comparing(Exports::source))
1102             .map(e -&gt; Stream.concat(Stream.of(e.source()),
1103                                     toStringStream(e.modifiers()))
1104                     .collect(Collectors.joining(&quot; &quot;)))
1105             .forEach(sourceAndMods -&gt; ostream.format(&quot;exports %s%n&quot;, sourceAndMods));
1106 
1107         // dependences
1108         for (Requires r : md.requires()) {
1109             String nameAndMods = Stream.concat(Stream.of(r.name()),
1110                                                toStringStream(r.modifiers()))
1111                     .collect(Collectors.joining(&quot; &quot;));
1112             ostream.format(&quot;requires %s&quot;, nameAndMods);
1113             finder.find(r.name())
1114                 .map(ModuleReference::descriptor)
1115                 .filter(ModuleDescriptor::isAutomatic)
1116                 .ifPresent(any -&gt; ostream.print(&quot; automatic&quot;));
1117             ostream.println();
1118         }
1119 
1120         // service use and provides
1121         for (String s : md.uses()) {
1122             ostream.format(&quot;uses %s%n&quot;, s);
1123         }
1124         for (Provides ps : md.provides()) {
1125             String names = ps.providers().stream().collect(Collectors.joining(&quot; &quot;));
1126             ostream.format(&quot;provides %s with %s%n&quot;, ps.service(), names);
1127 
1128         }
1129 
1130         // qualified exports
1131         for (Exports e : md.exports()) {
1132             if (e.isQualified()) {
1133                 String who = e.targets().stream().collect(Collectors.joining(&quot; &quot;));
1134                 ostream.format(&quot;qualified exports %s to %s%n&quot;, e.source(), who);
1135             }
1136         }
1137 
1138         // open packages
1139         for (Opens opens: md.opens()) {
1140             if (opens.isQualified())
1141                 ostream.print(&quot;qualified &quot;);
1142             String sourceAndMods = Stream.concat(Stream.of(opens.source()),
1143                                                  toStringStream(opens.modifiers()))
1144                     .collect(Collectors.joining(&quot; &quot;));
1145             ostream.format(&quot;opens %s&quot;, sourceAndMods);
1146             if (opens.isQualified()) {
1147                 String who = opens.targets().stream().collect(Collectors.joining(&quot; &quot;));
1148                 ostream.format(&quot; to %s&quot;, who);
1149             }
1150             ostream.println();
1151         }
1152 
1153         // non-exported/non-open packages
1154         Set&lt;String&gt; concealed = new TreeSet&lt;&gt;(md.packages());
1155         md.exports().stream().map(Exports::source).forEach(concealed::remove);
1156         md.opens().stream().map(Opens::source).forEach(concealed::remove);
1157         concealed.forEach(p -&gt; ostream.format(&quot;contains %s%n&quot;, p));
1158     }
1159 
1160     /**
1161      * Prints a single line with the module name, version and modifiers
1162      */
1163     private static void showModule(ModuleReference mref) {
1164         ModuleDescriptor md = mref.descriptor();
1165         ostream.print(md.toNameAndVersion());
1166         mref.location()
1167                 .filter(uri -&gt; !isJrt(uri))
1168                 .ifPresent(uri -&gt; ostream.format(&quot; %s&quot;, uri));
1169         if (md.isOpen())
1170             ostream.print(&quot; open&quot;);
1171         if (md.isAutomatic())
1172             ostream.print(&quot; automatic&quot;);
1173         ostream.println();
1174     }
1175 
1176     /**
1177      * A ModuleReference comparator that considers modules in the run-time
1178      * image to be less than modules than not in the run-time image.
1179      */
1180     private static class JrtFirstComparator implements Comparator&lt;ModuleReference&gt; {
1181         private final Comparator&lt;ModuleReference&gt; real;
1182 
1183         JrtFirstComparator() {
1184             this.real = Comparator.comparing(ModuleReference::descriptor);
1185         }
1186 
1187         @Override
1188         public int compare(ModuleReference a, ModuleReference b) {
1189             if (isJrt(a)) {
1190                 return isJrt(b) ? real.compare(a, b) : -1;
1191             } else {
1192                 return isJrt(b) ? 1 : real.compare(a, b);
1193             }
1194         }
1195     }
1196 
1197     private static &lt;T&gt; Stream&lt;String&gt; toStringStream(Set&lt;T&gt; s) {
1198         return s.stream().map(e -&gt; e.toString().toLowerCase());
1199     }
1200 
1201     private static boolean isJrt(ModuleReference mref) {
1202         return isJrt(mref.location().orElse(null));
1203     }
1204 
1205     private static boolean isJrt(URI uri) {
1206         return (uri != null &amp;&amp; uri.getScheme().equalsIgnoreCase(&quot;jrt&quot;));
1207     }
1208 
1209 }
    </pre>
  </body>
</html>
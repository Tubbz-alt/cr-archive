diff a/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java b/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
--- a/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
+++ b/src/java.base/share/classes/sun/security/util/ObjectIdentifier.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -48,13 +48,11 @@
  * @author David Brownell
  * @author Amit Kapoor
  * @author Hemma Prafullchandra
  */
 
-public final
-class ObjectIdentifier implements Serializable
-{
+public final class ObjectIdentifier implements Serializable {
     /**
      * We use the DER value (no tag, no length) as the internal format
      * @serial
      */
     private byte[] encoding = null;
@@ -98,10 +96,11 @@
      * Changed to Object
      * @serial
      */
     @SuppressWarnings("serial") // Not statically typed as Serializable
     private Object      components   = null;          // path from root
+
     /**
      * @serial
      */
     private int         componentLen = -1;            // how much is used.
 
@@ -139,19 +138,19 @@
     }
 
     static class HugeOidNotSupportedByOldJDK implements Serializable {
         @java.io.Serial
         private static final long serialVersionUID = 1L;
-        static HugeOidNotSupportedByOldJDK theOne = new HugeOidNotSupportedByOldJDK();
+        static HugeOidNotSupportedByOldJDK theOne =
+                new HugeOidNotSupportedByOldJDK();
     }
 
     /**
      * Constructs, from a string.  This string should be of the form 1.23.56.
      * Validity check included.
      */
-    public ObjectIdentifier (String oid) throws IOException
-    {
+    public ObjectIdentifier(String oid) throws IOException {
         int ch = '.';
         int start = 0;
         int end = 0;
 
         int pos = 0;
@@ -215,24 +214,10 @@
             throw new IOException("ObjectIdentifier() -- Invalid format: "
                     + e.toString(), e);
         }
     }
 
-    /**
-     * Constructor, from an array of integers.
-     * Validity check included.
-     */
-    public ObjectIdentifier(int[] values) throws IOException
-    {
-        checkCount(values.length);
-        checkFirstComponent(values[0]);
-        checkSecondComponent(values[0], values[1]);
-        for (int i=2; i<values.length; i++)
-            checkOtherComponent(i, values[i]);
-        init(values, values.length);
-    }
-
     /**
      * Constructor, from an ASN.1 encoded input stream.
      * Validity check NOT included.
      * The encoding of the ID in the stream uses "DER", a BER/1 subset.
      * In this case, that means a triple { typeId, length, data }.
@@ -241,12 +226,11 @@
      * input stream has not been returned to its "initial" state.
      *
      * @param in DER-encoded data holding an object ID
      * @exception IOException indicates a decoding error
      */
-    public ObjectIdentifier (DerInputStream in) throws IOException
-    {
+    public ObjectIdentifier(DerInputStream in) throws IOException {
         byte    type_id;
         int     bufferEnd;
 
         /*
          * Object IDs are a "universal" type, and their tag needs only
@@ -255,11 +239,11 @@
          *
          * Then get and check the length of the ID's encoding.  We set
          * up so that we can use in.available() to check for the end of
          * this value in the data stream.
          */
-        type_id = (byte) in.getByte ();
+        type_id = (byte)in.getByte();
         if (type_id != DerValue.tag_ObjectId)
             throw new IOException (
                 "ObjectIdentifier() -- data isn't an object ID"
                 + " (tag = " +  type_id + ")"
                 );
@@ -278,12 +262,11 @@
     /*
      * Constructor, from the rest of a DER input buffer;
      * the tag and length have been removed/verified
      * Validity check NOT included.
      */
-    ObjectIdentifier (DerInputBuffer buf) throws IOException
-    {
+    ObjectIdentifier(DerInputBuffer buf) throws IOException {
         DerInputStream in = new DerInputStream(buf);
         encoding = new byte[in.available()];
         in.getBytes(encoding);
         check(encoding);
     }
@@ -306,32 +289,27 @@
         encoding = new byte[pos];
         System.arraycopy(tmp, 0, encoding, 0, pos);
     }
 
     /**
-     * This method is kept for compatibility reasons. The new implementation
-     * does the check and conversion. All around the JDK, the method is called
-     * in static blocks to initialize pre-defined ObjectIdentifieies. No
-     * obvious performance hurt will be made after this change.
+     * Returns an ObjectIdentifier instance for the specific string OID.
      *
-     * Old doc: Create a new ObjectIdentifier for internal use. The values are
-     * neither checked nor cloned.
+     * Note: Please use legal string OID only.  Otherwise, a RuntimeException
+     * is thrown.
      */
-    public static ObjectIdentifier newInternal(int[] values) {
+    public static ObjectIdentifier of(String oid) {
         try {
-            return new ObjectIdentifier(values);
-        } catch (IOException ex) {
-            throw new RuntimeException(ex);
-            // Should not happen, internal calls always uses legal values.
+            return new ObjectIdentifier(oid);
+        } catch (IOException ioe) {
+            throw new RuntimeException(ioe);
         }
     }
 
     /*
      * n.b. the only public interface is DerOutputStream.putOID()
      */
-    void encode (DerOutputStream out) throws IOException
-    {
+    void encode(DerOutputStream out) throws IOException {
         out.write (DerValue.tag_ObjectId, encoding);
     }
 
     /**
      * Compares this identifier with another, for equality.
@@ -368,21 +346,25 @@
         int fromPos = 0;
         for (int i = 0; i < length; i++) {
             if ((encoding[i] & 0x80) == 0) {
                 // one section [fromPos..i]
                 if (i - fromPos + 1 > 4) {
-                    BigInteger big = new BigInteger(pack(encoding, fromPos, i-fromPos+1, 7, 8));
+                    BigInteger big = new BigInteger(pack(encoding,
+                            fromPos, i-fromPos+1, 7, 8));
                     if (fromPos == 0) {
                         result[which++] = 2;
-                        BigInteger second = big.subtract(BigInteger.valueOf(80));
-                        if (second.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {
+                        BigInteger second =
+                                big.subtract(BigInteger.valueOf(80));
+                        if (second.compareTo(
+                                BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {
                             return null;
                         } else {
                             result[which++] = second.intValue();
                         }
                     } else {
-                        if (big.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {
+                        if (big.compareTo(
+                                BigInteger.valueOf(Integer.MAX_VALUE)) == 1) {
                             return null;
                         } else {
                             result[which++] = big.intValue();
                         }
                     }
@@ -433,11 +415,12 @@
                     // one section [fromPos..i]
                     if (fromPos != 0) {  // not the first segment
                         sb.append('.');
                     }
                     if (i - fromPos + 1 > 4) { // maybe big integer
-                        BigInteger big = new BigInteger(pack(encoding, fromPos, i-fromPos+1, 7, 8));
+                        BigInteger big = new BigInteger(
+                                pack(encoding, fromPos, i-fromPos+1, 7, 8));
                         if (fromPos == 0) {
                             // first section encoded with more than 4 bytes,
                             // must be 2.something
                             sb.append("2.");
                             sb.append(big.subtract(BigInteger.valueOf(80)));
@@ -474,11 +457,11 @@
     }
 
     /**
      * Repack all bits from input to output. On the both sides, only a portion
      * (from the least significant bit) of the 8 bits in a byte is used. This
-     * number is defined as the number of useful bits (NUB) for the array. All the
+     * number is defined as the number of useful bits (NUB) for the array. All
      * used bits from the input byte array and repacked into the output in the
      * exactly same order. The output bits are aligned so that the final bit of
      * the input (the least significant bit in the last byte), when repacked as
      * the final bit of the output, is still at the least significant position.
      * Zeroes will be padded on the left side of the first output byte if
@@ -496,11 +479,12 @@
      * @param ilength   number of bytes to repack
      * @param iw        NUB for input
      * @param ow        NUB for output
      * @return          the repacked bytes
      */
-    private static byte[] pack(byte[] in, int ioffset, int ilength, int iw, int ow) {
+    private static byte[] pack(byte[] in,
+            int ioffset, int ilength, int iw, int ow) {
         assert (iw > 0 && iw <= 8): "input NUB must be between 1 and 8";
         assert (ow > 0 && ow <= 8): "output NUB must be between 1 and 8";
 
         if (iw == ow) {
             return in.clone();
@@ -518,16 +502,17 @@
         while(ipos < bits) {
             int count = iw - ipos%iw;   // unpacked bits in current input byte
             if (count > ow - opos%ow) { // free space available in output byte
                 count = ow - opos%ow;   // choose the smaller number
             }
+
             // and move them!
-            out[opos/ow] |=                         // paste!
-                (((in[ioffset+ipos/iw]+256)         // locate the byte (+256 so that it's never negative)
-                    >> (iw-ipos%iw-count))          // move to the end of a byte
-                        & ((1 << (count))-1))       // zero out all other bits
-                            << (ow-opos%ow-count);  // move to the output position
+            out[opos/ow] |=                     // paste!
+                (((in[ioffset+ipos/iw]+256)     // locate the byte (+256 so that it's never negative)
+                    >> (iw-ipos%iw-count)) &    // move to the end of a byte
+                  ((1 << (count))-1))           // zero out all other bits
+                        << (ow-opos%ow-count);  // move to the output position
             ipos += count;  // advance
             opos += count;  // advance
         }
         return out;
     }
@@ -539,39 +524,43 @@
      * paste it into an existing byte array.
      * @param out the existing array to be pasted into
      * @param ooffset the starting position to paste
      * @return the number of bytes pasted
      */
-    private static int pack7Oid(byte[] in, int ioffset, int ilength, byte[] out, int ooffset) {
+    private static int pack7Oid(byte[] in,
+            int ioffset, int ilength, byte[] out, int ooffset) {
         byte[] pack = pack(in, ioffset, ilength, 8, 7);
         int firstNonZero = pack.length-1;   // paste at least one byte
         for (int i=pack.length-2; i>=0; i--) {
             if (pack[i] != 0) {
                 firstNonZero = i;
             }
             pack[i] |= 0x80;
         }
-        System.arraycopy(pack, firstNonZero, out, ooffset, pack.length-firstNonZero);
+        System.arraycopy(pack, firstNonZero,
+                out, ooffset, pack.length-firstNonZero);
         return pack.length-firstNonZero;
     }
 
     /**
      * Repack from NUB 7 to NUB 8, remove all unnecessary 0
      * headings, and paste it into an existing byte array.
      * @param out the existing array to be pasted into
      * @param ooffset the starting position to paste
      * @return the number of bytes pasted
      */
-    private static int pack8(byte[] in, int ioffset, int ilength, byte[] out, int ooffset) {
+    private static int pack8(byte[] in,
+            int ioffset, int ilength, byte[] out, int ooffset) {
         byte[] pack = pack(in, ioffset, ilength, 7, 8);
         int firstNonZero = pack.length-1;   // paste at least one byte
         for (int i=pack.length-2; i>=0; i--) {
             if (pack[i] != 0) {
                 firstNonZero = i;
             }
         }
-        System.arraycopy(pack, firstNonZero, out, ooffset, pack.length-firstNonZero);
+        System.arraycopy(pack, firstNonZero,
+                out, ooffset, pack.length-firstNonZero);
         return pack.length-firstNonZero;
     }
 
     /**
      * Pack the int into a OID sub-identifier DER encoding
@@ -619,49 +608,60 @@
                 throw new IOException("ObjectIdentifier() -- " +
                         "Invalid DER encoding, useless extra octet detected");
             }
         }
     }
+
     private static void checkCount(int count) throws IOException {
         if (count < 2) {
             throw new IOException("ObjectIdentifier() -- " +
                     "Must be at least two oid components ");
         }
     }
+
     private static void checkFirstComponent(int first) throws IOException {
         if (first < 0 || first > 2) {
             throw new IOException("ObjectIdentifier() -- " +
                     "First oid component is invalid ");
         }
     }
-    private static void checkFirstComponent(BigInteger first) throws IOException {
+
+    private static void checkFirstComponent(
+            BigInteger first) throws IOException {
         if (first.signum() == -1 || first.compareTo(BigInteger.TWO) > 0) {
             throw new IOException("ObjectIdentifier() -- " +
                     "First oid component is invalid ");
         }
     }
-    private static void checkSecondComponent(int first, int second) throws IOException {
+
+    private static void checkSecondComponent(
+            int first, int second) throws IOException {
         if (second < 0 || first != 2 && second > 39) {
             throw new IOException("ObjectIdentifier() -- " +
                     "Second oid component is invalid ");
         }
     }
-    private static void checkSecondComponent(int first, BigInteger second) throws IOException {
+
+    private static void checkSecondComponent(
+            int first, BigInteger second) throws IOException {
         if (second.signum() == -1 ||
                 first != 2 &&
                 second.compareTo(BigInteger.valueOf(39)) == 1) {
             throw new IOException("ObjectIdentifier() -- " +
                     "Second oid component is invalid ");
         }
     }
+
     private static void checkOtherComponent(int i, int num) throws IOException {
         if (num < 0) {
             throw new IOException("ObjectIdentifier() -- " +
                     "oid component #" + (i+1) + " must be non-negative ");
         }
     }
-    private static void checkOtherComponent(int i, BigInteger num) throws IOException {
+
+    private static void checkOtherComponent(
+            int i, BigInteger num) throws IOException {
         if (num.signum() == -1) {
             throw new IOException("ObjectIdentifier() -- " +
                     "oid component #" + (i+1) + " must be non-negative ");
         }
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/stream/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Stream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../javax/crypto/CryptoPolicyParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/stream/package-info.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 /**
 27  * Classes to support functional-style operations on streams of elements, such
 28  * as map-reduce transformations on collections.  For example:
 29  *
 30  * &lt;pre&gt;{@code
 31  *     int sum = widgets.stream()
 32  *                      .filter(b -&gt; b.getColor() == RED)
 33  *                      .mapToInt(b -&gt; b.getWeight())
 34  *                      .sum();
 35  * }&lt;/pre&gt;
 36  *
 37  * &lt;p&gt;Here we use {@code widgets}, a {@code Collection&lt;Widget&gt;},
 38  * as a source for a stream, and then perform a filter-map-reduce on the stream
 39  * to obtain the sum of the weights of the red widgets.  (Summation is an
 40  * example of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;
 41  * operation.)
 42  *
 43  * &lt;p&gt;The key abstraction introduced in this package is &lt;em&gt;stream&lt;/em&gt;.  The
 44  * classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream},
 45  * {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream}
<span class="line-modified"> 46  * are streams over objects and the primitive {@code int}, {@code long} and</span>
 47  * {@code double} types.  Streams differ from collections in several ways:
 48  *
 49  * &lt;ul&gt;
 50  *     &lt;li&gt;No storage.  A stream is not a data structure that stores elements;
 51  *     instead, it conveys elements from a source such as a data structure,
 52  *     an array, a generator function, or an I/O channel, through a pipeline of
 53  *     computational operations.&lt;/li&gt;
 54  *     &lt;li&gt;Functional in nature.  An operation on a stream produces a result,
 55  *     but does not modify its source.  For example, filtering a {@code Stream}
 56  *     obtained from a collection produces a new {@code Stream} without the
 57  *     filtered elements, rather than removing elements from the source
 58  *     collection.&lt;/li&gt;
 59  *     &lt;li&gt;Laziness-seeking.  Many stream operations, such as filtering, mapping,
 60  *     or duplicate removal, can be implemented lazily, exposing opportunities
 61  *     for optimization.  For example, &quot;find the first {@code String} with
 62  *     three consecutive vowels&quot; need not examine all the input strings.
 63  *     Stream operations are divided into intermediate ({@code Stream}-producing)
 64  *     operations and terminal (value- or side-effect-producing) operations.
 65  *     Intermediate operations are always lazy.&lt;/li&gt;
 66  *     &lt;li&gt;Possibly unbounded.  While collections have a finite size, streams
</pre>
<hr />
<pre>
159  * is a necessary, but not sufficient, condition for the processing of an infinite
160  * stream to terminate normally in finite time.
161  *
162  * &lt;h3&gt;&lt;a id=&quot;Parallelism&quot;&gt;Parallelism&lt;/a&gt;&lt;/h3&gt;
163  *
164  * &lt;p&gt;Processing elements with an explicit {@code for-}loop is inherently serial.
165  * Streams facilitate parallel execution by reframing the computation as a pipeline of
166  * aggregate operations, rather than as imperative operations on each individual
167  * element.  All streams operations can execute either in serial or in parallel.
168  * The stream implementations in the JDK create serial streams unless parallelism is
169  * explicitly requested.  For example, {@code Collection} has methods
170  * {@link java.util.Collection#stream} and {@link java.util.Collection#parallelStream},
171  * which produce sequential and parallel streams respectively; other
172  * stream-bearing methods such as {@link java.util.stream.IntStream#range(int, int)}
173  * produce sequential streams but these streams can be efficiently parallelized by
174  * invoking their {@link java.util.stream.BaseStream#parallel()} method.
175  * To execute the prior &quot;sum of weights of widgets&quot; query in parallel, we would
176  * do:
177  *
178  * &lt;pre&gt;{@code
<span class="line-modified">179  *     int sumOfWeights = widgets.&lt;b&gt;parallelStream()&lt;/b&gt;</span>
180  *                               .filter(b -&gt; b.getColor() == RED)
181  *                               .mapToInt(b -&gt; b.getWeight())
182  *                               .sum();
183  * }&lt;/pre&gt;
184  *
185  * &lt;p&gt;The only difference between the serial and parallel versions of this
186  * example is the creation of the initial stream, using &quot;{@code parallelStream()}&quot;
187  * instead of &quot;{@code stream()}&quot;. The stream pipeline is executed sequentially or
188  * in parallel depending on the mode of the stream on which the terminal operation
189  * is invoked. The sequential or parallel mode of a stream can be determined with the
190  * {@link java.util.stream.BaseStream#isParallel()} method, and the
191  * stream&#39;s mode can be modified with the
192  * {@link java.util.stream.BaseStream#sequential()} and
193  * {@link java.util.stream.BaseStream#parallel()} operations.
194  * The most recent sequential or parallel mode setting applies to the
195  * execution of the entire stream pipeline.
196  *
197  * &lt;p&gt;Except for operations identified as explicitly nondeterministic, such
198  * as {@code findAny()}, whether a stream executes sequentially or in parallel
199  * should not change the result of the computation.
</pre>
<hr />
<pre>
225  * &lt;p&gt;Accordingly, behavioral parameters in stream pipelines whose source might
226  * not be concurrent should never modify the stream&#39;s data source.
227  * A behavioral parameter is said to &lt;em&gt;interfere&lt;/em&gt; with a non-concurrent
228  * data source if it modifies, or causes to be
229  * modified, the stream&#39;s data source.  The need for non-interference applies
230  * to all pipelines, not just parallel ones.  Unless the stream source is
231  * concurrent, modifying a stream&#39;s data source during execution of a stream
232  * pipeline can cause exceptions, incorrect answers, or nonconformant behavior.
233  *
234  * For well-behaved stream sources, the source can be modified before the
235  * terminal operation commences and those modifications will be reflected in
236  * the covered elements.  For example, consider the following code:
237  *
238  * &lt;pre&gt;{@code
239  *     List&lt;String&gt; l = new ArrayList(Arrays.asList(&quot;one&quot;, &quot;two&quot;));
240  *     Stream&lt;String&gt; sl = l.stream();
241  *     l.add(&quot;three&quot;);
242  *     String s = sl.collect(joining(&quot; &quot;));
243  * }&lt;/pre&gt;
244  *
<span class="line-modified">245  * First a list is created consisting of two strings: &quot;one&quot;; and &quot;two&quot;. Then a</span>
246  * stream is created from that list. Next the list is modified by adding a third
247  * string: &quot;three&quot;. Finally the elements of the stream are collected and joined
248  * together. Since the list was modified before the terminal {@code collect}
249  * operation commenced the result will be a string of &quot;one two three&quot;. All the
250  * streams returned from JDK collections, and most other JDK classes,
251  * are well-behaved in this manner; for streams generated by other libraries, see
252  * &lt;a href=&quot;package-summary.html#StreamSources&quot;&gt;Low-level stream
253  * construction&lt;/a&gt; for requirements for building well-behaved streams.
254  *
255  * &lt;h3&gt;&lt;a id=&quot;Statelessness&quot;&gt;Stateless behaviors&lt;/a&gt;&lt;/h3&gt;
256  *
257  * Stream pipeline results may be nondeterministic or incorrect if the behavioral
258  * parameters to the stream operations are &lt;em&gt;stateful&lt;/em&gt;.  A stateful lambda
259  * (or other object implementing the appropriate functional interface) is one
260  * whose result depends on any state which might change during the execution
261  * of the stream pipeline.  An example of a stateful lambda is the parameter
262  * to {@code map()} in:
263  *
264  * &lt;pre&gt;{@code
265  *     Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());
</pre>
<hr />
<pre>
299  *    computation.
300  *    &lt;/li&gt;
301  * &lt;/ul&gt;
302  * &lt;p&gt;The ordering of side-effects may be surprising.  Even when a pipeline is
303  * constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the
304  * encounter order of the stream source (for example,
305  * {@code IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()}
306  * must produce {@code [0, 2, 4, 6, 8]}), no guarantees are made as to the order
307  * in which the mapper function is applied to individual elements, or in what
308  * thread any behavioral parameter is executed for a given element.
309  *
310  * &lt;p&gt;The eliding of side-effects may also be surprising.  With the exception of
311  * terminal operations {@link java.util.stream.Stream#forEach forEach} and
312  * {@link java.util.stream.Stream#forEachOrdered forEachOrdered}, side-effects
313  * of behavioral parameters may not always be executed when the stream
314  * implementation can optimize away the execution of behavioral parameters
315  * without affecting the result of the computation.  (For a specific example
316  * see the API note documented on the {@link java.util.stream.Stream#count count}
317  * operation.)
318  *
<span class="line-modified">319  * &lt;p&gt;Many computations where one might be tempted to use side effects can be more</span>
320  * safely and efficiently expressed without side-effects, such as using
321  * &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt; instead of mutable
322  * accumulators. However, side-effects such as using {@code println()} for debugging
323  * purposes are usually harmless.  A small number of stream operations, such as
324  * {@code forEach()} and {@code peek()}, can operate only via side-effects;
325  * these should be used with care.
326  *
327  * &lt;p&gt;As an example of how to transform a stream pipeline that inappropriately
328  * uses side-effects to one that does not, the following code searches a stream
329  * of strings for those matching a given regular expression, and puts the
330  * matches in a list.
331  *
332  * &lt;pre&gt;{@code
333  *     ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();
334  *     stream.filter(s -&gt; pattern.matcher(s).matches())
335  *           .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!
336  * }&lt;/pre&gt;
337  *
338  * This code unnecessarily uses side-effects.  If executed in parallel, the
339  * non-thread-safety of {@code ArrayList} would cause incorrect results, and
340  * adding needed synchronization would cause contention, undermining the
341  * benefit of parallelism.  Furthermore, using side-effects here is completely
342  * unnecessary; the {@code forEach()} can simply be replaced with a reduction
343  * operation that is safer, more efficient, and more amenable to
344  * parallelization:
345  *
346  * &lt;pre&gt;{@code
<span class="line-modified">347  *     List&lt;String&gt;results =</span>
348  *         stream.filter(s -&gt; pattern.matcher(s).matches())
349  *               .collect(Collectors.toList());  // No side-effects!
350  * }&lt;/pre&gt;
351  *
352  * &lt;h3&gt;&lt;a id=&quot;Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/h3&gt;
353  *
354  * &lt;p&gt;Streams may or may not have a defined &lt;em&gt;encounter order&lt;/em&gt;.  Whether
355  * or not a stream has an encounter order depends on the source and the
356  * intermediate operations.  Certain stream sources (such as {@code List} or
357  * arrays) are intrinsically ordered, whereas others (such as {@code HashSet})
358  * are not.  Some intermediate operations, such as {@code sorted()}, may impose
359  * an encounter order on an otherwise unordered stream, and others may render an
360  * ordered stream unordered, such as {@link java.util.stream.BaseStream#unordered()}.
361  * Further, some terminal operations may ignore encounter order, such as
362  * {@code forEach()}.
363  *
364  * &lt;p&gt;If a stream is ordered, most operations are constrained to operate on the
365  * elements in their encounter order; if the source of a stream is a {@code List}
366  * containing {@code [1, 2, 3]}, then the result of executing {@code map(x -&gt; x*2)}
367  * must be {@code [2, 4, 6]}.  However, if the source has no defined encounter
</pre>
<hr />
<pre>
428  *
429  * &lt;p&gt;These reduction operations can run safely in parallel with almost no
430  * modification:
431  * &lt;pre&gt;{@code
432  *    int sum = numbers.parallelStream().reduce(0, Integer::sum);
433  * }&lt;/pre&gt;
434  *
435  * &lt;p&gt;Reduction parallellizes well because the implementation
436  * can operate on subsets of the data in parallel, and then combine the
437  * intermediate results to get the final correct answer.  (Even if the language
438  * had a &quot;parallel for-each&quot; construct, the mutative accumulation approach would
439  * still required the developer to provide
440  * thread-safe updates to the shared accumulating variable {@code sum}, and
441  * the required synchronization would then likely eliminate any performance gain from
442  * parallelism.)  Using {@code reduce()} instead removes all of the
443  * burden of parallelizing the reduction operation, and the library can provide
444  * an efficient parallel implementation with no additional synchronization
445  * required.
446  *
447  * &lt;p&gt;The &quot;widgets&quot; examples shown earlier shows how reduction combines with
<span class="line-modified">448  * other operations to replace for loops with bulk operations.  If {@code widgets}</span>
449  * is a collection of {@code Widget} objects, which have a {@code getWeight} method,
450  * we can find the heaviest widget with:
451  * &lt;pre&gt;{@code
452  *     OptionalInt heaviest = widgets.parallelStream()
453  *                                   .mapToInt(Widget::getWeight)
454  *                                   .max();
455  * }&lt;/pre&gt;
456  *
457  * &lt;p&gt;In its more general form, a {@code reduce} operation on elements of type
458  * {@code &lt;T&gt;} yielding a result of type {@code &lt;U&gt;} requires three parameters:
459  * &lt;pre&gt;{@code
460  * &lt;U&gt; U reduce(U identity,
461  *              BiFunction&lt;U, ? super T, U&gt; accumulator,
462  *              BinaryOperator&lt;U&gt; combiner);
463  * }&lt;/pre&gt;
464  * Here, the &lt;em&gt;identity&lt;/em&gt; element is both an initial seed value for the reduction
465  * and a default result if there are no input elements. The &lt;em&gt;accumulator&lt;/em&gt;
466  * function takes a partial result and the next element, and produces a new
467  * partial result. The &lt;em&gt;combiner&lt;/em&gt; function combines two partial results
468  * to produce a new partial result.  (The combiner is necessary in parallel
</pre>
</td>
<td>
<hr />
<pre>
 26 /**
 27  * Classes to support functional-style operations on streams of elements, such
 28  * as map-reduce transformations on collections.  For example:
 29  *
 30  * &lt;pre&gt;{@code
 31  *     int sum = widgets.stream()
 32  *                      .filter(b -&gt; b.getColor() == RED)
 33  *                      .mapToInt(b -&gt; b.getWeight())
 34  *                      .sum();
 35  * }&lt;/pre&gt;
 36  *
 37  * &lt;p&gt;Here we use {@code widgets}, a {@code Collection&lt;Widget&gt;},
 38  * as a source for a stream, and then perform a filter-map-reduce on the stream
 39  * to obtain the sum of the weights of the red widgets.  (Summation is an
 40  * example of a &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt;
 41  * operation.)
 42  *
 43  * &lt;p&gt;The key abstraction introduced in this package is &lt;em&gt;stream&lt;/em&gt;.  The
 44  * classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream},
 45  * {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream}
<span class="line-modified"> 46  * are streams over objects and the primitive {@code int}, {@code long}, and</span>
 47  * {@code double} types.  Streams differ from collections in several ways:
 48  *
 49  * &lt;ul&gt;
 50  *     &lt;li&gt;No storage.  A stream is not a data structure that stores elements;
 51  *     instead, it conveys elements from a source such as a data structure,
 52  *     an array, a generator function, or an I/O channel, through a pipeline of
 53  *     computational operations.&lt;/li&gt;
 54  *     &lt;li&gt;Functional in nature.  An operation on a stream produces a result,
 55  *     but does not modify its source.  For example, filtering a {@code Stream}
 56  *     obtained from a collection produces a new {@code Stream} without the
 57  *     filtered elements, rather than removing elements from the source
 58  *     collection.&lt;/li&gt;
 59  *     &lt;li&gt;Laziness-seeking.  Many stream operations, such as filtering, mapping,
 60  *     or duplicate removal, can be implemented lazily, exposing opportunities
 61  *     for optimization.  For example, &quot;find the first {@code String} with
 62  *     three consecutive vowels&quot; need not examine all the input strings.
 63  *     Stream operations are divided into intermediate ({@code Stream}-producing)
 64  *     operations and terminal (value- or side-effect-producing) operations.
 65  *     Intermediate operations are always lazy.&lt;/li&gt;
 66  *     &lt;li&gt;Possibly unbounded.  While collections have a finite size, streams
</pre>
<hr />
<pre>
159  * is a necessary, but not sufficient, condition for the processing of an infinite
160  * stream to terminate normally in finite time.
161  *
162  * &lt;h3&gt;&lt;a id=&quot;Parallelism&quot;&gt;Parallelism&lt;/a&gt;&lt;/h3&gt;
163  *
164  * &lt;p&gt;Processing elements with an explicit {@code for-}loop is inherently serial.
165  * Streams facilitate parallel execution by reframing the computation as a pipeline of
166  * aggregate operations, rather than as imperative operations on each individual
167  * element.  All streams operations can execute either in serial or in parallel.
168  * The stream implementations in the JDK create serial streams unless parallelism is
169  * explicitly requested.  For example, {@code Collection} has methods
170  * {@link java.util.Collection#stream} and {@link java.util.Collection#parallelStream},
171  * which produce sequential and parallel streams respectively; other
172  * stream-bearing methods such as {@link java.util.stream.IntStream#range(int, int)}
173  * produce sequential streams but these streams can be efficiently parallelized by
174  * invoking their {@link java.util.stream.BaseStream#parallel()} method.
175  * To execute the prior &quot;sum of weights of widgets&quot; query in parallel, we would
176  * do:
177  *
178  * &lt;pre&gt;{@code
<span class="line-modified">179  *     int sumOfWeights = widgets.parallelStream()</span>
180  *                               .filter(b -&gt; b.getColor() == RED)
181  *                               .mapToInt(b -&gt; b.getWeight())
182  *                               .sum();
183  * }&lt;/pre&gt;
184  *
185  * &lt;p&gt;The only difference between the serial and parallel versions of this
186  * example is the creation of the initial stream, using &quot;{@code parallelStream()}&quot;
187  * instead of &quot;{@code stream()}&quot;. The stream pipeline is executed sequentially or
188  * in parallel depending on the mode of the stream on which the terminal operation
189  * is invoked. The sequential or parallel mode of a stream can be determined with the
190  * {@link java.util.stream.BaseStream#isParallel()} method, and the
191  * stream&#39;s mode can be modified with the
192  * {@link java.util.stream.BaseStream#sequential()} and
193  * {@link java.util.stream.BaseStream#parallel()} operations.
194  * The most recent sequential or parallel mode setting applies to the
195  * execution of the entire stream pipeline.
196  *
197  * &lt;p&gt;Except for operations identified as explicitly nondeterministic, such
198  * as {@code findAny()}, whether a stream executes sequentially or in parallel
199  * should not change the result of the computation.
</pre>
<hr />
<pre>
225  * &lt;p&gt;Accordingly, behavioral parameters in stream pipelines whose source might
226  * not be concurrent should never modify the stream&#39;s data source.
227  * A behavioral parameter is said to &lt;em&gt;interfere&lt;/em&gt; with a non-concurrent
228  * data source if it modifies, or causes to be
229  * modified, the stream&#39;s data source.  The need for non-interference applies
230  * to all pipelines, not just parallel ones.  Unless the stream source is
231  * concurrent, modifying a stream&#39;s data source during execution of a stream
232  * pipeline can cause exceptions, incorrect answers, or nonconformant behavior.
233  *
234  * For well-behaved stream sources, the source can be modified before the
235  * terminal operation commences and those modifications will be reflected in
236  * the covered elements.  For example, consider the following code:
237  *
238  * &lt;pre&gt;{@code
239  *     List&lt;String&gt; l = new ArrayList(Arrays.asList(&quot;one&quot;, &quot;two&quot;));
240  *     Stream&lt;String&gt; sl = l.stream();
241  *     l.add(&quot;three&quot;);
242  *     String s = sl.collect(joining(&quot; &quot;));
243  * }&lt;/pre&gt;
244  *
<span class="line-modified">245  * First a list is created consisting of two strings: &quot;one&quot; and &quot;two&quot;. Then a</span>
246  * stream is created from that list. Next the list is modified by adding a third
247  * string: &quot;three&quot;. Finally the elements of the stream are collected and joined
248  * together. Since the list was modified before the terminal {@code collect}
249  * operation commenced the result will be a string of &quot;one two three&quot;. All the
250  * streams returned from JDK collections, and most other JDK classes,
251  * are well-behaved in this manner; for streams generated by other libraries, see
252  * &lt;a href=&quot;package-summary.html#StreamSources&quot;&gt;Low-level stream
253  * construction&lt;/a&gt; for requirements for building well-behaved streams.
254  *
255  * &lt;h3&gt;&lt;a id=&quot;Statelessness&quot;&gt;Stateless behaviors&lt;/a&gt;&lt;/h3&gt;
256  *
257  * Stream pipeline results may be nondeterministic or incorrect if the behavioral
258  * parameters to the stream operations are &lt;em&gt;stateful&lt;/em&gt;.  A stateful lambda
259  * (or other object implementing the appropriate functional interface) is one
260  * whose result depends on any state which might change during the execution
261  * of the stream pipeline.  An example of a stateful lambda is the parameter
262  * to {@code map()} in:
263  *
264  * &lt;pre&gt;{@code
265  *     Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());
</pre>
<hr />
<pre>
299  *    computation.
300  *    &lt;/li&gt;
301  * &lt;/ul&gt;
302  * &lt;p&gt;The ordering of side-effects may be surprising.  Even when a pipeline is
303  * constrained to produce a &lt;em&gt;result&lt;/em&gt; that is consistent with the
304  * encounter order of the stream source (for example,
305  * {@code IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()}
306  * must produce {@code [0, 2, 4, 6, 8]}), no guarantees are made as to the order
307  * in which the mapper function is applied to individual elements, or in what
308  * thread any behavioral parameter is executed for a given element.
309  *
310  * &lt;p&gt;The eliding of side-effects may also be surprising.  With the exception of
311  * terminal operations {@link java.util.stream.Stream#forEach forEach} and
312  * {@link java.util.stream.Stream#forEachOrdered forEachOrdered}, side-effects
313  * of behavioral parameters may not always be executed when the stream
314  * implementation can optimize away the execution of behavioral parameters
315  * without affecting the result of the computation.  (For a specific example
316  * see the API note documented on the {@link java.util.stream.Stream#count count}
317  * operation.)
318  *
<span class="line-modified">319  * &lt;p&gt;Many computations where one might be tempted to use side-effects can be more</span>
320  * safely and efficiently expressed without side-effects, such as using
321  * &lt;a href=&quot;package-summary.html#Reduction&quot;&gt;reduction&lt;/a&gt; instead of mutable
322  * accumulators. However, side-effects such as using {@code println()} for debugging
323  * purposes are usually harmless.  A small number of stream operations, such as
324  * {@code forEach()} and {@code peek()}, can operate only via side-effects;
325  * these should be used with care.
326  *
327  * &lt;p&gt;As an example of how to transform a stream pipeline that inappropriately
328  * uses side-effects to one that does not, the following code searches a stream
329  * of strings for those matching a given regular expression, and puts the
330  * matches in a list.
331  *
332  * &lt;pre&gt;{@code
333  *     ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();
334  *     stream.filter(s -&gt; pattern.matcher(s).matches())
335  *           .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!
336  * }&lt;/pre&gt;
337  *
338  * This code unnecessarily uses side-effects.  If executed in parallel, the
339  * non-thread-safety of {@code ArrayList} would cause incorrect results, and
340  * adding needed synchronization would cause contention, undermining the
341  * benefit of parallelism.  Furthermore, using side-effects here is completely
342  * unnecessary; the {@code forEach()} can simply be replaced with a reduction
343  * operation that is safer, more efficient, and more amenable to
344  * parallelization:
345  *
346  * &lt;pre&gt;{@code
<span class="line-modified">347  *     List&lt;String&gt; results =</span>
348  *         stream.filter(s -&gt; pattern.matcher(s).matches())
349  *               .collect(Collectors.toList());  // No side-effects!
350  * }&lt;/pre&gt;
351  *
352  * &lt;h3&gt;&lt;a id=&quot;Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/h3&gt;
353  *
354  * &lt;p&gt;Streams may or may not have a defined &lt;em&gt;encounter order&lt;/em&gt;.  Whether
355  * or not a stream has an encounter order depends on the source and the
356  * intermediate operations.  Certain stream sources (such as {@code List} or
357  * arrays) are intrinsically ordered, whereas others (such as {@code HashSet})
358  * are not.  Some intermediate operations, such as {@code sorted()}, may impose
359  * an encounter order on an otherwise unordered stream, and others may render an
360  * ordered stream unordered, such as {@link java.util.stream.BaseStream#unordered()}.
361  * Further, some terminal operations may ignore encounter order, such as
362  * {@code forEach()}.
363  *
364  * &lt;p&gt;If a stream is ordered, most operations are constrained to operate on the
365  * elements in their encounter order; if the source of a stream is a {@code List}
366  * containing {@code [1, 2, 3]}, then the result of executing {@code map(x -&gt; x*2)}
367  * must be {@code [2, 4, 6]}.  However, if the source has no defined encounter
</pre>
<hr />
<pre>
428  *
429  * &lt;p&gt;These reduction operations can run safely in parallel with almost no
430  * modification:
431  * &lt;pre&gt;{@code
432  *    int sum = numbers.parallelStream().reduce(0, Integer::sum);
433  * }&lt;/pre&gt;
434  *
435  * &lt;p&gt;Reduction parallellizes well because the implementation
436  * can operate on subsets of the data in parallel, and then combine the
437  * intermediate results to get the final correct answer.  (Even if the language
438  * had a &quot;parallel for-each&quot; construct, the mutative accumulation approach would
439  * still required the developer to provide
440  * thread-safe updates to the shared accumulating variable {@code sum}, and
441  * the required synchronization would then likely eliminate any performance gain from
442  * parallelism.)  Using {@code reduce()} instead removes all of the
443  * burden of parallelizing the reduction operation, and the library can provide
444  * an efficient parallel implementation with no additional synchronization
445  * required.
446  *
447  * &lt;p&gt;The &quot;widgets&quot; examples shown earlier shows how reduction combines with
<span class="line-modified">448  * other operations to replace for-loops with bulk operations.  If {@code widgets}</span>
449  * is a collection of {@code Widget} objects, which have a {@code getWeight} method,
450  * we can find the heaviest widget with:
451  * &lt;pre&gt;{@code
452  *     OptionalInt heaviest = widgets.parallelStream()
453  *                                   .mapToInt(Widget::getWeight)
454  *                                   .max();
455  * }&lt;/pre&gt;
456  *
457  * &lt;p&gt;In its more general form, a {@code reduce} operation on elements of type
458  * {@code &lt;T&gt;} yielding a result of type {@code &lt;U&gt;} requires three parameters:
459  * &lt;pre&gt;{@code
460  * &lt;U&gt; U reduce(U identity,
461  *              BiFunction&lt;U, ? super T, U&gt; accumulator,
462  *              BinaryOperator&lt;U&gt; combiner);
463  * }&lt;/pre&gt;
464  * Here, the &lt;em&gt;identity&lt;/em&gt; element is both an initial seed value for the reduction
465  * and a default result if there are no input elements. The &lt;em&gt;accumulator&lt;/em&gt;
466  * function takes a partial result and the next element, and produces a new
467  * partial result. The &lt;em&gt;combiner&lt;/em&gt; function combines two partial results
468  * to produce a new partial result.  (The combiner is necessary in parallel
</pre>
</td>
</tr>
</table>
<center><a href="Stream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../javax/crypto/CryptoPolicyParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
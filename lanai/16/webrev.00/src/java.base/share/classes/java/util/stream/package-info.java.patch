diff a/src/java.base/share/classes/java/util/stream/package-info.java b/src/java.base/share/classes/java/util/stream/package-info.java
--- a/src/java.base/share/classes/java/util/stream/package-info.java
+++ b/src/java.base/share/classes/java/util/stream/package-info.java
@@ -41,11 +41,11 @@
  * operation.)
  *
  * <p>The key abstraction introduced in this package is <em>stream</em>.  The
  * classes {@link java.util.stream.Stream}, {@link java.util.stream.IntStream},
  * {@link java.util.stream.LongStream}, and {@link java.util.stream.DoubleStream}
- * are streams over objects and the primitive {@code int}, {@code long} and
+ * are streams over objects and the primitive {@code int}, {@code long}, and
  * {@code double} types.  Streams differ from collections in several ways:
  *
  * <ul>
  *     <li>No storage.  A stream is not a data structure that stores elements;
  *     instead, it conveys elements from a source such as a data structure,
@@ -174,11 +174,11 @@
  * invoking their {@link java.util.stream.BaseStream#parallel()} method.
  * To execute the prior "sum of weights of widgets" query in parallel, we would
  * do:
  *
  * <pre>{@code
- *     int sumOfWeights = widgets.<b>parallelStream()</b>
+ *     int sumOfWeights = widgets.parallelStream()
  *                               .filter(b -> b.getColor() == RED)
  *                               .mapToInt(b -> b.getWeight())
  *                               .sum();
  * }</pre>
  *
@@ -240,11 +240,11 @@
  *     Stream<String> sl = l.stream();
  *     l.add("three");
  *     String s = sl.collect(joining(" "));
  * }</pre>
  *
- * First a list is created consisting of two strings: "one"; and "two". Then a
+ * First a list is created consisting of two strings: "one" and "two". Then a
  * stream is created from that list. Next the list is modified by adding a third
  * string: "three". Finally the elements of the stream are collected and joined
  * together. Since the list was modified before the terminal {@code collect}
  * operation commenced the result will be a string of "one two three". All the
  * streams returned from JDK collections, and most other JDK classes,
@@ -314,11 +314,11 @@
  * implementation can optimize away the execution of behavioral parameters
  * without affecting the result of the computation.  (For a specific example
  * see the API note documented on the {@link java.util.stream.Stream#count count}
  * operation.)
  *
- * <p>Many computations where one might be tempted to use side effects can be more
+ * <p>Many computations where one might be tempted to use side-effects can be more
  * safely and efficiently expressed without side-effects, such as using
  * <a href="package-summary.html#Reduction">reduction</a> instead of mutable
  * accumulators. However, side-effects such as using {@code println()} for debugging
  * purposes are usually harmless.  A small number of stream operations, such as
  * {@code forEach()} and {@code peek()}, can operate only via side-effects;
@@ -342,11 +342,11 @@
  * unnecessary; the {@code forEach()} can simply be replaced with a reduction
  * operation that is safer, more efficient, and more amenable to
  * parallelization:
  *
  * <pre>{@code
- *     List<String>results =
+ *     List<String> results =
  *         stream.filter(s -> pattern.matcher(s).matches())
  *               .collect(Collectors.toList());  // No side-effects!
  * }</pre>
  *
  * <h3><a id="Ordering">Ordering</a></h3>
@@ -443,11 +443,11 @@
  * burden of parallelizing the reduction operation, and the library can provide
  * an efficient parallel implementation with no additional synchronization
  * required.
  *
  * <p>The "widgets" examples shown earlier shows how reduction combines with
- * other operations to replace for loops with bulk operations.  If {@code widgets}
+ * other operations to replace for-loops with bulk operations.  If {@code widgets}
  * is a collection of {@code Widget} objects, which have a {@code getWeight} method,
  * we can find the heaviest widget with:
  * <pre>{@code
  *     OptionalInt heaviest = widgets.parallelStream()
  *                                   .mapToInt(Widget::getWeight)

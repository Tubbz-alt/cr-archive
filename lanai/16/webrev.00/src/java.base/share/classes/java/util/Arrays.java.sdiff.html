<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/Arrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractList.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BitSet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/Arrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
2777         int bLength = bToIndex - bFromIndex;
2778         if (aLength != bLength)
2779             return false;
2780 
2781         return ArraysSupport.mismatch(a, aFromIndex,
2782                                       b, bFromIndex,
2783                                       aLength) &lt; 0;
2784     }
2785 
2786     /**
2787      * Returns {@code true} if the two specified arrays of doubles are
2788      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2789      * arrays contain the same number of elements, and all corresponding pairs
2790      * of elements in the two arrays are equal.  In other words, two arrays
2791      * are equal if they contain the same elements in the same order.  Also,
2792      * two array references are considered equal if both are {@code null}.
2793      *
2794      * Two doubles {@code d1} and {@code d2} are considered equal if:
2795      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
2796      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2797      * {@code NaN} equals to itself, and 0.0d unequal to -0.0d.)</span>
2798      *
2799      * @param a one array to be tested for equality
2800      * @param a2 the other array to be tested for equality
2801      * @return {@code true} if the two arrays are equal
2802      * @see Double#equals(Object)
2803      */
2804     public static boolean equals(double[] a, double[] a2) {
2805         if (a==a2)
2806             return true;
2807         if (a==null || a2==null)
2808             return false;
2809 
2810         int length = a.length;
2811         if (a2.length != length)
2812             return false;
2813 
2814         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2815     }
2816 
2817     /**
2818      * Returns true if the two specified arrays of doubles, over the specified
2819      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2820      *
2821      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2822      * each range is the same, and all corresponding pairs of elements over the
2823      * specified ranges in the two arrays are equal.  In other words, two arrays
2824      * are equal if they contain, over the specified ranges, the same elements
2825      * in the same order.
2826      *
2827      * &lt;p&gt;Two doubles {@code d1} and {@code d2} are considered equal if:
2828      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
2829      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2830      * {@code NaN} equals to itself, and 0.0d unequal to -0.0d.)</span>
2831      *
2832      * @param a the first array to be tested for equality
2833      * @param aFromIndex the index (inclusive) of the first element in the
2834      *                   first array to be tested
2835      * @param aToIndex the index (exclusive) of the last element in the
2836      *                 first array to be tested
2837      * @param b the second array to be tested for equality
2838      * @param bFromIndex the index (inclusive) of the first element in the
2839      *                   second array to be tested
2840      * @param bToIndex the index (exclusive) of the last element in the
2841      *                 second array to be tested
2842      * @return {@code true} if the two arrays, over the specified ranges, are
2843      *         equal
2844      * @throws IllegalArgumentException
2845      *         if {@code aFromIndex &gt; aToIndex} or
2846      *         if {@code bFromIndex &gt; bToIndex}
2847      * @throws ArrayIndexOutOfBoundsException
2848      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2849      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2850      * @throws NullPointerException
</pre>
<hr />
<pre>
2860         int aLength = aToIndex - aFromIndex;
2861         int bLength = bToIndex - bFromIndex;
2862         if (aLength != bLength)
2863             return false;
2864 
2865         return ArraysSupport.mismatch(a, aFromIndex,
2866                                       b, bFromIndex, aLength) &lt; 0;
2867     }
2868 
2869     /**
2870      * Returns {@code true} if the two specified arrays of floats are
2871      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2872      * arrays contain the same number of elements, and all corresponding pairs
2873      * of elements in the two arrays are equal.  In other words, two arrays
2874      * are equal if they contain the same elements in the same order.  Also,
2875      * two array references are considered equal if both are {@code null}.
2876      *
2877      * Two floats {@code f1} and {@code f2} are considered equal if:
2878      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
2879      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2880      * {@code NaN} equals to itself, and 0.0f unequal to -0.0f.)</span>
2881      *
2882      * @param a one array to be tested for equality
2883      * @param a2 the other array to be tested for equality
2884      * @return {@code true} if the two arrays are equal
2885      * @see Float#equals(Object)
2886      */
2887     public static boolean equals(float[] a, float[] a2) {
2888         if (a==a2)
2889             return true;
2890         if (a==null || a2==null)
2891             return false;
2892 
2893         int length = a.length;
2894         if (a2.length != length)
2895             return false;
2896 
2897         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2898     }
2899 
2900     /**
2901      * Returns true if the two specified arrays of floats, over the specified
2902      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2903      *
2904      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2905      * each range is the same, and all corresponding pairs of elements over the
2906      * specified ranges in the two arrays are equal.  In other words, two arrays
2907      * are equal if they contain, over the specified ranges, the same elements
2908      * in the same order.
2909      *
2910      * &lt;p&gt;Two floats {@code f1} and {@code f2} are considered equal if:
2911      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
2912      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2913      * {@code NaN} equals to itself, and 0.0f unequal to -0.0f.)</span>
2914      *
2915      * @param a the first array to be tested for equality
2916      * @param aFromIndex the index (inclusive) of the first element in the
2917      *                   first array to be tested
2918      * @param aToIndex the index (exclusive) of the last element in the
2919      *                 first array to be tested
2920      * @param b the second array to be tested for equality
2921      * @param bFromIndex the index (inclusive) of the first element in the
2922      *                   second array to be tested
2923      * @param bToIndex the index (exclusive) of the last element in the
2924      *                 second array to be tested
2925      * @return {@code true} if the two arrays, over the specified ranges, are
2926      *         equal
2927      * @throws IllegalArgumentException
2928      *         if {@code aFromIndex &gt; aToIndex} or
2929      *         if {@code bFromIndex &gt; bToIndex}
2930      * @throws ArrayIndexOutOfBoundsException
2931      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2932      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2933      * @throws NullPointerException
</pre>
<hr />
<pre>
7476      * it follows that the relative index is only valid for the array with the
7477      * larger range.
7478      * Otherwise, there is no mismatch.
7479      *
7480      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7481      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7482      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7483      * prefix of length {@code pl} if the following expression is true:
7484      * &lt;pre&gt;{@code
7485      *     pl &gt;= 0 &amp;&amp;
7486      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7487      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7488      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7489      * }&lt;/pre&gt;
7490      * Note that a common prefix length of {@code 0} indicates that the first
7491      * elements from each array mismatch.
7492      *
7493      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7494      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7495      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7496      * if the following expression is true:</span>
7497      * &lt;pre&gt;{@code
7498      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7499      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7500      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7501      * }&lt;/pre&gt;
7502      *
7503      * @param a the first array to be tested for a mismatch
7504      * @param aFromIndex the index (inclusive) of the first element in the
7505      *                   first array to be tested
7506      * @param aToIndex the index (exclusive) of the last element in the
7507      *                 first array to be tested
7508      * @param b the second array to be tested for a mismatch
7509      * @param bFromIndex the index (inclusive) of the first element in the
7510      *                   second array to be tested
7511      * @param bToIndex the index (exclusive) of the last element in the
7512      *                 second array to be tested
7513      * @return the relative index of the first mismatch between the two arrays
7514      *         over the specified ranges, otherwise {@code -1}.
7515      * @throws IllegalArgumentException
7516      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7603      * it follows that the relative index is only valid for the array with the
7604      * larger range.
7605      * Otherwise, there is no mismatch.
7606      *
7607      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7608      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7609      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7610      * prefix of length {@code pl} if the following expression is true:
7611      * &lt;pre&gt;{@code
7612      *     pl &gt;= 0 &amp;&amp;
7613      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7614      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7615      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7616      * }&lt;/pre&gt;
7617      * Note that a common prefix length of {@code 0} indicates that the first
7618      * elements from each array mismatch.
7619      *
7620      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7621      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7622      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7623      * if the following expression is true:</span>
7624      * &lt;pre&gt;{@code
7625      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7626      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7627      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7628      * }&lt;/pre&gt;
7629      *
7630      * @param a the first array to be tested for a mismatch
7631      * @param aFromIndex the index (inclusive) of the first element in the
7632      *                   first array to be tested
7633      * @param aToIndex the index (exclusive) of the last element in the
7634      *                 first array to be tested
7635      * @param b the second array to be tested for a mismatch
7636      * @param bFromIndex the index (inclusive) of the first element in the
7637      *                   second array to be tested
7638      * @param bToIndex the index (exclusive) of the last element in the
7639      *                 second array to be tested
7640      * @return the relative index of the first mismatch between the two arrays
7641      *         over the specified ranges, otherwise {@code -1}.
7642      * @throws IllegalArgumentException
7643      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7730      * it follows that the relative index is only valid for the array with the
7731      * larger range.
7732      * Otherwise, there is no mismatch.
7733      *
7734      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7735      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7736      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7737      * prefix of length {@code pl} if the following expression is true:
7738      * &lt;pre&gt;{@code
7739      *     pl &gt;= 0 &amp;&amp;
7740      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7741      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7742      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7743      * }&lt;/pre&gt;
7744      * Note that a common prefix length of {@code 0} indicates that the first
7745      * elements from each array mismatch.
7746      *
7747      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7748      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7749      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7750      * if the following expression is true:</span>
7751      * &lt;pre&gt;{@code
7752      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7753      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7754      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7755      * }&lt;/pre&gt;
7756      *
7757      * @param a the first array to be tested for a mismatch
7758      * @param aFromIndex the index (inclusive) of the first element in the
7759      *                   first array to be tested
7760      * @param aToIndex the index (exclusive) of the last element in the
7761      *                 first array to be tested
7762      * @param b the second array to be tested for a mismatch
7763      * @param bFromIndex the index (inclusive) of the first element in the
7764      *                   second array to be tested
7765      * @param bToIndex the index (exclusive) of the last element in the
7766      *                 second array to be tested
7767      * @return the relative index of the first mismatch between the two arrays
7768      *         over the specified ranges, otherwise {@code -1}.
7769      * @throws IllegalArgumentException
7770      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7857      * it follows that the relative index is only valid for the array with the
7858      * larger range.
7859      * Otherwise, there is no mismatch.
7860      *
7861      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7862      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7863      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7864      * prefix of length {@code pl} if the following expression is true:
7865      * &lt;pre&gt;{@code
7866      *     pl &gt;= 0 &amp;&amp;
7867      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7868      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7869      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7870      * }&lt;/pre&gt;
7871      * Note that a common prefix length of {@code 0} indicates that the first
7872      * elements from each array mismatch.
7873      *
7874      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7875      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7876      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7877      * if the following expression is true:</span>
7878      * &lt;pre&gt;{@code
7879      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7880      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7881      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7882      * }&lt;/pre&gt;
7883      *
7884      * @param a the first array to be tested for a mismatch
7885      * @param aFromIndex the index (inclusive) of the first element in the
7886      *                   first array to be tested
7887      * @param aToIndex the index (exclusive) of the last element in the
7888      *                 first array to be tested
7889      * @param b the second array to be tested for a mismatch
7890      * @param bFromIndex the index (inclusive) of the first element in the
7891      *                   second array to be tested
7892      * @param bToIndex the index (exclusive) of the last element in the
7893      *                 second array to be tested
7894      * @return the relative index of the first mismatch between the two arrays
7895      *         over the specified ranges, otherwise {@code -1}.
7896      * @throws IllegalArgumentException
7897      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7984      * it follows that the relative index is only valid for the array with the
7985      * larger range.
7986      * Otherwise, there is no mismatch.
7987      *
7988      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7989      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7990      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7991      * prefix of length {@code pl} if the following expression is true:
7992      * &lt;pre&gt;{@code
7993      *     pl &gt;= 0 &amp;&amp;
7994      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7995      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7996      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7997      * }&lt;/pre&gt;
7998      * Note that a common prefix length of {@code 0} indicates that the first
7999      * elements from each array mismatch.
8000      *
8001      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8002      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8003      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8004      * if the following expression is true:</span>
8005      * &lt;pre&gt;{@code
8006      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8007      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8008      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8009      * }&lt;/pre&gt;
8010      *
8011      * @param a the first array to be tested for a mismatch
8012      * @param aFromIndex the index (inclusive) of the first element in the
8013      *                   first array to be tested
8014      * @param aToIndex the index (exclusive) of the last element in the
8015      *                 first array to be tested
8016      * @param b the second array to be tested for a mismatch
8017      * @param bFromIndex the index (inclusive) of the first element in the
8018      *                   second array to be tested
8019      * @param bToIndex the index (exclusive) of the last element in the
8020      *                 second array to be tested
8021      * @return the relative index of the first mismatch between the two arrays
8022      *         over the specified ranges, otherwise {@code -1}.
8023      * @throws IllegalArgumentException
8024      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8111      * it follows that the relative index is only valid for the array with the
8112      * larger range.
8113      * Otherwise, there is no mismatch.
8114      *
8115      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8116      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8117      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8118      * prefix of length {@code pl} if the following expression is true:
8119      * &lt;pre&gt;{@code
8120      *     pl &gt;= 0 &amp;&amp;
8121      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8122      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8123      *     a[aFromIndex + pl] != b[bFromIndex + pl]
8124      * }&lt;/pre&gt;
8125      * Note that a common prefix length of {@code 0} indicates that the first
8126      * elements from each array mismatch.
8127      *
8128      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8129      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8130      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8131      * if the following expression is true:</span>
8132      * &lt;pre&gt;{@code
8133      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8134      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8135      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8136      * }&lt;/pre&gt;
8137      *
8138      * @param a the first array to be tested for a mismatch
8139      * @param aFromIndex the index (inclusive) of the first element in the
8140      *                   first array to be tested
8141      * @param aToIndex the index (exclusive) of the last element in the
8142      *                 first array to be tested
8143      * @param b the second array to be tested for a mismatch
8144      * @param bFromIndex the index (inclusive) of the first element in the
8145      *                   second array to be tested
8146      * @param bToIndex the index (exclusive) of the last element in the
8147      *                 second array to be tested
8148      * @return the relative index of the first mismatch between the two arrays
8149      *         over the specified ranges, otherwise {@code -1}.
8150      * @throws IllegalArgumentException
8151      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8238      * it follows that the relative index is only valid for the array with the
8239      * larger range.
8240      * Otherwise, there is no mismatch.
8241      *
8242      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8243      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8244      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8245      * prefix of length {@code pl} if the following expression is true:
8246      * &lt;pre&gt;{@code
8247      *     pl &gt;= 0 &amp;&amp;
8248      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8249      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8250      *     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8251      * }&lt;/pre&gt;
8252      * Note that a common prefix length of {@code 0} indicates that the first
8253      * elements from each array mismatch.
8254      *
8255      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8256      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8257      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8258      * if the following expression is true:</span>
8259      * &lt;pre&gt;{@code
8260      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8261      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8262      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8263      * }&lt;/pre&gt;
8264      *
8265      * @param a the first array to be tested for a mismatch
8266      * @param aFromIndex the index (inclusive) of the first element in the
8267      *                   first array to be tested
8268      * @param aToIndex the index (exclusive) of the last element in the
8269      *                 first array to be tested
8270      * @param b the second array to be tested for a mismatch
8271      * @param bFromIndex the index (inclusive) of the first element in the
8272      *                   second array to be tested
8273      * @param bToIndex the index (exclusive) of the last element in the
8274      *                 second array to be tested
8275      * @return the relative index of the first mismatch between the two arrays
8276      *         over the specified ranges, otherwise {@code -1}.
8277      * @throws IllegalArgumentException
8278      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8365      * it follows that the relative index is only valid for the array with the
8366      * larger range.
8367      * Otherwise, there is no mismatch.
8368      *
8369      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8370      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8371      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8372      * prefix of length {@code pl} if the following expression is true:
8373      * &lt;pre&gt;{@code
8374      *     pl &gt;= 0 &amp;&amp;
8375      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8376      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8377      *     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8378      * }&lt;/pre&gt;
8379      * Note that a common prefix length of {@code 0} indicates that the first
8380      * elements from each array mismatch.
8381      *
8382      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8383      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8384      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8385      * if the following expression is true:</span>
8386      * &lt;pre&gt;{@code
8387      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8388      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8389      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8390      * }&lt;/pre&gt;
8391      *
8392      * @param a the first array to be tested for a mismatch
8393      * @param aFromIndex the index (inclusive) of the first element in the
8394      *                   first array to be tested
8395      * @param aToIndex the index (exclusive) of the last element in the
8396      *                 first array to be tested
8397      * @param b the second array to be tested for a mismatch
8398      * @param bFromIndex the index (inclusive) of the first element in the
8399      *                   second array to be tested
8400      * @param bToIndex the index (exclusive) of the last element in the
8401      *                 second array to be tested
8402      * @return the relative index of the first mismatch between the two arrays
8403      *         over the specified ranges, otherwise {@code -1}.
8404      * @throws IllegalArgumentException
8405      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8496      * it follows that the relative index is only valid for the array with the
8497      * larger range.
8498      * Otherwise, there is no mismatch.
8499      *
8500      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8501      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8502      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8503      * prefix of length {@code pl} if the following expression is true:
8504      * &lt;pre&gt;{@code
8505      *     pl &gt;= 0 &amp;&amp;
8506      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8507      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8508      *     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])
8509      * }&lt;/pre&gt;
8510      * Note that a common prefix length of {@code 0} indicates that the first
8511      * elements from each array mismatch.
8512      *
8513      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8514      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8515      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8516      * if the following expression is true:</span>
8517      * &lt;pre&gt;{@code
8518      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8519      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8520      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8521      * }&lt;/pre&gt;
8522      *
8523      * @param a the first array to be tested for a mismatch
8524      * @param aFromIndex the index (inclusive) of the first element in the
8525      *                   first array to be tested
8526      * @param aToIndex the index (exclusive) of the last element in the
8527      *                 first array to be tested
8528      * @param b the second array to be tested for a mismatch
8529      * @param bFromIndex the index (inclusive) of the first element in the
8530      *                   second array to be tested
8531      * @param bToIndex the index (exclusive) of the last element in the
8532      *                 second array to be tested
8533      * @return the relative index of the first mismatch between the two arrays
8534      *         over the specified ranges, otherwise {@code -1}.
8535      * @throws IllegalArgumentException
8536      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8642      * it follows that the relative index is only valid for the array with the
8643      * larger range.
8644      * Otherwise, there is no mismatch.
8645      *
8646      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8647      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8648      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8649      * prefix of length {@code pl} if the following expression is true:
8650      * &lt;pre&gt;{@code
8651      *     pl &gt;= 0 &amp;&amp;
8652      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8653      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &amp;&amp;
8654      *     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8655      * }&lt;/pre&gt;
8656      * Note that a common prefix length of {@code 0} indicates that the first
8657      * elements from each array mismatch.
8658      *
8659      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8660      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8661      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8662      * if the following expression is true:</span>
8663      * &lt;pre&gt;{@code
8664      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8665      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8666      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8667      *                   cmp)
8668      * }&lt;/pre&gt;
8669      *
8670      * @param a the first array to be tested for a mismatch
8671      * @param aFromIndex the index (inclusive) of the first element in the
8672      *                   first array to be tested
8673      * @param aToIndex the index (exclusive) of the last element in the
8674      *                 first array to be tested
8675      * @param b the second array to be tested for a mismatch
8676      * @param bFromIndex the index (inclusive) of the first element in the
8677      *                   second array to be tested
8678      * @param bToIndex the index (exclusive) of the last element in the
8679      *                 second array to be tested
8680      * @param cmp the comparator to compare array elements
8681      * @param &lt;T&gt; the type of array elements
8682      * @return the relative index of the first mismatch between the two arrays
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
2777         int bLength = bToIndex - bFromIndex;
2778         if (aLength != bLength)
2779             return false;
2780 
2781         return ArraysSupport.mismatch(a, aFromIndex,
2782                                       b, bFromIndex,
2783                                       aLength) &lt; 0;
2784     }
2785 
2786     /**
2787      * Returns {@code true} if the two specified arrays of doubles are
2788      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2789      * arrays contain the same number of elements, and all corresponding pairs
2790      * of elements in the two arrays are equal.  In other words, two arrays
2791      * are equal if they contain the same elements in the same order.  Also,
2792      * two array references are considered equal if both are {@code null}.
2793      *
2794      * Two doubles {@code d1} and {@code d2} are considered equal if:
2795      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
2796      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2797      * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)</span>
2798      *
2799      * @param a one array to be tested for equality
2800      * @param a2 the other array to be tested for equality
2801      * @return {@code true} if the two arrays are equal
2802      * @see Double#equals(Object)
2803      */
2804     public static boolean equals(double[] a, double[] a2) {
2805         if (a==a2)
2806             return true;
2807         if (a==null || a2==null)
2808             return false;
2809 
2810         int length = a.length;
2811         if (a2.length != length)
2812             return false;
2813 
2814         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2815     }
2816 
2817     /**
2818      * Returns true if the two specified arrays of doubles, over the specified
2819      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2820      *
2821      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2822      * each range is the same, and all corresponding pairs of elements over the
2823      * specified ranges in the two arrays are equal.  In other words, two arrays
2824      * are equal if they contain, over the specified ranges, the same elements
2825      * in the same order.
2826      *
2827      * &lt;p&gt;Two doubles {@code d1} and {@code d2} are considered equal if:
2828      * &lt;pre&gt;    {@code new Double(d1).equals(new Double(d2))}&lt;/pre&gt;
2829      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2830      * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)</span>
2831      *
2832      * @param a the first array to be tested for equality
2833      * @param aFromIndex the index (inclusive) of the first element in the
2834      *                   first array to be tested
2835      * @param aToIndex the index (exclusive) of the last element in the
2836      *                 first array to be tested
2837      * @param b the second array to be tested for equality
2838      * @param bFromIndex the index (inclusive) of the first element in the
2839      *                   second array to be tested
2840      * @param bToIndex the index (exclusive) of the last element in the
2841      *                 second array to be tested
2842      * @return {@code true} if the two arrays, over the specified ranges, are
2843      *         equal
2844      * @throws IllegalArgumentException
2845      *         if {@code aFromIndex &gt; aToIndex} or
2846      *         if {@code bFromIndex &gt; bToIndex}
2847      * @throws ArrayIndexOutOfBoundsException
2848      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2849      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2850      * @throws NullPointerException
</pre>
<hr />
<pre>
2860         int aLength = aToIndex - aFromIndex;
2861         int bLength = bToIndex - bFromIndex;
2862         if (aLength != bLength)
2863             return false;
2864 
2865         return ArraysSupport.mismatch(a, aFromIndex,
2866                                       b, bFromIndex, aLength) &lt; 0;
2867     }
2868 
2869     /**
2870      * Returns {@code true} if the two specified arrays of floats are
2871      * &lt;i&gt;equal&lt;/i&gt; to one another.  Two arrays are considered equal if both
2872      * arrays contain the same number of elements, and all corresponding pairs
2873      * of elements in the two arrays are equal.  In other words, two arrays
2874      * are equal if they contain the same elements in the same order.  Also,
2875      * two array references are considered equal if both are {@code null}.
2876      *
2877      * Two floats {@code f1} and {@code f2} are considered equal if:
2878      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
2879      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2880      * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)</span>
2881      *
2882      * @param a one array to be tested for equality
2883      * @param a2 the other array to be tested for equality
2884      * @return {@code true} if the two arrays are equal
2885      * @see Float#equals(Object)
2886      */
2887     public static boolean equals(float[] a, float[] a2) {
2888         if (a==a2)
2889             return true;
2890         if (a==null || a2==null)
2891             return false;
2892 
2893         int length = a.length;
2894         if (a2.length != length)
2895             return false;
2896 
2897         return ArraysSupport.mismatch(a, a2, length) &lt; 0;
2898     }
2899 
2900     /**
2901      * Returns true if the two specified arrays of floats, over the specified
2902      * ranges, are &lt;i&gt;equal&lt;/i&gt; to one another.
2903      *
2904      * &lt;p&gt;Two arrays are considered equal if the number of elements covered by
2905      * each range is the same, and all corresponding pairs of elements over the
2906      * specified ranges in the two arrays are equal.  In other words, two arrays
2907      * are equal if they contain, over the specified ranges, the same elements
2908      * in the same order.
2909      *
2910      * &lt;p&gt;Two floats {@code f1} and {@code f2} are considered equal if:
2911      * &lt;pre&gt;    {@code new Float(f1).equals(new Float(f2))}&lt;/pre&gt;
2912      * (Unlike the {@code ==} operator, this method considers
<span class="line-modified">2913      * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)</span>
2914      *
2915      * @param a the first array to be tested for equality
2916      * @param aFromIndex the index (inclusive) of the first element in the
2917      *                   first array to be tested
2918      * @param aToIndex the index (exclusive) of the last element in the
2919      *                 first array to be tested
2920      * @param b the second array to be tested for equality
2921      * @param bFromIndex the index (inclusive) of the first element in the
2922      *                   second array to be tested
2923      * @param bToIndex the index (exclusive) of the last element in the
2924      *                 second array to be tested
2925      * @return {@code true} if the two arrays, over the specified ranges, are
2926      *         equal
2927      * @throws IllegalArgumentException
2928      *         if {@code aFromIndex &gt; aToIndex} or
2929      *         if {@code bFromIndex &gt; bToIndex}
2930      * @throws ArrayIndexOutOfBoundsException
2931      *         if {@code aFromIndex &lt; 0 or aToIndex &gt; a.length} or
2932      *         if {@code bFromIndex &lt; 0 or bToIndex &gt; b.length}
2933      * @throws NullPointerException
</pre>
<hr />
<pre>
7476      * it follows that the relative index is only valid for the array with the
7477      * larger range.
7478      * Otherwise, there is no mismatch.
7479      *
7480      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7481      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7482      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7483      * prefix of length {@code pl} if the following expression is true:
7484      * &lt;pre&gt;{@code
7485      *     pl &gt;= 0 &amp;&amp;
7486      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7487      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7488      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7489      * }&lt;/pre&gt;
7490      * Note that a common prefix length of {@code 0} indicates that the first
7491      * elements from each array mismatch.
7492      *
7493      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7494      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7495      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7496      * prefix if the following expression is true:</span>
7497      * &lt;pre&gt;{@code
7498      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7499      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7500      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7501      * }&lt;/pre&gt;
7502      *
7503      * @param a the first array to be tested for a mismatch
7504      * @param aFromIndex the index (inclusive) of the first element in the
7505      *                   first array to be tested
7506      * @param aToIndex the index (exclusive) of the last element in the
7507      *                 first array to be tested
7508      * @param b the second array to be tested for a mismatch
7509      * @param bFromIndex the index (inclusive) of the first element in the
7510      *                   second array to be tested
7511      * @param bToIndex the index (exclusive) of the last element in the
7512      *                 second array to be tested
7513      * @return the relative index of the first mismatch between the two arrays
7514      *         over the specified ranges, otherwise {@code -1}.
7515      * @throws IllegalArgumentException
7516      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7603      * it follows that the relative index is only valid for the array with the
7604      * larger range.
7605      * Otherwise, there is no mismatch.
7606      *
7607      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7608      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7609      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7610      * prefix of length {@code pl} if the following expression is true:
7611      * &lt;pre&gt;{@code
7612      *     pl &gt;= 0 &amp;&amp;
7613      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7614      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7615      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7616      * }&lt;/pre&gt;
7617      * Note that a common prefix length of {@code 0} indicates that the first
7618      * elements from each array mismatch.
7619      *
7620      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7621      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7622      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7623      * prefix if the following expression is true:</span>
7624      * &lt;pre&gt;{@code
7625      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7626      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7627      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7628      * }&lt;/pre&gt;
7629      *
7630      * @param a the first array to be tested for a mismatch
7631      * @param aFromIndex the index (inclusive) of the first element in the
7632      *                   first array to be tested
7633      * @param aToIndex the index (exclusive) of the last element in the
7634      *                 first array to be tested
7635      * @param b the second array to be tested for a mismatch
7636      * @param bFromIndex the index (inclusive) of the first element in the
7637      *                   second array to be tested
7638      * @param bToIndex the index (exclusive) of the last element in the
7639      *                 second array to be tested
7640      * @return the relative index of the first mismatch between the two arrays
7641      *         over the specified ranges, otherwise {@code -1}.
7642      * @throws IllegalArgumentException
7643      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7730      * it follows that the relative index is only valid for the array with the
7731      * larger range.
7732      * Otherwise, there is no mismatch.
7733      *
7734      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7735      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7736      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7737      * prefix of length {@code pl} if the following expression is true:
7738      * &lt;pre&gt;{@code
7739      *     pl &gt;= 0 &amp;&amp;
7740      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7741      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7742      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7743      * }&lt;/pre&gt;
7744      * Note that a common prefix length of {@code 0} indicates that the first
7745      * elements from each array mismatch.
7746      *
7747      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7748      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7749      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7750      * prefix if the following expression is true:</span>
7751      * &lt;pre&gt;{@code
7752      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7753      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7754      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7755      * }&lt;/pre&gt;
7756      *
7757      * @param a the first array to be tested for a mismatch
7758      * @param aFromIndex the index (inclusive) of the first element in the
7759      *                   first array to be tested
7760      * @param aToIndex the index (exclusive) of the last element in the
7761      *                 first array to be tested
7762      * @param b the second array to be tested for a mismatch
7763      * @param bFromIndex the index (inclusive) of the first element in the
7764      *                   second array to be tested
7765      * @param bToIndex the index (exclusive) of the last element in the
7766      *                 second array to be tested
7767      * @return the relative index of the first mismatch between the two arrays
7768      *         over the specified ranges, otherwise {@code -1}.
7769      * @throws IllegalArgumentException
7770      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7857      * it follows that the relative index is only valid for the array with the
7858      * larger range.
7859      * Otherwise, there is no mismatch.
7860      *
7861      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7862      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7863      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7864      * prefix of length {@code pl} if the following expression is true:
7865      * &lt;pre&gt;{@code
7866      *     pl &gt;= 0 &amp;&amp;
7867      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7868      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7869      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7870      * }&lt;/pre&gt;
7871      * Note that a common prefix length of {@code 0} indicates that the first
7872      * elements from each array mismatch.
7873      *
7874      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7875      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7876      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">7877      * prefix if the following expression is true:</span>
7878      * &lt;pre&gt;{@code
7879      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
7880      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
7881      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
7882      * }&lt;/pre&gt;
7883      *
7884      * @param a the first array to be tested for a mismatch
7885      * @param aFromIndex the index (inclusive) of the first element in the
7886      *                   first array to be tested
7887      * @param aToIndex the index (exclusive) of the last element in the
7888      *                 first array to be tested
7889      * @param b the second array to be tested for a mismatch
7890      * @param bFromIndex the index (inclusive) of the first element in the
7891      *                   second array to be tested
7892      * @param bToIndex the index (exclusive) of the last element in the
7893      *                 second array to be tested
7894      * @return the relative index of the first mismatch between the two arrays
7895      *         over the specified ranges, otherwise {@code -1}.
7896      * @throws IllegalArgumentException
7897      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
7984      * it follows that the relative index is only valid for the array with the
7985      * larger range.
7986      * Otherwise, there is no mismatch.
7987      *
7988      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
7989      * ranges [{@code aFromIndex}, {@code atoIndex}) and
7990      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
7991      * prefix of length {@code pl} if the following expression is true:
7992      * &lt;pre&gt;{@code
7993      *     pl &gt;= 0 &amp;&amp;
7994      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
7995      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
7996      *     a[aFromIndex + pl] != b[bFromIndex + pl]
7997      * }&lt;/pre&gt;
7998      * Note that a common prefix length of {@code 0} indicates that the first
7999      * elements from each array mismatch.
8000      *
8001      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8002      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8003      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8004      * prefix if the following expression is true:</span>
8005      * &lt;pre&gt;{@code
8006      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8007      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8008      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8009      * }&lt;/pre&gt;
8010      *
8011      * @param a the first array to be tested for a mismatch
8012      * @param aFromIndex the index (inclusive) of the first element in the
8013      *                   first array to be tested
8014      * @param aToIndex the index (exclusive) of the last element in the
8015      *                 first array to be tested
8016      * @param b the second array to be tested for a mismatch
8017      * @param bFromIndex the index (inclusive) of the first element in the
8018      *                   second array to be tested
8019      * @param bToIndex the index (exclusive) of the last element in the
8020      *                 second array to be tested
8021      * @return the relative index of the first mismatch between the two arrays
8022      *         over the specified ranges, otherwise {@code -1}.
8023      * @throws IllegalArgumentException
8024      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8111      * it follows that the relative index is only valid for the array with the
8112      * larger range.
8113      * Otherwise, there is no mismatch.
8114      *
8115      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8116      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8117      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8118      * prefix of length {@code pl} if the following expression is true:
8119      * &lt;pre&gt;{@code
8120      *     pl &gt;= 0 &amp;&amp;
8121      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8122      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8123      *     a[aFromIndex + pl] != b[bFromIndex + pl]
8124      * }&lt;/pre&gt;
8125      * Note that a common prefix length of {@code 0} indicates that the first
8126      * elements from each array mismatch.
8127      *
8128      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8129      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8130      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8131      * prefix if the following expression is true:</span>
8132      * &lt;pre&gt;{@code
8133      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8134      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8135      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8136      * }&lt;/pre&gt;
8137      *
8138      * @param a the first array to be tested for a mismatch
8139      * @param aFromIndex the index (inclusive) of the first element in the
8140      *                   first array to be tested
8141      * @param aToIndex the index (exclusive) of the last element in the
8142      *                 first array to be tested
8143      * @param b the second array to be tested for a mismatch
8144      * @param bFromIndex the index (inclusive) of the first element in the
8145      *                   second array to be tested
8146      * @param bToIndex the index (exclusive) of the last element in the
8147      *                 second array to be tested
8148      * @return the relative index of the first mismatch between the two arrays
8149      *         over the specified ranges, otherwise {@code -1}.
8150      * @throws IllegalArgumentException
8151      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8238      * it follows that the relative index is only valid for the array with the
8239      * larger range.
8240      * Otherwise, there is no mismatch.
8241      *
8242      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8243      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8244      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8245      * prefix of length {@code pl} if the following expression is true:
8246      * &lt;pre&gt;{@code
8247      *     pl &gt;= 0 &amp;&amp;
8248      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8249      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8250      *     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8251      * }&lt;/pre&gt;
8252      * Note that a common prefix length of {@code 0} indicates that the first
8253      * elements from each array mismatch.
8254      *
8255      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8256      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8257      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8258      * prefix if the following expression is true:</span>
8259      * &lt;pre&gt;{@code
8260      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8261      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8262      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8263      * }&lt;/pre&gt;
8264      *
8265      * @param a the first array to be tested for a mismatch
8266      * @param aFromIndex the index (inclusive) of the first element in the
8267      *                   first array to be tested
8268      * @param aToIndex the index (exclusive) of the last element in the
8269      *                 first array to be tested
8270      * @param b the second array to be tested for a mismatch
8271      * @param bFromIndex the index (inclusive) of the first element in the
8272      *                   second array to be tested
8273      * @param bToIndex the index (exclusive) of the last element in the
8274      *                 second array to be tested
8275      * @return the relative index of the first mismatch between the two arrays
8276      *         over the specified ranges, otherwise {@code -1}.
8277      * @throws IllegalArgumentException
8278      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8365      * it follows that the relative index is only valid for the array with the
8366      * larger range.
8367      * Otherwise, there is no mismatch.
8368      *
8369      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8370      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8371      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8372      * prefix of length {@code pl} if the following expression is true:
8373      * &lt;pre&gt;{@code
8374      *     pl &gt;= 0 &amp;&amp;
8375      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8376      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8377      *     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8378      * }&lt;/pre&gt;
8379      * Note that a common prefix length of {@code 0} indicates that the first
8380      * elements from each array mismatch.
8381      *
8382      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8383      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8384      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8385      * prefix if the following expression is true:</span>
8386      * &lt;pre&gt;{@code
8387      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8388      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8389      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8390      * }&lt;/pre&gt;
8391      *
8392      * @param a the first array to be tested for a mismatch
8393      * @param aFromIndex the index (inclusive) of the first element in the
8394      *                   first array to be tested
8395      * @param aToIndex the index (exclusive) of the last element in the
8396      *                 first array to be tested
8397      * @param b the second array to be tested for a mismatch
8398      * @param bFromIndex the index (inclusive) of the first element in the
8399      *                   second array to be tested
8400      * @param bToIndex the index (exclusive) of the last element in the
8401      *                 second array to be tested
8402      * @return the relative index of the first mismatch between the two arrays
8403      *         over the specified ranges, otherwise {@code -1}.
8404      * @throws IllegalArgumentException
8405      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8496      * it follows that the relative index is only valid for the array with the
8497      * larger range.
8498      * Otherwise, there is no mismatch.
8499      *
8500      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8501      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8502      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8503      * prefix of length {@code pl} if the following expression is true:
8504      * &lt;pre&gt;{@code
8505      *     pl &gt;= 0 &amp;&amp;
8506      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8507      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
8508      *     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])
8509      * }&lt;/pre&gt;
8510      * Note that a common prefix length of {@code 0} indicates that the first
8511      * elements from each array mismatch.
8512      *
8513      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8514      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8515      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8516      * prefix if the following expression is true:</span>
8517      * &lt;pre&gt;{@code
8518      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8519      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8520      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
8521      * }&lt;/pre&gt;
8522      *
8523      * @param a the first array to be tested for a mismatch
8524      * @param aFromIndex the index (inclusive) of the first element in the
8525      *                   first array to be tested
8526      * @param aToIndex the index (exclusive) of the last element in the
8527      *                 first array to be tested
8528      * @param b the second array to be tested for a mismatch
8529      * @param bFromIndex the index (inclusive) of the first element in the
8530      *                   second array to be tested
8531      * @param bToIndex the index (exclusive) of the last element in the
8532      *                 second array to be tested
8533      * @return the relative index of the first mismatch between the two arrays
8534      *         over the specified ranges, otherwise {@code -1}.
8535      * @throws IllegalArgumentException
8536      *         if {@code aFromIndex &gt; aToIndex} or
</pre>
<hr />
<pre>
8642      * it follows that the relative index is only valid for the array with the
8643      * larger range.
8644      * Otherwise, there is no mismatch.
8645      *
8646      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8647      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8648      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common
8649      * prefix of length {@code pl} if the following expression is true:
8650      * &lt;pre&gt;{@code
8651      *     pl &gt;= 0 &amp;&amp;
8652      *     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
8653      *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &amp;&amp;
8654      *     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0
8655      * }&lt;/pre&gt;
8656      * Note that a common prefix length of {@code 0} indicates that the first
8657      * elements from each array mismatch.
8658      *
8659      * &lt;p&gt;Two non-{@code null} arrays, {@code a} and {@code b} with specified
8660      * ranges [{@code aFromIndex}, {@code atoIndex}) and
8661      * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper
<span class="line-modified">8662      * prefix if the following expression is true:</span>
8663      * &lt;pre&gt;{@code
8664      *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
8665      *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8666      *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
8667      *                   cmp)
8668      * }&lt;/pre&gt;
8669      *
8670      * @param a the first array to be tested for a mismatch
8671      * @param aFromIndex the index (inclusive) of the first element in the
8672      *                   first array to be tested
8673      * @param aToIndex the index (exclusive) of the last element in the
8674      *                 first array to be tested
8675      * @param b the second array to be tested for a mismatch
8676      * @param bFromIndex the index (inclusive) of the first element in the
8677      *                   second array to be tested
8678      * @param bToIndex the index (exclusive) of the last element in the
8679      *                 second array to be tested
8680      * @param cmp the comparator to compare array elements
8681      * @param &lt;T&gt; the type of array elements
8682      * @return the relative index of the first mismatch between the two arrays
</pre>
</td>
</tr>
</table>
<center><a href="AbstractList.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="BitSet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
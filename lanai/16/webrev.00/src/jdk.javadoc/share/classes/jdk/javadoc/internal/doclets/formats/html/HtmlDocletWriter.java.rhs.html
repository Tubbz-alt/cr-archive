<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.LinkedList;
  32 import java.util.List;
  33 import java.util.ListIterator;
  34 import java.util.Locale;
  35 import java.util.Map;
  36 import java.util.Set;
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
  54 import javax.lang.model.util.SimpleElementVisitor14;
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<a name="1" id="anc1"></a><span class="line-modified">  83 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;</span>
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 104 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 105 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 106 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 107 
 108 import static com.sun.source.doctree.DocTree.Kind.CODE;
 109 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK;
 111 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 112 import static com.sun.source.doctree.DocTree.Kind.SEE;
 113 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 114 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 115 
 116 
 117 /**
 118  * Class for the Html Format Code Generation specific to JavaDoc.
 119  * This Class contains methods related to the Html Code Generation which
 120  * are used extensively while generating the entire documentation.
 121  *
 122  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 123  *  If you write code that depends on this, you do so at your own risk.
 124  *  This code and its internal interfaces are subject to change or
 125  *  deletion without notice.&lt;/b&gt;
 126  */
 127 public class HtmlDocletWriter {
 128 
 129     /**
 130      * Relative path from the file getting generated to the destination
 131      * directory. For example, if the file getting generated is
 132      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 133      * This string can be empty if the file getting generated is in
 134      * the destination directory.
 135      */
 136     public final DocPath pathToRoot;
 137 
 138     /**
 139      * Platform-independent path from the current or the
 140      * destination directory to the file getting generated.
 141      * Used when creating the file.
 142      */
 143     public final DocPath path;
 144 
 145     /**
 146      * Name of the file getting generated. If the file getting generated is
 147      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 148      */
 149     public final DocPath filename;
 150 
 151     /**
 152      * The global configuration information for this run.
 153      */
 154     public final HtmlConfiguration configuration;
 155 
<a name="2" id="anc2"></a><span class="line-added"> 156     protected final SearchIndexItems searchItems;</span>
<span class="line-added"> 157 </span>
 158     protected final HtmlOptions options;
 159 
 160     protected final Utils utils;
 161 
 162     protected final Contents contents;
 163 
 164     protected final Messages messages;
 165 
 166     protected final Resources resources;
 167 
 168     protected final Links links;
 169 
 170     protected final DocPaths docPaths;
 171 
 172     /**
 173      * To check whether annotation heading is printed or not.
 174      */
 175     protected boolean printedAnnotationHeading = false;
 176 
 177     /**
 178      * To check whether annotation field heading is printed or not.
 179      */
 180     protected boolean printedAnnotationFieldHeading = false;
 181 
 182     /**
 183      * To check whether the repeated annotations is documented or not.
 184      */
 185     private boolean isAnnotationDocumented = false;
 186 
 187     /**
 188      * To check whether the container annotations is documented or not.
 189      */
 190     private boolean isContainerDocumented = false;
 191 
 192     /**
 193      * The window title of this file.
 194      */
 195     protected String winTitle;
 196 
 197     protected Script mainBodyScript;
 198 
 199     /**
 200      * A table of the anchors used for at-index and related tags,
 201      * so that they can be made unique by appending a suitable suffix.
 202      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 203      * to avoid generating duplicates.)
 204      */
 205     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 206 
 207     /**
<a name="3" id="anc3"></a><span class="line-modified"> 208      * Creates an {@code HtmlDocletWriter}.</span>
 209      *
 210      * @param configuration the configuration for this doclet
 211      * @param path the file to be generated.
 212      */
 213     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 214         this.configuration = configuration;
<a name="4" id="anc4"></a><span class="line-added"> 215         this.searchItems = configuration.searchItems;</span>
 216         this.options = configuration.getOptions();
 217         this.contents = configuration.contents;
 218         this.messages = configuration.messages;
 219         this.resources = configuration.docResources;
 220         this.links = new Links(path);
 221         this.utils = configuration.utils;
 222         this.path = path;
 223         this.pathToRoot = path.parent().invert();
 224         this.filename = path.basename();
 225         this.docPaths = configuration.docPaths;
 226         this.mainBodyScript = new Script();
 227 
 228         messages.notice(&quot;doclet.Generating_0&quot;,
 229             DocFile.createFileForOutput(configuration, path).getPath());
 230     }
 231 
 232     /**
 233      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 234      * as -header, -footer, -top and -bottom, and when converting a relative
 235      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 236      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 237      * comments.)
 238      * &lt;p&gt;
 239      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 240      * destination directory from the directory where the file is being
 241      * written, looping to handle all such tags in htmlstr.
 242      * &lt;p&gt;
 243      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 244      * the HTML page for source file p/C1.java is being generated, the
 245      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 246      * the relative path from docs/p/ to docs/ (the document root).
 247      * &lt;p&gt;
 248      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 249      * to prevent the inline tag from being interpreted.
 250      */
 251     public String replaceDocRootDir(String htmlstr) {
 252         // Return if no inline tags exist
 253         int index = htmlstr.indexOf(&quot;{@&quot;);
 254         if (index &lt; 0) {
 255             return htmlstr;
 256         }
 257         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 258         if (!docrootMatcher.find()) {
 259             return htmlstr;
 260         }
 261         StringBuilder buf = new StringBuilder();
 262         int prevEnd = 0;
 263         do {
 264             int match = docrootMatcher.start();
 265             // append htmlstr up to start of next {@docroot}
 266             buf.append(htmlstr.substring(prevEnd, match));
 267             prevEnd = docrootMatcher.end();
 268             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {
 269                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 270                 buf.append(options.docrootParent());
 271                 prevEnd += 3;
 272             } else {
 273                 // Insert relative path where {@docRoot} was located
 274                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 275             }
 276             // Append slash if next character is not a slash
 277             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 278                 buf.append(&#39;/&#39;);
 279             }
 280         } while (docrootMatcher.find());
 281         buf.append(htmlstr.substring(prevEnd));
 282         return buf.toString();
 283     }
 284     //where:
 285         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 286         private static final Pattern docrootPattern =
 287                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 288 
<a name="5" id="anc5"></a>























 289 
 290     /**
 291      * Add method information.
 292      *
 293      * @param method the method to be documented
 294      * @param dl the content tree to which the method information will be added
 295      */
 296     private void addMethodInfo(ExecutableElement method, Content dl) {
 297         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 298         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 299         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 300         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 301         // Check whether there is any implementation or overridden info to be
 302         // printed. If no overridden or implementation info needs to be
 303         // printed, do not print this section.
 304         if ((!intfacs.isEmpty()
 305                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 306                 || overriddenMethod != null) {
 307             MethodWriterImpl.addImplementsInfo(this, method, dl);
 308             if (overriddenMethod != null) {
 309                 MethodWriterImpl.addOverridden(this,
 310                         utils.overriddenType(method),
 311                         overriddenMethod,
 312                         dl);
 313             }
 314         }
 315     }
 316 
 317     /**
 318      * Adds the tags information.
 319      *
 320      * @param e the Element for which the tags will be generated
<a name="6" id="anc6"></a><span class="line-modified"> 321      * @param htmlTree the documentation tree to which the tags will be added</span>
 322      */
<a name="7" id="anc7"></a><span class="line-modified"> 323     protected void addTagsInfo(Element e, Content htmlTree) {</span>
 324         if (options.noComment()) {
 325             return;
 326         }
<a name="8" id="anc8"></a><span class="line-modified"> 327         HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);</span>
 328         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 329             addMethodInfo((ExecutableElement)e, dl);
 330         }
 331         Content output = new ContentBuilder();
 332         TagletWriter.genTagOutput(configuration.tagletManager, e,
 333             configuration.tagletManager.getBlockTaglets(e),
 334                 getTagletWriterInstance(false), output);
 335         dl.add(output);
<a name="9" id="anc9"></a><span class="line-modified"> 336         htmlTree.add(dl);</span>
 337     }
 338 
 339     /**
 340      * Check whether there are any tags for Serialization Overview
 341      * section to be printed.
 342      *
 343      * @param field the VariableElement object to check for tags.
 344      * @return true if there are tags to be printed else return false.
 345      */
 346     protected boolean hasSerializationOverviewTags(VariableElement field) {
 347         Content output = new ContentBuilder();
 348         TagletWriter.genTagOutput(configuration.tagletManager, field,
 349                 configuration.tagletManager.getBlockTaglets(field),
 350                 getTagletWriterInstance(false), output);
 351         return !output.isEmpty();
 352     }
 353 
 354     /**
 355      * Returns a TagletWriter that knows how to write HTML.
 356      *
 357      * @param isFirstSentence  true if we want to write the first sentence
 358      * @return a TagletWriter that knows how to write HTML.
 359      */
 360     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 361         return new TagletWriterImpl(this, isFirstSentence);
 362     }
 363 
 364     /**
 365      * Returns a TagletWriter that knows how to write HTML.
 366      *
 367      * @param isFirstSentence  true if we want to write the first sentence
 368      * @param inSummary  true if tags are to be added in a summary section
 369      * @return a TagletWriter
 370      */
 371     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 372         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 373     }
 374 
 375     /**
 376      * Generates the HTML document tree and prints it out.
 377      *
 378      * @param metakeywords Array of String keywords for META tag. Each element
 379      *                     of the array is assigned to a separate META tag.
 380      *                     Pass in null for no array
 381      * @param description the content for the description META tag.
 382      * @param body the body htmltree to be included in the document
 383      * @throws DocFileIOException if there is a problem writing the file
 384      */
 385     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 386                                   String description,
 387                                   Content body)
 388             throws DocFileIOException {
 389         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);
 390     }
 391 
 392     /**
 393      * Generates the HTML document tree and prints it out.
 394      *
 395      * @param metakeywords Array of String keywords for META tag. Each element
 396      *                     of the array is assigned to a separate META tag.
 397      *                     Pass in null for no array
 398      * @param description the content for the description META tag.
 399      * @param localStylesheets local stylesheets to be included in the HEAD element
 400      * @param body the body htmltree to be included in the document
 401      * @throws DocFileIOException if there is a problem writing the file
 402      */
 403     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 404                                   String description,
 405                                   List&lt;DocPath&gt; localStylesheets,
 406                                   Content body)
 407             throws DocFileIOException {
 408         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);
 409     }
 410 
 411     /**
 412      * Generates the HTML document tree and prints it out.
 413      *
 414      * @param metakeywords Array of String keywords for META tag. Each element
 415      *                     of the array is assigned to a separate META tag.
 416      *                     Pass in null for no array
 417      * @param description the content for the description META tag.
 418      * @param extraHeadContent any additional content to be included in the HEAD element
 419      * @param localStylesheets local stylesheets to be included in the HEAD element
 420      * @param body the body htmltree to be included in the document
 421      * @throws DocFileIOException if there is a problem writing the file
 422      */
 423     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 424                                   String description,
 425                                   Content extraHeadContent,
 426                                   List&lt;DocPath&gt; localStylesheets,
 427                                   Content body)
 428             throws DocFileIOException {
 429         Content htmlComment = contents.newPage;
 430         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 431         additionalStylesheets.addAll(localStylesheets);
 432         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 433                 .setTimestamp(!options.noTimestamp())
 434                 .setDescription(description)
 435                 .setGenerator(getGenerator(getClass()))
 436                 .setTitle(winTitle)
 437                 .setCharset(options.charset())
 438                 .addKeywords(metakeywords)
 439                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 440                 .setIndex(options.createIndex(), mainBodyScript)
 441                 .addContent(extraHeadContent);
 442 
<a name="10" id="anc10"></a><span class="line-modified"> 443         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head, body);</span>
 444         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 445         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 446     }
 447 
 448     /**
 449      * Get the window title.
 450      *
 451      * @param title the title string to construct the complete window title
 452      * @return the window title string
 453      */
 454     public String getWindowTitle(String title) {
 455         if (options.windowTitle().length() &gt; 0) {
 456             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 457         }
 458         return title;
 459     }
 460 
 461     /**
 462      * Get user specified header and the footer.
 463      *
 464      * @param header if true print the user provided header else print the
 465      * user provided footer.
 466      */
 467     public Content getUserHeaderFooter(boolean header) {
 468         String content;
 469         if (header) {
 470             content = replaceDocRootDir(options.header());
 471         } else {
 472             if (options.footer().length() != 0) {
 473                 content = replaceDocRootDir(options.footer());
 474             } else {
 475                 content = replaceDocRootDir(options.header());
 476             }
 477         }
 478         Content rawContent = new RawHtml(content);
 479         return rawContent;
 480     }
 481 
 482     /**
 483      * Adds the user specified top.
 484      *
 485      * @param htmlTree the content tree to which user specified top will be added
 486      */
 487     public void addTop(Content htmlTree) {
 488         Content top = new RawHtml(replaceDocRootDir(options.top()));
 489         htmlTree.add(top);
 490     }
 491 
 492     /**
 493      * Adds the user specified bottom.
 494      *
 495      * @param htmlTree the content tree to which user specified bottom will be added
 496      */
 497     public void addBottom(Content htmlTree) {
 498         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));
 499         Content small = HtmlTree.SMALL(bottom);
 500         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 501         htmlTree.add(p);
 502     }
 503 
 504     /**
 505      * Get the overview tree link for the main tree.
 506      *
 507      * @param label the label for the link
 508      * @return a content tree for the link
 509      */
 510     protected Content getNavLinkMainTree(String label) {
 511         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 512                 new StringContent(label));
 513         Content li = HtmlTree.LI(mainTreeContent);
 514         return li;
 515     }
 516 
 517     /**
 518      * Get table caption.
 519      *
 520      * @param title the content for the caption
 521      * @return a content tree for the caption
 522      */
 523     public Content getTableCaption(Content title) {
 524         Content captionSpan = HtmlTree.SPAN(title);
 525         Content space = Entity.NO_BREAK_SPACE;
 526         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 527         Content caption = HtmlTree.CAPTION(captionSpan);
 528         caption.add(tabSpan);
 529         return caption;
 530     }
 531 
 532     /**
 533      * Returns a packagename content.
 534      *
 535      * @param packageElement the package to check
 536      * @return package name content
 537      */
 538     public Content getPackageName(PackageElement packageElement) {
 539         return packageElement == null || packageElement.isUnnamed()
 540                 ? contents.defaultPackageLabel
 541                 : getPackageLabel(packageElement.getQualifiedName());
 542     }
 543 
 544     /**
 545      * Returns a package name label.
 546      *
 547      * @param packageName the package name
 548      * @return the package name content
 549      */
 550     public Content getPackageLabel(CharSequence packageName) {
 551         return new StringContent(packageName);
 552     }
 553 
 554     /**
 555      * Return the path to the class page for a typeElement.
 556      *
 557      * @param te   TypeElement for which the path is requested.
 558      * @param name Name of the file(doesn&#39;t include path).
 559      */
 560     protected DocPath pathString(TypeElement te, DocPath name) {
 561         return pathString(utils.containingPackage(te), name);
 562     }
 563 
 564     /**
 565      * Return path to the given file name in the given package. So if the name
 566      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 567      * if the relative path is &quot;../..&quot; then returned string will be
 568      * &quot;../../java/lang/Object.html&quot;
 569      *
 570      * @param packageElement Package in which the file name is assumed to be.
 571      * @param name File name, to which path string is.
 572      */
 573     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 574         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 575     }
 576 
 577     /**
 578      * Given a package, return the name to be used in HTML anchor tag.
 579      * @param packageElement the package.
 580      * @return the name to be used in HTML anchor tag.
 581      */
 582     public String getPackageAnchorName(PackageElement packageElement) {
 583         return packageElement == null || packageElement.isUnnamed()
 584                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 585                 : utils.getPackageName(packageElement);
 586     }
 587 
 588     /**
 589      * Return the link to the given package.
 590      *
 591      * @param packageElement the package to link to.
 592      * @param label the label for the link.
 593      * @return a content tree for the package link.
 594      */
 595     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 596         return getPackageLink(packageElement, new StringContent(label));
 597     }
 598 
 599     public Content getPackageLink(PackageElement packageElement) {
 600         StringContent content =  packageElement.isUnnamed()
 601                 ? new StringContent()
 602                 : new StringContent(utils.getPackageName(packageElement));
 603         return getPackageLink(packageElement, content);
 604     }
 605 
 606     /**
 607      * Return the link to the given package.
 608      *
 609      * @param packageElement the package to link to.
 610      * @param label the label for the link.
 611      * @return a content tree for the package link.
 612      */
 613     public Content getPackageLink(PackageElement packageElement, Content label) {
 614         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 615         if (!included) {
 616             for (PackageElement p : configuration.packages) {
 617                 if (p.equals(packageElement)) {
 618                     included = true;
 619                     break;
 620                 }
 621             }
 622         }
 623         if (included || packageElement == null) {
 624             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 625                     label);
 626         } else {
 627             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 628             if (crossPkgLink != null) {
 629                 return links.createLink(crossPkgLink, label);
 630             } else {
 631                 return label;
 632             }
 633         }
 634     }
 635 
 636     /**
 637      * Get Module link.
 638      *
 639      * @param mdle the module being documented
 640      * @param label tag for the link
 641      * @return a content for the module link
 642      */
 643     public Content getModuleLink(ModuleElement mdle, Content label) {
 644         boolean included = utils.isIncluded(mdle);
 645         return (included)
 646                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 647                 : label;
 648     }
 649 
 650     public Content interfaceName(TypeElement typeElement, boolean qual) {
 651         Content name = new StringContent((qual)
 652                 ? typeElement.getQualifiedName()
 653                 : utils.getSimpleName(typeElement));
 654         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 655     }
 656 
 657     /**
 658      * Add the link to the content tree.
 659      *
 660      * @param element program element for which the link will be added
 661      * @param label label for the link
 662      * @param htmltree the content tree to which the link will be added
 663      */
 664     public void addSrcLink(Element element, Content label, Content htmltree) {
 665         if (element == null) {
 666             return;
 667         }
 668         TypeElement te = utils.getEnclosingTypeElement(element);
 669         if (te == null) {
 670             // must be a typeElement since in has no containing class.
 671             te = (TypeElement) element;
 672         }
 673         if (utils.isIncluded(te)) {
 674             DocPath href = pathToRoot
 675                     .resolve(DocPaths.SOURCE_OUTPUT)
 676                     .resolve(docPaths.forClass(te));
 677             Content content = links.createLink(href
 678                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 679             htmltree.add(content);
 680         } else {
 681             htmltree.add(label);
 682         }
 683     }
 684 
 685     /**
 686      * Return the link to the given class.
 687      *
 688      * @param linkInfo the information about the link.
 689      *
 690      * @return the link for the given class.
 691      */
 692     public Content getLink(LinkInfoImpl linkInfo) {
 693         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 694         return factory.getLink(linkInfo);
 695     }
 696 
 697     /**
 698      * Return the type parameters for the given class.
 699      *
 700      * @param linkInfo the information about the link.
 701      * @return the type for the given class.
 702      */
 703     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 704         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 705         return factory.getTypeParameterLinks(linkInfo, false);
 706     }
 707 
 708     /*************************************************************
 709      * Return a class cross link to external class documentation.
 710      * The -link option does not allow users to
 711      * link to external classes in the &quot;default&quot; package.
 712      *
 713      * @param classElement the class element
 714      * @param refMemName the name of the member being referenced.  This should
 715      * be null or empty string if no member is being referenced.
 716      * @param label the label for the external link.
 717      * @param strong true if the link should be strong.
 718      * @param code true if the label should be code font.
 719      * @return the link
 720      */
 721     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 722                                     Content label, boolean strong, boolean code) {
 723         if (classElement != null) {
 724             String className = utils.getSimpleName(classElement);
 725             PackageElement packageElement = utils.containingPackage(classElement);
 726             Content defaultLabel = new StringContent(className);
 727             if (code)
 728                 defaultLabel = HtmlTree.CODE(defaultLabel);
 729             if (getCrossPackageLink(packageElement) != null) {
 730                 /*
 731                 The package exists in external documentation, so link to the external
 732                 class (assuming that it exists).  This is definitely a limitation of
 733                 the -link option.  There are ways to determine if an external package
 734                 exists, but no way to determine if the external class exists.  We just
 735                 have to assume that it does.
 736                 */
 737                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 738                                 className + &quot;.html&quot;, refMemName);
 739                 return links.createLink(link,
 740                     (label == null) || label.isEmpty() ? defaultLabel : label,
 741                     strong,
 742                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 743                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 744             }
 745         }
 746         return null;
 747     }
 748 
 749     public boolean isClassLinkable(TypeElement typeElement) {
 750         if (utils.isIncluded(typeElement)) {
 751             return configuration.isGeneratedDoc(typeElement);
 752         }
 753         return configuration.extern.isExternal(typeElement);
 754     }
 755 
 756     public DocLink getCrossPackageLink(PackageElement element) {
 757         return configuration.extern.getExternalLink(element, pathToRoot,
 758             DocPaths.PACKAGE_SUMMARY.getPath());
 759     }
 760 
 761     public DocLink getCrossModuleLink(ModuleElement element) {
 762         return configuration.extern.getExternalLink(element, pathToRoot,
 763             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 764     }
 765 
 766     /**
 767      * Get the class link.
 768      *
 769      * @param context the id of the context where the link will be added
 770      * @param element to link to
 771      * @return a content tree for the link
 772      */
 773     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 774         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 775         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 776     }
 777 
 778     /**
 779      * Add the class link.
 780      *
 781      * @param context the id of the context where the link will be added
 782      * @param typeElement to link to
 783      * @param contentTree the content tree to which the link will be added
 784      */
 785     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 786         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 787     }
 788 
 789     /**
 790      * Retrieve the class link with the package portion of the label in
 791      * plain text.  If the qualifier is excluded, it will not be included in the
 792      * link label.
 793      *
 794      * @param typeElement the class to link to.
 795      * @param isStrong true if the link should be strong.
 796      * @return the link with the package portion of the label in plain text.
 797      */
 798     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 799             TypeElement typeElement, boolean isStrong) {
 800         ContentBuilder classlink = new ContentBuilder();
 801         PackageElement pkg = utils.containingPackage(typeElement);
 802         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 803             classlink.add(getEnclosingPackageName(typeElement));
 804         }
 805         classlink.add(getLink(new LinkInfoImpl(configuration,
 806                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 807         return classlink;
 808     }
 809 
 810     /**
 811      * Add the class link with the package portion of the label in
 812      * plain text. If the qualifier is excluded, it will not be included in the
 813      * link label.
 814      *
 815      * @param context the id of the context where the link will be added
 816      * @param typeElement the class to link to
 817      * @param isStrong true if the link should be strong
 818      * @param contentTree the content tree to which the link with be added
 819      */
 820     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 821             TypeElement typeElement, boolean isStrong, Content contentTree) {
 822         PackageElement pkg = utils.containingPackage(typeElement);
 823         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 824             contentTree.add(getEnclosingPackageName(typeElement));
 825         }
 826         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 827                 .label(utils.getSimpleName(typeElement))
 828                 .strong(isStrong);
 829         Content link = getLink(linkinfo);
 830         contentTree.add(link);
 831     }
 832 
 833     /**
 834      * Get the enclosed name of the package
 835      *
 836      * @param te  TypeElement
 837      * @return the name
 838      */
 839     public String getEnclosingPackageName(TypeElement te) {
 840 
 841         PackageElement encl = configuration.utils.containingPackage(te);
 842         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 843     }
 844 
 845     /**
 846      * Return the main type element of the current page or null for pages that don&#39;t have one.
 847      *
 848      * @return the type element of the current page.
 849      */
 850     protected TypeElement getCurrentPageElement() {
 851         return null;
 852     }
 853 
 854     /**
 855      * Add the class link, with only class name as the strong link and prefixing
 856      * plain package name.
 857      *
 858      * @param context the id of the context where the link will be added
 859      * @param typeElement the class to link to
 860      * @param contentTree the content tree to which the link with be added
 861      */
 862     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 863         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 864     }
 865 
 866     /**
 867      * Get the link for the given member.
 868      *
 869      * @param context the id of the context where the link will be added
 870      * @param element the member being linked to
 871      * @param label the label for the link
 872      * @return a content tree for the element link
 873      */
 874     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 875         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 876                 new StringContent(label));
 877     }
 878 
 879     /**
 880      * Return the link for the given member.
 881      *
 882      * @param context the id of the context where the link will be printed.
 883      * @param element the member being linked to.
 884      * @param label the label for the link.
 885      * @param strong true if the link should be strong.
 886      * @return the link for the given member.
 887      */
 888     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 889             boolean strong) {
 890         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 891     }
 892 
 893     /**
 894      * Return the link for the given member.
 895      *
 896      * @param context the id of the context where the link will be printed.
 897      * @param typeElement the typeElement that we should link to.  This is not
 898                  necessarily equal to element.containingClass().  We may be
 899                  inheriting comments.
 900      * @param element the member being linked to.
 901      * @param label the label for the link.
 902      * @param strong true if the link should be strong.
 903      * @return the link for the given member.
 904      */
 905     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 906             CharSequence label, boolean strong) {
 907         return getDocLink(context, typeElement, element, label, strong, false);
 908     }
 909 
 910     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 911             Content label, boolean strong) {
 912         return getDocLink(context, typeElement, element, label, strong, false);
 913     }
 914 
 915     /**
 916      * Return the link for the given member.
 917      *
 918      * @param context the id of the context where the link will be printed.
 919      * @param typeElement the typeElement that we should link to.  This is not
 920                  necessarily equal to element.containingClass().  We may be
 921                  inheriting comments.
 922      * @param element the member being linked to.
 923      * @param label the label for the link.
 924      * @param strong true if the link should be strong.
 925      * @param isProperty true if the element parameter is a JavaFX property.
 926      * @return the link for the given member.
 927      */
 928     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 929             CharSequence label, boolean strong, boolean isProperty) {
 930         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 931     }
 932 
 933     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 934             Content label, boolean strong, boolean isProperty) {
 935         if (!utils.isLinkable(typeElement, element)) {
 936             return label;
 937         }
 938 
 939         if (utils.isExecutableElement(element)) {
 940             ExecutableElement ee = (ExecutableElement)element;
 941             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 942                 .label(label)
 943                 .where(links.getName(getAnchor(ee, isProperty)))
 944                 .strong(strong));
 945         }
 946 
 947         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 948             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 949                 .label(label)
 950                 .where(links.getName(element.getSimpleName().toString()))
 951                 .strong(strong));
 952         }
 953 
 954         return label;
 955     }
 956 
 957     /**
 958      * Return the link for the given member.
 959      *
 960      * @param context the id of the context where the link will be added
 961      * @param typeElement the typeElement that we should link to.  This is not
 962                  necessarily equal to element.containingClass().  We may be
 963                  inheriting comments
 964      * @param element the member being linked to
 965      * @param label the label for the link
 966      * @return the link for the given member
 967      */
 968     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 969             Content label) {
 970         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 971             return label;
 972         } else if (utils.isExecutableElement(element)) {
 973             ExecutableElement emd = (ExecutableElement) element;
 974             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 975                 .label(label)
 976                 .where(links.getName(getAnchor(emd))));
 977         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 978             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 979                 .label(label).where(links.getName(element.getSimpleName().toString())));
 980         } else {
 981             return label;
 982         }
 983     }
 984 
 985     public String getAnchor(ExecutableElement executableElement) {
 986         return getAnchor(executableElement, false);
 987     }
 988 
 989     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
 990         if (isProperty) {
 991             return executableElement.getSimpleName().toString();
 992         }
 993         String member = anchorName(executableElement);
 994         String erasedSignature = utils.makeSignature(executableElement, true, true);
 995         return member + erasedSignature;
 996     }
 997 
 998     public String anchorName(Element member) {
 999         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1000             return &quot;&lt;init&gt;&quot;;
1001         } else {
1002             return utils.getSimpleName(member);
1003         }
1004     }
1005 
1006     public Content seeTagToContent(Element element, DocTree see) {
1007         Kind kind = see.getKind();
1008         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1009             return new ContentBuilder();
1010         }
1011 
1012         CommentHelper ch = utils.getCommentHelper(element);
1013         String tagName = ch.getTagName(see);
1014         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1015         // Check if @see is an href or &quot;string&quot;
1016         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1017             return new RawHtml(seetext);
1018         }
1019         boolean isLinkPlain = kind == LINK_PLAIN;
1020         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));
1021 
1022         //The text from the @see tag.  We will output this text when a label is not specified.
1023         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1024 
1025         TypeElement refClass = ch.getReferencedClass(see);
1026         String refClassName =  ch.getReferencedClassName(see);
1027         Element refMem =       ch.getReferencedMember(see);
1028         String refMemName =    ch.getReferencedMemberName(see);
1029 
1030         if (refMemName == null &amp;&amp; refMem != null) {
1031             refMemName = refMem.toString();
1032         }
1033         if (refClass == null) {
1034             //@see is not referencing an included class
1035             PackageElement refPackage = ch.getReferencedPackage(see);
1036             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1037                 //@see is referencing an included package
1038                 if (label.isEmpty())
1039                     label = plainOrCode(isLinkPlain,
1040                             new StringContent(refPackage.getQualifiedName()));
1041                 return getPackageLink(refPackage, label);
1042             } else {
1043                 // @see is not referencing an included class, module or package. Check for cross links.
1044                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1045                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1046                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1047                 if (elementCrossLink != null) {
1048                     // Element cross link found
1049                     return links.createLink(elementCrossLink,
1050                             (label.isEmpty() ? text : label), true);
1051                 } else {
1052                     // No cross link found so print warning
1053                     messages.warning(ch.getDocTreePath(see),
1054                             &quot;doclet.see.class_or_package_not_found&quot;,
1055                             &quot;@&quot; + tagName,
1056                             seetext);
1057                     return (label.isEmpty() ? text: label);
1058                 }
1059             }
1060         } else if (refMemName == null) {
1061             // Must be a class reference since refClass is not null and refMemName is null.
1062             if (label.isEmpty()) {
1063                 /*
1064                  * it seems to me this is the right thing to do, but it causes comparator failures.
1065                  */
1066                 if (!configuration.backwardCompatibility) {
1067                     StringContent content = utils.isEnclosingPackageIncluded(refClass)
1068                             ? new StringContent(utils.getSimpleName(refClass))
1069                             : new StringContent(utils.getFullyQualifiedName(refClass));
1070                     label = plainOrCode(isLinkPlain, content);
1071                 } else {
1072                     label = plainOrCode(isLinkPlain,
1073                             new StringContent(utils.getSimpleName(refClass)));
1074                 }
1075 
1076             }
1077             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1078                     .label(label));
1079         } else if (refMem == null) {
1080             // Must be a member reference since refClass is not null and refMemName is not null.
1081             // However, refMem is null, so this referenced member does not exist.
1082             return (label.isEmpty() ? text: label);
1083         } else {
1084             // Must be a member reference since refClass is not null and refMemName is not null.
1085             // refMem is not null, so this @see tag must be referencing a valid member.
1086             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1087 
1088             // Find the enclosing type where the method is actually visible
1089             // in the inheritance hierarchy.
1090             ExecutableElement overriddenMethod = null;
1091             if (refMem.getKind() == ElementKind.METHOD) {
1092                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1093                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1094 
1095                 if (overriddenMethod != null)
1096                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1097             }
1098             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1099                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1100                 // Since the link is relative and the holder is not even being
1101                 // documented, this must be an inherited link.  Redirect it.
1102                 // The current class either overrides the referenced member or
1103                 // inherits it automatically.
1104                 if (this instanceof ClassWriterImpl) {
1105                     containing = ((ClassWriterImpl) this).getTypeElement();
1106                 } else if (!utils.isPublic(containing)) {
1107                     messages.warning(
1108                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1109                         tagName, utils.getFullyQualifiedName(containing));
1110                 } else {
1111                     messages.warning(
1112                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1113                         tagName, seetext);
1114                 }
1115             }
1116             if (configuration.currentTypeElement != containing) {
1117                 refMemName = (utils.isConstructor(refMem))
1118                         ? refMemName
1119                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1120             }
1121             if (utils.isExecutableElement(refMem)) {
1122                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
1123                     refMemName += utils.makeSignature((ExecutableElement)refMem, true);
1124                 }
1125                 if (overriddenMethod != null) {
1126                     // The method to actually link.
1127                     refMem = overriddenMethod;
1128                 }
1129             }
1130 
1131             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1132 
1133             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1134                     refMem, (label.isEmpty() ? text: label), false);
1135         }
1136     }
1137 
1138     private Content plainOrCode(boolean plain, Content body) {
1139         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1140     }
1141 
1142     /**
1143      * Add the inline comment.
1144      *
1145      * @param element the Element for which the inline comment will be added
1146      * @param tag the inline tag to be added
1147      * @param htmltree the content tree to which the comment will be added
1148      */
1149     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1150         CommentHelper ch = utils.getCommentHelper(element);
1151         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);
1152         addCommentTags(element, tag, description, false, false, false, htmltree);
1153     }
1154 
1155     /**
1156      * Get the deprecated phrase as content.
1157      *
1158      * @param e the Element for which the inline deprecated comment will be added
1159      * @return a content tree for the deprecated phrase.
1160      */
1161     public Content getDeprecatedPhrase(Element e) {
1162         return (utils.isDeprecatedForRemoval(e))
1163                 ? contents.deprecatedForRemovalPhrase
1164                 : contents.deprecatedPhrase;
1165     }
1166 
1167     /**
1168      * Add the inline deprecated comment.
1169      *
1170      * @param e the Element for which the inline deprecated comment will be added
1171      * @param tag the inline tag to be added
1172      * @param htmltree the content tree to which the comment will be added
1173      */
1174     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1175         CommentHelper ch = utils.getCommentHelper(e);
1176         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);
1177     }
1178 
1179     /**
1180      * Adds the summary content.
1181      *
1182      * @param element the Element for which the summary will be generated
1183      * @param htmltree the documentation tree to which the summary will be added
1184      */
1185     public void addSummaryComment(Element element, Content htmltree) {
1186         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1187     }
1188 
1189     /**
1190      * Adds the summary content.
1191      *
1192      * @param element the Element for which the summary will be generated
1193      * @param firstSentenceTags the first sentence tags for the doc
1194      * @param htmltree the documentation tree to which the summary will be added
1195      */
1196     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1197         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1198     }
1199 
1200     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1201         CommentHelper ch = utils.getCommentHelper(element);
1202         List&lt;? extends DocTree&gt; body = ch.getBody(tag);
1203         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);
1204     }
1205 
1206     /**
1207      * Adds the inline comment.
1208      *
1209      * @param element the Element for which the inline comments will be generated
1210      * @param htmltree the documentation tree to which the inline comments will be added
1211      */
1212     public void addInlineComment(Element element, Content htmltree) {
1213         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1214     }
1215 
1216     /**
1217      * Adds the comment tags.
1218      *
1219      * @param element the Element for which the comment tags will be generated
1220      * @param tags the first sentence tags for the doc
1221      * @param depr true if it is deprecated
1222      * @param first true if the first sentence tags should be added
1223      * @param inSummary true if the comment tags are added into the summary section
1224      * @param htmltree the documentation tree to which the comment tags will be added
1225      */
1226     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1227             boolean first, boolean inSummary, Content htmltree) {
1228         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1229     }
1230 
1231     /**
1232      * Adds the comment tags.
1233      *
1234      * @param element for which the comment tags will be generated
1235      * @param holderTag the block tag context for the inline tags
1236      * @param tags the first sentence tags for the doc
1237      * @param depr true if it is deprecated
1238      * @param first true if the first sentence tags should be added
1239      * @param inSummary true if the comment tags are added into the summary section
1240      * @param htmltree the documentation tree to which the comment tags will be added
1241      */
1242     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1243             boolean first, boolean inSummary, Content htmltree) {
1244         if (options.noComment()){
1245             return;
1246         }
1247         Content div;
1248         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1249         if (depr) {
1250             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1251             htmltree.add(div);
1252         }
1253         else {
1254             div = HtmlTree.DIV(HtmlStyle.block, result);
1255             htmltree.add(div);
1256         }
1257         if (tags.isEmpty()) {
1258             htmltree.add(Entity.NO_BREAK_SPACE);
1259         }
1260     }
1261 
1262     boolean ignoreNonInlineTag(DocTree dtree) {
1263         Name name = null;
1264         if (dtree.getKind() == Kind.START_ELEMENT) {
1265             StartElementTree setree = (StartElementTree)dtree;
1266             name = setree.getName();
1267         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1268             EndElementTree eetree = (EndElementTree)dtree;
1269             name = eetree.getName();
1270         }
1271 
1272         if (name != null) {
1273             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1274             if (htmlTag != null &amp;&amp;
1275                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1276                 return true;
1277             }
1278         }
1279         return false;
1280     }
1281 
1282     boolean isAllWhiteSpace(String body) {
1283         for (int i = 0 ; i &lt; body.length(); i++) {
1284             if (!Character.isWhitespace(body.charAt(i)))
1285                 return false;
1286         }
1287         return true;
1288     }
1289 
1290     // Notify the next DocTree handler to take necessary action
1291     private boolean commentRemoved = false;
1292 
1293     /**
1294      * Converts inline tags and text to Content, expanding the
1295      * inline tags along the way.  Called wherever text can contain
1296      * an inline tag, such as in comments or in free-form text arguments
1297      * to block tags.
1298      *
1299      * @param holderTag    specific tag where comment resides
1300      * @param element    specific element where comment resides
1301      * @param tags   array of text tags and inline tags (often alternating)
1302                present in the text of interest for this element
1303      * @param isFirstSentence  true if text is first sentence
1304      * @return a Content object
1305      */
<a name="11" id="anc11"></a><span class="line-modified">1306     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">1307                                         Element element,</span>
<span class="line-added">1308                                         List&lt;? extends DocTree&gt; tags,</span>
<span class="line-added">1309                                         boolean isFirstSentence)</span>
<span class="line-added">1310     {</span>
1311         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1312     }
1313 
1314     /**
1315      * Converts inline tags and text to text strings, expanding the
1316      * inline tags along the way.  Called wherever text can contain
1317      * an inline tag, such as in comments or in free-form text arguments
1318      * to block tags.
1319      *
1320      * @param holderTag       specific tag where comment resides
1321      * @param element         specific element where comment resides
1322      * @param trees           array of text tags and inline tags (often alternating)
1323      *                        present in the text of interest for this element
1324      * @param isFirstSentence true if text is first sentence
1325      * @param inSummary       if the comment tags are added into the summary section
1326      * @return a Content object
1327      */
<a name="12" id="anc12"></a><span class="line-modified">1328     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">1329                                         Element element,</span>
<span class="line-modified">1330                                         List&lt;? extends DocTree&gt; trees,</span>
<span class="line-added">1331                                         boolean isFirstSentence,</span>
<span class="line-added">1332                                         boolean inSummary)</span>
<span class="line-added">1333     {</span>
1334         final Content result = new ContentBuilder() {
1335             @Override
<a name="13" id="anc13"></a><span class="line-modified">1336             public ContentBuilder add(CharSequence text) {</span>
<span class="line-modified">1337                 return super.add(utils.normalizeNewlines(text));</span>
1338             }
1339         };
1340         CommentHelper ch = utils.getCommentHelper(element);
1341         // Array of all possible inline tags for this javadoc run
1342         configuration.tagletManager.checkTags(element, trees, true);
1343         commentRemoved = false;
1344 
1345         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1346             boolean isFirstNode = !iterator.hasPrevious();
1347             DocTree tag = iterator.next();
1348             boolean isLastNode  = !iterator.hasNext();
1349 
1350             if (isFirstSentence) {
1351                 // Ignore block tags
1352                 if (ignoreNonInlineTag(tag))
1353                     continue;
1354 
1355                 // Ignore any trailing whitespace OR whitespace after removed html comment
1356                 if ((isLastNode || commentRemoved)
1357                         &amp;&amp; tag.getKind() == TEXT
1358                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1359                     continue;
1360 
1361                 // Ignore any leading html comments
1362                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1363                     commentRemoved = true;
1364                     continue;
1365                 }
1366             }
1367 
1368             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1369 
1370                 private boolean inAnAtag() {
1371                     if (utils.isStartElement(tag)) {
1372                         StartElementTree st = (StartElementTree)tag;
1373                         Name name = st.getName();
1374                         if (name != null) {
1375                             com.sun.tools.doclint.HtmlTag htag =
1376                                     com.sun.tools.doclint.HtmlTag.get(name);
1377                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1378                         }
1379                     }
1380                     return false;
1381                 }
1382 
1383                 @Override
1384                 public Boolean visitAttribute(AttributeTree node, Content c) {
1385                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1386                     if (node.getValueKind() == ValueKind.EMPTY) {
1387                         result.add(sb);
1388                         return false;
1389                     }
1390                     sb.append(&quot;=&quot;);
1391                     String quote;
1392                     switch (node.getValueKind()) {
1393                         case DOUBLE:
1394                             quote = &quot;\&quot;&quot;;
1395                             break;
1396                         case SINGLE:
<a name="14" id="anc14"></a><span class="line-modified">1397                             quote = &quot;&#39;&quot;;</span>
1398                             break;
1399                         default:
1400                             quote = &quot;&quot;;
1401                             break;
1402                     }
1403                     sb.append(quote);
1404                     result.add(sb);
1405                     Content docRootContent = new ContentBuilder();
1406 
1407                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1408                     for (DocTree dt : node.getValue()) {
1409                         if (utils.isText(dt) &amp;&amp; isHRef) {
1410                             String text = ((TextTree) dt).getBody();
1411                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {
1412                                 result.add(options.docrootParent());
1413                                 docRootContent = new ContentBuilder();
1414                                 result.add(textCleanup(text.substring(3), isLastNode));
1415                             } else {
1416                                 if (!docRootContent.isEmpty()) {
1417                                     docRootContent = copyDocRootContent(docRootContent);
1418                                 } else {
1419                                     text = redirectRelativeLinks(element, (TextTree) dt);
1420                                 }
1421                                 result.add(textCleanup(text, isLastNode));
1422                             }
1423                         } else {
1424                             docRootContent = copyDocRootContent(docRootContent);
1425                             dt.accept(this, docRootContent);
1426                         }
1427                     }
1428                     copyDocRootContent(docRootContent);
1429                     result.add(quote);
1430                     return false;
1431                 }
1432 
1433                 @Override
1434                 public Boolean visitComment(CommentTree node, Content c) {
1435                     result.add(new RawHtml(node.getBody()));
1436                     return false;
1437                 }
1438 
1439                 private Content copyDocRootContent(Content content) {
1440                     if (!content.isEmpty()) {
1441                         result.add(content);
1442                         return new ContentBuilder();
1443                     }
1444                     return content;
1445                 }
1446 
1447                 @Override
1448                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1449                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1450                             configuration.tagletManager,
1451                             holderTag,
1452                             node,
1453                             getTagletWriterInstance(isFirstSentence));
1454                     if (c != null) {
1455                         c.add(docRootContent);
1456                     } else {
1457                         result.add(docRootContent);
1458                     }
1459                     return false;
1460                 }
1461 
1462                 @Override
1463                 public Boolean visitEndElement(EndElementTree node, Content c) {
1464                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1465                     result.add(rawHtml);
1466                     return false;
1467                 }
1468 
1469                 @Override
1470                 public Boolean visitEntity(EntityTree node, Content c) {
1471                     result.add(new RawHtml(node.toString()));
1472                     return false;
1473                 }
1474 
1475                 @Override
1476                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1477                     messages.warning(ch.getDocTreePath(node),
1478                             &quot;doclet.tag.invalid_usage&quot;, node);
1479                     result.add(new RawHtml(node.toString()));
1480                     return false;
1481                 }
1482 
1483                 @Override
1484                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1485                     Content output = TagletWriter.getInlineTagOutput(element,
1486                             configuration.tagletManager, holderTag,
1487                             tag, getTagletWriterInstance(isFirstSentence));
1488                     result.add(output);
1489                     // if we obtained the first sentence successfully, nothing more to do
1490                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1491                 }
1492 
1493                 @Override
1494                 public Boolean visitIndex(IndexTree node, Content p) {
1495                     Content output = TagletWriter.getInlineTagOutput(element,
1496                             configuration.tagletManager, holderTag, tag,
1497                             getTagletWriterInstance(isFirstSentence, inSummary));
1498                     if (output != null) {
1499                         result.add(output);
1500                     }
1501                     return false;
1502                 }
1503 
1504                 @Override
1505                 public Boolean visitLink(LinkTree node, Content c) {
1506                     // we need to pass the DocTreeImpl here, so ignore node
1507                     Content content = seeTagToContent(element, tag);
1508                     result.add(content);
1509                     return false;
1510                 }
1511 
1512                 @Override
1513                 public Boolean visitLiteral(LiteralTree node, Content c) {
1514                     String s = node.getBody().getBody();
1515                     Content content = new StringContent(utils.normalizeNewlines(s));
1516                     if (node.getKind() == CODE)
1517                         content = HtmlTree.CODE(content);
1518                     result.add(content);
1519                     return false;
1520                 }
1521 
1522                 @Override
1523                 public Boolean visitSee(SeeTree node, Content c) {
1524                     // we need to pass the DocTreeImpl here, so ignore node
1525                     result.add(seeTagToContent(element, tag));
1526                     return false;
1527                 }
1528 
1529                 @Override
1530                 public Boolean visitStartElement(StartElementTree node, Content c) {
1531                     String text = &quot;&lt;&quot; + node.getName();
1532                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1533                     result.add(rawHtml);
1534 
1535                     for (DocTree dt : node.getAttributes()) {
1536                         dt.accept(this, null);
1537                     }
1538                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1539                     return false;
1540                 }
1541 
1542                 @Override
1543                 public Boolean visitSummary(SummaryTree node, Content c) {
1544                     Content output = TagletWriter.getInlineTagOutput(element,
1545                             configuration.tagletManager, holderTag, tag,
1546                             getTagletWriterInstance(isFirstSentence));
1547                     result.add(output);
1548                     return false;
1549                 }
1550 
1551                 @Override
1552                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1553                     Content output = TagletWriter.getInlineTagOutput(element,
1554                             configuration.tagletManager, holderTag, tag,
1555                             getTagletWriterInstance(isFirstSentence, inSummary));
1556                     if (output != null) {
1557                         result.add(output);
1558                     }
1559                     return false;
1560                 }
1561 
1562                 private CharSequence textCleanup(String text, boolean isLast) {
1563                     return textCleanup(text, isLast, false);
1564                 }
1565 
1566                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {
1567                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;
1568                     if (stripLeading &amp;&amp; stripTrailing) {
1569                         text = text.strip();
1570                     } else if (stripLeading) {
1571                         text = text.stripLeading();
1572                     } else if (stripTrailing) {
1573                         text = text.stripTrailing();
1574                     }
1575                     text = utils.replaceTabs(text);
1576                     return utils.normalizeNewlines(text);
1577                 }
1578 
1579                 @Override
1580                 public Boolean visitText(TextTree node, Content c) {
1581                     String text = node.getBody();
1582                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1583                     return false;
1584                 }
1585 
1586                 @Override
1587                 protected Boolean defaultAction(DocTree node, Content c) {
1588                     Content output = TagletWriter.getInlineTagOutput(element,
1589                             configuration.tagletManager, holderTag, tag,
1590                             getTagletWriterInstance(isFirstSentence));
1591                     if (output != null) {
1592                         result.add(output);
1593                     }
1594                     return false;
1595                 }
1596 
1597             }.visit(tag, null);
1598             commentRemoved = false;
1599             if (allDone)
1600                 break;
1601         }
1602         return result;
1603     }
1604 
1605     /**
1606      * Return true if relative links should not be redirected.
1607      *
1608      * @return Return true if a relative link should not be redirected.
1609      */
1610     private boolean shouldNotRedirectRelativeLinks() {
1611         return  this instanceof AnnotationTypeWriter ||
1612                 this instanceof ClassWriter ||
1613                 this instanceof PackageSummaryWriter;
1614     }
1615 
1616     /**
1617      * Suppose a piece of documentation has a relative link.  When you copy
1618      * that documentation to another place such as the index or class-use page,
1619      * that relative link will no longer work.  We should redirect those links
1620      * so that they will work again.
1621      * &lt;p&gt;
1622      * Here is the algorithm used to fix the link:
1623      * &lt;p&gt;
1624      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1625      * &lt;p&gt;
1626      * For example, suppose DocletEnvironment has this link:
1627      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1628      * &lt;p&gt;
1629      * If this link appeared in the index, we would redirect
1630      * the link like this:
1631      *
1632      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1633      *
1634      * @param element the Element object whose documentation is being written.
1635      * @param tt the text being written.
1636      *
1637      * @return the text, with all the relative links redirected to work.
1638      */
1639     @SuppressWarnings(&quot;preview&quot;)
1640     private String redirectRelativeLinks(Element element, TextTree tt) {
1641         String text = tt.getBody();
1642         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1643             return text;
1644         }
1645 
1646         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {
1647             @Override
1648             public DocPath visitType(TypeElement e, Void p) {
1649                 return docPaths.forPackage(utils.containingPackage(e));
1650             }
1651 
1652             @Override
1653             public DocPath visitPackage(PackageElement e, Void p) {
1654                 return docPaths.forPackage(e);
1655             }
1656 
1657             @Override
1658             public DocPath visitVariable(VariableElement e, Void p) {
1659                 return docPaths.forPackage(utils.containingPackage(e));
1660             }
1661 
1662             @Override
1663             public DocPath visitExecutable(ExecutableElement e, Void p) {
1664                 return docPaths.forPackage(utils.containingPackage(e));
1665             }
1666 
1667             @Override
1668             protected DocPath defaultAction(Element e, Void p) {
1669                 return null;
1670             }
1671         }.visit(element);
1672         if (redirectPathFromRoot == null) {
1673             return text;
1674         }
1675         String lower = Utils.toLowerCase(text);
1676         if (!(lower.startsWith(&quot;mailto:&quot;)
1677                 || lower.startsWith(&quot;http:&quot;)
1678                 || lower.startsWith(&quot;https:&quot;)
1679                 || lower.startsWith(&quot;file:&quot;))) {
1680             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1681                     + redirectPathFromRoot.resolve(text).getPath();
1682             text = replaceDocRootDir(text);
1683         }
1684         return text;
1685     }
1686 
1687     /**
1688      * According to
1689      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1690      * all the outer classes and static nested classes are core classes.
1691      */
1692     public boolean isCoreClass(TypeElement typeElement) {
1693         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1694     }
1695 
1696     /**
1697      * Adds the annotation types for the given packageElement.
1698      *
1699      * @param packageElement the package to write annotations for.
1700      * @param htmltree the documentation tree to which the annotation info will be
1701      *        added
1702      */
1703     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
1704         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);
1705     }
1706 
1707     /*
1708      * this is a hack to delay dealing with Annotations in the writers, the assumption
1709      * is that all necessary checks have been made to get here.
1710      */
1711     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1712             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1713         TypeMirror rcvrType = method.getReceiverType();
1714         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
1715         htmltree.add(getAnnotationInfo(annotationMirrors1, false));
1716     }
1717 
1718     /**
1719      * Adds the annotation types for the given element.
1720      *
1721      * @param element the package to write annotations for
1722      * @param htmltree the content tree to which the annotation types will be added
1723      */
1724     public void addAnnotationInfo(Element element, Content htmltree) {
1725         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);
1726     }
1727 
1728     /**
1729      * Add the annotation types for the given element and parameter.
1730      *
1731      * @param param the parameter to write annotations for.
1732      * @param tree the content tree to which the annotation types will be added
1733      */
1734     public boolean addAnnotationInfo(VariableElement param, Content tree) {
1735         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);
1736         if (annotationInfo.isEmpty()) {
1737             return false;
1738         }
1739         tree.add(annotationInfo);
1740         return true;
1741     }
1742 
1743     /**
1744      * Adds the annotation types for the given Element.
1745      *
1746      * @param descList a list of annotation mirrors.
1747      * @param htmltree the documentation tree to which the annotation info will be
1748      *        added
1749      */
1750     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {
1751         htmltree.add(getAnnotationInfo(descList, true));
1752     }
1753 
1754     /**
1755      * Return a content tree containing the annotation types for the given element.
1756      *
1757      * @param descList a list of annotation mirrors.
1758      * @return the documentation tree containing the annotation info.
1759      */
1760     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {
1761         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);
1762         String sep = &quot;&quot;;
1763         ContentBuilder builder = new ContentBuilder();
1764         for (Content annotation: annotations) {
1765             builder.add(sep);
1766             builder.add(annotation);
1767             if (!lineBreak) {
1768                 sep = &quot; &quot;;
1769             }
1770         }
1771         return builder;
1772     }
1773 
1774     /**
1775      * Return the string representations of the annotation types for
1776      * the given doc.
1777      *
1778      * @param descList a list of annotation mirrors.
1779      * @param linkBreak if true, add new line between each member value.
1780      * @return a list of strings representing the annotations being
1781      *         documented.
1782      */
1783     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {
1784         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1785         ContentBuilder annotation;
1786         for (AnnotationMirror aDesc : descList) {
1787             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1788             // If an annotation is not documented, do not add it to the list. If
1789             // the annotation is of a repeatable type, and if it is not documented
1790             // and also if its container annotation is not documented, do not add it
1791             // to the list. If an annotation of a repeatable type is not documented
1792             // but its container is documented, it will be added to the list.
1793             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1794                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1795                 continue;
1796             }
1797             annotation = new ContentBuilder();
1798             isAnnotationDocumented = false;
1799             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1800                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1801             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1802             // If the annotation is synthesized, do not print the container.
1803             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1804                 for (ExecutableElement ee : pairs.keySet()) {
1805                     AnnotationValue annotationValue = pairs.get(ee);
1806                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1807 
1808                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1809                         @Override
1810                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1811                             p.addAll(vals);
1812                             return null;
1813                         }
1814 
1815                         @Override
1816                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1817                             p.add(annotationValue);
1818                             return null;
1819                         }
1820                     }.visit(annotationValue, annotationTypeValues);
1821 
1822                     String sep = &quot;&quot;;
1823                     for (AnnotationValue av : annotationTypeValues) {
1824                         annotation.add(sep);
1825                         annotation.add(annotationValueToContent(av));
1826                         sep = &quot; &quot;;
1827                     }
1828                 }
1829             } else if (isAnnotationArray(pairs)) {
1830                 // If the container has 1 or more value defined and if the
1831                 // repeatable type annotation is not documented, do not print
1832                 // the container.
1833                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1834                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1835                     for (AnnotationValue a :  pairs.values()) {
1836                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1837                             @Override
1838                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
1839                                annotationTypeValues.addAll(vals);
1840                                return null;
1841                             }
1842                         }.visit(a, annotationTypeValues);
1843                     }
1844                     String sep = &quot;&quot;;
1845                     for (AnnotationValue av : annotationTypeValues) {
1846                         annotation.add(sep);
1847                         annotation.add(annotationValueToContent(av));
1848                         sep = &quot; &quot;;
1849                     }
1850                 }
1851                 // If the container has 1 or more value defined and if the
1852                 // repeatable type annotation is not documented, print the container.
1853                 else {
1854                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);
1855                 }
1856             }
1857             else {
1858                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);
1859             }
1860             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1861             results.add(annotation);
1862         }
1863         return results;
1864     }
1865 
1866     /**
1867      * Add annotation to the annotation string.
1868      *
1869      * @param annotationDoc the annotation being documented
1870      * @param linkInfo the information about the link
1871      * @param annotation the annotation string to which the annotation will be added
1872      * @param map annotation type element to annotation value pairs
1873      * @param linkBreak if true, add new line between each member value
1874      */
1875     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1876                                 ContentBuilder annotation,
1877                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
1878                                 boolean linkBreak) {
1879         linkInfo.label = new StringContent(&quot;@&quot;);
1880         linkInfo.label.add(annotationDoc.getSimpleName());
1881         annotation.add(getLink(linkInfo));
1882         if (!map.isEmpty()) {
1883             annotation.add(&quot;(&quot;);
1884             boolean isFirst = true;
1885             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1886             boolean multipleValues = keys.size() &gt; 1;
1887             for (ExecutableElement element : keys) {
1888                 if (isFirst) {
1889                     isFirst = false;
1890                 } else {
1891                     annotation.add(&quot;,&quot;);
1892                     if (linkBreak) {
1893                         annotation.add(DocletConstants.NL);
1894                         int spaces = annotationDoc.getSimpleName().length() + 2;
1895                         for (int k = 0; k &lt; (spaces); k++) {
1896                             annotation.add(&quot; &quot;);
1897                         }
1898                     }
1899                 }
1900                 String simpleName = element.getSimpleName().toString();
1901                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1902                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1903                                                      element, simpleName, false));
1904                     annotation.add(&quot;=&quot;);
1905                 }
1906                 AnnotationValue annotationValue = map.get(element);
1907                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1908                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1909                     @Override
1910                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1911                         annotationTypeValues.addAll(vals);
1912                         return null;
1913                     }
1914                     @Override
1915                     protected Void defaultAction(Object o, AnnotationValue p) {
1916                         annotationTypeValues.add(p);
1917                         return null;
1918                     }
1919                 }.visit(annotationValue, annotationValue);
1920                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1921                 String sep = &quot;&quot;;
1922                 for (AnnotationValue av : annotationTypeValues) {
1923                     annotation.add(sep);
1924                     annotation.add(annotationValueToContent(av));
1925                     sep = &quot;,&quot;;
1926                 }
1927                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
1928                 isContainerDocumented = false;
1929             }
1930             annotation.add(&quot;)&quot;);
1931         }
1932     }
1933 
1934     /**
1935      * Check if the annotation contains an array of annotation as a value. This
1936      * check is to verify if a repeatable type annotation is present or not.
1937      *
1938      * @param pairs annotation type element and value pairs
1939      *
1940      * @return true if the annotation contains an array of annotation as a value.
1941      */
1942     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
1943         AnnotationValue annotationValue;
1944         for (ExecutableElement ee : pairs.keySet()) {
1945             annotationValue = pairs.get(ee);
1946             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1947                 @Override
1948                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
1949                     if (vals.size() &gt; 1) {
1950                         if (vals.get(0) instanceof AnnotationMirror) {
1951                             isContainerDocumented = true;
1952                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1953                                 @Override
1954                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
1955                                     isContainerDocumented = true;
1956                                     Element asElement = a.getAnnotationType().asElement();
1957                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
1958                                         isAnnotationDocumented = true;
1959                                     }
1960                                     return true;
1961                                 }
1962                                 @Override
1963                                 protected Boolean defaultAction(Object o, Void p) {
1964                                     return false;
1965                                 }
1966                             }.visit(vals.get(0));
1967                         }
1968                     }
1969                     return false;
1970                 }
1971 
1972                 @Override
1973                 protected Boolean defaultAction(Object o, Void p) {
1974                     return false;
1975                 }
1976             }.visit(annotationValue);
1977             if (rvalue) {
1978                 return true;
1979             }
1980         }
1981         return false;
1982     }
1983 
1984     private Content annotationValueToContent(AnnotationValue annotationValue) {
1985         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
1986 
1987             @Override
1988             public Content visitType(TypeMirror t, Void p) {
1989                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
1990                     @Override
1991                     public Content visitDeclared(DeclaredType t, Void p) {
1992                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1993                                 LinkInfoImpl.Kind.ANNOTATION, t);
1994                         String name = utils.isIncluded(t.asElement())
1995                                 ? t.asElement().getSimpleName().toString()
1996                                 : utils.getFullyQualifiedName(t.asElement());
1997                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
1998                         return getLink(linkInfo);
1999                     }
2000                     @Override
2001                     protected Content defaultAction(TypeMirror e, Void p) {
2002                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2003                     }
2004                 }.visit(t);
2005             }
2006             @Override
2007             public Content visitAnnotation(AnnotationMirror a, Void p) {
2008                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);
2009                 ContentBuilder buf = new ContentBuilder();
2010                 for (Content c : list) {
2011                     buf.add(c);
2012                 }
2013                 return buf;
2014             }
2015             @Override
2016             public Content visitEnumConstant(VariableElement c, Void p) {
2017                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2018                         c, c.getSimpleName(), false);
2019             }
2020             @Override
2021             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2022                 ContentBuilder buf = new ContentBuilder();
2023                 String sep = &quot;&quot;;
2024                 for (AnnotationValue av : vals) {
2025                     buf.add(sep);
2026                     buf.add(visit(av));
2027                     sep = &quot; &quot;;
2028                 }
2029                 return buf;
2030             }
2031             @Override
2032             protected Content defaultAction(Object o, Void p) {
2033                 return new StringContent(annotationValue.toString());
2034             }
2035         }.visit(annotationValue);
2036     }
2037 
2038     protected TableHeader getPackageTableHeader() {
2039         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2040     }
2041 
2042     /**
2043      * Generates a string for use in a description meta element,
2044      * based on an element and its enclosing elements
2045      * @param prefix a prefix for the string
2046      * @param elem the element
2047      * @return the description
2048      */
2049     static String getDescription(String prefix, Element elem) {
2050         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2051         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2052             // ignore unnamed enclosing elements
2053             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2054                 break;
2055             }
2056             chain.addFirst(e);
2057         }
2058         StringBuilder sb = new StringBuilder();
2059         for (Element e: chain) {
2060             CharSequence name;
2061             switch (e.getKind()) {
2062                 case MODULE:
2063                 case PACKAGE:
2064                     name = ((QualifiedNameable) e).getQualifiedName();
2065                     if (name.length() == 0) {
2066                         name = &quot;&lt;unnamed&gt;&quot;;
2067                     }
2068                     break;
2069 
2070                 default:
2071                     name = e.getSimpleName();
2072                     break;
2073             }
2074 
2075             if (sb.length() == 0) {
2076                 sb.append(prefix).append(&quot;: &quot;);
2077             } else {
2078                 sb.append(&quot;, &quot;);
2079             }
2080             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2081                     .append(&quot;: &quot;)
2082                     .append(name);
2083         }
2084         return sb.toString();
2085     }
2086 
2087     static String getGenerator(Class&lt;?&gt; clazz) {
2088         return &quot;javadoc/&quot; + clazz.getSimpleName();
2089     }
2090 
2091     /**
2092      * Returns an HtmlTree for the BODY tag.
2093      *
2094      * @param title title for the window
2095      * @return an HtmlTree for the BODY tag
2096      */
2097     public HtmlTree getBody(String title) {
<a name="15" id="anc15"></a><span class="line-modified">2098         HtmlTree body = new HtmlTree(TagName.BODY);</span>
2099         body.put(HtmlAttr.CLASS, getBodyClass());
2100 
2101         this.winTitle = title;
2102         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2103         // and package-frame
2104         body.add(mainBodyScript.asContent());
2105         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2106         body.add(noScript);
2107         return body;
2108     }
2109 
2110     public String getBodyClass() {
2111         return getClass().getSimpleName()
2112                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2113                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2114                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)
2115                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)
2116                 .toLowerCase(Locale.US);
2117     }
2118 
2119     Script getMainBodyScript() {
2120         return mainBodyScript;
2121     }
2122 
2123     /**
2124      * Returns the path of module/package specific stylesheets for the element.
2125      * @param element module/Package element
2126      * @return list of path of module/package specific stylesheets
2127      * @throws DocFileIOException
2128      */
2129     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2130         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2131         DocPath basePath = null;
2132         if (element instanceof PackageElement) {
2133             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2134             basePath = docPaths.forPackage((PackageElement)element);
2135         } else if (element instanceof ModuleElement) {
2136             basePath = DocPaths.forModule((ModuleElement)element);
2137         }
2138         for (DocPath stylesheet : getStylesheets(element)) {
2139             stylesheets.add(basePath.resolve(stylesheet.getPath()));
2140         }
2141         return stylesheets;
2142     }
2143 
2144     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws
2145             DocFileIOException {
2146         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();
2147         ModuleElement moduleElement = utils.containingModule(pkgElement);
2148         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {
2149             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);
2150             DocPath basePath = DocPaths.forModule(moduleElement);
2151             for (DocPath stylesheet : localStylesheets) {
2152                 moduleStylesheets.add(basePath.resolve(stylesheet));
2153             }
2154         }
2155         return moduleStylesheets;
2156     }
2157 
2158     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {
2159         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2160         if (localStylesheets == null) {
2161             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2162                     .getWriterFactory().getDocFilesHandler(element);
2163             localStylesheets = docFilesHandler.getStylesheets();
2164             configuration.localStylesheetMap.put(element, localStylesheets);
2165         }
2166         return localStylesheets;
2167     }
2168 
2169     Content getVerticalSeparator() {
2170         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));
2171     }
2172 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
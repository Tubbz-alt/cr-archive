diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractIndexWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,31 +24,32 @@
  */
 
 package jdk.javadoc.internal.doclets.formats.html;
 
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.Writer;
 import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipOutputStream;
+import java.util.Map;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.ModuleElement;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.SimpleElementVisitor14;
 
 import com.sun.source.doctree.DocTree;
+import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;
 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
-import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
-import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;
 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 import jdk.javadoc.internal.doclets.toolkit.Content;
 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
@@ -71,28 +72,34 @@
 public class AbstractIndexWriter extends HtmlDocletWriter {
 
     /**
      * The index of all the members with unicode character.
      */
-    protected IndexBuilder indexbuilder;
+    protected IndexBuilder indexBuilder;
 
     protected Navigation navBar;
 
+    protected final Map<Character, List<SearchIndexItem>> tagSearchIndexMap;
+
     /**
      * This constructor will be used by {@link SplitIndexWriter}. Initializes
      * path to this file and relative path from this file.
      *
      * @param configuration  The current configuration
      * @param path       Path to the file which is getting generated.
-     * @param indexbuilder Unicode based Index from {@link IndexBuilder}
+     * @param indexBuilder Unicode based Index from {@link IndexBuilder}
      */
     protected AbstractIndexWriter(HtmlConfiguration configuration,
                                   DocPath path,
-                                  IndexBuilder indexbuilder) {
+                                  IndexBuilder indexBuilder) {
         super(configuration, path);
-        this.indexbuilder = indexbuilder;
+        this.indexBuilder = indexBuilder;
         this.navBar = new Navigation(null, configuration, PageMode.INDEX, path);
+        Stream<SearchIndexItem> items =
+                searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY)
+                        .sorted(utils.makeGenericSearchIndexComparator());
+        this.tagSearchIndexMap = buildSearchTagIndex(items);
     }
 
     /**
      * Add the member information for the unicode character along with the
      * list of the members.
@@ -104,11 +111,11 @@
     protected void addContents(Character uc, Collection<? extends Element> memberlist,
             Content contentTree) {
         addHeading(uc, contentTree);
         // Display the list only if there are elements to be displayed.
         if (!memberlist.isEmpty()) {
-            Content dl = new HtmlTree(HtmlTag.DL);
+            HtmlTree dl = HtmlTree.DL(HtmlStyle.index);
             for (Element element : memberlist) {
                 addDescription(dl, element);
             }
             contentTree.add(dl);
         }
@@ -117,11 +124,11 @@
     protected void addSearchContents(Character uc, List<SearchIndexItem> searchList,
             Content contentTree) {
         addHeading(uc, contentTree);
         // Display the list only if there are elements to be displayed.
         if (!searchList.isEmpty()) {
-            Content dl = new HtmlTree(HtmlTag.DL);
+            HtmlTree dl = HtmlTree.DL(HtmlStyle.index);
             for (SearchIndexItem sii : searchList) {
                 addDescription(sii, dl);
             }
             contentTree.add(dl);
         }
@@ -132,11 +139,11 @@
         addHeading(uc, contentTree);
         int memberListSize = memberlist.size();
         int searchListSize = searchList.size();
         int i = 0;
         int j = 0;
-        Content dl = new HtmlTree(HtmlTag.DL);
+        HtmlTree dl = HtmlTree.DL(HtmlStyle.index);
         while (i < memberListSize && j < searchListSize) {
             Element elem = memberlist.get(i);
             String name = (utils.isModule(elem))
                     ? utils.getFullyQualifiedName(elem) : utils.getSimpleName(elem);
             if (name.compareTo(searchList.get(j).getLabel()) < 0) {
@@ -168,11 +175,11 @@
     }
 
     protected void addHeading(Character uc, Content contentTree) {
         String unicode = uc.toString();
         Content headContent = new StringContent(unicode);
-        HtmlTree heading = HtmlTree.HEADING(Headings.CONTENT_HEADING, false,
+        HtmlTree heading = HtmlTree.HEADING(Headings.CONTENT_HEADING,
                 HtmlStyle.title, headContent);
         heading.setId(getNameForIndex(unicode));
         contentTree.add(heading);
     }
 
@@ -183,33 +190,33 @@
 
             @Override
             public Void visitModule(ModuleElement e, Void p) {
                 if (configuration.showModules) {
                     addDescription(e, dl, si);
-                    configuration.moduleSearchIndex.add(si);
+                    searchItems.add(si);
                 }
                 return null;
             }
 
             @Override
             public Void visitPackage(PackageElement e, Void p) {
                 addDescription(e, dl, si);
-                configuration.packageSearchIndex.add(si);
+                searchItems.add(si);
                 return null;
             }
 
             @Override
             public Void visitType(TypeElement e, Void p) {
                 addDescription(e, dl, si);
-                configuration.typeSearchIndex.add(si);
+                searchItems.add(si);
                 return null;
             }
 
             @Override
             protected Void defaultAction(Element e, Void p) {
                 addDescription(e, dl, si);
-                configuration.memberSearchIndex.add(si);
+                searchItems.add(si);
                 return null;
             }
 
         }.visit(element);
     }
@@ -223,17 +230,17 @@
      */
     protected void addDescription(ModuleElement mdle, Content dlTree, SearchIndexItem si) {
         String moduleName = utils.getFullyQualifiedName(mdle);
         Content link = getModuleLink(mdle, new StringContent(moduleName));
         si.setLabel(moduleName);
-        si.setCategory(SearchIndexItem.Category.MODULES);
+        si.setCategory(Category.MODULES);
         Content dt = HtmlTree.DT(link);
         dt.add(" - ");
         dt.add(contents.module_);
         dt.add(" " + moduleName);
         dlTree.add(dt);
-        Content dd = new HtmlTree(HtmlTag.DD);
+        Content dd = new HtmlTree(TagName.DD);
         addSummaryComment(mdle, dd);
         dlTree.add(dd);
     }
 
     /**
@@ -247,17 +254,17 @@
         Content link = getPackageLink(pkg, new StringContent(utils.getPackageName(pkg)));
         if (configuration.showModules) {
             si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(pkg)));
         }
         si.setLabel(utils.getPackageName(pkg));
-        si.setCategory(SearchIndexItem.Category.PACKAGES);
+        si.setCategory(Category.PACKAGES);
         Content dt = HtmlTree.DT(link);
         dt.add(" - ");
         dt.add(contents.package_);
         dt.add(" " + utils.getPackageName(pkg));
         dlTree.add(dt);
-        Content dd = new HtmlTree(HtmlTag.DD);
+        Content dd = new HtmlTree(TagName.DD);
         addSummaryComment(pkg, dd);
         dlTree.add(dd);
     }
 
     /**
@@ -270,16 +277,16 @@
     protected void addDescription(TypeElement typeElement, Content dlTree, SearchIndexItem si) {
         Content link = getLink(new LinkInfoImpl(configuration,
                         LinkInfoImpl.Kind.INDEX, typeElement).strong(true));
         si.setContainingPackage(utils.getPackageName(utils.containingPackage(typeElement)));
         si.setLabel(utils.getSimpleName(typeElement));
-        si.setCategory(SearchIndexItem.Category.TYPES);
+        si.setCategory(Category.TYPES);
         Content dt = HtmlTree.DT(link);
         dt.add(" - ");
         addClassInfo(typeElement, dt);
         dlTree.add(dt);
-        Content dd = new HtmlTree(HtmlTag.DD);
+        Content dd = new HtmlTree(TagName.DD);
         addComment(typeElement, dd);
         dlTree.add(dd);
     }
 
     /**
@@ -318,18 +325,18 @@
                 si.setUrl(url);
             }
         }  else {
             si.setLabel(name);
         }
-        si.setCategory(SearchIndexItem.Category.MEMBERS);
+        si.setCategory(Category.MEMBERS);
         Content span = HtmlTree.SPAN(HtmlStyle.memberNameLink,
                 getDocLink(LinkInfoImpl.Kind.INDEX, member, name));
         Content dt = HtmlTree.DT(span);
         dt.add(" - ");
         addMemberDesc(member, dt);
         dlTree.add(dt);
-        Content dd = new HtmlTree(HtmlTag.DD);
+        Content dd = new HtmlTree(TagName.DD);
         addComment(member, dd);
         dlTree.add(dd);
     }
 
     protected void addDescription(SearchIndexItem sii, Content dlTree) {
@@ -338,11 +345,11 @@
         HtmlTree labelLink = HtmlTree.A(siiPath, new StringContent(sii.getLabel()));
         Content dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.searchTagLink, labelLink));
         dt.add(" - ");
         dt.add(contents.getContent("doclet.Search_tag_in", sii.getHolder()));
         dlTree.add(dt);
-        Content dd = new HtmlTree(HtmlTag.DD);
+        Content dd = new HtmlTree(TagName.DD);
         if (sii.getDescription().isEmpty()) {
             dd.add(Entity.NO_BREAK_SPACE);
         } else {
             dd.add(sii.getDescription());
         }
@@ -359,11 +366,11 @@
      * @param contentTree the content tree to which the comment will be added
      */
     protected void addComment(Element element, Content contentTree) {
         List<? extends DocTree> tags;
         Content span = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(element));
-        HtmlTree div = new HtmlTree(HtmlTag.DIV);
+        HtmlTree div = new HtmlTree(TagName.DIV);
         div.setStyle(HtmlStyle.deprecationBlock);
         if (utils.isDeprecated(element)) {
             div.add(span);
             tags = utils.getBlockTags(element, DocTree.Kind.DEPRECATED);
             if (!tags.isEmpty())
@@ -424,51 +431,61 @@
     /**
      * @throws DocFileIOException if there is a problem creating any of the search index files
      */
     protected void createSearchIndexFiles() throws DocFileIOException {
         if (configuration.showModules) {
-            createSearchIndexFile(DocPaths.MODULE_SEARCH_INDEX_JSON, DocPaths.MODULE_SEARCH_INDEX_ZIP,
-                    DocPaths.MODULE_SEARCH_INDEX_JS, configuration.moduleSearchIndex, "moduleSearchIndex");
+            createSearchIndexFile(DocPaths.MODULE_SEARCH_INDEX_JS,
+                                  searchItems.itemsOfCategories(Category.MODULES),
+                                  "moduleSearchIndex");
         }
         if (!configuration.packages.isEmpty()) {
             SearchIndexItem si = new SearchIndexItem();
-            si.setCategory(SearchIndexItem.Category.PACKAGES);
+            si.setCategory(Category.PACKAGES);
             si.setLabel(resources.getText("doclet.All_Packages"));
             si.setUrl(DocPaths.ALLPACKAGES_INDEX.getPath());
-            configuration.packageSearchIndex.add(si);
+            searchItems.add(si);
         }
-        createSearchIndexFile(DocPaths.PACKAGE_SEARCH_INDEX_JSON, DocPaths.PACKAGE_SEARCH_INDEX_ZIP,
-                DocPaths.PACKAGE_SEARCH_INDEX_JS, configuration.packageSearchIndex, "packageSearchIndex");
+        createSearchIndexFile(DocPaths.PACKAGE_SEARCH_INDEX_JS,
+                              searchItems.itemsOfCategories(Category.PACKAGES),
+                              "packageSearchIndex");
         SearchIndexItem si = new SearchIndexItem();
-        si.setCategory(SearchIndexItem.Category.TYPES);
+        si.setCategory(Category.TYPES);
         si.setLabel(resources.getText("doclet.All_Classes"));
         si.setUrl(DocPaths.ALLCLASSES_INDEX.getPath());
-        configuration.typeSearchIndex.add(si);
-        createSearchIndexFile(DocPaths.TYPE_SEARCH_INDEX_JSON, DocPaths.TYPE_SEARCH_INDEX_ZIP,
-                DocPaths.TYPE_SEARCH_INDEX_JS, configuration.typeSearchIndex, "typeSearchIndex");
-        createSearchIndexFile(DocPaths.MEMBER_SEARCH_INDEX_JSON, DocPaths.MEMBER_SEARCH_INDEX_ZIP,
-                DocPaths.MEMBER_SEARCH_INDEX_JS, configuration.memberSearchIndex, "memberSearchIndex");
-        createSearchIndexFile(DocPaths.TAG_SEARCH_INDEX_JSON, DocPaths.TAG_SEARCH_INDEX_ZIP,
-                DocPaths.TAG_SEARCH_INDEX_JS, configuration.tagSearchIndex, "tagSearchIndex");
+        searchItems.add(si);
+        createSearchIndexFile(DocPaths.TYPE_SEARCH_INDEX_JS,
+                              searchItems.itemsOfCategories(Category.TYPES),
+                              "typeSearchIndex");
+        createSearchIndexFile(DocPaths.MEMBER_SEARCH_INDEX_JS,
+                              searchItems.itemsOfCategories(Category.MEMBERS),
+                              "memberSearchIndex");
+        createSearchIndexFile(DocPaths.TAG_SEARCH_INDEX_JS,
+                              searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY),
+                              "tagSearchIndex");
     }
 
     /**
      * Creates a search index file.
      *
-     * @param searchIndexFile   the file to be generated
-     * @param searchIndexZip    the zip file to be generated
      * @param searchIndexJS     the file for the JavaScript to be generated
      * @param searchIndex       the search index items
      * @param varName           the variable name to write in the JavaScript file
      * @throws DocFileIOException if there is a problem creating the search index file
      */
-    protected void createSearchIndexFile(DocPath searchIndexFile, DocPath searchIndexZip,
-            DocPath searchIndexJS, Collection<SearchIndexItem> searchIndex, String varName) throws DocFileIOException {
-        if (!searchIndex.isEmpty()) {
+    protected void createSearchIndexFile(DocPath searchIndexJS,
+                                         Stream<SearchIndexItem> searchIndex,
+                                         String varName)
+            throws DocFileIOException
+    {
+        // The file needs to be created even if there are no searchIndex items
+        // File could be written straight-through, without an intermediate StringBuilder
+        Iterator<SearchIndexItem> index = searchIndex.iterator();
+        if (index.hasNext()) {
             StringBuilder searchVar = new StringBuilder("[");
             boolean first = true;
-            for (SearchIndexItem item : searchIndex) {
+            while (index.hasNext()) {
+                SearchIndexItem item = index.next();
                 if (first) {
                     searchVar.append(item.toString());
                     first = false;
                 } else {
                     searchVar.append(",").append(item.toString());
@@ -481,22 +498,18 @@
                 wr.write(" = ");
                 wr.write(searchVar.toString());
             } catch (IOException ie) {
                 throw new DocFileIOException(jsFile, DocFileIOException.Mode.WRITE, ie);
             }
-
-            DocFile zipFile = DocFile.createFileForOutput(configuration, searchIndexZip);
-            try (OutputStream fos = zipFile.openOutputStream();
-                    ZipOutputStream zos = new ZipOutputStream(fos)) {
-                try {
-                    ZipEntry ze = new ZipEntry(searchIndexFile.getPath());
-                    zos.putNextEntry(ze);
-                    zos.write(searchVar.toString().getBytes());
-                } finally {
-                    zos.closeEntry();
-                }
-            } catch (IOException ie) {
-                throw new DocFileIOException(zipFile, DocFileIOException.Mode.WRITE, ie);
-            }
         }
     }
+
+    private static Map<Character, List<SearchIndexItem>> buildSearchTagIndex(
+            Stream<? extends SearchIndexItem> searchItems)
+    {
+        return searchItems.collect(Collectors.groupingBy(i -> keyCharacter(i.getLabel())));
+    }
+
+    protected static Character keyCharacter(String s) {
+        return s.isEmpty() ? '*' : Character.toUpperCase(s.charAt(0));
+    }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
 159         deferredLintHandler = DeferredLintHandler.instance(context);



 160     }
 161 
 162     /** Character for synthetic names
 163      */
 164     char syntheticNameChar;
 165 
 166     /** A table mapping flat names of all compiled classes for each module in this run
 167      *  to their symbols; maintained from outside.
 168      */
 169     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 170 
 171     /** A handler for messages about deprecated usage.
 172      */
 173     private MandatoryWarningHandler deprecationHandler;
 174 
 175     /** A handler for messages about deprecated-for-removal usage.
 176      */
 177     private MandatoryWarningHandler removalHandler;
 178 
 179     /** A handler for messages about unchecked or unsafe usage.
 180      */
 181     private MandatoryWarningHandler uncheckedHandler;
 182 
 183     /** A handler for messages about using proprietary API.
 184      */
 185     private MandatoryWarningHandler sunApiHandler;
 186 
 187     /** A handler for deferred lint warnings.
 188      */
 189     private DeferredLintHandler deferredLintHandler;
 190 




 191 /* *************************************************************************
 192  * Errors and Warnings
 193  **************************************************************************/
 194 
 195     Lint setLint(Lint newLint) {
 196         Lint prev = lint;
 197         lint = newLint;
 198         return prev;
 199     }
 200 
 201     MethodSymbol setMethod(MethodSymbol newMethod) {
 202         MethodSymbol prev = method;
 203         method = newMethod;
 204         return prev;
 205     }
 206 
 207     /** Warn about deprecated symbol.
 208      *  @param pos        Position to be used for error reporting.
 209      *  @param sym        The deprecated symbol.
 210      */
</pre>
<hr />
<pre>
3147                 if (!(app instanceof Attribute.Enum)) {
3148                     continue; // recovery
3149                 }
3150                 Attribute.Enum e = (Attribute.Enum)app;
3151                 containedTargets.add(e.value.name);
3152             }
3153         }
3154 
3155         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3156             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3157         }
3158     }
3159 
3160     /* get a set of names for the default target */
3161     private Set&lt;Name&gt; getDefaultTargetSet() {
3162         if (defaultTargets == null) {
3163             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3164             targets.add(names.ANNOTATION_TYPE);
3165             targets.add(names.CONSTRUCTOR);
3166             targets.add(names.FIELD);
<span class="line-modified">3167             targets.add(names.RECORD_COMPONENT);</span>


3168             targets.add(names.LOCAL_VARIABLE);
3169             targets.add(names.METHOD);
3170             targets.add(names.PACKAGE);
3171             targets.add(names.PARAMETER);
3172             targets.add(names.TYPE);
3173 
3174             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3175         }
3176 
3177         return defaultTargets;
3178     }
3179     private Set&lt;Name&gt; defaultTargets;
3180 
3181 
3182     /** Checks that s is a subset of t, with respect to ElementType
3183      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3184      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3185      * TYPE_PARAMETER}.
3186      */
3187     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
</pre>
</td>
<td>
<hr />
<pre>
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
 159         deferredLintHandler = DeferredLintHandler.instance(context);
<span class="line-added"> 160 </span>
<span class="line-added"> 161         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 162                 Feature.RECORDS.allowedInSource(source);</span>
 163     }
 164 
 165     /** Character for synthetic names
 166      */
 167     char syntheticNameChar;
 168 
 169     /** A table mapping flat names of all compiled classes for each module in this run
 170      *  to their symbols; maintained from outside.
 171      */
 172     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 173 
 174     /** A handler for messages about deprecated usage.
 175      */
 176     private MandatoryWarningHandler deprecationHandler;
 177 
 178     /** A handler for messages about deprecated-for-removal usage.
 179      */
 180     private MandatoryWarningHandler removalHandler;
 181 
 182     /** A handler for messages about unchecked or unsafe usage.
 183      */
 184     private MandatoryWarningHandler uncheckedHandler;
 185 
 186     /** A handler for messages about using proprietary API.
 187      */
 188     private MandatoryWarningHandler sunApiHandler;
 189 
 190     /** A handler for deferred lint warnings.
 191      */
 192     private DeferredLintHandler deferredLintHandler;
 193 
<span class="line-added"> 194     /** Are records allowed</span>
<span class="line-added"> 195      */</span>
<span class="line-added"> 196     private final boolean allowRecords;</span>
<span class="line-added"> 197 </span>
 198 /* *************************************************************************
 199  * Errors and Warnings
 200  **************************************************************************/
 201 
 202     Lint setLint(Lint newLint) {
 203         Lint prev = lint;
 204         lint = newLint;
 205         return prev;
 206     }
 207 
 208     MethodSymbol setMethod(MethodSymbol newMethod) {
 209         MethodSymbol prev = method;
 210         method = newMethod;
 211         return prev;
 212     }
 213 
 214     /** Warn about deprecated symbol.
 215      *  @param pos        Position to be used for error reporting.
 216      *  @param sym        The deprecated symbol.
 217      */
</pre>
<hr />
<pre>
3154                 if (!(app instanceof Attribute.Enum)) {
3155                     continue; // recovery
3156                 }
3157                 Attribute.Enum e = (Attribute.Enum)app;
3158                 containedTargets.add(e.value.name);
3159             }
3160         }
3161 
3162         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3163             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3164         }
3165     }
3166 
3167     /* get a set of names for the default target */
3168     private Set&lt;Name&gt; getDefaultTargetSet() {
3169         if (defaultTargets == null) {
3170             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3171             targets.add(names.ANNOTATION_TYPE);
3172             targets.add(names.CONSTRUCTOR);
3173             targets.add(names.FIELD);
<span class="line-modified">3174             if (allowRecords) {</span>
<span class="line-added">3175                 targets.add(names.RECORD_COMPONENT);</span>
<span class="line-added">3176             }</span>
3177             targets.add(names.LOCAL_VARIABLE);
3178             targets.add(names.METHOD);
3179             targets.add(names.PACKAGE);
3180             targets.add(names.PARAMETER);
3181             targets.add(names.TYPE);
3182 
3183             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3184         }
3185 
3186         return defaultTargets;
3187     }
3188     private Set&lt;Name&gt; defaultTargets;
3189 
3190 
3191     /** Checks that s is a subset of t, with respect to ElementType
3192      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3193      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3194      * TYPE_PARAMETER}.
3195      */
3196     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
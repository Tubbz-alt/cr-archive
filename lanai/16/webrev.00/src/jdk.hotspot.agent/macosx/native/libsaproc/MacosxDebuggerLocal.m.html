<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;objc/objc-runtime.h&gt;
  26 #import &lt;Foundation/Foundation.h&gt;
  27 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
  28 #import &lt;JavaRuntimeSupport/JavaRuntimeSupport.h&gt;
  29 
  30 #include &lt;jni.h&gt;
  31 
  32 #import &lt;mach/mach.h&gt;
  33 #import &lt;mach/mach_types.h&gt;
  34 #import &lt;sys/sysctl.h&gt;
  35 #import &lt;stdio.h&gt;
  36 #import &lt;string.h&gt;
  37 #import &lt;stdarg.h&gt;
  38 #import &lt;stdlib.h&gt;
  39 #import &lt;strings.h&gt;
  40 #import &lt;dlfcn.h&gt;
  41 #import &lt;limits.h&gt;
  42 #import &lt;errno.h&gt;
  43 #import &lt;sys/types.h&gt;
  44 #import &lt;sys/ptrace.h&gt;
  45 #include &quot;libproc_impl.h&quot;
  46 
  47 #define UNSUPPORTED_ARCH &quot;Unsupported architecture!&quot;
  48 
  49 #if defined(x86_64) &amp;&amp; !defined(amd64)
  50 #define amd64 1
  51 #endif
  52 
  53 #if amd64
  54 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
  55 #else
  56 #error UNSUPPORTED_ARCH
  57 #endif
  58 
  59 static jfieldID symbolicatorID = 0; // set in _init0
  60 static jfieldID taskID = 0; // set in _init0
  61 
  62 static jfieldID p_ps_prochandle_ID = 0;
  63 static jfieldID loadObjectList_ID = 0;
  64 static jmethodID listAdd_ID = 0;
  65 
  66 static jmethodID createClosestSymbol_ID = 0;
  67 static jmethodID createLoadObject_ID = 0;
  68 static jmethodID getJavaThreadsInfo_ID = 0;
  69 
  70 // indicator if thread id (lwpid_t) was set
  71 static bool _threads_filled = false;
  72 
  73 // mach_exc_server defined in the generated mach_excServer.c
  74 extern boolean_t mach_exc_server(mach_msg_header_t *input_msg_hdr,
  75                                  mach_msg_header_t *output_msg_hdr);
  76 
  77 kern_return_t catch_mach_exception_raise(
  78   mach_port_t exception_port, mach_port_t thread,
  79   mach_port_t task, exception_type_t exception,
  80   mach_exception_data_t code,
  81   mach_msg_type_number_t code_cnt);
  82 
  83 kern_return_t catch_mach_exception_raise_state(
  84   mach_port_t exception_port, exception_type_t exception,
  85   const mach_exception_data_t code, mach_msg_type_number_t code_cnt,
  86   int *flavor, const thread_state_t old_state,
  87   mach_msg_type_number_t old_state_cnt, thread_state_t new_state,
  88   mach_msg_type_number_t *new_state_cnt);
  89 
  90 kern_return_t catch_mach_exception_raise_state_identity(
  91   mach_port_t exception_port, mach_port_t thread, mach_port_t task,
  92   exception_type_t exception, mach_exception_data_t code,
  93   mach_msg_type_number_t code_cnt, int *flavor, thread_state_t old_state,
  94   mach_msg_type_number_t old_state_cnt, thread_state_t new_state,
  95   mach_msg_type_number_t *new_state_cnt);
  96 
  97 static struct exception_saved_state {
  98   exception_mask_t       saved_masks[EXC_TYPES_COUNT];
  99   mach_port_t            saved_ports[EXC_TYPES_COUNT];
 100   exception_behavior_t   saved_behaviors[EXC_TYPES_COUNT];
 101   thread_state_flavor_t  saved_flavors[EXC_TYPES_COUNT];
 102   mach_msg_type_number_t saved_exception_types_count;
 103 } exception_saved_state;
 104 
 105 static mach_port_t tgt_exception_port;
 106 
 107 // Mirrors __Reply__mach_exception_raise_t generated in mach_excServer.c
 108 static struct rep_msg {
 109   mach_msg_header_t header;
 110   NDR_record_t ndr;
 111   kern_return_t ret_code;
 112 } rep_msg;
 113 
 114 // Mirrors __Request__mach_exception_raise_t generated in mach_excServer.c
 115 // with a large trailing pad to avoid MACH_MSG_RCV_TOO_LARGE
 116 static struct exc_msg {
 117   mach_msg_header_t header;
 118   // start of the kernel processed data
 119   mach_msg_body_t msgh_body;
 120   mach_msg_port_descriptor_t thread;
 121   mach_msg_port_descriptor_t task;
 122   // end of the kernel processed data
 123   NDR_record_t ndr;
 124   exception_type_t exception;
 125   mach_msg_type_number_t code_cnt;
 126   mach_exception_data_t code; // an array of int64_t
 127   char pad[512];
 128 } exc_msg;
 129 
 130 static void putSymbolicator(JNIEnv *env, jobject this_obj, id symbolicator) {
 131   (*env)-&gt;SetLongField(env, this_obj, symbolicatorID, (jlong)(intptr_t)symbolicator);
 132 }
 133 
 134 static id getSymbolicator(JNIEnv *env, jobject this_obj) {
 135   jlong ptr = (*env)-&gt;GetLongField(env, this_obj, symbolicatorID);
 136   return (id)(intptr_t)ptr;
 137 }
 138 
 139 static void putTask(JNIEnv *env, jobject this_obj, task_t task) {
 140   (*env)-&gt;SetLongField(env, this_obj, taskID, (jlong)task);
 141 }
 142 
 143 static task_t getTask(JNIEnv *env, jobject this_obj) {
 144   jlong ptr = (*env)-&gt;GetLongField(env, this_obj, taskID);
 145   return (task_t)ptr;
 146 }
 147 
 148 #define CHECK_EXCEPTION_(value) if ((*env)-&gt;ExceptionOccurred(env)) { return value; }
 149 #define CHECK_EXCEPTION if ((*env)-&gt;ExceptionOccurred(env)) { return;}
 150 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throw_new_debugger_exception(env, str); return value; }
 151 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { throw_new_debugger_exception(env, str); return;}
 152 #define CHECK_EXCEPTION_CLEAR if ((*env)-&gt;ExceptionOccurred(env)) { (*env)-&gt;ExceptionClear(env); }
 153 #define CHECK_EXCEPTION_CLEAR_VOID if ((*env)-&gt;ExceptionOccurred(env)) { (*env)-&gt;ExceptionClear(env); return; }
 154 #define CHECK_EXCEPTION_CLEAR_(value) if ((*env)-&gt;ExceptionOccurred(env)) { (*env)-&gt;ExceptionClear(env); return value; }
 155 
 156 static void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
 157   jclass exceptionClass = (*env)-&gt;FindClass(env, &quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
 158   CHECK_EXCEPTION;
 159   (*env)-&gt;ThrowNew(env, exceptionClass, errMsg);
 160 }
 161 
 162 static struct ps_prochandle* get_proc_handle(JNIEnv* env, jobject this_obj) {
 163   jlong ptr = (*env)-&gt;GetLongField(env, this_obj, p_ps_prochandle_ID);
 164   return (struct ps_prochandle*)(intptr_t)ptr;
 165 }
 166 
 167 #if defined(__i386__)
 168     #define hsdb_thread_state_t     x86_thread_state32_t
 169     #define hsdb_float_state_t      x86_float_state32_t
 170     #define HSDB_THREAD_STATE       x86_THREAD_STATE32
 171     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32
 172     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
 173     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT
 174 #elif defined(__x86_64__)
 175     #define hsdb_thread_state_t     x86_thread_state64_t
 176     #define hsdb_float_state_t      x86_float_state64_t
 177     #define HSDB_THREAD_STATE       x86_THREAD_STATE64
 178     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE64
 179     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
 180     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE64_COUNT
 181 #else
 182     #error UNSUPPORTED_ARCH
 183 #endif
 184 
 185 /*
 186  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 187  * Method:    init0
 188  * Signature: ()V
 189  */
 190 JNIEXPORT void JNICALL
 191 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_init0(JNIEnv *env, jclass cls) {
 192   symbolicatorID = (*env)-&gt;GetFieldID(env, cls, &quot;symbolicator&quot;, &quot;J&quot;);
 193   CHECK_EXCEPTION;
 194   taskID = (*env)-&gt;GetFieldID(env, cls, &quot;task&quot;, &quot;J&quot;);
 195   CHECK_EXCEPTION;
 196 
 197   // for core file
 198   p_ps_prochandle_ID = (*env)-&gt;GetFieldID(env, cls, &quot;p_ps_prochandle&quot;, &quot;J&quot;);
 199   CHECK_EXCEPTION;
 200   loadObjectList_ID = (*env)-&gt;GetFieldID(env, cls, &quot;loadObjectList&quot;, &quot;Ljava/util/List;&quot;);
 201   CHECK_EXCEPTION;
 202 
 203   // methods we use
 204   createClosestSymbol_ID = (*env)-&gt;GetMethodID(env, cls, &quot;createClosestSymbol&quot;,
 205                     &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);
 206   CHECK_EXCEPTION;
 207   createLoadObject_ID = (*env)-&gt;GetMethodID(env, cls, &quot;createLoadObject&quot;,
 208                     &quot;(Ljava/lang/String;JJ)Lsun/jvm/hotspot/debugger/cdbg/LoadObject;&quot;);
 209   CHECK_EXCEPTION;
 210 
 211   // java.util.List method we call
 212   jclass listClass = (*env)-&gt;FindClass(env, &quot;java/util/List&quot;);
 213   CHECK_EXCEPTION;
 214   listAdd_ID = (*env)-&gt;GetMethodID(env, listClass, &quot;add&quot;, &quot;(Ljava/lang/Object;)Z&quot;);
 215   CHECK_EXCEPTION;
 216   getJavaThreadsInfo_ID = (*env)-&gt;GetMethodID(env, cls, &quot;getJavaThreadsInfo&quot;,
 217                                                      &quot;()[J&quot;);
 218   CHECK_EXCEPTION;
 219 
 220   init_libproc(getenv(&quot;LIBSAPROC_DEBUG&quot;) != NULL);
 221 }
 222 
 223 JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getAddressSize
 224   (JNIEnv *env, jclass cls)
 225 {
 226 #ifdef _LP64
 227   return 8;
 228 #else
 229   #error UNSUPPORTED_ARCH
 230 #endif
 231 }
 232 
 233 /** called by Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0 */
 234 jlong lookupByNameIncore(
 235   JNIEnv *env, struct ps_prochandle *ph, jobject this_obj, jstring objectName, jstring symbolName)
 236 {
 237   const char *objectName_cstr, *symbolName_cstr;
 238   jlong addr;
 239   jboolean isCopy;
 240   objectName_cstr = NULL;
 241   if (objectName != NULL) {
 242     objectName_cstr = (*env)-&gt;GetStringUTFChars(env, objectName, &amp;isCopy);
 243     CHECK_EXCEPTION_(0);
 244   }
 245   symbolName_cstr = (*env)-&gt;GetStringUTFChars(env, symbolName, &amp;isCopy);
 246   if ((*env)-&gt;ExceptionOccurred(env)) {
 247     if (objectName_cstr != NULL) {
 248       (*env)-&gt;ReleaseStringUTFChars(env, objectName, objectName_cstr);
 249     }
 250     return 0;
 251   }
 252 
 253   print_debug(&quot;look for %s \n&quot;, symbolName_cstr);
 254   addr = (jlong) lookup_symbol(ph, objectName_cstr, symbolName_cstr);
 255 
 256   if (objectName_cstr != NULL) {
 257     (*env)-&gt;ReleaseStringUTFChars(env, objectName, objectName_cstr);
 258   }
 259   (*env)-&gt;ReleaseStringUTFChars(env, symbolName, symbolName_cstr);
 260   return addr;
 261 }
 262 
 263 /*
 264  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 265  * Method:    lookupByName0
 266  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
 267  */
 268 JNIEXPORT jlong JNICALL
 269 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0(
 270   JNIEnv *env, jobject this_obj,
 271   jstring objectName, jstring symbolName)
 272 {
 273   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 274   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 275     return lookupByNameIncore(env, ph, this_obj, objectName, symbolName);
 276   }
 277 
 278   jlong address = 0;
 279 
 280 JNF_COCOA_ENTER(env);
 281   NSString *symbolNameString = JNFJavaToNSString(env, symbolName);
 282 
 283   print_debug(&quot;lookupInProcess called for %s\n&quot;, [symbolNameString UTF8String]);
 284 
 285   id symbolicator = getSymbolicator(env, this_obj);
 286   if (symbolicator != nil) {
 287     uint64_t (*dynamicCall)(id, SEL, NSString *) = (uint64_t (*)(id, SEL, NSString *))&amp;objc_msgSend;
 288     address = (jlong) dynamicCall(symbolicator, @selector(addressForSymbol:), symbolNameString);
 289   }
 290 
 291   print_debug(&quot;address of symbol %s = %llx\n&quot;, [symbolNameString UTF8String], address);
 292 JNF_COCOA_EXIT(env);
 293 
 294   return address;
 295 }
 296 
 297 /*
 298  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 299  * Method:    lookupByAddress0
 300  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
 301  */
 302 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByAddress0
 303   (JNIEnv *env, jobject this_obj, jlong addr) {
 304   uintptr_t offset;
 305   const char* sym = NULL;
 306   jstring sym_string;
 307 
 308   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 309   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 310     sym = symbol_for_pc(ph, (uintptr_t) addr, &amp;offset);
 311     if (sym == NULL) return 0;
 312     sym_string = (*env)-&gt;NewStringUTF(env, sym);
 313     CHECK_EXCEPTION_(0);
 314     return (*env)-&gt;CallObjectMethod(env, this_obj, createClosestSymbol_ID,
 315                                                 sym_string, (jlong)offset);
 316   }
 317   return 0;
 318 }
 319 
 320 /** called from Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0 */
 321 jbyteArray readBytesFromCore(
 322   JNIEnv *env, struct ps_prochandle *ph, jobject this_obj, jlong addr, jlong numBytes)
 323 {
 324   jboolean isCopy;
 325   jbyteArray array;
 326   jbyte *bufPtr;
 327   ps_err_e err;
 328 
 329   array = (*env)-&gt;NewByteArray(env, numBytes);
 330   CHECK_EXCEPTION_(0);
 331   bufPtr = (*env)-&gt;GetByteArrayElements(env, array, &amp;isCopy);
 332   CHECK_EXCEPTION_(0);
 333 
 334   err = ps_pread(ph, (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
 335   (*env)-&gt;ReleaseByteArrayElements(env, array, bufPtr, 0);
 336   return (err == PS_OK)? array : 0;
 337 }
 338 
 339 /*
 340  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 341  * Method:    readBytesFromProcess0
 342  * Signature: (JJ)Lsun/jvm/hotspot/debugger/ReadResult;
 343  */
 344 JNIEXPORT jbyteArray JNICALL
 345 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0(
 346   JNIEnv *env, jobject this_obj,
 347   jlong addr, jlong numBytes)
 348 {
 349   print_debug(&quot;readBytesFromProcess called. addr = %llx numBytes = %lld\n&quot;, addr, numBytes);
 350 
 351   // must allocate storage instead of using former parameter buf
 352   jbyteArray array;
 353 
 354   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 355   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 356     return readBytesFromCore(env, ph, this_obj, addr, numBytes);
 357   }
 358 
 359   array = (*env)-&gt;NewByteArray(env, numBytes);
 360   CHECK_EXCEPTION_(0);
 361 
 362   unsigned long alignedAddress;
 363   unsigned long alignedLength = 0;
 364   kern_return_t result;
 365   vm_offset_t *pages;
 366   int *mapped;
 367   long pageCount;
 368   uint byteCount;
 369   int i;
 370   unsigned long remaining;
 371 
 372   alignedAddress = trunc_page(addr);
 373   if (addr != alignedAddress) {
 374     alignedLength += addr - alignedAddress;
 375   }
 376   alignedLength = round_page(numBytes);
 377   pageCount = alignedLength/vm_page_size;
 378 
 379   // Allocate storage for pages and flags.
 380   pages = malloc(pageCount * sizeof(vm_offset_t));
 381   if (pages == NULL) {
 382     (*env)-&gt;DeleteLocalRef(env, array);
 383     return NULL;
 384   }
 385   mapped = calloc(pageCount, sizeof(int));
 386   if (mapped == NULL) {
 387     (*env)-&gt;DeleteLocalRef(env, array);
 388     free(pages);
 389     return NULL;
 390   }
 391 
 392   task_t gTask = getTask(env, this_obj);
 393   // Try to read each of the pages.
 394   for (i = 0; i &lt; pageCount; i++) {
 395     result = vm_read(gTask, alignedAddress + i*vm_page_size, vm_page_size,
 396 		     &amp;pages[i], &amp;byteCount);
 397     mapped[i] = (result == KERN_SUCCESS);
 398     // assume all failures are unmapped pages
 399   }
 400 
 401   print_debug(&quot;%ld pages\n&quot;, pageCount);
 402 
 403   remaining = numBytes;
 404 
 405   for (i = 0; i &lt; pageCount; i++) {
 406     unsigned long len = vm_page_size;
 407     unsigned long start = 0;
 408 
 409     if (i == 0) {
 410       start = addr - alignedAddress;
 411       len = vm_page_size - start;
 412     }
 413 
 414     if (i == (pageCount - 1)) {
 415       len = remaining;
 416     }
 417 
 418     if (mapped[i]) {
 419       print_debug(&quot;page %d mapped (len %ld start %ld)\n&quot;, i, len, start);
 420       (*env)-&gt;SetByteArrayRegion(env, array, 0, len, ((jbyte *) pages[i] + start));
 421       vm_deallocate(mach_task_self(), pages[i], vm_page_size);
 422     }
 423 
 424     remaining -= len;
 425   }
 426 
 427   free (pages);
 428   free (mapped);
 429   return array;
 430 }
 431 
 432 /** Only used for core file reading, set thread_id for threads which is got after core file parsed.
 433   * Thread context is available in Mach-O core file but thread id is not. We can get thread id
 434   * from Threads which store all java threads information when they are created. Here we can identify
 435   * them as java threads by checking if a thread&#39;s rsp or rbp within a java thread&#39;s stack.
 436   * Note Macosx uses unique_thread_id which is different from other platforms though printed ids
 437   * are still pthread id. Function BsdDebuggerLocal.getJavaThreadsInfo returns an array of long
 438   * integers to host all java threads&#39; id, stack_start, stack_end as:
 439   * [uid0, stack_start0, stack_end0, uid1, stack_start1, stack_end1, ...]
 440   *
 441   * The work cannot be done at init0 since Threads is not available yet(VM not initialized yet).
 442   * This function should be called only once if succeeded
 443   */
 444 bool fill_java_threads(JNIEnv* env, jobject this_obj, struct ps_prochandle* ph) {
 445   int n = 0, i = 0, j;
 446   struct reg regs;
 447 
 448   jlongArray thrinfos = (*env)-&gt;CallObjectMethod(env, this_obj, getJavaThreadsInfo_ID);
 449   CHECK_EXCEPTION_(false);
 450   int len = (int)(*env)-&gt;GetArrayLength(env, thrinfos);
 451   uint64_t* cinfos = (uint64_t *)(*env)-&gt;GetLongArrayElements(env, thrinfos, NULL);
 452   CHECK_EXCEPTION_(false);
 453   n = get_num_threads(ph);
 454   print_debug(&quot;fill_java_threads called, num_of_thread = %d\n&quot;, n);
 455   for (i = 0; i &lt; n; i++) {
 456     if (!get_nth_lwp_regs(ph, i, &amp;regs)) {
 457       print_debug(&quot;Could not get regs of thread %d, already set!\n&quot;, i);
 458       (*env)-&gt;ReleaseLongArrayElements(env, thrinfos, (jlong*)cinfos, 0);
 459       return false;
 460     }
 461     for (j = 0; j &lt; len; j += 3) {
 462       lwpid_t  uid = cinfos[j];
 463       uint64_t beg = cinfos[j + 1];
 464       uint64_t end = cinfos[j + 2];
 465       if ((regs.r_rsp &lt; end &amp;&amp; regs.r_rsp &gt;= beg) ||
 466           (regs.r_rbp &lt; end &amp;&amp; regs.r_rbp &gt;= beg)) {
 467         set_lwp_id(ph, i, uid);
 468         break;
 469       }
 470     }
 471   }
 472   (*env)-&gt;ReleaseLongArrayElements(env, thrinfos, (jlong*)cinfos, 0);
 473   CHECK_EXCEPTION_(false);
 474   return true;
 475 }
 476 
 477 /* For core file only, called from
 478  * Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0
 479  */
 480 jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, long lwp_id, struct ps_prochandle* ph) {
 481   if (!_threads_filled)  {
 482     if (!fill_java_threads(env, this_obj, ph)) {
 483       throw_new_debugger_exception(env, &quot;Failed to fill in threads&quot;);
 484       return 0;
 485     } else {
 486       _threads_filled = true;
 487     }
 488   }
 489 
 490   struct reg gregs;
 491   jboolean isCopy;
 492   jlongArray array;
 493   jlong *regs;
 494 
 495   if (get_lwp_regs(ph, lwp_id, &amp;gregs) != true) {
 496     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;get_thread_regs failed for a lwp&quot;, 0);
 497   }
 498 
 499 #undef NPRGREG
 500 #undef REG_INDEX
 501 #if amd64
 502 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 503 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 504 
 505   array = (*env)-&gt;NewLongArray(env, NPRGREG);
 506   CHECK_EXCEPTION_(0);
 507   regs = (*env)-&gt;GetLongArrayElements(env, array, &amp;isCopy);
 508 
 509   regs[REG_INDEX(R15)] = gregs.r_r15;
 510   regs[REG_INDEX(R14)] = gregs.r_r14;
 511   regs[REG_INDEX(R13)] = gregs.r_r13;
 512   regs[REG_INDEX(R12)] = gregs.r_r12;
 513   regs[REG_INDEX(RBP)] = gregs.r_rbp;
 514   regs[REG_INDEX(RBX)] = gregs.r_rbx;
 515   regs[REG_INDEX(R11)] = gregs.r_r11;
 516   regs[REG_INDEX(R10)] = gregs.r_r10;
 517   regs[REG_INDEX(R9)]  = gregs.r_r9;
 518   regs[REG_INDEX(R8)]  = gregs.r_r8;
 519   regs[REG_INDEX(RAX)] = gregs.r_rax;
 520   regs[REG_INDEX(RCX)] = gregs.r_rcx;
 521   regs[REG_INDEX(RDX)] = gregs.r_rdx;
 522   regs[REG_INDEX(RSI)] = gregs.r_rsi;
 523   regs[REG_INDEX(RDI)] = gregs.r_rdi;
 524   regs[REG_INDEX(RIP)] = gregs.r_rip;
 525   regs[REG_INDEX(CS)]  = gregs.r_cs;
 526   regs[REG_INDEX(RSP)] = gregs.r_rsp;
 527   regs[REG_INDEX(SS)]  = gregs.r_ss;
 528   regs[REG_INDEX(FSBASE)] = 0;
 529   regs[REG_INDEX(GSBASE)] = 0;
 530   regs[REG_INDEX(DS)] = gregs.r_ds;
 531   regs[REG_INDEX(ES)] = gregs.r_es;
 532   regs[REG_INDEX(FS)] = gregs.r_fs;
 533   regs[REG_INDEX(GS)] = gregs.r_gs;
 534   regs[REG_INDEX(TRAPNO)] = gregs.r_trapno;
 535   regs[REG_INDEX(RFL)]    = gregs.r_rflags;
 536 
 537   (*env)-&gt;ReleaseLongArrayElements(env, array, regs, JNI_COMMIT);
 538 #endif /* amd64 */
 539   return array;
 540 }
 541 
 542 /*
 543  * Lookup the thread_t that corresponds to the given thread_id.
 544  * The thread_id should be the result from calling thread_info() with THREAD_IDENTIFIER_INFO
 545  * and reading the m_ident_info.thread_id returned.
 546  * The returned thread_t is the mach send right to the kernel port for the corresponding thread.
 547  *
 548  * We cannot simply use the OSThread._thread_id field in the JVM. This is set to ::mach_thread_self()
 549  * in the VM, but that thread port is not valid for a remote debugger to access the thread.
 550  */
 551 thread_t
 552 lookupThreadFromThreadId(task_t task, jlong thread_id) {
 553   print_debug(&quot;lookupThreadFromThreadId thread_id=0x%llx\n&quot;, thread_id);
 554 
 555   thread_array_t thread_list = NULL;
 556   mach_msg_type_number_t thread_list_count = 0;
 557   thread_t result_thread = 0;
 558   int i;
 559 
 560   // get the list of all the send rights
 561   kern_return_t result = task_threads(task, &amp;thread_list, &amp;thread_list_count);
 562   if (result != KERN_SUCCESS) {
 563     print_debug(&quot;task_threads returned 0x%x\n&quot;, result);
 564     return 0;
 565   }
 566 
 567   for(i = 0 ; i &lt; thread_list_count; i++) {
 568     thread_identifier_info_data_t m_ident_info;
 569     mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;
 570 
 571     // get the THREAD_IDENTIFIER_INFO for the send right
 572     result = thread_info(thread_list[i], THREAD_IDENTIFIER_INFO, (thread_info_t) &amp;m_ident_info, &amp;count);
 573     if (result != KERN_SUCCESS) {
 574       print_debug(&quot;thread_info returned 0x%x\n&quot;, result);
 575       break;
 576     }
 577 
 578     // if this is the one we&#39;re looking for, return the send right
 579     if (thread_id == m_ident_info.thread_id)
 580     {
 581       result_thread = thread_list[i];
 582       break;
 583     }
 584   }
 585 
 586   vm_size_t thread_list_size = (vm_size_t) (thread_list_count * sizeof (thread_t));
 587   vm_deallocate(mach_task_self(), (vm_address_t) thread_list, thread_list_count);
 588 
 589   return result_thread;
 590 }
 591 
 592 
 593 /*
 594  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 595  * Method:    getThreadIntegerRegisterSet0
 596  * Signature: (J)[J
 597  */
 598 JNIEXPORT jlongArray JNICALL
 599 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0(
 600   JNIEnv *env, jobject this_obj,
 601   jlong thread_id)
 602 {
 603   print_debug(&quot;getThreadRegisterSet0 called\n&quot;);
 604 
 605   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 606   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 607     return getThreadIntegerRegisterSetFromCore(env, this_obj, thread_id, ph);
 608   }
 609 
 610   kern_return_t result;
 611   thread_t tid;
 612   mach_msg_type_number_t count = HSDB_THREAD_STATE_COUNT;
 613   hsdb_thread_state_t state;
 614   jlongArray registerArray;
 615   jlong *primitiveArray;
 616   task_t gTask = getTask(env, this_obj);
 617 
 618   tid = lookupThreadFromThreadId(gTask, thread_id);
 619 
 620   result = thread_get_state(tid, HSDB_THREAD_STATE, (thread_state_t)&amp;state, &amp;count);
 621 
 622   if (result != KERN_SUCCESS) {
 623     print_error(&quot;getregs: thread_get_state(%d) failed (%d)\n&quot;, tid, result);
 624     return NULL;
 625   }
 626 
 627 #if amd64
 628 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 629 #undef REG_INDEX
 630 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 631 
 632   // 64 bit
 633   print_debug(&quot;Getting threads for a 64-bit process\n&quot;);
 634   registerArray = (*env)-&gt;NewLongArray(env, NPRGREG);
 635   CHECK_EXCEPTION_(0);
 636   primitiveArray = (*env)-&gt;GetLongArrayElements(env, registerArray, NULL);
 637 
 638   primitiveArray[REG_INDEX(R15)] = state.__r15;
 639   primitiveArray[REG_INDEX(R14)] = state.__r14;
 640   primitiveArray[REG_INDEX(R13)] = state.__r13;
 641   primitiveArray[REG_INDEX(R12)] = state.__r12;
 642   primitiveArray[REG_INDEX(R11)] = state.__r11;
 643   primitiveArray[REG_INDEX(R10)] = state.__r10;
 644   primitiveArray[REG_INDEX(R9)]  = state.__r9;
 645   primitiveArray[REG_INDEX(R8)]  = state.__r8;
 646   primitiveArray[REG_INDEX(RDI)] = state.__rdi;
 647   primitiveArray[REG_INDEX(RSI)] = state.__rsi;
 648   primitiveArray[REG_INDEX(RBP)] = state.__rbp;
 649   primitiveArray[REG_INDEX(RBX)] = state.__rbx;
 650   primitiveArray[REG_INDEX(RDX)] = state.__rdx;
 651   primitiveArray[REG_INDEX(RCX)] = state.__rcx;
 652   primitiveArray[REG_INDEX(RAX)] = state.__rax;
 653   primitiveArray[REG_INDEX(TRAPNO)] = 0;            // trapno, not used
 654   primitiveArray[REG_INDEX(ERR)]    = 0;            // err, not used
 655   primitiveArray[REG_INDEX(RIP)] = state.__rip;
 656   primitiveArray[REG_INDEX(CS)]  = state.__cs;
 657   primitiveArray[REG_INDEX(RFL)] = state.__rflags;
 658   primitiveArray[REG_INDEX(RSP)] = state.__rsp;
 659   primitiveArray[REG_INDEX(SS)] = 0;                // We don&#39;t have SS
 660   primitiveArray[REG_INDEX(FS)] = state.__fs;
 661   primitiveArray[REG_INDEX(GS)] = state.__gs;
 662   primitiveArray[REG_INDEX(ES)] = 0;
 663   primitiveArray[REG_INDEX(DS)] = 0;
 664   primitiveArray[REG_INDEX(FSBASE)] = 0;
 665   primitiveArray[REG_INDEX(GSBASE)] = 0;
 666   print_debug(&quot;set registers\n&quot;);
 667 
 668   (*env)-&gt;ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
 669 
 670 #else
 671 #error UNSUPPORTED_ARCH
 672 #endif /* amd64 */
 673 
 674   return registerArray;
 675 }
 676 
 677 /*
 678  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 679  * Method:    translateTID0
 680  * Signature: (I)I
 681  */
 682 JNIEXPORT jint JNICALL
 683 Java_sun_jvm_hotspot_debugger_macosx_MacOSXDebuggerLocal_translateTID0(
 684   JNIEnv *env, jobject this_obj, jint tid) 
 685 {
 686   print_debug(&quot;translateTID0 called on tid = 0x%x\n&quot;, (int)tid);
 687 
 688   kern_return_t result;
 689   thread_t foreign_tid, usable_tid;
 690   mach_msg_type_name_t type;
 691   
 692   foreign_tid = tid;
 693     
 694   task_t gTask = getTask(env, this_obj);
 695   result = mach_port_extract_right(gTask, foreign_tid, 
 696 				   MACH_MSG_TYPE_COPY_SEND, 
 697 				   &amp;usable_tid, &amp;type);
 698   if (result != KERN_SUCCESS)
 699     return -1;
 700     
 701   print_debug(&quot;translateTID0: 0x%x -&gt; 0x%x\n&quot;, foreign_tid, usable_tid);
 702     
 703   return (jint) usable_tid;
 704 }
 705 
 706 // attach to a process/thread specified by &quot;pid&quot;
 707 static bool ptrace_attach(pid_t pid) {
 708   errno = 0;
 709   ptrace(PT_ATTACHEXC, pid, 0, 0);
 710 
 711   if (errno != 0) {
 712     print_error(&quot;ptrace_attach: ptrace(PT_ATTACHEXC,...) failed: %s&quot;, strerror(errno));
 713     return false;
 714   }
 715   return true;
 716 }
 717 
 718 kern_return_t catch_mach_exception_raise(
 719   mach_port_t exception_port, mach_port_t thread_port, mach_port_t task_port,
 720   exception_type_t exception_type, mach_exception_data_t codes,
 721   mach_msg_type_number_t num_codes) {
 722 
 723   print_debug(&quot;catch_mach_exception_raise: Exception port = %d thread_port = %d &quot;
 724               &quot;task port %d exc type = %d num_codes %d\n&quot;,
 725               exception_port, thread_port, task_port, exception_type, num_codes);
 726 
 727   // This message should denote a Unix soft signal, with
 728   // 1. the exception type = EXC_SOFTWARE
 729   // 2. codes[0] (which is the code) = EXC_SOFT_SIGNAL
 730   // 3. codes[1] (which is the sub-code) = SIGSTOP
 731   if (!(exception_type == EXC_SOFTWARE &amp;&amp;
 732         codes[0] == EXC_SOFT_SIGNAL    &amp;&amp;
 733         codes[num_codes -1] == SIGSTOP)) {
 734     print_error(&quot;catch_mach_exception_raise: Message doesn&#39;t denote a Unix &quot;
 735                 &quot;soft signal. exception_type = %d, codes[0] = %d, &quot;
 736                 &quot;codes[num_codes -1] = %d, num_codes = %d\n&quot;,
 737                 exception_type, codes[0], codes[num_codes - 1], num_codes);
 738     return MACH_RCV_INVALID_TYPE;
 739   }
 740   return KERN_SUCCESS;
 741 }
 742 
 743 kern_return_t catch_mach_exception_raise_state(
 744   mach_port_t exception_port, exception_type_t exception, const mach_exception_data_t code,
 745   mach_msg_type_number_t code_cnt, int *flavor, const thread_state_t old_state,
 746   mach_msg_type_number_t old_state_cnt, thread_state_t new_state,
 747   mach_msg_type_number_t *new_state_cnt) {
 748   return MACH_RCV_INVALID_TYPE;
 749 }
 750 
 751 
 752 kern_return_t catch_mach_exception_raise_state_identity(
 753   mach_port_t exception_port, mach_port_t thread, mach_port_t task,
 754   exception_type_t exception, mach_exception_data_t code,
 755   mach_msg_type_number_t code_cnt, int *flavor,
 756   thread_state_t old_state, mach_msg_type_number_t old_state_cnt,
 757   thread_state_t new_state, mach_msg_type_number_t *new_state_cnt) {
 758   return MACH_RCV_INVALID_TYPE;
 759 }
 760 
 761 // wait to receive an exception message
 762 static bool wait_for_exception() {
 763   kern_return_t result;
 764 
 765   result = mach_msg(&amp;exc_msg.header,
 766                     MACH_RCV_MSG,
 767                     0,
 768                     sizeof(exc_msg),
 769                     tgt_exception_port,
 770                     MACH_MSG_TIMEOUT_NONE,
 771                     MACH_PORT_NULL);
 772 
 773   if (result != MACH_MSG_SUCCESS) {
 774     print_error(&quot;attach: wait_for_exception: mach_msg() failed: &#39;%s&#39; (%d)\n&quot;,
 775                 mach_error_string(result), result);
 776     return false;
 777   }
 778 
 779   if (mach_exc_server(&amp;exc_msg.header, &amp;rep_msg.header) == false ||
 780       rep_msg.ret_code != KERN_SUCCESS) {
 781     print_error(&quot;attach: wait_for_exception: mach_exc_server failure\n&quot;);
 782     if (rep_msg.ret_code != KERN_SUCCESS) {
 783       print_error(&quot;catch_mach_exception_raise() failed &#39;%s&#39; (%d)\n&quot;,
 784                   mach_error_string(rep_msg.ret_code), rep_msg.ret_code);
 785     }
 786     return false;
 787   }
 788 
 789   print_debug(&quot;reply msg from mach_exc_server: (msg-&gt;{bits = %#x, size = %u, &quot;
 790               &quot;remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x},)&quot;,
 791               rep_msg.header.msgh_bits, rep_msg.header.msgh_size,
 792               rep_msg.header.msgh_remote_port, rep_msg.header.msgh_local_port,
 793               rep_msg.header.msgh_reserved, rep_msg.header.msgh_id);
 794 
 795   return true;
 796 }
 797 
 798 /*
 799  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 800  * Method:    attach0
 801  * Signature: (I)V
 802  */
 803 JNIEXPORT void JNICALL
 804 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__I(
 805   JNIEnv *env, jobject this_obj, jint jpid)
 806 {
 807   print_debug(&quot;attach0 called for jpid=%d\n&quot;, (int)jpid);
 808 
 809 JNF_COCOA_ENTER(env);
 810 
 811   kern_return_t result;
 812   task_t gTask = 0;
 813 
 814   result = task_for_pid(mach_task_self(), jpid, &amp;gTask);
 815   if (result != KERN_SUCCESS) {
 816     print_error(&quot;attach: task_for_pid(%d) failed: &#39;%s&#39; (%d)\n&quot;, (int)jpid, mach_error_string(result), result);
 817     THROW_NEW_DEBUGGER_EXCEPTION(
 818       &quot;Can&#39;t attach to the process. Could be caused by an incorrect pid or lack of privileges.&quot;);
 819   }
 820   putTask(env, this_obj, gTask);
 821 
 822   // Allocate an exception port.
 823   result = mach_port_allocate(mach_task_self(),
 824                               MACH_PORT_RIGHT_RECEIVE,
 825                               &amp;tgt_exception_port);
 826   if (result != KERN_SUCCESS) {
 827     print_error(&quot;attach: mach_port_allocate() for tgt_exception_port failed: &#39;%s&#39; (%d)\n&quot;,
 828                 mach_error_string(result), result);
 829     THROW_NEW_DEBUGGER_EXCEPTION(
 830       &quot;Can&#39;t attach to the process. Couldn&#39;t allocate an exception port.&quot;);
 831   }
 832 
 833   // Enable the new exception port to send messages.
 834   result = mach_port_insert_right (mach_task_self(),
 835                                    tgt_exception_port,
 836                                    tgt_exception_port,
 837                                    MACH_MSG_TYPE_MAKE_SEND);
 838   if (result != KERN_SUCCESS) {
 839     print_error(&quot;attach: mach_port_insert_right() failed for port 0x%x: &#39;%s&#39; (%d)\n&quot;,
 840                 tgt_exception_port, mach_error_string(result), result);
 841     THROW_NEW_DEBUGGER_EXCEPTION(
 842       &quot;Can&#39;t attach to the process. Couldn&#39;t add send privileges to the exception port.&quot;);
 843   }
 844 
 845   // Save the existing original exception ports registered with the target
 846   // process (for later restoration while detaching from the process).
 847   result = task_get_exception_ports(gTask,
 848                                     EXC_MASK_ALL,
 849                                     exception_saved_state.saved_masks,
 850                                     &amp;exception_saved_state.saved_exception_types_count,
 851                                     exception_saved_state.saved_ports,
 852                                     exception_saved_state.saved_behaviors,
 853                                     exception_saved_state.saved_flavors);
 854 
 855   if (result != KERN_SUCCESS) {
 856     print_error(&quot;attach: task_get_exception_ports() failed: &#39;%s&#39; (%d)\n&quot;,
 857                 mach_error_string(result), result);
 858     THROW_NEW_DEBUGGER_EXCEPTION(
 859       &quot;Can&#39;t attach to the process. Could not get the target exception ports.&quot;);
 860   }
 861 
 862   // register the exception port to be used for all future exceptions with the
 863   // target process.
 864   result = task_set_exception_ports(gTask,
 865                                     EXC_MASK_ALL,
 866                                     tgt_exception_port,
 867                                     EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES,
 868                                     THREAD_STATE_NONE);
 869 
 870   if (result != KERN_SUCCESS) {
 871     print_error(&quot;attach: task_set_exception_ports() failed -- port 0x%x: &#39;%s&#39; (%d)\n&quot;,
 872                 tgt_exception_port, mach_error_string(result), result);
 873     mach_port_deallocate(mach_task_self(), gTask);
 874     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 875     THROW_NEW_DEBUGGER_EXCEPTION(
 876       &quot;Can&#39;t attach to the process. Could not register the exception port &quot;
 877       &quot;with the target process.&quot;);
 878   }
 879 
 880   // use ptrace to stop the process
 881   // on os x, ptrace only needs to be called on the process, not the individual threads
 882   if (ptrace_attach(jpid) != true) {
 883     print_error(&quot;attach: ptrace failure in attaching to %d\n&quot;, (int)jpid);
 884     mach_port_deallocate(mach_task_self(), gTask);
 885     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 886     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t ptrace attach to the process&quot;);
 887   }
 888 
 889   if (wait_for_exception() != true) {
 890     mach_port_deallocate(mach_task_self(), gTask);
 891     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 892     THROW_NEW_DEBUGGER_EXCEPTION(
 893       &quot;Can&#39;t attach to the process. Issues with reception of the exception message.&quot;);
 894   }
 895 
 896   // suspend all the threads in the task
 897   result = task_suspend(gTask);
 898   if (result != KERN_SUCCESS) {
 899     print_error(&quot;attach: task_suspend() failed: &#39;%s&#39; (%d)\n&quot;,
 900                 mach_error_string(result), result);
 901     mach_port_deallocate(mach_task_self(), gTask);
 902     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 903     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach. Unable to suspend all the threads in the task.&quot;);
 904   }
 905 
 906   id symbolicator = nil;
 907   id jrsSymbolicator = objc_lookUpClass(&quot;JRSSymbolicator&quot;);
 908   if (jrsSymbolicator != nil) {
 909     id (*dynamicCall)(id, SEL, pid_t) = (id (*)(id, SEL, pid_t))&amp;objc_msgSend;
 910     symbolicator = dynamicCall(jrsSymbolicator, @selector(symbolicatorForPid:), (pid_t)jpid);
 911   }
 912   if (symbolicator != nil) {
 913     CFRetain(symbolicator); // pin symbolicator while in java heap
 914   }
 915 
 916   putSymbolicator(env, this_obj, symbolicator);
 917   if (symbolicator == nil) {
 918     mach_port_deallocate(mach_task_self(), gTask);
 919     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 920     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach symbolicator to the process&quot;);
 921   }
 922 
 923 JNF_COCOA_EXIT(env);
 924 }
 925 
 926 /** For core file,
 927     called from Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2 */
 928 static void fillLoadObjects(JNIEnv* env, jobject this_obj, struct ps_prochandle* ph) {
 929   int n = 0, i = 0;
 930 
 931   // add load objects
 932   n = get_num_libs(ph);
 933   for (i = 0; i &lt; n; i++) {
 934      uintptr_t base;
 935      const char* name;
 936      jobject loadObject;
 937      jobject loadObjectList;
 938      jstring nameString;
 939 
 940      base = get_lib_base(ph, i);
 941      name = get_lib_name(ph, i);
 942      nameString = (*env)-&gt;NewStringUTF(env, name);
 943      CHECK_EXCEPTION;
 944      loadObject = (*env)-&gt;CallObjectMethod(env, this_obj, createLoadObject_ID,
 945                                             nameString, (jlong)0, (jlong)base);
 946      CHECK_EXCEPTION;
 947      loadObjectList = (*env)-&gt;GetObjectField(env, this_obj, loadObjectList_ID);
 948      CHECK_EXCEPTION;
 949      (*env)-&gt;CallBooleanMethod(env, loadObjectList, listAdd_ID, loadObject);
 950      CHECK_EXCEPTION;
 951   }
 952 }
 953 
 954 /*
 955  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 956  * Method:    attach0
 957  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
 958  */
 959 JNIEXPORT void JNICALL
 960 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2(
 961   JNIEnv *env, jobject this_obj, jstring execName, jstring coreName)
 962 {
 963   const char *execName_cstr;
 964   const char *coreName_cstr;
 965   jboolean isCopy;
 966   struct ps_prochandle* ph;
 967 
 968   execName_cstr = (*env)-&gt;GetStringUTFChars(env, execName, &amp;isCopy);
 969   CHECK_EXCEPTION;
 970   coreName_cstr = (*env)-&gt;GetStringUTFChars(env, coreName, &amp;isCopy);
 971   if ((*env)-&gt;ExceptionOccurred(env)) {
 972     (*env)-&gt;ReleaseStringUTFChars(env, execName, execName_cstr);
 973     return;
 974   }
 975 
 976   print_debug(&quot;attach: %s %s\n&quot;, execName_cstr, coreName_cstr);
 977 
 978   if ( (ph = Pgrab_core(execName_cstr, coreName_cstr)) == NULL) {
 979     (*env)-&gt;ReleaseStringUTFChars(env, execName, execName_cstr);
 980     (*env)-&gt;ReleaseStringUTFChars(env, coreName, coreName_cstr);
 981     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach to the core file&quot;);
 982   }
 983   (*env)-&gt;SetLongField(env, this_obj, p_ps_prochandle_ID, (jlong)(intptr_t)ph);
 984   (*env)-&gt;ReleaseStringUTFChars(env, execName, execName_cstr);
 985   (*env)-&gt;ReleaseStringUTFChars(env, coreName, coreName_cstr);
 986   fillLoadObjects(env, this_obj, ph);
 987 }
 988 
 989 static void detach_cleanup(task_t gTask, JNIEnv *env, jobject this_obj, bool throw_exception) {
 990   mach_port_deallocate(mach_task_self(), tgt_exception_port);
 991   mach_port_deallocate(mach_task_self(), gTask);
 992 
 993   id symbolicator = getSymbolicator(env, this_obj);
 994   if (symbolicator != nil) {
 995     CFRelease(symbolicator);
 996   }
 997   if (throw_exception) {
 998     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Cannot detach.&quot;);
 999   }
1000 }
1001 
1002 /*
1003  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
1004  * Method:    detach0
1005  * Signature: ()V
1006  */
1007 JNIEXPORT void JNICALL
1008 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_detach0(
1009   JNIEnv *env, jobject this_obj)
1010 {
1011   print_debug(&quot;detach0 called\n&quot;);
1012   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
1013   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
1014      Prelease(ph);
1015      return;
1016   }
1017 JNF_COCOA_ENTER(env);
1018 
1019   task_t gTask = getTask(env, this_obj);
1020   kern_return_t k_res = 0;
1021 
1022   // Restore the pre-saved original exception ports registered with the target process
1023   for (uint32_t i = 0; i &lt; exception_saved_state.saved_exception_types_count; ++i) {
1024     k_res = task_set_exception_ports(gTask,
1025                                      exception_saved_state.saved_masks[i],
1026                                      exception_saved_state.saved_ports[i],
1027                                      exception_saved_state.saved_behaviors[i],
1028                                      exception_saved_state.saved_flavors[i]);
1029     if (k_res != KERN_SUCCESS) {
1030       print_error(&quot;detach: task_set_exception_ports failed with %d while &quot;
1031                   &quot;restoring the target exception ports.\n&quot;, k_res);
1032       detach_cleanup(gTask, env, this_obj, true);
1033     }
1034   }
1035 
1036   // detach from the ptraced process causing it to resume execution
1037   int pid;
1038   k_res = pid_for_task(gTask, &amp;pid);
1039   if (k_res != KERN_SUCCESS) {
1040     print_error(&quot;detach: pid_for_task(%d) failed (%d)\n&quot;, pid, k_res);
1041     detach_cleanup(gTask, env, this_obj, true);
1042   }
1043   else {
1044     errno = 0;
1045     ptrace(PT_DETACH, pid, (caddr_t)1, 0);
1046     if (errno != 0) {
1047       print_error(&quot;detach: ptrace(PT_DETACH,...) failed: %s&quot;, strerror(errno));
1048       detach_cleanup(gTask, env, this_obj, true);
1049     }
1050   }
1051 
1052   // reply to the previous exception message
1053   k_res = mach_msg(&amp;rep_msg.header,
1054                    MACH_SEND_MSG| MACH_SEND_INTERRUPT,
1055                    rep_msg.header.msgh_size,
1056                    0,
1057                    MACH_PORT_NULL,
1058                    MACH_MSG_TIMEOUT_NONE,
1059                    MACH_PORT_NULL);
1060   if (k_res != MACH_MSG_SUCCESS) {
1061     print_error(&quot;detach: mach_msg() for replying to pending exceptions failed: &#39;%s&#39; (%d)\n&quot;,
1062                  mach_error_string(k_res), k_res);
1063     detach_cleanup(gTask, env, this_obj, true);
1064   }
1065 
1066   detach_cleanup(gTask, env, this_obj, false);
1067 
1068 JNF_COCOA_EXIT(env);
1069 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../.mx.jvmci/mx_jvmci.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 1558 #ifndef PRODUCT
 1559   void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const {
 1560     st-&gt;print(&quot;nop \t# %d bytes pad for loops and calls&quot;, _count);
 1561   }
 1562 #endif
 1563 
 1564   void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc*) const {
 1565     MacroAssembler _masm(&amp;cbuf);
 1566     for (int i = 0; i &lt; _count; i++) {
 1567       __ nop();
 1568     }
 1569   }
 1570 
 1571   uint MachNopNode::size(PhaseRegAlloc*) const {
 1572     return _count * NativeInstruction::instruction_size;
 1573   }
 1574 
 1575 //=============================================================================
 1576 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 1577 
<span class="line-modified"> 1578 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
 1579   return 0;  // absolute addressing, no offset
 1580 }
 1581 
 1582 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1583 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1584   ShouldNotReachHere();
 1585 }
 1586 
 1587 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1588   // Empty encoding
 1589 }
 1590 
 1591 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1592   return 0;
 1593 }
 1594 
 1595 #ifndef PRODUCT
 1596 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1597   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1598 }
 1599 #endif
 1600 
 1601 #ifndef PRODUCT
 1602 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1603   Compile* C = ra_-&gt;C;
 1604 
<span class="line-modified"> 1605   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1606 
<span class="line-modified"> 1607   if (C-&gt;need_stack_bang(framesize))</span>
 1608     st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
 1609 
 1610   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1611     st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
 1612     st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
 1613     if (PreserveFramePointer) st-&gt;print(&quot;\n\tadd  rfp, sp, #%d&quot;, framesize - 2 * wordSize);
 1614   } else {
 1615     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1616     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1617     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1618     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1619   }
 1620 }
 1621 #endif
 1622 
 1623 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1624   Compile* C = ra_-&gt;C;
 1625   MacroAssembler _masm(&amp;cbuf);
 1626 
 1627   // n.b. frame size includes space for return pc and rfp
<span class="line-modified"> 1628   const long framesize = C-&gt;frame_size_in_bytes();</span>
 1629   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1630 
 1631   // insert a nop at the start of the prolog so we can patch in a
 1632   // branch if we need to invalidate the method later
 1633   __ nop();
 1634 
 1635   if (C-&gt;clinit_barrier_on_entry()) {
 1636     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 1637 
 1638     Label L_skip_barrier;
 1639 
 1640     __ mov_metadata(rscratch2, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1641     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
 1642     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 1643     __ bind(L_skip_barrier);
 1644   }
 1645 
<span class="line-modified"> 1646   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="line-modified"> 1647   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
 1648     __ generate_stack_overflow_check(bangsize);
 1649 
 1650   __ build_frame(framesize);
 1651 
 1652   if (VerifyStackAtCalls) {
 1653     Unimplemented();
 1654   }
 1655 
<span class="line-modified"> 1656   C-&gt;set_frame_complete(cbuf.insts_size());</span>
 1657 
 1658   if (C-&gt;has_mach_constant_base_node()) {
 1659     // NOTE: We set the table base offset here because users might be
 1660     // emitted before MachConstantBaseNode.
<span class="line-modified"> 1661     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
 1662     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1663   }
 1664 }
 1665 
 1666 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1667 {
 1668   return MachNode::size(ra_); // too many variables; just compute it
 1669                               // the hard way
 1670 }
 1671 
 1672 int MachPrologNode::reloc() const
 1673 {
 1674   return 0;
 1675 }
 1676 
 1677 //=============================================================================
 1678 
 1679 #ifndef PRODUCT
 1680 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1681   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1682   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1683 
 1684   st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
 1685 
 1686   if (framesize == 0) {
 1687     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1688   } else if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1689     st-&gt;print(&quot;ldp  lr, rfp, [sp,#%d]\n\t&quot;, framesize - 2 * wordSize);
 1690     st-&gt;print(&quot;add  sp, sp, #%d\n\t&quot;, framesize);
 1691   } else {
 1692     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1693     st-&gt;print(&quot;add  sp, sp, rscratch1\n\t&quot;);
 1694     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1695   }
 1696 
 1697   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1698     st-&gt;print(&quot;# touch polling page\n\t&quot;);
 1699     st-&gt;print(&quot;mov  rscratch1, #0x%lx\n\t&quot;, p2i(os::get_polling_page()));
 1700     st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
 1701   }
 1702 }
 1703 #endif
 1704 
 1705 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1706   Compile* C = ra_-&gt;C;
 1707   MacroAssembler _masm(&amp;cbuf);
<span class="line-modified"> 1708   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1709 
 1710   __ remove_frame(framesize);
 1711 
 1712   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1713     __ reserved_stack_check();
 1714   }
 1715 
 1716   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1717     __ read_polling_page(rscratch1, os::get_polling_page(), relocInfo::poll_return_type);
 1718   }
 1719 }
 1720 
 1721 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1722   // Variable size. Determine dynamically.
 1723   return MachNode::size(ra_);
 1724 }
 1725 
 1726 int MachEpilogNode::reloc() const {
 1727   // Return number of relocatable values contained in this instruction.
 1728   return 1; // 1 for polling page.
</pre>
<hr />
<pre>
 2057 //=============================================================================
 2058 
 2059 const bool Matcher::match_rule_supported(int opcode) {
 2060   if (!has_match_rule(opcode))
 2061     return false;
 2062 
 2063   bool ret_value = true;
 2064   switch (opcode) {
 2065     case Op_CacheWB:
 2066     case Op_CacheWBPreSync:
 2067     case Op_CacheWBPostSync:
 2068       if (!VM_Version::supports_data_cache_line_flush()) {
 2069         ret_value = false;
 2070       }
 2071       break;
 2072   }
 2073 
 2074   return ret_value; // Per default match rules are supported.
 2075 }
 2076 


 2077 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {



 2078 
<span class="line-modified"> 2079   // TODO</span>
<span class="line-modified"> 2080   // identify extra cases that we might want to provide match rules for</span>
<span class="line-modified"> 2081   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen</span>
<span class="line-modified"> 2082   bool ret_value = match_rule_supported(opcode);</span>
<span class="line-modified"> 2083   // Add rules here.</span>




 2084 
<span class="line-modified"> 2085   return ret_value;  // Per default match rules are supported.</span>
 2086 }
 2087 
 2088 const bool Matcher::has_predicated_vectors(void) {
 2089   return false;
 2090 }
 2091 
 2092 const int Matcher::float_pressure(int default_pressure_threshold) {
 2093   return default_pressure_threshold;
 2094 }
 2095 
 2096 int Matcher::regnum_to_fpu_offset(int regnum)
 2097 {
 2098   Unimplemented();
 2099   return 0;
 2100 }
 2101 
 2102 // Is this branch offset short enough that a short branch can be used?
 2103 //
 2104 // NOTE: If the platform does not provide any short branch variants, then
 2105 //       this method should return false for offset 0.
</pre>
<hr />
<pre>
 2240 }
 2241 
 2242 // Is it better to copy float constants, or load them directly from
 2243 // memory?  Intel can load a float constant from a direct address,
 2244 // requiring no extra registers.  Most RISCs will have to materialize
 2245 // an address into a register first, so they would do better to copy
 2246 // the constant from stack.
 2247 const bool Matcher::rematerialize_float_constants = false;
 2248 
 2249 // If CPU can load and store mis-aligned doubles directly then no
 2250 // fixup is needed.  Else we split the double into 2 integer pieces
 2251 // and move it piece-by-piece.  Only happens when passing doubles into
 2252 // C code as the Java calling convention forces doubles to be aligned.
 2253 const bool Matcher::misaligned_doubles_ok = true;
 2254 
 2255 // No-op on amd64
 2256 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2257   Unimplemented();
 2258 }
 2259 
<span class="line-modified"> 2260 // Advertise here if the CPU requires explicit rounding operations to</span>
<span class="line-removed"> 2261 // implement the UseStrictFP mode.</span>
 2262 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2263 
 2264 // Are floats converted to double when stored to stack during
 2265 // deoptimization?
 2266 bool Matcher::float_in_double() { return false; }
 2267 
 2268 // Do ints take an entire long register or just half?
 2269 // The relevant question is how the int is callee-saved:
 2270 // the whole long is written but de-opt&#39;ing will have to extract
 2271 // the relevant 32 bits.
 2272 const bool Matcher::int_in_long = true;
 2273 
 2274 // Return whether or not this register is ever used as an argument.
 2275 // This function is used on startup to build the trampoline stubs in
 2276 // generateOptoStub.  Registers not mentioned will be killed by the VM
 2277 // call in the trampoline, and arguments in those registers not be
 2278 // available to the callee.
 2279 bool Matcher::can_be_java_arg(int reg)
 2280 {
 2281   return
</pre>
<hr />
<pre>
10539 
10540   ins_pipe(imac_reg_reg);
10541 %}
10542 
10543 instruct smnegL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, immL0 zero) %{
10544   match(Set dst (MulL (SubL zero (ConvI2L src1)) (ConvI2L src2)));
10545   match(Set dst (MulL (ConvI2L src1) (SubL zero (ConvI2L src2))));
10546 
10547   ins_cost(INSN_COST * 3);
10548   format %{ &quot;smnegl  $dst, $src1, $src2&quot; %}
10549 
10550   ins_encode %{
10551     __ smnegl(as_Register($dst$$reg),
10552               as_Register($src1$$reg),
10553               as_Register($src2$$reg));
10554   %}
10555 
10556   ins_pipe(imac_reg_reg);
10557 %}
10558 
















10559 // Integer Divide
10560 
10561 instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
10562   match(Set dst (DivI src1 src2));
10563 
10564   ins_cost(INSN_COST * 19);
10565   format %{ &quot;sdivw  $dst, $src1, $src2&quot; %}
10566 
10567   ins_encode(aarch64_enc_divw(dst, src1, src2));
10568   ins_pipe(idiv_reg_reg);
10569 %}
10570 
10571 instruct signExtract(iRegINoSp dst, iRegIorL2I src1, immI_31 div1, immI_31 div2) %{
10572   match(Set dst (URShiftI (RShiftI src1 div1) div2));
10573   ins_cost(INSN_COST);
10574   format %{ &quot;lsrw $dst, $src1, $div1&quot; %}
10575   ins_encode %{
10576     __ lsrw(as_Register($dst$$reg), as_Register($src1$$reg), 31);
10577   %}
10578   ins_pipe(ialu_reg_shift);
</pre>
<hr />
<pre>
14895 %}
14896 
14897 instruct cmpI_branch_sign(cmpOpLtGe cmp, iRegIorL2I op1, immI0 op2, label labl) %{
14898   match(If cmp (CmpI op1 op2));
14899   effect(USE labl);
14900 
14901   ins_cost(BRANCH_COST);
14902   format %{ &quot;cb$cmp   $op1, $labl # int&quot; %}
14903   ins_encode %{
14904     Label* L = $labl$$label;
14905     Assembler::Condition cond =
14906       ((Assembler::Condition)$cmp$$cmpcode == Assembler::LT) ? Assembler::NE : Assembler::EQ;
14907     __ tbr(cond, $op1$$Register, 31, *L);
14908   %}
14909   ins_pipe(pipe_cmp_branch);
14910   ins_short_branch(1);
14911 %}
14912 
14913 instruct cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
14914   match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">14915   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
14916   effect(USE labl);
14917 
14918   ins_cost(BRANCH_COST);
14919   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
14920   ins_encode %{
14921     Label* L = $labl$$label;
14922     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">14923     int bit = exact_log2($op2$$constant);</span>
14924     __ tbr(cond, $op1$$Register, bit, *L);
14925   %}
14926   ins_pipe(pipe_cmp_branch);
14927   ins_short_branch(1);
14928 %}
14929 
14930 instruct cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
14931   match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">14932   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
14933   effect(USE labl);
14934 
14935   ins_cost(BRANCH_COST);
14936   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
14937   ins_encode %{
14938     Label* L = $labl$$label;
14939     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">14940     int bit = exact_log2($op2$$constant);</span>
14941     __ tbr(cond, $op1$$Register, bit, *L);
14942   %}
14943   ins_pipe(pipe_cmp_branch);
14944   ins_short_branch(1);
14945 %}
14946 
14947 // And far variants
14948 instruct far_cmpL_branch_sign(cmpOpLtGe cmp, iRegL op1, immL0 op2, label labl) %{
14949   match(If cmp (CmpL op1 op2));
14950   effect(USE labl);
14951 
14952   ins_cost(BRANCH_COST);
14953   format %{ &quot;cb$cmp   $op1, $labl # long&quot; %}
14954   ins_encode %{
14955     Label* L = $labl$$label;
14956     Assembler::Condition cond =
14957       ((Assembler::Condition)$cmp$$cmpcode == Assembler::LT) ? Assembler::NE : Assembler::EQ;
14958     __ tbr(cond, $op1$$Register, 63, *L, /*far*/true);
14959   %}
14960   ins_pipe(pipe_cmp_branch);
14961 %}
14962 
14963 instruct far_cmpI_branch_sign(cmpOpLtGe cmp, iRegIorL2I op1, immI0 op2, label labl) %{
14964   match(If cmp (CmpI op1 op2));
14965   effect(USE labl);
14966 
14967   ins_cost(BRANCH_COST);
14968   format %{ &quot;cb$cmp   $op1, $labl # int&quot; %}
14969   ins_encode %{
14970     Label* L = $labl$$label;
14971     Assembler::Condition cond =
14972       ((Assembler::Condition)$cmp$$cmpcode == Assembler::LT) ? Assembler::NE : Assembler::EQ;
14973     __ tbr(cond, $op1$$Register, 31, *L, /*far*/true);
14974   %}
14975   ins_pipe(pipe_cmp_branch);
14976 %}
14977 
14978 instruct far_cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
14979   match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">14980   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
14981   effect(USE labl);
14982 
14983   ins_cost(BRANCH_COST);
14984   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
14985   ins_encode %{
14986     Label* L = $labl$$label;
14987     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">14988     int bit = exact_log2($op2$$constant);</span>
14989     __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
14990   %}
14991   ins_pipe(pipe_cmp_branch);
14992 %}
14993 
14994 instruct far_cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
14995   match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">14996   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
14997   effect(USE labl);
14998 
14999   ins_cost(BRANCH_COST);
15000   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
15001   ins_encode %{
15002     Label* L = $labl$$label;
15003     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">15004     int bit = exact_log2($op2$$constant);</span>
15005     __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
15006   %}
15007   ins_pipe(pipe_cmp_branch);
15008 %}
15009 
15010 // Test bits
15011 
15012 instruct cmpL_and(cmpOp cmp, iRegL op1, immL op2, immL0 op3, rFlagsReg cr) %{
15013   match(Set cr (CmpL (AndL op1 op2) op3));
15014   predicate(Assembler::operand_valid_for_logical_immediate
15015             (/*is_32*/false, n-&gt;in(1)-&gt;in(2)-&gt;get_long()));
15016 
15017   ins_cost(INSN_COST);
15018   format %{ &quot;tst $op1, $op2 # long&quot; %}
15019   ins_encode %{
15020     __ tst($op1$$Register, $op2$$constant);
15021   %}
15022   ins_pipe(ialu_reg_reg);
15023 %}
15024 
</pre>
<hr />
<pre>
16919             as_FloatRegister($src2$$reg));
16920   %}
16921   ins_pipe(vmuldiv_fp128);
16922 %}
16923 
16924 // dst - src1 * src2
16925 instruct vmls2D(vecX dst, vecX src1, vecX src2) %{
16926   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
16927   match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));
16928   match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));
16929   format %{ &quot;fmls  $dst,$src1,$src2\t# vector (2D)&quot; %}
16930   ins_cost(INSN_COST);
16931   ins_encode %{
16932     __ fmls(as_FloatRegister($dst$$reg), __ T2D,
16933             as_FloatRegister($src1$$reg),
16934             as_FloatRegister($src2$$reg));
16935   %}
16936   ins_pipe(vmuldiv_fp128);
16937 %}
16938 
























16939 // --------------------------------- DIV --------------------------------------
16940 
16941 instruct vdiv2F(vecD dst, vecD src1, vecD src2)
16942 %{
16943   predicate(n-&gt;as_Vector()-&gt;length() == 2);
16944   match(Set dst (DivVF src1 src2));
16945   ins_cost(INSN_COST);
16946   format %{ &quot;fdiv  $dst,$src1,$src2\t# vector (2S)&quot; %}
16947   ins_encode %{
16948     __ fdiv(as_FloatRegister($dst$$reg), __ T2S,
16949             as_FloatRegister($src1$$reg),
16950             as_FloatRegister($src2$$reg));
16951   %}
16952   ins_pipe(vmuldiv_fp64);
16953 %}
16954 
16955 instruct vdiv4F(vecX dst, vecX src1, vecX src2)
16956 %{
16957   predicate(n-&gt;as_Vector()-&gt;length() == 4);
16958   match(Set dst (DivVF src1 src2));
</pre>
<hr />
<pre>
17296 instruct vsrl16B(vecX dst, vecX src, vecX shift, vecX tmp) %{
17297   predicate(n-&gt;as_Vector()-&gt;length() == 16);
17298   match(Set dst (URShiftVB src shift));
17299   ins_cost(INSN_COST);
17300   effect(TEMP tmp);
17301   format %{ &quot;negr  $tmp,$shift\t&quot;
17302             &quot;ushl  $dst,$src,$tmp\t# vector (16B)&quot; %}
17303   ins_encode %{
17304     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17305             as_FloatRegister($shift$$reg));
17306     __ ushl(as_FloatRegister($dst$$reg), __ T16B,
17307             as_FloatRegister($src$$reg),
17308             as_FloatRegister($tmp$$reg));
17309   %}
17310   ins_pipe(vshift128);
17311 %}
17312 
17313 instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{
17314   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17315             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17316   match(Set dst (LShiftVB src shift));</span>
17317   ins_cost(INSN_COST);
17318   format %{ &quot;shl    $dst, $src, $shift\t# vector (8B)&quot; %}
17319   ins_encode %{
17320     int sh = (int)$shift$$constant;
17321     if (sh &gt;= 8) {
17322       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17323              as_FloatRegister($src$$reg),
17324              as_FloatRegister($src$$reg));
17325     } else {
17326       __ shl(as_FloatRegister($dst$$reg), __ T8B,
17327              as_FloatRegister($src$$reg), sh);
17328     }
17329   %}
17330   ins_pipe(vshift64_imm);
17331 %}
17332 
17333 instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{
17334   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17335   match(Set dst (LShiftVB src shift));</span>
17336   ins_cost(INSN_COST);
17337   format %{ &quot;shl    $dst, $src, $shift\t# vector (16B)&quot; %}
17338   ins_encode %{
17339     int sh = (int)$shift$$constant;
17340     if (sh &gt;= 8) {
17341       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17342              as_FloatRegister($src$$reg),
17343              as_FloatRegister($src$$reg));
17344     } else {
17345       __ shl(as_FloatRegister($dst$$reg), __ T16B,
17346              as_FloatRegister($src$$reg), sh);
17347     }
17348   %}
17349   ins_pipe(vshift128_imm);
17350 %}
17351 
17352 instruct vsra8B_imm(vecD dst, vecD src, immI shift) %{
17353   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17354             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17355   match(Set dst (RShiftVB src shift));</span>
17356   ins_cost(INSN_COST);
17357   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8B)&quot; %}
17358   ins_encode %{
17359     int sh = (int)$shift$$constant;
17360     if (sh &gt;= 8) sh = 7;
17361     __ sshr(as_FloatRegister($dst$$reg), __ T8B,
17362            as_FloatRegister($src$$reg), sh);
17363   %}
17364   ins_pipe(vshift64_imm);
17365 %}
17366 
17367 instruct vsra16B_imm(vecX dst, vecX src, immI shift) %{
17368   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17369   match(Set dst (RShiftVB src shift));</span>
17370   ins_cost(INSN_COST);
17371   format %{ &quot;sshr    $dst, $src, $shift\t# vector (16B)&quot; %}
17372   ins_encode %{
17373     int sh = (int)$shift$$constant;
17374     if (sh &gt;= 8) sh = 7;
17375     __ sshr(as_FloatRegister($dst$$reg), __ T16B,
17376            as_FloatRegister($src$$reg), sh);
17377   %}
17378   ins_pipe(vshift128_imm);
17379 %}
17380 
17381 instruct vsrl8B_imm(vecD dst, vecD src, immI shift) %{
17382   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17383             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17384   match(Set dst (URShiftVB src shift));</span>
17385   ins_cost(INSN_COST);
17386   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8B)&quot; %}
17387   ins_encode %{
17388     int sh = (int)$shift$$constant;
17389     if (sh &gt;= 8) {
17390       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17391              as_FloatRegister($src$$reg),
17392              as_FloatRegister($src$$reg));
17393     } else {
17394       __ ushr(as_FloatRegister($dst$$reg), __ T8B,
17395              as_FloatRegister($src$$reg), sh);
17396     }
17397   %}
17398   ins_pipe(vshift64_imm);
17399 %}
17400 
17401 instruct vsrl16B_imm(vecX dst, vecX src, immI shift) %{
17402   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17403   match(Set dst (URShiftVB src shift));</span>
17404   ins_cost(INSN_COST);
17405   format %{ &quot;ushr    $dst, $src, $shift\t# vector (16B)&quot; %}
17406   ins_encode %{
17407     int sh = (int)$shift$$constant;
17408     if (sh &gt;= 8) {
17409       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17410              as_FloatRegister($src$$reg),
17411              as_FloatRegister($src$$reg));
17412     } else {
17413       __ ushr(as_FloatRegister($dst$$reg), __ T16B,
17414              as_FloatRegister($src$$reg), sh);
17415     }
17416   %}
17417   ins_pipe(vshift128_imm);
17418 %}
17419 
17420 instruct vsll4S(vecD dst, vecD src, vecD shift) %{
17421   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17422             n-&gt;as_Vector()-&gt;length() == 4);
17423   match(Set dst (LShiftVS src shift));
</pre>
<hr />
<pre>
17500 instruct vsrl8S(vecX dst, vecX src, vecX shift, vecX tmp) %{
17501   predicate(n-&gt;as_Vector()-&gt;length() == 8);
17502   match(Set dst (URShiftVS src shift));
17503   ins_cost(INSN_COST);
17504   effect(TEMP tmp);
17505   format %{ &quot;negr  $tmp,$shift\t&quot;
17506             &quot;ushl  $dst,$src,$tmp\t# vector (8H)&quot; %}
17507   ins_encode %{
17508     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17509             as_FloatRegister($shift$$reg));
17510     __ ushl(as_FloatRegister($dst$$reg), __ T8H,
17511             as_FloatRegister($src$$reg),
17512             as_FloatRegister($tmp$$reg));
17513   %}
17514   ins_pipe(vshift128);
17515 %}
17516 
17517 instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{
17518   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17519             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17520   match(Set dst (LShiftVS src shift));</span>
17521   ins_cost(INSN_COST);
17522   format %{ &quot;shl    $dst, $src, $shift\t# vector (4H)&quot; %}
17523   ins_encode %{
17524     int sh = (int)$shift$$constant;
17525     if (sh &gt;= 16) {
17526       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17527              as_FloatRegister($src$$reg),
17528              as_FloatRegister($src$$reg));
17529     } else {
17530       __ shl(as_FloatRegister($dst$$reg), __ T4H,
17531              as_FloatRegister($src$$reg), sh);
17532     }
17533   %}
17534   ins_pipe(vshift64_imm);
17535 %}
17536 
17537 instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{
17538   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17539   match(Set dst (LShiftVS src shift));</span>
17540   ins_cost(INSN_COST);
17541   format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
17542   ins_encode %{
17543     int sh = (int)$shift$$constant;
17544     if (sh &gt;= 16) {
17545       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17546              as_FloatRegister($src$$reg),
17547              as_FloatRegister($src$$reg));
17548     } else {
17549       __ shl(as_FloatRegister($dst$$reg), __ T8H,
17550              as_FloatRegister($src$$reg), sh);
17551     }
17552   %}
17553   ins_pipe(vshift128_imm);
17554 %}
17555 
17556 instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
17557   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17558             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17559   match(Set dst (RShiftVS src shift));</span>
17560   ins_cost(INSN_COST);
17561   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
17562   ins_encode %{
17563     int sh = (int)$shift$$constant;
17564     if (sh &gt;= 16) sh = 15;
17565     __ sshr(as_FloatRegister($dst$$reg), __ T4H,
17566            as_FloatRegister($src$$reg), sh);
17567   %}
17568   ins_pipe(vshift64_imm);
17569 %}
17570 
17571 instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
17572   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17573   match(Set dst (RShiftVS src shift));</span>
17574   ins_cost(INSN_COST);
17575   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
17576   ins_encode %{
17577     int sh = (int)$shift$$constant;
17578     if (sh &gt;= 16) sh = 15;
17579     __ sshr(as_FloatRegister($dst$$reg), __ T8H,
17580            as_FloatRegister($src$$reg), sh);
17581   %}
17582   ins_pipe(vshift128_imm);
17583 %}
17584 
17585 instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
17586   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17587             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17588   match(Set dst (URShiftVS src shift));</span>
17589   ins_cost(INSN_COST);
17590   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
17591   ins_encode %{
17592     int sh = (int)$shift$$constant;
17593     if (sh &gt;= 16) {
17594       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17595              as_FloatRegister($src$$reg),
17596              as_FloatRegister($src$$reg));
17597     } else {
17598       __ ushr(as_FloatRegister($dst$$reg), __ T4H,
17599              as_FloatRegister($src$$reg), sh);
17600     }
17601   %}
17602   ins_pipe(vshift64_imm);
17603 %}
17604 
17605 instruct vsrl8S_imm(vecX dst, vecX src, immI shift) %{
17606   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17607   match(Set dst (URShiftVS src shift));</span>
17608   ins_cost(INSN_COST);
17609   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8H)&quot; %}
17610   ins_encode %{
17611     int sh = (int)$shift$$constant;
17612     if (sh &gt;= 16) {
17613       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17614              as_FloatRegister($src$$reg),
17615              as_FloatRegister($src$$reg));
17616     } else {
17617       __ ushr(as_FloatRegister($dst$$reg), __ T8H,
17618              as_FloatRegister($src$$reg), sh);
17619     }
17620   %}
17621   ins_pipe(vshift128_imm);
17622 %}
17623 
17624 instruct vsll2I(vecD dst, vecD src, vecD shift) %{
17625   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17626   match(Set dst (LShiftVI src shift));
17627   ins_cost(INSN_COST);
</pre>
<hr />
<pre>
17700 
17701 instruct vsrl4I(vecX dst, vecX src, vecX shift, vecX tmp) %{
17702   predicate(n-&gt;as_Vector()-&gt;length() == 4);
17703   match(Set dst (URShiftVI src shift));
17704   ins_cost(INSN_COST);
17705   effect(TEMP tmp);
17706   format %{ &quot;negr  $tmp,$shift\t&quot;
17707             &quot;ushl  $dst,$src,$tmp\t# vector (4S)&quot; %}
17708   ins_encode %{
17709     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17710             as_FloatRegister($shift$$reg));
17711     __ ushl(as_FloatRegister($dst$$reg), __ T4S,
17712             as_FloatRegister($src$$reg),
17713             as_FloatRegister($tmp$$reg));
17714   %}
17715   ins_pipe(vshift128);
17716 %}
17717 
17718 instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{
17719   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17720   match(Set dst (LShiftVI src shift));</span>
17721   ins_cost(INSN_COST);
17722   format %{ &quot;shl    $dst, $src, $shift\t# vector (2S)&quot; %}
17723   ins_encode %{
17724     __ shl(as_FloatRegister($dst$$reg), __ T2S,
17725            as_FloatRegister($src$$reg),
17726            (int)$shift$$constant);
17727   %}
17728   ins_pipe(vshift64_imm);
17729 %}
17730 
17731 instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{
17732   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17733   match(Set dst (LShiftVI src shift));</span>
17734   ins_cost(INSN_COST);
17735   format %{ &quot;shl    $dst, $src, $shift\t# vector (4S)&quot; %}
17736   ins_encode %{
17737     __ shl(as_FloatRegister($dst$$reg), __ T4S,
17738            as_FloatRegister($src$$reg),
17739            (int)$shift$$constant);
17740   %}
17741   ins_pipe(vshift128_imm);
17742 %}
17743 
17744 instruct vsra2I_imm(vecD dst, vecD src, immI shift) %{
17745   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17746   match(Set dst (RShiftVI src shift));</span>
17747   ins_cost(INSN_COST);
17748   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2S)&quot; %}
17749   ins_encode %{
17750     __ sshr(as_FloatRegister($dst$$reg), __ T2S,
17751             as_FloatRegister($src$$reg),
17752             (int)$shift$$constant);
17753   %}
17754   ins_pipe(vshift64_imm);
17755 %}
17756 
17757 instruct vsra4I_imm(vecX dst, vecX src, immI shift) %{
17758   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17759   match(Set dst (RShiftVI src shift));</span>
17760   ins_cost(INSN_COST);
17761   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4S)&quot; %}
17762   ins_encode %{
17763     __ sshr(as_FloatRegister($dst$$reg), __ T4S,
17764             as_FloatRegister($src$$reg),
17765             (int)$shift$$constant);
17766   %}
17767   ins_pipe(vshift128_imm);
17768 %}
17769 
17770 instruct vsrl2I_imm(vecD dst, vecD src, immI shift) %{
17771   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17772   match(Set dst (URShiftVI src shift));</span>
17773   ins_cost(INSN_COST);
17774   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2S)&quot; %}
17775   ins_encode %{
17776     __ ushr(as_FloatRegister($dst$$reg), __ T2S,
17777             as_FloatRegister($src$$reg),
17778             (int)$shift$$constant);
17779   %}
17780   ins_pipe(vshift64_imm);
17781 %}
17782 
17783 instruct vsrl4I_imm(vecX dst, vecX src, immI shift) %{
17784   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17785   match(Set dst (URShiftVI src shift));</span>
17786   ins_cost(INSN_COST);
17787   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4S)&quot; %}
17788   ins_encode %{
17789     __ ushr(as_FloatRegister($dst$$reg), __ T4S,
17790             as_FloatRegister($src$$reg),
17791             (int)$shift$$constant);
17792   %}
17793   ins_pipe(vshift128_imm);
17794 %}
17795 
17796 instruct vsll2L(vecX dst, vecX src, vecX shift) %{
17797   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17798   match(Set dst (LShiftVL src shift));
17799   ins_cost(INSN_COST);
17800   format %{ &quot;sshl  $dst,$src,$shift\t# vector (2D)&quot; %}
17801   ins_encode %{
17802     __ sshl(as_FloatRegister($dst$$reg), __ T2D,
17803             as_FloatRegister($src$$reg),
17804             as_FloatRegister($shift$$reg));
17805   %}
</pre>
<hr />
<pre>
17825 
17826 instruct vsrl2L(vecX dst, vecX src, vecX shift, vecX tmp) %{
17827   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17828   match(Set dst (URShiftVL src shift));
17829   ins_cost(INSN_COST);
17830   effect(TEMP tmp);
17831   format %{ &quot;negr  $tmp,$shift\t&quot;
17832             &quot;ushl  $dst,$src,$tmp\t# vector (2D)&quot; %}
17833   ins_encode %{
17834     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17835             as_FloatRegister($shift$$reg));
17836     __ ushl(as_FloatRegister($dst$$reg), __ T2D,
17837             as_FloatRegister($src$$reg),
17838             as_FloatRegister($tmp$$reg));
17839   %}
17840   ins_pipe(vshift128);
17841 %}
17842 
17843 instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{
17844   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17845   match(Set dst (LShiftVL src shift));</span>
17846   ins_cost(INSN_COST);
17847   format %{ &quot;shl    $dst, $src, $shift\t# vector (2D)&quot; %}
17848   ins_encode %{
17849     __ shl(as_FloatRegister($dst$$reg), __ T2D,
17850            as_FloatRegister($src$$reg),
17851            (int)$shift$$constant);
17852   %}
17853   ins_pipe(vshift128_imm);
17854 %}
17855 
17856 instruct vsra2L_imm(vecX dst, vecX src, immI shift) %{
17857   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17858   match(Set dst (RShiftVL src shift));</span>
17859   ins_cost(INSN_COST);
17860   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2D)&quot; %}
17861   ins_encode %{
17862     __ sshr(as_FloatRegister($dst$$reg), __ T2D,
17863             as_FloatRegister($src$$reg),
17864             (int)$shift$$constant);
17865   %}
17866   ins_pipe(vshift128_imm);
17867 %}
17868 
17869 instruct vsrl2L_imm(vecX dst, vecX src, immI shift) %{
17870   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17871   match(Set dst (URShiftVL src shift));</span>
17872   ins_cost(INSN_COST);
17873   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2D)&quot; %}
17874   ins_encode %{
17875     __ ushr(as_FloatRegister($dst$$reg), __ T2D,
17876             as_FloatRegister($src$$reg),
17877             (int)$shift$$constant);
17878   %}
17879   ins_pipe(vshift128_imm);
17880 %}
17881 
17882 instruct vmax2F(vecD dst, vecD src1, vecD src2)
17883 %{
17884   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
17885   match(Set dst (MaxV src1 src2));
17886   ins_cost(INSN_COST);
17887   format %{ &quot;fmax  $dst,$src1,$src2\t# vector (2F)&quot; %}
17888   ins_encode %{
17889     __ fmax(as_FloatRegister($dst$$reg), __ T2S,
17890             as_FloatRegister($src1$$reg),
17891             as_FloatRegister($src2$$reg));
</pre>
</td>
<td>
<hr />
<pre>
 1558 #ifndef PRODUCT
 1559   void MachNopNode::format(PhaseRegAlloc*, outputStream* st) const {
 1560     st-&gt;print(&quot;nop \t# %d bytes pad for loops and calls&quot;, _count);
 1561   }
 1562 #endif
 1563 
 1564   void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc*) const {
 1565     MacroAssembler _masm(&amp;cbuf);
 1566     for (int i = 0; i &lt; _count; i++) {
 1567       __ nop();
 1568     }
 1569   }
 1570 
 1571   uint MachNopNode::size(PhaseRegAlloc*) const {
 1572     return _count * NativeInstruction::instruction_size;
 1573   }
 1574 
 1575 //=============================================================================
 1576 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 1577 
<span class="line-modified"> 1578 int ConstantTable::calculate_table_base_offset() const {</span>
 1579   return 0;  // absolute addressing, no offset
 1580 }
 1581 
 1582 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1583 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1584   ShouldNotReachHere();
 1585 }
 1586 
 1587 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1588   // Empty encoding
 1589 }
 1590 
 1591 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1592   return 0;
 1593 }
 1594 
 1595 #ifndef PRODUCT
 1596 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1597   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1598 }
 1599 #endif
 1600 
 1601 #ifndef PRODUCT
 1602 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1603   Compile* C = ra_-&gt;C;
 1604 
<span class="line-modified"> 1605   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1606 
<span class="line-modified"> 1607   if (C-&gt;output()-&gt;need_stack_bang(framesize))</span>
 1608     st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
 1609 
 1610   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1611     st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
 1612     st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
 1613     if (PreserveFramePointer) st-&gt;print(&quot;\n\tadd  rfp, sp, #%d&quot;, framesize - 2 * wordSize);
 1614   } else {
 1615     st-&gt;print(&quot;stp  lr, rfp, [sp, #%d]!\n\t&quot;, -(2 * wordSize));
 1616     if (PreserveFramePointer) st-&gt;print(&quot;mov  rfp, sp\n\t&quot;);
 1617     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1618     st-&gt;print(&quot;sub  sp, sp, rscratch1&quot;);
 1619   }
 1620 }
 1621 #endif
 1622 
 1623 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1624   Compile* C = ra_-&gt;C;
 1625   MacroAssembler _masm(&amp;cbuf);
 1626 
 1627   // n.b. frame size includes space for return pc and rfp
<span class="line-modified"> 1628   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
 1629   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1630 
 1631   // insert a nop at the start of the prolog so we can patch in a
 1632   // branch if we need to invalidate the method later
 1633   __ nop();
 1634 
 1635   if (C-&gt;clinit_barrier_on_entry()) {
 1636     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 1637 
 1638     Label L_skip_barrier;
 1639 
 1640     __ mov_metadata(rscratch2, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1641     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
 1642     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 1643     __ bind(L_skip_barrier);
 1644   }
 1645 
<span class="line-modified"> 1646   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-modified"> 1647   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
 1648     __ generate_stack_overflow_check(bangsize);
 1649 
 1650   __ build_frame(framesize);
 1651 
 1652   if (VerifyStackAtCalls) {
 1653     Unimplemented();
 1654   }
 1655 
<span class="line-modified"> 1656   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
 1657 
 1658   if (C-&gt;has_mach_constant_base_node()) {
 1659     // NOTE: We set the table base offset here because users might be
 1660     // emitted before MachConstantBaseNode.
<span class="line-modified"> 1661     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
 1662     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1663   }
 1664 }
 1665 
 1666 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 1667 {
 1668   return MachNode::size(ra_); // too many variables; just compute it
 1669                               // the hard way
 1670 }
 1671 
 1672 int MachPrologNode::reloc() const
 1673 {
 1674   return 0;
 1675 }
 1676 
 1677 //=============================================================================
 1678 
 1679 #ifndef PRODUCT
 1680 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1681   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1682   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1683 
 1684   st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
 1685 
 1686   if (framesize == 0) {
 1687     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1688   } else if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
 1689     st-&gt;print(&quot;ldp  lr, rfp, [sp,#%d]\n\t&quot;, framesize - 2 * wordSize);
 1690     st-&gt;print(&quot;add  sp, sp, #%d\n\t&quot;, framesize);
 1691   } else {
 1692     st-&gt;print(&quot;mov  rscratch1, #%d\n\t&quot;, framesize - 2 * wordSize);
 1693     st-&gt;print(&quot;add  sp, sp, rscratch1\n\t&quot;);
 1694     st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
 1695   }
 1696 
 1697   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1698     st-&gt;print(&quot;# touch polling page\n\t&quot;);
 1699     st-&gt;print(&quot;mov  rscratch1, #0x%lx\n\t&quot;, p2i(os::get_polling_page()));
 1700     st-&gt;print(&quot;ldr zr, [rscratch1]&quot;);
 1701   }
 1702 }
 1703 #endif
 1704 
 1705 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1706   Compile* C = ra_-&gt;C;
 1707   MacroAssembler _masm(&amp;cbuf);
<span class="line-modified"> 1708   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1709 
 1710   __ remove_frame(framesize);
 1711 
 1712   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1713     __ reserved_stack_check();
 1714   }
 1715 
 1716   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1717     __ read_polling_page(rscratch1, os::get_polling_page(), relocInfo::poll_return_type);
 1718   }
 1719 }
 1720 
 1721 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1722   // Variable size. Determine dynamically.
 1723   return MachNode::size(ra_);
 1724 }
 1725 
 1726 int MachEpilogNode::reloc() const {
 1727   // Return number of relocatable values contained in this instruction.
 1728   return 1; // 1 for polling page.
</pre>
<hr />
<pre>
 2057 //=============================================================================
 2058 
 2059 const bool Matcher::match_rule_supported(int opcode) {
 2060   if (!has_match_rule(opcode))
 2061     return false;
 2062 
 2063   bool ret_value = true;
 2064   switch (opcode) {
 2065     case Op_CacheWB:
 2066     case Op_CacheWBPreSync:
 2067     case Op_CacheWBPostSync:
 2068       if (!VM_Version::supports_data_cache_line_flush()) {
 2069         ret_value = false;
 2070       }
 2071       break;
 2072   }
 2073 
 2074   return ret_value; // Per default match rules are supported.
 2075 }
 2076 
<span class="line-added"> 2077 // Identify extra cases that we might want to provide match rules for vector nodes and</span>
<span class="line-added"> 2078 // other intrinsics guarded with vector length (vlen) and element type (bt).</span>
 2079 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
<span class="line-added"> 2080   if (!match_rule_supported(opcode)) {</span>
<span class="line-added"> 2081     return false;</span>
<span class="line-added"> 2082   }</span>
 2083 
<span class="line-modified"> 2084   // Special cases which require vector length</span>
<span class="line-modified"> 2085   switch (opcode) {</span>
<span class="line-modified"> 2086     case Op_MulAddVS2VI: {</span>
<span class="line-modified"> 2087       if (vlen != 4) {</span>
<span class="line-modified"> 2088         return false;</span>
<span class="line-added"> 2089       }</span>
<span class="line-added"> 2090       break;</span>
<span class="line-added"> 2091     }</span>
<span class="line-added"> 2092   }</span>
 2093 
<span class="line-modified"> 2094   return true; // Per default match rules are supported.</span>
 2095 }
 2096 
 2097 const bool Matcher::has_predicated_vectors(void) {
 2098   return false;
 2099 }
 2100 
 2101 const int Matcher::float_pressure(int default_pressure_threshold) {
 2102   return default_pressure_threshold;
 2103 }
 2104 
 2105 int Matcher::regnum_to_fpu_offset(int regnum)
 2106 {
 2107   Unimplemented();
 2108   return 0;
 2109 }
 2110 
 2111 // Is this branch offset short enough that a short branch can be used?
 2112 //
 2113 // NOTE: If the platform does not provide any short branch variants, then
 2114 //       this method should return false for offset 0.
</pre>
<hr />
<pre>
 2249 }
 2250 
 2251 // Is it better to copy float constants, or load them directly from
 2252 // memory?  Intel can load a float constant from a direct address,
 2253 // requiring no extra registers.  Most RISCs will have to materialize
 2254 // an address into a register first, so they would do better to copy
 2255 // the constant from stack.
 2256 const bool Matcher::rematerialize_float_constants = false;
 2257 
 2258 // If CPU can load and store mis-aligned doubles directly then no
 2259 // fixup is needed.  Else we split the double into 2 integer pieces
 2260 // and move it piece-by-piece.  Only happens when passing doubles into
 2261 // C code as the Java calling convention forces doubles to be aligned.
 2262 const bool Matcher::misaligned_doubles_ok = true;
 2263 
 2264 // No-op on amd64
 2265 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2266   Unimplemented();
 2267 }
 2268 
<span class="line-modified"> 2269 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>

 2270 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2271 
 2272 // Are floats converted to double when stored to stack during
 2273 // deoptimization?
 2274 bool Matcher::float_in_double() { return false; }
 2275 
 2276 // Do ints take an entire long register or just half?
 2277 // The relevant question is how the int is callee-saved:
 2278 // the whole long is written but de-opt&#39;ing will have to extract
 2279 // the relevant 32 bits.
 2280 const bool Matcher::int_in_long = true;
 2281 
 2282 // Return whether or not this register is ever used as an argument.
 2283 // This function is used on startup to build the trampoline stubs in
 2284 // generateOptoStub.  Registers not mentioned will be killed by the VM
 2285 // call in the trampoline, and arguments in those registers not be
 2286 // available to the callee.
 2287 bool Matcher::can_be_java_arg(int reg)
 2288 {
 2289   return
</pre>
<hr />
<pre>
10547 
10548   ins_pipe(imac_reg_reg);
10549 %}
10550 
10551 instruct smnegL(iRegLNoSp dst, iRegIorL2I src1, iRegIorL2I src2, immL0 zero) %{
10552   match(Set dst (MulL (SubL zero (ConvI2L src1)) (ConvI2L src2)));
10553   match(Set dst (MulL (ConvI2L src1) (SubL zero (ConvI2L src2))));
10554 
10555   ins_cost(INSN_COST * 3);
10556   format %{ &quot;smnegl  $dst, $src1, $src2&quot; %}
10557 
10558   ins_encode %{
10559     __ smnegl(as_Register($dst$$reg),
10560               as_Register($src1$$reg),
10561               as_Register($src2$$reg));
10562   %}
10563 
10564   ins_pipe(imac_reg_reg);
10565 %}
10566 
<span class="line-added">10567 // Combined Multiply-Add Shorts into Integer (dst = src1 * src2 + src3 * src4)</span>
<span class="line-added">10568 </span>
<span class="line-added">10569 instruct muladdS2I(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, iRegIorL2I src3, iRegIorL2I src4) %{</span>
<span class="line-added">10570   match(Set dst (MulAddS2I (Binary src1 src2) (Binary src3 src4)));</span>
<span class="line-added">10571 </span>
<span class="line-added">10572   ins_cost(INSN_COST * 5);</span>
<span class="line-added">10573   format %{ &quot;mulw  rscratch1, $src1, $src2\n\t&quot;</span>
<span class="line-added">10574             &quot;maddw $dst, $src3, $src4, rscratch1&quot; %}</span>
<span class="line-added">10575 </span>
<span class="line-added">10576   ins_encode %{</span>
<span class="line-added">10577     __ mulw(rscratch1, as_Register($src1$$reg), as_Register($src2$$reg));</span>
<span class="line-added">10578     __ maddw(as_Register($dst$$reg), as_Register($src3$$reg), as_Register($src4$$reg), rscratch1); %}</span>
<span class="line-added">10579 </span>
<span class="line-added">10580   ins_pipe(imac_reg_reg);</span>
<span class="line-added">10581 %}</span>
<span class="line-added">10582 </span>
10583 // Integer Divide
10584 
10585 instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
10586   match(Set dst (DivI src1 src2));
10587 
10588   ins_cost(INSN_COST * 19);
10589   format %{ &quot;sdivw  $dst, $src1, $src2&quot; %}
10590 
10591   ins_encode(aarch64_enc_divw(dst, src1, src2));
10592   ins_pipe(idiv_reg_reg);
10593 %}
10594 
10595 instruct signExtract(iRegINoSp dst, iRegIorL2I src1, immI_31 div1, immI_31 div2) %{
10596   match(Set dst (URShiftI (RShiftI src1 div1) div2));
10597   ins_cost(INSN_COST);
10598   format %{ &quot;lsrw $dst, $src1, $div1&quot; %}
10599   ins_encode %{
10600     __ lsrw(as_Register($dst$$reg), as_Register($src1$$reg), 31);
10601   %}
10602   ins_pipe(ialu_reg_shift);
</pre>
<hr />
<pre>
14919 %}
14920 
14921 instruct cmpI_branch_sign(cmpOpLtGe cmp, iRegIorL2I op1, immI0 op2, label labl) %{
14922   match(If cmp (CmpI op1 op2));
14923   effect(USE labl);
14924 
14925   ins_cost(BRANCH_COST);
14926   format %{ &quot;cb$cmp   $op1, $labl # int&quot; %}
14927   ins_encode %{
14928     Label* L = $labl$$label;
14929     Assembler::Condition cond =
14930       ((Assembler::Condition)$cmp$$cmpcode == Assembler::LT) ? Assembler::NE : Assembler::EQ;
14931     __ tbr(cond, $op1$$Register, 31, *L);
14932   %}
14933   ins_pipe(pipe_cmp_branch);
14934   ins_short_branch(1);
14935 %}
14936 
14937 instruct cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
14938   match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">14939   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
14940   effect(USE labl);
14941 
14942   ins_cost(BRANCH_COST);
14943   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
14944   ins_encode %{
14945     Label* L = $labl$$label;
14946     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">14947     int bit = exact_log2_long($op2$$constant);</span>
14948     __ tbr(cond, $op1$$Register, bit, *L);
14949   %}
14950   ins_pipe(pipe_cmp_branch);
14951   ins_short_branch(1);
14952 %}
14953 
14954 instruct cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
14955   match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">14956   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
14957   effect(USE labl);
14958 
14959   ins_cost(BRANCH_COST);
14960   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
14961   ins_encode %{
14962     Label* L = $labl$$label;
14963     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">14964     int bit = exact_log2((juint)$op2$$constant);</span>
14965     __ tbr(cond, $op1$$Register, bit, *L);
14966   %}
14967   ins_pipe(pipe_cmp_branch);
14968   ins_short_branch(1);
14969 %}
14970 
14971 // And far variants
14972 instruct far_cmpL_branch_sign(cmpOpLtGe cmp, iRegL op1, immL0 op2, label labl) %{
14973   match(If cmp (CmpL op1 op2));
14974   effect(USE labl);
14975 
14976   ins_cost(BRANCH_COST);
14977   format %{ &quot;cb$cmp   $op1, $labl # long&quot; %}
14978   ins_encode %{
14979     Label* L = $labl$$label;
14980     Assembler::Condition cond =
14981       ((Assembler::Condition)$cmp$$cmpcode == Assembler::LT) ? Assembler::NE : Assembler::EQ;
14982     __ tbr(cond, $op1$$Register, 63, *L, /*far*/true);
14983   %}
14984   ins_pipe(pipe_cmp_branch);
14985 %}
14986 
14987 instruct far_cmpI_branch_sign(cmpOpLtGe cmp, iRegIorL2I op1, immI0 op2, label labl) %{
14988   match(If cmp (CmpI op1 op2));
14989   effect(USE labl);
14990 
14991   ins_cost(BRANCH_COST);
14992   format %{ &quot;cb$cmp   $op1, $labl # int&quot; %}
14993   ins_encode %{
14994     Label* L = $labl$$label;
14995     Assembler::Condition cond =
14996       ((Assembler::Condition)$cmp$$cmpcode == Assembler::LT) ? Assembler::NE : Assembler::EQ;
14997     __ tbr(cond, $op1$$Register, 31, *L, /*far*/true);
14998   %}
14999   ins_pipe(pipe_cmp_branch);
15000 %}
15001 
15002 instruct far_cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
15003   match(If cmp (CmpL (AndL op1 op2) op3));
<span class="line-modified">15004   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
15005   effect(USE labl);
15006 
15007   ins_cost(BRANCH_COST);
15008   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
15009   ins_encode %{
15010     Label* L = $labl$$label;
15011     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">15012     int bit = exact_log2_long($op2$$constant);</span>
15013     __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
15014   %}
15015   ins_pipe(pipe_cmp_branch);
15016 %}
15017 
15018 instruct far_cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
15019   match(If cmp (CmpI (AndI op1 op2) op3));
<span class="line-modified">15020   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
15021   effect(USE labl);
15022 
15023   ins_cost(BRANCH_COST);
15024   format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
15025   ins_encode %{
15026     Label* L = $labl$$label;
15027     Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="line-modified">15028     int bit = exact_log2((juint)$op2$$constant);</span>
15029     __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
15030   %}
15031   ins_pipe(pipe_cmp_branch);
15032 %}
15033 
15034 // Test bits
15035 
15036 instruct cmpL_and(cmpOp cmp, iRegL op1, immL op2, immL0 op3, rFlagsReg cr) %{
15037   match(Set cr (CmpL (AndL op1 op2) op3));
15038   predicate(Assembler::operand_valid_for_logical_immediate
15039             (/*is_32*/false, n-&gt;in(1)-&gt;in(2)-&gt;get_long()));
15040 
15041   ins_cost(INSN_COST);
15042   format %{ &quot;tst $op1, $op2 # long&quot; %}
15043   ins_encode %{
15044     __ tst($op1$$Register, $op2$$constant);
15045   %}
15046   ins_pipe(ialu_reg_reg);
15047 %}
15048 
</pre>
<hr />
<pre>
16943             as_FloatRegister($src2$$reg));
16944   %}
16945   ins_pipe(vmuldiv_fp128);
16946 %}
16947 
16948 // dst - src1 * src2
16949 instruct vmls2D(vecX dst, vecX src1, vecX src2) %{
16950   predicate(UseFMA &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
16951   match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));
16952   match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));
16953   format %{ &quot;fmls  $dst,$src1,$src2\t# vector (2D)&quot; %}
16954   ins_cost(INSN_COST);
16955   ins_encode %{
16956     __ fmls(as_FloatRegister($dst$$reg), __ T2D,
16957             as_FloatRegister($src1$$reg),
16958             as_FloatRegister($src2$$reg));
16959   %}
16960   ins_pipe(vmuldiv_fp128);
16961 %}
16962 
<span class="line-added">16963 // --------------- Vector Multiply-Add Shorts into Integer --------------------</span>
<span class="line-added">16964 </span>
<span class="line-added">16965 instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{</span>
<span class="line-added">16966   predicate(n-&gt;in(1)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_SHORT);</span>
<span class="line-added">16967   match(Set dst (MulAddVS2VI src1 src2));</span>
<span class="line-added">16968   ins_cost(INSN_COST);</span>
<span class="line-added">16969   effect(TEMP tmp);</span>
<span class="line-added">16970   format %{ &quot;smullv  $tmp, $src1, $src2\t# vector (4H)\n\t&quot;</span>
<span class="line-added">16971             &quot;smullv  $dst, $src1, $src2\t# vector (8H)\n\t&quot;</span>
<span class="line-added">16972             &quot;addpv   $dst, $tmp, $dst\t# vector (4S)\n\t&quot; %}</span>
<span class="line-added">16973   ins_encode %{</span>
<span class="line-added">16974     __ smullv(as_FloatRegister($tmp$$reg), __ T4H,</span>
<span class="line-added">16975               as_FloatRegister($src1$$reg),</span>
<span class="line-added">16976               as_FloatRegister($src2$$reg));</span>
<span class="line-added">16977     __ smullv(as_FloatRegister($dst$$reg), __ T8H,</span>
<span class="line-added">16978               as_FloatRegister($src1$$reg),</span>
<span class="line-added">16979               as_FloatRegister($src2$$reg));</span>
<span class="line-added">16980     __ addpv(as_FloatRegister($dst$$reg), __ T4S,</span>
<span class="line-added">16981              as_FloatRegister($tmp$$reg),</span>
<span class="line-added">16982              as_FloatRegister($dst$$reg));</span>
<span class="line-added">16983   %}</span>
<span class="line-added">16984   ins_pipe(vmuldiv_fp128);</span>
<span class="line-added">16985 %}</span>
<span class="line-added">16986 </span>
16987 // --------------------------------- DIV --------------------------------------
16988 
16989 instruct vdiv2F(vecD dst, vecD src1, vecD src2)
16990 %{
16991   predicate(n-&gt;as_Vector()-&gt;length() == 2);
16992   match(Set dst (DivVF src1 src2));
16993   ins_cost(INSN_COST);
16994   format %{ &quot;fdiv  $dst,$src1,$src2\t# vector (2S)&quot; %}
16995   ins_encode %{
16996     __ fdiv(as_FloatRegister($dst$$reg), __ T2S,
16997             as_FloatRegister($src1$$reg),
16998             as_FloatRegister($src2$$reg));
16999   %}
17000   ins_pipe(vmuldiv_fp64);
17001 %}
17002 
17003 instruct vdiv4F(vecX dst, vecX src1, vecX src2)
17004 %{
17005   predicate(n-&gt;as_Vector()-&gt;length() == 4);
17006   match(Set dst (DivVF src1 src2));
</pre>
<hr />
<pre>
17344 instruct vsrl16B(vecX dst, vecX src, vecX shift, vecX tmp) %{
17345   predicate(n-&gt;as_Vector()-&gt;length() == 16);
17346   match(Set dst (URShiftVB src shift));
17347   ins_cost(INSN_COST);
17348   effect(TEMP tmp);
17349   format %{ &quot;negr  $tmp,$shift\t&quot;
17350             &quot;ushl  $dst,$src,$tmp\t# vector (16B)&quot; %}
17351   ins_encode %{
17352     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17353             as_FloatRegister($shift$$reg));
17354     __ ushl(as_FloatRegister($dst$$reg), __ T16B,
17355             as_FloatRegister($src$$reg),
17356             as_FloatRegister($tmp$$reg));
17357   %}
17358   ins_pipe(vshift128);
17359 %}
17360 
17361 instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{
17362   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17363             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17364   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
17365   ins_cost(INSN_COST);
17366   format %{ &quot;shl    $dst, $src, $shift\t# vector (8B)&quot; %}
17367   ins_encode %{
17368     int sh = (int)$shift$$constant;
17369     if (sh &gt;= 8) {
17370       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17371              as_FloatRegister($src$$reg),
17372              as_FloatRegister($src$$reg));
17373     } else {
17374       __ shl(as_FloatRegister($dst$$reg), __ T8B,
17375              as_FloatRegister($src$$reg), sh);
17376     }
17377   %}
17378   ins_pipe(vshift64_imm);
17379 %}
17380 
17381 instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{
17382   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17383   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
17384   ins_cost(INSN_COST);
17385   format %{ &quot;shl    $dst, $src, $shift\t# vector (16B)&quot; %}
17386   ins_encode %{
17387     int sh = (int)$shift$$constant;
17388     if (sh &gt;= 8) {
17389       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17390              as_FloatRegister($src$$reg),
17391              as_FloatRegister($src$$reg));
17392     } else {
17393       __ shl(as_FloatRegister($dst$$reg), __ T16B,
17394              as_FloatRegister($src$$reg), sh);
17395     }
17396   %}
17397   ins_pipe(vshift128_imm);
17398 %}
17399 
17400 instruct vsra8B_imm(vecD dst, vecD src, immI shift) %{
17401   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17402             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17403   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
17404   ins_cost(INSN_COST);
17405   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8B)&quot; %}
17406   ins_encode %{
17407     int sh = (int)$shift$$constant;
17408     if (sh &gt;= 8) sh = 7;
17409     __ sshr(as_FloatRegister($dst$$reg), __ T8B,
17410            as_FloatRegister($src$$reg), sh);
17411   %}
17412   ins_pipe(vshift64_imm);
17413 %}
17414 
17415 instruct vsra16B_imm(vecX dst, vecX src, immI shift) %{
17416   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17417   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
17418   ins_cost(INSN_COST);
17419   format %{ &quot;sshr    $dst, $src, $shift\t# vector (16B)&quot; %}
17420   ins_encode %{
17421     int sh = (int)$shift$$constant;
17422     if (sh &gt;= 8) sh = 7;
17423     __ sshr(as_FloatRegister($dst$$reg), __ T16B,
17424            as_FloatRegister($src$$reg), sh);
17425   %}
17426   ins_pipe(vshift128_imm);
17427 %}
17428 
17429 instruct vsrl8B_imm(vecD dst, vecD src, immI shift) %{
17430   predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
17431             n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17432   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
17433   ins_cost(INSN_COST);
17434   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8B)&quot; %}
17435   ins_encode %{
17436     int sh = (int)$shift$$constant;
17437     if (sh &gt;= 8) {
17438       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17439              as_FloatRegister($src$$reg),
17440              as_FloatRegister($src$$reg));
17441     } else {
17442       __ ushr(as_FloatRegister($dst$$reg), __ T8B,
17443              as_FloatRegister($src$$reg), sh);
17444     }
17445   %}
17446   ins_pipe(vshift64_imm);
17447 %}
17448 
17449 instruct vsrl16B_imm(vecX dst, vecX src, immI shift) %{
17450   predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="line-modified">17451   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
17452   ins_cost(INSN_COST);
17453   format %{ &quot;ushr    $dst, $src, $shift\t# vector (16B)&quot; %}
17454   ins_encode %{
17455     int sh = (int)$shift$$constant;
17456     if (sh &gt;= 8) {
17457       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17458              as_FloatRegister($src$$reg),
17459              as_FloatRegister($src$$reg));
17460     } else {
17461       __ ushr(as_FloatRegister($dst$$reg), __ T16B,
17462              as_FloatRegister($src$$reg), sh);
17463     }
17464   %}
17465   ins_pipe(vshift128_imm);
17466 %}
17467 
17468 instruct vsll4S(vecD dst, vecD src, vecD shift) %{
17469   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17470             n-&gt;as_Vector()-&gt;length() == 4);
17471   match(Set dst (LShiftVS src shift));
</pre>
<hr />
<pre>
17548 instruct vsrl8S(vecX dst, vecX src, vecX shift, vecX tmp) %{
17549   predicate(n-&gt;as_Vector()-&gt;length() == 8);
17550   match(Set dst (URShiftVS src shift));
17551   ins_cost(INSN_COST);
17552   effect(TEMP tmp);
17553   format %{ &quot;negr  $tmp,$shift\t&quot;
17554             &quot;ushl  $dst,$src,$tmp\t# vector (8H)&quot; %}
17555   ins_encode %{
17556     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17557             as_FloatRegister($shift$$reg));
17558     __ ushl(as_FloatRegister($dst$$reg), __ T8H,
17559             as_FloatRegister($src$$reg),
17560             as_FloatRegister($tmp$$reg));
17561   %}
17562   ins_pipe(vshift128);
17563 %}
17564 
17565 instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{
17566   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17567             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17568   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
17569   ins_cost(INSN_COST);
17570   format %{ &quot;shl    $dst, $src, $shift\t# vector (4H)&quot; %}
17571   ins_encode %{
17572     int sh = (int)$shift$$constant;
17573     if (sh &gt;= 16) {
17574       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17575              as_FloatRegister($src$$reg),
17576              as_FloatRegister($src$$reg));
17577     } else {
17578       __ shl(as_FloatRegister($dst$$reg), __ T4H,
17579              as_FloatRegister($src$$reg), sh);
17580     }
17581   %}
17582   ins_pipe(vshift64_imm);
17583 %}
17584 
17585 instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{
17586   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17587   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
17588   ins_cost(INSN_COST);
17589   format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
17590   ins_encode %{
17591     int sh = (int)$shift$$constant;
17592     if (sh &gt;= 16) {
17593       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17594              as_FloatRegister($src$$reg),
17595              as_FloatRegister($src$$reg));
17596     } else {
17597       __ shl(as_FloatRegister($dst$$reg), __ T8H,
17598              as_FloatRegister($src$$reg), sh);
17599     }
17600   %}
17601   ins_pipe(vshift128_imm);
17602 %}
17603 
17604 instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
17605   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17606             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17607   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
17608   ins_cost(INSN_COST);
17609   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
17610   ins_encode %{
17611     int sh = (int)$shift$$constant;
17612     if (sh &gt;= 16) sh = 15;
17613     __ sshr(as_FloatRegister($dst$$reg), __ T4H,
17614            as_FloatRegister($src$$reg), sh);
17615   %}
17616   ins_pipe(vshift64_imm);
17617 %}
17618 
17619 instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
17620   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17621   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
17622   ins_cost(INSN_COST);
17623   format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
17624   ins_encode %{
17625     int sh = (int)$shift$$constant;
17626     if (sh &gt;= 16) sh = 15;
17627     __ sshr(as_FloatRegister($dst$$reg), __ T8H,
17628            as_FloatRegister($src$$reg), sh);
17629   %}
17630   ins_pipe(vshift128_imm);
17631 %}
17632 
17633 instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
17634   predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
17635             n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17636   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
17637   ins_cost(INSN_COST);
17638   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
17639   ins_encode %{
17640     int sh = (int)$shift$$constant;
17641     if (sh &gt;= 16) {
17642       __ eor(as_FloatRegister($dst$$reg), __ T8B,
17643              as_FloatRegister($src$$reg),
17644              as_FloatRegister($src$$reg));
17645     } else {
17646       __ ushr(as_FloatRegister($dst$$reg), __ T4H,
17647              as_FloatRegister($src$$reg), sh);
17648     }
17649   %}
17650   ins_pipe(vshift64_imm);
17651 %}
17652 
17653 instruct vsrl8S_imm(vecX dst, vecX src, immI shift) %{
17654   predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="line-modified">17655   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
17656   ins_cost(INSN_COST);
17657   format %{ &quot;ushr    $dst, $src, $shift\t# vector (8H)&quot; %}
17658   ins_encode %{
17659     int sh = (int)$shift$$constant;
17660     if (sh &gt;= 16) {
17661       __ eor(as_FloatRegister($dst$$reg), __ T16B,
17662              as_FloatRegister($src$$reg),
17663              as_FloatRegister($src$$reg));
17664     } else {
17665       __ ushr(as_FloatRegister($dst$$reg), __ T8H,
17666              as_FloatRegister($src$$reg), sh);
17667     }
17668   %}
17669   ins_pipe(vshift128_imm);
17670 %}
17671 
17672 instruct vsll2I(vecD dst, vecD src, vecD shift) %{
17673   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17674   match(Set dst (LShiftVI src shift));
17675   ins_cost(INSN_COST);
</pre>
<hr />
<pre>
17748 
17749 instruct vsrl4I(vecX dst, vecX src, vecX shift, vecX tmp) %{
17750   predicate(n-&gt;as_Vector()-&gt;length() == 4);
17751   match(Set dst (URShiftVI src shift));
17752   ins_cost(INSN_COST);
17753   effect(TEMP tmp);
17754   format %{ &quot;negr  $tmp,$shift\t&quot;
17755             &quot;ushl  $dst,$src,$tmp\t# vector (4S)&quot; %}
17756   ins_encode %{
17757     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17758             as_FloatRegister($shift$$reg));
17759     __ ushl(as_FloatRegister($dst$$reg), __ T4S,
17760             as_FloatRegister($src$$reg),
17761             as_FloatRegister($tmp$$reg));
17762   %}
17763   ins_pipe(vshift128);
17764 %}
17765 
17766 instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{
17767   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17768   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
17769   ins_cost(INSN_COST);
17770   format %{ &quot;shl    $dst, $src, $shift\t# vector (2S)&quot; %}
17771   ins_encode %{
17772     __ shl(as_FloatRegister($dst$$reg), __ T2S,
17773            as_FloatRegister($src$$reg),
17774            (int)$shift$$constant);
17775   %}
17776   ins_pipe(vshift64_imm);
17777 %}
17778 
17779 instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{
17780   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17781   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
17782   ins_cost(INSN_COST);
17783   format %{ &quot;shl    $dst, $src, $shift\t# vector (4S)&quot; %}
17784   ins_encode %{
17785     __ shl(as_FloatRegister($dst$$reg), __ T4S,
17786            as_FloatRegister($src$$reg),
17787            (int)$shift$$constant);
17788   %}
17789   ins_pipe(vshift128_imm);
17790 %}
17791 
17792 instruct vsra2I_imm(vecD dst, vecD src, immI shift) %{
17793   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17794   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
17795   ins_cost(INSN_COST);
17796   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2S)&quot; %}
17797   ins_encode %{
17798     __ sshr(as_FloatRegister($dst$$reg), __ T2S,
17799             as_FloatRegister($src$$reg),
17800             (int)$shift$$constant);
17801   %}
17802   ins_pipe(vshift64_imm);
17803 %}
17804 
17805 instruct vsra4I_imm(vecX dst, vecX src, immI shift) %{
17806   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17807   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
17808   ins_cost(INSN_COST);
17809   format %{ &quot;sshr    $dst, $src, $shift\t# vector (4S)&quot; %}
17810   ins_encode %{
17811     __ sshr(as_FloatRegister($dst$$reg), __ T4S,
17812             as_FloatRegister($src$$reg),
17813             (int)$shift$$constant);
17814   %}
17815   ins_pipe(vshift128_imm);
17816 %}
17817 
17818 instruct vsrl2I_imm(vecD dst, vecD src, immI shift) %{
17819   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17820   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
17821   ins_cost(INSN_COST);
17822   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2S)&quot; %}
17823   ins_encode %{
17824     __ ushr(as_FloatRegister($dst$$reg), __ T2S,
17825             as_FloatRegister($src$$reg),
17826             (int)$shift$$constant);
17827   %}
17828   ins_pipe(vshift64_imm);
17829 %}
17830 
17831 instruct vsrl4I_imm(vecX dst, vecX src, immI shift) %{
17832   predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="line-modified">17833   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
17834   ins_cost(INSN_COST);
17835   format %{ &quot;ushr    $dst, $src, $shift\t# vector (4S)&quot; %}
17836   ins_encode %{
17837     __ ushr(as_FloatRegister($dst$$reg), __ T4S,
17838             as_FloatRegister($src$$reg),
17839             (int)$shift$$constant);
17840   %}
17841   ins_pipe(vshift128_imm);
17842 %}
17843 
17844 instruct vsll2L(vecX dst, vecX src, vecX shift) %{
17845   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17846   match(Set dst (LShiftVL src shift));
17847   ins_cost(INSN_COST);
17848   format %{ &quot;sshl  $dst,$src,$shift\t# vector (2D)&quot; %}
17849   ins_encode %{
17850     __ sshl(as_FloatRegister($dst$$reg), __ T2D,
17851             as_FloatRegister($src$$reg),
17852             as_FloatRegister($shift$$reg));
17853   %}
</pre>
<hr />
<pre>
17873 
17874 instruct vsrl2L(vecX dst, vecX src, vecX shift, vecX tmp) %{
17875   predicate(n-&gt;as_Vector()-&gt;length() == 2);
17876   match(Set dst (URShiftVL src shift));
17877   ins_cost(INSN_COST);
17878   effect(TEMP tmp);
17879   format %{ &quot;negr  $tmp,$shift\t&quot;
17880             &quot;ushl  $dst,$src,$tmp\t# vector (2D)&quot; %}
17881   ins_encode %{
17882     __ negr(as_FloatRegister($tmp$$reg), __ T16B,
17883             as_FloatRegister($shift$$reg));
17884     __ ushl(as_FloatRegister($dst$$reg), __ T2D,
17885             as_FloatRegister($src$$reg),
17886             as_FloatRegister($tmp$$reg));
17887   %}
17888   ins_pipe(vshift128);
17889 %}
17890 
17891 instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{
17892   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17893   match(Set dst (LShiftVL src (LShiftCntV shift)));</span>
17894   ins_cost(INSN_COST);
17895   format %{ &quot;shl    $dst, $src, $shift\t# vector (2D)&quot; %}
17896   ins_encode %{
17897     __ shl(as_FloatRegister($dst$$reg), __ T2D,
17898            as_FloatRegister($src$$reg),
17899            (int)$shift$$constant);
17900   %}
17901   ins_pipe(vshift128_imm);
17902 %}
17903 
17904 instruct vsra2L_imm(vecX dst, vecX src, immI shift) %{
17905   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17906   match(Set dst (RShiftVL src (RShiftCntV shift)));</span>
17907   ins_cost(INSN_COST);
17908   format %{ &quot;sshr    $dst, $src, $shift\t# vector (2D)&quot; %}
17909   ins_encode %{
17910     __ sshr(as_FloatRegister($dst$$reg), __ T2D,
17911             as_FloatRegister($src$$reg),
17912             (int)$shift$$constant);
17913   %}
17914   ins_pipe(vshift128_imm);
17915 %}
17916 
17917 instruct vsrl2L_imm(vecX dst, vecX src, immI shift) %{
17918   predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="line-modified">17919   match(Set dst (URShiftVL src (RShiftCntV shift)));</span>
17920   ins_cost(INSN_COST);
17921   format %{ &quot;ushr    $dst, $src, $shift\t# vector (2D)&quot; %}
17922   ins_encode %{
17923     __ ushr(as_FloatRegister($dst$$reg), __ T2D,
17924             as_FloatRegister($src$$reg),
17925             (int)$shift$$constant);
17926   %}
17927   ins_pipe(vshift128_imm);
17928 %}
17929 
17930 instruct vmax2F(vecD dst, vecD src1, vecD src2)
17931 %{
17932   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; n-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_FLOAT);
17933   match(Set dst (MaxV src1 src2));
17934   ins_cost(INSN_COST);
17935   format %{ &quot;fmax  $dst,$src1,$src2\t# vector (2F)&quot; %}
17936   ins_encode %{
17937     __ fmax(as_FloatRegister($dst$$reg), __ T2S,
17938             as_FloatRegister($src1$$reg),
17939             as_FloatRegister($src2$$reg));
</pre>
</td>
</tr>
</table>
<center><a href="../../.mx.jvmci/mx_jvmci.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
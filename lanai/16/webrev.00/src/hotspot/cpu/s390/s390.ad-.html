<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2017, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 
   25 // z/Architecture Architecture Description File
   26 
   27 // Major contributions by AS, JL, LS.
   28 
   29 //
   30 // Following information is derived from private mail communication
   31 // (Oct. 2011).
   32 //
   33 // General branch target alignment considerations
   34 //
   35 // z/Architecture does not imply a general branch target alignment requirement.
   36 // There are side effects and side considerations, though, which may
   37 // provide some performance benefit. These are:
   38 //  - Align branch target on octoword (32-byte) boundary
   39 //    On more recent models (from z9 on), I-fetch is done on a Octoword
   40 //    (32 bytes at a time) basis. To avoid I-fetching unnecessary
   41 //    instructions, branch targets should be 32-byte aligend. If this
   42 //    exact alingment cannot be achieved, having the branch target in
   43 //    the first doubleword still provides some benefit.
   44 //  - Avoid branch targets at the end of cache lines (&gt; 64 bytes distance).
   45 //    Sequential instruction prefetching after the branch target starts
   46 //    immediately after having fetched the octoword containing the
   47 //    branch target. When I-fetching crosses a cache line, there may be
   48 //    a small stall. The worst case: the branch target (at the end of
   49 //    a cache line) is a L1 I-cache miss and the next line as well.
   50 //    Then, the entire target line must be filled first (to contine at the
   51 //    branch target). Only then can the next sequential line be filled.
   52 //  - Avoid multiple poorly predicted branches in a row.
   53 //
   54 
   55 //----------REGISTER DEFINITION BLOCK------------------------------------------
   56 // This information is used by the matcher and the register allocator to
   57 // describe individual registers and classes of registers within the target
   58 // architecture.
   59 
   60 register %{
   61 
   62 //----------Architecture Description Register Definitions----------------------
   63 // General Registers
   64 // &quot;reg_def&quot; name (register save type, C convention save type,
   65 //                   ideal register type, encoding);
   66 //
   67 // Register Save Types:
   68 //
   69 //   NS  = No-Save:     The register allocator assumes that these registers
   70 //                      can be used without saving upon entry to the method, &amp;
   71 //                      that they do not need to be saved at call sites.
   72 //
   73 //   SOC = Save-On-Call: The register allocator assumes that these registers
   74 //                      can be used without saving upon entry to the method,
   75 //                      but that they must be saved at call sites.
   76 //
   77 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   78 //                      must be saved before using them upon entry to the
   79 //                      method, but they do not need to be saved at call sites.
   80 //
   81 //   AS  = Always-Save: The register allocator assumes that these registers
   82 //                      must be saved before using them upon entry to the
   83 //                      method, &amp; that they must be saved at call sites.
   84 //
   85 // Ideal Register Type is used to determine how to save &amp; restore a
   86 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   87 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   88 //
   89 // The encoding number is the actual bit-pattern placed into the opcodes.
   90 
   91 // z/Architecture register definitions, based on the z/Architecture Principles
   92 // of Operation, 5th Edition, September 2005, and z/Linux Elf ABI Supplement,
   93 // 5th Edition, March 2001.
   94 //
   95 // For each 64-bit register we must define two registers: the register
   96 // itself, e.g. Z_R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   97 // e.g. Z_R3_H, which is needed by the allocator, but is not used
   98 // for stores, loads, etc.
   99 
  100   // Integer/Long Registers
  101   // ----------------------------
  102 
  103   // z/Architecture has 16 64-bit integer registers.
  104 
  105   // types: v = volatile, nv = non-volatile, s = system
  106   reg_def Z_R0   (SOC, SOC, Op_RegI,  0, Z_R0-&gt;as_VMReg());   // v   scratch1
  107   reg_def Z_R0_H (SOC, SOC, Op_RegI, 99, Z_R0-&gt;as_VMReg()-&gt;next());
  108   reg_def Z_R1   (SOC, SOC, Op_RegI,  1, Z_R1-&gt;as_VMReg());   // v   scratch2
  109   reg_def Z_R1_H (SOC, SOC, Op_RegI, 99, Z_R1-&gt;as_VMReg()-&gt;next());
  110   reg_def Z_R2   (SOC, SOC, Op_RegI,  2, Z_R2-&gt;as_VMReg());   // v   iarg1 &amp; iret
  111   reg_def Z_R2_H (SOC, SOC, Op_RegI, 99, Z_R2-&gt;as_VMReg()-&gt;next());
  112   reg_def Z_R3   (SOC, SOC, Op_RegI,  3, Z_R3-&gt;as_VMReg());   // v   iarg2
  113   reg_def Z_R3_H (SOC, SOC, Op_RegI, 99, Z_R3-&gt;as_VMReg()-&gt;next());
  114   reg_def Z_R4   (SOC, SOC, Op_RegI,  4, Z_R4-&gt;as_VMReg());   // v   iarg3
  115   reg_def Z_R4_H (SOC, SOC, Op_RegI, 99, Z_R4-&gt;as_VMReg()-&gt;next());
  116   reg_def Z_R5   (SOC, SOC, Op_RegI,  5, Z_R5-&gt;as_VMReg());   // v   iarg4
  117   reg_def Z_R5_H (SOC, SOC, Op_RegI, 99, Z_R5-&gt;as_VMReg()-&gt;next());
  118   reg_def Z_R6   (SOC, SOE, Op_RegI,  6, Z_R6-&gt;as_VMReg());   // v   iarg5
  119   reg_def Z_R6_H (SOC, SOE, Op_RegI, 99, Z_R6-&gt;as_VMReg()-&gt;next());
  120   reg_def Z_R7   (SOC, SOE, Op_RegI,  7, Z_R7-&gt;as_VMReg());
  121   reg_def Z_R7_H (SOC, SOE, Op_RegI, 99, Z_R7-&gt;as_VMReg()-&gt;next());
  122   reg_def Z_R8   (SOC, SOE, Op_RegI,  8, Z_R8-&gt;as_VMReg());
  123   reg_def Z_R8_H (SOC, SOE, Op_RegI, 99, Z_R8-&gt;as_VMReg()-&gt;next());
  124   reg_def Z_R9   (SOC, SOE, Op_RegI,  9, Z_R9-&gt;as_VMReg());
  125   reg_def Z_R9_H (SOC, SOE, Op_RegI, 99, Z_R9-&gt;as_VMReg()-&gt;next());
  126   reg_def Z_R10  (SOC, SOE, Op_RegI, 10, Z_R10-&gt;as_VMReg());
  127   reg_def Z_R10_H(SOC, SOE, Op_RegI, 99, Z_R10-&gt;as_VMReg()-&gt;next());
  128   reg_def Z_R11  (SOC, SOE, Op_RegI, 11, Z_R11-&gt;as_VMReg());
  129   reg_def Z_R11_H(SOC, SOE, Op_RegI, 99, Z_R11-&gt;as_VMReg()-&gt;next());
  130   reg_def Z_R12  (SOC, SOE, Op_RegI, 12, Z_R12-&gt;as_VMReg());
  131   reg_def Z_R12_H(SOC, SOE, Op_RegI, 99, Z_R12-&gt;as_VMReg()-&gt;next());
  132   reg_def Z_R13  (SOC, SOE, Op_RegI, 13, Z_R13-&gt;as_VMReg());
  133   reg_def Z_R13_H(SOC, SOE, Op_RegI, 99, Z_R13-&gt;as_VMReg()-&gt;next());
  134   reg_def Z_R14  (NS,  NS,  Op_RegI, 14, Z_R14-&gt;as_VMReg());   // s  return_pc
  135   reg_def Z_R14_H(NS,  NS,  Op_RegI, 99, Z_R14-&gt;as_VMReg()-&gt;next());
  136   reg_def Z_R15  (NS,  NS,  Op_RegI, 15, Z_R15-&gt;as_VMReg());   // s  SP
  137   reg_def Z_R15_H(NS,  NS,  Op_RegI, 99, Z_R15-&gt;as_VMReg()-&gt;next());
  138 
  139   // Float/Double Registers
  140 
  141   // The rules of ADL require that double registers be defined in pairs.
  142   // Each pair must be two 32-bit values, but not necessarily a pair of
  143   // single float registers. In each pair, ADLC-assigned register numbers
  144   // must be adjacent, with the lower number even. Finally, when the
  145   // CPU stores such a register pair to memory, the word associated with
  146   // the lower ADLC-assigned number must be stored to the lower address.
  147 
  148   // z/Architecture has 16 64-bit floating-point registers. Each can store a single
  149   // or double precision floating-point value.
  150 
  151   // types: v = volatile, nv = non-volatile, s = system
  152   reg_def Z_F0   (SOC, SOC, Op_RegF,  0, Z_F0-&gt;as_VMReg());   // v   farg1 &amp; fret
  153   reg_def Z_F0_H (SOC, SOC, Op_RegF, 99, Z_F0-&gt;as_VMReg()-&gt;next());
  154   reg_def Z_F1   (SOC, SOC, Op_RegF,  1, Z_F1-&gt;as_VMReg());
  155   reg_def Z_F1_H (SOC, SOC, Op_RegF, 99, Z_F1-&gt;as_VMReg()-&gt;next());
  156   reg_def Z_F2   (SOC, SOC, Op_RegF,  2, Z_F2-&gt;as_VMReg());   // v   farg2
  157   reg_def Z_F2_H (SOC, SOC, Op_RegF, 99, Z_F2-&gt;as_VMReg()-&gt;next());
  158   reg_def Z_F3   (SOC, SOC, Op_RegF,  3, Z_F3-&gt;as_VMReg());
  159   reg_def Z_F3_H (SOC, SOC, Op_RegF, 99, Z_F3-&gt;as_VMReg()-&gt;next());
  160   reg_def Z_F4   (SOC, SOC, Op_RegF,  4, Z_F4-&gt;as_VMReg());   // v   farg3
  161   reg_def Z_F4_H (SOC, SOC, Op_RegF, 99, Z_F4-&gt;as_VMReg()-&gt;next());
  162   reg_def Z_F5   (SOC, SOC, Op_RegF,  5, Z_F5-&gt;as_VMReg());
  163   reg_def Z_F5_H (SOC, SOC, Op_RegF, 99, Z_F5-&gt;as_VMReg()-&gt;next());
  164   reg_def Z_F6   (SOC, SOC, Op_RegF,  6, Z_F6-&gt;as_VMReg());
  165   reg_def Z_F6_H (SOC, SOC, Op_RegF, 99, Z_F6-&gt;as_VMReg()-&gt;next());
  166   reg_def Z_F7   (SOC, SOC, Op_RegF,  7, Z_F7-&gt;as_VMReg());
  167   reg_def Z_F7_H (SOC, SOC, Op_RegF, 99, Z_F7-&gt;as_VMReg()-&gt;next());
  168   reg_def Z_F8   (SOC, SOE, Op_RegF,  8, Z_F8-&gt;as_VMReg());
  169   reg_def Z_F8_H (SOC, SOE, Op_RegF, 99, Z_F8-&gt;as_VMReg()-&gt;next());
  170   reg_def Z_F9   (SOC, SOE, Op_RegF,  9, Z_F9-&gt;as_VMReg());
  171   reg_def Z_F9_H (SOC, SOE, Op_RegF, 99, Z_F9-&gt;as_VMReg()-&gt;next());
  172   reg_def Z_F10  (SOC, SOE, Op_RegF, 10, Z_F10-&gt;as_VMReg());
  173   reg_def Z_F10_H(SOC, SOE, Op_RegF, 99, Z_F10-&gt;as_VMReg()-&gt;next());
  174   reg_def Z_F11  (SOC, SOE, Op_RegF, 11, Z_F11-&gt;as_VMReg());
  175   reg_def Z_F11_H(SOC, SOE, Op_RegF, 99, Z_F11-&gt;as_VMReg()-&gt;next());
  176   reg_def Z_F12  (SOC, SOE, Op_RegF, 12, Z_F12-&gt;as_VMReg());
  177   reg_def Z_F12_H(SOC, SOE, Op_RegF, 99, Z_F12-&gt;as_VMReg()-&gt;next());
  178   reg_def Z_F13  (SOC, SOE, Op_RegF, 13, Z_F13-&gt;as_VMReg());
  179   reg_def Z_F13_H(SOC, SOE, Op_RegF, 99, Z_F13-&gt;as_VMReg()-&gt;next());
  180   reg_def Z_F14  (SOC, SOE, Op_RegF, 14, Z_F14-&gt;as_VMReg());
  181   reg_def Z_F14_H(SOC, SOE, Op_RegF, 99, Z_F14-&gt;as_VMReg()-&gt;next());
  182   reg_def Z_F15  (SOC, SOE, Op_RegF, 15, Z_F15-&gt;as_VMReg());
  183   reg_def Z_F15_H(SOC, SOE, Op_RegF, 99, Z_F15-&gt;as_VMReg()-&gt;next());
  184 
  185 
  186   // Special Registers
  187 
  188   // Condition Codes Flag Registers
  189 
  190   // z/Architecture has the PSW (program status word) that contains
  191   // (among other information) the condition code. We treat this
  192   // part of the PSW as a condition register CR. It consists of 4
  193   // bits. Floating point instructions influence the same condition register CR.
  194 
  195   reg_def Z_CR(SOC, SOC, Op_RegFlags, 0, Z_CR-&gt;as_VMReg());   // volatile
  196 
  197 
  198 // Specify priority of register selection within phases of register
  199 // allocation. Highest priority is first. A useful heuristic is to
  200 // give registers a low priority when they are required by machine
  201 // instructions, and choose no-save registers before save-on-call, and
  202 // save-on-call before save-on-entry. Registers which participate in
  203 // fix calling sequences should come last. Registers which are used
  204 // as pairs must fall on an even boundary.
  205 
  206 // It&#39;s worth about 1% on SPEC geomean to get this right.
  207 
  208 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  209 // in adGlobals_s390.hpp which defines the &lt;register&gt;_num values, e.g.
  210 // Z_R3_num. Therefore, Z_R3_num may not be (and in reality is not)
  211 // the same as Z_R3-&gt;encoding()! Furthermore, we cannot make any
  212 // assumptions on ordering, e.g. Z_R3_num may be less than Z_R2_num.
  213 // Additionally, the function
  214 //   static enum RC rc_class(OptoReg::Name reg)
  215 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  216 // and its current implementation relies on chunk0 and chunk1 having a
  217 // size of 64 each.
  218 
  219 alloc_class chunk0(
  220   // chunk0 contains *all* 32 integer registers halves.
  221 
  222   // potential SOE regs
  223   Z_R13,Z_R13_H,
  224   Z_R12,Z_R12_H,
  225   Z_R11,Z_R11_H,
  226   Z_R10,Z_R10_H,
  227 
  228   Z_R9,Z_R9_H,
  229   Z_R8,Z_R8_H,
  230   Z_R7,Z_R7_H,
  231 
  232   Z_R1,Z_R1_H,
  233   Z_R0,Z_R0_H,
  234 
  235   // argument registers
  236   Z_R6,Z_R6_H,
  237   Z_R5,Z_R5_H,
  238   Z_R4,Z_R4_H,
  239   Z_R3,Z_R3_H,
  240   Z_R2,Z_R2_H,
  241 
  242   // special registers
  243   Z_R14,Z_R14_H,
  244   Z_R15,Z_R15_H
  245 );
  246 
  247 alloc_class chunk1(
  248   // Chunk1 contains *all* 64 floating-point registers halves.
  249 
  250   Z_F15,Z_F15_H,
  251   Z_F14,Z_F14_H,
  252   Z_F13,Z_F13_H,
  253   Z_F12,Z_F12_H,
  254   Z_F11,Z_F11_H,
  255   Z_F10,Z_F10_H,
  256   Z_F9,Z_F9_H,
  257   Z_F8,Z_F8_H,
  258   // scratch register
  259   Z_F7,Z_F7_H,
  260   Z_F5,Z_F5_H,
  261   Z_F3,Z_F3_H,
  262   Z_F1,Z_F1_H,
  263   // argument registers
  264   Z_F6,Z_F6_H,
  265   Z_F4,Z_F4_H,
  266   Z_F2,Z_F2_H,
  267   Z_F0,Z_F0_H
  268 );
  269 
  270 alloc_class chunk2(
  271   Z_CR
  272 );
  273 
  274 
  275 //-------Architecture Description Register Classes-----------------------
  276 
  277 // Several register classes are automatically defined based upon
  278 // information in this architecture description.
  279 
  280 // 1) reg_class inline_cache_reg           (as defined in frame section)
  281 // 2) reg_class compiler_method_oop_reg    (as defined in frame section)
  282 // 2) reg_class interpreter_method_oop_reg (as defined in frame section)
  283 // 3) reg_class stack_slots(/* one chunk of stack-based &quot;registers&quot; */)
  284 
  285 // Integer Register Classes
  286 reg_class z_int_reg(
  287 /*Z_R0*/              // R0
  288 /*Z_R1*/
  289   Z_R2,
  290   Z_R3,
  291   Z_R4,
  292   Z_R5,
  293   Z_R6,
  294   Z_R7,
  295 /*Z_R8,*/             // Z_thread
  296   Z_R9,
  297   Z_R10,
  298   Z_R11,
  299   Z_R12,
  300   Z_R13
  301 /*Z_R14*/             // return_pc
  302 /*Z_R15*/             // SP
  303 );
  304 
  305 reg_class z_no_odd_int_reg(
  306 /*Z_R0*/              // R0
  307 /*Z_R1*/
  308   Z_R2,
  309   Z_R3,
  310   Z_R4,
  311 /*Z_R5,*/             // odd part of fix register pair
  312   Z_R6,
  313   Z_R7,
  314 /*Z_R8,*/             // Z_thread
  315   Z_R9,
  316   Z_R10,
  317   Z_R11,
  318   Z_R12,
  319   Z_R13
  320 /*Z_R14*/             // return_pc
  321 /*Z_R15*/             // SP
  322 );
  323 
  324 reg_class z_no_arg_int_reg(
  325 /*Z_R0*/              // R0
  326 /*Z_R1*/              // scratch
  327 /*Z_R2*/
  328 /*Z_R3*/
  329 /*Z_R4*/
  330 /*Z_R5*/
  331 /*Z_R6*/
  332   Z_R7,
  333 /*Z_R8*/              // Z_thread
  334   Z_R9,
  335   Z_R10,
  336   Z_R11,
  337   Z_R12,
  338   Z_R13
  339 /*Z_R14*/             // return_pc
  340 /*Z_R15*/             // SP
  341 );
  342 
  343 reg_class z_rarg1_int_reg(Z_R2);
  344 reg_class z_rarg2_int_reg(Z_R3);
  345 reg_class z_rarg3_int_reg(Z_R4);
  346 reg_class z_rarg4_int_reg(Z_R5);
  347 reg_class z_rarg5_int_reg(Z_R6);
  348 
  349 // Pointer Register Classes
  350 
  351 // 64-bit build means 64-bit pointers means hi/lo pairs.
  352 
  353 reg_class z_rarg5_ptrN_reg(Z_R6);
  354 
  355 reg_class z_rarg1_ptr_reg(Z_R2_H,Z_R2);
  356 reg_class z_rarg2_ptr_reg(Z_R3_H,Z_R3);
  357 reg_class z_rarg3_ptr_reg(Z_R4_H,Z_R4);
  358 reg_class z_rarg4_ptr_reg(Z_R5_H,Z_R5);
  359 reg_class z_rarg5_ptr_reg(Z_R6_H,Z_R6);
  360 reg_class z_thread_ptr_reg(Z_R8_H,Z_R8);
  361 
  362 reg_class z_ptr_reg(
  363 /*Z_R0_H,Z_R0*/     // R0
  364 /*Z_R1_H,Z_R1*/
  365   Z_R2_H,Z_R2,
  366   Z_R3_H,Z_R3,
  367   Z_R4_H,Z_R4,
  368   Z_R5_H,Z_R5,
  369   Z_R6_H,Z_R6,
  370   Z_R7_H,Z_R7,
  371 /*Z_R8_H,Z_R8,*/    // Z_thread
  372   Z_R9_H,Z_R9,
  373   Z_R10_H,Z_R10,
  374   Z_R11_H,Z_R11,
  375   Z_R12_H,Z_R12,
  376   Z_R13_H,Z_R13
  377 /*Z_R14_H,Z_R14*/   // return_pc
  378 /*Z_R15_H,Z_R15*/   // SP
  379 );
  380 
  381 reg_class z_lock_ptr_reg(
  382 /*Z_R0_H,Z_R0*/     // R0
  383 /*Z_R1_H,Z_R1*/
  384   Z_R2_H,Z_R2,
  385   Z_R3_H,Z_R3,
  386   Z_R4_H,Z_R4,
  387 /*Z_R5_H,Z_R5,*/
  388 /*Z_R6_H,Z_R6,*/
  389   Z_R7_H,Z_R7,
  390 /*Z_R8_H,Z_R8,*/    // Z_thread
  391   Z_R9_H,Z_R9,
  392   Z_R10_H,Z_R10,
  393   Z_R11_H,Z_R11,
  394   Z_R12_H,Z_R12,
  395   Z_R13_H,Z_R13
  396 /*Z_R14_H,Z_R14*/   // return_pc
  397 /*Z_R15_H,Z_R15*/   // SP
  398 );
  399 
  400 reg_class z_no_arg_ptr_reg(
  401 /*Z_R0_H,Z_R0*/        // R0
  402 /*Z_R1_H,Z_R1*/        // scratch
  403 /*Z_R2_H,Z_R2*/
  404 /*Z_R3_H,Z_R3*/
  405 /*Z_R4_H,Z_R4*/
  406 /*Z_R5_H,Z_R5*/
  407 /*Z_R6_H,Z_R6*/
  408   Z_R7_H, Z_R7,
  409 /*Z_R8_H,Z_R8*/        // Z_thread
  410   Z_R9_H,Z_R9,
  411   Z_R10_H,Z_R10,
  412   Z_R11_H,Z_R11,
  413   Z_R12_H,Z_R12,
  414   Z_R13_H,Z_R13
  415 /*Z_R14_H,Z_R14*/      // return_pc
  416 /*Z_R15_H,Z_R15*/      // SP
  417 );
  418 
  419 // Special class for storeP instructions, which can store SP or RPC to
  420 // TLS. (Note: Do not generalize this to &quot;any_reg&quot;. If you add
  421 // another register, such as FP, to this mask, the allocator may try
  422 // to put a temp in it.)
  423 // Register class for memory access base registers,
  424 // This class is a superset of z_ptr_reg including Z_thread.
  425 reg_class z_memory_ptr_reg(
  426 /*Z_R0_H,Z_R0*/     // R0
  427 /*Z_R1_H,Z_R1*/
  428   Z_R2_H,Z_R2,
  429   Z_R3_H,Z_R3,
  430   Z_R4_H,Z_R4,
  431   Z_R5_H,Z_R5,
  432   Z_R6_H,Z_R6,
  433   Z_R7_H,Z_R7,
  434   Z_R8_H,Z_R8,      // Z_thread
  435   Z_R9_H,Z_R9,
  436   Z_R10_H,Z_R10,
  437   Z_R11_H,Z_R11,
  438   Z_R12_H,Z_R12,
  439   Z_R13_H,Z_R13
  440 /*Z_R14_H,Z_R14*/   // return_pc
  441 /*Z_R15_H,Z_R15*/   // SP
  442 );
  443 
  444 // Other special pointer regs.
  445 reg_class z_r1_regP(Z_R1_H,Z_R1);
  446 reg_class z_r9_regP(Z_R9_H,Z_R9);
  447 
  448 
  449 // Long Register Classes
  450 
  451 reg_class z_rarg1_long_reg(Z_R2_H,Z_R2);
  452 reg_class z_rarg2_long_reg(Z_R3_H,Z_R3);
  453 reg_class z_rarg3_long_reg(Z_R4_H,Z_R4);
  454 reg_class z_rarg4_long_reg(Z_R5_H,Z_R5);
  455 reg_class z_rarg5_long_reg(Z_R6_H,Z_R6);
  456 
  457 // Longs in 1 register. Aligned adjacent hi/lo pairs.
  458 reg_class z_long_reg(
  459 /*Z_R0_H,Z_R0*/     // R0
  460 /*Z_R1_H,Z_R1*/
  461   Z_R2_H,Z_R2,
  462   Z_R3_H,Z_R3,
  463   Z_R4_H,Z_R4,
  464   Z_R5_H,Z_R5,
  465   Z_R6_H,Z_R6,
  466   Z_R7_H,Z_R7,
  467 /*Z_R8_H,Z_R8,*/    // Z_thread
  468   Z_R9_H,Z_R9,
  469   Z_R10_H,Z_R10,
  470   Z_R11_H,Z_R11,
  471   Z_R12_H,Z_R12,
  472   Z_R13_H,Z_R13
  473 /*Z_R14_H,Z_R14,*/  // return_pc
  474 /*Z_R15_H,Z_R15*/   // SP
  475 );
  476 
  477 // z_long_reg without even registers
  478 reg_class z_long_odd_reg(
  479 /*Z_R0_H,Z_R0*/     // R0
  480 /*Z_R1_H,Z_R1*/
  481   Z_R3_H,Z_R3,
  482   Z_R5_H,Z_R5,
  483   Z_R7_H,Z_R7,
  484   Z_R9_H,Z_R9,
  485   Z_R11_H,Z_R11,
  486   Z_R13_H,Z_R13
  487 /*Z_R14_H,Z_R14,*/  // return_pc
  488 /*Z_R15_H,Z_R15*/   // SP
  489 );
  490 
  491 // Special Class for Condition Code Flags Register
  492 
  493 reg_class z_condition_reg(
  494   Z_CR
  495 );
  496 
  497 // Scratch register for late profiling. Callee saved.
  498 reg_class z_rscratch2_bits64_reg(Z_R2_H, Z_R2);
  499 
  500 
  501 // Float Register Classes
  502 
  503 reg_class z_flt_reg(
  504   Z_F0,
  505 /*Z_F1,*/ // scratch
  506   Z_F2,
  507   Z_F3,
  508   Z_F4,
  509   Z_F5,
  510   Z_F6,
  511   Z_F7,
  512   Z_F8,
  513   Z_F9,
  514   Z_F10,
  515   Z_F11,
  516   Z_F12,
  517   Z_F13,
  518   Z_F14,
  519   Z_F15
  520 );
  521 reg_class z_rscratch1_flt_reg(Z_F1);
  522 
  523 // Double precision float registers have virtual `high halves&#39; that
  524 // are needed by the allocator.
  525 reg_class z_dbl_reg(
  526   Z_F0,Z_F0_H,
  527 /*Z_F1,Z_F1_H,*/ // scratch
  528   Z_F2,Z_F2_H,
  529   Z_F3,Z_F3_H,
  530   Z_F4,Z_F4_H,
  531   Z_F5,Z_F5_H,
  532   Z_F6,Z_F6_H,
  533   Z_F7,Z_F7_H,
  534   Z_F8,Z_F8_H,
  535   Z_F9,Z_F9_H,
  536   Z_F10,Z_F10_H,
  537   Z_F11,Z_F11_H,
  538   Z_F12,Z_F12_H,
  539   Z_F13,Z_F13_H,
  540   Z_F14,Z_F14_H,
  541   Z_F15,Z_F15_H
  542 );
  543 reg_class z_rscratch1_dbl_reg(Z_F1,Z_F1_H);
  544 
  545 %}
  546 
  547 //----------DEFINITION BLOCK---------------------------------------------------
  548 // Define &#39;name --&gt; value&#39; mappings to inform the ADLC of an integer valued name.
  549 // Current support includes integer values in the range [0, 0x7FFFFFFF].
  550 // Format:
  551 //        int_def  &lt;name&gt;         (&lt;int_value&gt;, &lt;expression&gt;);
  552 // Generated Code in ad_&lt;arch&gt;.hpp
  553 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  554 //        // value == &lt;int_value&gt;
  555 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  556 //        assert(&lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  557 //
  558 definitions %{
  559   // The default cost (of an ALU instruction).
  560   int_def DEFAULT_COST      (   100,     100);
  561   int_def DEFAULT_COST_LOW  (    80,      80);
  562   int_def DEFAULT_COST_HIGH (   120,     120);
  563   int_def HUGE_COST         (1000000, 1000000);
  564 
  565   // Put an advantage on REG_MEM vs. MEM+REG_REG operations.
  566   int_def ALU_REG_COST      (   100, DEFAULT_COST);
  567   int_def ALU_MEMORY_COST   (   150,          150);
  568 
  569   // Memory refs are twice as expensive as run-of-the-mill.
  570   int_def MEMORY_REF_COST_HI (   220, 2 * DEFAULT_COST+20);
  571   int_def MEMORY_REF_COST    (   200, 2 * DEFAULT_COST);
  572   int_def MEMORY_REF_COST_LO (   180, 2 * DEFAULT_COST-20);
  573 
  574   // Branches are even more expensive.
  575   int_def BRANCH_COST       (   300, DEFAULT_COST * 3);
  576   int_def CALL_COST         (   300, DEFAULT_COST * 3);
  577 %}
  578 
  579 source %{
  580 
  581 #ifdef PRODUCT
  582 #define BLOCK_COMMENT(str)
  583 #define BIND(label)        __ bind(label)
  584 #else
  585 #define BLOCK_COMMENT(str) __ block_comment(str)
  586 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  587 #endif
  588 
  589 #define __ _masm.
  590 
  591 #define Z_DISP_SIZE Immediate::is_uimm12((long)opnd_array(1)-&gt;disp(ra_,this,2)) ?  4 : 6
  592 #define Z_DISP3_SIZE 6
  593 
  594 // Tertiary op of a LoadP or StoreP encoding.
  595 #define REGP_OP true
  596 
  597 // Given a register encoding, produce an Integer Register object.
  598 static Register reg_to_register_object(int register_encoding);
  599 
  600 // ****************************************************************************
  601 
  602 // REQUIRED FUNCTIONALITY
  603 
  604 // !!!!! Special hack to get all type of calls to specify the byte offset
  605 //       from the start of the call to the point where the return address
  606 //       will point.
  607 
  608 int MachCallStaticJavaNode::ret_addr_offset() {
  609   if (_method) {
  610     return 8;
  611   } else {
  612     return MacroAssembler::call_far_patchable_ret_addr_offset();
  613   }
  614 }
  615 
  616 int MachCallDynamicJavaNode::ret_addr_offset() {
  617   // Consider size of receiver type profiling (C2 tiers).
  618   int profile_receiver_type_size = 0;
  619 
  620   int vtable_index = this-&gt;_vtable_index;
  621   if (vtable_index == -4) {
  622     return 14 + profile_receiver_type_size;
  623   } else {
  624     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  625     return 36 + profile_receiver_type_size;
  626   }
  627 }
  628 
  629 int MachCallRuntimeNode::ret_addr_offset() {
  630   return 12 + MacroAssembler::call_far_patchable_ret_addr_offset();
  631 }
  632 
  633 // Compute padding required for nodes which need alignment
  634 //
  635 // The addresses of the call instructions needs to be 4-byte aligned to
  636 // ensure that they don&#39;t span a cache line so that they are atomically patchable.
  637 // The actual calls get emitted at different offsets within the node emitters.
  638 // ins_alignment needs to be set to 2 which means that up to 1 nop may get inserted.
  639 
  640 int CallStaticJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  641   return (0 - current_offset) &amp; 2;
  642 }
  643 
  644 int CallDynamicJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  645   return (6 - current_offset) &amp; 2;
  646 }
  647 
  648 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  649   return (12 - current_offset) &amp; 2;
  650 }
  651 
  652 int CallLeafDirectNode::compute_padding(int current_offset) const {
  653   return (12 - current_offset) &amp; 2;
  654 }
  655 
  656 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  657   return (12 - current_offset) &amp; 2;
  658 }
  659 
  660 // Indicate if the safepoint node needs the polling page as an input.
  661 // Since z/Architecture does not have absolute addressing, it does.
  662 bool SafePointNode::needs_polling_address_input() {
  663   return true;
  664 }
  665 
  666 void emit_nop(CodeBuffer &amp;cbuf) {
  667   MacroAssembler _masm(&amp;cbuf);
  668   __ z_nop();
  669 }
  670 
  671 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  672 void emit_break(CodeBuffer &amp;cbuf) {
  673   MacroAssembler _masm(&amp;cbuf);
  674   __ z_illtrap();
  675 }
  676 
  677 #if !defined(PRODUCT)
  678 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  679   os-&gt;print(&quot;TA&quot;);
  680 }
  681 #endif
  682 
  683 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  684   emit_break(cbuf);
  685 }
  686 
  687 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  688   return MachNode::size(ra_);
  689 }
  690 
  691 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  692   // 32bit instructions may become sign extended.
  693   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  694   assert(value &lt; (1L &lt;&lt; 16), &quot;instruction too large&quot;);
  695   *((unsigned short*)(cbuf.insts_end())) = (unsigned short)value;
  696   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned short));
  697 }
  698 
  699 static inline void z_emit32(CodeBuffer &amp;cbuf, long value) {
  700   // 32bit instructions may become sign extended.
  701   assert(value &lt; (1L &lt;&lt; 32), &quot;instruction too large&quot;);
  702   *((unsigned int*)(cbuf.insts_end())) = (unsigned int)value;
  703   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned int));
  704 }
  705 
  706 static inline void z_emit48(CodeBuffer &amp;cbuf, long value) {
  707   // 32bit instructions may become sign extended.
  708   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  709   assert(value &lt; (1L &lt;&lt; 48), &quot;instruction too large&quot;);
  710   value = value&lt;&lt;16;
  711   memcpy(cbuf.insts_end(), (unsigned char*)&amp;value, 6);
  712   cbuf.set_insts_end(cbuf.insts_end() + 6);
  713 }
  714 
  715 static inline unsigned int z_emit_inst(CodeBuffer &amp;cbuf, long value) {
  716   if (value &lt; 0) {
  717     // There obviously has been an unintended sign extension (int-&gt;long). Revert it.
  718     value = (long)((unsigned long)((unsigned int)value));
  719   }
  720 
  721   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  722     z_emit16(cbuf, value);
  723     return 2;
  724   }
  725 
  726   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  727     z_emit32(cbuf, value);
  728     return 4;
  729   }
  730 
  731   // 6-byte instruction, probably unaligned store.
  732   z_emit48(cbuf, value);
  733   return 6;
  734 }
  735 
  736 // Check effective address (at runtime) for required alignment.
  737 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
  738   MacroAssembler _masm(&amp;cbuf);
  739 
  740   __ z_lay(Z_R0, disp, index, base);
  741   __ z_nill(Z_R0, alignment-1);
  742   __ z_brc(Assembler::bcondEqual, +3);
  743   __ z_illtrap();
  744 }
  745 
  746 int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,
  747                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  748   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  749   address old_mark = __ inst_mark();
  750   unsigned int start_off = __ offset();
  751 
  752   if (is_native_call) {
  753     ShouldNotReachHere();
  754   }
  755 
  756   if (rtype == relocInfo::runtime_call_w_cp_type) {
  757     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  758     address call_addr = __ call_c_opt((address)entry_point);
  759     if (call_addr == NULL) {
  760       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  761       return -1;
  762     }
  763   } else {
  764     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  765            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  766     __ relocate(rtype);
  767     // BRASL must be prepended with a nop to identify it in the instruction stream.
  768     __ z_nop();
  769     __ z_brasl(Z_R14, (address)entry_point);
  770   }
  771 
  772   unsigned int ret_off = __ offset();
  773 
  774   return (ret_off - start_off);
  775 }
  776 
  777 static int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {
  778   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  779   address old_mark = __ inst_mark();
  780   unsigned int start_off = __ offset();
  781 
  782   relocInfo::relocType rtype = rspec.type();
  783   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  784          &quot;unexpected rtype&quot;);
  785 
  786   __ relocate(rspec);
  787   __ z_nop();
  788   __ z_brasl(Z_R14, (address)entry_point);
  789 
  790   unsigned int ret_off = __ offset();
  791 
  792   return (ret_off - start_off);
  793 }
  794 
  795 //=============================================================================
  796 
  797 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
  798 int Compile::ConstantTable::calculate_table_base_offset() const {
  799   return 0;  // absolute addressing, no offset
  800 }
  801 
  802 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  803 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  804   ShouldNotReachHere();
  805 }
  806 
  807 // Even with PC-relative TOC addressing, we still need this node.
  808 // Float loads/stores do not support PC-relative addresses.
  809 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  810   MacroAssembler _masm(&amp;cbuf);
  811   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  812   __ load_toc(Rtoc);
  813 }
  814 
  815 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  816   // PCrelative TOC access.
  817   return 6;   // sizeof(LARL)
  818 }
  819 
  820 #if !defined(PRODUCT)
  821 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  822   Register r = as_Register(ra_-&gt;get_encode(this));
  823   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  824 }
  825 #endif
  826 
  827 //=============================================================================
  828 
  829 #if !defined(PRODUCT)
  830 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  831   Compile* C = ra_-&gt;C;
  832   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  833   st-&gt;print(&quot;\t&quot;);
  834   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  835     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  836   }
  837 
  838   if (VerifyThread) {
  839     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  840     st-&gt;print(&quot;\t&quot;);
  841   }
  842 
  843   long framesize = C-&gt;frame_size_in_bytes();
  844   int bangsize   = C-&gt;bang_size_in_bytes();
  845 
  846   // Calls to C2R adapters often do not accept exceptional returns.
  847   // We require that their callers must bang for them. But be
  848   // careful, because some VM calls (such as call site linkage) can
  849   // use several kilobytes of stack. But the stack safety zone should
  850   // account for that. See bugs 4446381, 4468289, 4497237.
  851   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  852     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  853   }
  854   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  855   st-&gt;print(&quot;\t&quot;);
  856 }
  857 #endif
  858 
  859 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  860   Compile* C = ra_-&gt;C;
  861   MacroAssembler _masm(&amp;cbuf);
  862 
  863   __ verify_thread();
  864 
  865   size_t framesize = C-&gt;frame_size_in_bytes();
  866   size_t bangsize  = C-&gt;bang_size_in_bytes();
  867 
  868   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  872 
  873     Label L_skip_barrier;
  874     Register klass = Z_R1_scratch;
  875 
  876     // Notify OOP recorder (don&#39;t need the relocation)
  877     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ load_const_optimized(klass, md.value());
  879     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  880 
  881     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  882     __ z_br(klass);
  883 
  884     __ bind(L_skip_barrier);
  885   }
  886 
  887   // Calls to C2R adapters often do not accept exceptional returns.
  888   // We require that their callers must bang for them. But be
  889   // careful, because some VM calls (such as call site linkage) can
  890   // use several kilobytes of stack. But the stack safety zone should
  891   // account for that. See bugs 4446381, 4468289, 4497237.
  892   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  893     __ generate_stack_overflow_check(bangsize);
  894   }
  895 
  896   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  897   __ save_return_pc();
  898 
  899   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  900   // &#39;out_preserve_stack_slots&#39; declaration.
  901   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  902 
  903   if (C-&gt;has_mach_constant_base_node()) {
  904     // NOTE: We set the table base offset here because users might be
  905     // emitted before MachConstantBaseNode.
  906     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  907     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  908   }
  909 }
  910 
  911 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  912   // Variable size. Determine dynamically.
  913   return MachNode::size(ra_);
  914 }
  915 
  916 int MachPrologNode::reloc() const {
  917   // Return number of relocatable values contained in this instruction.
  918   return 1; // One reloc entry for load_const(toc).
  919 }
  920 
  921 //=============================================================================
  922 
  923 #if !defined(PRODUCT)
  924 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  925   os-&gt;print_cr(&quot;epilog&quot;);
  926   os-&gt;print(&quot;\t&quot;);
  927   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  928     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  929     os-&gt;print(&quot;\t&quot;);
  930   }
  931 }
  932 #endif
  933 
  934 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  935   MacroAssembler _masm(&amp;cbuf);
  936   Compile* C = ra_-&gt;C;
  937   __ verify_thread();
  938 
  939   // If this does safepoint polling, then do it here.
  940   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  941 
  942   // Pop frame, restore return_pc, and all stuff needed by interpreter.
  943   int frame_size_in_bytes = Assembler::align((C-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);
  944   __ pop_frame_restore_retPC(frame_size_in_bytes);
  945 
  946   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  947     __ reserved_stack_check(Z_R14);
  948   }
  949 
  950   // Touch the polling page.
  951   if (need_polling) {
  952     if (SafepointMechanism::uses_thread_local_poll()) {
  953       __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
  954     } else {
  955       AddressLiteral pp(os::get_polling_page());
  956       __ load_const_optimized(Z_R1_scratch, pp);
  957     }
  958     // We need to mark the code position where the load from the safepoint
  959     // polling page was emitted as relocInfo::poll_return_type here.
  960     __ relocate(relocInfo::poll_return_type);
  961     __ load_from_polling_page(Z_R1_scratch);
  962   }
  963 }
  964 
  965 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  966   // Variable size. determine dynamically.
  967   return MachNode::size(ra_);
  968 }
  969 
  970 int MachEpilogNode::reloc() const {
  971   // Return number of relocatable values contained in this instruction.
  972   return 1; // One for load_from_polling_page.
  973 }
  974 
  975 const Pipeline * MachEpilogNode::pipeline() const {
  976   return MachNode::pipeline_class();
  977 }
  978 
  979 int MachEpilogNode::safepoint_offset() const {
  980   assert(do_polling(), &quot;no return for this epilog node&quot;);
  981   return 0;
  982 }
  983 
  984 //=============================================================================
  985 
  986 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  987 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  988 
  989 static enum RC rc_class(OptoReg::Name reg) {
  990   // Return the register class for the given register. The given register
  991   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
  992   // enumeration in adGlobals_s390.hpp.
  993 
  994   if (reg == OptoReg::Bad) {
  995     return rc_bad;
  996   }
  997 
  998   // We have 32 integer register halves, starting at index 0.
  999   if (reg &lt; 32) {
 1000     return rc_int;
 1001   }
 1002 
 1003   // We have 32 floating-point register halves, starting at index 32.
 1004   if (reg &lt; 32+32) {
 1005     return rc_float;
 1006   }
 1007 
 1008   // Between float regs &amp; stack are the flags regs.
 1009   assert(reg &gt;= OptoReg::stack0(), &quot;blow up if spilling flags&quot;);
 1010   return rc_stack;
 1011 }
 1012 
 1013 // Returns size as obtained from z_emit_instr.
 1014 static unsigned int z_ld_st_helper(CodeBuffer *cbuf, const char *op_str, unsigned long opcode,
 1015                                    int reg, int offset, bool do_print, outputStream *os) {
 1016 
 1017   if (cbuf) {
 1018     if (opcode &gt; (1L&lt;&lt;32)) {
 1019       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1020                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1021     } else {
 1022       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1023                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1024     }
 1025   }
 1026 
 1027 #if !defined(PRODUCT)
 1028   if (do_print) {
 1029     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1030   }
 1031 #endif
 1032   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1033 }
 1034 
 1035 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1036   if (cbuf) {
 1037     MacroAssembler _masm(cbuf);
 1038     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1039   }
 1040 
 1041 #if !defined(PRODUCT)
 1042   else if (do_print) {
 1043     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1044   }
 1045 #endif
 1046 
 1047   return 6;
 1048 }
 1049 
 1050 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1051   // Get registers to move.
 1052   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1053   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1054   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1055   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1056 
 1057   enum RC src_hi_rc = rc_class(src_hi);
 1058   enum RC src_lo_rc = rc_class(src_lo);
 1059   enum RC dst_hi_rc = rc_class(dst_hi);
 1060   enum RC dst_lo_rc = rc_class(dst_lo);
 1061 
 1062   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1063   bool is64 = (src_hi_rc != rc_bad);
 1064   assert(!is64 ||
 1065          ((src_lo&amp;1) == 0 &amp;&amp; src_lo+1 == src_hi &amp;&amp; (dst_lo&amp;1) == 0 &amp;&amp; dst_lo+1 == dst_hi),
 1066          &quot;expected aligned-adjacent pairs&quot;);
 1067 
 1068   // Generate spill code!
 1069 
 1070   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi) {
 1071     return 0;            // Self copy, no move.
 1072   }
 1073 
 1074   int  src_offset = ra_-&gt;reg2offset(src_lo);
 1075   int  dst_offset = ra_-&gt;reg2offset(dst_lo);
 1076   bool print = !do_size;
 1077   bool src12 = Immediate::is_uimm12(src_offset);
 1078   bool dst12 = Immediate::is_uimm12(dst_offset);
 1079 
 1080   const char   *mnemo = NULL;
 1081   unsigned long opc = 0;
 1082 
 1083   // Memory-&gt;Memory Spill. Use Z_R0 to hold the value.
 1084   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1085 
 1086     assert(!is64 || (src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack),
 1087            &quot;expected same type of move for high parts&quot;);
 1088 
 1089     if (src12 &amp;&amp; dst12) {
 1090       return z_mvc_helper(cbuf, is64 ? 8 : 4, dst_offset, src_offset, print, os);
 1091     }
 1092 
 1093     int r0 = Z_R0_num;
 1094     if (is64) {
 1095       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1096              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1097     }
 1098 
 1099     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1100            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1101   }
 1102 
 1103   // Check for float-&gt;int copy. Requires a trip through memory.
 1104   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1105     Unimplemented();  // Unsafe, do not remove!
 1106   }
 1107 
 1108   // Check for integer reg-reg copy.
 1109   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1110     if (cbuf) {
 1111       MacroAssembler _masm(cbuf);
 1112       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1113       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1114       __ z_lgr(Rdst, Rsrc);
 1115       return 4;
 1116     }
 1117 #if !defined(PRODUCT)
 1118     // else
 1119     if (print) {
 1120       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1121     }
 1122 #endif
 1123     return 4;
 1124   }
 1125 
 1126   // Check for integer store.
 1127   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1128     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1129            &quot;expected same type of move for high parts&quot;);
 1130 
 1131     if (is64) {
 1132       return z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, src_lo, dst_offset, print, os);
 1133     }
 1134 
 1135     // else
 1136     mnemo = dst12 ? &quot;ST  &quot; : &quot;STY &quot;;
 1137     opc = dst12 ? ST_ZOPC : STY_ZOPC;
 1138 
 1139     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1140   }
 1141 
 1142   // Check for integer load
 1143   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1144   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1145 
 1146     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1147            &quot;expected same type of move for high parts&quot;);
 1148 
 1149     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1150     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1151 
 1152     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1153   }
 1154 
 1155   // Check for float reg-reg copy.
 1156   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1157     if (cbuf) {
 1158       MacroAssembler _masm(cbuf);
 1159       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1160       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1161       __ z_ldr(Rdst, Rsrc);
 1162       return 2;
 1163     }
 1164 #if !defined(PRODUCT)
 1165     // else
 1166     if (print) {
 1167       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1168     }
 1169 #endif
 1170     return 2;
 1171   }
 1172 
 1173   // Check for float store.
 1174   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1175     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1176            &quot;expected same type of move for high parts&quot;);
 1177 
 1178     if (is64) {
 1179       mnemo = dst12 ? &quot;STD  &quot; : &quot;STDY &quot;;
 1180       opc = dst12 ? STD_ZOPC : STDY_ZOPC;
 1181       return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1182     }
 1183     // else
 1184 
 1185     mnemo = dst12 ? &quot;STE  &quot; : &quot;STEY &quot;;
 1186     opc = dst12 ? STE_ZOPC : STEY_ZOPC;
 1187     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1188   }
 1189 
 1190   // Check for float load.
 1191   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1192     assert(!is64 || (dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack),
 1193            &quot;expected same type of move for high parts&quot;);
 1194 
 1195     if (is64) {
 1196       mnemo = src12 ? &quot;LD   &quot; : &quot;LDY  &quot;;
 1197       opc = src12 ? LD_ZOPC : LDY_ZOPC;
 1198       return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1199     }
 1200     // else
 1201 
 1202     mnemo = src12 ? &quot;LE   &quot; : &quot;LEY  &quot;;
 1203     opc = src12 ? LE_ZOPC : LEY_ZOPC;
 1204     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1205   }
 1206 
 1207   // --------------------------------------------------------------------
 1208   // Check for hi bits still needing moving. Only happens for misaligned
 1209   // arguments to native calls.
 1210   if (src_hi == dst_hi) {
 1211     return 0;               // Self copy, no move.
 1212   }
 1213 
 1214   assert(is64 &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1215   Unimplemented();  // Unsafe, do not remove!
 1216 
 1217   return 0; // never reached, but make the compiler shut up!
 1218 }
 1219 
 1220 #if !defined(PRODUCT)
 1221 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1222   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1223     implementation(NULL, ra_, false, os);
 1224   } else {
 1225     if (req() == 2 &amp;&amp; in(1)) {
 1226       os-&gt;print(&quot;N%d = N%d\n&quot;, _idx, in(1)-&gt;_idx);
 1227     } else {
 1228       const char *c = &quot;(&quot;;
 1229       os-&gt;print(&quot;N%d = &quot;, _idx);
 1230       for (uint i = 1; i &lt; req(); ++i) {
 1231         os-&gt;print(&quot;%sN%d&quot;, c, in(i)-&gt;_idx);
 1232         c = &quot;, &quot;;
 1233       }
 1234       os-&gt;print(&quot;)&quot;);
 1235     }
 1236   }
 1237 }
 1238 #endif
 1239 
 1240 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1241   implementation(&amp;cbuf, ra_, false, NULL);
 1242 }
 1243 
 1244 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1245   return implementation(NULL, ra_, true, NULL);
 1246 }
 1247 
 1248 //=============================================================================
 1249 
 1250 #if !defined(PRODUCT)
 1251 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1252   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1253 }
 1254 #endif
 1255 
 1256 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
 1257   MacroAssembler _masm(&amp;cbuf);
 1258 
 1259   int rem_space = 0;
 1260   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {
 1261     rem_space = cbuf.insts()-&gt;remaining();
 1262     if (rem_space &lt;= _count*2 + 8) {
 1263       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1264     }
 1265   }
 1266 
 1267   for (int i = 0; i &lt; _count; i++) {
 1268     __ z_nop();
 1269   }
 1270 
 1271   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {
 1272     if (rem_space &lt;= _count*2 + 8) {
 1273       int rem_space2 = cbuf.insts()-&gt;remaining();
 1274       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1275     }
 1276   }
 1277 }
 1278 
 1279 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1280    return 2 * _count;
 1281 }
 1282 
 1283 #if !defined(PRODUCT)
 1284 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1285   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1286   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1287     int reg = ra_-&gt;get_reg_first(this);
 1288     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1289   } else {
 1290     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1291   }
 1292 }
 1293 #endif
 1294 
 1295 // Take care of the size function, if you make changes here!
 1296 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1297   MacroAssembler _masm(&amp;cbuf);
 1298 
 1299   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1300   int reg = ra_-&gt;get_encode(this);
 1301   __ z_lay(as_Register(reg), offset, Z_SP);
 1302 }
 1303 
 1304 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1305   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1306   return 6;
 1307 }
 1308 
 1309  %} // end source section
 1310 
 1311 //----------SOURCE BLOCK-------------------------------------------------------
 1312 // This is a block of C++ code which provides values, functions, and
 1313 // definitions necessary in the rest of the architecture description
 1314 
 1315 source_hpp %{
 1316 
 1317 // Header information of the source block.
 1318 // Method declarations/definitions which are used outside
 1319 // the ad-scope can conveniently be defined here.
 1320 //
 1321 // To keep related declarations/definitions/uses close together,
 1322 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 1323 
 1324 //--------------------------------------------------------------
 1325 // Used for optimization in Compile::Shorten_branches
 1326 //--------------------------------------------------------------
 1327 
 1328 class CallStubImpl {
 1329  public:
 1330 
 1331   // call trampolines
 1332   // Size of call trampoline stub. For add&#39;l comments, see size_java_to_interp().
 1333   static uint size_call_trampoline() {
 1334     return 0; // no call trampolines on this platform
 1335   }
 1336 
 1337   // call trampolines
 1338   // Number of relocations needed by a call trampoline stub.
 1339   static uint reloc_call_trampoline() {
 1340     return 0; // No call trampolines on this platform.
 1341   }
 1342 };
 1343 
 1344 %} // end source_hpp section
 1345 
 1346 source %{
 1347 
 1348 #if !defined(PRODUCT)
 1349 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1350   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1351   os-&gt;print_cr(&quot;\tTA&quot;);
 1352   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1353   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1354   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1355   os-&gt;print_cr(&quot;\t...&quot;);
 1356   os-&gt;print_cr(&quot;\tTA&quot;);
 1357   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1358   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1359 }
 1360 #endif
 1361 
 1362 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1363   MacroAssembler _masm(&amp;cbuf);
 1364   const int ic_miss_offset = 2;
 1365 
 1366   // Inline_cache contains a klass.
 1367   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1368   // ARG1 is the receiver oop.
 1369   Register R2_receiver = Z_ARG1;
 1370   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1371   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1372   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1373 
 1374   // Null check of receiver.
 1375   // This is the null check of the receiver that actually should be
 1376   // done in the caller. It&#39;s here because in case of implicit null
 1377   // checks we get it for free.
 1378   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1379          &quot;second word in oop should not require explicit null check.&quot;);
 1380   if (!ImplicitNullChecks) {
 1381     Label valid;
 1382     if (VM_Version::has_CompareBranch()) {
 1383       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
 1384     } else {
 1385       __ z_ltgr(R2_receiver, R2_receiver);
 1386       __ z_bre(valid);
 1387     }
 1388     // The ic_miss_stub will handle the null pointer exception.
 1389     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1390     __ z_br(R1_ic_miss_stub_addr);
 1391     __ bind(valid);
 1392   }
 1393 
 1394   // Check whether this method is the proper implementation for the class of
 1395   // the receiver (ic miss check).
 1396   {
 1397     Label valid;
 1398     // Compare cached class against klass from receiver.
 1399     // This also does an implicit null check!
 1400     __ compare_klass_ptr(ic_klass, klass_offset, R2_receiver, false);
 1401     __ z_bre(valid);
 1402     // The inline cache points to the wrong method. Call the
 1403     // ic_miss_stub to find the proper method.
 1404     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1405     __ z_br(R1_ic_miss_stub_addr);
 1406     __ bind(valid);
 1407   }
 1408 }
 1409 
 1410 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1411   // Determine size dynamically.
 1412   return MachNode::size(ra_);
 1413 }
 1414 
 1415 //=============================================================================
 1416 
 1417 %} // interrupt source section
 1418 
 1419 source_hpp %{ // Header information of the source block.
 1420 
 1421 class HandlerImpl {
 1422  public:
 1423 
 1424   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1425   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1426 
 1427   static uint size_exception_handler() {
 1428     return NativeJump::max_instruction_size();
 1429   }
 1430 
 1431   static uint size_deopt_handler() {
 1432     return NativeCall::max_instruction_size();
 1433   }
 1434 };
 1435 
 1436 %} // end source_hpp section
 1437 
 1438 source %{
 1439 
 1440 // This exception handler code snippet is placed after the method&#39;s
 1441 // code. It is the return point if an exception occurred. it jumps to
 1442 // the exception blob.
 1443 //
 1444 // If the method gets deoptimized, the method and this code snippet
 1445 // get patched.
 1446 //
 1447 // 1) Trampoline code gets patched into the end of this exception
 1448 //   handler. the trampoline code jumps to the deoptimization blob.
 1449 //
 1450 // 2) The return address in the method&#39;s code will get patched such
 1451 //   that it jumps to the trampoline.
 1452 //
 1453 // 3) The handler will get patched such that it does not jump to the
 1454 //   exception blob, but to an entry in the deoptimization blob being
 1455 //   aware of the exception.
 1456 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1457   Register temp_reg = Z_R1;
 1458   MacroAssembler _masm(&amp;cbuf);
 1459 
 1460   address base = __ start_a_stub(size_exception_handler());
 1461   if (base == NULL) {
 1462     return 0;          // CodeBuffer::expand failed
 1463   }
 1464 
 1465   int offset = __ offset();
 1466   // Use unconditional pc-relative jump with 32-bit range here.
 1467   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1468   __ z_br(temp_reg);
 1469 
 1470   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1471 
 1472   __ end_a_stub();
 1473 
 1474   return offset;
 1475 }
 1476 
 1477 // Emit deopt handler code.
 1478 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1479   MacroAssembler _masm(&amp;cbuf);
 1480   address        base = __ start_a_stub(size_deopt_handler());
 1481 
 1482   if (base == NULL) {
 1483     return 0;  // CodeBuffer::expand failed
 1484   }
 1485 
 1486   int offset = __ offset();
 1487 
 1488   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1489   // we do not use load_const_opt here.
 1490   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1491   __ call(Z_R1);
 1492   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1493 
 1494   __ end_a_stub();
 1495   return offset;
 1496 }
 1497 
 1498 //=============================================================================
 1499 
 1500 
 1501 // Given a register encoding, produce an Integer Register object.
 1502 static Register reg_to_register_object(int register_encoding) {
 1503   assert(Z_R12-&gt;encoding() == Z_R12_enc, &quot;wrong coding&quot;);
 1504   return as_Register(register_encoding);
 1505 }
 1506 
 1507 const bool Matcher::match_rule_supported(int opcode) {
 1508   if (!has_match_rule(opcode)) return false;
 1509 
 1510   switch (opcode) {
 1511     case Op_CountLeadingZerosI:
 1512     case Op_CountLeadingZerosL:
 1513     case Op_CountTrailingZerosI:
 1514     case Op_CountTrailingZerosL:
 1515       // Implementation requires FLOGR instruction, which is available since z9.
 1516       return true;
 1517 
 1518     case Op_ReverseBytesI:
 1519     case Op_ReverseBytesL:
 1520       return UseByteReverseInstruction;
 1521 
 1522     // PopCount supported by H/W from z/Architecture G5 (z196) on.
 1523     case Op_PopCountI:
 1524     case Op_PopCountL:
 1525       return UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount();
 1526 
 1527     case Op_StrComp:
 1528       return SpecialStringCompareTo;
 1529     case Op_StrEquals:
 1530       return SpecialStringEquals;
 1531     case Op_StrIndexOf:
 1532     case Op_StrIndexOfChar:
 1533       return SpecialStringIndexOf;
 1534 
 1535     case Op_GetAndAddI:
 1536     case Op_GetAndAddL:
 1537       return true;
 1538       // return VM_Version::has_AtomicMemWithImmALUOps();
 1539     case Op_GetAndSetI:
 1540     case Op_GetAndSetL:
 1541     case Op_GetAndSetP:
 1542     case Op_GetAndSetN:
 1543       return true;  // General CAS implementation, always available.
 1544 
 1545     default:
 1546       return true;  // Per default match rules are supported.
 1547                     // BUT: make sure match rule is not disabled by a false predicate!
 1548   }
 1549 
 1550   return true;  // Per default match rules are supported.
 1551                 // BUT: make sure match rule is not disabled by a false predicate!
 1552 }
 1553 
 1554 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1555   // TODO
 1556   // Identify extra cases that we might want to provide match rules for
 1557   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
 1558   bool ret_value = match_rule_supported(opcode);
 1559   // Add rules here.
 1560 
 1561   return ret_value;  // Per default match rules are supported.
 1562 }
 1563 
 1564 int Matcher::regnum_to_fpu_offset(int regnum) {
 1565   ShouldNotReachHere();
 1566   return regnum - 32; // The FP registers are in the second chunk.
 1567 }
 1568 
 1569 const bool Matcher::has_predicated_vectors(void) {
 1570   return false;
 1571 }
 1572 
 1573 const int Matcher::float_pressure(int default_pressure_threshold) {
 1574   return default_pressure_threshold;
 1575 }
 1576 
 1577 const bool Matcher::convL2FSupported(void) {
 1578   return true; // False means that conversion is done by runtime call.
 1579 }
 1580 
 1581 //----------SUPERWORD HELPERS----------------------------------------
 1582 
 1583 // Vector width in bytes.
 1584 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1585   assert(MaxVectorSize == 8, &quot;&quot;);
 1586   return 8;
 1587 }
 1588 
 1589 // Vector ideal reg.
 1590 const uint Matcher::vector_ideal_reg(int size) {
 1591   assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 1592   return Op_RegL;
 1593 }
 1594 
 1595 // Limits on vector size (number of elements) loaded into vector.
 1596 const int Matcher::max_vector_size(const BasicType bt) {
 1597   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1598   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1599 }
 1600 
 1601 const int Matcher::min_vector_size(const BasicType bt) {
 1602   return max_vector_size(bt); // Same as max.
 1603 }
 1604 
 1605 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1606   fatal(&quot;vector shift is not supported&quot;);
 1607   return Node::NotAMachineReg;
 1608 }
 1609 
 1610 // z/Architecture does support misaligned store/load at minimal extra cost.
 1611 const bool Matcher::misaligned_vectors_ok() {
 1612   return true;
 1613 }
 1614 
 1615 // Not yet ported to z/Architecture.
 1616 const bool Matcher::pass_original_key_for_aes() {
 1617   return false;
 1618 }
 1619 
 1620 // RETURNS: whether this branch offset is short enough that a short
 1621 // branch can be used.
 1622 //
 1623 // If the platform does not provide any short branch variants, then
 1624 // this method should return `false&#39; for offset 0.
 1625 //
 1626 // `Compile::Fill_buffer&#39; will decide on basis of this information
 1627 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 1628 //
 1629 // And `Compile::Shorten_branches&#39; will decide on basis of this
 1630 // information whether to replace particular branch sites by short
 1631 // ones.
 1632 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1633   // On zarch short branches use a 16 bit signed immediate that
 1634   // is the pc-relative offset in halfword (= 2 bytes) units.
 1635   return Assembler::is_within_range_of_RelAddr16((address)((long)offset), (address)0);
 1636 }
 1637 
 1638 const bool Matcher::isSimpleConstant64(jlong value) {
 1639   // Probably always true, even if a temp register is required.
 1640   return true;
 1641 }
 1642 
 1643 // Should correspond to setting above
 1644 const bool Matcher::init_array_count_is_in_bytes = false;
 1645 
 1646 // Suppress CMOVL. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1647 const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }
 1648 
 1649 // Suppress CMOVF. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1650 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1651 
 1652 // Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?
 1653 const bool Matcher::require_postalloc_expand = false;
 1654 
 1655 // Do we need to mask the count passed to shift instructions or does
 1656 // the cpu only look at the lower 5/6 bits anyway?
 1657 // 32bit shifts mask in emitter, 64bit shifts need no mask.
 1658 // Constant shift counts are handled in Ideal phase.
 1659 const bool Matcher::need_masked_shift_count = false;
 1660 
 1661 // No support for generic vector operands.
 1662 const bool Matcher::supports_generic_vector_operands  = false;
 1663 
 1664 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1665   ShouldNotReachHere(); // generic vector operands not supported
 1666   return NULL;
 1667 }
 1668 
 1669 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1670   ShouldNotReachHere();  // generic vector operands not supported
 1671   return false;
 1672 }
 1673 
 1674 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1675   ShouldNotReachHere();  // generic vector operands not supported
 1676   return false;
 1677 }
 1678 
 1679 // Set this as clone_shift_expressions.
 1680 bool Matcher::narrow_oop_use_complex_address() {
 1681   if (CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0) return true;
 1682   return false;
 1683 }
 1684 
 1685 bool Matcher::narrow_klass_use_complex_address() {
 1686   NOT_LP64(ShouldNotCallThis());
 1687   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1688   // TODO HS25: z port if (MatchDecodeNodes) return true;
 1689   return false;
 1690 }
 1691 
 1692 bool Matcher::const_oop_prefer_decode() {
 1693   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1694   return CompressedOops::base() == NULL;
 1695 }
 1696 
 1697 bool Matcher::const_klass_prefer_decode() {
 1698   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1699   return CompressedKlassPointers::base() == NULL;
 1700 }
 1701 
 1702 // Is it better to copy float constants, or load them directly from memory?
 1703 // Most RISCs will have to materialize an address into a
 1704 // register first, so they would do better to copy the constant from stack.
 1705 const bool Matcher::rematerialize_float_constants = false;
 1706 
 1707 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1708 // needed. Else we split the double into 2 integer pieces and move it
 1709 // piece-by-piece. Only happens when passing doubles into C code as the
 1710 // Java calling convention forces doubles to be aligned.
 1711 const bool Matcher::misaligned_doubles_ok = true;
 1712 
 1713 // Advertise here if the CPU requires explicit rounding operations
 1714 // to implement the UseStrictFP mode.
 1715 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1716 
 1717 // Do floats take an entire double register or just half?
 1718 //
 1719 // A float in resides in a zarch double register. When storing it by
 1720 // z_std, it cannot be restored in C-code by reloading it as a double
 1721 // and casting it into a float afterwards.
 1722 bool Matcher::float_in_double() { return false; }
 1723 
 1724 // Do ints take an entire long register or just half?
 1725 // The relevant question is how the int is callee-saved:
 1726 // the whole long is written but de-opt&#39;ing will have to extract
 1727 // the relevant 32 bits.
 1728 const bool Matcher::int_in_long = true;
 1729 
 1730 // Constants for c2c and c calling conventions.
 1731 
 1732 const MachRegisterNumbers z_iarg_reg[5] = {
 1733   Z_R2_num, Z_R3_num, Z_R4_num, Z_R5_num, Z_R6_num
 1734 };
 1735 
 1736 const MachRegisterNumbers z_farg_reg[4] = {
 1737   Z_F0_num, Z_F2_num, Z_F4_num, Z_F6_num
 1738 };
 1739 
 1740 const int z_num_iarg_registers = sizeof(z_iarg_reg) / sizeof(z_iarg_reg[0]);
 1741 
 1742 const int z_num_farg_registers = sizeof(z_farg_reg) / sizeof(z_farg_reg[0]);
 1743 
 1744 // Return whether or not this register is ever used as an argument. This
 1745 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1746 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1747 // arguments in those registers not be available to the callee.
 1748 bool Matcher::can_be_java_arg(int reg) {
 1749   // We return true for all registers contained in z_iarg_reg[] and
 1750   // z_farg_reg[] and their virtual halves.
 1751   // We must include the virtual halves in order to get STDs and LDs
 1752   // instead of STWs and LWs in the trampoline stubs.
 1753 
 1754   if (reg == Z_R2_num || reg == Z_R2_H_num ||
 1755       reg == Z_R3_num || reg == Z_R3_H_num ||
 1756       reg == Z_R4_num || reg == Z_R4_H_num ||
 1757       reg == Z_R5_num || reg == Z_R5_H_num ||
 1758       reg == Z_R6_num || reg == Z_R6_H_num) {
 1759     return true;
 1760   }
 1761 
 1762   if (reg == Z_F0_num || reg == Z_F0_H_num ||
 1763       reg == Z_F2_num || reg == Z_F2_H_num ||
 1764       reg == Z_F4_num || reg == Z_F4_H_num ||
 1765       reg == Z_F6_num || reg == Z_F6_H_num) {
 1766     return true;
 1767   }
 1768 
 1769   return false;
 1770 }
 1771 
 1772 bool Matcher::is_spillable_arg(int reg) {
 1773   return can_be_java_arg(reg);
 1774 }
 1775 
 1776 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 1777   return false;
 1778 }
 1779 
 1780 // Register for DIVI projection of divmodI
 1781 RegMask Matcher::divI_proj_mask() {
 1782   return _Z_RARG4_INT_REG_mask;
 1783 }
 1784 
 1785 // Register for MODI projection of divmodI
 1786 RegMask Matcher::modI_proj_mask() {
 1787   return _Z_RARG3_INT_REG_mask;
 1788 }
 1789 
 1790 // Register for DIVL projection of divmodL
 1791 RegMask Matcher::divL_proj_mask() {
 1792   return _Z_RARG4_LONG_REG_mask;
 1793 }
 1794 
 1795 // Register for MODL projection of divmodL
 1796 RegMask Matcher::modL_proj_mask() {
 1797   return _Z_RARG3_LONG_REG_mask;
 1798 }
 1799 
 1800 // Copied from sparc.
 1801 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1802   return RegMask();
 1803 }
 1804 
 1805 const bool Matcher::convi2l_type_required = true;
 1806 
 1807 // Should the Matcher clone shifts on addressing modes, expecting them
 1808 // to be subsumed into complex addressing expressions or compute them
 1809 // into registers?
 1810 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1811   return clone_base_plus_offset_address(m, mstack, address_visited);
 1812 }
 1813 
 1814 void Compile::reshape_address(AddPNode* addp) {
 1815 }
 1816 
 1817 %} // source
 1818 
 1819 //----------ENCODING BLOCK-----------------------------------------------------
 1820 // This block specifies the encoding classes used by the compiler to output
 1821 // byte streams. Encoding classes are parameterized macros used by
 1822 // Machine Instruction Nodes in order to generate the bit encoding of the
 1823 // instruction. Operands specify their base encoding interface with the
 1824 // interface keyword. There are currently supported four interfaces,
 1825 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1826 // operand to generate a function which returns its register number when
 1827 // queried. CONST_INTER causes an operand to generate a function which
 1828 // returns the value of the constant when queried. MEMORY_INTER causes an
 1829 // operand to generate four functions which return the Base Register, the
 1830 // Index Register, the Scale Value, and the Offset Value of the operand when
 1831 // queried. COND_INTER causes an operand to generate six functions which
 1832 // return the encoding code (ie - encoding bits for the instruction)
 1833 // associated with each basic boolean condition for a conditional instruction.
 1834 //
 1835 // Instructions specify two basic values for encoding. Again, a function
 1836 // is available to check if the constant displacement is an oop. They use the
 1837 // ins_encode keyword to specify their encoding classes (which must be
 1838 // a sequence of enc_class names, and their parameters, specified in
 1839 // the encoding block), and they use the
 1840 // opcode keyword to specify, in order, their primary, secondary, and
 1841 // tertiary opcode. Only the opcode sections which a particular instruction
 1842 // needs for encoding need to be specified.
 1843 encode %{
 1844   enc_class enc_unimplemented %{
 1845     MacroAssembler _masm(&amp;cbuf);
 1846     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1847   %}
 1848 
 1849   enc_class enc_untested %{
 1850 #ifdef ASSERT
 1851     MacroAssembler _masm(&amp;cbuf);
 1852     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1853 #endif
 1854   %}
 1855 
 1856   enc_class z_rrform(iRegI dst, iRegI src) %{
 1857     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1858     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1859     z_emit16(cbuf, $primary |
 1860              Assembler::reg($dst$$reg,8,16) |
 1861              Assembler::reg($src$$reg,12,16));
 1862   %}
 1863 
 1864   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1865     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1866     z_emit32(cbuf, $primary |
 1867              Assembler::reg($dst1$$reg,24,32) |
 1868              Assembler::reg($src2$$reg,28,32));
 1869   %}
 1870 
 1871   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
 1872     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1873     z_emit32(cbuf, $primary |
 1874              Assembler::reg($dst1$$reg,24,32) |
 1875              Assembler::reg($src2$$reg,28,32) |
 1876              Assembler::reg($src3$$reg,16,32));
 1877   %}
 1878 
 1879   enc_class z_riform_signed(iRegI dst, immI16 src) %{
 1880     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1881     z_emit32(cbuf, $primary |
 1882              Assembler::reg($dst$$reg,8,32) |
 1883              Assembler::simm16($src$$constant,16,32));
 1884   %}
 1885 
 1886   enc_class z_riform_unsigned(iRegI dst, uimmI16 src) %{
 1887     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1888     z_emit32(cbuf, $primary |
 1889              Assembler::reg($dst$$reg,8,32) |
 1890              Assembler::uimm16($src$$constant,16,32));
 1891   %}
 1892 
 1893   enc_class z_rieform_d(iRegI dst1, iRegI src3, immI src2) %{
 1894     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1895     z_emit48(cbuf, $primary |
 1896              Assembler::reg($dst1$$reg,8,48) |
 1897              Assembler::reg($src3$$reg,12,48) |
 1898              Assembler::simm16($src2$$constant,16,48));
 1899   %}
 1900 
 1901   enc_class z_rilform_signed(iRegI dst, immL32 src) %{
 1902     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1903     z_emit48(cbuf, $primary |
 1904              Assembler::reg($dst$$reg,8,48) |
 1905              Assembler::simm32($src$$constant,16,48));
 1906   %}
 1907 
 1908   enc_class z_rilform_unsigned(iRegI dst, uimmL32 src) %{
 1909     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1910     z_emit48(cbuf, $primary |
 1911              Assembler::reg($dst$$reg,8,48) |
 1912              Assembler::uimm32($src$$constant,16,48));
 1913   %}
 1914 
 1915   enc_class z_rsyform_const(iRegI dst, iRegI src1, immI src2) %{
 1916     z_emit48(cbuf, $primary |
 1917              Assembler::reg($dst$$reg,8,48) |
 1918              Assembler::reg($src1$$reg,12,48) |
 1919              Assembler::simm20($src2$$constant));
 1920   %}
 1921 
 1922   enc_class z_rsyform_reg_reg(iRegI dst, iRegI src, iRegI shft) %{
 1923     z_emit48(cbuf, $primary |
 1924              Assembler::reg($dst$$reg,8,48) |
 1925              Assembler::reg($src$$reg,12,48) |
 1926              Assembler::reg($shft$$reg,16,48) |
 1927              Assembler::simm20(0));
 1928   %}
 1929 
 1930   enc_class z_rxform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1931     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1932     z_emit32(cbuf, $primary |
 1933              Assembler::reg($dst$$reg,8,32) |
 1934              Assembler::reg($src1$$reg,12,32) |
 1935              Assembler::reg($src2$$reg,16,32) |
 1936              Assembler::uimm12($con$$constant,20,32));
 1937   %}
 1938 
 1939   enc_class z_rxform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1940     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1941     z_emit32(cbuf, $primary |
 1942              Assembler::reg($dst$$reg,8,32) |
 1943              Assembler::reg($src$$reg,16,32) |
 1944              Assembler::uimm12($con$$constant,20,32));
 1945   %}
 1946 
 1947   enc_class z_rxyform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1948     z_emit48(cbuf, $primary |
 1949              Assembler::reg($dst$$reg,8,48) |
 1950              Assembler::reg($src1$$reg,12,48) |
 1951              Assembler::reg($src2$$reg,16,48) |
 1952              Assembler::simm20($con$$constant));
 1953   %}
 1954 
 1955   enc_class z_rxyform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1956     z_emit48(cbuf, $primary |
 1957              Assembler::reg($dst$$reg,8,48) |
 1958              Assembler::reg($src$$reg,16,48) |
 1959              Assembler::simm20($con$$constant));
 1960   %}
 1961 
 1962   // Direct memory arithmetic.
 1963   enc_class z_siyform(memoryRSY mem, immI8 src) %{
 1964     int      disp = $mem$$disp;
 1965     Register base = reg_to_register_object($mem$$base);
 1966     int      con  = $src$$constant;
 1967 
 1968     assert(VM_Version::has_MemWithImmALUOps(), &quot;unsupported CPU&quot;);
 1969     z_emit_inst(cbuf, $primary |
 1970                 Assembler::regz(base,16,48) |
 1971                 Assembler::simm20(disp) |
 1972                 Assembler::simm8(con,8,48));
 1973   %}
 1974 
 1975   enc_class z_silform(memoryRS mem, immI16 src) %{
 1976     z_emit_inst(cbuf, $primary |
 1977                 Assembler::regz(reg_to_register_object($mem$$base),16,48) |
 1978                 Assembler::uimm12($mem$$disp,20,48) |
 1979                 Assembler::simm16($src$$constant,32,48));
 1980   %}
 1981 
 1982   // Encoder for FP ALU reg/mem instructions (support only short displacements).
 1983   enc_class z_form_rt_memFP(RegF dst, memoryRX mem) %{
 1984     Register Ridx = $mem$$index$$Register;
 1985     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 1986     if ($primary &gt; (1L &lt;&lt; 32)) {
 1987       z_emit_inst(cbuf, $primary |
 1988                   Assembler::reg($dst$$reg, 8, 48) |
 1989                   Assembler::uimm12($mem$$disp, 20, 48) |
 1990                   Assembler::reg(Ridx, 12, 48) |
 1991                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 1992     } else {
 1993       z_emit_inst(cbuf, $primary |
 1994                   Assembler::reg($dst$$reg, 8, 32) |
 1995                   Assembler::uimm12($mem$$disp, 20, 32) |
 1996                   Assembler::reg(Ridx, 12, 32) |
 1997                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 1998     }
 1999   %}
 2000 
 2001   enc_class z_form_rt_mem(iRegI dst, memory mem) %{
 2002     Register Ridx = $mem$$index$$Register;
 2003     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2004     if ($primary &gt; (1L&lt;&lt;32)) {
 2005       z_emit_inst(cbuf, $primary |
 2006                   Assembler::reg($dst$$reg, 8, 48) |
 2007                   Assembler::simm20($mem$$disp) |
 2008                   Assembler::reg(Ridx, 12, 48) |
 2009                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2010     } else {
 2011       z_emit_inst(cbuf, $primary |
 2012                   Assembler::reg($dst$$reg, 8, 32) |
 2013                   Assembler::uimm12($mem$$disp, 20, 32) |
 2014                   Assembler::reg(Ridx, 12, 32) |
 2015                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 2016     }
 2017   %}
 2018 
 2019   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2020     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2021     Register Ridx = $mem$$index$$Register;
 2022     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2023 
 2024     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2025       z_emit_inst(cbuf, $secondary |
 2026                   Assembler::reg($dst$$reg, 8, isize) |
 2027                   Assembler::uimm12($mem$$disp, 20, isize) |
 2028                   Assembler::reg(Ridx, 12, isize) |
 2029                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2030     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2031       z_emit_inst(cbuf, $primary |
 2032                   Assembler::reg($dst$$reg, 8, 48) |
 2033                   Assembler::simm20($mem$$disp) |
 2034                   Assembler::reg(Ridx, 12, 48) |
 2035                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2036     } else {
 2037         MacroAssembler _masm(&amp;cbuf);
 2038         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2039         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2040         z_emit_inst(cbuf, $secondary |
 2041                     Assembler::reg($dst$$reg, 8, isize) |
 2042                     Assembler::uimm12(0, 20, isize) |
 2043                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2044                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2045     }
 2046   %}
 2047 
 2048   enc_class z_enc_brul(Label lbl) %{
 2049     MacroAssembler _masm(&amp;cbuf);
 2050     Label* p = $lbl$$label;
 2051 
 2052     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2053     // determine the size of the encoded instruction.
 2054     // Use a bound dummy label in that case.
 2055     Label d;
 2056     __ bind(d);
 2057     Label&amp; l = (NULL == p) ? d : *(p);
 2058     __ z_brul(l);
 2059   %}
 2060 
 2061   enc_class z_enc_bru(Label lbl) %{
 2062     MacroAssembler _masm(&amp;cbuf);
 2063     Label* p = $lbl$$label;
 2064 
 2065     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2066     // determine the size of the encoded instruction.
 2067     // Use a bound dummy label in that case.
 2068     Label d;
 2069     __ bind(d);
 2070     Label&amp; l = (NULL == p) ? d : *(p);
 2071     __ z_bru(l);
 2072   %}
 2073 
 2074   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
 2075     MacroAssembler _masm(&amp;cbuf);
 2076     Label* p = $lbl$$label;
 2077 
 2078     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2079     // determine the size of the encoded instruction.
 2080     // Use a bound dummy label in that case.
 2081     Label d;
 2082     __ bind(d);
 2083     Label&amp; l = (NULL == p) ? d : *(p);
 2084     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2085   %}
 2086 
 2087   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
 2088     MacroAssembler _masm(&amp;cbuf);
 2089     Label* p = $lbl$$label;
 2090 
 2091     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2092     // determine the size of the encoded instruction.
 2093     // Use a bound dummy label in that case.
 2094     Label d;
 2095     __ bind(d);
 2096     Label&amp; l = (NULL == p) ? d : *(p);
 2097     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2098   %}
 2099 
 2100   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2101     MacroAssembler _masm(&amp;cbuf);
 2102     Label* p = $lbl$$label;
 2103 
 2104     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2105     // determine the size of the encoded instruction.
 2106     // Use a bound dummy label in that case.
 2107     Label d;
 2108     __ bind(d);
 2109     Label&amp; l = (NULL == p) ? d : *(p);
 2110     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2111     unsigned long instr = $primary;
 2112     if (instr == CRJ_ZOPC) {
 2113       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2114     } else if (instr == CLRJ_ZOPC) {
 2115       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2116     } else if (instr == CGRJ_ZOPC) {
 2117       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2118     } else {
 2119       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2120       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2121     }
 2122   %}
 2123 
 2124   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2125     MacroAssembler _masm(&amp;cbuf);
 2126     Label* p = $lbl$$label;
 2127 
 2128     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2129     // determine the size of the encoded instruction.
 2130     // Use a bound dummy label in that case.
 2131     Label d;
 2132     __ bind(d);
 2133     Label&amp; l = (NULL == p) ? d : *(p);
 2134 
 2135     unsigned long instr = $primary;
 2136     if (instr == CR_ZOPC) {
 2137       __ z_cr($src1$$Register, $src2$$Register);
 2138     } else if (instr == CLR_ZOPC) {
 2139       __ z_clr($src1$$Register, $src2$$Register);
 2140     } else if (instr == CGR_ZOPC) {
 2141       __ z_cgr($src1$$Register, $src2$$Register);
 2142     } else {
 2143       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2144       __ z_clgr($src1$$Register, $src2$$Register);
 2145     }
 2146 
 2147     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2148   %}
 2149 
 2150   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2151     MacroAssembler _masm(&amp;cbuf);
 2152     Label* p = $lbl$$label;
 2153 
 2154     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2155     // determine the size of the encoded instruction.
 2156     // Use a bound dummy label in that case.
 2157     Label d;
 2158     __ bind(d);
 2159     Label&amp; l = (NULL == p) ? d : *(p);
 2160 
 2161     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2162     unsigned long instr = $primary;
 2163     if (instr == CIJ_ZOPC) {
 2164       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2165     } else if (instr == CLIJ_ZOPC) {
 2166       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2167     } else if (instr == CGIJ_ZOPC) {
 2168       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2169     } else {
 2170       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2171       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2172     }
 2173   %}
 2174 
 2175   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2176     MacroAssembler _masm(&amp;cbuf);
 2177     Label* p = $lbl$$label;
 2178 
 2179     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2180     // determine the size of the encoded instruction.
 2181     // Use a bound dummy label in that case.
 2182     Label d;
 2183     __ bind(d);
 2184     Label&amp; l = (NULL == p) ? d : *(p);
 2185 
 2186     unsigned long instr = $primary;
 2187     if (instr == CHI_ZOPC) {
 2188       __ z_chi($src1$$Register, $src2$$constant);
 2189     } else if (instr == CLFI_ZOPC) {
 2190       __ z_clfi($src1$$Register, $src2$$constant);
 2191     } else if (instr == CGHI_ZOPC) {
 2192       __ z_cghi($src1$$Register, $src2$$constant);
 2193     } else {
 2194       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2195       __ z_clgfi($src1$$Register, $src2$$constant);
 2196     }
 2197 
 2198     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2199   %}
 2200 
 2201   // Call from Java to runtime.
 2202   enc_class z_enc_java_to_runtime_call(method meth) %{
 2203     MacroAssembler _masm(&amp;cbuf);
 2204 
 2205     // Save return pc before call to the place where we need it, since
 2206     // callee doesn&#39;t.
 2207     unsigned int start_off = __ offset();
 2208     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2209     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2210     __ get_PC(Z_R14, size_of_code);
 2211     __ save_return_pc();
 2212     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2213 
 2214     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2215     address call_addr = __ call_c_opt((address)$meth$$method);
 2216     if (call_addr == NULL) {
 2217       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2218       return;
 2219     }
 2220 
 2221 #ifdef ASSERT
 2222     // Plausibility check for size_of_code assumptions.
 2223     unsigned int actual_ret_off = __ offset();
 2224     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2225 #endif
 2226   %}
 2227 
 2228   enc_class z_enc_java_static_call(method meth) %{
 2229     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2230     // whom we intended to call.
 2231     MacroAssembler _masm(&amp;cbuf);
 2232     int ret_offset = 0;
 2233 
 2234     if (!_method) {
 2235       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2236                                    relocInfo::runtime_call_w_cp_type, ra_);
 2237     } else {
 2238       int method_index = resolved_method_index(cbuf);
 2239       if (_optimized_virtual) {
 2240         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2241                                      opt_virtual_call_Relocation::spec(method_index));
 2242       } else {
 2243         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2244                                      static_call_Relocation::spec(method_index));
 2245       }
 2246     }
 2247     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2248 
 2249     if (_method) { // Emit stub for static call.
 2250       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2251       if (stub == NULL) {
 2252         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2253         return;
 2254       }
 2255     }
 2256   %}
 2257 
 2258   // Java dynamic call
 2259   enc_class z_enc_java_dynamic_call(method meth) %{
 2260     MacroAssembler _masm(&amp;cbuf);
 2261     unsigned int start_off = __ offset();
 2262 
 2263     int vtable_index = this-&gt;_vtable_index;
 2264     if (vtable_index == -4) {
 2265       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2266       address virtual_call_oop_addr = NULL;
 2267 
 2268       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2269       virtual_call_oop_addr = __ pc();
 2270       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2271       if (!success) {
 2272         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2273         return;
 2274       }
 2275 
 2276       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2277       // to determine who we intended to call.
 2278       int method_index = resolved_method_index(cbuf);
 2279       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2280       unsigned int ret_off = __ offset();
 2281       assert(__ offset() - start_off == 6, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2282       ret_off += emit_call_reloc(_masm, $meth$$method, relocInfo::none, ra_);
 2283       assert(_method, &quot;lazy_constant may be wrong when _method==null&quot;);
 2284     } else {
 2285       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2286       // Go through the vtable. Get receiver klass. Receiver already
 2287       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 2288       // interpreter expects method in Z_method.
 2289       // Use Z_method to temporarily hold the klass oop.
 2290       // Z_R1_scratch is destroyed.
 2291       __ load_klass(Z_method, Z_R2);
 2292 
 2293       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index * vtableEntry::size_in_bytes();
 2294       int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();
 2295 
 2296       if (Displacement::is_validDisp(v_off) ) {
 2297         // Can use load instruction with large offset.
 2298         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2299       } else {
 2300         // Worse case, must load offset into register.
 2301         __ load_const(Z_R1_scratch, v_off);
 2302         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2303       }
 2304       // NOTE: for vtable dispatches, the vtable entry will never be
 2305       // null. However it may very well end up in handle_wrong_method
 2306       // if the method is abstract for the particular class.
 2307       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2308       // Call target. Either compiled code or C2I adapter.
 2309       __ z_basr(Z_R14, Z_R1_scratch);
 2310       unsigned int ret_off = __ offset();
 2311     }
 2312   %}
 2313 
 2314   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
 2315     MacroAssembler _masm(&amp;cbuf);
 2316     Register Rdst = reg_to_register_object($dst$$reg);
 2317     Register Rsrc = reg_to_register_object($src$$reg);
 2318 
 2319     // Don&#39;t emit code if operands are identical (same register).
 2320     if (Rsrc != Rdst) {
 2321       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2322 
 2323       if (VM_Version::has_LoadStoreConditional()) {
 2324         __ z_locgr(Rdst, Rsrc, cc);
 2325       } else {
 2326         // Branch if not (cmp cr).
 2327         Label done;
 2328         __ z_brc(Assembler::inverse_condition(cc), done);
 2329         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2330         __ bind(done);
 2331       }
 2332     }
 2333   %}
 2334 
 2335   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
 2336     MacroAssembler _masm(&amp;cbuf);
 2337     Register Rdst = reg_to_register_object($dst$$reg);
 2338     int      Csrc = $src$$constant;
 2339     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2340     Label done;
 2341     // Branch if not (cmp cr).
 2342     __ z_brc(Assembler::inverse_condition(cc), done);
 2343     if (Csrc == 0) {
 2344       // Don&#39;t set CC.
 2345       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2346     } else {
 2347       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2348     }
 2349     __ bind(done);
 2350   %}
 2351 
 2352   enc_class z_enc_cctobool(iRegI res) %{
 2353     MacroAssembler _masm(&amp;cbuf);
 2354     Register Rres = reg_to_register_object($res$$reg);
 2355 
 2356     if (VM_Version::has_LoadStoreConditional()) {
 2357       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2358       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2359       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2360     } else {
 2361       Label done;
 2362       __ load_const_optimized(Rres, 0L); // false (failed)
 2363       __ z_brne(done);                   // Assume true to be the common case.
 2364       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2365       __ bind(done);
 2366     }
 2367   %}
 2368 
 2369   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
 2370     MacroAssembler _masm(&amp;cbuf);
 2371     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2372     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2373     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2374 
 2375     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2376   %}
 2377 
 2378   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
 2379     MacroAssembler _masm(&amp;cbuf);
 2380     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2381     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2382     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2383 
 2384     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2385   %}
 2386 
 2387   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
 2388     MacroAssembler _masm(&amp;cbuf);
 2389     Register Rdst = reg_to_register_object($dst$$reg);
 2390     Register Rtmp = reg_to_register_object($tmp$$reg);
 2391     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2392     Label    retry;
 2393 
 2394     // Iterate until swap succeeds.
 2395     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2396     __ bind(retry);
 2397       // Calculate incremented value.
 2398       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2399       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2400     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2401   %}
 2402 
 2403   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
 2404     MacroAssembler _masm(&amp;cbuf);
 2405     Register Rdst = reg_to_register_object($dst$$reg);
 2406     Register Rtmp = reg_to_register_object($tmp$$reg);
 2407     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2408     Label    retry;
 2409 
 2410     // Iterate until swap succeeds.
 2411     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2412     __ bind(retry);
 2413       // Calculate incremented value.
 2414       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2415       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2416     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2417   %}
 2418 
 2419 %} // encode
 2420 
 2421 source %{
 2422 
 2423   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2424   // 32 bits after encoding.
 2425   static bool all_outs_are_Stores(const Node *n) {
 2426     for (DUIterator_Fast imax, k = n-&gt;fast_outs(imax); k &lt; imax; k++) {
 2427       Node *out = n-&gt;fast_out(k);
 2428       if (!out-&gt;is_Mach() || out-&gt;as_Mach()-&gt;ideal_Opcode() != Op_StoreN) {
 2429         // Most other outs are SpillCopy, but there are various other.
 2430         // jvm98 has arond 9% Encodes where we return false.
 2431         return false;
 2432       }
 2433     }
 2434     return true;
 2435   }
 2436 
 2437 %} // source
 2438 
 2439 
 2440 //----------FRAME--------------------------------------------------------------
 2441 // Definition of frame structure and management information.
 2442 
 2443 frame %{
 2444   // What direction does stack grow in (assumed to be same for native &amp; Java).
 2445   stack_direction(TOWARDS_LOW);
 2446 
 2447   // These two registers define part of the calling convention between
 2448   // compiled code and the interpreter.
 2449 
 2450   // Inline Cache Register
 2451   inline_cache_reg(Z_R9); // Z_inline_cache
 2452 
 2453   // Argument pointer for I2C adapters
 2454   //
 2455   // Tos is loaded in run_compiled_code to Z_ARG5=Z_R6.
 2456   // interpreter_arg_ptr_reg(Z_R6);
 2457 
 2458   // Temporary in compiled entry-points
 2459   // compiler_method_oop_reg(Z_R1);//Z_R1_scratch
 2460 
 2461   // Method Oop Register when calling interpreter
 2462   interpreter_method_oop_reg(Z_R9);//Z_method
 2463 
 2464   // Optional: name the operand used by cisc-spilling to access
 2465   // [stack_pointer + offset].
 2466   cisc_spilling_operand_name(indOffset12);
 2467 
 2468   // Number of stack slots consumed by a Monitor enter.
 2469   sync_stack_slots(frame::jit_monitor_size_in_4_byte_units);
 2470 
 2471   // Compiled code&#39;s Frame Pointer
 2472   //
 2473   // z/Architecture stack pointer
 2474   frame_pointer(Z_R15); // Z_SP
 2475 
 2476   // Interpreter stores its frame pointer in a register which is
 2477   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 2478   // interpreted java to compiled java.
 2479   //
 2480   // Z_state holds pointer to caller&#39;s cInterpreter.
 2481   interpreter_frame_pointer(Z_R7); // Z_state
 2482 
 2483   // Use alignment_in_bytes instead of log_2_of_alignment_in_bits.
 2484   stack_alignment(frame::alignment_in_bytes);
 2485 
 2486   in_preserve_stack_slots(frame::jit_in_preserve_size_in_4_byte_units);
 2487 
 2488   // A `slot&#39; is assumed 4 bytes here!
 2489   // out_preserve_stack_slots(frame::jit_out_preserve_size_in_4_byte_units);
 2490 
 2491   // Number of outgoing stack slots killed above the
 2492   // out_preserve_stack_slots for calls to C. Supports the var-args
 2493   // backing area for register parms.
 2494   varargs_C_out_slots_killed(((frame::z_abi_160_size - frame::z_jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 2495 
 2496   // The after-PROLOG location of the return address. Location of
 2497   // return address specifies a type (REG or STACK) and a number
 2498   // representing the register number (i.e. - use a register name) or
 2499   // stack slot.
 2500   return_addr(REG Z_R14);
 2501 
 2502   // This is the body of the function
 2503   //
 2504   // void Matcher::calling_convention(OptoRegPair* sig /* array of ideal regs */,
 2505   //                                  uint length      /* length of array */,
 2506   //                                  bool is_outgoing)
 2507   //
 2508   // The `sig&#39; array is to be updated. Sig[j] represents the location
 2509   // of the j-th argument, either a register or a stack slot.
 2510 
 2511   // Body of function which returns an integer array locating
 2512   // arguments either in registers or in stack slots. Passed an array
 2513   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2514   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2515   // arguments for a CALLEE. Incoming stack arguments are
 2516   // automatically biased by the preserve_stack_slots field above.
 2517   calling_convention %{
 2518     // No difference between ingoing/outgoing just pass false.
 2519     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2520   %}
 2521 
 2522   // Body of function which returns an integer array locating
 2523   // arguments either in registers or in stack slots. Passed an array
 2524   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2525   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2526   // arguments for a CALLEE. Incoming stack arguments are
 2527   // automatically biased by the preserve_stack_slots field above.
 2528   c_calling_convention %{
 2529     // This is obviously always outgoing.
 2530     // C argument must be in register AND stack slot.
 2531     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2532   %}
 2533 
 2534   // Location of native (C/C++) and interpreter return values. This
 2535   // is specified to be the same as Java. In the 32-bit VM, long
 2536   // values are actually returned from native calls in O0:O1 and
 2537   // returned to the interpreter in I0:I1. The copying to and from
 2538   // the register pairs is done by the appropriate call and epilog
 2539   // opcodes. This simplifies the register allocator.
 2540   //
 2541   // Use register pair for c return value.
 2542   c_return_value %{
 2543     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2544     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2545     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2546     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2547   %}
 2548 
 2549   // Use register pair for return value.
 2550   // Location of compiled Java return values. Same as C
 2551   return_value %{
 2552     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2553     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2554     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2555     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2556   %}
 2557 %}
 2558 
 2559 
 2560 //----------ATTRIBUTES---------------------------------------------------------
 2561 
 2562 //----------Operand Attributes-------------------------------------------------
 2563 op_attrib op_cost(1);          // Required cost attribute
 2564 
 2565 //----------Instruction Attributes---------------------------------------------
 2566 
 2567 // Cost attribute. required.
 2568 ins_attrib ins_cost(DEFAULT_COST);
 2569 
 2570 // Is this instruction a non-matching short branch variant of some
 2571 // long branch? Not required.
 2572 ins_attrib ins_short_branch(0);
 2573 
 2574 // Indicates this is a trap based check node and final control-flow fixup
 2575 // must generate a proper fall through.
 2576 ins_attrib ins_is_TrapBasedCheckNode(true);
 2577 
 2578 // Attribute of instruction to tell how many constants the instruction will generate.
 2579 // (optional attribute). Default: 0.
 2580 ins_attrib ins_num_consts(0);
 2581 
 2582 // Required alignment attribute (must be a power of 2)
 2583 // specifies the alignment that some part of the instruction (not
 2584 // necessarily the start) requires. If &gt; 1, a compute_padding()
 2585 // function must be provided for the instruction.
 2586 //
 2587 // WARNING: Don&#39;t use size(FIXED_SIZE) or size(VARIABLE_SIZE) in
 2588 // instructions which depend on the proper alignment, because the
 2589 // desired alignment isn&#39;t guaranteed for the call to &quot;emit()&quot; during
 2590 // the size computation.
 2591 ins_attrib ins_alignment(1);
 2592 
 2593 // Enforce/prohibit rematerializations.
 2594 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 2595 //   then rematerialization of that instruction is prohibited and the
 2596 //   instruction&#39;s value will be spilled if necessary.
 2597 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 2598 //   then rematerialization is enforced and the instruction&#39;s value will
 2599 //   never get spilled. a copy of the instruction will be inserted if
 2600 //   necessary.
 2601 //   Note: this may result in rematerializations in front of every use.
 2602 // (optional attribute)
 2603 ins_attrib ins_cannot_rematerialize(false);
 2604 ins_attrib ins_should_rematerialize(false);
 2605 
 2606 //----------OPERANDS-----------------------------------------------------------
 2607 // Operand definitions must precede instruction definitions for correct
 2608 // parsing in the ADLC because operands constitute user defined types
 2609 // which are used in instruction definitions.
 2610 
 2611 //----------Simple Operands----------------------------------------------------
 2612 // Immediate Operands
 2613 // Please note:
 2614 // Formats are generated automatically for constants and base registers.
 2615 
 2616 //----------------------------------------------
 2617 // SIGNED (shorter than INT) immediate operands
 2618 //----------------------------------------------
 2619 
 2620 // Byte Immediate: constant &#39;int -1&#39;
 2621 operand immB_minus1() %{
 2622   //         sign-ext constant      zero-ext constant
 2623   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x000000ff) == 0x000000ff));
 2624   match(ConI);
 2625   op_cost(1);
 2626   format %{ %}
 2627   interface(CONST_INTER);
 2628 %}
 2629 
 2630 // Byte Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2631 operand immB_n0m1() %{
 2632   //                             sign-ext constant     zero-ext constant
 2633   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x000000ff) != 0x000000ff);
 2634   match(ConI);
 2635   op_cost(1);
 2636   format %{ %}
 2637   interface(CONST_INTER);
 2638 %}
 2639 
 2640 // Short Immediate: constant &#39;int -1&#39;
 2641 operand immS_minus1() %{
 2642   //         sign-ext constant      zero-ext constant
 2643   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x0000ffff) == 0x0000ffff));
 2644   match(ConI);
 2645   op_cost(1);
 2646   format %{ %}
 2647   interface(CONST_INTER);
 2648 %}
 2649 
 2650 // Short Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2651 operand immS_n0m1() %{
 2652   //                             sign-ext constant     zero-ext constant
 2653   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x0000ffff) != 0x0000ffff);
 2654   match(ConI);
 2655   op_cost(1);
 2656   format %{ %}
 2657   interface(CONST_INTER);
 2658 %}
 2659 
 2660 //-----------------------------------------
 2661 //  SIGNED INT immediate operands
 2662 //-----------------------------------------
 2663 
 2664 // Integer Immediate: 32-bit
 2665 operand immI() %{
 2666   match(ConI);
 2667   op_cost(1);
 2668   format %{ %}
 2669   interface(CONST_INTER);
 2670 %}
 2671 
 2672 // Int Immediate: 20-bit
 2673 operand immI20() %{
 2674   predicate(Immediate::is_simm20(n-&gt;get_int()));
 2675   match(ConI);
 2676   op_cost(1);
 2677   format %{ %}
 2678   interface(CONST_INTER);
 2679 %}
 2680 
 2681 // Integer Immediate: 16-bit
 2682 operand immI16() %{
 2683   predicate(Immediate::is_simm16(n-&gt;get_int()));
 2684   match(ConI);
 2685   op_cost(1);
 2686   format %{ %}
 2687   interface(CONST_INTER);
 2688 %}
 2689 
 2690 // Integer Immediate: 8-bit
 2691 operand immI8() %{
 2692   predicate(Immediate::is_simm8(n-&gt;get_int()));
 2693   match(ConI);
 2694   op_cost(1);
 2695   format %{ %}
 2696   interface(CONST_INTER);
 2697 %}
 2698 
 2699 // Integer Immediate: constant &#39;int 0&#39;
 2700 operand immI_0() %{
 2701   predicate(n-&gt;get_int() == 0);
 2702   match(ConI);
 2703   op_cost(1);
 2704   format %{ %}
 2705   interface(CONST_INTER);
 2706 %}
 2707 
 2708 // Integer Immediate: constant &#39;int -1&#39;
 2709 operand immI_minus1() %{
 2710   predicate(n-&gt;get_int() == -1);
 2711   match(ConI);
 2712   op_cost(1);
 2713   format %{ %}
 2714   interface(CONST_INTER);
 2715 %}
 2716 
 2717 // Integer Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2718 operand immI_n0m1() %{
 2719   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1);
 2720   match(ConI);
 2721   op_cost(1);
 2722   format %{ %}
 2723   interface(CONST_INTER);
 2724 %}
 2725 
 2726 //-------------------------------------------
 2727 // UNSIGNED INT immediate operands
 2728 //-------------------------------------------
 2729 
 2730 // Unsigned Integer Immediate: 32-bit
 2731 operand uimmI() %{
 2732   match(ConI);
 2733   op_cost(1);
 2734   format %{ %}
 2735   interface(CONST_INTER);
 2736 %}
 2737 
 2738 // Unsigned Integer Immediate: 16-bit
 2739 operand uimmI16() %{
 2740   predicate(Immediate::is_uimm16(n-&gt;get_int()));
 2741   match(ConI);
 2742   op_cost(1);
 2743   format %{ %}
 2744   interface(CONST_INTER);
 2745 %}
 2746 
 2747 // Unsigned Integer Immediate: 12-bit
 2748 operand uimmI12() %{
 2749   predicate(Immediate::is_uimm12(n-&gt;get_int()));
 2750   match(ConI);
 2751   op_cost(1);
 2752   format %{ %}
 2753   interface(CONST_INTER);
 2754 %}
 2755 
 2756 // Unsigned Integer Immediate: 12-bit
 2757 operand uimmI8() %{
 2758   predicate(Immediate::is_uimm8(n-&gt;get_int()));
 2759   match(ConI);
 2760   op_cost(1);
 2761   format %{ %}
 2762   interface(CONST_INTER);
 2763 %}
 2764 
 2765 // Integer Immediate: 6-bit
 2766 operand uimmI6() %{
 2767   predicate(Immediate::is_uimm(n-&gt;get_int(), 6));
 2768   match(ConI);
 2769   op_cost(1);
 2770   format %{ %}
 2771   interface(CONST_INTER);
 2772 %}
 2773 
 2774 // Integer Immediate: 5-bit
 2775 operand uimmI5() %{
 2776   predicate(Immediate::is_uimm(n-&gt;get_int(), 5));
 2777   match(ConI);
 2778   op_cost(1);
 2779   format %{ %}
 2780   interface(CONST_INTER);
 2781 %}
 2782 
 2783 // Length for SS instructions, given in DWs,
 2784 //   possible range [1..512], i.e. [8..4096] Bytes
 2785 //   used     range [1..256], i.e. [8..2048] Bytes
 2786 //   operand type int
 2787 // Unsigned Integer Immediate: 9-bit
 2788 operand SSlenDW() %{
 2789   predicate(Immediate::is_uimm8(n-&gt;get_long()-1));
 2790   match(ConL);
 2791   op_cost(1);
 2792   format %{ %}
 2793   interface(CONST_INTER);
 2794 %}
 2795 
 2796 //------------------------------------------
 2797 // (UN)SIGNED INT specific values
 2798 //------------------------------------------
 2799 
 2800 // Integer Immediate: the value 1
 2801 operand immI_1() %{
 2802   predicate(n-&gt;get_int() == 1);
 2803   match(ConI);
 2804   op_cost(1);
 2805   format %{ %}
 2806   interface(CONST_INTER);
 2807 %}
 2808 
 2809 // Integer Immediate: the value 16.
 2810 operand immI_16() %{
 2811   predicate(n-&gt;get_int() == 16);
 2812   match(ConI);
 2813   op_cost(1);
 2814   format %{ %}
 2815   interface(CONST_INTER);
 2816 %}
 2817 
 2818 // Integer Immediate: the value 24.
 2819 operand immI_24() %{
 2820   predicate(n-&gt;get_int() == 24);
 2821   match(ConI);
 2822   op_cost(1);
 2823   format %{ %}
 2824   interface(CONST_INTER);
 2825 %}
 2826 
 2827 // Integer Immediate: the value 255
 2828 operand immI_255() %{
 2829   predicate(n-&gt;get_int() == 255);
 2830   match(ConI);
 2831   op_cost(1);
 2832   format %{ %}
 2833   interface(CONST_INTER);
 2834 %}
 2835 
 2836 // Integer Immediate: the values 32-63
 2837 operand immI_32_63() %{
 2838   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 2839   match(ConI);
 2840   op_cost(1);
 2841   format %{ %}
 2842   interface(CONST_INTER);
 2843 %}
 2844 
 2845 // Unsigned Integer Immediate: LL-part, extended by 1s.
 2846 operand uimmI_LL1() %{
 2847   predicate((n-&gt;get_int() &amp; 0xFFFF0000) == 0xFFFF0000);
 2848   match(ConI);
 2849   op_cost(1);
 2850   format %{ %}
 2851   interface(CONST_INTER);
 2852 %}
 2853 
 2854 // Unsigned Integer Immediate: LH-part, extended by 1s.
 2855 operand uimmI_LH1() %{
 2856   predicate((n-&gt;get_int() &amp; 0xFFFF) == 0xFFFF);
 2857   match(ConI);
 2858   op_cost(1);
 2859   format %{ %}
 2860   interface(CONST_INTER);
 2861 %}
 2862 
 2863 //------------------------------------------
 2864 // SIGNED LONG immediate operands
 2865 //------------------------------------------
 2866 
 2867 operand immL() %{
 2868   match(ConL);
 2869   op_cost(1);
 2870   format %{ %}
 2871   interface(CONST_INTER);
 2872 %}
 2873 
 2874 // Long Immediate: 32-bit
 2875 operand immL32() %{
 2876   predicate(Immediate::is_simm32(n-&gt;get_long()));
 2877   match(ConL);
 2878   op_cost(1);
 2879   format %{ %}
 2880   interface(CONST_INTER);
 2881 %}
 2882 
 2883 // Long Immediate: 20-bit
 2884 operand immL20() %{
 2885   predicate(Immediate::is_simm20(n-&gt;get_long()));
 2886   match(ConL);
 2887   op_cost(1);
 2888   format %{ %}
 2889   interface(CONST_INTER);
 2890 %}
 2891 
 2892 // Long Immediate: 16-bit
 2893 operand immL16() %{
 2894   predicate(Immediate::is_simm16(n-&gt;get_long()));
 2895   match(ConL);
 2896   op_cost(1);
 2897   format %{ %}
 2898   interface(CONST_INTER);
 2899 %}
 2900 
 2901 // Long Immediate: 8-bit
 2902 operand immL8() %{
 2903   predicate(Immediate::is_simm8(n-&gt;get_long()));
 2904   match(ConL);
 2905   op_cost(1);
 2906   format %{ %}
 2907   interface(CONST_INTER);
 2908 %}
 2909 
 2910 //--------------------------------------------
 2911 // UNSIGNED LONG immediate operands
 2912 //--------------------------------------------
 2913 
 2914 operand uimmL32() %{
 2915   predicate(Immediate::is_uimm32(n-&gt;get_long()));
 2916   match(ConL);
 2917   op_cost(1);
 2918   format %{ %}
 2919   interface(CONST_INTER);
 2920 %}
 2921 
 2922 // Unsigned Long Immediate: 16-bit
 2923 operand uimmL16() %{
 2924   predicate(Immediate::is_uimm16(n-&gt;get_long()));
 2925   match(ConL);
 2926   op_cost(1);
 2927   format %{ %}
 2928   interface(CONST_INTER);
 2929 %}
 2930 
 2931 // Unsigned Long Immediate: 12-bit
 2932 operand uimmL12() %{
 2933   predicate(Immediate::is_uimm12(n-&gt;get_long()));
 2934   match(ConL);
 2935   op_cost(1);
 2936   format %{ %}
 2937   interface(CONST_INTER);
 2938 %}
 2939 
 2940 // Unsigned Long Immediate: 8-bit
 2941 operand uimmL8() %{
 2942   predicate(Immediate::is_uimm8(n-&gt;get_long()));
 2943   match(ConL);
 2944   op_cost(1);
 2945   format %{ %}
 2946   interface(CONST_INTER);
 2947 %}
 2948 
 2949 //-------------------------------------------
 2950 // (UN)SIGNED LONG specific values
 2951 //-------------------------------------------
 2952 
 2953 // Long Immediate: the value FF
 2954 operand immL_FF() %{
 2955   predicate(n-&gt;get_long() == 0xFFL);
 2956   match(ConL);
 2957   op_cost(1);
 2958   format %{ %}
 2959   interface(CONST_INTER);
 2960 %}
 2961 
 2962 // Long Immediate: the value FFFF
 2963 operand immL_FFFF() %{
 2964   predicate(n-&gt;get_long() == 0xFFFFL);
 2965   match(ConL);
 2966   op_cost(1);
 2967   format %{ %}
 2968   interface(CONST_INTER);
 2969 %}
 2970 
 2971 // Long Immediate: the value FFFFFFFF
 2972 operand immL_FFFFFFFF() %{
 2973   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 2974   match(ConL);
 2975   op_cost(1);
 2976   format %{ %}
 2977   interface(CONST_INTER);
 2978 %}
 2979 
 2980 operand immL_0() %{
 2981   predicate(n-&gt;get_long() == 0L);
 2982   match(ConL);
 2983   op_cost(1);
 2984   format %{ %}
 2985   interface(CONST_INTER);
 2986 %}
 2987 
 2988 // Unsigned Long Immediate: LL-part, extended by 1s.
 2989 operand uimmL_LL1() %{
 2990   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFF0000L) == 0xFFFFFFFFFFFF0000L);
 2991   match(ConL);
 2992   op_cost(1);
 2993   format %{ %}
 2994   interface(CONST_INTER);
 2995 %}
 2996 
 2997 // Unsigned Long Immediate: LH-part, extended by 1s.
 2998 operand uimmL_LH1() %{
 2999   predicate((n-&gt;get_long() &amp; 0xFFFFFFFF0000FFFFL) == 0xFFFFFFFF0000FFFFL);
 3000   match(ConL);
 3001   op_cost(1);
 3002   format %{ %}
 3003   interface(CONST_INTER);
 3004 %}
 3005 
 3006 // Unsigned Long Immediate: HL-part, extended by 1s.
 3007 operand uimmL_HL1() %{
 3008   predicate((n-&gt;get_long() &amp; 0xFFFF0000FFFFFFFFL) == 0xFFFF0000FFFFFFFFL);
 3009   match(ConL);
 3010   op_cost(1);
 3011   format %{ %}
 3012   interface(CONST_INTER);
 3013 %}
 3014 
 3015 // Unsigned Long Immediate: HH-part, extended by 1s.
 3016 operand uimmL_HH1() %{
 3017   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFFL) == 0xFFFFFFFFFFFFL);
 3018   match(ConL);
 3019   op_cost(1);
 3020   format %{ %}
 3021   interface(CONST_INTER);
 3022 %}
 3023 
 3024 // Long Immediate: low 32-bit mask
 3025 operand immL_32bits() %{
 3026   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3027   match(ConL);
 3028   op_cost(1);
 3029   format %{ %}
 3030   interface(CONST_INTER);
 3031 %}
 3032 
 3033 //--------------------------------------
 3034 //  POINTER immediate operands
 3035 //--------------------------------------
 3036 
 3037 // Pointer Immediate: 64-bit
 3038 operand immP() %{
 3039   match(ConP);
 3040   op_cost(1);
 3041   format %{ %}
 3042   interface(CONST_INTER);
 3043 %}
 3044 
 3045 // Pointer Immediate: 32-bit
 3046 operand immP32() %{
 3047   predicate(Immediate::is_uimm32(n-&gt;get_ptr()));
 3048   match(ConP);
 3049   op_cost(1);
 3050   format %{ %}
 3051   interface(CONST_INTER);
 3052 %}
 3053 
 3054 // Pointer Immediate: 16-bit
 3055 operand immP16() %{
 3056   predicate(Immediate::is_uimm16(n-&gt;get_ptr()));
 3057   match(ConP);
 3058   op_cost(1);
 3059   format %{ %}
 3060   interface(CONST_INTER);
 3061 %}
 3062 
 3063 // Pointer Immediate: 8-bit
 3064 operand immP8() %{
 3065   predicate(Immediate::is_uimm8(n-&gt;get_ptr()));
 3066   match(ConP);
 3067   op_cost(1);
 3068   format %{ %}
 3069   interface(CONST_INTER);
 3070 %}
 3071 
 3072 //-----------------------------------
 3073 // POINTER specific values
 3074 //-----------------------------------
 3075 
 3076 // Pointer Immediate: NULL
 3077 operand immP0() %{
 3078   predicate(n-&gt;get_ptr() == 0);
 3079   match(ConP);
 3080   op_cost(1);
 3081   format %{ %}
 3082   interface(CONST_INTER);
 3083 %}
 3084 
 3085 //---------------------------------------------
 3086 // NARROW POINTER immediate operands
 3087 //---------------------------------------------
 3088 
 3089 // Narrow Pointer Immediate
 3090 operand immN() %{
 3091   match(ConN);
 3092   op_cost(1);
 3093   format %{ %}
 3094   interface(CONST_INTER);
 3095 %}
 3096 
 3097 operand immNKlass() %{
 3098   match(ConNKlass);
 3099   op_cost(1);
 3100   format %{ %}
 3101   interface(CONST_INTER);
 3102 %}
 3103 
 3104 // Narrow Pointer Immediate
 3105 operand immN8() %{
 3106   predicate(Immediate::is_uimm8(n-&gt;get_narrowcon()));
 3107   match(ConN);
 3108   op_cost(1);
 3109   format %{ %}
 3110   interface(CONST_INTER);
 3111 %}
 3112 
 3113 // Narrow NULL Pointer Immediate
 3114 operand immN0() %{
 3115   predicate(n-&gt;get_narrowcon() == 0);
 3116   match(ConN);
 3117   op_cost(1);
 3118   format %{ %}
 3119   interface(CONST_INTER);
 3120 %}
 3121 
 3122 // FLOAT and DOUBLE immediate operands
 3123 
 3124 // Double Immediate
 3125 operand immD() %{
 3126   match(ConD);
 3127   op_cost(1);
 3128   format %{ %}
 3129   interface(CONST_INTER);
 3130 %}
 3131 
 3132 // Double Immediate: +-0
 3133 operand immDpm0() %{
 3134   predicate(n-&gt;getd() == 0);
 3135   match(ConD);
 3136   op_cost(1);
 3137   format %{ %}
 3138   interface(CONST_INTER);
 3139 %}
 3140 
 3141 // Double Immediate: +0
 3142 operand immDp0() %{
 3143   predicate(jlong_cast(n-&gt;getd()) == 0);
 3144   match(ConD);
 3145   op_cost(1);
 3146   format %{ %}
 3147   interface(CONST_INTER);
 3148 %}
 3149 
 3150 // Float Immediate
 3151 operand immF() %{
 3152   match(ConF);
 3153   op_cost(1);
 3154   format %{ %}
 3155   interface(CONST_INTER);
 3156 %}
 3157 
 3158 // Float Immediate: +-0
 3159 operand immFpm0() %{
 3160   predicate(n-&gt;getf() == 0);
 3161   match(ConF);
 3162   op_cost(1);
 3163   format %{ %}
 3164   interface(CONST_INTER);
 3165 %}
 3166 
 3167 // Float Immediate: +0
 3168 operand immFp0() %{
 3169   predicate(jint_cast(n-&gt;getf()) == 0);
 3170   match(ConF);
 3171   op_cost(1);
 3172   format %{ %}
 3173   interface(CONST_INTER);
 3174 %}
 3175 
 3176 // End of Immediate Operands
 3177 
 3178 // Integer Register Operands
 3179 // Integer Register
 3180 operand iRegI() %{
 3181   constraint(ALLOC_IN_RC(z_int_reg));
 3182   match(RegI);
 3183   match(noArg_iRegI);
 3184   match(rarg1RegI);
 3185   match(rarg2RegI);
 3186   match(rarg3RegI);
 3187   match(rarg4RegI);
 3188   match(rarg5RegI);
 3189   match(noOdd_iRegI);
 3190   match(revenRegI);
 3191   match(roddRegI);
 3192   format %{ %}
 3193   interface(REG_INTER);
 3194 %}
 3195 
 3196 operand noArg_iRegI() %{
 3197   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3198   match(RegI);
 3199   format %{ %}
 3200   interface(REG_INTER);
 3201 %}
 3202 
 3203 // revenRegI and roddRegI constitute and even-odd-pair.
 3204 operand revenRegI() %{
 3205   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3206   match(iRegI);
 3207   format %{ %}
 3208   interface(REG_INTER);
 3209 %}
 3210 
 3211 // revenRegI and roddRegI constitute and even-odd-pair.
 3212 operand roddRegI() %{
 3213   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3214   match(iRegI);
 3215   format %{ %}
 3216   interface(REG_INTER);
 3217 %}
 3218 
 3219 operand rarg1RegI() %{
 3220   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3221   match(iRegI);
 3222   format %{ %}
 3223   interface(REG_INTER);
 3224 %}
 3225 
 3226 operand rarg2RegI() %{
 3227   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3228   match(iRegI);
 3229   format %{ %}
 3230   interface(REG_INTER);
 3231 %}
 3232 
 3233 operand rarg3RegI() %{
 3234   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3235   match(iRegI);
 3236   format %{ %}
 3237   interface(REG_INTER);
 3238 %}
 3239 
 3240 operand rarg4RegI() %{
 3241   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3242   match(iRegI);
 3243   format %{ %}
 3244   interface(REG_INTER);
 3245 %}
 3246 
 3247 operand rarg5RegI() %{
 3248   constraint(ALLOC_IN_RC(z_rarg5_int_reg));
 3249   match(iRegI);
 3250   format %{ %}
 3251   interface(REG_INTER);
 3252 %}
 3253 
 3254 operand noOdd_iRegI() %{
 3255   constraint(ALLOC_IN_RC(z_no_odd_int_reg));
 3256   match(RegI);
 3257   match(revenRegI);
 3258   format %{ %}
 3259   interface(REG_INTER);
 3260 %}
 3261 
 3262 // Pointer Register
 3263 operand iRegP() %{
 3264   constraint(ALLOC_IN_RC(z_ptr_reg));
 3265   match(RegP);
 3266   match(noArg_iRegP);
 3267   match(rarg1RegP);
 3268   match(rarg2RegP);
 3269   match(rarg3RegP);
 3270   match(rarg4RegP);
 3271   match(rarg5RegP);
 3272   match(revenRegP);
 3273   match(roddRegP);
 3274   format %{ %}
 3275   interface(REG_INTER);
 3276 %}
 3277 
 3278 // thread operand
 3279 operand threadRegP() %{
 3280   constraint(ALLOC_IN_RC(z_thread_ptr_reg));
 3281   match(RegP);
 3282   format %{ &quot;Z_THREAD&quot; %}
 3283   interface(REG_INTER);
 3284 %}
 3285 
 3286 operand noArg_iRegP() %{
 3287   constraint(ALLOC_IN_RC(z_no_arg_ptr_reg));
 3288   match(iRegP);
 3289   format %{ %}
 3290   interface(REG_INTER);
 3291 %}
 3292 
 3293 operand rarg1RegP() %{
 3294   constraint(ALLOC_IN_RC(z_rarg1_ptr_reg));
 3295   match(iRegP);
 3296   format %{ %}
 3297   interface(REG_INTER);
 3298 %}
 3299 
 3300 operand rarg2RegP() %{
 3301   constraint(ALLOC_IN_RC(z_rarg2_ptr_reg));
 3302   match(iRegP);
 3303   format %{ %}
 3304   interface(REG_INTER);
 3305 %}
 3306 
 3307 operand rarg3RegP() %{
 3308   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3309   match(iRegP);
 3310   format %{ %}
 3311   interface(REG_INTER);
 3312 %}
 3313 
 3314 operand rarg4RegP() %{
 3315   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3316   match(iRegP);
 3317   format %{ %}
 3318   interface(REG_INTER);
 3319 %}
 3320 
 3321 operand rarg5RegP() %{
 3322   constraint(ALLOC_IN_RC(z_rarg5_ptr_reg));
 3323   match(iRegP);
 3324   format %{ %}
 3325   interface(REG_INTER);
 3326 %}
 3327 
 3328 operand memoryRegP() %{
 3329   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3330   match(RegP);
 3331   match(iRegP);
 3332   match(threadRegP);
 3333   format %{ %}
 3334   interface(REG_INTER);
 3335 %}
 3336 
 3337 // revenRegP and roddRegP constitute and even-odd-pair.
 3338 operand revenRegP() %{
 3339   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3340   match(iRegP);
 3341   format %{ %}
 3342   interface(REG_INTER);
 3343 %}
 3344 
 3345 // revenRegP and roddRegP constitute and even-odd-pair.
 3346 operand roddRegP() %{
 3347   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3348   match(iRegP);
 3349   format %{ %}
 3350   interface(REG_INTER);
 3351 %}
 3352 
 3353 operand lock_ptr_RegP() %{
 3354   constraint(ALLOC_IN_RC(z_lock_ptr_reg));
 3355   match(RegP);
 3356   format %{ %}
 3357   interface(REG_INTER);
 3358 %}
 3359 
 3360 operand rscratch2RegP() %{
 3361   constraint(ALLOC_IN_RC(z_rscratch2_bits64_reg));
 3362   match(RegP);
 3363   format %{ %}
 3364   interface(REG_INTER);
 3365 %}
 3366 
 3367 operand iRegN() %{
 3368   constraint(ALLOC_IN_RC(z_int_reg));
 3369   match(RegN);
 3370   match(noArg_iRegN);
 3371   match(rarg1RegN);
 3372   match(rarg2RegN);
 3373   match(rarg3RegN);
 3374   match(rarg4RegN);
 3375   match(rarg5RegN);
 3376   format %{ %}
 3377   interface(REG_INTER);
 3378 %}
 3379 
 3380 operand noArg_iRegN() %{
 3381   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3382   match(iRegN);
 3383   format %{ %}
 3384   interface(REG_INTER);
 3385 %}
 3386 
 3387 operand rarg1RegN() %{
 3388   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3389   match(iRegN);
 3390   format %{ %}
 3391   interface(REG_INTER);
 3392 %}
 3393 
 3394 operand rarg2RegN() %{
 3395   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3396   match(iRegN);
 3397   format %{ %}
 3398   interface(REG_INTER);
 3399 %}
 3400 
 3401 operand rarg3RegN() %{
 3402   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3403   match(iRegN);
 3404   format %{ %}
 3405   interface(REG_INTER);
 3406 %}
 3407 
 3408 operand rarg4RegN() %{
 3409   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3410   match(iRegN);
 3411   format %{ %}
 3412   interface(REG_INTER);
 3413 %}
 3414 
 3415 operand rarg5RegN() %{
 3416   constraint(ALLOC_IN_RC(z_rarg5_ptrN_reg));
 3417   match(iRegN);
 3418   format %{ %}
 3419   interface(REG_INTER);
 3420 %}
 3421 
 3422 // Long Register
 3423 operand iRegL() %{
 3424   constraint(ALLOC_IN_RC(z_long_reg));
 3425   match(RegL);
 3426   match(revenRegL);
 3427   match(roddRegL);
 3428   match(allRoddRegL);
 3429   match(rarg1RegL);
 3430   match(rarg5RegL);
 3431   format %{ %}
 3432   interface(REG_INTER);
 3433 %}
 3434 
 3435 // revenRegL and roddRegL constitute and even-odd-pair.
 3436 operand revenRegL() %{
 3437   constraint(ALLOC_IN_RC(z_rarg3_long_reg));
 3438   match(iRegL);
 3439   format %{ %}
 3440   interface(REG_INTER);
 3441 %}
 3442 
 3443 // revenRegL and roddRegL constitute and even-odd-pair.
 3444 operand roddRegL() %{
 3445   constraint(ALLOC_IN_RC(z_rarg4_long_reg));
 3446   match(iRegL);
 3447   format %{ %}
 3448   interface(REG_INTER);
 3449 %}
 3450 
 3451 // available odd registers for iRegL
 3452 operand allRoddRegL() %{
 3453   constraint(ALLOC_IN_RC(z_long_odd_reg));
 3454   match(iRegL);
 3455   format %{ %}
 3456   interface(REG_INTER);
 3457 %}
 3458 
 3459 operand rarg1RegL() %{
 3460   constraint(ALLOC_IN_RC(z_rarg1_long_reg));
 3461   match(iRegL);
 3462   format %{ %}
 3463   interface(REG_INTER);
 3464 %}
 3465 
 3466 operand rarg5RegL() %{
 3467   constraint(ALLOC_IN_RC(z_rarg5_long_reg));
 3468   match(iRegL);
 3469   format %{ %}
 3470   interface(REG_INTER);
 3471 %}
 3472 
 3473 // Condition Code Flag Registers
 3474 operand flagsReg() %{
 3475   constraint(ALLOC_IN_RC(z_condition_reg));
 3476   match(RegFlags);
 3477   format %{ &quot;CR&quot; %}
 3478   interface(REG_INTER);
 3479 %}
 3480 
 3481 // Condition Code Flag Registers for rules with result tuples
 3482 operand TD_flagsReg() %{
 3483   constraint(ALLOC_IN_RC(z_condition_reg));
 3484   match(RegFlags);
 3485   format %{ &quot;CR&quot; %}
 3486   interface(REG_TUPLE_DEST_INTER);
 3487 %}
 3488 
 3489 operand regD() %{
 3490   constraint(ALLOC_IN_RC(z_dbl_reg));
 3491   match(RegD);
 3492   format %{ %}
 3493   interface(REG_INTER);
 3494 %}
 3495 
 3496 operand rscratchRegD() %{
 3497   constraint(ALLOC_IN_RC(z_rscratch1_dbl_reg));
 3498   match(RegD);
 3499   format %{ %}
 3500   interface(REG_INTER);
 3501 %}
 3502 
 3503 operand regF() %{
 3504   constraint(ALLOC_IN_RC(z_flt_reg));
 3505   match(RegF);
 3506   format %{ %}
 3507   interface(REG_INTER);
 3508 %}
 3509 
 3510 operand rscratchRegF() %{
 3511   constraint(ALLOC_IN_RC(z_rscratch1_flt_reg));
 3512   match(RegF);
 3513   format %{ %}
 3514   interface(REG_INTER);
 3515 %}
 3516 
 3517 // Special Registers
 3518 
 3519 // Method Register
 3520 operand inline_cache_regP(iRegP reg) %{
 3521   constraint(ALLOC_IN_RC(z_r9_regP)); // inline_cache_reg
 3522   match(reg);
 3523   format %{ %}
 3524   interface(REG_INTER);
 3525 %}
 3526 
 3527 operand compiler_method_oop_regP(iRegP reg) %{
 3528   constraint(ALLOC_IN_RC(z_r1_RegP)); // compiler_method_oop_reg
 3529   match(reg);
 3530   format %{ %}
 3531   interface(REG_INTER);
 3532 %}
 3533 
 3534 operand interpreter_method_oop_regP(iRegP reg) %{
 3535   constraint(ALLOC_IN_RC(z_r9_regP)); // interpreter_method_oop_reg
 3536   match(reg);
 3537   format %{ %}
 3538   interface(REG_INTER);
 3539 %}
 3540 
 3541 // Operands to remove register moves in unscaled mode.
 3542 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 3543 operand iRegP2N(iRegP reg) %{
 3544   predicate(CompressedOops::shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);
 3545   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3546   match(EncodeP reg);
 3547   format %{ &quot;$reg&quot; %}
 3548   interface(REG_INTER)
 3549 %}
 3550 
 3551 operand iRegN2P(iRegN reg) %{
 3552   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0 &amp;&amp;
 3553             _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
 3554   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3555   match(DecodeN reg);
 3556   format %{ &quot;$reg&quot; %}
 3557   interface(REG_INTER)
 3558 %}
 3559 
 3560 
 3561 //----------Complex Operands---------------------------------------------------
 3562 
 3563 // Indirect Memory Reference
 3564 operand indirect(memoryRegP base) %{
 3565   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3566   match(base);
 3567   op_cost(1);
 3568   format %{ &quot;#0[,$base]&quot; %}
 3569   interface(MEMORY_INTER) %{
 3570     base($base);
 3571     index(0xffffFFFF); // noreg
 3572     scale(0x0);
 3573     disp(0x0);
 3574   %}
 3575 %}
 3576 
 3577 // Indirect with Offset (long)
 3578 operand indOffset20(memoryRegP base, immL20 offset) %{
 3579   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3580   match(AddP base offset);
 3581   op_cost(1);
 3582   format %{ &quot;$offset[,$base]&quot; %}
 3583   interface(MEMORY_INTER) %{
 3584     base($base);
 3585     index(0xffffFFFF); // noreg
 3586     scale(0x0);
 3587     disp($offset);
 3588   %}
 3589 %}
 3590 
 3591 operand indOffset20Narrow(iRegN base, immL20 offset) %{
 3592   predicate(Matcher::narrow_oop_use_complex_address());
 3593   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3594   match(AddP (DecodeN base) offset);
 3595   op_cost(1);
 3596   format %{ &quot;$offset[,$base]&quot; %}
 3597   interface(MEMORY_INTER) %{
 3598     base($base);
 3599     index(0xffffFFFF); // noreg
 3600     scale(0x0);
 3601     disp($offset);
 3602   %}
 3603 %}
 3604 
 3605 // Indirect with Offset (short)
 3606 operand indOffset12(memoryRegP base, uimmL12 offset) %{
 3607   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3608   match(AddP base offset);
 3609   op_cost(1);
 3610   format %{ &quot;$offset[[,$base]]&quot; %}
 3611   interface(MEMORY_INTER) %{
 3612     base($base);
 3613     index(0xffffFFFF); // noreg
 3614     scale(0x0);
 3615     disp($offset);
 3616   %}
 3617 %}
 3618 
 3619 operand indOffset12Narrow(iRegN base, uimmL12 offset) %{
 3620   predicate(Matcher::narrow_oop_use_complex_address());
 3621   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3622   match(AddP (DecodeN base) offset);
 3623   op_cost(1);
 3624   format %{ &quot;$offset[[,$base]]&quot; %}
 3625   interface(MEMORY_INTER) %{
 3626     base($base);
 3627     index(0xffffFFFF); // noreg
 3628     scale(0x0);
 3629     disp($offset);
 3630   %}
 3631 %}
 3632 
 3633 // Indirect with Register Index
 3634 operand indIndex(memoryRegP base, iRegL index) %{
 3635   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3636   match(AddP base index);
 3637   op_cost(1);
 3638   format %{ &quot;#0[($index,$base)]&quot; %}
 3639   interface(MEMORY_INTER) %{
 3640     base($base);
 3641     index($index);
 3642     scale(0x0);
 3643     disp(0x0);
 3644   %}
 3645 %}
 3646 
 3647 // Indirect with Offset (long) and index
 3648 operand indOffset20index(memoryRegP base, immL20 offset, iRegL index) %{
 3649   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3650   match(AddP (AddP base index) offset);
 3651   op_cost(1);
 3652   format %{ &quot;$offset[($index,$base)]&quot; %}
 3653   interface(MEMORY_INTER) %{
 3654     base($base);
 3655     index($index);
 3656     scale(0x0);
 3657     disp($offset);
 3658   %}
 3659 %}
 3660 
 3661 operand indOffset20indexNarrow(iRegN base, immL20 offset, iRegL index) %{
 3662   predicate(Matcher::narrow_oop_use_complex_address());
 3663   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3664   match(AddP (AddP (DecodeN base) index) offset);
 3665   op_cost(1);
 3666   format %{ &quot;$offset[($index,$base)]&quot; %}
 3667   interface(MEMORY_INTER) %{
 3668     base($base);
 3669     index($index);
 3670     scale(0x0);
 3671     disp($offset);
 3672   %}
 3673 %}
 3674 
 3675 // Indirect with Offset (short) and index
 3676 operand indOffset12index(memoryRegP base, uimmL12 offset, iRegL index) %{
 3677   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3678   match(AddP (AddP base index) offset);
 3679   op_cost(1);
 3680   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3681   interface(MEMORY_INTER) %{
 3682     base($base);
 3683     index($index);
 3684     scale(0x0);
 3685     disp($offset);
 3686   %}
 3687 %}
 3688 
 3689 operand indOffset12indexNarrow(iRegN base, uimmL12 offset, iRegL index) %{
 3690   predicate(Matcher::narrow_oop_use_complex_address());
 3691   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3692   match(AddP (AddP (DecodeN base) index) offset);
 3693   op_cost(1);
 3694   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3695   interface(MEMORY_INTER) %{
 3696     base($base);
 3697     index($index);
 3698     scale(0x0);
 3699     disp($offset);
 3700   %}
 3701 %}
 3702 
 3703 //----------Special Memory Operands--------------------------------------------
 3704 
 3705 // Stack Slot Operand
 3706 // This operand is used for loading and storing temporary values on
 3707 // the stack where a match requires a value to flow through memory.
 3708 operand stackSlotI(sRegI reg) %{
 3709   constraint(ALLOC_IN_RC(stack_slots));
 3710   op_cost(1);
 3711   format %{ &quot;[$reg(stackSlotI)]&quot; %}
 3712   interface(MEMORY_INTER) %{
 3713     base(0xf);   // Z_SP
 3714     index(0xffffFFFF); // noreg
 3715     scale(0x0);
 3716     disp($reg);  // stack offset
 3717   %}
 3718 %}
 3719 
 3720 operand stackSlotP(sRegP reg) %{
 3721   constraint(ALLOC_IN_RC(stack_slots));
 3722   op_cost(1);
 3723   format %{ &quot;[$reg(stackSlotP)]&quot; %}
 3724   interface(MEMORY_INTER) %{
 3725     base(0xf);   // Z_SP
 3726     index(0xffffFFFF); // noreg
 3727     scale(0x0);
 3728     disp($reg);  // Stack Offset
 3729   %}
 3730 %}
 3731 
 3732 operand stackSlotF(sRegF reg) %{
 3733   constraint(ALLOC_IN_RC(stack_slots));
 3734   op_cost(1);
 3735   format %{ &quot;[$reg(stackSlotF)]&quot; %}
 3736   interface(MEMORY_INTER) %{
 3737     base(0xf);   // Z_SP
 3738     index(0xffffFFFF); // noreg
 3739     scale(0x0);
 3740     disp($reg);  // Stack Offset
 3741   %}
 3742 %}
 3743 
 3744 operand stackSlotD(sRegD reg) %{
 3745   constraint(ALLOC_IN_RC(stack_slots));
 3746   op_cost(1);
 3747   //match(RegD);
 3748   format %{ &quot;[$reg(stackSlotD)]&quot; %}
 3749   interface(MEMORY_INTER) %{
 3750     base(0xf);   // Z_SP
 3751     index(0xffffFFFF); // noreg
 3752     scale(0x0);
 3753     disp($reg);  // Stack Offset
 3754   %}
 3755 %}
 3756 
 3757 operand stackSlotL(sRegL reg) %{
 3758   constraint(ALLOC_IN_RC(stack_slots));
 3759   op_cost(1);  //match(RegL);
 3760   format %{ &quot;[$reg(stackSlotL)]&quot; %}
 3761   interface(MEMORY_INTER) %{
 3762     base(0xf);   // Z_SP
 3763     index(0xffffFFFF); // noreg
 3764     scale(0x0);
 3765     disp($reg);  // Stack Offset
 3766   %}
 3767 %}
 3768 
 3769 // Operands for expressing Control Flow
 3770 // NOTE: Label is a predefined operand which should not be redefined in
 3771 // the AD file. It is generically handled within the ADLC.
 3772 
 3773 //----------Conditional Branch Operands----------------------------------------
 3774 // Comparison Op  - This is the operation of the comparison, and is limited to
 3775 //                  the following set of codes:
 3776 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 3777 //
 3778 // Other attributes of the comparison, such as unsignedness, are specified
 3779 // by the comparison instruction that sets a condition code flags register.
 3780 // That result is represented by a flags operand whose subtype is appropriate
 3781 // to the unsignedness (etc.) of the comparison.
 3782 //
 3783 // Later, the instruction which matches both the Comparison Op (a Bool) and
 3784 // the flags (produced by the Cmp) specifies the coding of the comparison op
 3785 // by matching a specific subtype of Bool operand below.
 3786 
 3787 // INT cmpOps for CompareAndBranch and CompareAndTrap instructions should not
 3788 // have mask bit #3 set.
 3789 operand cmpOpT() %{
 3790   match(Bool);
 3791   format %{ &quot;&quot; %}
 3792   interface(COND_INTER) %{
 3793     equal(0x8);         // Assembler::bcondEqual
 3794     not_equal(0x6);     // Assembler::bcondNotEqual
 3795     less(0x4);          // Assembler::bcondLow
 3796     greater_equal(0xa); // Assembler::bcondNotLow
 3797     less_equal(0xc);    // Assembler::bcondNotHigh
 3798     greater(0x2);       // Assembler::bcondHigh
 3799     overflow(0x1);      // Assembler::bcondOverflow
 3800     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3801   %}
 3802 %}
 3803 
 3804 // When used for floating point comparisons: unordered is treated as less.
 3805 operand cmpOpF() %{
 3806   match(Bool);
 3807   format %{ &quot;&quot; %}
 3808   interface(COND_INTER) %{
 3809     equal(0x8);
 3810     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3811     less(0x5);          // Includes &#39;unordered&#39;.
 3812     greater_equal(0xa);
 3813     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3814     greater(0x2);
 3815     overflow(0x0);      // Not meaningful on z/Architecture.
 3816     no_overflow(0x0);   // leave unchanged (zero) therefore
 3817   %}
 3818 %}
 3819 
 3820 // &quot;Regular&quot; cmpOp for int comparisons, includes bit #3 (overflow).
 3821 operand cmpOp() %{
 3822   match(Bool);
 3823   format %{ &quot;&quot; %}
 3824   interface(COND_INTER) %{
 3825     equal(0x8);
 3826     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3827     less(0x5);          // Includes &#39;unordered&#39;.
 3828     greater_equal(0xa);
 3829     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3830     greater(0x2);
 3831     overflow(0x1);      // Assembler::bcondOverflow
 3832     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3833   %}
 3834 %}
 3835 
 3836 //----------OPERAND CLASSES----------------------------------------------------
 3837 // Operand Classes are groups of operands that are used to simplify
 3838 // instruction definitions by not requiring the AD writer to specify
 3839 // seperate instructions for every form of operand when the
 3840 // instruction accepts multiple operand types with the same basic
 3841 // encoding and format.  The classic case of this is memory operands.
 3842 // Indirect is not included since its use is limited to Compare &amp; Swap
 3843 
 3844 // Most general memory operand, allows base, index, and long displacement.
 3845 opclass memory(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3846 opclass memoryRXY(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3847 
 3848 // General memory operand, allows base, index, and short displacement.
 3849 opclass memoryRX(indirect, indIndex, indOffset12, indOffset12Narrow, indOffset12index, indOffset12indexNarrow);
 3850 
 3851 // Memory operand, allows only base and long displacement.
 3852 opclass memoryRSY(indirect, indOffset20, indOffset20Narrow);
 3853 
 3854 // Memory operand, allows only base and short displacement.
 3855 opclass memoryRS(indirect, indOffset12, indOffset12Narrow);
 3856 
 3857 // Operand classes to match encode and decode.
 3858 opclass iRegN_P2N(iRegN);
 3859 opclass iRegP_N2P(iRegP);
 3860 
 3861 
 3862 //----------PIPELINE-----------------------------------------------------------
 3863 pipeline %{
 3864 
 3865 //----------ATTRIBUTES---------------------------------------------------------
 3866 attributes %{
 3867   // z/Architecture instructions are of length 2, 4, or 6 bytes.
 3868   variable_size_instructions;
 3869   instruction_unit_size = 2;
 3870 
 3871   // Meaningless on z/Architecture.
 3872   max_instructions_per_bundle = 1;
 3873 
 3874   // The z/Architecture processor fetches 64 bytes...
 3875   instruction_fetch_unit_size = 64;
 3876 
 3877   // ...in one line.
 3878   instruction_fetch_units = 1
 3879 %}
 3880 
 3881 //----------RESOURCES----------------------------------------------------------
 3882 // Resources are the functional units available to the machine.
 3883 resources(
 3884    Z_BR,     // branch unit
 3885    Z_CR,     // condition unit
 3886    Z_FX1,    // integer arithmetic unit 1
 3887    Z_FX2,    // integer arithmetic unit 2
 3888    Z_LDST1,  // load/store unit 1
 3889    Z_LDST2,  // load/store unit 2
 3890    Z_FP1,    // float arithmetic unit 1
 3891    Z_FP2,    // float arithmetic unit 2
 3892    Z_LDST = Z_LDST1 | Z_LDST2,
 3893    Z_FX   = Z_FX1 | Z_FX2,
 3894    Z_FP   = Z_FP1 | Z_FP2
 3895   );
 3896 
 3897 //----------PIPELINE DESCRIPTION-----------------------------------------------
 3898 // Pipeline Description specifies the stages in the machine&#39;s pipeline.
 3899 pipe_desc(
 3900    // TODO: adapt
 3901    Z_IF,  // instruction fetch
 3902    Z_IC,
 3903    Z_D0,  // decode
 3904    Z_D1,  // decode
 3905    Z_D2,  // decode
 3906    Z_D3,  // decode
 3907    Z_Xfer1,
 3908    Z_GD,  // group definition
 3909    Z_MP,  // map
 3910    Z_ISS, // issue
 3911    Z_RF,  // resource fetch
 3912    Z_EX1, // execute (all units)
 3913    Z_EX2, // execute (FP, LDST)
 3914    Z_EX3, // execute (FP, LDST)
 3915    Z_EX4, // execute (FP)
 3916    Z_EX5, // execute (FP)
 3917    Z_EX6, // execute (FP)
 3918    Z_WB,  // write back
 3919    Z_Xfer2,
 3920    Z_CP
 3921   );
 3922 
 3923 //----------PIPELINE CLASSES---------------------------------------------------
 3924 // Pipeline Classes describe the stages in which input and output are
 3925 // referenced by the hardware pipeline.
 3926 
 3927 // Providing the `ins_pipe&#39; declarations in the instruction
 3928 // specifications seems to be of little use. So we use
 3929 // `pipe_class_dummy&#39; for all our instructions at present.
 3930 pipe_class pipe_class_dummy() %{
 3931   single_instruction;
 3932   fixed_latency(4);
 3933 %}
 3934 
 3935 // SIGTRAP based implicit range checks in compiled code.
 3936 // Currently, no pipe classes are used on z/Architecture.
 3937 pipe_class pipe_class_trap() %{
 3938   single_instruction;
 3939 %}
 3940 
 3941 pipe_class pipe_class_fx_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 3942   single_instruction;
 3943   dst  : Z_EX1(write);
 3944   src1 : Z_RF(read);
 3945   src2 : Z_RF(read);
 3946   Z_FX : Z_RF;
 3947 %}
 3948 
 3949 pipe_class pipe_class_ldst(iRegP dst, memory mem) %{
 3950   single_instruction;
 3951   mem : Z_RF(read);
 3952   dst : Z_WB(write);
 3953   Z_LDST : Z_RF;
 3954 %}
 3955 
 3956 define %{
 3957   MachNop = pipe_class_dummy;
 3958 %}
 3959 
 3960 %}
 3961 
 3962 //----------INSTRUCTIONS-------------------------------------------------------
 3963 
 3964 //---------- Chain stack slots between similar types --------
 3965 
 3966 // Load integer from stack slot.
 3967 instruct stkI_to_regI(iRegI dst, stackSlotI src) %{
 3968   match(Set dst src);
 3969   ins_cost(MEMORY_REF_COST);
 3970   // TODO: s390 port size(FIXED_SIZE);
 3971   format %{ &quot;L       $dst,$src\t # stk reload int&quot; %}
 3972   opcode(L_ZOPC);
 3973   ins_encode(z_form_rt_mem(dst, src));
 3974   ins_pipe(pipe_class_dummy);
 3975 %}
 3976 
 3977 // Store integer to stack slot.
 3978 instruct regI_to_stkI(stackSlotI dst, iRegI src) %{
 3979   match(Set dst src);
 3980   ins_cost(MEMORY_REF_COST);
 3981   // TODO: s390 port size(FIXED_SIZE);
 3982   format %{ &quot;ST      $src,$dst\t # stk spill int&quot; %}
 3983   opcode(ST_ZOPC);
 3984   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 3985   ins_pipe(pipe_class_dummy);
 3986 %}
 3987 
 3988 // Load long from stack slot.
 3989 instruct stkL_to_regL(iRegL dst, stackSlotL src) %{
 3990   match(Set dst src);
 3991   ins_cost(MEMORY_REF_COST);
 3992   // TODO: s390 port size(FIXED_SIZE);
 3993   format %{ &quot;LG      $dst,$src\t # stk reload long&quot; %}
 3994   opcode(LG_ZOPC);
 3995   ins_encode(z_form_rt_mem(dst, src));
 3996   ins_pipe(pipe_class_dummy);
 3997 %}
 3998 
 3999 // Store long to stack slot.
 4000 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 4001   match(Set dst src);
 4002   ins_cost(MEMORY_REF_COST);
 4003   size(6);
 4004   format %{ &quot;STG     $src,$dst\t # stk spill long&quot; %}
 4005   opcode(STG_ZOPC);
 4006   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4007   ins_pipe(pipe_class_dummy);
 4008 %}
 4009 
 4010 // Load pointer from stack slot, 64-bit encoding.
 4011 instruct stkP_to_regP(iRegP dst, stackSlotP src) %{
 4012   match(Set dst src);
 4013   ins_cost(MEMORY_REF_COST);
 4014   // TODO: s390 port size(FIXED_SIZE);
 4015   format %{ &quot;LG      $dst,$src\t # stk reload ptr&quot; %}
 4016   opcode(LG_ZOPC);
 4017   ins_encode(z_form_rt_mem(dst, src));
 4018   ins_pipe(pipe_class_dummy);
 4019 %}
 4020 
 4021 // Store pointer to stack slot.
 4022 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 4023   match(Set dst src);
 4024   ins_cost(MEMORY_REF_COST);
 4025   // TODO: s390 port size(FIXED_SIZE);
 4026   format %{ &quot;STG     $src,$dst\t # stk spill ptr&quot; %}
 4027   opcode(STG_ZOPC);
 4028   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4029   ins_pipe(pipe_class_dummy);
 4030 %}
 4031 
 4032 //  Float types
 4033 
 4034 // Load float value from stack slot.
 4035 instruct stkF_to_regF(regF dst, stackSlotF src) %{
 4036   match(Set dst src);
 4037   ins_cost(MEMORY_REF_COST);
 4038   size(4);
 4039   format %{ &quot;LE(Y)   $dst,$src\t # stk reload float&quot; %}
 4040   opcode(LE_ZOPC);
 4041   ins_encode(z_form_rt_mem(dst, src));
 4042   ins_pipe(pipe_class_dummy);
 4043 %}
 4044 
 4045 // Store float value to stack slot.
 4046 instruct regF_to_stkF(stackSlotF dst, regF src) %{
 4047   match(Set dst src);
 4048   ins_cost(MEMORY_REF_COST);
 4049   size(4);
 4050   format %{ &quot;STE(Y)  $src,$dst\t # stk spill float&quot; %}
 4051   opcode(STE_ZOPC);
 4052   ins_encode(z_form_rt_mem(src, dst));
 4053   ins_pipe(pipe_class_dummy);
 4054 %}
 4055 
 4056 // Load double value from stack slot.
 4057 instruct stkD_to_regD(regD dst, stackSlotD src) %{
 4058   match(Set dst src);
 4059   ins_cost(MEMORY_REF_COST);
 4060   // TODO: s390 port size(FIXED_SIZE);
 4061   format %{ &quot;LD(Y)   $dst,$src\t # stk reload double&quot; %}
 4062   opcode(LD_ZOPC);
 4063   ins_encode(z_form_rt_mem(dst, src));
 4064   ins_pipe(pipe_class_dummy);
 4065 %}
 4066 
 4067 // Store double value to stack slot.
 4068 instruct regD_to_stkD(stackSlotD dst, regD src) %{
 4069   match(Set dst src);
 4070   ins_cost(MEMORY_REF_COST);
 4071   size(4);
 4072   format %{ &quot;STD(Y)  $src,$dst\t # stk spill double&quot; %}
 4073   opcode(STD_ZOPC);
 4074   ins_encode(z_form_rt_mem(src, dst));
 4075   ins_pipe(pipe_class_dummy);
 4076 %}
 4077 
 4078 //----------Load/Store/Move Instructions---------------------------------------
 4079 
 4080 //----------Load Instructions--------------------------------------------------
 4081 
 4082 //------------------
 4083 //  MEMORY
 4084 //------------------
 4085 
 4086 //  BYTE
 4087 // Load Byte (8bit signed)
 4088 instruct loadB(iRegI dst, memory mem) %{
 4089   match(Set dst (LoadB mem));
 4090   ins_cost(MEMORY_REF_COST);
 4091   size(Z_DISP3_SIZE);
 4092   format %{ &quot;LB      $dst, $mem\t # sign-extend byte to int&quot; %}
 4093   opcode(LB_ZOPC, LB_ZOPC);
 4094   ins_encode(z_form_rt_mem_opt(dst, mem));
 4095   ins_pipe(pipe_class_dummy);
 4096 %}
 4097 
 4098 // Load Byte (8bit signed)
 4099 instruct loadB2L(iRegL dst, memory mem) %{
 4100   match(Set dst (ConvI2L (LoadB mem)));
 4101   ins_cost(MEMORY_REF_COST);
 4102   size(Z_DISP3_SIZE);
 4103   format %{ &quot;LGB     $dst, $mem\t # sign-extend byte to long&quot; %}
 4104   opcode(LGB_ZOPC, LGB_ZOPC);
 4105   ins_encode(z_form_rt_mem_opt(dst, mem));
 4106   ins_pipe(pipe_class_dummy);
 4107 %}
 4108 
 4109 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 4110 instruct loadUB(iRegI dst, memory mem) %{
 4111   match(Set dst (LoadUB mem));
 4112   ins_cost(MEMORY_REF_COST);
 4113   size(Z_DISP3_SIZE);
 4114   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to int&quot; %}
 4115   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4116   ins_encode(z_form_rt_mem_opt(dst, mem));
 4117   ins_pipe(pipe_class_dummy);
 4118 %}
 4119 
 4120 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 4121 instruct loadUB2L(iRegL dst, memory mem) %{
 4122   match(Set dst (ConvI2L (LoadUB mem)));
 4123   ins_cost(MEMORY_REF_COST);
 4124   size(Z_DISP3_SIZE);
 4125   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to long&quot; %}
 4126   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4127   ins_encode(z_form_rt_mem_opt(dst, mem));
 4128   ins_pipe(pipe_class_dummy);
 4129 %}
 4130 
 4131 // CHAR/SHORT
 4132 
 4133 // Load Short (16bit signed)
 4134 instruct loadS(iRegI dst, memory mem) %{
 4135   match(Set dst (LoadS mem));
 4136   ins_cost(MEMORY_REF_COST);
 4137   size(Z_DISP_SIZE);
 4138   format %{ &quot;LH(Y)   $dst,$mem\t # sign-extend short to int&quot; %}
 4139   opcode(LHY_ZOPC, LH_ZOPC);
 4140   ins_encode(z_form_rt_mem_opt(dst, mem));
 4141   ins_pipe(pipe_class_dummy);
 4142 %}
 4143 
 4144 // Load Short (16bit signed)
 4145 instruct loadS2L(iRegL dst, memory mem) %{
 4146   match(Set dst (ConvI2L (LoadS mem)));
 4147   ins_cost(MEMORY_REF_COST);
 4148   size(Z_DISP3_SIZE);
 4149   format %{ &quot;LGH     $dst,$mem\t # sign-extend short to long&quot; %}
 4150   opcode(LGH_ZOPC, LGH_ZOPC);
 4151   ins_encode(z_form_rt_mem_opt(dst, mem));
 4152   ins_pipe(pipe_class_dummy);
 4153 %}
 4154 
 4155 // Load Char (16bit Unsigned)
 4156 instruct loadUS(iRegI dst, memory mem) %{
 4157   match(Set dst (LoadUS mem));
 4158   ins_cost(MEMORY_REF_COST);
 4159   size(Z_DISP3_SIZE);
 4160   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to int&quot; %}
 4161   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4162   ins_encode(z_form_rt_mem_opt(dst, mem));
 4163   ins_pipe(pipe_class_dummy);
 4164 %}
 4165 
 4166 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 4167 instruct loadUS2L(iRegL dst, memory mem) %{
 4168   match(Set dst (ConvI2L (LoadUS mem)));
 4169   ins_cost(MEMORY_REF_COST);
 4170   size(Z_DISP3_SIZE);
 4171   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to long&quot; %}
 4172   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4173   ins_encode(z_form_rt_mem_opt(dst, mem));
 4174   ins_pipe(pipe_class_dummy);
 4175 %}
 4176 
 4177 // INT
 4178 
 4179 // Load Integer
 4180 instruct loadI(iRegI dst, memory mem) %{
 4181   match(Set dst (LoadI mem));
 4182   ins_cost(MEMORY_REF_COST);
 4183   size(Z_DISP_SIZE);
 4184   format %{ &quot;L(Y)    $dst,$mem\t #&quot; %}
 4185   opcode(LY_ZOPC, L_ZOPC);
 4186   ins_encode(z_form_rt_mem_opt(dst, mem));
 4187   ins_pipe(pipe_class_dummy);
 4188 %}
 4189 
 4190 // Load and convert to long.
 4191 instruct loadI2L(iRegL dst, memory mem) %{
 4192   match(Set dst (ConvI2L (LoadI mem)));
 4193   ins_cost(MEMORY_REF_COST);
 4194   size(Z_DISP3_SIZE);
 4195   format %{ &quot;LGF     $dst,$mem\t #&quot; %}
 4196   opcode(LGF_ZOPC, LGF_ZOPC);
 4197   ins_encode(z_form_rt_mem_opt(dst, mem));
 4198   ins_pipe(pipe_class_dummy);
 4199 %}
 4200 
 4201 // Load Unsigned Integer into a Long Register
 4202 instruct loadUI2L(iRegL dst, memory mem, immL_FFFFFFFF mask) %{
 4203   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 4204   ins_cost(MEMORY_REF_COST);
 4205   size(Z_DISP3_SIZE);
 4206   format %{ &quot;LLGF    $dst,$mem\t # zero-extend int to long&quot; %}
 4207   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4208   ins_encode(z_form_rt_mem_opt(dst, mem));
 4209   ins_pipe(pipe_class_dummy);
 4210 %}
 4211 
 4212 // range = array length (=jint)
 4213 // Load Range
 4214 instruct loadRange(iRegI dst, memory mem) %{
 4215   match(Set dst (LoadRange mem));
 4216   ins_cost(MEMORY_REF_COST);
 4217   size(Z_DISP_SIZE);
 4218   format %{ &quot;L(Y)    $dst,$mem\t # range&quot; %}
 4219   opcode(LY_ZOPC, L_ZOPC);
 4220   ins_encode(z_form_rt_mem_opt(dst, mem));
 4221   ins_pipe(pipe_class_dummy);
 4222 %}
 4223 
 4224 // LONG
 4225 
 4226 // Load Long - aligned
 4227 instruct loadL(iRegL dst, memory mem) %{
 4228   match(Set dst (LoadL mem));
 4229   ins_cost(MEMORY_REF_COST);
 4230   size(Z_DISP3_SIZE);
 4231   format %{ &quot;LG      $dst,$mem\t # long&quot; %}
 4232   opcode(LG_ZOPC, LG_ZOPC);
 4233   ins_encode(z_form_rt_mem_opt(dst, mem));
 4234   ins_pipe(pipe_class_dummy);
 4235 %}
 4236 
 4237 // Load Long - UNaligned
 4238 instruct loadL_unaligned(iRegL dst, memory mem) %{
 4239   match(Set dst (LoadL_unaligned mem));
 4240   ins_cost(MEMORY_REF_COST);
 4241   size(Z_DISP3_SIZE);
 4242   format %{ &quot;LG      $dst,$mem\t # unaligned long&quot; %}
 4243   opcode(LG_ZOPC, LG_ZOPC);
 4244   ins_encode(z_form_rt_mem_opt(dst, mem));
 4245   ins_pipe(pipe_class_dummy);
 4246 %}
 4247 
 4248 
 4249 // PTR
 4250 
 4251 // Load Pointer
 4252 instruct loadP(iRegP dst, memory mem) %{
 4253   match(Set dst (LoadP mem));
 4254   ins_cost(MEMORY_REF_COST);
 4255   size(Z_DISP3_SIZE);
 4256   format %{ &quot;LG      $dst,$mem\t # ptr&quot; %}
 4257   opcode(LG_ZOPC, LG_ZOPC);
 4258   ins_encode(z_form_rt_mem_opt(dst, mem));
 4259   ins_pipe(pipe_class_dummy);
 4260 %}
 4261 
 4262 // LoadP + CastP2L
 4263 instruct castP2X_loadP(iRegL dst, memory mem) %{
 4264   match(Set dst (CastP2X (LoadP mem)));
 4265   ins_cost(MEMORY_REF_COST);
 4266   size(Z_DISP3_SIZE);
 4267   format %{ &quot;LG      $dst,$mem\t # ptr + p2x&quot; %}
 4268   opcode(LG_ZOPC, LG_ZOPC);
 4269   ins_encode(z_form_rt_mem_opt(dst, mem));
 4270   ins_pipe(pipe_class_dummy);
 4271 %}
 4272 
 4273 // Load Klass Pointer
 4274 instruct loadKlass(iRegP dst, memory mem) %{
 4275   match(Set dst (LoadKlass mem));
 4276   ins_cost(MEMORY_REF_COST);
 4277   size(Z_DISP3_SIZE);
 4278   format %{ &quot;LG      $dst,$mem\t # klass ptr&quot; %}
 4279   opcode(LG_ZOPC, LG_ZOPC);
 4280   ins_encode(z_form_rt_mem_opt(dst, mem));
 4281   ins_pipe(pipe_class_dummy);
 4282 %}
 4283 
 4284 instruct loadTOC(iRegL dst) %{
 4285   effect(DEF dst);
 4286   ins_cost(DEFAULT_COST);
 4287   // TODO: s390 port size(FIXED_SIZE);
 4288   // TODO: check why this attribute causes many unnecessary rematerializations.
 4289   //
 4290   // The graphs I saw just had high register pressure. Further the
 4291   // register TOC is loaded to is overwritten by the constant short
 4292   // after. Here something as round robin register allocation might
 4293   // help. But rematerializing seems not to hurt, jack even seems to
 4294   // improve slightly.
 4295   //
 4296   // Without this flag we get spill-split recycle sanity check
 4297   // failures in
 4298   // spec.benchmarks._228_jack.NfaState::GenerateCode. This happens in
 4299   // a block with three loadConP_dynTOC nodes and a tlsLoadP. The
 4300   // tlsLoadP has a huge amount of outs and forces the TOC down to the
 4301   // stack. Later tlsLoadP is rematerialized, leaving the register
 4302   // allocator with TOC on the stack and a badly placed reload.
 4303   ins_should_rematerialize(true);
 4304   format %{ &quot;LARL    $dst, &amp;constant_pool\t; load dynTOC&quot; %}
 4305   ins_encode %{ __ load_toc($dst$$Register); %}
 4306   ins_pipe(pipe_class_dummy);
 4307 %}
 4308 
 4309 // FLOAT
 4310 
 4311 // Load Float
 4312 instruct loadF(regF dst, memory mem) %{
 4313   match(Set dst (LoadF mem));
 4314   ins_cost(MEMORY_REF_COST);
 4315   size(Z_DISP_SIZE);
 4316   format %{ &quot;LE(Y)    $dst,$mem&quot; %}
 4317   opcode(LEY_ZOPC, LE_ZOPC);
 4318   ins_encode(z_form_rt_mem_opt(dst, mem));
 4319   ins_pipe(pipe_class_dummy);
 4320 %}
 4321 
 4322 // DOUBLE
 4323 
 4324 // Load Double
 4325 instruct loadD(regD dst, memory mem) %{
 4326   match(Set dst (LoadD mem));
 4327   ins_cost(MEMORY_REF_COST);
 4328   size(Z_DISP_SIZE);
 4329   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4330   opcode(LDY_ZOPC, LD_ZOPC);
 4331   ins_encode(z_form_rt_mem_opt(dst, mem));
 4332   ins_pipe(pipe_class_dummy);
 4333 %}
 4334 
 4335 // Load Double - UNaligned
 4336 instruct loadD_unaligned(regD dst, memory mem) %{
 4337   match(Set dst (LoadD_unaligned mem));
 4338   ins_cost(MEMORY_REF_COST);
 4339   size(Z_DISP_SIZE);
 4340   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4341   opcode(LDY_ZOPC, LD_ZOPC);
 4342   ins_encode(z_form_rt_mem_opt(dst, mem));
 4343   ins_pipe(pipe_class_dummy);
 4344 %}
 4345 
 4346 
 4347 //----------------------
 4348 //  IMMEDIATES
 4349 //----------------------
 4350 
 4351 instruct loadConI(iRegI dst, immI src) %{
 4352   match(Set dst src);
 4353   ins_cost(DEFAULT_COST);
 4354   size(6);
 4355   format %{ &quot;LGFI    $dst,$src\t # (int)&quot; %}
 4356   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4357   ins_pipe(pipe_class_dummy);
 4358 %}
 4359 
 4360 instruct loadConI16(iRegI dst, immI16 src) %{
 4361   match(Set dst src);
 4362   ins_cost(DEFAULT_COST_LOW);
 4363   size(4);
 4364   format %{ &quot;LGHI    $dst,$src\t # (int)&quot; %}
 4365   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4366   ins_pipe(pipe_class_dummy);
 4367 %}
 4368 
 4369 instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
 4370   match(Set dst src);
 4371   effect(KILL cr);
 4372   ins_cost(DEFAULT_COST_LOW);
 4373   size(4);
 4374   format %{ &quot;loadConI $dst,$src\t # (int) XGR because ZERO is loaded&quot; %}
 4375   opcode(XGR_ZOPC);
 4376   ins_encode(z_rreform(dst, dst));
 4377   ins_pipe(pipe_class_dummy);
 4378 %}
 4379 
 4380 instruct loadConUI16(iRegI dst, uimmI16 src) %{
 4381   match(Set dst src);
 4382   // TODO: s390 port size(FIXED_SIZE);
 4383   format %{ &quot;LLILL    $dst,$src&quot; %}
 4384   opcode(LLILL_ZOPC);
 4385   ins_encode(z_riform_unsigned(dst, src) );
 4386   ins_pipe(pipe_class_dummy);
 4387 %}
 4388 
 4389 // Load long constant from TOC with pcrelative address.
 4390 instruct loadConL_pcrelTOC(iRegL dst, immL src) %{
 4391   match(Set dst src);
 4392   ins_cost(MEMORY_REF_COST_LO);
 4393   size(6);
 4394   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load long $src from table&quot; %}
 4395   ins_encode %{
 4396     address long_address = __ long_constant($src$$constant);
 4397     if (long_address == NULL) {
 4398       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4399       return;
 4400     }
 4401     __ load_long_pcrelative($dst$$Register, long_address);
 4402   %}
 4403   ins_pipe(pipe_class_dummy);
 4404 %}
 4405 
 4406 instruct loadConL32(iRegL dst, immL32 src) %{
 4407   match(Set dst src);
 4408   ins_cost(DEFAULT_COST);
 4409   size(6);
 4410   format %{ &quot;LGFI     $dst,$src\t # (long)&quot; %}
 4411   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4412   ins_pipe(pipe_class_dummy);
 4413 %}
 4414 
 4415 instruct loadConL16(iRegL dst, immL16 src) %{
 4416   match(Set dst src);
 4417   ins_cost(DEFAULT_COST_LOW);
 4418   size(4);
 4419   format %{ &quot;LGHI     $dst,$src\t # (long)&quot; %}
 4420   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4421   ins_pipe(pipe_class_dummy);
 4422 %}
 4423 
 4424 instruct loadConL_0(iRegL dst, immL_0 src, flagsReg cr) %{
 4425   match(Set dst src);
 4426   effect(KILL cr);
 4427   ins_cost(DEFAULT_COST_LOW);
 4428   format %{ &quot;LoadConL    $dst,$src\t # (long) XGR because ZERO is loaded&quot; %}
 4429   opcode(XGR_ZOPC);
 4430   ins_encode(z_rreform(dst, dst));
 4431   ins_pipe(pipe_class_dummy);
 4432 %}
 4433 
 4434 // Load ptr constant from TOC with pc relative address.
 4435 // Special handling for oop constants required.
 4436 instruct loadConP_pcrelTOC(iRegP dst, immP src) %{
 4437   match(Set dst src);
 4438   ins_cost(MEMORY_REF_COST_LO);
 4439   size(6);
 4440   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load ptr $src from table&quot; %}
 4441   ins_encode %{
 4442     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();
 4443     if (constant_reloc == relocInfo::oop_type) {
 4444       AddressLiteral a = __ allocate_oop_address((jobject)$src$$constant);
 4445       bool success = __ load_oop_from_toc($dst$$Register, a);
 4446       if (!success) {
 4447         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4448         return;
 4449       }
 4450     } else if (constant_reloc == relocInfo::metadata_type) {
 4451       AddressLiteral a = __ constant_metadata_address((Metadata *)$src$$constant);
 4452       address const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 4453       if (const_toc_addr == NULL) {
 4454         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4455         return;
 4456       }
 4457       __ load_long_pcrelative($dst$$Register, const_toc_addr);
 4458     } else {          // Non-oop pointers, e.g. card mark base, heap top.
 4459       address long_address = __ long_constant((jlong)$src$$constant);
 4460       if (long_address == NULL) {
 4461         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4462         return;
 4463       }
 4464       __ load_long_pcrelative($dst$$Register, long_address);
 4465     }
 4466   %}
 4467   ins_pipe(pipe_class_dummy);
 4468 %}
 4469 
 4470 // We don&#39;t use immP16 to avoid problems with oops.
 4471 instruct loadConP0(iRegP dst, immP0 src, flagsReg cr) %{
 4472   match(Set dst src);
 4473   effect(KILL cr);
 4474   size(4);
 4475   format %{ &quot;XGR     $dst,$dst\t # NULL ptr&quot; %}
 4476   opcode(XGR_ZOPC);
 4477   ins_encode(z_rreform(dst, dst));
 4478   ins_pipe(pipe_class_dummy);
 4479 %}
 4480 
 4481 //----------Load Float Constant Instructions-------------------------------------------------
 4482 
 4483 // We may not specify this instruction via an `expand&#39; rule. If we do,
 4484 // code selection will forget that this instruction needs a floating
 4485 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4486 // will fail.
 4487 instruct loadConF_dynTOC(regF dst, immF src, flagsReg cr) %{
 4488   match(Set dst src);
 4489   effect(KILL cr);
 4490   ins_cost(MEMORY_REF_COST);
 4491   size(6);
 4492   // If this instruction rematerializes, it prolongs the live range
 4493   // of the toc node, causing illegal graphs.
 4494   ins_cannot_rematerialize(true);
 4495   format %{ &quot;LE(Y)    $dst,$constantoffset[,$constanttablebase]\t # load FLOAT $src from table&quot; %}
 4496   ins_encode %{
 4497     __ load_float_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4498   %}
 4499   ins_pipe(pipe_class_dummy);
 4500 %}
 4501 
 4502 // E may not specify this instruction via an `expand&#39; rule. If we do,
 4503 // code selection will forget that this instruction needs a floating
 4504 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4505 // will fail.
 4506 instruct loadConD_dynTOC(regD dst, immD src, flagsReg cr) %{
 4507   match(Set dst src);
 4508   effect(KILL cr);
 4509   ins_cost(MEMORY_REF_COST);
 4510   size(6);
 4511   // If this instruction rematerializes, it prolongs the live range
 4512   // of the toc node, causing illegal graphs.
 4513   ins_cannot_rematerialize(true);
 4514   format %{ &quot;LD(Y)    $dst,$constantoffset[,$constanttablebase]\t # load DOUBLE $src from table&quot; %}
 4515   ins_encode %{
 4516     __ load_double_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4517   %}
 4518   ins_pipe(pipe_class_dummy);
 4519 %}
 4520 
 4521 // Special case: Load Const 0.0F
 4522 
 4523 // There&#39;s a special instr to clear a FP register.
 4524 instruct loadConF0(regF dst, immFp0 src) %{
 4525   match(Set dst src);
 4526   ins_cost(DEFAULT_COST_LOW);
 4527   size(4);
 4528   format %{ &quot;LZER     $dst,$src\t # clear to zero&quot; %}
 4529   opcode(LZER_ZOPC);
 4530   ins_encode(z_rreform(dst, Z_F0));
 4531   ins_pipe(pipe_class_dummy);
 4532 %}
 4533 
 4534 // There&#39;s a special instr to clear a FP register.
 4535 instruct loadConD0(regD dst, immDp0 src) %{
 4536   match(Set dst src);
 4537   ins_cost(DEFAULT_COST_LOW);
 4538   size(4);
 4539   format %{ &quot;LZDR     $dst,$src\t # clear to zero&quot; %}
 4540   opcode(LZDR_ZOPC);
 4541   ins_encode(z_rreform(dst, Z_F0));
 4542   ins_pipe(pipe_class_dummy);
 4543 %}
 4544 
 4545 
 4546 //----------Store Instructions-------------------------------------------------
 4547 
 4548 // BYTE
 4549 
 4550 // Store Byte
 4551 instruct storeB(memory mem, iRegI src) %{
 4552   match(Set mem (StoreB mem src));
 4553   ins_cost(MEMORY_REF_COST);
 4554   size(Z_DISP_SIZE);
 4555   format %{ &quot;STC(Y)  $src,$mem\t # byte&quot; %}
 4556   opcode(STCY_ZOPC, STC_ZOPC);
 4557   ins_encode(z_form_rt_mem_opt(src, mem));
 4558   ins_pipe(pipe_class_dummy);
 4559 %}
 4560 
 4561 instruct storeCM(memory mem, immI_0 src) %{
 4562   match(Set mem (StoreCM mem src));
 4563   ins_cost(MEMORY_REF_COST);
 4564   // TODO: s390 port size(VARIABLE_SIZE);
 4565   format %{ &quot;STC(Y)  $src,$mem\t # CMS card-mark byte (must be 0!)&quot; %}
 4566   ins_encode %{
 4567     guarantee($mem$$index$$Register != Z_R0, &quot;content will not be used.&quot;);
 4568     if ($mem$$index$$Register != noreg) {
 4569       // Can&#39;t use clear_mem --&gt; load const zero and store character.
 4570       __ load_const_optimized(Z_R0_scratch, (long)0);
 4571       if (Immediate::is_uimm12($mem$$disp)) {
 4572         __ z_stc(Z_R0_scratch, $mem$$Address);
 4573       } else {
 4574         __ z_stcy(Z_R0_scratch, $mem$$Address);
 4575       }
 4576     } else {
 4577       __ clear_mem(Address($mem$$Address), 1);
 4578     }
 4579   %}
 4580   ins_pipe(pipe_class_dummy);
 4581 %}
 4582 
 4583 // CHAR/SHORT
 4584 
 4585 // Store Char/Short
 4586 instruct storeC(memory mem, iRegI src) %{
 4587   match(Set mem (StoreC mem src));
 4588   ins_cost(MEMORY_REF_COST);
 4589   size(Z_DISP_SIZE);
 4590   format %{ &quot;STH(Y)  $src,$mem\t # short&quot; %}
 4591   opcode(STHY_ZOPC, STH_ZOPC);
 4592   ins_encode(z_form_rt_mem_opt(src, mem));
 4593   ins_pipe(pipe_class_dummy);
 4594 %}
 4595 
 4596 // INT
 4597 
 4598 // Store Integer
 4599 instruct storeI(memory mem, iRegI src) %{
 4600   match(Set mem (StoreI mem src));
 4601   ins_cost(MEMORY_REF_COST);
 4602   size(Z_DISP_SIZE);
 4603   format %{ &quot;ST(Y)   $src,$mem\t # int&quot; %}
 4604   opcode(STY_ZOPC, ST_ZOPC);
 4605   ins_encode(z_form_rt_mem_opt(src, mem));
 4606   ins_pipe(pipe_class_dummy);
 4607 %}
 4608 
 4609 // LONG
 4610 
 4611 // Store Long
 4612 instruct storeL(memory mem, iRegL src) %{
 4613   match(Set mem (StoreL mem src));
 4614   ins_cost(MEMORY_REF_COST);
 4615   size(Z_DISP3_SIZE);
 4616   format %{ &quot;STG     $src,$mem\t # long&quot; %}
 4617   opcode(STG_ZOPC, STG_ZOPC);
 4618   ins_encode(z_form_rt_mem_opt(src, mem));
 4619   ins_pipe(pipe_class_dummy);
 4620 %}
 4621 
 4622 // PTR
 4623 
 4624 // Store Pointer
 4625 instruct storeP(memory dst, memoryRegP src) %{
 4626   match(Set dst (StoreP dst src));
 4627   ins_cost(MEMORY_REF_COST);
 4628   size(Z_DISP3_SIZE);
 4629   format %{ &quot;STG     $src,$dst\t # ptr&quot; %}
 4630   opcode(STG_ZOPC, STG_ZOPC);
 4631   ins_encode(z_form_rt_mem_opt(src, dst));
 4632   ins_pipe(pipe_class_dummy);
 4633 %}
 4634 
 4635 // FLOAT
 4636 
 4637 // Store Float
 4638 instruct storeF(memory mem, regF src) %{
 4639   match(Set mem (StoreF mem src));
 4640   ins_cost(MEMORY_REF_COST);
 4641   size(Z_DISP_SIZE);
 4642   format %{ &quot;STE(Y)   $src,$mem\t # float&quot; %}
 4643   opcode(STEY_ZOPC, STE_ZOPC);
 4644   ins_encode(z_form_rt_mem_opt(src, mem));
 4645   ins_pipe(pipe_class_dummy);
 4646 %}
 4647 
 4648 // DOUBLE
 4649 
 4650 // Store Double
 4651 instruct storeD(memory mem, regD src) %{
 4652   match(Set mem (StoreD mem src));
 4653   ins_cost(MEMORY_REF_COST);
 4654   size(Z_DISP_SIZE);
 4655   format %{ &quot;STD(Y)   $src,$mem\t # double&quot; %}
 4656   opcode(STDY_ZOPC, STD_ZOPC);
 4657   ins_encode(z_form_rt_mem_opt(src, mem));
 4658   ins_pipe(pipe_class_dummy);
 4659 %}
 4660 
 4661 // Prefetch instructions. Must be safe to execute with invalid address (cannot fault).
 4662 
 4663 // Should support match rule for PrefetchAllocation.
 4664 // Still needed after 8068977 for PrefetchAllocate.
 4665 instruct prefetchAlloc(memory mem) %{
 4666   match(PrefetchAllocation mem);
 4667   predicate(VM_Version::has_Prefetch());
 4668   ins_cost(DEFAULT_COST);
 4669   format %{ &quot;PREFETCH 2, $mem\t # Prefetch allocation, z10 only&quot; %}
 4670   ins_encode %{ __ z_pfd(0x02, $mem$$Address); %}
 4671   ins_pipe(pipe_class_dummy);
 4672 %}
 4673 
 4674 //----------Memory init instructions------------------------------------------
 4675 
 4676 // Move Immediate to 1-byte memory.
 4677 instruct memInitB(memoryRSY mem, immI8 src) %{
 4678   match(Set mem (StoreB mem src));
 4679   ins_cost(MEMORY_REF_COST);
 4680   // TODO: s390 port size(VARIABLE_SIZE);
 4681   format %{ &quot;MVI     $mem,$src\t # direct mem init 1&quot; %}
 4682   ins_encode %{
 4683     if (Immediate::is_uimm12((long)$mem$$disp)) {
 4684       __ z_mvi($mem$$Address, $src$$constant);
 4685     } else {
 4686       __ z_mviy($mem$$Address, $src$$constant);
 4687     }
 4688   %}
 4689   ins_pipe(pipe_class_dummy);
 4690 %}
 4691 
 4692 // Move Immediate to 2-byte memory.
 4693 instruct memInitC(memoryRS mem, immI16 src) %{
 4694   match(Set mem (StoreC mem src));
 4695   ins_cost(MEMORY_REF_COST);
 4696   size(6);
 4697   format %{ &quot;MVHHI   $mem,$src\t # direct mem init 2&quot; %}
 4698   opcode(MVHHI_ZOPC);
 4699   ins_encode(z_silform(mem, src));
 4700   ins_pipe(pipe_class_dummy);
 4701 %}
 4702 
 4703 // Move Immediate to 4-byte memory.
 4704 instruct memInitI(memoryRS mem, immI16 src) %{
 4705   match(Set mem (StoreI mem src));
 4706   ins_cost(MEMORY_REF_COST);
 4707   size(6);
 4708   format %{ &quot;MVHI    $mem,$src\t # direct mem init 4&quot; %}
 4709   opcode(MVHI_ZOPC);
 4710   ins_encode(z_silform(mem, src));
 4711   ins_pipe(pipe_class_dummy);
 4712 %}
 4713 
 4714 
 4715 // Move Immediate to 8-byte memory.
 4716 instruct memInitL(memoryRS mem, immL16 src) %{
 4717   match(Set mem (StoreL mem src));
 4718   ins_cost(MEMORY_REF_COST);
 4719   size(6);
 4720   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4721   opcode(MVGHI_ZOPC);
 4722   ins_encode(z_silform(mem, src));
 4723   ins_pipe(pipe_class_dummy);
 4724 %}
 4725 
 4726 // Move Immediate to 8-byte memory.
 4727 instruct memInitP(memoryRS mem, immP16 src) %{
 4728   match(Set mem (StoreP mem src));
 4729   ins_cost(MEMORY_REF_COST);
 4730   size(6);
 4731   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4732   opcode(MVGHI_ZOPC);
 4733   ins_encode(z_silform(mem, src));
 4734   ins_pipe(pipe_class_dummy);
 4735 %}
 4736 
 4737 
 4738 //----------Instructions for compressed pointers (cOop and NKlass)-------------
 4739 
 4740 // See cOop encoding classes for elaborate comment.
 4741 
 4742 // Moved here because it is needed in expand rules for encode.
 4743 // Long negation.
 4744 instruct negL_reg_reg(iRegL dst, immL_0 zero, iRegL src, flagsReg cr) %{
 4745   match(Set dst (SubL zero src));
 4746   effect(KILL cr);
 4747   size(4);
 4748   format %{ &quot;NEG     $dst, $src\t # long&quot; %}
 4749   ins_encode %{ __ z_lcgr($dst$$Register, $src$$Register); %}
 4750   ins_pipe(pipe_class_dummy);
 4751 %}
 4752 
 4753 // Load Compressed Pointer
 4754 
 4755 // Load narrow oop
 4756 instruct loadN(iRegN dst, memory mem) %{
 4757   match(Set dst (LoadN mem));
 4758   ins_cost(MEMORY_REF_COST);
 4759   size(Z_DISP3_SIZE);
 4760   format %{ &quot;LoadN   $dst,$mem\t # (cOop)&quot; %}
 4761   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4762   ins_encode(z_form_rt_mem_opt(dst, mem));
 4763   ins_pipe(pipe_class_dummy);
 4764 %}
 4765 
 4766 // Load narrow Klass Pointer
 4767 instruct loadNKlass(iRegN dst, memory mem) %{
 4768   match(Set dst (LoadNKlass mem));
 4769   ins_cost(MEMORY_REF_COST);
 4770   size(Z_DISP3_SIZE);
 4771   format %{ &quot;LoadNKlass $dst,$mem\t # (klass cOop)&quot; %}
 4772   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4773   ins_encode(z_form_rt_mem_opt(dst, mem));
 4774   ins_pipe(pipe_class_dummy);
 4775 %}
 4776 
 4777 // Load constant Compressed Pointer
 4778 
 4779 instruct loadConN(iRegN dst, immN src) %{
 4780   match(Set dst src);
 4781   ins_cost(DEFAULT_COST);
 4782   size(6);
 4783   format %{ &quot;loadConN    $dst,$src\t # (cOop)&quot; %}
 4784   ins_encode %{
 4785     AddressLiteral cOop = __ constant_oop_address((jobject)$src$$constant);
 4786     __ relocate(cOop.rspec(), 1);
 4787     __ load_narrow_oop($dst$$Register, (narrowOop)cOop.value());
 4788   %}
 4789   ins_pipe(pipe_class_dummy);
 4790 %}
 4791 
 4792 instruct loadConN0(iRegN dst, immN0 src, flagsReg cr) %{
 4793   match(Set dst src);
 4794   effect(KILL cr);
 4795   ins_cost(DEFAULT_COST_LOW);
 4796   size(4);
 4797   format %{ &quot;loadConN    $dst,$src\t # (cOop) XGR because ZERO is loaded&quot; %}
 4798   opcode(XGR_ZOPC);
 4799   ins_encode(z_rreform(dst, dst));
 4800   ins_pipe(pipe_class_dummy);
 4801 %}
 4802 
 4803 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 4804   match(Set dst src);
 4805   ins_cost(DEFAULT_COST);
 4806   size(6);
 4807   format %{ &quot;loadConNKlass $dst,$src\t # (cKlass)&quot; %}
 4808   ins_encode %{
 4809     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4810     __ relocate(NKlass.rspec(), 1);
 4811     __ load_narrow_klass($dst$$Register, (Klass*)NKlass.value());
 4812   %}
 4813   ins_pipe(pipe_class_dummy);
 4814 %}
 4815 
 4816 // Load and Decode Compressed Pointer
 4817 // optimized variants for Unscaled cOops
 4818 
 4819 instruct decodeLoadN(iRegP dst, memory mem) %{
 4820   match(Set dst (DecodeN (LoadN mem)));
 4821   predicate(false &amp;&amp; (CompressedOops::base()==NULL)&amp;&amp;(CompressedOops::shift()==0));
 4822   ins_cost(MEMORY_REF_COST);
 4823   size(Z_DISP3_SIZE);
 4824   format %{ &quot;DecodeLoadN  $dst,$mem\t # (cOop Load+Decode)&quot; %}
 4825   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4826   ins_encode(z_form_rt_mem_opt(dst, mem));
 4827   ins_pipe(pipe_class_dummy);
 4828 %}
 4829 
 4830 instruct decodeLoadNKlass(iRegP dst, memory mem) %{
 4831   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 4832   predicate(false &amp;&amp; (CompressedKlassPointers::base()==NULL)&amp;&amp;(CompressedKlassPointers::shift()==0));
 4833   ins_cost(MEMORY_REF_COST);
 4834   size(Z_DISP3_SIZE);
 4835   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t # (load/decode NKlass)&quot; %}
 4836   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4837   ins_encode(z_form_rt_mem_opt(dst, mem));
 4838   ins_pipe(pipe_class_dummy);
 4839 %}
 4840 
 4841 instruct decodeLoadConNKlass(iRegP dst, immNKlass src) %{
 4842   match(Set dst (DecodeNKlass src));
 4843   ins_cost(3 * DEFAULT_COST);
 4844   size(12);
 4845   format %{ &quot;DecodeLoadConNKlass  $dst,$src\t # decode(cKlass)&quot; %}
 4846   ins_encode %{
 4847     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4848     __ relocate(NKlass.rspec(), 1);
 4849     __ load_const($dst$$Register, (Klass*)NKlass.value());
 4850   %}
 4851   ins_pipe(pipe_class_dummy);
 4852 %}
 4853 
 4854 // Decode Compressed Pointer
 4855 
 4856 // General decoder
 4857 instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
 4858   match(Set dst (DecodeN src));
 4859   effect(KILL cr);
 4860   predicate(CompressedOops::base() == NULL || !ExpandLoadingBaseDecode);
 4861   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4862   // TODO: s390 port size(VARIABLE_SIZE);
 4863   format %{ &quot;decodeN  $dst,$src\t # (decode cOop)&quot; %}
 4864   ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
 4865   ins_pipe(pipe_class_dummy);
 4866 %}
 4867 
 4868 // General Klass decoder
 4869 instruct decodeKlass(iRegP dst, iRegN src, flagsReg cr) %{
 4870   match(Set dst (DecodeNKlass src));
 4871   effect(KILL cr);
 4872   ins_cost(3 * DEFAULT_COST);
 4873   format %{ &quot;decode_klass $dst,$src&quot; %}
 4874   ins_encode %{ __ decode_klass_not_null($dst$$Register, $src$$Register); %}
 4875   ins_pipe(pipe_class_dummy);
 4876 %}
 4877 
 4878 // General decoder
 4879 instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
 4880   match(Set dst (DecodeN src));
 4881   effect(KILL cr);
 4882   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4883              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4884             (CompressedOops::base()== NULL || !ExpandLoadingBaseDecode_NN));
 4885   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4886   // TODO: s390 port size(VARIABLE_SIZE);
 4887   format %{ &quot;decodeN  $dst,$src\t # (decode cOop NN)&quot; %}
 4888   ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
 4889   ins_pipe(pipe_class_dummy);
 4890 %}
 4891 
 4892   instruct loadBase(iRegL dst, immL baseImm) %{
 4893     effect(DEF dst, USE baseImm);
 4894     predicate(false);
 4895     format %{ &quot;llihl    $dst=$baseImm \t// load heap base&quot; %}
 4896     ins_encode %{ __ get_oop_base($dst$$Register, $baseImm$$constant); %}
 4897     ins_pipe(pipe_class_dummy);
 4898   %}
 4899 
 4900   // Decoder for heapbased mode peeling off loading the base.
 4901   instruct decodeN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4902     match(Set dst (DecodeN src base));
 4903     // Note: Effect TEMP dst was used with the intention to get
 4904     // different regs for dst and base, but this has caused ADLC to
 4905     // generate wrong code. Oop_decoder generates additional lgr when
 4906     // dst==base.
 4907     effect(KILL cr);
 4908     predicate(false);
 4909     // TODO: s390 port size(VARIABLE_SIZE);
 4910     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4911     ins_encode %{
 4912       __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
 4913                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4914     %}
 4915     ins_pipe(pipe_class_dummy);
 4916   %}
 4917 
 4918   // Decoder for heapbased mode peeling off loading the base.
 4919   instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4920     match(Set dst (DecodeN src base));
 4921     effect(KILL cr);
 4922     predicate(false);
 4923     // TODO: s390 port size(VARIABLE_SIZE);
 4924     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4925     ins_encode %{
 4926       __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
 4927                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4928     %}
 4929     ins_pipe(pipe_class_dummy);
 4930   %}
 4931 
 4932 // Decoder for heapbased mode peeling off loading the base.
 4933 instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4934   match(Set dst (DecodeN src));
 4935   predicate(CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode);
 4936   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4937   // TODO: s390 port size(VARIABLE_SIZE);
 4938   expand %{
 4939     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4940     iRegL base;
 4941     loadBase(base, baseImm);
 4942     decodeN_base(dst, src, base, cr);
 4943   %}
 4944 %}
 4945 
 4946 // Decoder for heapbased mode peeling off loading the base.
 4947 instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4948   match(Set dst (DecodeN src));
 4949   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4950              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4951             CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);
 4952   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4953   // TODO: s390 port size(VARIABLE_SIZE);
 4954   expand %{
 4955     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4956     iRegL base;
 4957     loadBase(base, baseImm);
 4958     decodeN_NN_base(dst, src, base, cr);
 4959   %}
 4960 %}
 4961 
 4962 //  Encode Compressed Pointer
 4963 
 4964 // General encoder
 4965 instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
 4966   match(Set dst (EncodeP src));
 4967   effect(KILL cr);
 4968   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 4969             (CompressedOops::base() == 0 ||
 4970              CompressedOops::base_disjoint() ||
 4971              !ExpandLoadingBaseEncode));
 4972   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4973   // TODO: s390 port size(VARIABLE_SIZE);
 4974   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 4975   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4976   ins_pipe(pipe_class_dummy);
 4977 %}
 4978 
 4979 // General class encoder
 4980 instruct encodeKlass(iRegN dst, iRegP src, flagsReg cr) %{
 4981   match(Set dst (EncodePKlass src));
 4982   effect(KILL cr);
 4983   format %{ &quot;encode_klass $dst,$src&quot; %}
 4984   ins_encode %{ __ encode_klass_not_null($dst$$Register, $src$$Register); %}
 4985   ins_pipe(pipe_class_dummy);
 4986 %}
 4987 
 4988 instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
 4989   match(Set dst (EncodeP src));
 4990   effect(KILL cr);
 4991   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 4992             (CompressedOops::base() == 0 ||
 4993              CompressedOops::base_disjoint() ||
 4994              !ExpandLoadingBaseEncode_NN));
 4995   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4996   // TODO: s390 port size(VARIABLE_SIZE);
 4997   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 4998   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4999   ins_pipe(pipe_class_dummy);
 5000 %}
 5001 
 5002   // Encoder for heapbased mode peeling off loading the base.
 5003   instruct encodeP_base(iRegN dst, iRegP src, iRegL base) %{
 5004     match(Set dst (EncodeP src (Binary base dst)));
 5005     effect(TEMP_DEF dst);
 5006     predicate(false);
 5007     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5008     // TODO: s390 port size(VARIABLE_SIZE);
 5009     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t # (encode cOop)&quot; %}
 5010     ins_encode %{
 5011       jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
 5012         (((uint64_t)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift());
 5013       __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
 5014     %}
 5015     ins_pipe(pipe_class_dummy);
 5016   %}
 5017 
 5018   // Encoder for heapbased mode peeling off loading the base.
 5019   instruct encodeP_NN_base(iRegN dst, iRegP src, iRegL base, immL pow2_offset) %{
 5020     match(Set dst (EncodeP src base));
 5021     effect(USE pow2_offset);
 5022     predicate(false);
 5023     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5024     // TODO: s390 port size(VARIABLE_SIZE);
 5025     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t # (encode cOop)&quot; %}
 5026     ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
 5027     ins_pipe(pipe_class_dummy);
 5028   %}
 5029 
 5030 // Encoder for heapbased mode peeling off loading the base.
 5031 instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5032   match(Set dst (EncodeP src));
 5033   effect(KILL cr);
 5034   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 5035             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));
 5036   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5037   // TODO: s390 port size(VARIABLE_SIZE);
 5038   expand %{
 5039     immL baseImm %{ ((jlong)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift() %}
 5040     immL_0 zero %{ (0) %}
 5041     flagsReg ccr;
 5042     iRegL base;
 5043     iRegL negBase;
 5044     loadBase(base, baseImm);
 5045     negL_reg_reg(negBase, zero, base, ccr);
 5046     encodeP_base(dst, src, negBase);
 5047   %}
 5048 %}
 5049 
 5050 // Encoder for heapbased mode peeling off loading the base.
 5051 instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5052   match(Set dst (EncodeP src));
 5053   effect(KILL cr);
 5054   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 5055             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));
 5056   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5057   // TODO: s390 port size(VARIABLE_SIZE);
 5058   expand %{
 5059     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 5060     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)CompressedOops::base())) %}
 5061     immL_0 zero %{ 0 %}
 5062     flagsReg ccr;
 5063     iRegL base;
 5064     iRegL negBase;
 5065     loadBase(base, baseImm);
 5066     negL_reg_reg(negBase, zero, base, ccr);
 5067     encodeP_NN_base(dst, src, negBase, pow2_offset);
 5068   %}
 5069 %}
 5070 
 5071 //  Store Compressed Pointer
 5072 
 5073 // Store Compressed Pointer
 5074 instruct storeN(memory mem, iRegN_P2N src) %{
 5075   match(Set mem (StoreN mem src));
 5076   ins_cost(MEMORY_REF_COST);
 5077   size(Z_DISP_SIZE);
 5078   format %{ &quot;ST      $src,$mem\t # (cOop)&quot; %}
 5079   opcode(STY_ZOPC, ST_ZOPC);
 5080   ins_encode(z_form_rt_mem_opt(src, mem));
 5081   ins_pipe(pipe_class_dummy);
 5082 %}
 5083 
 5084 // Store Compressed Klass pointer
 5085 instruct storeNKlass(memory mem, iRegN src) %{
 5086   match(Set mem (StoreNKlass mem src));
 5087   ins_cost(MEMORY_REF_COST);
 5088   size(Z_DISP_SIZE);
 5089   format %{ &quot;ST      $src,$mem\t # (cKlass)&quot; %}
 5090   opcode(STY_ZOPC, ST_ZOPC);
 5091   ins_encode(z_form_rt_mem_opt(src, mem));
 5092   ins_pipe(pipe_class_dummy);
 5093 %}
 5094 
 5095 // Compare Compressed Pointers
 5096 
 5097 instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
 5098   match(Set cr (CmpN src1 src2));
 5099   ins_cost(DEFAULT_COST);
 5100   size(2);
 5101   format %{ &quot;CLR     $src1,$src2\t # (cOop)&quot; %}
 5102   opcode(CLR_ZOPC);
 5103   ins_encode(z_rrform(src1, src2));
 5104   ins_pipe(pipe_class_dummy);
 5105 %}
 5106 
 5107 instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
 5108   match(Set cr (CmpN src1 src2));
 5109   ins_cost(DEFAULT_COST);
 5110   size(6);
 5111   format %{ &quot;CLFI    $src1,$src2\t # (cOop) compare immediate narrow&quot; %}
 5112   ins_encode %{
 5113     AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
 5114     __ relocate(cOop.rspec(), 1);
 5115     __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
 5116   %}
 5117   ins_pipe(pipe_class_dummy);
 5118 %}
 5119 
 5120 instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
 5121   match(Set cr (CmpN src1 src2));
 5122   ins_cost(DEFAULT_COST);
 5123   size(6);
 5124   format %{ &quot;CLFI    $src1,$src2\t # (NKlass) compare immediate narrow&quot; %}
 5125   ins_encode %{
 5126     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
 5127     __ relocate(NKlass.rspec(), 1);
 5128     __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
 5129   %}
 5130   ins_pipe(pipe_class_dummy);
 5131 %}
 5132 
 5133 instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
 5134   match(Set cr (CmpN src1 src2));
 5135   ins_cost(DEFAULT_COST);
 5136   size(2);
 5137   format %{ &quot;LTR     $src1,$src2\t # (cOop) LTR because comparing against zero&quot; %}
 5138   opcode(LTR_ZOPC);
 5139   ins_encode(z_rrform(src1, src1));
 5140   ins_pipe(pipe_class_dummy);
 5141 %}
 5142 
 5143 
 5144 //----------MemBar Instructions-----------------------------------------------
 5145 
 5146 // Memory barrier flavors
 5147 
 5148 instruct membar_acquire() %{
 5149   match(MemBarAcquire);
 5150   match(LoadFence);
 5151   ins_cost(4*MEMORY_REF_COST);
 5152   size(0);
 5153   format %{ &quot;MEMBAR-acquire&quot; %}
 5154   ins_encode %{ __ z_acquire(); %}
 5155   ins_pipe(pipe_class_dummy);
 5156 %}
 5157 
 5158 instruct membar_acquire_lock() %{
 5159   match(MemBarAcquireLock);
 5160   ins_cost(0);
 5161   size(0);
 5162   format %{ &quot;MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 5163   ins_encode(/*empty*/);
 5164   ins_pipe(pipe_class_dummy);
 5165 %}
 5166 
 5167 instruct membar_release() %{
 5168   match(MemBarRelease);
 5169   match(StoreFence);
 5170   ins_cost(4 * MEMORY_REF_COST);
 5171   size(0);
 5172   format %{ &quot;MEMBAR-release&quot; %}
 5173   ins_encode %{ __ z_release(); %}
 5174   ins_pipe(pipe_class_dummy);
 5175 %}
 5176 
 5177 instruct membar_release_lock() %{
 5178   match(MemBarReleaseLock);
 5179   ins_cost(0);
 5180   size(0);
 5181   format %{ &quot;MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 5182   ins_encode(/*empty*/);
 5183   ins_pipe(pipe_class_dummy);
 5184 %}
 5185 
 5186 instruct membar_volatile() %{
 5187   match(MemBarVolatile);
 5188   ins_cost(4 * MEMORY_REF_COST);
 5189   size(2);
 5190   format %{ &quot;MEMBAR-volatile&quot; %}
 5191   ins_encode %{ __ z_fence(); %}
 5192   ins_pipe(pipe_class_dummy);
 5193 %}
 5194 
 5195 instruct unnecessary_membar_volatile() %{
 5196   match(MemBarVolatile);
 5197   predicate(Matcher::post_store_load_barrier(n));
 5198   ins_cost(0);
 5199   size(0);
 5200   format %{ &quot;# MEMBAR-volatile (empty)&quot; %}
 5201   ins_encode(/*empty*/);
 5202   ins_pipe(pipe_class_dummy);
 5203 %}
 5204 
 5205 instruct membar_CPUOrder() %{
 5206   match(MemBarCPUOrder);
 5207   ins_cost(0);
 5208   // TODO: s390 port size(FIXED_SIZE);
 5209   format %{ &quot;MEMBAR-CPUOrder (empty)&quot; %}
 5210   ins_encode(/*empty*/);
 5211   ins_pipe(pipe_class_dummy);
 5212 %}
 5213 
 5214 instruct membar_storestore() %{
 5215   match(MemBarStoreStore);
 5216   ins_cost(0);
 5217   size(0);
 5218   format %{ &quot;MEMBAR-storestore (empty)&quot; %}
 5219   ins_encode();
 5220   ins_pipe(pipe_class_dummy);
 5221 %}
 5222 
 5223 
 5224 //----------Register Move Instructions-----------------------------------------
 5225 instruct roundDouble_nop(regD dst) %{
 5226   match(Set dst (RoundDouble dst));
 5227   ins_cost(0);
 5228   // TODO: s390 port size(FIXED_SIZE);
 5229   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5230   ins_encode();
 5231   ins_pipe(pipe_class_dummy);
 5232 %}
 5233 
 5234 instruct roundFloat_nop(regF dst) %{
 5235   match(Set dst (RoundFloat dst));
 5236   ins_cost(0);
 5237   // TODO: s390 port size(FIXED_SIZE);
 5238   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5239   ins_encode();
 5240   ins_pipe(pipe_class_dummy);
 5241 %}
 5242 
 5243 // Cast Long to Pointer for unsafe natives.
 5244 instruct castX2P(iRegP dst, iRegL src) %{
 5245   match(Set dst (CastX2P src));
 5246   // TODO: s390 port size(VARIABLE_SIZE);
 5247   format %{ &quot;LGR     $dst,$src\t # CastX2P&quot; %}
 5248   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5249   ins_pipe(pipe_class_dummy);
 5250 %}
 5251 
 5252 // Cast Pointer to Long for unsafe natives.
 5253 instruct castP2X(iRegL dst, iRegP_N2P src) %{
 5254   match(Set dst (CastP2X src));
 5255   // TODO: s390 port size(VARIABLE_SIZE);
 5256   format %{ &quot;LGR     $dst,$src\t # CastP2X&quot; %}
 5257   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5258   ins_pipe(pipe_class_dummy);
 5259 %}
 5260 
 5261 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 5262   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5263   match(Set stkSlot src);   // chain rule
 5264   ins_cost(MEMORY_REF_COST);
 5265   // TODO: s390 port size(FIXED_SIZE);
 5266   format %{ &quot; STD   $src,$stkSlot\t # stk&quot; %}
 5267   opcode(STD_ZOPC);
 5268   ins_encode(z_form_rt_mem(src, stkSlot));
 5269   ins_pipe(pipe_class_dummy);
 5270 %}
 5271 
 5272 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 5273   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5274   match(Set stkSlot src);   // chain rule
 5275   ins_cost(MEMORY_REF_COST);
 5276   // TODO: s390 port size(FIXED_SIZE);
 5277   format %{ &quot;STE   $src,$stkSlot\t # stk&quot; %}
 5278   opcode(STE_ZOPC);
 5279   ins_encode(z_form_rt_mem(src, stkSlot));
 5280   ins_pipe(pipe_class_dummy);
 5281 %}
 5282 
 5283 //----------Conditional Move---------------------------------------------------
 5284 
 5285 instruct cmovN_reg(cmpOp cmp, flagsReg cr, iRegN dst, iRegN_P2N src) %{
 5286   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5287   ins_cost(DEFAULT_COST + BRANCH_COST);
 5288   // TODO: s390 port size(VARIABLE_SIZE);
 5289   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5290   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5291   ins_pipe(pipe_class_dummy);
 5292 %}
 5293 
 5294 instruct cmovN_imm(cmpOp cmp, flagsReg cr, iRegN dst, immN0 src) %{
 5295   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5296   ins_cost(DEFAULT_COST + BRANCH_COST);
 5297   // TODO: s390 port size(VARIABLE_SIZE);
 5298   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5299   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5300   ins_pipe(pipe_class_dummy);
 5301 %}
 5302 
 5303 instruct cmovI_reg(cmpOp cmp, flagsReg cr, iRegI dst, iRegI src) %{
 5304   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5305   ins_cost(DEFAULT_COST + BRANCH_COST);
 5306   // TODO: s390 port size(VARIABLE_SIZE);
 5307   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5308   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5309   ins_pipe(pipe_class_dummy);
 5310 %}
 5311 
 5312 instruct cmovI_imm(cmpOp cmp, flagsReg cr, iRegI dst, immI16 src) %{
 5313   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5314   ins_cost(DEFAULT_COST + BRANCH_COST);
 5315   // TODO: s390 port size(VARIABLE_SIZE);
 5316   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5317   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5318   ins_pipe(pipe_class_dummy);
 5319 %}
 5320 
 5321 instruct cmovP_reg(cmpOp cmp, flagsReg cr, iRegP dst, iRegP_N2P src) %{
 5322   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5323   ins_cost(DEFAULT_COST + BRANCH_COST);
 5324   // TODO: s390 port size(VARIABLE_SIZE);
 5325   format %{ &quot;CMoveP,$cmp    $dst,$src&quot; %}
 5326   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5327   ins_pipe(pipe_class_dummy);
 5328 %}
 5329 
 5330 instruct cmovP_imm(cmpOp cmp, flagsReg cr, iRegP dst, immP0 src) %{
 5331   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5332   ins_cost(DEFAULT_COST + BRANCH_COST);
 5333   // TODO: s390 port size(VARIABLE_SIZE);
 5334   format %{ &quot;CMoveP,$cmp  $dst,$src&quot; %}
 5335   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5336   ins_pipe(pipe_class_dummy);
 5337 %}
 5338 
 5339 instruct cmovF_reg(cmpOpF cmp, flagsReg cr, regF dst, regF src) %{
 5340   match(Set dst (CMoveF (Binary cmp cr) (Binary dst src)));
 5341   ins_cost(DEFAULT_COST + BRANCH_COST);
 5342   // TODO: s390 port size(VARIABLE_SIZE);
 5343   format %{ &quot;CMoveF,$cmp   $dst,$src&quot; %}
 5344   ins_encode %{
 5345     // Don&#39;t emit code if operands are identical (same register).
 5346     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5347       Label done;
 5348       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5349       __ z_ler($dst$$FloatRegister, $src$$FloatRegister);
 5350       __ bind(done);
 5351     }
 5352   %}
 5353   ins_pipe(pipe_class_dummy);
 5354 %}
 5355 
 5356 instruct cmovD_reg(cmpOpF cmp, flagsReg cr, regD dst, regD src) %{
 5357   match(Set dst (CMoveD (Binary cmp cr) (Binary dst src)));
 5358   ins_cost(DEFAULT_COST + BRANCH_COST);
 5359   // TODO: s390 port size(VARIABLE_SIZE);
 5360   format %{ &quot;CMoveD,$cmp   $dst,$src&quot; %}
 5361   ins_encode %{
 5362     // Don&#39;t emit code if operands are identical (same register).
 5363     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5364       Label done;
 5365       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5366       __ z_ldr($dst$$FloatRegister, $src$$FloatRegister);
 5367       __ bind(done);
 5368     }
 5369   %}
 5370   ins_pipe(pipe_class_dummy);
 5371 %}
 5372 
 5373 instruct cmovL_reg(cmpOp cmp, flagsReg cr, iRegL dst, iRegL src) %{
 5374   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5375   ins_cost(DEFAULT_COST + BRANCH_COST);
 5376   // TODO: s390 port size(VARIABLE_SIZE);
 5377   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5378   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5379   ins_pipe(pipe_class_dummy);
 5380 %}
 5381 
 5382 instruct cmovL_imm(cmpOp cmp, flagsReg cr, iRegL dst, immL16 src) %{
 5383   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5384   ins_cost(DEFAULT_COST + BRANCH_COST);
 5385   // TODO: s390 port size(VARIABLE_SIZE);
 5386   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5387   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5388   ins_pipe(pipe_class_dummy);
 5389 %}
 5390 
 5391 //----------OS and Locking Instructions----------------------------------------
 5392 
 5393 // This name is KNOWN by the ADLC and cannot be changed.
 5394 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 5395 // for this guy.
 5396 instruct tlsLoadP(threadRegP dst) %{
 5397   match(Set dst (ThreadLocal));
 5398   ins_cost(0);
 5399   size(0);
 5400   ins_should_rematerialize(true);
 5401   format %{ &quot;# $dst=ThreadLocal&quot; %}
 5402   ins_encode(/* empty */);
 5403   ins_pipe(pipe_class_dummy);
 5404 %}
 5405 
 5406 instruct checkCastPP(iRegP dst) %{
 5407   match(Set dst (CheckCastPP dst));
 5408   size(0);
 5409   format %{ &quot;# checkcastPP of $dst&quot; %}
 5410   ins_encode(/*empty*/);
 5411   ins_pipe(pipe_class_dummy);
 5412 %}
 5413 
 5414 instruct castPP(iRegP dst) %{
 5415   match(Set dst (CastPP dst));
 5416   size(0);
 5417   format %{ &quot;# castPP of $dst&quot; %}
 5418   ins_encode(/*empty*/);
 5419   ins_pipe(pipe_class_dummy);
 5420 %}
 5421 
 5422 instruct castII(iRegI dst) %{
 5423   match(Set dst (CastII dst));
 5424   size(0);
 5425   format %{ &quot;# castII of $dst&quot; %}
 5426   ins_encode(/*empty*/);
 5427   ins_pipe(pipe_class_dummy);
 5428 %}
 5429 
 5430 instruct castLL(iRegL dst) %{
 5431   match(Set dst (CastLL dst));
 5432   size(0);
 5433   format %{ &quot;# castLL of $dst&quot; %}
 5434   ins_encode(/*empty*/);
 5435   ins_pipe(pipe_class_dummy);
 5436 %}
 5437 
 5438 
 5439 //----------Conditional_store--------------------------------------------------
 5440 // Conditional-store of the updated heap-top.
 5441 // Used during allocation of the shared heap.
 5442 // Sets flags (EQ) on success.
 5443 
 5444 // Implement LoadPLocked. Must be ordered against changes of the memory location
 5445 // by storePConditional.
 5446 // Don&#39;t know whether this is ever used.
 5447 instruct loadPLocked(iRegP dst, memory mem) %{
 5448   match(Set dst (LoadPLocked mem));
 5449   ins_cost(MEMORY_REF_COST);
 5450   size(Z_DISP3_SIZE);
 5451   format %{ &quot;LG      $dst,$mem\t # LoadPLocked&quot; %}
 5452   opcode(LG_ZOPC, LG_ZOPC);
 5453   ins_encode(z_form_rt_mem_opt(dst, mem));
 5454   ins_pipe(pipe_class_dummy);
 5455 %}
 5456 
 5457 // As compareAndSwapP, but return flag register instead of boolean value in
 5458 // int register.
 5459 // This instruction is matched if UseTLAB is off. Needed to pass
 5460 // option tests.  Mem_ptr must be a memory operand, else this node
 5461 // does not get Flag_needs_anti_dependence_check set by adlc. If this
 5462 // is not set this node can be rematerialized which leads to errors.
 5463 instruct storePConditional(indirect mem_ptr, rarg5RegP oldval, iRegP_N2P newval, flagsReg cr) %{
 5464   match(Set cr (StorePConditional mem_ptr (Binary oldval newval)));
 5465   effect(KILL oldval);
 5466   // TODO: s390 port size(FIXED_SIZE);
 5467   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5468   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5469   ins_pipe(pipe_class_dummy);
 5470 %}
 5471 
 5472 // As compareAndSwapL, but return flag register instead of boolean value in
 5473 // int register.
 5474 // Used by sun/misc/AtomicLongCSImpl.java. Mem_ptr must be a memory
 5475 // operand, else this node does not get
 5476 // Flag_needs_anti_dependence_check set by adlc. If this is not set
 5477 // this node can be rematerialized which leads to errors.
 5478 instruct storeLConditional(indirect mem_ptr, rarg5RegL oldval, iRegL newval, flagsReg cr) %{
 5479   match(Set cr (StoreLConditional mem_ptr (Binary oldval newval)));
 5480   effect(KILL oldval);
 5481   // TODO: s390 port size(FIXED_SIZE);
 5482   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5483   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5484   ins_pipe(pipe_class_dummy);
 5485 %}
 5486 
 5487 // No flag versions for CompareAndSwap{P,I,L,N} because matcher can&#39;t match them.
 5488 
 5489 instruct compareAndSwapI_bool(iRegP mem_ptr, rarg5RegI oldval, iRegI newval, iRegI res, flagsReg cr) %{
 5490   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 5491   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5492   size(16);
 5493   format %{ &quot;$res = CompareAndSwapI $oldval,$newval,$mem_ptr&quot; %}
 5494   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5495              z_enc_cctobool(res));
 5496   ins_pipe(pipe_class_dummy);
 5497 %}
 5498 
 5499 instruct compareAndSwapL_bool(iRegP mem_ptr, rarg5RegL oldval, iRegL newval, iRegI res, flagsReg cr) %{
 5500   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 5501   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5502   size(18);
 5503   format %{ &quot;$res = CompareAndSwapL $oldval,$newval,$mem_ptr&quot; %}
 5504   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5505              z_enc_cctobool(res));
 5506   ins_pipe(pipe_class_dummy);
 5507 %}
 5508 
 5509 instruct compareAndSwapP_bool(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegI res, flagsReg cr) %{
 5510   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 5511   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5512   size(18);
 5513   format %{ &quot;$res = CompareAndSwapP $oldval,$newval,$mem_ptr&quot; %}
 5514   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5515              z_enc_cctobool(res));
 5516   ins_pipe(pipe_class_dummy);
 5517 %}
 5518 
 5519 instruct compareAndSwapN_bool(iRegP mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegI res, flagsReg cr) %{
 5520   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 5521   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5522   size(16);
 5523   format %{ &quot;$res = CompareAndSwapN $oldval,$newval,$mem_ptr&quot; %}
 5524   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5525              z_enc_cctobool(res));
 5526   ins_pipe(pipe_class_dummy);
 5527 %}
 5528 
 5529 //----------Atomic operations on memory (GetAndSet*, GetAndAdd*)---------------
 5530 
 5531 // Exploit: direct memory arithmetic
 5532 // Prereqs: - instructions available
 5533 //          - instructions guarantee atomicity
 5534 //          - immediate operand to be added
 5535 //          - immediate operand is small enough (8-bit signed).
 5536 //          - result of instruction is not used
 5537 instruct addI_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immI8 src, flagsReg cr) %{
 5538   match(Set dummy (GetAndAddI mem src));
 5539   effect(KILL cr);
 5540   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5541   ins_cost(MEMORY_REF_COST);
 5542   size(6);
 5543   format %{ &quot;ASI     [$mem],$src\t # GetAndAddI (atomic)&quot; %}
 5544   opcode(ASI_ZOPC);
 5545   ins_encode(z_siyform(mem, src));
 5546   ins_pipe(pipe_class_dummy);
 5547 %}
 5548 
 5549 // Fallback: direct memory arithmetic not available
 5550 // Disadvantages: - CS-Loop required, very expensive.
 5551 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5552 instruct addI_mem_imm16_atomic(memoryRSY mem, iRegI dst, immI16 src, iRegI tmp, flagsReg cr) %{
 5553   match(Set dst (GetAndAddI mem src));
 5554   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5555   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5556   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5557             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5558             &quot;  AHIK    $tmp,$dst,$src\n\t&quot;
 5559             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5560             &quot;  retry if failed\n\t&quot;
 5561             &quot;} END ATOMIC&quot;
 5562          %}
 5563   ins_encode %{
 5564     Register Rdst = $dst$$Register;
 5565     Register Rtmp = $tmp$$Register;
 5566     int      Isrc = $src$$constant;
 5567     Label    retry;
 5568 
 5569     // Iterate until update with incremented value succeeds.
 5570     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5571     __ bind(retry);
 5572       // Calculate incremented value.
 5573       if (VM_Version::has_DistinctOpnds()) {
 5574         __ z_ahik(Rtmp, Rdst, Isrc);
 5575       } else {
 5576         __ z_lr(Rtmp, Rdst);
 5577         __ z_ahi(Rtmp, Isrc);
 5578       }
 5579       // Swap into memory location.
 5580       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5581     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5582   %}
 5583   ins_pipe(pipe_class_dummy);
 5584 %}
 5585 
 5586 instruct addI_mem_imm32_atomic(memoryRSY mem, iRegI dst, immI src, iRegI tmp, flagsReg cr) %{
 5587   match(Set dst (GetAndAddI mem src));
 5588   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5589   ins_cost(MEMORY_REF_COST+200*DEFAULT_COST);
 5590   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5591             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5592             &quot;  LGR     $tmp,$dst\n\t&quot;
 5593             &quot;  AFI     $tmp,$src\n\t&quot;
 5594             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5595             &quot;  retry if failed\n\t&quot;
 5596             &quot;} END ATOMIC&quot;
 5597          %}
 5598   ins_encode %{
 5599     Register Rdst = $dst$$Register;
 5600     Register Rtmp = $tmp$$Register;
 5601     int      Isrc = $src$$constant;
 5602     Label    retry;
 5603 
 5604     // Iterate until update with incremented value succeeds.
 5605     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5606     __ bind(retry);
 5607       // Calculate incremented value.
 5608       __ z_lr(Rtmp, Rdst);
 5609       __ z_afi(Rtmp, Isrc);
 5610       // Swap into memory location.
 5611       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5612     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5613   %}
 5614   ins_pipe(pipe_class_dummy);
 5615 %}
 5616 
 5617 instruct addI_mem_reg_atomic(memoryRSY mem, iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
 5618   match(Set dst (GetAndAddI mem src));
 5619   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5620   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5621   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5622             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5623             &quot;  ARK     $tmp,$dst,$src\n\t&quot;
 5624             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5625             &quot;  retry if failed\n\t&quot;
 5626             &quot;} END ATOMIC&quot;
 5627          %}
 5628   ins_encode %{
 5629     Register Rsrc = $src$$Register;
 5630     Register Rdst = $dst$$Register;
 5631     Register Rtmp = $tmp$$Register;
 5632     Label    retry;
 5633 
 5634     // Iterate until update with incremented value succeeds.
 5635     __ z_lgf(Rdst, $mem$$Address);  // current contents
 5636     __ bind(retry);
 5637       // Calculate incremented value.
 5638       if (VM_Version::has_DistinctOpnds()) {
 5639         __ z_ark(Rtmp, Rdst, Rsrc);
 5640       } else {
 5641         __ z_lr(Rtmp, Rdst);
 5642         __ z_ar(Rtmp, Rsrc);
 5643       }
 5644       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5645     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5646   %}
 5647   ins_pipe(pipe_class_dummy);
 5648 %}
 5649 
 5650 
 5651 // Exploit: direct memory arithmetic
 5652 // Prereqs: - instructions available
 5653 //          - instructions guarantee atomicity
 5654 //          - immediate operand to be added
 5655 //          - immediate operand is small enough (8-bit signed).
 5656 //          - result of instruction is not used
 5657 instruct addL_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immL8 src, flagsReg cr) %{
 5658   match(Set dummy (GetAndAddL mem src));
 5659   effect(KILL cr);
 5660   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5661   ins_cost(MEMORY_REF_COST);
 5662   size(6);
 5663   format %{ &quot;AGSI    [$mem],$src\t # GetAndAddL (atomic)&quot; %}
 5664   opcode(AGSI_ZOPC);
 5665   ins_encode(z_siyform(mem, src));
 5666   ins_pipe(pipe_class_dummy);
 5667 %}
 5668 
 5669 // Fallback: direct memory arithmetic not available
 5670 // Disadvantages: - CS-Loop required, very expensive.
 5671 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5672 instruct addL_mem_imm16_atomic(memoryRSY mem, iRegL dst, immL16 src, iRegL tmp, flagsReg cr) %{
 5673   match(Set dst (GetAndAddL mem src));
 5674   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5675   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5676   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5677             &quot;  LG      $dst,[$mem]\n\t&quot;
 5678             &quot;  AGHIK   $tmp,$dst,$src\n\t&quot;
 5679             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5680             &quot;  retry if failed\n\t&quot;
 5681             &quot;} END ATOMIC&quot;
 5682          %}
 5683   ins_encode %{
 5684     Register Rdst = $dst$$Register;
 5685     Register Rtmp = $tmp$$Register;
 5686     int      Isrc = $src$$constant;
 5687     Label    retry;
 5688 
 5689     // Iterate until update with incremented value succeeds.
 5690     __ z_lg(Rdst, $mem$$Address);  // current contents
 5691     __ bind(retry);
 5692       // Calculate incremented value.
 5693       if (VM_Version::has_DistinctOpnds()) {
 5694         __ z_aghik(Rtmp, Rdst, Isrc);
 5695       } else {
 5696         __ z_lgr(Rtmp, Rdst);
 5697         __ z_aghi(Rtmp, Isrc);
 5698       }
 5699       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5700     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5701   %}
 5702   ins_pipe(pipe_class_dummy);
 5703 %}
 5704 
 5705 instruct addL_mem_imm32_atomic(memoryRSY mem, iRegL dst, immL32 src, iRegL tmp, flagsReg cr) %{
 5706   match(Set dst (GetAndAddL mem src));
 5707   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5708   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5709   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5710             &quot;  LG      $dst,[$mem]\n\t&quot;
 5711             &quot;  LGR     $tmp,$dst\n\t&quot;
 5712             &quot;  AGFI    $tmp,$src\n\t&quot;
 5713             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5714             &quot;  retry if failed\n\t&quot;
 5715             &quot;} END ATOMIC&quot;
 5716          %}
 5717   ins_encode %{
 5718     Register Rdst = $dst$$Register;
 5719     Register Rtmp = $tmp$$Register;
 5720     int      Isrc = $src$$constant;
 5721     Label    retry;
 5722 
 5723     // Iterate until update with incremented value succeeds.
 5724     __ z_lg(Rdst, $mem$$Address);  // current contents
 5725     __ bind(retry);
 5726       // Calculate incremented value.
 5727       __ z_lgr(Rtmp, Rdst);
 5728       __ z_agfi(Rtmp, Isrc);
 5729       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5730     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5731   %}
 5732   ins_pipe(pipe_class_dummy);
 5733 %}
 5734 
 5735 instruct addL_mem_reg_atomic(memoryRSY mem, iRegL dst, iRegL src, iRegL tmp, flagsReg cr) %{
 5736   match(Set dst (GetAndAddL mem src));
 5737   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5738   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5739   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5740             &quot;  LG      $dst,[$mem]\n\t&quot;
 5741             &quot;  AGRK    $tmp,$dst,$src\n\t&quot;
 5742             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5743             &quot;  retry if failed\n\t&quot;
 5744             &quot;} END ATOMIC&quot;
 5745          %}
 5746   ins_encode %{
 5747     Register Rsrc = $src$$Register;
 5748     Register Rdst = $dst$$Register;
 5749     Register Rtmp = $tmp$$Register;
 5750     Label    retry;
 5751 
 5752     // Iterate until update with incremented value succeeds.
 5753     __ z_lg(Rdst, $mem$$Address);  // current contents
 5754     __ bind(retry);
 5755       // Calculate incremented value.
 5756       if (VM_Version::has_DistinctOpnds()) {
 5757         __ z_agrk(Rtmp, Rdst, Rsrc);
 5758       } else {
 5759         __ z_lgr(Rtmp, Rdst);
 5760         __ z_agr(Rtmp, Rsrc);
 5761       }
 5762       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5763     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5764   %}
 5765   ins_pipe(pipe_class_dummy);
 5766 %}
 5767 
 5768 // Increment value in memory, save old value in dst.
 5769 instruct addI_mem_reg_atomic_z196(memoryRSY mem, iRegI dst, iRegI src) %{
 5770   match(Set dst (GetAndAddI mem src));
 5771   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5772   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5773   size(6);
 5774   format %{ &quot;LAA     $dst,$src,[$mem]&quot; %}
 5775   ins_encode %{ __ z_laa($dst$$Register, $src$$Register, $mem$$Address); %}
 5776   ins_pipe(pipe_class_dummy);
 5777 %}
 5778 
 5779 // Increment value in memory, save old value in dst.
 5780 instruct addL_mem_reg_atomic_z196(memoryRSY mem, iRegL dst, iRegL src) %{
 5781   match(Set dst (GetAndAddL mem src));
 5782   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5783   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5784   size(6);
 5785   format %{ &quot;LAAG    $dst,$src,[$mem]&quot; %}
 5786   ins_encode %{ __ z_laag($dst$$Register, $src$$Register, $mem$$Address); %}
 5787   ins_pipe(pipe_class_dummy);
 5788 %}
 5789 
 5790 
 5791 instruct xchgI_reg_mem(memoryRSY mem, iRegI dst, iRegI tmp, flagsReg cr) %{
 5792   match(Set dst (GetAndSetI mem dst));
 5793   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5794   format %{ &quot;XCHGI   $dst,[$mem]\t # EXCHANGE (int, atomic), temp $tmp&quot; %}
 5795   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5796   ins_pipe(pipe_class_dummy);
 5797 %}
 5798 
 5799 instruct xchgL_reg_mem(memoryRSY mem, iRegL dst, iRegL tmp, flagsReg cr) %{
 5800   match(Set dst (GetAndSetL mem dst));
 5801   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5802   format %{ &quot;XCHGL   $dst,[$mem]\t # EXCHANGE (long, atomic), temp $tmp&quot; %}
 5803   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5804   ins_pipe(pipe_class_dummy);
 5805 %}
 5806 
 5807 instruct xchgN_reg_mem(memoryRSY mem, iRegN dst, iRegI tmp, flagsReg cr) %{
 5808   match(Set dst (GetAndSetN mem dst));
 5809   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5810   format %{ &quot;XCHGN   $dst,[$mem]\t # EXCHANGE (coop, atomic), temp $tmp&quot; %}
 5811   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5812   ins_pipe(pipe_class_dummy);
 5813 %}
 5814 
 5815 instruct xchgP_reg_mem(memoryRSY mem, iRegP dst, iRegL tmp, flagsReg cr) %{
 5816   match(Set dst (GetAndSetP mem dst));
 5817   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5818   format %{ &quot;XCHGP   $dst,[$mem]\t # EXCHANGE (oop, atomic), temp $tmp&quot; %}
 5819   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5820   ins_pipe(pipe_class_dummy);
 5821 %}
 5822 
 5823 
 5824 //----------Arithmetic Instructions--------------------------------------------
 5825 
 5826 // The rules are sorted by right operand type and operand length. Please keep
 5827 // it that way.
 5828 // Left operand type is always reg. Left operand len is I, L, P
 5829 // Right operand type is reg, imm, mem. Right operand len is S, I, L, P
 5830 // Special instruction formats, e.g. multi-operand, are inserted at the end.
 5831 
 5832 // ADD
 5833 
 5834 // REG = REG + REG
 5835 
 5836 // Register Addition
 5837 instruct addI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 5838   match(Set dst (AddI dst src));
 5839   effect(KILL cr);
 5840   // TODO: s390 port size(FIXED_SIZE);
 5841   format %{ &quot;AR      $dst,$src\t # int  CISC ALU&quot; %}
 5842   opcode(AR_ZOPC);
 5843   ins_encode(z_rrform(dst, src));
 5844   ins_pipe(pipe_class_dummy);
 5845 %}
 5846 
 5847 // Avoid use of LA(Y) for general ALU operation.
 5848 instruct addI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 5849   match(Set dst (AddI src1 src2));
 5850   effect(KILL cr);
 5851   predicate(VM_Version::has_DistinctOpnds());
 5852   ins_cost(DEFAULT_COST);
 5853   size(4);
 5854   format %{ &quot;ARK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 5855   opcode(ARK_ZOPC);
 5856   ins_encode(z_rrfform(dst, src1, src2));
 5857   ins_pipe(pipe_class_dummy);
 5858 %}
 5859 
 5860 // REG = REG + IMM
 5861 
 5862 // Avoid use of LA(Y) for general ALU operation.
 5863 // Immediate Addition
 5864 instruct addI_reg_imm16_CISC(iRegI dst, immI16 con, flagsReg cr) %{
 5865   match(Set dst (AddI dst con));
 5866   effect(KILL cr);
 5867   ins_cost(DEFAULT_COST);
 5868   // TODO: s390 port size(FIXED_SIZE);
 5869   format %{ &quot;AHI     $dst,$con\t # int  CISC ALU&quot; %}
 5870   opcode(AHI_ZOPC);
 5871   ins_encode(z_riform_signed(dst, con));
 5872   ins_pipe(pipe_class_dummy);
 5873 %}
 5874 
 5875 // Avoid use of LA(Y) for general ALU operation.
 5876 // Immediate Addition
 5877 instruct addI_reg_imm16_RISC(iRegI dst, iRegI src, immI16 con, flagsReg cr) %{
 5878   match(Set dst (AddI src con));
 5879   effect(KILL cr);
 5880   predicate( VM_Version::has_DistinctOpnds());
 5881   ins_cost(DEFAULT_COST);
 5882   // TODO: s390 port size(FIXED_SIZE);
 5883   format %{ &quot;AHIK    $dst,$src,$con\t # int  RISC ALU&quot; %}
 5884   opcode(AHIK_ZOPC);
 5885   ins_encode(z_rieform_d(dst, src, con));
 5886   ins_pipe(pipe_class_dummy);
 5887 %}
 5888 
 5889 // Immediate Addition
 5890 instruct addI_reg_imm32(iRegI dst, immI src, flagsReg cr) %{
 5891   match(Set dst (AddI dst src));
 5892   effect(KILL cr);
 5893   ins_cost(DEFAULT_COST_HIGH);
 5894   size(6);
 5895   format %{ &quot;AFI     $dst,$src&quot; %}
 5896   opcode(AFI_ZOPC);
 5897   ins_encode(z_rilform_signed(dst, src));
 5898   ins_pipe(pipe_class_dummy);
 5899 %}
 5900 
 5901 // Immediate Addition
 5902 instruct addI_reg_imm12(iRegI dst, iRegI src, uimmI12 con) %{
 5903   match(Set dst (AddI src con));
 5904   predicate(PreferLAoverADD);
 5905   ins_cost(DEFAULT_COST_LOW);
 5906   size(4);
 5907   format %{ &quot;LA      $dst,$con(,$src)\t # int d12(,b)&quot; %}
 5908   opcode(LA_ZOPC);
 5909   ins_encode(z_rxform_imm_reg(dst, con, src));
 5910   ins_pipe(pipe_class_dummy);
 5911 %}
 5912 
 5913 // Immediate Addition
 5914 instruct addI_reg_imm20(iRegI dst, iRegI src, immI20 con) %{
 5915   match(Set dst (AddI src con));
 5916   predicate(PreferLAoverADD);
 5917   ins_cost(DEFAULT_COST);
 5918   size(6);
 5919   format %{ &quot;LAY     $dst,$con(,$src)\t # int d20(,b)&quot; %}
 5920   opcode(LAY_ZOPC);
 5921   ins_encode(z_rxyform_imm_reg(dst, con, src));
 5922   ins_pipe(pipe_class_dummy);
 5923 %}
 5924 
 5925 instruct addI_reg_reg_imm12(iRegI dst, iRegI src1, iRegI src2, uimmI12 con) %{
 5926   match(Set dst (AddI (AddI src1 src2) con));
 5927   predicate( PreferLAoverADD);
 5928   ins_cost(DEFAULT_COST_LOW);
 5929   size(4);
 5930   format %{ &quot;LA      $dst,$con($src1,$src2)\t # int d12(x,b)&quot; %}
 5931   opcode(LA_ZOPC);
 5932   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 5933   ins_pipe(pipe_class_dummy);
 5934 %}
 5935 
 5936 instruct addI_reg_reg_imm20(iRegI dst, iRegI src1, iRegI src2, immI20 con) %{
 5937   match(Set dst (AddI (AddI src1 src2) con));
 5938   predicate(PreferLAoverADD);
 5939   ins_cost(DEFAULT_COST);
 5940   size(6);
 5941   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # int d20(x,b)&quot; %}
 5942   opcode(LAY_ZOPC);
 5943   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 5944   ins_pipe(pipe_class_dummy);
 5945 %}
 5946 
 5947 // REG = REG + MEM
 5948 
 5949 instruct addI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 5950   match(Set dst (AddI dst (LoadI src)));
 5951   effect(KILL cr);
 5952   ins_cost(MEMORY_REF_COST);
 5953   // TODO: s390 port size(VARIABLE_SIZE);
 5954   format %{ &quot;A(Y)    $dst, $src\t # int&quot; %}
 5955   opcode(AY_ZOPC, A_ZOPC);
 5956   ins_encode(z_form_rt_mem_opt(dst, src));
 5957   ins_pipe(pipe_class_dummy);
 5958 %}
 5959 
 5960 // MEM = MEM + IMM
 5961 
 5962 // Add Immediate to 4-byte memory operand and result
 5963 instruct addI_mem_imm(memoryRSY mem, immI8 src, flagsReg cr) %{
 5964   match(Set mem (StoreI mem (AddI (LoadI mem) src)));
 5965   effect(KILL cr);
 5966   predicate(VM_Version::has_MemWithImmALUOps());
 5967   ins_cost(MEMORY_REF_COST);
 5968   size(6);
 5969   format %{ &quot;ASI     $mem,$src\t # direct mem add 4&quot; %}
 5970   opcode(ASI_ZOPC);
 5971   ins_encode(z_siyform(mem, src));
 5972   ins_pipe(pipe_class_dummy);
 5973 %}
 5974 
 5975 
 5976 //
 5977 
 5978 // REG = REG + REG
 5979 
 5980 instruct addL_reg_regI(iRegL dst, iRegI src, flagsReg cr) %{
 5981   match(Set dst (AddL dst (ConvI2L src)));
 5982   effect(KILL cr);
 5983   size(4);
 5984   format %{ &quot;AGFR    $dst,$src\t # long&lt;-int CISC ALU&quot; %}
 5985   opcode(AGFR_ZOPC);
 5986   ins_encode(z_rreform(dst, src));
 5987   ins_pipe(pipe_class_dummy);
 5988 %}
 5989 
 5990 instruct addL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 5991   match(Set dst (AddL dst src));
 5992   effect(KILL cr);
 5993   // TODO: s390 port size(FIXED_SIZE);
 5994   format %{ &quot;AGR     $dst, $src\t # long CISC ALU&quot; %}
 5995   opcode(AGR_ZOPC);
 5996   ins_encode(z_rreform(dst, src));
 5997   ins_pipe(pipe_class_dummy);
 5998 %}
 5999 
 6000 // Avoid use of LA(Y) for general ALU operation.
 6001 instruct addL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6002   match(Set dst (AddL src1 src2));
 6003   effect(KILL cr);
 6004   predicate(VM_Version::has_DistinctOpnds());
 6005   ins_cost(DEFAULT_COST);
 6006   size(4);
 6007   format %{ &quot;AGRK    $dst,$src1,$src2\t # long RISC ALU&quot; %}
 6008   opcode(AGRK_ZOPC);
 6009   ins_encode(z_rrfform(dst, src1, src2));
 6010   ins_pipe(pipe_class_dummy);
 6011 %}
 6012 
 6013 // REG = REG + IMM
 6014 
 6015 instruct addL_reg_imm12(iRegL dst, iRegL src, uimmL12 con) %{
 6016   match(Set dst (AddL src con));
 6017   predicate( PreferLAoverADD);
 6018   ins_cost(DEFAULT_COST_LOW);
 6019   size(4);
 6020   format %{ &quot;LA      $dst,$con(,$src)\t # long d12(,b)&quot; %}
 6021   opcode(LA_ZOPC);
 6022   ins_encode(z_rxform_imm_reg(dst, con, src));
 6023   ins_pipe(pipe_class_dummy);
 6024 %}
 6025 
 6026 instruct addL_reg_imm20(iRegL dst, iRegL src, immL20 con) %{
 6027   match(Set dst (AddL src con));
 6028   predicate(PreferLAoverADD);
 6029   ins_cost(DEFAULT_COST);
 6030   size(6);
 6031   format %{ &quot;LAY     $dst,$con(,$src)\t # long d20(,b)&quot; %}
 6032   opcode(LAY_ZOPC);
 6033   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6034   ins_pipe(pipe_class_dummy);
 6035 %}
 6036 
 6037 instruct addL_reg_imm32(iRegL dst, immL32 con, flagsReg cr) %{
 6038   match(Set dst (AddL dst con));
 6039   effect(KILL cr);
 6040   ins_cost(DEFAULT_COST_HIGH);
 6041   size(6);
 6042   format %{ &quot;AGFI    $dst,$con\t # long CISC ALU&quot; %}
 6043   opcode(AGFI_ZOPC);
 6044   ins_encode(z_rilform_signed(dst, con));
 6045   ins_pipe(pipe_class_dummy);
 6046 %}
 6047 
 6048 // Avoid use of LA(Y) for general ALU operation.
 6049 instruct addL_reg_imm16_CISC(iRegL dst, immL16 con, flagsReg cr) %{
 6050   match(Set dst (AddL dst con));
 6051   effect(KILL cr);
 6052   ins_cost(DEFAULT_COST);
 6053   // TODO: s390 port size(FIXED_SIZE);
 6054   format %{ &quot;AGHI    $dst,$con\t # long CISC ALU&quot; %}
 6055   opcode(AGHI_ZOPC);
 6056   ins_encode(z_riform_signed(dst, con));
 6057   ins_pipe(pipe_class_dummy);
 6058 %}
 6059 
 6060 // Avoid use of LA(Y) for general ALU operation.
 6061 instruct addL_reg_imm16_RISC(iRegL dst, iRegL src, immL16 con, flagsReg cr) %{
 6062   match(Set dst (AddL src con));
 6063   effect(KILL cr);
 6064   predicate( VM_Version::has_DistinctOpnds());
 6065   ins_cost(DEFAULT_COST);
 6066   size(6);
 6067   format %{ &quot;AGHIK   $dst,$src,$con\t # long RISC ALU&quot; %}
 6068   opcode(AGHIK_ZOPC);
 6069   ins_encode(z_rieform_d(dst, src, con));
 6070   ins_pipe(pipe_class_dummy);
 6071 %}
 6072 
 6073 // REG = REG + MEM
 6074 
 6075 instruct addL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6076   match(Set dst (AddL dst (ConvI2L (LoadI src))));
 6077   effect(KILL cr);
 6078   ins_cost(MEMORY_REF_COST);
 6079   size(Z_DISP3_SIZE);
 6080   format %{ &quot;AGF     $dst, $src\t # long/int&quot; %}
 6081   opcode(AGF_ZOPC, AGF_ZOPC);
 6082   ins_encode(z_form_rt_mem_opt(dst, src));
 6083   ins_pipe(pipe_class_dummy);
 6084 %}
 6085 
 6086 instruct addL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6087   match(Set dst (AddL dst (LoadL src)));
 6088   effect(KILL cr);
 6089   ins_cost(MEMORY_REF_COST);
 6090   size(Z_DISP3_SIZE);
 6091   format %{ &quot;AG      $dst, $src\t # long&quot; %}
 6092   opcode(AG_ZOPC, AG_ZOPC);
 6093   ins_encode(z_form_rt_mem_opt(dst, src));
 6094   ins_pipe(pipe_class_dummy);
 6095 %}
 6096 
 6097 instruct addL_reg_reg_imm12(iRegL dst, iRegL src1, iRegL src2, uimmL12 con) %{
 6098   match(Set dst (AddL (AddL src1 src2) con));
 6099   predicate( PreferLAoverADD);
 6100   ins_cost(DEFAULT_COST_LOW);
 6101   size(4);
 6102   format %{ &quot;LA     $dst,$con($src1,$src2)\t # long d12(x,b)&quot; %}
 6103   opcode(LA_ZOPC);
 6104   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6105   ins_pipe(pipe_class_dummy);
 6106 %}
 6107 
 6108 instruct addL_reg_reg_imm20(iRegL dst, iRegL src1, iRegL src2, immL20 con) %{
 6109   match(Set dst (AddL (AddL src1 src2) con));
 6110   predicate(PreferLAoverADD);
 6111   ins_cost(DEFAULT_COST);
 6112   size(6);
 6113   format %{ &quot;LAY    $dst,$con($src1,$src2)\t # long d20(x,b)&quot; %}
 6114   opcode(LAY_ZOPC);
 6115   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6116   ins_pipe(pipe_class_dummy);
 6117 %}
 6118 
 6119 // MEM = MEM + IMM
 6120 
 6121 // Add Immediate to 8-byte memory operand and result.
 6122 instruct addL_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6123   match(Set mem (StoreL mem (AddL (LoadL mem) src)));
 6124   effect(KILL cr);
 6125   predicate(VM_Version::has_MemWithImmALUOps());
 6126   ins_cost(MEMORY_REF_COST);
 6127   size(6);
 6128   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8&quot; %}
 6129   opcode(AGSI_ZOPC);
 6130   ins_encode(z_siyform(mem, src));
 6131   ins_pipe(pipe_class_dummy);
 6132 %}
 6133 
 6134 
 6135 // REG = REG + REG
 6136 
 6137 // Ptr Addition
 6138 instruct addP_reg_reg_LA(iRegP dst, iRegP_N2P src1, iRegL src2) %{
 6139   match(Set dst (AddP src1 src2));
 6140   predicate( PreferLAoverADD);
 6141   ins_cost(DEFAULT_COST);
 6142   size(4);
 6143   format %{ &quot;LA      $dst,#0($src1,$src2)\t # ptr 0(x,b)&quot; %}
 6144   opcode(LA_ZOPC);
 6145   ins_encode(z_rxform_imm_reg_reg(dst, 0x0, src1, src2));
 6146   ins_pipe(pipe_class_dummy);
 6147 %}
 6148 
 6149 // Ptr Addition
 6150 // Avoid use of LA(Y) for general ALU operation.
 6151 instruct addP_reg_reg_CISC(iRegP dst, iRegL src, flagsReg cr) %{
 6152   match(Set dst (AddP dst src));
 6153   effect(KILL cr);
 6154   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6155   ins_cost(DEFAULT_COST);
 6156   // TODO: s390 port size(FIXED_SIZE);
 6157   format %{ &quot;ALGR    $dst,$src\t # ptr CICS ALU&quot; %}
 6158   opcode(ALGR_ZOPC);
 6159   ins_encode(z_rreform(dst, src));
 6160   ins_pipe(pipe_class_dummy);
 6161 %}
 6162 
 6163 // Ptr Addition
 6164 // Avoid use of LA(Y) for general ALU operation.
 6165 instruct addP_reg_reg_RISC(iRegP dst, iRegP_N2P src1, iRegL src2, flagsReg cr) %{
 6166   match(Set dst (AddP src1 src2));
 6167   effect(KILL cr);
 6168   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6169   ins_cost(DEFAULT_COST);
 6170   // TODO: s390 port size(FIXED_SIZE);
 6171   format %{ &quot;ALGRK   $dst,$src1,$src2\t # ptr RISC ALU&quot; %}
 6172   opcode(ALGRK_ZOPC);
 6173   ins_encode(z_rrfform(dst, src1, src2));
 6174   ins_pipe(pipe_class_dummy);
 6175 %}
 6176 
 6177 // REG = REG + IMM
 6178 
 6179 instruct addP_reg_imm12(iRegP dst, iRegP_N2P src, uimmL12 con) %{
 6180   match(Set dst (AddP src con));
 6181   predicate( PreferLAoverADD);
 6182   ins_cost(DEFAULT_COST_LOW);
 6183   size(4);
 6184   format %{ &quot;LA      $dst,$con(,$src)\t # ptr d12(,b)&quot; %}
 6185   opcode(LA_ZOPC);
 6186   ins_encode(z_rxform_imm_reg(dst, con, src));
 6187   ins_pipe(pipe_class_dummy);
 6188 %}
 6189 
 6190 // Avoid use of LA(Y) for general ALU operation.
 6191 instruct addP_reg_imm16_CISC(iRegP dst, immL16 src, flagsReg cr) %{
 6192   match(Set dst (AddP dst src));
 6193   effect(KILL cr);
 6194   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6195   ins_cost(DEFAULT_COST);
 6196   // TODO: s390 port size(FIXED_SIZE);
 6197   format %{ &quot;AGHI    $dst,$src\t # ptr CISC ALU&quot; %}
 6198   opcode(AGHI_ZOPC);
 6199   ins_encode(z_riform_signed(dst, src));
 6200   ins_pipe(pipe_class_dummy);
 6201 %}
 6202 
 6203 // Avoid use of LA(Y) for general ALU operation.
 6204 instruct addP_reg_imm16_RISC(iRegP dst, iRegP_N2P src, immL16 con, flagsReg cr) %{
 6205   match(Set dst (AddP src con));
 6206   effect(KILL cr);
 6207   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6208   ins_cost(DEFAULT_COST);
 6209   // TODO: s390 port size(FIXED_SIZE);
 6210   format %{ &quot;ALGHSIK $dst,$src,$con\t # ptr RISC ALU&quot; %}
 6211   opcode(ALGHSIK_ZOPC);
 6212   ins_encode(z_rieform_d(dst, src, con));
 6213   ins_pipe(pipe_class_dummy);
 6214 %}
 6215 
 6216 instruct addP_reg_imm20(iRegP dst, memoryRegP src, immL20 con) %{
 6217   match(Set dst (AddP src con));
 6218   predicate(PreferLAoverADD);
 6219   ins_cost(DEFAULT_COST);
 6220   size(6);
 6221   format %{ &quot;LAY     $dst,$con(,$src)\t # ptr d20(,b)&quot; %}
 6222   opcode(LAY_ZOPC);
 6223   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6224   ins_pipe(pipe_class_dummy);
 6225 %}
 6226 
 6227 // Pointer Immediate Addition
 6228 instruct addP_reg_imm32(iRegP dst, immL32 src, flagsReg cr) %{
 6229   match(Set dst (AddP dst src));
 6230   effect(KILL cr);
 6231   ins_cost(DEFAULT_COST_HIGH);
 6232   // TODO: s390 port size(FIXED_SIZE);
 6233   format %{ &quot;AGFI    $dst,$src\t # ptr&quot; %}
 6234   opcode(AGFI_ZOPC);
 6235   ins_encode(z_rilform_signed(dst, src));
 6236   ins_pipe(pipe_class_dummy);
 6237 %}
 6238 
 6239 // REG = REG1 + REG2 + IMM
 6240 
 6241 instruct addP_reg_reg_imm12(iRegP dst, memoryRegP src1, iRegL src2, uimmL12 con) %{
 6242   match(Set dst (AddP (AddP src1 src2) con));
 6243   predicate( PreferLAoverADD);
 6244   ins_cost(DEFAULT_COST_LOW);
 6245   size(4);
 6246   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6247   opcode(LA_ZOPC);
 6248   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6249   ins_pipe(pipe_class_dummy);
 6250 %}
 6251 
 6252 instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
 6253   match(Set dst (AddP (AddP src1 src2) con));
 6254   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6255   ins_cost(DEFAULT_COST_LOW);
 6256   size(4);
 6257   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6258   opcode(LA_ZOPC);
 6259   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6260   ins_pipe(pipe_class_dummy);
 6261 %}
 6262 
 6263 instruct addP_reg_reg_imm20(iRegP dst, memoryRegP src1, iRegL src2, immL20 con) %{
 6264   match(Set dst (AddP (AddP src1 src2) con));
 6265   predicate(PreferLAoverADD);
 6266   ins_cost(DEFAULT_COST);
 6267   // TODO: s390 port size(FIXED_SIZE);
 6268   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6269   opcode(LAY_ZOPC);
 6270   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6271   ins_pipe(pipe_class_dummy);
 6272 %}
 6273 
 6274 instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
 6275   match(Set dst (AddP (AddP src1 src2) con));
 6276   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6277   ins_cost(DEFAULT_COST);
 6278   // TODO: s390 port size(FIXED_SIZE);
 6279   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6280   opcode(LAY_ZOPC);
 6281   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6282   ins_pipe(pipe_class_dummy);
 6283 %}
 6284 
 6285 // MEM = MEM + IMM
 6286 
 6287 // Add Immediate to 8-byte memory operand and result
 6288 instruct addP_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6289   match(Set mem (StoreP mem (AddP (LoadP mem) src)));
 6290   effect(KILL cr);
 6291   predicate(VM_Version::has_MemWithImmALUOps());
 6292   ins_cost(MEMORY_REF_COST);
 6293   size(6);
 6294   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8 (ptr)&quot; %}
 6295   opcode(AGSI_ZOPC);
 6296   ins_encode(z_siyform(mem, src));
 6297   ins_pipe(pipe_class_dummy);
 6298 %}
 6299 
 6300 // SUB
 6301 
 6302 // Register Subtraction
 6303 instruct subI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 6304   match(Set dst (SubI dst src));
 6305   effect(KILL cr);
 6306   // TODO: s390 port size(FIXED_SIZE);
 6307   format %{ &quot;SR      $dst,$src\t # int  CISC ALU&quot; %}
 6308   opcode(SR_ZOPC);
 6309   ins_encode(z_rrform(dst, src));
 6310   ins_pipe(pipe_class_dummy);
 6311 %}
 6312 
 6313 instruct subI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 6314   match(Set dst (SubI src1 src2));
 6315   effect(KILL cr);
 6316   predicate(VM_Version::has_DistinctOpnds());
 6317   ins_cost(DEFAULT_COST);
 6318   size(4);
 6319   format %{ &quot;SRK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6320   opcode(SRK_ZOPC);
 6321   ins_encode(z_rrfform(dst, src1, src2));
 6322   ins_pipe(pipe_class_dummy);
 6323 %}
 6324 
 6325 instruct subI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 6326   match(Set dst (SubI dst (LoadI src)));
 6327   effect(KILL cr);
 6328   ins_cost(MEMORY_REF_COST);
 6329   // TODO: s390 port size(VARIABLE_SIZE);
 6330   format %{ &quot;S(Y)    $dst, $src\t # int&quot; %}
 6331   opcode(SY_ZOPC, S_ZOPC);
 6332   ins_encode(z_form_rt_mem_opt(dst, src));
 6333   ins_pipe(pipe_class_dummy);
 6334 %}
 6335 
 6336 instruct subI_zero_reg(iRegI dst, immI_0 zero, iRegI src, flagsReg cr) %{
 6337   match(Set dst (SubI zero src));
 6338   effect(KILL cr);
 6339   size(2);
 6340   format %{ &quot;NEG     $dst, $src&quot; %}
 6341   ins_encode %{ __ z_lcr($dst$$Register, $src$$Register); %}
 6342   ins_pipe(pipe_class_dummy);
 6343 %}
 6344 
 6345 //
 6346 
 6347 // Long subtraction
 6348 instruct subL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 6349   match(Set dst (SubL dst src));
 6350   effect(KILL cr);
 6351   // TODO: s390 port size(FIXED_SIZE);
 6352   format %{ &quot;SGR     $dst,$src\t # int  CISC ALU&quot; %}
 6353   opcode(SGR_ZOPC);
 6354   ins_encode(z_rreform(dst, src));
 6355   ins_pipe(pipe_class_dummy);
 6356 %}
 6357 
 6358 // Avoid use of LA(Y) for general ALU operation.
 6359 instruct subL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6360   match(Set dst (SubL src1 src2));
 6361   effect(KILL cr);
 6362   predicate(VM_Version::has_DistinctOpnds());
 6363   ins_cost(DEFAULT_COST);
 6364   size(4);
 6365   format %{ &quot;SGRK    $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6366   opcode(SGRK_ZOPC);
 6367   ins_encode(z_rrfform(dst, src1, src2));
 6368   ins_pipe(pipe_class_dummy);
 6369 %}
 6370 
 6371 instruct subL_reg_regI_CISC(iRegL dst, iRegI src, flagsReg cr) %{
 6372   match(Set dst (SubL dst (ConvI2L src)));
 6373   effect(KILL cr);
 6374   size(4);
 6375   format %{ &quot;SGFR    $dst, $src\t # int  CISC ALU&quot; %}
 6376   opcode(SGFR_ZOPC);
 6377   ins_encode(z_rreform(dst, src));
 6378   ins_pipe(pipe_class_dummy);
 6379 %}
 6380 
 6381 instruct subL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6382   match(Set dst (SubL dst (ConvI2L (LoadI src))));
 6383   effect(KILL cr);
 6384   ins_cost(MEMORY_REF_COST);
 6385   size(Z_DISP3_SIZE);
 6386   format %{ &quot;SGF     $dst, $src\t # long/int&quot; %}
 6387   opcode(SGF_ZOPC, SGF_ZOPC);
 6388   ins_encode(z_form_rt_mem_opt(dst, src));
 6389   ins_pipe(pipe_class_dummy);
 6390 %}
 6391 
 6392 instruct subL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6393   match(Set dst (SubL dst (LoadL src)));
 6394   effect(KILL cr);
 6395   ins_cost(MEMORY_REF_COST);
 6396   size(Z_DISP3_SIZE);
 6397   format %{ &quot;SG      $dst, $src\t # long&quot; %}
 6398   opcode(SG_ZOPC, SG_ZOPC);
 6399   ins_encode(z_form_rt_mem_opt(dst, src));
 6400   ins_pipe(pipe_class_dummy);
 6401 %}
 6402 
 6403 // Moved declaration of negL_reg_reg before encode nodes, where it is used.
 6404 
 6405 //  MUL
 6406 
 6407 // Register Multiplication
 6408 instruct mulI_reg_reg(iRegI dst, iRegI src) %{
 6409   match(Set dst (MulI dst src));
 6410   ins_cost(DEFAULT_COST);
 6411   size(4);
 6412   format %{ &quot;MSR     $dst, $src&quot; %}
 6413   opcode(MSR_ZOPC);
 6414   ins_encode(z_rreform(dst, src));
 6415   ins_pipe(pipe_class_dummy);
 6416 %}
 6417 
 6418 // Immediate Multiplication
 6419 instruct mulI_reg_imm16(iRegI dst, immI16 con) %{
 6420   match(Set dst (MulI dst con));
 6421   ins_cost(DEFAULT_COST);
 6422   // TODO: s390 port size(FIXED_SIZE);
 6423   format %{ &quot;MHI     $dst,$con&quot; %}
 6424   opcode(MHI_ZOPC);
 6425   ins_encode(z_riform_signed(dst,con));
 6426   ins_pipe(pipe_class_dummy);
 6427 %}
 6428 
 6429 // Immediate (32bit) Multiplication
 6430 instruct mulI_reg_imm32(iRegI dst, immI con) %{
 6431   match(Set dst (MulI dst con));
 6432   ins_cost(DEFAULT_COST);
 6433   size(6);
 6434   format %{ &quot;MSFI    $dst,$con&quot; %}
 6435   opcode(MSFI_ZOPC);
 6436   ins_encode(z_rilform_signed(dst,con));
 6437   ins_pipe(pipe_class_dummy);
 6438 %}
 6439 
 6440 instruct mulI_Reg_mem(iRegI dst, memory src)%{
 6441   match(Set dst (MulI dst (LoadI src)));
 6442   ins_cost(MEMORY_REF_COST);
 6443   // TODO: s390 port size(VARIABLE_SIZE);
 6444   format %{ &quot;MS(Y)   $dst, $src\t # int&quot; %}
 6445   opcode(MSY_ZOPC, MS_ZOPC);
 6446   ins_encode(z_form_rt_mem_opt(dst, src));
 6447   ins_pipe(pipe_class_dummy);
 6448 %}
 6449 
 6450 //
 6451 
 6452 instruct mulL_reg_regI(iRegL dst, iRegI src) %{
 6453   match(Set dst (MulL dst (ConvI2L src)));
 6454   ins_cost(DEFAULT_COST);
 6455   // TODO: s390 port size(FIXED_SIZE);
 6456   format %{ &quot;MSGFR   $dst $src\t # long/int&quot; %}
 6457   opcode(MSGFR_ZOPC);
 6458   ins_encode(z_rreform(dst, src));
 6459   ins_pipe(pipe_class_dummy);
 6460 %}
 6461 
 6462 instruct mulL_reg_reg(iRegL dst, iRegL src) %{
 6463   match(Set dst (MulL dst src));
 6464   ins_cost(DEFAULT_COST);
 6465   size(4);
 6466   format %{ &quot;MSGR    $dst $src\t # long&quot; %}
 6467   opcode(MSGR_ZOPC);
 6468   ins_encode(z_rreform(dst, src));
 6469   ins_pipe(pipe_class_dummy);
 6470 %}
 6471 
 6472 // Immediate Multiplication
 6473 instruct mulL_reg_imm16(iRegL dst, immL16 src) %{
 6474   match(Set dst (MulL dst src));
 6475   ins_cost(DEFAULT_COST);
 6476   // TODO: s390 port size(FIXED_SIZE);
 6477   format %{ &quot;MGHI    $dst,$src\t # long&quot; %}
 6478   opcode(MGHI_ZOPC);
 6479   ins_encode(z_riform_signed(dst, src));
 6480   ins_pipe(pipe_class_dummy);
 6481 %}
 6482 
 6483 // Immediate (32bit) Multiplication
 6484 instruct mulL_reg_imm32(iRegL dst, immL32 con) %{
 6485   match(Set dst (MulL dst con));
 6486   ins_cost(DEFAULT_COST);
 6487   size(6);
 6488   format %{ &quot;MSGFI   $dst,$con&quot; %}
 6489   opcode(MSGFI_ZOPC);
 6490   ins_encode(z_rilform_signed(dst,con));
 6491   ins_pipe(pipe_class_dummy);
 6492 %}
 6493 
 6494 instruct mulL_Reg_memI(iRegL dst, memory src)%{
 6495   match(Set dst (MulL dst (ConvI2L (LoadI src))));
 6496   ins_cost(MEMORY_REF_COST);
 6497   size(Z_DISP3_SIZE);
 6498   format %{ &quot;MSGF    $dst, $src\t # long&quot; %}
 6499   opcode(MSGF_ZOPC, MSGF_ZOPC);
 6500   ins_encode(z_form_rt_mem_opt(dst, src));
 6501   ins_pipe(pipe_class_dummy);
 6502 %}
 6503 
 6504 instruct mulL_Reg_mem(iRegL dst, memory src)%{
 6505   match(Set dst (MulL dst (LoadL src)));
 6506   ins_cost(MEMORY_REF_COST);
 6507   size(Z_DISP3_SIZE);
 6508   format %{ &quot;MSG     $dst, $src\t # long&quot; %}
 6509   opcode(MSG_ZOPC, MSG_ZOPC);
 6510   ins_encode(z_form_rt_mem_opt(dst, src));
 6511   ins_pipe(pipe_class_dummy);
 6512 %}
 6513 
 6514 instruct mulHiL_reg_reg(revenRegL Rdst, roddRegL Rsrc1, iRegL Rsrc2, iRegL Rtmp1, flagsReg cr)%{
 6515   match(Set Rdst (MulHiL Rsrc1 Rsrc2));
 6516   effect(TEMP_DEF Rdst, USE_KILL Rsrc1, TEMP Rtmp1, KILL cr);
 6517   ins_cost(7*DEFAULT_COST);
 6518   // TODO: s390 port size(VARIABLE_SIZE);
 6519   format %{ &quot;MulHiL  $Rdst, $Rsrc1, $Rsrc2\t # Multiply High Long&quot; %}
 6520   ins_encode%{
 6521     Register dst  = $Rdst$$Register;
 6522     Register src1 = $Rsrc1$$Register;
 6523     Register src2 = $Rsrc2$$Register;
 6524     Register tmp1 = $Rtmp1$$Register;
 6525     Register tmp2 = $Rdst$$Register;
 6526     // z/Architecture has only unsigned multiply (64 * 64 -&gt; 128).
 6527     // implementing mulhs(a,b) = mulhu(a,b) – (a &amp; (b&gt;&gt;63)) – (b &amp; (a&gt;&gt;63))
 6528     __ z_srag(tmp2, src1, 63);  // a&gt;&gt;63
 6529     __ z_srag(tmp1, src2, 63);  // b&gt;&gt;63
 6530     __ z_ngr(tmp2, src2);       // b &amp; (a&gt;&gt;63)
 6531     __ z_ngr(tmp1, src1);       // a &amp; (b&gt;&gt;63)
 6532     __ z_agr(tmp1, tmp2);       // ((a &amp; (b&gt;&gt;63)) + (b &amp; (a&gt;&gt;63)))
 6533     __ z_mlgr(dst, src2);       // tricky: 128-bit product is written to even/odd pair (dst,src1),
 6534                                 //         multiplicand is taken from oddReg (src1), multiplier in src2.
 6535     __ z_sgr(dst, tmp1);
 6536   %}
 6537   ins_pipe(pipe_class_dummy);
 6538 %}
 6539 
 6540 //  DIV
 6541 
 6542 // Integer DIVMOD with Register, both quotient and mod results
 6543 instruct divModI_reg_divmod(roddRegI dst1src1, revenRegI dst2, noOdd_iRegI src2, flagsReg cr) %{
 6544   match(DivModI dst1src1 src2);
 6545   effect(KILL cr);
 6546   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6547   size((VM_Version::has_CompareBranch() ? 24 : 26));
 6548   format %{ &quot;DIVMODI ($dst1src1, $dst2) $src2&quot; %}
 6549   ins_encode %{
 6550     Register d1s1 = $dst1src1$$Register;
 6551     Register d2   = $dst2$$Register;
 6552     Register s2   = $src2$$Register;
 6553 
 6554     assert_different_registers(d1s1, s2);
 6555 
 6556     Label do_div, done_div;
 6557     if (VM_Version::has_CompareBranch()) {
 6558       __ z_cij(s2, -1, Assembler::bcondNotEqual, do_div);
 6559     } else {
 6560       __ z_chi(s2, -1);
 6561       __ z_brne(do_div);
 6562     }
 6563     __ z_lcr(d1s1, d1s1);
 6564     __ clear_reg(d2, false, false);
 6565     __ z_bru(done_div);
 6566     __ bind(do_div);
 6567     __ z_lgfr(d1s1, d1s1);
 6568     __ z_dsgfr(d2, s2);
 6569     __ bind(done_div);
 6570   %}
 6571   ins_pipe(pipe_class_dummy);
 6572 %}
 6573 
 6574 
 6575 // Register Division
 6576 instruct divI_reg_reg(roddRegI dst, iRegI src1, noOdd_iRegI src2, revenRegI tmp, flagsReg cr) %{
 6577   match(Set dst (DivI src1 src2));
 6578   effect(KILL tmp, KILL cr);
 6579   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6580   size((VM_Version::has_CompareBranch() ? 20 : 22));
 6581   format %{ &quot;DIV_checked $dst, $src1,$src2\t # treats special case 0x80../-1&quot; %}
 6582   ins_encode %{
 6583     Register a = $src1$$Register;
 6584     Register b = $src2$$Register;
 6585     Register t = $dst$$Register;
 6586 
 6587     assert_different_registers(t, b);
 6588 
 6589     Label do_div, done_div;
 6590     if (VM_Version::has_CompareBranch()) {
 6591       __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6592     } else {
 6593       __ z_chi(b, -1);
 6594       __ z_brne(do_div);
 6595     }
 6596     __ z_lcr(t, a);
 6597     __ z_bru(done_div);
 6598     __ bind(do_div);
 6599     __ z_lgfr(t, a);
 6600     __ z_dsgfr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6601     __ bind(done_div);
 6602   %}
 6603   ins_pipe(pipe_class_dummy);
 6604 %}
 6605 
 6606 // Immediate Division
 6607 instruct divI_reg_imm16(roddRegI dst, iRegI src1, immI16 src2, revenRegI tmp, flagsReg cr) %{
 6608   match(Set dst (DivI src1 src2));
 6609   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6610   ins_cost(2 * DEFAULT_COST);
 6611   // TODO: s390 port size(VARIABLE_SIZE);
 6612   format %{ &quot;DIV_const  $dst,$src1,$src2&quot; %}
 6613   ins_encode %{
 6614     // No sign extension of Rdividend needed here.
 6615     if ($src2$$constant != -1) {
 6616       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6617       __ z_lgfr($dst$$Register, $src1$$Register);
 6618       __ z_dsgfr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6619     } else {
 6620       __ z_lcr($dst$$Register, $src1$$Register);
 6621     }
 6622   %}
 6623   ins_pipe(pipe_class_dummy);
 6624 %}
 6625 
 6626 // Long DIVMOD with Register, both quotient and mod results
 6627 instruct divModL_reg_divmod(roddRegL dst1src1, revenRegL dst2, iRegL src2, flagsReg cr) %{
 6628   match(DivModL dst1src1 src2);
 6629   effect(KILL cr);
 6630   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6631   size((VM_Version::has_CompareBranch() ? 22 : 24));
 6632   format %{ &quot;DIVMODL ($dst1src1, $dst2) $src2&quot; %}
 6633   ins_encode %{
 6634     Register d1s1 = $dst1src1$$Register;
 6635     Register d2   = $dst2$$Register;
 6636     Register s2   = $src2$$Register;
 6637 
 6638     Label do_div, done_div;
 6639     if (VM_Version::has_CompareBranch()) {
 6640       __ z_cgij(s2, -1, Assembler::bcondNotEqual, do_div);
 6641     } else {
 6642       __ z_cghi(s2, -1);
 6643       __ z_brne(do_div);
 6644     }
 6645     __ z_lcgr(d1s1, d1s1);
 6646     // indicate unused result
 6647     (void) __ clear_reg(d2, true, false);
 6648     __ z_bru(done_div);
 6649     __ bind(do_div);
 6650     __ z_dsgr(d2, s2);
 6651     __ bind(done_div);
 6652   %}
 6653   ins_pipe(pipe_class_dummy);
 6654 %}
 6655 
 6656 // Register Long Division
 6657 instruct divL_reg_reg(roddRegL dst, iRegL src, revenRegL tmp, flagsReg cr) %{
 6658   match(Set dst (DivL dst src));
 6659   effect(KILL tmp, KILL cr);
 6660   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6661   size((VM_Version::has_CompareBranch() ? 18 : 20));
 6662   format %{ &quot;DIVG_checked  $dst, $src\t # long, treats special case 0x80../-1&quot; %}
 6663   ins_encode %{
 6664     Register b = $src$$Register;
 6665     Register t = $dst$$Register;
 6666 
 6667     Label done_div;
 6668     __ z_lcgr(t, t);    // Does no harm. divisor is in other register.
 6669     if (VM_Version::has_CompareBranch()) {
 6670       __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6671     } else {
 6672       __ z_cghi(b, -1);
 6673       __ z_bre(done_div);
 6674     }
 6675     __ z_lcgr(t, t);    // Restore sign.
 6676     __ z_dsgr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6677     __ bind(done_div);
 6678   %}
 6679   ins_pipe(pipe_class_dummy);
 6680 %}
 6681 
 6682 // Immediate Long Division
 6683 instruct divL_reg_imm16(roddRegL dst, iRegL src1, immL16 src2, revenRegL tmp, flagsReg cr) %{
 6684   match(Set dst (DivL src1 src2));
 6685   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6686   ins_cost(2 * DEFAULT_COST);
 6687   // TODO: s390 port size(VARIABLE_SIZE);
 6688   format %{ &quot;DIVG_const  $dst,$src1,$src2\t # long&quot; %}
 6689   ins_encode %{
 6690     if ($src2$$constant != -1) {
 6691       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6692       __ lgr_if_needed($dst$$Register, $src1$$Register);
 6693       __ z_dsgr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6694     } else {
 6695       __ z_lcgr($dst$$Register, $src1$$Register);
 6696     }
 6697   %}
 6698   ins_pipe(pipe_class_dummy);
 6699 %}
 6700 
 6701 // REM
 6702 
 6703 // Integer Remainder
 6704 // Register Remainder
 6705 instruct modI_reg_reg(revenRegI dst, iRegI src1, noOdd_iRegI src2, roddRegI tmp, flagsReg cr) %{
 6706   match(Set dst (ModI src1 src2));
 6707   effect(KILL tmp, KILL cr);
 6708   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6709   // TODO: s390 port size(VARIABLE_SIZE);
 6710   format %{ &quot;MOD_checked   $dst,$src1,$src2&quot; %}
 6711   ins_encode %{
 6712     Register a = $src1$$Register;
 6713     Register b = $src2$$Register;
 6714     Register t = $dst$$Register;
 6715     assert_different_registers(t-&gt;successor(), b);
 6716 
 6717     Label do_div, done_div;
 6718 
 6719     if ((t-&gt;encoding() != b-&gt;encoding()) &amp;&amp; (t-&gt;encoding() != a-&gt;encoding())) {
 6720       (void) __ clear_reg(t, true, false);  // Does no harm. Operands are in other regs.
 6721       if (VM_Version::has_CompareBranch()) {
 6722         __ z_cij(b, -1, Assembler::bcondEqual, done_div);
 6723       } else {
 6724         __ z_chi(b, -1);
 6725         __ z_bre(done_div);
 6726       }
 6727       __ z_lgfr(t-&gt;successor(), a);
 6728       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6729     } else {
 6730       if (VM_Version::has_CompareBranch()) {
 6731         __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6732       } else {
 6733         __ z_chi(b, -1);
 6734         __ z_brne(do_div);
 6735       }
 6736       __ clear_reg(t, true, false);
 6737       __ z_bru(done_div);
 6738       __ bind(do_div);
 6739       __ z_lgfr(t-&gt;successor(), a);
 6740       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6741     }
 6742     __ bind(done_div);
 6743   %}
 6744   ins_pipe(pipe_class_dummy);
 6745 %}
 6746 
 6747 // Immediate Remainder
 6748 instruct modI_reg_imm16(revenRegI dst, iRegI src1, immI16 src2, roddRegI tmp, flagsReg cr) %{
 6749   match(Set dst (ModI src1 src2));
 6750   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6751   ins_cost(3 * DEFAULT_COST);
 6752   // TODO: s390 port size(VARIABLE_SIZE);
 6753   format %{ &quot;MOD_const  $dst,src1,$src2&quot; %}
 6754   ins_encode %{
 6755     assert_different_registers($dst$$Register, $src1$$Register);
 6756     assert_different_registers($dst$$Register-&gt;successor(), $src1$$Register);
 6757     int divisor = $src2$$constant;
 6758 
 6759     if (divisor != -1) {
 6760       __ z_lghi(Z_R0_scratch, divisor);
 6761       __ z_lgfr($dst$$Register-&gt;successor(), $src1$$Register);
 6762       __ z_dsgfr($dst$$Register/* Dst is even part of a register pair. */, Z_R0_scratch); // Instruction kills tmp.
 6763     } else {
 6764       __ clear_reg($dst$$Register, true, false);
 6765     }
 6766   %}
 6767   ins_pipe(pipe_class_dummy);
 6768 %}
 6769 
 6770 // Register Long Remainder
 6771 instruct modL_reg_reg(revenRegL dst, roddRegL src1, iRegL src2, flagsReg cr) %{
 6772   match(Set dst (ModL src1 src2));
 6773   effect(KILL src1, KILL cr); // R0 is killed, too.
 6774   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6775   // TODO: s390 port size(VARIABLE_SIZE);
 6776   format %{ &quot;MODG_checked   $dst,$src1,$src2&quot; %}
 6777   ins_encode %{
 6778     Register a = $src1$$Register;
 6779     Register b = $src2$$Register;
 6780     Register t = $dst$$Register;
 6781     assert(t-&gt;successor() == a, &quot;(t,a) is an even-odd pair&quot; );
 6782 
 6783     Label do_div, done_div;
 6784     if (t-&gt;encoding() != b-&gt;encoding()) {
 6785       (void) __ clear_reg(t, true, false); // Does no harm. Dividend is in successor.
 6786       if (VM_Version::has_CompareBranch()) {
 6787         __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6788       } else {
 6789         __ z_cghi(b, -1);
 6790         __ z_bre(done_div);
 6791       }
 6792       __ z_dsgr(t, b);
 6793     } else {
 6794       if (VM_Version::has_CompareBranch()) {
 6795         __ z_cgij(b, -1, Assembler::bcondNotEqual, do_div);
 6796       } else {
 6797         __ z_cghi(b, -1);
 6798         __ z_brne(do_div);
 6799       }
 6800       __ clear_reg(t, true, false);
 6801       __ z_bru(done_div);
 6802       __ bind(do_div);
 6803       __ z_dsgr(t, b);
 6804     }
 6805     __ bind(done_div);
 6806   %}
 6807   ins_pipe(pipe_class_dummy);
 6808 %}
 6809 
 6810 // Register Long Remainder
 6811 instruct modL_reg_imm16(revenRegL dst, iRegL src1, immL16 src2, roddRegL tmp, flagsReg cr) %{
 6812   match(Set dst (ModL src1 src2));
 6813   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6814   ins_cost(3 * DEFAULT_COST);
 6815   // TODO: s390 port size(VARIABLE_SIZE);
 6816   format %{ &quot;MODG_const  $dst,src1,$src2\t # long&quot; %}
 6817   ins_encode %{
 6818     int divisor = $src2$$constant;
 6819     if (divisor != -1) {
 6820       __ z_lghi(Z_R0_scratch, divisor);
 6821       __ z_lgr($dst$$Register-&gt;successor(), $src1$$Register);
 6822       __ z_dsgr($dst$$Register /* Dst is even part of a register pair. */, Z_R0_scratch);  // Instruction kills tmp.
 6823     } else {
 6824       __ clear_reg($dst$$Register, true, false);
 6825     }
 6826   %}
 6827   ins_pipe(pipe_class_dummy);
 6828 %}
 6829 
 6830 // SHIFT
 6831 
 6832 // Shift left logical
 6833 
 6834 // Register Shift Left variable
 6835 instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
 6836   match(Set dst (LShiftI src nbits));
 6837   effect(KILL cr); // R1 is killed, too.
 6838   ins_cost(3 * DEFAULT_COST);
 6839   size(14);
 6840   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t # use RISC-like SLLG also for int&quot; %}
 6841   ins_encode %{
 6842     __ z_lgr(Z_R1_scratch, $nbits$$Register);
 6843     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6844     __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
 6845   %}
 6846   ins_pipe(pipe_class_dummy);
 6847 %}
 6848 
 6849 // Register Shift Left Immediate
 6850 // Constant shift count is masked in ideal graph already.
 6851 instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
 6852   match(Set dst (LShiftI src nbits));
 6853   size(6);
 6854   format %{ &quot;SLL     $dst,$src,$nbits\t # use RISC-like SLLG also for int&quot; %}
 6855   ins_encode %{
 6856     int Nbit = $nbits$$constant;
 6857     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6858     __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6859   %}
 6860   ins_pipe(pipe_class_dummy);
 6861 %}
 6862 
 6863 // Register Shift Left Immediate by 1bit
 6864 instruct sllI_reg_imm_1(iRegI dst, iRegI src, immI_1 nbits) %{
 6865   match(Set dst (LShiftI src nbits));
 6866   predicate(PreferLAoverADD);
 6867   ins_cost(DEFAULT_COST_LOW);
 6868   size(4);
 6869   format %{ &quot;LA      $dst,#0($src,$src)\t # SLL by 1 (int)&quot; %}
 6870   ins_encode %{ __ z_la($dst$$Register, 0, $src$$Register, $src$$Register); %}
 6871   ins_pipe(pipe_class_dummy);
 6872 %}
 6873 
 6874 // Register Shift Left Long
 6875 instruct sllL_reg_reg(iRegL dst, iRegL src1, iRegI nbits) %{
 6876   match(Set dst (LShiftL src1 nbits));
 6877   size(6);
 6878   format %{ &quot;SLLG    $dst,$src1,[$nbits]&quot; %}
 6879   opcode(SLLG_ZOPC);
 6880   ins_encode(z_rsyform_reg_reg(dst, src1, nbits));
 6881   ins_pipe(pipe_class_dummy);
 6882 %}
 6883 
 6884 // Register Shift Left Long Immediate
 6885 instruct sllL_reg_imm(iRegL dst, iRegL src1, immI nbits) %{
 6886   match(Set dst (LShiftL src1 nbits));
 6887   size(6);
 6888   format %{ &quot;SLLG    $dst,$src1,$nbits&quot; %}
 6889   opcode(SLLG_ZOPC);
 6890   ins_encode(z_rsyform_const(dst, src1, nbits));
 6891   ins_pipe(pipe_class_dummy);
 6892 %}
 6893 
 6894 // Register Shift Left Long Immediate by 1bit
 6895 instruct sllL_reg_imm_1(iRegL dst, iRegL src1, immI_1 nbits) %{
 6896   match(Set dst (LShiftL src1 nbits));
 6897   predicate(PreferLAoverADD);
 6898   ins_cost(DEFAULT_COST_LOW);
 6899   size(4);
 6900   format %{ &quot;LA      $dst,#0($src1,$src1)\t # SLLG by 1 (long)&quot; %}
 6901   ins_encode %{ __ z_la($dst$$Register, 0, $src1$$Register, $src1$$Register); %}
 6902   ins_pipe(pipe_class_dummy);
 6903 %}
 6904 
 6905 // Shift right arithmetic
 6906 
 6907 // Register Arithmetic Shift Right
 6908 instruct sraI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6909   match(Set dst (RShiftI dst src));
 6910   effect(KILL cr); // R1 is killed, too.
 6911   ins_cost(3 * DEFAULT_COST);
 6912   size(12);
 6913   format %{ &quot;SRA     $dst,[$src] &amp; 31&quot; %}
 6914   ins_encode %{
 6915     __ z_lgr(Z_R1_scratch, $src$$Register);
 6916     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6917     __ z_sra($dst$$Register, 0, Z_R1_scratch);
 6918   %}
 6919   ins_pipe(pipe_class_dummy);
 6920 %}
 6921 
 6922 // Register Arithmetic Shift Right Immediate
 6923 // Constant shift count is masked in ideal graph already.
 6924 instruct sraI_reg_imm(iRegI dst, immI src, flagsReg cr) %{
 6925   match(Set dst (RShiftI dst src));
 6926   effect(KILL cr);
 6927   size(4);
 6928   format %{ &quot;SRA     $dst,$src&quot; %}
 6929   ins_encode %{
 6930     int Nbit = $src$$constant;
 6931     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6932     __ z_sra($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6933   %}
 6934   ins_pipe(pipe_class_dummy);
 6935 %}
 6936 
 6937 // Register Arithmetic Shift Right Long
 6938 instruct sraL_reg_reg(iRegL dst, iRegL src1, iRegI src2, flagsReg cr) %{
 6939   match(Set dst (RShiftL src1 src2));
 6940   effect(KILL cr);
 6941   size(6);
 6942   format %{ &quot;SRAG    $dst,$src1,[$src2]&quot; %}
 6943   opcode(SRAG_ZOPC);
 6944   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6945   ins_pipe(pipe_class_dummy);
 6946 %}
 6947 
 6948 // Register Arithmetic Shift Right Long Immediate
 6949 instruct sraL_reg_imm(iRegL dst, iRegL src1, immI src2, flagsReg cr) %{
 6950   match(Set dst (RShiftL src1 src2));
 6951   effect(KILL cr);
 6952   size(6);
 6953   format %{ &quot;SRAG    $dst,$src1,$src2&quot; %}
 6954   opcode(SRAG_ZOPC);
 6955   ins_encode(z_rsyform_const(dst, src1, src2));
 6956   ins_pipe(pipe_class_dummy);
 6957 %}
 6958 
 6959 //  Shift right logical
 6960 
 6961 // Register Shift Right
 6962 instruct srlI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6963   match(Set dst (URShiftI dst src));
 6964   effect(KILL cr); // R1 is killed, too.
 6965   ins_cost(3 * DEFAULT_COST);
 6966   size(12);
 6967   format %{ &quot;SRL     $dst,[$src] &amp; 31&quot; %}
 6968   ins_encode %{
 6969     __ z_lgr(Z_R1_scratch, $src$$Register);
 6970     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6971     __ z_srl($dst$$Register, 0, Z_R1_scratch);
 6972   %}
 6973   ins_pipe(pipe_class_dummy);
 6974 %}
 6975 
 6976 // Register Shift Right Immediate
 6977 // Constant shift count is masked in ideal graph already.
 6978 instruct srlI_reg_imm(iRegI dst, immI src) %{
 6979   match(Set dst (URShiftI dst src));
 6980   size(4);
 6981   format %{ &quot;SRL     $dst,$src&quot; %}
 6982   ins_encode %{
 6983     int Nbit = $src$$constant;
 6984     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6985     __ z_srl($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6986   %}
 6987   ins_pipe(pipe_class_dummy);
 6988 %}
 6989 
 6990 // Register Shift Right Long
 6991 instruct srlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 6992   match(Set dst (URShiftL src1 src2));
 6993   size(6);
 6994   format %{ &quot;SRLG    $dst,$src1,[$src2]&quot; %}
 6995   opcode(SRLG_ZOPC);
 6996   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6997   ins_pipe(pipe_class_dummy);
 6998 %}
 6999 
 7000 // Register Shift Right Long Immediate
 7001 instruct srlL_reg_imm(iRegL dst, iRegL src1, immI src2) %{
 7002   match(Set dst (URShiftL src1 src2));
 7003   size(6);
 7004   format %{ &quot;SRLG    $dst,$src1,$src2&quot; %}
 7005   opcode(SRLG_ZOPC);
 7006   ins_encode(z_rsyform_const(dst, src1, src2));
 7007   ins_pipe(pipe_class_dummy);
 7008 %}
 7009 
 7010 // Register Shift Right Immediate with a CastP2X
 7011 instruct srlP_reg_imm(iRegL dst, iRegP_N2P src1, immI src2) %{
 7012   match(Set dst (URShiftL (CastP2X src1) src2));
 7013   size(6);
 7014   format %{ &quot;SRLG    $dst,$src1,$src2\t # Cast ptr $src1 to long and shift&quot; %}
 7015   opcode(SRLG_ZOPC);
 7016   ins_encode(z_rsyform_const(dst, src1, src2));
 7017   ins_pipe(pipe_class_dummy);
 7018 %}
 7019 
 7020 //----------Rotate Instructions------------------------------------------------
 7021 
 7022 // Rotate left 32bit.
 7023 instruct rotlI_reg_immI8(iRegI dst, iRegI src, immI8 lshift, immI8 rshift) %{
 7024   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 7025   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7026   size(6);
 7027   format %{ &quot;RLL     $dst,$src,$lshift\t # ROTL32&quot; %}
 7028   opcode(RLL_ZOPC);
 7029   ins_encode(z_rsyform_const(dst, src, lshift));
 7030   ins_pipe(pipe_class_dummy);
 7031 %}
 7032 
 7033 // Rotate left 64bit.
 7034 instruct rotlL_reg_immI8(iRegL dst, iRegL src, immI8 lshift, immI8 rshift) %{
 7035   match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));
 7036   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7037   size(6);
 7038   format %{ &quot;RLLG    $dst,$src,$lshift\t # ROTL64&quot; %}
 7039   opcode(RLLG_ZOPC);
 7040   ins_encode(z_rsyform_const(dst, src, lshift));
 7041   ins_pipe(pipe_class_dummy);
 7042 %}
 7043 
 7044 // Rotate right 32bit.
 7045 instruct rotrI_reg_immI8(iRegI dst, iRegI src, immI8 rshift, immI8 lshift) %{
 7046   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 7047   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7048   // TODO: s390 port size(FIXED_SIZE);
 7049   format %{ &quot;RLL     $dst,$src,$rshift\t # ROTR32&quot; %}
 7050   opcode(RLL_ZOPC);
 7051   ins_encode(z_rsyform_const(dst, src, rshift));
 7052   ins_pipe(pipe_class_dummy);
 7053 %}
 7054 
 7055 // Rotate right 64bit.
 7056 instruct rotrL_reg_immI8(iRegL dst, iRegL src, immI8 rshift, immI8 lshift) %{
 7057   match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));
 7058   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7059   // TODO: s390 port size(FIXED_SIZE);
 7060   format %{ &quot;RLLG    $dst,$src,$rshift\t # ROTR64&quot; %}
 7061   opcode(RLLG_ZOPC);
 7062   ins_encode(z_rsyform_const(dst, src, rshift));
 7063   ins_pipe(pipe_class_dummy);
 7064 %}
 7065 
 7066 
 7067 //----------Overflow Math Instructions-----------------------------------------
 7068 
 7069 instruct overflowAddI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7070   match(Set cr (OverflowAddI op1 op2));
 7071   effect(DEF cr, USE op1, USE op2);
 7072   // TODO: s390 port size(FIXED_SIZE);
 7073   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7074   ins_encode %{
 7075     __ z_lr(Z_R0_scratch, $op1$$Register);
 7076     __ z_ar(Z_R0_scratch, $op2$$Register);
 7077   %}
 7078   ins_pipe(pipe_class_dummy);
 7079 %}
 7080 
 7081 instruct overflowAddI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7082   match(Set cr (OverflowAddI op1 op2));
 7083   effect(DEF cr, USE op1, USE op2);
 7084   // TODO: s390 port size(VARIABLE_SIZE);
 7085   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7086   ins_encode %{
 7087     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7088     __ z_ar(Z_R0_scratch, $op1$$Register);
 7089   %}
 7090   ins_pipe(pipe_class_dummy);
 7091 %}
 7092 
 7093 instruct overflowAddL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7094   match(Set cr (OverflowAddL op1 op2));
 7095   effect(DEF cr, USE op1, USE op2);
 7096   // TODO: s390 port size(FIXED_SIZE);
 7097   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7098   ins_encode %{
 7099     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7100     __ z_agr(Z_R0_scratch, $op2$$Register);
 7101   %}
 7102   ins_pipe(pipe_class_dummy);
 7103 %}
 7104 
 7105 instruct overflowAddL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7106   match(Set cr (OverflowAddL op1 op2));
 7107   effect(DEF cr, USE op1, USE op2);
 7108   // TODO: s390 port size(VARIABLE_SIZE);
 7109   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7110   ins_encode %{
 7111     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7112     __ z_agr(Z_R0_scratch, $op1$$Register);
 7113   %}
 7114   ins_pipe(pipe_class_dummy);
 7115 %}
 7116 
 7117 instruct overflowSubI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7118   match(Set cr (OverflowSubI op1 op2));
 7119   effect(DEF cr, USE op1, USE op2);
 7120   // TODO: s390 port size(FIXED_SIZE);
 7121   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7122   ins_encode %{
 7123     __ z_lr(Z_R0_scratch, $op1$$Register);
 7124     __ z_sr(Z_R0_scratch, $op2$$Register);
 7125   %}
 7126   ins_pipe(pipe_class_dummy);
 7127 %}
 7128 
 7129 instruct overflowSubI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7130   match(Set cr (OverflowSubI op1 op2));
 7131   effect(DEF cr, USE op1, USE op2);
 7132   // TODO: s390 port size(VARIABLE_SIZE);
 7133   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7134   ins_encode %{
 7135     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7136     __ z_lr(Z_R0_scratch, $op1$$Register);
 7137     __ z_sr(Z_R0_scratch, Z_R1_scratch);
 7138   %}
 7139   ins_pipe(pipe_class_dummy);
 7140 %}
 7141 
 7142 instruct overflowSubL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7143   match(Set cr (OverflowSubL op1 op2));
 7144   effect(DEF cr, USE op1, USE op2);
 7145   // TODO: s390 port size(FIXED_SIZE);
 7146   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7147   ins_encode %{
 7148     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7149     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7150   %}
 7151   ins_pipe(pipe_class_dummy);
 7152 %}
 7153 
 7154 instruct overflowSubL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7155   match(Set cr (OverflowSubL op1 op2));
 7156   effect(DEF cr, USE op1, USE op2);
 7157   // TODO: s390 port size(VARIABLE_SIZE);
 7158   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7159   ins_encode %{
 7160     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7161     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7162     __ z_sgr(Z_R0_scratch, Z_R1_scratch);
 7163   %}
 7164   ins_pipe(pipe_class_dummy);
 7165 %}
 7166 
 7167 instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
 7168   match(Set cr (OverflowSubI zero op2));
 7169   effect(DEF cr, USE op2);
 7170   format %{ &quot;NEG    $op2\t # overflow check int&quot; %}
 7171   ins_encode %{
 7172     __ clear_reg(Z_R0_scratch, false, false);
 7173     __ z_sr(Z_R0_scratch, $op2$$Register);
 7174   %}
 7175   ins_pipe(pipe_class_dummy);
 7176 %}
 7177 
 7178 instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
 7179   match(Set cr (OverflowSubL zero op2));
 7180   effect(DEF cr, USE op2);
 7181   format %{ &quot;NEGG    $op2\t # overflow check long&quot; %}
 7182   ins_encode %{
 7183     __ clear_reg(Z_R0_scratch, true, false);
 7184     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7185   %}
 7186   ins_pipe(pipe_class_dummy);
 7187 %}
 7188 
 7189 // No intrinsics for multiplication, since there is no easy way
 7190 // to check for overflow.
 7191 
 7192 
 7193 //----------Floating Point Arithmetic Instructions-----------------------------
 7194 
 7195 //  ADD
 7196 
 7197 //  Add float single precision
 7198 instruct addF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7199   match(Set dst (AddF dst src));
 7200   effect(KILL cr);
 7201   ins_cost(ALU_REG_COST);
 7202   size(4);
 7203   format %{ &quot;AEBR     $dst,$src&quot; %}
 7204   opcode(AEBR_ZOPC);
 7205   ins_encode(z_rreform(dst, src));
 7206   ins_pipe(pipe_class_dummy);
 7207 %}
 7208 
 7209 instruct addF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7210   match(Set dst (AddF dst (LoadF src)));
 7211   effect(KILL cr);
 7212   ins_cost(ALU_MEMORY_COST);
 7213   size(6);
 7214   format %{ &quot;AEB      $dst,$src\t # floatMemory&quot; %}
 7215   opcode(AEB_ZOPC);
 7216   ins_encode(z_form_rt_memFP(dst, src));
 7217   ins_pipe(pipe_class_dummy);
 7218 %}
 7219 
 7220 // Add float double precision
 7221 instruct addD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7222   match(Set dst (AddD dst src));
 7223   effect(KILL cr);
 7224   ins_cost(ALU_REG_COST);
 7225   size(4);
 7226   format %{ &quot;ADBR     $dst,$src&quot; %}
 7227   opcode(ADBR_ZOPC);
 7228   ins_encode(z_rreform(dst, src));
 7229   ins_pipe(pipe_class_dummy);
 7230 %}
 7231 
 7232 instruct addD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7233   match(Set dst (AddD dst (LoadD src)));
 7234   effect(KILL cr);
 7235   ins_cost(ALU_MEMORY_COST);
 7236   size(6);
 7237   format %{ &quot;ADB      $dst,$src\t # doubleMemory&quot; %}
 7238   opcode(ADB_ZOPC);
 7239   ins_encode(z_form_rt_memFP(dst, src));
 7240   ins_pipe(pipe_class_dummy);
 7241 %}
 7242 
 7243 // SUB
 7244 
 7245 // Sub float single precision
 7246 instruct subF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7247   match(Set dst (SubF dst src));
 7248   effect(KILL cr);
 7249   ins_cost(ALU_REG_COST);
 7250   size(4);
 7251   format %{ &quot;SEBR     $dst,$src&quot; %}
 7252   opcode(SEBR_ZOPC);
 7253   ins_encode(z_rreform(dst, src));
 7254   ins_pipe(pipe_class_dummy);
 7255 %}
 7256 
 7257 instruct subF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7258   match(Set dst (SubF dst (LoadF src)));
 7259   effect(KILL cr);
 7260   ins_cost(ALU_MEMORY_COST);
 7261   size(6);
 7262   format %{ &quot;SEB      $dst,$src\t # floatMemory&quot; %}
 7263   opcode(SEB_ZOPC);
 7264   ins_encode(z_form_rt_memFP(dst, src));
 7265   ins_pipe(pipe_class_dummy);
 7266 %}
 7267 
 7268 //  Sub float double precision
 7269 instruct subD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7270   match(Set dst (SubD dst src));
 7271   effect(KILL cr);
 7272   ins_cost(ALU_REG_COST);
 7273   size(4);
 7274   format %{ &quot;SDBR     $dst,$src&quot; %}
 7275   opcode(SDBR_ZOPC);
 7276   ins_encode(z_rreform(dst, src));
 7277   ins_pipe(pipe_class_dummy);
 7278 %}
 7279 
 7280 instruct subD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7281   match(Set dst (SubD dst (LoadD src)));
 7282   effect(KILL cr);
 7283   ins_cost(ALU_MEMORY_COST);
 7284   size(6);
 7285   format %{ &quot;SDB      $dst,$src\t # doubleMemory&quot; %}
 7286   opcode(SDB_ZOPC);
 7287   ins_encode(z_form_rt_memFP(dst, src));
 7288   ins_pipe(pipe_class_dummy);
 7289 %}
 7290 
 7291 // MUL
 7292 
 7293 // Mul float single precision
 7294 instruct mulF_reg_reg(regF dst, regF src) %{
 7295   match(Set dst (MulF dst src));
 7296   // CC unchanged by MUL.
 7297   ins_cost(ALU_REG_COST);
 7298   size(4);
 7299   format %{ &quot;MEEBR    $dst,$src&quot; %}
 7300   opcode(MEEBR_ZOPC);
 7301   ins_encode(z_rreform(dst, src));
 7302   ins_pipe(pipe_class_dummy);
 7303 %}
 7304 
 7305 instruct mulF_reg_mem(regF dst, memoryRX src)%{
 7306   match(Set dst (MulF dst (LoadF src)));
 7307   // CC unchanged by MUL.
 7308   ins_cost(ALU_MEMORY_COST);
 7309   size(6);
 7310   format %{ &quot;MEEB     $dst,$src\t # floatMemory&quot; %}
 7311   opcode(MEEB_ZOPC);
 7312   ins_encode(z_form_rt_memFP(dst, src));
 7313   ins_pipe(pipe_class_dummy);
 7314 %}
 7315 
 7316 //  Mul float double precision
 7317 instruct mulD_reg_reg(regD dst, regD src) %{
 7318   match(Set dst (MulD dst src));
 7319   // CC unchanged by MUL.
 7320   ins_cost(ALU_REG_COST);
 7321   size(4);
 7322   format %{ &quot;MDBR     $dst,$src&quot; %}
 7323   opcode(MDBR_ZOPC);
 7324   ins_encode(z_rreform(dst, src));
 7325   ins_pipe(pipe_class_dummy);
 7326 %}
 7327 
 7328 instruct mulD_reg_mem(regD dst, memoryRX src)%{
 7329   match(Set dst (MulD dst (LoadD src)));
 7330   // CC unchanged by MUL.
 7331   ins_cost(ALU_MEMORY_COST);
 7332   size(6);
 7333   format %{ &quot;MDB      $dst,$src\t # doubleMemory&quot; %}
 7334   opcode(MDB_ZOPC);
 7335   ins_encode(z_form_rt_memFP(dst, src));
 7336   ins_pipe(pipe_class_dummy);
 7337 %}
 7338 
 7339 // Multiply-Accumulate
 7340 // src1 * src2 + dst
 7341 instruct maddF_reg_reg(regF dst, regF src1, regF src2) %{
 7342   match(Set dst (FmaF dst (Binary src1 src2)));
 7343   // CC unchanged by MUL-ADD.
 7344   ins_cost(ALU_REG_COST);
 7345   size(4);
 7346   format %{ &quot;MAEBR    $dst, $src1, $src2&quot; %}
 7347   ins_encode %{
 7348     __ z_maebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7349   %}
 7350   ins_pipe(pipe_class_dummy);
 7351 %}
 7352 
 7353 // src1 * src2 + dst
 7354 instruct maddD_reg_reg(regD dst, regD src1, regD src2) %{
 7355   match(Set dst (FmaD dst (Binary src1 src2)));
 7356   // CC unchanged by MUL-ADD.
 7357   ins_cost(ALU_REG_COST);
 7358   size(4);
 7359   format %{ &quot;MADBR    $dst, $src1, $src2&quot; %}
 7360   ins_encode %{
 7361     __ z_madbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7362   %}
 7363   ins_pipe(pipe_class_dummy);
 7364 %}
 7365 
 7366 // src1 * src2 - dst
 7367 instruct msubF_reg_reg(regF dst, regF src1, regF src2) %{
 7368   match(Set dst (FmaF (NegF dst) (Binary src1 src2)));
 7369   // CC unchanged by MUL-SUB.
 7370   ins_cost(ALU_REG_COST);
 7371   size(4);
 7372   format %{ &quot;MSEBR    $dst, $src1, $src2&quot; %}
 7373   ins_encode %{
 7374     __ z_msebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7375   %}
 7376   ins_pipe(pipe_class_dummy);
 7377 %}
 7378 
 7379 // src1 * src2 - dst
 7380 instruct msubD_reg_reg(regD dst, regD src1, regD src2) %{
 7381   match(Set dst (FmaD (NegD dst) (Binary src1 src2)));
 7382   // CC unchanged by MUL-SUB.
 7383   ins_cost(ALU_REG_COST);
 7384   size(4);
 7385   format %{ &quot;MSDBR    $dst, $src1, $src2&quot; %}
 7386   ins_encode %{
 7387     __ z_msdbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7388   %}
 7389   ins_pipe(pipe_class_dummy);
 7390 %}
 7391 
 7392 // src1 * src2 + dst
 7393 instruct maddF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7394   match(Set dst (FmaF dst (Binary src1 (LoadF src2))));
 7395   // CC unchanged by MUL-ADD.
 7396   ins_cost(ALU_MEMORY_COST);
 7397   size(6);
 7398   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7399   ins_encode %{
 7400     __ z_maeb($dst$$FloatRegister, $src1$$FloatRegister,
 7401               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7402   %}
 7403   ins_pipe(pipe_class_dummy);
 7404 %}
 7405 
 7406 // src1 * src2 + dst
 7407 instruct maddD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7408   match(Set dst (FmaD dst (Binary src1 (LoadD src2))));
 7409   // CC unchanged by MUL-ADD.
 7410   ins_cost(ALU_MEMORY_COST);
 7411   size(6);
 7412   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7413   ins_encode %{
 7414     __ z_madb($dst$$FloatRegister, $src1$$FloatRegister,
 7415               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7416   %}
 7417   ins_pipe(pipe_class_dummy);
 7418 %}
 7419 
 7420 // src1 * src2 - dst
 7421 instruct msubF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7422   match(Set dst (FmaF (NegF dst) (Binary src1 (LoadF src2))));
 7423   // CC unchanged by MUL-SUB.
 7424   ins_cost(ALU_MEMORY_COST);
 7425   size(6);
 7426   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7427   ins_encode %{
 7428     __ z_mseb($dst$$FloatRegister, $src1$$FloatRegister,
 7429               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7430   %}
 7431   ins_pipe(pipe_class_dummy);
 7432 %}
 7433 
 7434 // src1 * src2 - dst
 7435 instruct msubD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7436   match(Set dst (FmaD (NegD dst) (Binary src1 (LoadD src2))));
 7437   // CC unchanged by MUL-SUB.
 7438   ins_cost(ALU_MEMORY_COST);
 7439   size(6);
 7440   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7441   ins_encode %{
 7442     __ z_msdb($dst$$FloatRegister, $src1$$FloatRegister,
 7443               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7444   %}
 7445   ins_pipe(pipe_class_dummy);
 7446 %}
 7447 
 7448 // src1 * src2 + dst
 7449 instruct maddF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7450   match(Set dst (FmaF dst (Binary (LoadF src1) src2)));
 7451   // CC unchanged by MUL-ADD.
 7452   ins_cost(ALU_MEMORY_COST);
 7453   size(6);
 7454   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7455   ins_encode %{
 7456     __ z_maeb($dst$$FloatRegister, $src2$$FloatRegister,
 7457               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7458   %}
 7459   ins_pipe(pipe_class_dummy);
 7460 %}
 7461 
 7462 // src1 * src2 + dst
 7463 instruct maddD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7464   match(Set dst (FmaD dst (Binary (LoadD src1) src2)));
 7465   // CC unchanged by MUL-ADD.
 7466   ins_cost(ALU_MEMORY_COST);
 7467   size(6);
 7468   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7469   ins_encode %{
 7470     __ z_madb($dst$$FloatRegister, $src2$$FloatRegister,
 7471               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7472   %}
 7473   ins_pipe(pipe_class_dummy);
 7474 %}
 7475 
 7476 // src1 * src2 - dst
 7477 instruct msubF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7478   match(Set dst (FmaF (NegF dst) (Binary (LoadF src1) src2)));
 7479   // CC unchanged by MUL-SUB.
 7480   ins_cost(ALU_MEMORY_COST);
 7481   size(6);
 7482   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7483   ins_encode %{
 7484     __ z_mseb($dst$$FloatRegister, $src2$$FloatRegister,
 7485               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7486   %}
 7487   ins_pipe(pipe_class_dummy);
 7488 %}
 7489 
 7490 // src1 * src2 - dst
 7491 instruct msubD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7492   match(Set dst (FmaD (NegD dst) (Binary (LoadD src1) src2)));
 7493   // CC unchanged by MUL-SUB.
 7494   ins_cost(ALU_MEMORY_COST);
 7495   size(6);
 7496   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7497   ins_encode %{
 7498     __ z_msdb($dst$$FloatRegister, $src2$$FloatRegister,
 7499               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7500   %}
 7501   ins_pipe(pipe_class_dummy);
 7502 %}
 7503 
 7504 //  DIV
 7505 
 7506 //  Div float single precision
 7507 instruct divF_reg_reg(regF dst, regF src) %{
 7508   match(Set dst (DivF dst src));
 7509   // CC unchanged by DIV.
 7510   ins_cost(ALU_REG_COST);
 7511   size(4);
 7512   format %{ &quot;DEBR     $dst,$src&quot; %}
 7513   opcode(DEBR_ZOPC);
 7514   ins_encode(z_rreform(dst, src));
 7515   ins_pipe(pipe_class_dummy);
 7516 %}
 7517 
 7518 instruct divF_reg_mem(regF dst, memoryRX src)%{
 7519   match(Set dst (DivF dst (LoadF src)));
 7520   // CC unchanged by DIV.
 7521   ins_cost(ALU_MEMORY_COST);
 7522   size(6);
 7523   format %{ &quot;DEB      $dst,$src\t # floatMemory&quot; %}
 7524   opcode(DEB_ZOPC);
 7525   ins_encode(z_form_rt_memFP(dst, src));
 7526   ins_pipe(pipe_class_dummy);
 7527 %}
 7528 
 7529 //  Div float double precision
 7530 instruct divD_reg_reg(regD dst, regD src) %{
 7531   match(Set dst (DivD dst src));
 7532   // CC unchanged by DIV.
 7533   ins_cost(ALU_REG_COST);
 7534   size(4);
 7535   format %{ &quot;DDBR     $dst,$src&quot; %}
 7536   opcode(DDBR_ZOPC);
 7537   ins_encode(z_rreform(dst, src));
 7538   ins_pipe(pipe_class_dummy);
 7539 %}
 7540 
 7541 instruct divD_reg_mem(regD dst, memoryRX src)%{
 7542   match(Set dst (DivD dst (LoadD src)));
 7543   // CC unchanged by DIV.
 7544   ins_cost(ALU_MEMORY_COST);
 7545   size(6);
 7546   format %{ &quot;DDB      $dst,$src\t # doubleMemory&quot; %}
 7547   opcode(DDB_ZOPC);
 7548   ins_encode(z_form_rt_memFP(dst, src));
 7549   ins_pipe(pipe_class_dummy);
 7550 %}
 7551 
 7552 // ABS
 7553 
 7554 // Absolute float single precision
 7555 instruct absF_reg(regF dst, regF src, flagsReg cr) %{
 7556   match(Set dst (AbsF src));
 7557   effect(KILL cr);
 7558   size(4);
 7559   format %{ &quot;LPEBR    $dst,$src\t float&quot; %}
 7560   opcode(LPEBR_ZOPC);
 7561   ins_encode(z_rreform(dst, src));
 7562   ins_pipe(pipe_class_dummy);
 7563 %}
 7564 
 7565 // Absolute float double precision
 7566 instruct absD_reg(regD dst, regD src, flagsReg cr) %{
 7567   match(Set dst (AbsD src));
 7568   effect(KILL cr);
 7569   size(4);
 7570   format %{ &quot;LPDBR    $dst,$src\t double&quot; %}
 7571   opcode(LPDBR_ZOPC);
 7572   ins_encode(z_rreform(dst, src));
 7573   ins_pipe(pipe_class_dummy);
 7574 %}
 7575 
 7576 //  NEG(ABS)
 7577 
 7578 // Negative absolute float single precision
 7579 instruct nabsF_reg(regF dst, regF src, flagsReg cr) %{
 7580   match(Set dst (NegF (AbsF src)));
 7581   effect(KILL cr);
 7582   size(4);
 7583   format %{ &quot;LNEBR    $dst,$src\t float&quot; %}
 7584   opcode(LNEBR_ZOPC);
 7585   ins_encode(z_rreform(dst, src));
 7586   ins_pipe(pipe_class_dummy);
 7587 %}
 7588 
 7589 // Negative absolute float double precision
 7590 instruct nabsD_reg(regD dst, regD src, flagsReg cr) %{
 7591   match(Set dst (NegD (AbsD src)));
 7592   effect(KILL cr);
 7593   size(4);
 7594   format %{ &quot;LNDBR    $dst,$src\t double&quot; %}
 7595   opcode(LNDBR_ZOPC);
 7596   ins_encode(z_rreform(dst, src));
 7597   ins_pipe(pipe_class_dummy);
 7598 %}
 7599 
 7600 // NEG
 7601 
 7602 instruct negF_reg(regF dst, regF src, flagsReg cr) %{
 7603   match(Set dst (NegF src));
 7604   effect(KILL cr);
 7605   size(4);
 7606   format %{ &quot;NegF     $dst,$src\t float&quot; %}
 7607   ins_encode %{ __ z_lcebr($dst$$FloatRegister, $src$$FloatRegister); %}
 7608   ins_pipe(pipe_class_dummy);
 7609 %}
 7610 
 7611 instruct negD_reg(regD dst, regD src, flagsReg cr) %{
 7612   match(Set dst (NegD src));
 7613   effect(KILL cr);
 7614   size(4);
 7615   format %{ &quot;NegD     $dst,$src\t double&quot; %}
 7616   ins_encode %{ __ z_lcdbr($dst$$FloatRegister, $src$$FloatRegister); %}
 7617   ins_pipe(pipe_class_dummy);
 7618 %}
 7619 
 7620 // SQRT
 7621 
 7622 // Sqrt float precision
 7623 instruct sqrtF_reg(regF dst, regF src) %{
 7624   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7625   // CC remains unchanged.
 7626   ins_cost(ALU_REG_COST);
 7627   size(4);
 7628   format %{ &quot;SQEBR    $dst,$src&quot; %}
 7629   opcode(SQEBR_ZOPC);
 7630   ins_encode(z_rreform(dst, src));
 7631   ins_pipe(pipe_class_dummy);
 7632 %}
 7633 
 7634 // Sqrt double precision
 7635 instruct sqrtD_reg(regD dst, regD src) %{
 7636   match(Set dst (SqrtD src));
 7637   // CC remains unchanged.
 7638   ins_cost(ALU_REG_COST);
 7639   size(4);
 7640   format %{ &quot;SQDBR    $dst,$src&quot; %}
 7641   opcode(SQDBR_ZOPC);
 7642   ins_encode(z_rreform(dst, src));
 7643   ins_pipe(pipe_class_dummy);
 7644 %}
 7645 
 7646 instruct sqrtF_mem(regF dst, memoryRX src) %{
 7647   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7648   // CC remains unchanged.
 7649   ins_cost(ALU_MEMORY_COST);
 7650   size(6);
 7651   format %{ &quot;SQEB     $dst,$src\t # floatMemory&quot; %}
 7652   opcode(SQEB_ZOPC);
 7653   ins_encode(z_form_rt_memFP(dst, src));
 7654   ins_pipe(pipe_class_dummy);
 7655 %}
 7656 
 7657 instruct sqrtD_mem(regD dst, memoryRX src) %{
 7658   match(Set dst (SqrtD src));
 7659   // CC remains unchanged.
 7660   ins_cost(ALU_MEMORY_COST);
 7661   // TODO: s390 port size(FIXED_SIZE);
 7662   format %{ &quot;SQDB     $dst,$src\t # doubleMemory&quot; %}
 7663   opcode(SQDB_ZOPC);
 7664   ins_encode(z_form_rt_memFP(dst, src));
 7665   ins_pipe(pipe_class_dummy);
 7666 %}
 7667 
 7668 //----------Logical Instructions-----------------------------------------------
 7669 
 7670 // Register And
 7671 instruct andI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7672   match(Set dst (AndI dst src));
 7673   effect(KILL cr);
 7674   ins_cost(DEFAULT_COST_LOW);
 7675   size(2);
 7676   format %{ &quot;NR      $dst,$src\t # int&quot; %}
 7677   opcode(NR_ZOPC);
 7678   ins_encode(z_rrform(dst, src));
 7679   ins_pipe(pipe_class_dummy);
 7680 %}
 7681 
 7682 instruct andI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7683   match(Set dst (AndI dst (LoadI src)));
 7684   effect(KILL cr);
 7685   ins_cost(MEMORY_REF_COST);
 7686   // TODO: s390 port size(VARIABLE_SIZE);
 7687   format %{ &quot;N(Y)    $dst, $src\t # int&quot; %}
 7688   opcode(NY_ZOPC, N_ZOPC);
 7689   ins_encode(z_form_rt_mem_opt(dst, src));
 7690   ins_pipe(pipe_class_dummy);
 7691 %}
 7692 
 7693 // Immediate And
 7694 instruct andI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7695   match(Set dst (AndI dst src));
 7696   effect(KILL cr);
 7697   ins_cost(DEFAULT_COST_HIGH);
 7698   size(6);
 7699   format %{ &quot;NILF    $dst,$src&quot; %}
 7700   opcode(NILF_ZOPC);
 7701   ins_encode(z_rilform_unsigned(dst, src));
 7702   ins_pipe(pipe_class_dummy);
 7703 %}
 7704 
 7705 instruct andI_reg_uimmI_LH1(iRegI dst, uimmI_LH1 src, flagsReg cr) %{
 7706   match(Set dst (AndI dst src));
 7707   effect(KILL cr);
 7708   ins_cost(DEFAULT_COST);
 7709   size(4);
 7710   format %{ &quot;NILH    $dst,$src&quot; %}
 7711   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7712   ins_pipe(pipe_class_dummy);
 7713 %}
 7714 
 7715 instruct andI_reg_uimmI_LL1(iRegI dst, uimmI_LL1 src, flagsReg cr) %{
 7716   match(Set dst (AndI dst src));
 7717   effect(KILL cr);
 7718   ins_cost(DEFAULT_COST);
 7719   size(4);
 7720   format %{ &quot;NILL    $dst,$src&quot; %}
 7721   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7722   ins_pipe(pipe_class_dummy);
 7723 %}
 7724 
 7725 // Register And Long
 7726 instruct andL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7727   match(Set dst (AndL dst src));
 7728   effect(KILL cr);
 7729   ins_cost(DEFAULT_COST);
 7730   size(4);
 7731   format %{ &quot;NGR     $dst,$src\t # long&quot; %}
 7732   opcode(NGR_ZOPC);
 7733   ins_encode(z_rreform(dst, src));
 7734   ins_pipe(pipe_class_dummy);
 7735 %}
 7736 
 7737 instruct andL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7738   match(Set dst (AndL dst (LoadL src)));
 7739   effect(KILL cr);
 7740   ins_cost(MEMORY_REF_COST);
 7741   size(Z_DISP3_SIZE);
 7742   format %{ &quot;NG      $dst, $src\t # long&quot; %}
 7743   opcode(NG_ZOPC, NG_ZOPC);
 7744   ins_encode(z_form_rt_mem_opt(dst, src));
 7745   ins_pipe(pipe_class_dummy);
 7746 %}
 7747 
 7748 instruct andL_reg_uimmL_LL1(iRegL dst, uimmL_LL1 src, flagsReg cr) %{
 7749   match(Set dst (AndL dst src));
 7750   effect(KILL cr);
 7751   ins_cost(DEFAULT_COST);
 7752   size(4);
 7753   format %{ &quot;NILL    $dst,$src\t # long&quot; %}
 7754   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7755   ins_pipe(pipe_class_dummy);
 7756 %}
 7757 
 7758 instruct andL_reg_uimmL_LH1(iRegL dst, uimmL_LH1 src, flagsReg cr) %{
 7759   match(Set dst (AndL dst src));
 7760   effect(KILL cr);
 7761   ins_cost(DEFAULT_COST);
 7762   size(4);
 7763   format %{ &quot;NILH    $dst,$src\t # long&quot; %}
 7764   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7765   ins_pipe(pipe_class_dummy);
 7766 %}
 7767 
 7768 instruct andL_reg_uimmL_HL1(iRegL dst, uimmL_HL1 src, flagsReg cr) %{
 7769   match(Set dst (AndL dst src));
 7770   effect(KILL cr);
 7771   ins_cost(DEFAULT_COST);
 7772   size(4);
 7773   format %{ &quot;NIHL    $dst,$src\t # long&quot; %}
 7774   ins_encode %{ __ z_nihl($dst$$Register, ($src$$constant &gt;&gt; 32) &amp; 0xFFFF); %}
 7775   ins_pipe(pipe_class_dummy);
 7776 %}
 7777 
 7778 instruct andL_reg_uimmL_HH1(iRegL dst, uimmL_HH1 src, flagsReg cr) %{
 7779   match(Set dst (AndL dst src));
 7780   effect(KILL cr);
 7781   ins_cost(DEFAULT_COST);
 7782   size(4);
 7783   format %{ &quot;NIHH    $dst,$src\t # long&quot; %}
 7784   ins_encode %{ __ z_nihh($dst$$Register, ($src$$constant &gt;&gt; 48) &amp; 0xFFFF); %}
 7785   ins_pipe(pipe_class_dummy);
 7786 %}
 7787 
 7788 //  OR
 7789 
 7790 // Or Instructions
 7791 // Register Or
 7792 instruct orI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7793   match(Set dst (OrI dst src));
 7794   effect(KILL cr);
 7795   size(2);
 7796   format %{ &quot;OR      $dst,$src&quot; %}
 7797   opcode(OR_ZOPC);
 7798   ins_encode(z_rrform(dst, src));
 7799   ins_pipe(pipe_class_dummy);
 7800 %}
 7801 
 7802 instruct orI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7803   match(Set dst (OrI dst (LoadI src)));
 7804   effect(KILL cr);
 7805   ins_cost(MEMORY_REF_COST);
 7806   // TODO: s390 port size(VARIABLE_SIZE);
 7807   format %{ &quot;O(Y)    $dst, $src\t # int&quot; %}
 7808   opcode(OY_ZOPC, O_ZOPC);
 7809   ins_encode(z_form_rt_mem_opt(dst, src));
 7810   ins_pipe(pipe_class_dummy);
 7811 %}
 7812 
 7813 // Immediate Or
 7814 instruct orI_reg_uimm16(iRegI dst, uimmI16 con, flagsReg cr) %{
 7815   match(Set dst (OrI dst con));
 7816   effect(KILL cr);
 7817   size(4);
 7818   format %{ &quot;OILL    $dst,$con&quot; %}
 7819   opcode(OILL_ZOPC);
 7820   ins_encode(z_riform_unsigned(dst,con));
 7821   ins_pipe(pipe_class_dummy);
 7822 %}
 7823 
 7824 instruct orI_reg_uimm32(iRegI dst, uimmI con, flagsReg cr) %{
 7825   match(Set dst (OrI dst con));
 7826   effect(KILL cr);
 7827   ins_cost(DEFAULT_COST_HIGH);
 7828   size(6);
 7829   format %{ &quot;OILF    $dst,$con&quot; %}
 7830   opcode(OILF_ZOPC);
 7831   ins_encode(z_rilform_unsigned(dst,con));
 7832   ins_pipe(pipe_class_dummy);
 7833 %}
 7834 
 7835 // Register Or Long
 7836 instruct orL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7837   match(Set dst (OrL dst src));
 7838   effect(KILL cr);
 7839   ins_cost(DEFAULT_COST);
 7840   size(4);
 7841   format %{ &quot;OGR      $dst,$src\t # long&quot; %}
 7842   opcode(OGR_ZOPC);
 7843   ins_encode(z_rreform(dst, src));
 7844   ins_pipe(pipe_class_dummy);
 7845 %}
 7846 
 7847 instruct orL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7848   match(Set dst (OrL dst (LoadL src)));
 7849   effect(KILL cr);
 7850   ins_cost(MEMORY_REF_COST);
 7851   size(Z_DISP3_SIZE);
 7852   format %{ &quot;OG      $dst, $src\t # long&quot; %}
 7853   opcode(OG_ZOPC, OG_ZOPC);
 7854   ins_encode(z_form_rt_mem_opt(dst, src));
 7855   ins_pipe(pipe_class_dummy);
 7856 %}
 7857 
 7858 // Immediate Or long
 7859 instruct orL_reg_uimm16(iRegL dst, uimmL16 con, flagsReg cr) %{
 7860   match(Set dst (OrL dst con));
 7861   effect(KILL cr);
 7862   ins_cost(DEFAULT_COST);
 7863   size(4);
 7864   format %{ &quot;OILL    $dst,$con\t # long&quot; %}
 7865   opcode(OILL_ZOPC);
 7866   ins_encode(z_riform_unsigned(dst,con));
 7867   ins_pipe(pipe_class_dummy);
 7868 %}
 7869 
 7870 instruct orL_reg_uimm32(iRegI dst, uimmL32 con, flagsReg cr) %{
 7871   match(Set dst (OrI dst con));
 7872   effect(KILL cr);
 7873   ins_cost(DEFAULT_COST_HIGH);
 7874   // TODO: s390 port size(FIXED_SIZE);
 7875   format %{ &quot;OILF    $dst,$con\t # long&quot; %}
 7876   opcode(OILF_ZOPC);
 7877   ins_encode(z_rilform_unsigned(dst,con));
 7878   ins_pipe(pipe_class_dummy);
 7879 %}
 7880 
 7881 // XOR
 7882 
 7883 // Register Xor
 7884 instruct xorI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7885   match(Set dst (XorI dst src));
 7886   effect(KILL cr);
 7887   size(2);
 7888   format %{ &quot;XR      $dst,$src&quot; %}
 7889   opcode(XR_ZOPC);
 7890   ins_encode(z_rrform(dst, src));
 7891   ins_pipe(pipe_class_dummy);
 7892 %}
 7893 
 7894 instruct xorI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7895   match(Set dst (XorI dst (LoadI src)));
 7896   effect(KILL cr);
 7897   ins_cost(MEMORY_REF_COST);
 7898   // TODO: s390 port size(VARIABLE_SIZE);
 7899   format %{ &quot;X(Y)    $dst, $src\t # int&quot; %}
 7900   opcode(XY_ZOPC, X_ZOPC);
 7901   ins_encode(z_form_rt_mem_opt(dst, src));
 7902   ins_pipe(pipe_class_dummy);
 7903 %}
 7904 
 7905 // Immediate Xor
 7906 instruct xorI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7907   match(Set dst (XorI dst src));
 7908   effect(KILL cr);
 7909   ins_cost(DEFAULT_COST_HIGH);
 7910   size(6);
 7911   format %{ &quot;XILF    $dst,$src&quot; %}
 7912   opcode(XILF_ZOPC);
 7913   ins_encode(z_rilform_unsigned(dst, src));
 7914   ins_pipe(pipe_class_dummy);
 7915 %}
 7916 
 7917 // Register Xor Long
 7918 instruct xorL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7919   match(Set dst (XorL dst src));
 7920   effect(KILL cr);
 7921   ins_cost(DEFAULT_COST);
 7922   size(4);
 7923   format %{ &quot;XGR     $dst,$src\t # long&quot; %}
 7924   opcode(XGR_ZOPC);
 7925   ins_encode(z_rreform(dst, src));
 7926   ins_pipe(pipe_class_dummy);
 7927 %}
 7928 
 7929 instruct xorL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7930   match(Set dst (XorL dst (LoadL src)));
 7931   effect(KILL cr);
 7932   ins_cost(MEMORY_REF_COST);
 7933   size(Z_DISP3_SIZE);
 7934   format %{ &quot;XG      $dst, $src\t # long&quot; %}
 7935   opcode(XG_ZOPC, XG_ZOPC);
 7936   ins_encode(z_form_rt_mem_opt(dst, src));
 7937   ins_pipe(pipe_class_dummy);
 7938 %}
 7939 
 7940 // Immediate Xor Long
 7941 instruct xorL_reg_uimm32(iRegL dst, uimmL32 con, flagsReg cr) %{
 7942   match(Set dst (XorL dst con));
 7943   effect(KILL cr);
 7944   ins_cost(DEFAULT_COST_HIGH);
 7945   size(6);
 7946   format %{ &quot;XILF    $dst,$con\t # long&quot; %}
 7947   opcode(XILF_ZOPC);
 7948   ins_encode(z_rilform_unsigned(dst,con));
 7949   ins_pipe(pipe_class_dummy);
 7950 %}
 7951 
 7952 //----------Convert to Boolean-------------------------------------------------
 7953 
 7954 // Convert integer to boolean.
 7955 instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{
 7956   match(Set dst (Conv2B src));
 7957   effect(KILL cr);
 7958   ins_cost(3 * DEFAULT_COST);
 7959   size(6);
 7960   format %{ &quot;convI2B $dst,$src&quot; %}
 7961   ins_encode %{
 7962     __ z_lnr($dst$$Register, $src$$Register);  // Rdst := -|Rsrc|, i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7963     __ z_srl($dst$$Register, 31);              // Rdst := sign(Rdest)
 7964   %}
 7965   ins_pipe(pipe_class_dummy);
 7966 %}
 7967 
 7968 instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{
 7969   match(Set dst (Conv2B src));
 7970   effect(KILL cr);
 7971   ins_cost(3 * DEFAULT_COST);
 7972   size(10);
 7973   format %{ &quot;convP2B $dst,$src&quot; %}
 7974   ins_encode %{
 7975     __ z_lngr($dst$$Register, $src$$Register);     // Rdst := -|Rsrc| i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7976     __ z_srlg($dst$$Register, $dst$$Register, 63); // Rdst := sign(Rdest)
 7977   %}
 7978   ins_pipe(pipe_class_dummy);
 7979 %}
 7980 
 7981 instruct cmpLTMask_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7982   match(Set dst (CmpLTMask dst src));
 7983   effect(KILL cr);
 7984   ins_cost(2 * DEFAULT_COST);
 7985   size(18);
 7986   format %{ &quot;Set $dst CmpLTMask $dst,$src&quot; %}
 7987   ins_encode %{
 7988     // Avoid signed 32 bit overflow: Do sign extend and sub 64 bit.
 7989     __ z_lgfr(Z_R0_scratch, $src$$Register);
 7990     __ z_lgfr($dst$$Register, $dst$$Register);
 7991     __ z_sgr($dst$$Register, Z_R0_scratch);
 7992     __ z_srag($dst$$Register, $dst$$Register, 63);
 7993   %}
 7994   ins_pipe(pipe_class_dummy);
 7995 %}
 7996 
 7997 instruct cmpLTMask_reg_zero(iRegI dst, immI_0 zero, flagsReg cr) %{
 7998   match(Set dst (CmpLTMask dst zero));
 7999   effect(KILL cr);
 8000   ins_cost(DEFAULT_COST);
 8001   size(4);
 8002   format %{ &quot;Set $dst CmpLTMask $dst,$zero&quot; %}
 8003   ins_encode %{ __ z_sra($dst$$Register, 31); %}
 8004   ins_pipe(pipe_class_dummy);
 8005 %}
 8006 
 8007 
 8008 //----------Arithmetic Conversion Instructions---------------------------------
 8009 // The conversions operations are all Alpha sorted. Please keep it that way!
 8010 
 8011 instruct convD2F_reg(regF dst, regD src) %{
 8012   match(Set dst (ConvD2F src));
 8013   // CC remains unchanged.
 8014   size(4);
 8015   format %{ &quot;LEDBR   $dst,$src&quot; %}
 8016   opcode(LEDBR_ZOPC);
 8017   ins_encode(z_rreform(dst, src));
 8018   ins_pipe(pipe_class_dummy);
 8019 %}
 8020 
 8021 instruct convF2I_reg(iRegI dst, regF src, flagsReg cr) %{
 8022   match(Set dst (ConvF2I src));
 8023   effect(KILL cr);
 8024   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8025   size(16);
 8026   format %{ &quot;convF2I  $dst,$src&quot; %}
 8027   ins_encode %{
 8028     Label done;
 8029     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8030     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8031     __ z_brno(done);                             // Result is zero if unordered argument.
 8032     __ z_cfebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8033     __ bind(done);
 8034   %}
 8035   ins_pipe(pipe_class_dummy);
 8036 %}
 8037 
 8038 instruct convD2I_reg(iRegI dst, regD src, flagsReg cr) %{
 8039   match(Set dst (ConvD2I src));
 8040   effect(KILL cr);
 8041   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8042   size(16);
 8043   format %{ &quot;convD2I  $dst,$src&quot; %}
 8044   ins_encode %{
 8045     Label done;
 8046     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8047     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8048     __ z_brno(done);                             // Result is zero if unordered argument.
 8049     __ z_cfdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8050     __ bind(done);
 8051   %}
 8052   ins_pipe(pipe_class_dummy);
 8053 %}
 8054 
 8055 instruct convF2L_reg(iRegL dst, regF src, flagsReg cr) %{
 8056   match(Set dst (ConvF2L src));
 8057   effect(KILL cr);
 8058   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8059   size(16);
 8060   format %{ &quot;convF2L  $dst,$src&quot; %}
 8061   ins_encode %{
 8062     Label done;
 8063     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8064     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8065     __ z_brno(done);                             // Result is zero if unordered argument.
 8066     __ z_cgebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8067     __ bind(done);
 8068   %}
 8069   ins_pipe(pipe_class_dummy);
 8070 %}
 8071 
 8072 instruct convD2L_reg(iRegL dst, regD src, flagsReg cr) %{
 8073   match(Set dst (ConvD2L src));
 8074   effect(KILL cr);
 8075   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8076   size(16);
 8077   format %{ &quot;convD2L  $dst,$src&quot; %}
 8078   ins_encode %{
 8079     Label done;
 8080     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8081     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8082     __ z_brno(done);                             // Result is zero if unordered argument.
 8083     __ z_cgdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8084     __ bind(done);
 8085   %}
 8086   ins_pipe(pipe_class_dummy);
 8087 %}
 8088 
 8089 instruct convF2D_reg(regD dst, regF src) %{
 8090   match(Set dst (ConvF2D src));
 8091   // CC remains unchanged.
 8092   size(4);
 8093   format %{ &quot;LDEBR   $dst,$src&quot; %}
 8094   opcode(LDEBR_ZOPC);
 8095   ins_encode(z_rreform(dst, src));
 8096   ins_pipe(pipe_class_dummy);
 8097 %}
 8098 
 8099 instruct convF2D_mem(regD dst, memoryRX src) %{
 8100   match(Set dst (ConvF2D src));
 8101   // CC remains unchanged.
 8102   size(6);
 8103   format %{ &quot;LDEB    $dst,$src&quot; %}
 8104   opcode(LDEB_ZOPC);
 8105   ins_encode(z_form_rt_memFP(dst, src));
 8106   ins_pipe(pipe_class_dummy);
 8107 %}
 8108 
 8109 instruct convI2D_reg(regD dst, iRegI src) %{
 8110   match(Set dst (ConvI2D src));
 8111   // CC remains unchanged.
 8112   ins_cost(DEFAULT_COST);
 8113   size(4);
 8114   format %{ &quot;CDFBR   $dst,$src&quot; %}
 8115   opcode(CDFBR_ZOPC);
 8116   ins_encode(z_rreform(dst, src));
 8117   ins_pipe(pipe_class_dummy);
 8118 %}
 8119 
 8120 // Optimization that saves up to two memory operations for each conversion.
 8121 instruct convI2F_ireg(regF dst, iRegI src) %{
 8122   match(Set dst (ConvI2F src));
 8123   // CC remains unchanged.
 8124   ins_cost(DEFAULT_COST);
 8125   size(4);
 8126   format %{ &quot;CEFBR   $dst,$src\t # convert int to float&quot; %}
 8127   opcode(CEFBR_ZOPC);
 8128   ins_encode(z_rreform(dst, src));
 8129   ins_pipe(pipe_class_dummy);
 8130 %}
 8131 
 8132 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8133   match(Set dst (ConvI2L src));
 8134   size(4);
 8135   format %{ &quot;LGFR    $dst,$src\t # int-&gt;long&quot; %}
 8136   opcode(LGFR_ZOPC);
 8137   ins_encode(z_rreform(dst, src));
 8138   ins_pipe(pipe_class_dummy);
 8139 %}
 8140 
 8141 // Zero-extend convert int to long.
 8142 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask) %{
 8143   match(Set dst (AndL (ConvI2L src) mask));
 8144   size(4);
 8145   format %{ &quot;LLGFR   $dst, $src \t # zero-extend int to long&quot; %}
 8146   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8147   ins_pipe(pipe_class_dummy);
 8148 %}
 8149 
 8150 // Zero-extend convert int to long.
 8151 instruct convI2L_mem_zex(iRegL dst, memory src, immL_32bits mask) %{
 8152   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
 8153   // Uses load_const_optmized, so size can vary.
 8154   // TODO: s390 port size(VARIABLE_SIZE);
 8155   format %{ &quot;LLGF    $dst, $src \t # zero-extend int to long&quot; %}
 8156   opcode(LLGF_ZOPC, LLGF_ZOPC);
 8157   ins_encode(z_form_rt_mem_opt(dst, src));
 8158   ins_pipe(pipe_class_dummy);
 8159 %}
 8160 
 8161 // Zero-extend long
 8162 instruct zeroExtend_long(iRegL dst, iRegL src, immL_32bits mask) %{
 8163   match(Set dst (AndL src mask));
 8164   size(4);
 8165   format %{ &quot;LLGFR   $dst, $src \t # zero-extend long to long&quot; %}
 8166   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8167   ins_pipe(pipe_class_dummy);
 8168 %}
 8169 
 8170 instruct rShiftI16_lShiftI16_reg(iRegI dst, iRegI src, immI_16 amount) %{
 8171   match(Set dst (RShiftI (LShiftI src amount) amount));
 8172   size(4);
 8173   format %{ &quot;LHR     $dst,$src\t short-&gt;int&quot; %}
 8174   opcode(LHR_ZOPC);
 8175   ins_encode(z_rreform(dst, src));
 8176   ins_pipe(pipe_class_dummy);
 8177 %}
 8178 
 8179 instruct rShiftI24_lShiftI24_reg(iRegI dst, iRegI src, immI_24 amount) %{
 8180   match(Set dst (RShiftI (LShiftI src amount) amount));
 8181   size(4);
 8182   format %{ &quot;LBR     $dst,$src\t byte-&gt;int&quot; %}
 8183   opcode(LBR_ZOPC);
 8184   ins_encode(z_rreform(dst, src));
 8185   ins_pipe(pipe_class_dummy);
 8186 %}
 8187 
 8188 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8189   match(Set dst (MoveF2I src));
 8190   ins_cost(MEMORY_REF_COST);
 8191   size(4);
 8192   format %{ &quot;L       $dst,$src\t # MoveF2I&quot; %}
 8193   opcode(L_ZOPC);
 8194   ins_encode(z_form_rt_mem(dst, src));
 8195   ins_pipe(pipe_class_dummy);
 8196 %}
 8197 
 8198 // javax.imageio.stream.ImageInputStreamImpl.toFloats([B[FII)
 8199 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8200   match(Set dst (MoveI2F src));
 8201   ins_cost(MEMORY_REF_COST);
 8202   // TODO: s390 port size(FIXED_SIZE);
 8203   format %{ &quot;LE      $dst,$src\t # MoveI2F&quot; %}
 8204   opcode(LE_ZOPC);
 8205   ins_encode(z_form_rt_mem(dst, src));
 8206   ins_pipe(pipe_class_dummy);
 8207 %}
 8208 
 8209 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8210   match(Set dst (MoveD2L src));
 8211   ins_cost(MEMORY_REF_COST);
 8212   size(6);
 8213   format %{ &quot;LG      $src,$dst\t # MoveD2L&quot; %}
 8214   opcode(LG_ZOPC);
 8215   ins_encode(z_form_rt_mem(dst, src));
 8216   ins_pipe(pipe_class_dummy);
 8217 %}
 8218 
 8219 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8220   match(Set dst (MoveL2D src));
 8221   ins_cost(MEMORY_REF_COST);
 8222   size(4);
 8223   format %{ &quot;LD      $dst,$src\t # MoveL2D&quot; %}
 8224   opcode(LD_ZOPC);
 8225   ins_encode(z_form_rt_mem(dst, src));
 8226   ins_pipe(pipe_class_dummy);
 8227 %}
 8228 
 8229 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8230   match(Set dst (MoveI2F src));
 8231   ins_cost(MEMORY_REF_COST);
 8232   size(4);
 8233   format %{ &quot;ST      $src,$dst\t # MoveI2F&quot; %}
 8234   opcode(ST_ZOPC);
 8235   ins_encode(z_form_rt_mem(src, dst));
 8236   ins_pipe(pipe_class_dummy);
 8237 %}
 8238 
 8239 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8240   match(Set dst (MoveD2L src));
 8241   effect(DEF dst, USE src);
 8242   ins_cost(MEMORY_REF_COST);
 8243   size(4);
 8244   format %{ &quot;STD     $src,$dst\t # MoveD2L&quot; %}
 8245   opcode(STD_ZOPC);
 8246   ins_encode(z_form_rt_mem(src,dst));
 8247   ins_pipe(pipe_class_dummy);
 8248 %}
 8249 
 8250 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8251   match(Set dst (MoveL2D src));
 8252   ins_cost(MEMORY_REF_COST);
 8253   size(6);
 8254   format %{ &quot;STG     $src,$dst\t # MoveL2D&quot; %}
 8255   opcode(STG_ZOPC);
 8256   ins_encode(z_form_rt_mem(src,dst));
 8257   ins_pipe(pipe_class_dummy);
 8258 %}
 8259 
 8260 instruct convL2F_reg(regF dst, iRegL src) %{
 8261   match(Set dst (ConvL2F src));
 8262   // CC remains unchanged.
 8263   ins_cost(DEFAULT_COST);
 8264   size(4);
 8265   format %{ &quot;CEGBR   $dst,$src&quot; %}
 8266   opcode(CEGBR_ZOPC);
 8267   ins_encode(z_rreform(dst, src));
 8268   ins_pipe(pipe_class_dummy);
 8269 %}
 8270 
 8271 instruct convL2D_reg(regD dst, iRegL src) %{
 8272   match(Set dst (ConvL2D src));
 8273   // CC remains unchanged.
 8274   ins_cost(DEFAULT_COST);
 8275   size(4);
 8276   format %{ &quot;CDGBR   $dst,$src&quot; %}
 8277   opcode(CDGBR_ZOPC);
 8278   ins_encode(z_rreform(dst, src));
 8279   ins_pipe(pipe_class_dummy);
 8280 %}
 8281 
 8282 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8283   match(Set dst (ConvL2I src));
 8284   // TODO: s390 port size(VARIABLE_SIZE);
 8285   format %{ &quot;LR      $dst,$src\t # long-&gt;int (if needed)&quot; %}
 8286   ins_encode %{ __ lr_if_needed($dst$$Register, $src$$Register); %}
 8287   ins_pipe(pipe_class_dummy);
 8288 %}
 8289 
 8290 // Register Shift Right Immediate
 8291 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt, flagsReg cr) %{
 8292   match(Set dst (ConvL2I (RShiftL src cnt)));
 8293   effect(KILL cr);
 8294   size(6);
 8295   format %{ &quot;SRAG    $dst,$src,$cnt&quot; %}
 8296   opcode(SRAG_ZOPC);
 8297   ins_encode(z_rsyform_const(dst, src, cnt));
 8298   ins_pipe(pipe_class_dummy);
 8299 %}
 8300 
 8301 //----------TRAP based zero checks and range checks----------------------------
 8302 
 8303 // SIGTRAP based implicit range checks in compiled code.
 8304 // A range check in the ideal world has one of the following shapes:
 8305 //   - (If le (CmpU length index)), (IfTrue  throw exception)
 8306 //   - (If lt (CmpU index length)), (IfFalse throw exception)
 8307 //
 8308 // Match range check &#39;If le (CmpU length index)&#39;
 8309 instruct rangeCheck_iReg_uimmI16(cmpOpT cmp, iRegI length, uimmI16 index, label labl) %{
 8310   match(If cmp (CmpU length index));
 8311   effect(USE labl);
 8312   predicate(TrapBasedRangeChecks &amp;&amp;
 8313             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
 8314             PROB_UNLIKELY(_leaf-&gt;as_If ()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
 8315             Matcher::branches_to_uncommon_trap(_leaf));
 8316   ins_cost(1);
 8317   // TODO: s390 port size(FIXED_SIZE);
 8318 
 8319   ins_is_TrapBasedCheckNode(true);
 8320 
 8321   format %{ &quot;RangeCheck len=$length cmp=$cmp idx=$index =&gt; trap $labl&quot; %}
 8322   ins_encode %{ __ z_clfit($length$$Register, $index$$constant, $cmp$$cmpcode); %}
 8323   ins_pipe(pipe_class_trap);
 8324 %}
 8325 
 8326 // Match range check &#39;If lt (CmpU index length)&#39;
 8327 instruct rangeCheck_iReg_iReg(cmpOpT cmp, iRegI index, iRegI length, label labl, flagsReg cr) %{
 8328   match(If cmp (CmpU index length));
 8329   effect(USE labl, KILL cr);
 8330   predicate(TrapBasedRangeChecks &amp;&amp;
 8331             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8332             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8333             Matcher::branches_to_uncommon_trap(_leaf));
 8334   ins_cost(1);
 8335   // TODO: s390 port size(FIXED_SIZE);
 8336 
 8337   ins_is_TrapBasedCheckNode(true);
 8338 
 8339   format %{ &quot;RangeCheck idx=$index cmp=$cmp len=$length =&gt; trap $labl&quot; %}
 8340   ins_encode %{ __ z_clrt($index$$Register, $length$$Register, $cmp$$cmpcode); %}
 8341   ins_pipe(pipe_class_trap);
 8342 %}
 8343 
 8344 // Match range check &#39;If lt (CmpU index length)&#39;
 8345 instruct rangeCheck_uimmI16_iReg(cmpOpT cmp, iRegI index, uimmI16 length, label labl) %{
 8346   match(If cmp (CmpU index length));
 8347   effect(USE labl);
 8348   predicate(TrapBasedRangeChecks &amp;&amp;
 8349             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8350             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8351             Matcher::branches_to_uncommon_trap(_leaf));
 8352   ins_cost(1);
 8353   // TODO: s390 port size(FIXED_SIZE);
 8354 
 8355   ins_is_TrapBasedCheckNode(true);
 8356 
 8357   format %{ &quot;RangeCheck idx=$index cmp=$cmp len= $length =&gt; trap $labl&quot; %}
 8358   ins_encode %{ __ z_clfit($index$$Register, $length$$constant, $cmp$$cmpcode); %}
 8359   ins_pipe(pipe_class_trap);
 8360 %}
 8361 
 8362 // Implicit zero checks (more implicit null checks).
 8363 instruct zeroCheckP_iReg_imm0(cmpOpT cmp, iRegP_N2P value, immP0 zero, label labl) %{
 8364   match(If cmp (CmpP value zero));
 8365   effect(USE labl);
 8366   predicate(TrapBasedNullChecks &amp;&amp;
 8367             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8368             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8369             Matcher::branches_to_uncommon_trap(_leaf));
 8370   size(6);
 8371 
 8372   ins_is_TrapBasedCheckNode(true);
 8373 
 8374   format %{ &quot;ZeroCheckP value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8375   ins_encode %{ __ z_cgit($value$$Register, 0, $cmp$$cmpcode); %}
 8376   ins_pipe(pipe_class_trap);
 8377 %}
 8378 
 8379 // Implicit zero checks (more implicit null checks).
 8380 instruct zeroCheckN_iReg_imm0(cmpOpT cmp, iRegN_P2N value, immN0 zero, label labl) %{
 8381   match(If cmp (CmpN value zero));
 8382   effect(USE labl);
 8383   predicate(TrapBasedNullChecks &amp;&amp;
 8384             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8385             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8386             Matcher::branches_to_uncommon_trap(_leaf));
 8387   size(6);
 8388 
 8389   ins_is_TrapBasedCheckNode(true);
 8390 
 8391   format %{ &quot;ZeroCheckN value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8392   ins_encode %{ __ z_cit($value$$Register, 0, $cmp$$cmpcode); %}
 8393   ins_pipe(pipe_class_trap);
 8394 %}
 8395 
 8396 //----------Compare instructions-----------------------------------------------
 8397 
 8398 // INT signed
 8399 
 8400 // Compare Integers
 8401 instruct compI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8402   match(Set cr (CmpI op1 op2));
 8403   size(2);
 8404   format %{ &quot;CR      $op1,$op2&quot; %}
 8405   opcode(CR_ZOPC);
 8406   ins_encode(z_rrform(op1, op2));
 8407   ins_pipe(pipe_class_dummy);
 8408 %}
 8409 
 8410 instruct compI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 8411   match(Set cr (CmpI op1 op2));
 8412   size(6);
 8413   format %{ &quot;CFI     $op1,$op2&quot; %}
 8414   opcode(CFI_ZOPC);
 8415   ins_encode(z_rilform_signed(op1, op2));
 8416   ins_pipe(pipe_class_dummy);
 8417 %}
 8418 
 8419 instruct compI_reg_imm16(flagsReg cr, iRegI op1, immI16 op2) %{
 8420   match(Set cr (CmpI op1 op2));
 8421   size(4);
 8422   format %{ &quot;CHI     $op1,$op2&quot; %}
 8423   opcode(CHI_ZOPC);
 8424   ins_encode(z_riform_signed(op1, op2));
 8425   ins_pipe(pipe_class_dummy);
 8426 %}
 8427 
 8428 instruct compI_reg_imm0(flagsReg cr, iRegI op1, immI_0 zero) %{
 8429   match(Set cr (CmpI op1 zero));
 8430   ins_cost(DEFAULT_COST_LOW);
 8431   size(2);
 8432   format %{ &quot;LTR     $op1,$op1&quot; %}
 8433   opcode(LTR_ZOPC);
 8434   ins_encode(z_rrform(op1, op1));
 8435   ins_pipe(pipe_class_dummy);
 8436 %}
 8437 
 8438 instruct compI_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8439   match(Set cr (CmpI op1 (LoadI op2)));
 8440   ins_cost(MEMORY_REF_COST);
 8441   // TODO: s390 port size(VARIABLE_SIZE);
 8442   format %{ &quot;C(Y)    $op1, $op2\t # int&quot; %}
 8443   opcode(CY_ZOPC, C_ZOPC);
 8444   ins_encode(z_form_rt_mem_opt(op1, op2));
 8445   ins_pipe(pipe_class_dummy);
 8446 %}
 8447 
 8448 // INT unsigned
 8449 
 8450 instruct compU_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8451   match(Set cr (CmpU op1 op2));
 8452   size(2);
 8453   format %{ &quot;CLR     $op1,$op2\t # unsigned&quot; %}
 8454   opcode(CLR_ZOPC);
 8455   ins_encode(z_rrform(op1, op2));
 8456   ins_pipe(pipe_class_dummy);
 8457 %}
 8458 
 8459 instruct compU_reg_uimm(flagsReg cr, iRegI op1, uimmI op2) %{
 8460   match(Set cr (CmpU op1 op2));
 8461   size(6);
 8462   format %{ &quot;CLFI    $op1,$op2\t # unsigned&quot; %}
 8463   opcode(CLFI_ZOPC);
 8464   ins_encode(z_rilform_unsigned(op1, op2));
 8465   ins_pipe(pipe_class_dummy);
 8466 %}
 8467 
 8468 instruct compU_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8469   match(Set cr (CmpU op1 (LoadI op2)));
 8470   ins_cost(MEMORY_REF_COST);
 8471   // TODO: s390 port size(VARIABLE_SIZE);
 8472   format %{ &quot;CL(Y)   $op1, $op2\t # unsigned&quot; %}
 8473   opcode(CLY_ZOPC, CL_ZOPC);
 8474   ins_encode(z_form_rt_mem_opt(op1, op2));
 8475   ins_pipe(pipe_class_dummy);
 8476 %}
 8477 
 8478 // LONG signed
 8479 
 8480 instruct compL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8481   match(Set cr (CmpL op1 op2));
 8482   size(4);
 8483   format %{ &quot;CGR     $op1,$op2\t # long&quot; %}
 8484   opcode(CGR_ZOPC);
 8485   ins_encode(z_rreform(op1, op2));
 8486   ins_pipe(pipe_class_dummy);
 8487 %}
 8488 
 8489 instruct compL_reg_regI(flagsReg cr, iRegL op1, iRegI op2) %{
 8490   match(Set cr (CmpL op1 (ConvI2L op2)));
 8491   size(4);
 8492   format %{ &quot;CGFR    $op1,$op2\t # long/int&quot; %}
 8493   opcode(CGFR_ZOPC);
 8494   ins_encode(z_rreform(op1, op2));
 8495   ins_pipe(pipe_class_dummy);
 8496 %}
 8497 
 8498 instruct compL_reg_imm32(flagsReg cr, iRegL op1, immL32 con) %{
 8499   match(Set cr (CmpL op1 con));
 8500   size(6);
 8501   format %{ &quot;CGFI    $op1,$con&quot; %}
 8502   opcode(CGFI_ZOPC);
 8503   ins_encode(z_rilform_signed(op1, con));
 8504   ins_pipe(pipe_class_dummy);
 8505 %}
 8506 
 8507 instruct compL_reg_imm16(flagsReg cr, iRegL op1, immL16 con) %{
 8508   match(Set cr (CmpL op1 con));
 8509   size(4);
 8510   format %{ &quot;CGHI    $op1,$con&quot; %}
 8511   opcode(CGHI_ZOPC);
 8512   ins_encode(z_riform_signed(op1, con));
 8513   ins_pipe(pipe_class_dummy);
 8514 %}
 8515 
 8516 instruct compL_reg_imm0(flagsReg cr, iRegL op1, immL_0 con) %{
 8517   match(Set cr (CmpL op1 con));
 8518   ins_cost(DEFAULT_COST_LOW);
 8519   size(4);
 8520   format %{ &quot;LTGR    $op1,$op1&quot; %}
 8521   opcode(LTGR_ZOPC);
 8522   ins_encode(z_rreform(op1, op1));
 8523   ins_pipe(pipe_class_dummy);
 8524 %}
 8525 
 8526 instruct compL_conv_reg_imm0(flagsReg cr, iRegI op1, immL_0 con) %{
 8527   match(Set cr (CmpL (ConvI2L op1) con));
 8528   ins_cost(DEFAULT_COST_LOW);
 8529   size(4);
 8530   format %{ &quot;LTGFR    $op1,$op1&quot; %}
 8531   opcode(LTGFR_ZOPC);
 8532   ins_encode(z_rreform(op1, op1));
 8533   ins_pipe(pipe_class_dummy);
 8534 %}
 8535 
 8536 instruct compL_reg_mem(iRegL dst, memory src, flagsReg cr)%{
 8537   match(Set cr (CmpL dst (LoadL src)));
 8538   ins_cost(MEMORY_REF_COST);
 8539   size(Z_DISP3_SIZE);
 8540   format %{ &quot;CG      $dst, $src\t # long&quot; %}
 8541   opcode(CG_ZOPC, CG_ZOPC);
 8542   ins_encode(z_form_rt_mem_opt(dst, src));
 8543   ins_pipe(pipe_class_dummy);
 8544 %}
 8545 
 8546 instruct compL_reg_memI(iRegL dst, memory src, flagsReg cr)%{
 8547   match(Set cr (CmpL dst (ConvI2L (LoadI src))));
 8548   ins_cost(MEMORY_REF_COST);
 8549   size(Z_DISP3_SIZE);
 8550   format %{ &quot;CGF     $dst, $src\t # long/int&quot; %}
 8551   opcode(CGF_ZOPC, CGF_ZOPC);
 8552   ins_encode(z_form_rt_mem_opt(dst, src));
 8553   ins_pipe(pipe_class_dummy);
 8554 %}
 8555 
 8556 //  LONG unsigned
 8557 // Added CmpUL for LoopPredicate.
 8558 instruct compUL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8559   match(Set cr (CmpUL op1 op2));
 8560   size(4);
 8561   format %{ &quot;CLGR    $op1,$op2\t # long&quot; %}
 8562   opcode(CLGR_ZOPC);
 8563   ins_encode(z_rreform(op1, op2));
 8564   ins_pipe(pipe_class_dummy);
 8565 %}
 8566 
 8567 instruct compUL_reg_imm32(flagsReg cr, iRegL op1, uimmL32 con) %{
 8568   match(Set cr (CmpUL op1 con));
 8569   size(6);
 8570   format %{ &quot;CLGFI   $op1,$con&quot; %}
 8571   opcode(CLGFI_ZOPC);
 8572   ins_encode(z_rilform_unsigned(op1, con));
 8573   ins_pipe(pipe_class_dummy);
 8574 %}
 8575 
 8576 //  PTR unsigned
 8577 
 8578 instruct compP_reg_reg(flagsReg cr, iRegP_N2P op1, iRegP_N2P op2) %{
 8579   match(Set cr (CmpP op1 op2));
 8580   size(4);
 8581   format %{ &quot;CLGR    $op1,$op2\t # ptr&quot; %}
 8582   opcode(CLGR_ZOPC);
 8583   ins_encode(z_rreform(op1, op2));
 8584   ins_pipe(pipe_class_dummy);
 8585 %}
 8586 
 8587 instruct compP_reg_imm0(flagsReg cr, iRegP_N2P op1, immP0 op2) %{
 8588   match(Set cr (CmpP op1 op2));
 8589   ins_cost(DEFAULT_COST_LOW);
 8590   size(4);
 8591   format %{ &quot;LTGR    $op1, $op1\t # ptr&quot; %}
 8592   opcode(LTGR_ZOPC);
 8593   ins_encode(z_rreform(op1, op1));
 8594   ins_pipe(pipe_class_dummy);
 8595 %}
 8596 
 8597 // Don&#39;t use LTGFR which performs sign extend.
 8598 instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
 8599   match(Set cr (CmpP (DecodeN op1) op2));
 8600   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 8601   ins_cost(DEFAULT_COST_LOW);
 8602   size(2);
 8603   format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
 8604   opcode(LTR_ZOPC);
 8605   ins_encode(z_rrform(op1, op1));
 8606   ins_pipe(pipe_class_dummy);
 8607 %}
 8608 
 8609 instruct compP_reg_mem(iRegP dst, memory src, flagsReg cr)%{
 8610   match(Set cr (CmpP dst (LoadP src)));
 8611   ins_cost(MEMORY_REF_COST);
 8612   size(Z_DISP3_SIZE);
 8613   format %{ &quot;CLG     $dst, $src\t # ptr&quot; %}
 8614   opcode(CLG_ZOPC, CLG_ZOPC);
 8615   ins_encode(z_form_rt_mem_opt(dst, src));
 8616   ins_pipe(pipe_class_dummy);
 8617 %}
 8618 
 8619 //----------Max and Min--------------------------------------------------------
 8620 
 8621 // Max Register with Register
 8622 instruct z196_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8623   match(Set dst (MinI src1 src2));
 8624   effect(KILL cr);
 8625   predicate(VM_Version::has_LoadStoreConditional());
 8626   ins_cost(3 * DEFAULT_COST);
 8627   // TODO: s390 port size(VARIABLE_SIZE);
 8628   format %{ &quot;MinI $dst $src1,$src2\t MinI (z196 only)&quot; %}
 8629   ins_encode %{
 8630     Register Rdst = $dst$$Register;
 8631     Register Rsrc1 = $src1$$Register;
 8632     Register Rsrc2 = $src2$$Register;
 8633 
 8634     if (Rsrc1 == Rsrc2) {
 8635       if (Rdst != Rsrc1) {
 8636         __ z_lgfr(Rdst, Rsrc1);
 8637       }
 8638     } else if (Rdst == Rsrc1) {   // Rdst preset with src1.
 8639       __ z_cr(Rsrc1, Rsrc2);      // Move src2 only if src1 is NotLow.
 8640       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8641     } else if (Rdst == Rsrc2) {   // Rdst preset with src2.
 8642       __ z_cr(Rsrc2, Rsrc1);      // Move src1 only if src2 is NotLow.
 8643       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotLow);
 8644     } else {
 8645       // Rdst is disjoint from operands, move in either case.
 8646       __ z_cr(Rsrc1, Rsrc2);
 8647       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8648       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8649     }
 8650   %}
 8651   ins_pipe(pipe_class_dummy);
 8652 %}
 8653 
 8654 // Min Register with Register.
 8655 instruct z10_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8656   match(Set dst (MinI src1 src2));
 8657   effect(KILL cr);
 8658   predicate(VM_Version::has_CompareBranch());
 8659   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8660   // TODO: s390 port size(VARIABLE_SIZE);
 8661   format %{ &quot;MinI $dst $src1,$src2\t MinI (z10 only)&quot; %}
 8662   ins_encode %{
 8663     Register Rdst = $dst$$Register;
 8664     Register Rsrc1 = $src1$$Register;
 8665     Register Rsrc2 = $src2$$Register;
 8666     Label done;
 8667 
 8668     if (Rsrc1 == Rsrc2) {
 8669       if (Rdst != Rsrc1) {
 8670         __ z_lgfr(Rdst, Rsrc1);
 8671       }
 8672     } else if (Rdst == Rsrc1) {
 8673       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8674       __ z_lgfr(Rdst, Rsrc2);
 8675     } else if (Rdst == Rsrc2) {
 8676       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondLow, done);
 8677       __ z_lgfr(Rdst, Rsrc1);
 8678     } else {
 8679       __ z_lgfr(Rdst, Rsrc1);
 8680       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8681       __ z_lgfr(Rdst, Rsrc2);
 8682     }
 8683     __ bind(done);
 8684   %}
 8685   ins_pipe(pipe_class_dummy);
 8686 %}
 8687 
 8688 instruct minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8689   match(Set dst (MinI src1 src2));
 8690   effect(KILL cr);
 8691   predicate(!VM_Version::has_CompareBranch());
 8692   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8693   // TODO: s390 port size(VARIABLE_SIZE);
 8694   format %{ &quot;MinI $dst $src1,$src2\t MinI&quot; %}
 8695   ins_encode %{
 8696     Register Rdst = $dst$$Register;
 8697     Register Rsrc1 = $src1$$Register;
 8698     Register Rsrc2 = $src2$$Register;
 8699     Label done;
 8700 
 8701     if (Rsrc1 == Rsrc2) {
 8702       if (Rdst != Rsrc1) {
 8703         __ z_lgfr(Rdst, Rsrc1);
 8704       }
 8705     } else if (Rdst == Rsrc1) {
 8706       __ z_cr(Rsrc1, Rsrc2);
 8707       __ z_brl(done);
 8708       __ z_lgfr(Rdst, Rsrc2);
 8709     } else if (Rdst == Rsrc2) {
 8710       __ z_cr(Rsrc2, Rsrc1);
 8711       __ z_brl(done);
 8712       __ z_lgfr(Rdst, Rsrc1);
 8713     } else {
 8714       __ z_lgfr(Rdst, Rsrc1);
 8715       __ z_cr(Rsrc1, Rsrc2);
 8716       __ z_brl(done);
 8717       __ z_lgfr(Rdst, Rsrc2);
 8718     }
 8719     __ bind(done);
 8720   %}
 8721   ins_pipe(pipe_class_dummy);
 8722 %}
 8723 
 8724 instruct z196_minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8725   match(Set dst (MinI src1 src2));
 8726   effect(KILL cr);
 8727   predicate(VM_Version::has_LoadStoreConditional());
 8728   ins_cost(3 * DEFAULT_COST);
 8729   // TODO: s390 port size(VARIABLE_SIZE);
 8730   format %{ &quot;MinI $dst $src1,$src2\t MinI const32 (z196 only)&quot; %}
 8731   ins_encode %{
 8732     Register Rdst = $dst$$Register;
 8733     Register Rsrc1 = $src1$$Register;
 8734     int      Isrc2 = $src2$$constant;
 8735 
 8736     if (Rdst == Rsrc1) {
 8737       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8738       __ z_cfi(Rsrc1, Isrc2);
 8739       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8740     } else {
 8741       __ load_const_optimized(Rdst, Isrc2);
 8742       __ z_cfi(Rsrc1, Isrc2);
 8743       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8744     }
 8745   %}
 8746   ins_pipe(pipe_class_dummy);
 8747 %}
 8748 
 8749 instruct minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8750   match(Set dst (MinI src1 src2));
 8751   effect(KILL cr);
 8752   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8753   // TODO: s390 port size(VARIABLE_SIZE);
 8754   format %{ &quot;MinI $dst $src1,$src2\t MinI const32&quot; %}
 8755   ins_encode %{
 8756     Label done;
 8757     if ($dst$$Register != $src1$$Register) {
 8758       __ z_lgfr($dst$$Register, $src1$$Register);
 8759     }
 8760     __ z_cfi($src1$$Register, $src2$$constant);
 8761     __ z_brl(done);
 8762     __ z_lgfi($dst$$Register, $src2$$constant);
 8763     __ bind(done);
 8764   %}
 8765   ins_pipe(pipe_class_dummy);
 8766 %}
 8767 
 8768 instruct z196_minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8769   match(Set dst (MinI src1 src2));
 8770   effect(KILL cr);
 8771   predicate(VM_Version::has_LoadStoreConditional());
 8772   ins_cost(3 * DEFAULT_COST);
 8773   // TODO: s390 port size(VARIABLE_SIZE);
 8774   format %{ &quot;MinI $dst $src1,$src2\t MinI const16 (z196 only)&quot; %}
 8775   ins_encode %{
 8776     Register Rdst = $dst$$Register;
 8777     Register Rsrc1 = $src1$$Register;
 8778     int      Isrc2 = $src2$$constant;
 8779 
 8780     if (Rdst == Rsrc1) {
 8781       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8782       __ z_chi(Rsrc1, Isrc2);
 8783       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8784     } else {
 8785       __ load_const_optimized(Rdst, Isrc2);
 8786       __ z_chi(Rsrc1, Isrc2);
 8787       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8788     }
 8789   %}
 8790   ins_pipe(pipe_class_dummy);
 8791 %}
 8792 
 8793 instruct minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8794   match(Set dst (MinI src1 src2));
 8795   effect(KILL cr);
 8796   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8797   // TODO: s390 port size(VARIABLE_SIZE);
 8798   format %{ &quot;MinI $dst $src1,$src2\t MinI const16&quot; %}
 8799   ins_encode %{
 8800     Label done;
 8801     if ($dst$$Register != $src1$$Register) {
 8802       __ z_lgfr($dst$$Register, $src1$$Register);
 8803     }
 8804     __ z_chi($src1$$Register, $src2$$constant);
 8805     __ z_brl(done);
 8806     __ z_lghi($dst$$Register, $src2$$constant);
 8807     __ bind(done);
 8808   %}
 8809   ins_pipe(pipe_class_dummy);
 8810 %}
 8811 
 8812 instruct z10_minI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 8813   match(Set dst (MinI src1 src2));
 8814   effect(KILL cr);
 8815   predicate(VM_Version::has_CompareBranch());
 8816   ins_cost(DEFAULT_COST + BRANCH_COST);
 8817   // TODO: s390 port size(VARIABLE_SIZE);
 8818   format %{ &quot;MinI $dst $src1,$src2\t MinI const8 (z10 only)&quot; %}
 8819   ins_encode %{
 8820     Label done;
 8821     if ($dst$$Register != $src1$$Register) {
 8822       __ z_lgfr($dst$$Register, $src1$$Register);
 8823     }
 8824     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondLow, done);
 8825     __ z_lghi($dst$$Register, $src2$$constant);
 8826     __ bind(done);
 8827   %}
 8828   ins_pipe(pipe_class_dummy);
 8829 %}
 8830 
 8831 // Max Register with Register
 8832 instruct z196_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8833   match(Set dst (MaxI src1 src2));
 8834   effect(KILL cr);
 8835   predicate(VM_Version::has_LoadStoreConditional());
 8836   ins_cost(3 * DEFAULT_COST);
 8837   // TODO: s390 port size(VARIABLE_SIZE);
 8838   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z196 only)&quot; %}
 8839   ins_encode %{
 8840     Register Rdst = $dst$$Register;
 8841     Register Rsrc1 = $src1$$Register;
 8842     Register Rsrc2 = $src2$$Register;
 8843 
 8844     if (Rsrc1 == Rsrc2) {
 8845       if (Rdst != Rsrc1) {
 8846         __ z_lgfr(Rdst, Rsrc1);
 8847       }
 8848     } else if (Rdst == Rsrc1) { // Rdst preset with src1.
 8849       __ z_cr(Rsrc1, Rsrc2);    // Move src2 only if src1 is NotHigh.
 8850       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8851     } else if (Rdst == Rsrc2) { // Rdst preset with src2.
 8852       __ z_cr(Rsrc2, Rsrc1);    // Move src1 only if src2 is NotHigh.
 8853       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotHigh);
 8854     } else {                    // Rdst is disjoint from operands, move in either case.
 8855       __ z_cr(Rsrc1, Rsrc2);
 8856       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8857       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8858     }
 8859   %}
 8860   ins_pipe(pipe_class_dummy);
 8861 %}
 8862 
 8863 // Max Register with Register
 8864 instruct z10_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8865   match(Set dst (MaxI src1 src2));
 8866   effect(KILL cr);
 8867   predicate(VM_Version::has_CompareBranch());
 8868   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8869   // TODO: s390 port size(VARIABLE_SIZE);
 8870   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z10 only)&quot; %}
 8871   ins_encode %{
 8872     Register Rdst = $dst$$Register;
 8873     Register Rsrc1 = $src1$$Register;
 8874     Register Rsrc2 = $src2$$Register;
 8875     Label done;
 8876 
 8877     if (Rsrc1 == Rsrc2) {
 8878       if (Rdst != Rsrc1) {
 8879         __ z_lgfr(Rdst, Rsrc1);
 8880       }
 8881     } else if (Rdst == Rsrc1) {
 8882       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8883       __ z_lgfr(Rdst, Rsrc2);
 8884     } else if (Rdst == Rsrc2) {
 8885       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondHigh, done);
 8886       __ z_lgfr(Rdst, Rsrc1);
 8887     } else {
 8888       __ z_lgfr(Rdst, Rsrc1);
 8889       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8890       __ z_lgfr(Rdst, Rsrc2);
 8891     }
 8892     __ bind(done);
 8893   %}
 8894   ins_pipe(pipe_class_dummy);
 8895 %}
 8896 
 8897 instruct maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8898   match(Set dst (MaxI src1 src2));
 8899   effect(KILL cr);
 8900   predicate(!VM_Version::has_CompareBranch());
 8901   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8902   // TODO: s390 port size(VARIABLE_SIZE);
 8903   format %{ &quot;MaxI $dst $src1,$src2\t MaxI&quot; %}
 8904   ins_encode %{
 8905     Register Rdst = $dst$$Register;
 8906     Register Rsrc1 = $src1$$Register;
 8907     Register Rsrc2 = $src2$$Register;
 8908     Label done;
 8909 
 8910     if (Rsrc1 == Rsrc2) {
 8911       if (Rdst != Rsrc1) {
 8912         __ z_lgfr(Rdst, Rsrc1);
 8913       }
 8914     } else if (Rdst == Rsrc1) {
 8915       __ z_cr(Rsrc1, Rsrc2);
 8916       __ z_brh(done);
 8917       __ z_lgfr(Rdst, Rsrc2);
 8918     } else if (Rdst == Rsrc2) {
 8919       __ z_cr(Rsrc2, Rsrc1);
 8920       __ z_brh(done);
 8921       __ z_lgfr(Rdst, Rsrc1);
 8922     } else {
 8923       __ z_lgfr(Rdst, Rsrc1);
 8924       __ z_cr(Rsrc1, Rsrc2);
 8925       __ z_brh(done);
 8926       __ z_lgfr(Rdst, Rsrc2);
 8927     }
 8928 
 8929     __ bind(done);
 8930   %}
 8931 
 8932   ins_pipe(pipe_class_dummy);
 8933 %}
 8934 
 8935 instruct z196_maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8936   match(Set dst (MaxI src1 src2));
 8937   effect(KILL cr);
 8938   predicate(VM_Version::has_LoadStoreConditional());
 8939   ins_cost(3 * DEFAULT_COST);
 8940   // TODO: s390 port size(VARIABLE_SIZE);
 8941   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32 (z196 only)&quot; %}
 8942   ins_encode %{
 8943     Register Rdst = $dst$$Register;
 8944     Register Rsrc1 = $src1$$Register;
 8945     int      Isrc2 = $src2$$constant;
 8946 
 8947     if (Rdst == Rsrc1) {
 8948       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8949       __ z_cfi(Rsrc1, Isrc2);
 8950       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8951     } else {
 8952       __ load_const_optimized(Rdst, Isrc2);
 8953       __ z_cfi(Rsrc1, Isrc2);
 8954       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8955     }
 8956   %}
 8957   ins_pipe(pipe_class_dummy);
 8958 %}
 8959 
 8960 instruct maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8961   match(Set dst (MaxI src1 src2));
 8962   effect(KILL cr);
 8963   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8964   // TODO: s390 port size(VARIABLE_SIZE);
 8965   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32&quot; %}
 8966   ins_encode %{
 8967     Label done;
 8968     if ($dst$$Register != $src1$$Register) {
 8969       __ z_lgfr($dst$$Register, $src1$$Register);
 8970     }
 8971     __ z_cfi($src1$$Register, $src2$$constant);
 8972     __ z_brh(done);
 8973     __ z_lgfi($dst$$Register, $src2$$constant);
 8974     __ bind(done);
 8975   %}
 8976   ins_pipe(pipe_class_dummy);
 8977 %}
 8978 
 8979 instruct z196_maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8980   match(Set dst (MaxI src1 src2));
 8981   effect(KILL cr);
 8982   predicate(VM_Version::has_LoadStoreConditional());
 8983   ins_cost(3 * DEFAULT_COST);
 8984   // TODO: s390 port size(VARIABLE_SIZE);
 8985   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16 (z196 only)&quot; %}
 8986   ins_encode %{
 8987     Register Rdst = $dst$$Register;
 8988     Register Rsrc1 = $src1$$Register;
 8989     int      Isrc2 = $src2$$constant;
 8990     if (Rdst == Rsrc1) {
 8991       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8992       __ z_chi(Rsrc1, Isrc2);
 8993       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8994     } else {
 8995       __ load_const_optimized(Rdst, Isrc2);
 8996       __ z_chi(Rsrc1, Isrc2);
 8997       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8998     }
 8999   %}
 9000   ins_pipe(pipe_class_dummy);
 9001 %}
 9002 
 9003 instruct maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 9004   match(Set dst (MaxI src1 src2));
 9005   effect(KILL cr);
 9006   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 9007   // TODO: s390 port size(VARIABLE_SIZE);
 9008   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16&quot; %}
 9009   ins_encode %{
 9010     Label done;
 9011     if ($dst$$Register != $src1$$Register) {
 9012       __ z_lgfr($dst$$Register, $src1$$Register);
 9013     }
 9014     __ z_chi($src1$$Register, $src2$$constant);
 9015     __ z_brh(done);
 9016     __ z_lghi($dst$$Register, $src2$$constant);
 9017     __ bind(done);
 9018   %}
 9019   ins_pipe(pipe_class_dummy);
 9020 %}
 9021 
 9022 instruct z10_maxI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 9023   match(Set dst (MaxI src1 src2));
 9024   effect(KILL cr);
 9025   predicate(VM_Version::has_CompareBranch());
 9026   ins_cost(DEFAULT_COST + BRANCH_COST);
 9027   // TODO: s390 port size(VARIABLE_SIZE);
 9028   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const8&quot; %}
 9029   ins_encode %{
 9030     Label done;
 9031     if ($dst$$Register != $src1$$Register) {
 9032       __ z_lgfr($dst$$Register, $src1$$Register);
 9033     }
 9034     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondHigh, done);
 9035     __ z_lghi($dst$$Register, $src2$$constant);
 9036     __ bind(done);
 9037   %}
 9038   ins_pipe(pipe_class_dummy);
 9039 %}
 9040 
 9041 //----------Abs---------------------------------------------------------------
 9042 
 9043 instruct absI_reg(iRegI dst, iRegI src, flagsReg cr) %{
 9044   match(Set dst (AbsI src));
 9045   effect(KILL cr);
 9046   ins_cost(DEFAULT_COST_LOW);
 9047   // TODO: s390 port size(FIXED_SIZE);
 9048   format %{ &quot;LPR     $dst, $src&quot; %}
 9049   opcode(LPR_ZOPC);
 9050   ins_encode(z_rrform(dst, src));
 9051   ins_pipe(pipe_class_dummy);
 9052 %}
 9053 
 9054 instruct negabsI_reg(iRegI dst, iRegI src, immI_0 zero, flagsReg cr) %{
 9055   match(Set dst (SubI zero (AbsI src)));
 9056   effect(KILL cr);
 9057   ins_cost(DEFAULT_COST_LOW);
 9058   // TODO: s390 port size(FIXED_SIZE);
 9059   format %{ &quot;LNR     $dst, $src&quot; %}
 9060   opcode(LNR_ZOPC);
 9061   ins_encode(z_rrform(dst, src));
 9062   ins_pipe(pipe_class_dummy);
 9063 %}
 9064 
 9065 //----------Float Compares----------------------------------------------------
 9066 
 9067 // Compare floating, generate condition code.
 9068 instruct cmpF_cc(flagsReg cr, regF src1, regF src2) %{
 9069   match(Set cr (CmpF src1 src2));
 9070   ins_cost(ALU_REG_COST);
 9071   size(4);
 9072   format %{ &quot;FCMPcc   $src1,$src2\t # float&quot; %}
 9073   ins_encode %{ __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9074   ins_pipe(pipe_class_dummy);
 9075 %}
 9076 
 9077 instruct cmpD_cc(flagsReg cr, regD src1, regD src2) %{
 9078   match(Set cr (CmpD src1 src2));
 9079   ins_cost(ALU_REG_COST);
 9080   size(4);
 9081   format %{ &quot;FCMPcc   $src1,$src2 \t # double&quot; %}
 9082   ins_encode %{ __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9083   ins_pipe(pipe_class_dummy);
 9084 %}
 9085 
 9086 instruct cmpF_cc_mem(flagsReg cr, regF src1, memoryRX src2) %{
 9087   match(Set cr (CmpF src1 (LoadF src2)));
 9088   ins_cost(ALU_MEMORY_COST);
 9089   size(6);
 9090   format %{ &quot;FCMPcc_mem $src1,$src2\t # floatMemory&quot; %}
 9091   opcode(CEB_ZOPC);
 9092   ins_encode(z_form_rt_memFP(src1, src2));
 9093   ins_pipe(pipe_class_dummy);
 9094 %}
 9095 
 9096 instruct cmpD_cc_mem(flagsReg cr, regD src1, memoryRX src2) %{
 9097   match(Set cr (CmpD src1 (LoadD src2)));
 9098   ins_cost(ALU_MEMORY_COST);
 9099   size(6);
 9100   format %{ &quot;DCMPcc_mem $src1,$src2\t # doubleMemory&quot; %}
 9101   opcode(CDB_ZOPC);
 9102   ins_encode(z_form_rt_memFP(src1, src2));
 9103   ins_pipe(pipe_class_dummy);
 9104 %}
 9105 
 9106 // Compare floating, generate condition code
 9107 instruct cmpF0_cc(flagsReg cr, regF src1, immFpm0 src2) %{
 9108   match(Set cr (CmpF src1 src2));
 9109   ins_cost(DEFAULT_COST);
 9110   size(4);
 9111   format %{ &quot;LTEBR    $src1,$src1\t # float&quot; %}
 9112   opcode(LTEBR_ZOPC);
 9113   ins_encode(z_rreform(src1, src1));
 9114   ins_pipe(pipe_class_dummy);
 9115 %}
 9116 
 9117 instruct cmpD0_cc(flagsReg cr, regD src1, immDpm0 src2) %{
 9118   match(Set cr (CmpD src1 src2));
 9119   ins_cost(DEFAULT_COST);
 9120   size(4);
 9121   format %{ &quot;LTDBR    $src1,$src1 \t # double&quot; %}
 9122   opcode(LTDBR_ZOPC);
 9123   ins_encode(z_rreform(src1, src1));
 9124   ins_pipe(pipe_class_dummy);
 9125 %}
 9126 
 9127 // Compare floating, generate -1,0,1
 9128 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsReg cr) %{
 9129   match(Set dst (CmpF3 src1 src2));
 9130   effect(KILL cr);
 9131   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9132   size(24);
 9133   format %{ &quot;CmpF3    $dst,$src1,$src2&quot; %}
 9134   ins_encode %{
 9135     // compare registers
 9136     __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister);
 9137     // Convert condition code into -1,0,1, where
 9138     // -1 means unordered or less
 9139     //  0 means equal
 9140     //  1 means greater.
 9141     if (VM_Version::has_LoadStoreConditional()) {
 9142       Register one       = Z_R0_scratch;
 9143       Register minus_one = Z_R1_scratch;
 9144       __ z_lghi(minus_one, -1);
 9145       __ z_lghi(one, 1);
 9146       __ z_lghi( $dst$$Register, 0);
 9147       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9148       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9149     } else {
 9150       Label done;
 9151       __ clear_reg($dst$$Register, true, false);
 9152       __ z_bre(done);
 9153       __ z_lhi($dst$$Register, 1);
 9154       __ z_brh(done);
 9155       __ z_lhi($dst$$Register, -1);
 9156       __ bind(done);
 9157     }
 9158   %}
 9159   ins_pipe(pipe_class_dummy);
 9160 %}
 9161 
 9162 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsReg cr) %{
 9163   match(Set dst (CmpD3 src1 src2));
 9164   effect(KILL cr);
 9165   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9166   size(24);
 9167   format %{ &quot;CmpD3    $dst,$src1,$src2&quot; %}
 9168   ins_encode %{
 9169     // compare registers
 9170     __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister);
 9171     // Convert condition code into -1,0,1, where
 9172     // -1 means unordered or less
 9173     //  0 means equal
 9174     //  1 means greater.
 9175     if (VM_Version::has_LoadStoreConditional()) {
 9176       Register one       = Z_R0_scratch;
 9177       Register minus_one = Z_R1_scratch;
 9178       __ z_lghi(minus_one, -1);
 9179       __ z_lghi(one, 1);
 9180       __ z_lghi( $dst$$Register, 0);
 9181       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9182       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9183     } else {
 9184       Label done;
 9185       // indicate unused result
 9186       (void) __ clear_reg($dst$$Register, true, false);
 9187       __ z_bre(done);
 9188       __ z_lhi($dst$$Register, 1);
 9189       __ z_brh(done);
 9190       __ z_lhi($dst$$Register, -1);
 9191       __ bind(done);
 9192     }
 9193   %}
 9194   ins_pipe(pipe_class_dummy);
 9195 %}
 9196 
 9197 //----------Branches---------------------------------------------------------
 9198 // Jump
 9199 
 9200 // Direct Branch.
 9201 instruct branch(label labl) %{
 9202   match(Goto);
 9203   effect(USE labl);
 9204   ins_cost(BRANCH_COST);
 9205   size(4);
 9206   format %{ &quot;BRU     $labl&quot; %}
 9207   ins_encode(z_enc_bru(labl));
 9208   ins_pipe(pipe_class_dummy);
 9209   // If set to 1 this indicates that the current instruction is a
 9210   // short variant of a long branch. This avoids using this
 9211   // instruction in first-pass matching. It will then only be used in
 9212   // the `Shorten_branches&#39; pass.
 9213   ins_short_branch(1);
 9214 %}
 9215 
 9216 // Direct Branch.
 9217 instruct branchFar(label labl) %{
 9218   match(Goto);
 9219   effect(USE labl);
 9220   ins_cost(BRANCH_COST);
 9221   size(6);
 9222   format %{ &quot;BRUL   $labl&quot; %}
 9223   ins_encode(z_enc_brul(labl));
 9224   ins_pipe(pipe_class_dummy);
 9225   // This is not a short variant of a branch, but the long variant.
 9226   ins_short_branch(0);
 9227 %}
 9228 
 9229 // Conditional Near Branch
 9230 instruct branchCon(cmpOp cmp, flagsReg cr, label lbl) %{
 9231   // Same match rule as `branchConFar&#39;.
 9232   match(If cmp cr);
 9233   effect(USE lbl);
 9234   ins_cost(BRANCH_COST);
 9235   size(4);
 9236   format %{ &quot;branch_con_short,$cmp   $lbl&quot; %}
 9237   ins_encode(z_enc_branch_con_short(cmp, lbl));
 9238   ins_pipe(pipe_class_dummy);
 9239   // If set to 1 this indicates that the current instruction is a
 9240   // short variant of a long branch. This avoids using this
 9241   // instruction in first-pass matching. It will then only be used in
 9242   // the `Shorten_branches&#39; pass.
 9243   ins_short_branch(1);
 9244 %}
 9245 
 9246 // This is for cases when the z/Architecture conditional branch instruction
 9247 // does not reach far enough. So we emit a far branch here, which is
 9248 // more expensive.
 9249 //
 9250 // Conditional Far Branch
 9251 instruct branchConFar(cmpOp cmp, flagsReg cr, label lbl) %{
 9252   // Same match rule as `branchCon&#39;.
 9253   match(If cmp cr);
 9254   effect(USE cr, USE lbl);
 9255   // Make more expensive to prefer compare_and_branch over separate instructions.
 9256   ins_cost(2 * BRANCH_COST);
 9257   size(6);
 9258   format %{ &quot;branch_con_far,$cmp   $lbl&quot; %}
 9259   ins_encode(z_enc_branch_con_far(cmp, lbl));
 9260   ins_pipe(pipe_class_dummy);
 9261   // This is not a short variant of a branch, but the long variant..
 9262   ins_short_branch(0);
 9263 %}
 9264 
 9265 instruct branchLoopEnd(cmpOp cmp, flagsReg cr, label labl) %{
 9266   match(CountedLoopEnd cmp cr);
 9267   effect(USE labl);
 9268   ins_cost(BRANCH_COST);
 9269   size(4);
 9270   format %{ &quot;branch_con_short,$cmp   $labl\t # counted loop end&quot; %}
 9271   ins_encode(z_enc_branch_con_short(cmp, labl));
 9272   ins_pipe(pipe_class_dummy);
 9273   // If set to 1 this indicates that the current instruction is a
 9274   // short variant of a long branch. This avoids using this
 9275   // instruction in first-pass matching. It will then only be used in
 9276   // the `Shorten_branches&#39; pass.
 9277   ins_short_branch(1);
 9278 %}
 9279 
 9280 instruct branchLoopEndFar(cmpOp cmp, flagsReg cr, label labl) %{
 9281   match(CountedLoopEnd cmp cr);
 9282   effect(USE labl);
 9283   ins_cost(BRANCH_COST);
 9284   size(6);
 9285   format %{ &quot;branch_con_far,$cmp   $labl\t # counted loop end&quot; %}
 9286   ins_encode(z_enc_branch_con_far(cmp, labl));
 9287   ins_pipe(pipe_class_dummy);
 9288   // This is not a short variant of a branch, but the long variant.
 9289   ins_short_branch(0);
 9290 %}
 9291 
 9292 //----------Compare and Branch (short distance)------------------------------
 9293 
 9294 // INT REG operands for loop counter processing.
 9295 instruct testAndBranchLoopEnd_Reg(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9296   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9297   effect(USE labl, KILL cr);
 9298   predicate(VM_Version::has_CompareBranch());
 9299   ins_cost(BRANCH_COST);
 9300   // TODO: s390 port size(FIXED_SIZE);
 9301   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9302   opcode(CRJ_ZOPC);
 9303   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9304   ins_pipe(pipe_class_dummy);
 9305   ins_short_branch(1);
 9306 %}
 9307 
 9308 // INT REG operands.
 9309 instruct cmpb_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9310   match(If boolnode (CmpI src1 src2));
 9311   effect(USE labl, KILL cr);
 9312   predicate(VM_Version::has_CompareBranch());
 9313   ins_cost(BRANCH_COST);
 9314   // TODO: s390 port size(FIXED_SIZE);
 9315   format %{ &quot;CRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9316   opcode(CRJ_ZOPC);
 9317   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9318   ins_pipe(pipe_class_dummy);
 9319   ins_short_branch(1);
 9320 %}
 9321 
 9322 // Unsigned INT REG operands
 9323 instruct cmpbU_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9324   match(If boolnode (CmpU src1 src2));
 9325   effect(USE labl, KILL cr);
 9326   predicate(VM_Version::has_CompareBranch());
 9327   ins_cost(BRANCH_COST);
 9328   // TODO: s390 port size(FIXED_SIZE);
 9329   format %{ &quot;CLRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9330   opcode(CLRJ_ZOPC);
 9331   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9332   ins_pipe(pipe_class_dummy);
 9333   ins_short_branch(1);
 9334 %}
 9335 
 9336 // LONG REG operands
 9337 instruct cmpb_RegL(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9338   match(If boolnode (CmpL src1 src2));
 9339   effect(USE labl, KILL cr);
 9340   predicate(VM_Version::has_CompareBranch());
 9341   ins_cost(BRANCH_COST);
 9342   // TODO: s390 port size(FIXED_SIZE);
 9343   format %{ &quot;CGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9344   opcode(CGRJ_ZOPC);
 9345   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9346   ins_pipe(pipe_class_dummy);
 9347   ins_short_branch(1);
 9348 %}
 9349 
 9350 //  PTR REG operands
 9351 
 9352 // Separate rules for regular and narrow oops.  ADLC can&#39;t recognize
 9353 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9354 // will not shorten.
 9355 
 9356 instruct cmpb_RegPP(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9357   match(If boolnode (CmpP src1 src2));
 9358   effect(USE labl, KILL cr);
 9359   predicate(VM_Version::has_CompareBranch());
 9360   ins_cost(BRANCH_COST);
 9361   // TODO: s390 port size(FIXED_SIZE);
 9362   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9363   opcode(CLGRJ_ZOPC);
 9364   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9365   ins_pipe(pipe_class_dummy);
 9366   ins_short_branch(1);
 9367 %}
 9368 
 9369 instruct cmpb_RegNN(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9370   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9371   effect(USE labl, KILL cr);
 9372   predicate(VM_Version::has_CompareBranch());
 9373   ins_cost(BRANCH_COST);
 9374   // TODO: s390 port size(FIXED_SIZE);
 9375   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9376   opcode(CLGRJ_ZOPC);
 9377   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9378   ins_pipe(pipe_class_dummy);
 9379   ins_short_branch(1);
 9380 %}
 9381 
 9382 // INT REG/IMM operands for loop counter processing
 9383 instruct testAndBranchLoopEnd_Imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9384   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9385   effect(USE labl, KILL cr);
 9386   predicate(VM_Version::has_CompareBranch());
 9387   ins_cost(BRANCH_COST);
 9388   // TODO: s390 port size(FIXED_SIZE);
 9389   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9390   opcode(CIJ_ZOPC);
 9391   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9392   ins_pipe(pipe_class_dummy);
 9393   ins_short_branch(1);
 9394 %}
 9395 
 9396 // INT REG/IMM operands
 9397 instruct cmpb_RegI_imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9398   match(If boolnode (CmpI src1 src2));
 9399   effect(USE labl, KILL cr);
 9400   predicate(VM_Version::has_CompareBranch());
 9401   ins_cost(BRANCH_COST);
 9402   // TODO: s390 port size(FIXED_SIZE);
 9403   format %{ &quot;CIJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9404   opcode(CIJ_ZOPC);
 9405   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9406   ins_pipe(pipe_class_dummy);
 9407   ins_short_branch(1);
 9408 %}
 9409 
 9410 // INT REG/IMM operands
 9411 instruct cmpbU_RegI_imm(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9412   match(If boolnode (CmpU src1 src2));
 9413   effect(USE labl, KILL cr);
 9414   predicate(VM_Version::has_CompareBranch());
 9415   ins_cost(BRANCH_COST);
 9416   // TODO: s390 port size(FIXED_SIZE);
 9417   format %{ &quot;CLIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9418   opcode(CLIJ_ZOPC);
 9419   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9420   ins_pipe(pipe_class_dummy);
 9421   ins_short_branch(1);
 9422 %}
 9423 
 9424 // LONG REG/IMM operands
 9425 instruct cmpb_RegL_imm(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9426   match(If boolnode (CmpL src1 src2));
 9427   effect(USE labl, KILL cr);
 9428   predicate(VM_Version::has_CompareBranch());
 9429   ins_cost(BRANCH_COST);
 9430   // TODO: s390 port size(FIXED_SIZE);
 9431   format %{ &quot;CGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9432   opcode(CGIJ_ZOPC);
 9433   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9434   ins_pipe(pipe_class_dummy);
 9435   ins_short_branch(1);
 9436 %}
 9437 
 9438 // PTR REG-imm operands
 9439 
 9440 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9441 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9442 // will not shorten.
 9443 
 9444 instruct cmpb_RegP_immP(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9445   match(If boolnode (CmpP src1 src2));
 9446   effect(USE labl, KILL cr);
 9447   predicate(VM_Version::has_CompareBranch());
 9448   ins_cost(BRANCH_COST);
 9449   // TODO: s390 port size(FIXED_SIZE);
 9450   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9451   opcode(CLGIJ_ZOPC);
 9452   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9453   ins_pipe(pipe_class_dummy);
 9454   ins_short_branch(1);
 9455 %}
 9456 
 9457 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9458 instruct cmpb_RegN_immP0(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9459   match(If boolnode (CmpP (DecodeN src1) src2));
 9460   effect(USE labl, KILL cr);
 9461   predicate(VM_Version::has_CompareBranch());
 9462   ins_cost(BRANCH_COST);
 9463   // TODO: s390 port size(FIXED_SIZE);
 9464   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9465   opcode(CLGIJ_ZOPC);
 9466   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9467   ins_pipe(pipe_class_dummy);
 9468   ins_short_branch(1);
 9469 %}
 9470 
 9471 instruct cmpb_RegN_imm(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9472   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9473   effect(USE labl, KILL cr);
 9474   predicate(VM_Version::has_CompareBranch());
 9475   ins_cost(BRANCH_COST);
 9476   // TODO: s390 port size(FIXED_SIZE);
 9477   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9478   opcode(CLGIJ_ZOPC);
 9479   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9480   ins_pipe(pipe_class_dummy);
 9481   ins_short_branch(1);
 9482 %}
 9483 
 9484 
 9485 //----------Compare and Branch (far distance)------------------------------
 9486 
 9487 // INT REG operands for loop counter processing
 9488 instruct testAndBranchLoopEnd_RegFar(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9489   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9490   effect(USE labl, KILL cr);
 9491   predicate(VM_Version::has_CompareBranch());
 9492   ins_cost(BRANCH_COST+DEFAULT_COST);
 9493   // TODO: s390 port size(FIXED_SIZE);
 9494   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9495   opcode(CR_ZOPC, BRCL_ZOPC);
 9496   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9497   ins_pipe(pipe_class_dummy);
 9498   ins_short_branch(0);
 9499 %}
 9500 
 9501 // INT REG operands
 9502 instruct cmpb_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9503   match(If boolnode (CmpI src1 src2));
 9504   effect(USE labl, KILL cr);
 9505   predicate(VM_Version::has_CompareBranch());
 9506   ins_cost(BRANCH_COST+DEFAULT_COST);
 9507   // TODO: s390 port size(FIXED_SIZE);
 9508   format %{ &quot;CRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9509   opcode(CR_ZOPC, BRCL_ZOPC);
 9510   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9511   ins_pipe(pipe_class_dummy);
 9512   ins_short_branch(0);
 9513 %}
 9514 
 9515 // INT REG operands
 9516 instruct cmpbU_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9517   match(If boolnode (CmpU src1 src2));
 9518   effect(USE labl, KILL cr);
 9519   predicate(VM_Version::has_CompareBranch());
 9520   ins_cost(BRANCH_COST+DEFAULT_COST);
 9521   // TODO: s390 port size(FIXED_SIZE);
 9522   format %{ &quot;CLRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9523   opcode(CLR_ZOPC, BRCL_ZOPC);
 9524   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9525   ins_pipe(pipe_class_dummy);
 9526   ins_short_branch(0);
 9527 %}
 9528 
 9529 // LONG REG operands
 9530 instruct cmpb_RegL_Far(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9531   match(If boolnode (CmpL src1 src2));
 9532   effect(USE labl, KILL cr);
 9533   predicate(VM_Version::has_CompareBranch());
 9534   ins_cost(BRANCH_COST+DEFAULT_COST);
 9535   // TODO: s390 port size(FIXED_SIZE);
 9536   format %{ &quot;CGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9537   opcode(CGR_ZOPC, BRCL_ZOPC);
 9538   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9539   ins_pipe(pipe_class_dummy);
 9540   ins_short_branch(0);
 9541 %}
 9542 
 9543 // PTR REG operands
 9544 
 9545 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9546 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9547 // will not shorten.
 9548 
 9549 instruct cmpb_RegPP_Far(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9550   match(If boolnode (CmpP src1 src2));
 9551   effect(USE labl, KILL cr);
 9552   predicate(VM_Version::has_CompareBranch());
 9553   ins_cost(BRANCH_COST+DEFAULT_COST);
 9554   // TODO: s390 port size(FIXED_SIZE);
 9555   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9556   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9557   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9558   ins_pipe(pipe_class_dummy);
 9559   ins_short_branch(0);
 9560 %}
 9561 
 9562 instruct cmpb_RegNN_Far(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9563   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9564   effect(USE labl, KILL cr);
 9565   predicate(VM_Version::has_CompareBranch());
 9566   ins_cost(BRANCH_COST+DEFAULT_COST);
 9567   // TODO: s390 port size(FIXED_SIZE);
 9568   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9569   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9570   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9571   ins_pipe(pipe_class_dummy);
 9572   ins_short_branch(0);
 9573 %}
 9574 
 9575 // INT REG/IMM operands for loop counter processing
 9576 instruct testAndBranchLoopEnd_ImmFar(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9577   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9578   effect(USE labl, KILL cr);
 9579   predicate(VM_Version::has_CompareBranch());
 9580   ins_cost(BRANCH_COST+DEFAULT_COST);
 9581   // TODO: s390 port size(FIXED_SIZE);
 9582   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9583   opcode(CHI_ZOPC, BRCL_ZOPC);
 9584   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9585   ins_pipe(pipe_class_dummy);
 9586   ins_short_branch(0);
 9587 %}
 9588 
 9589 // INT REG/IMM operands
 9590 instruct cmpb_RegI_imm_Far(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9591   match(If boolnode (CmpI src1 src2));
 9592   effect(USE labl, KILL cr);
 9593   predicate(VM_Version::has_CompareBranch());
 9594   ins_cost(BRANCH_COST+DEFAULT_COST);
 9595   // TODO: s390 port size(FIXED_SIZE);
 9596   format %{ &quot;CIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9597   opcode(CHI_ZOPC, BRCL_ZOPC);
 9598   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9599   ins_pipe(pipe_class_dummy);
 9600   ins_short_branch(0);
 9601 %}
 9602 
 9603 // INT REG/IMM operands
 9604 instruct cmpbU_RegI_imm_Far(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9605   match(If boolnode (CmpU src1 src2));
 9606   effect(USE labl, KILL cr);
 9607   predicate(VM_Version::has_CompareBranch());
 9608   ins_cost(BRANCH_COST+DEFAULT_COST);
 9609   // TODO: s390 port size(FIXED_SIZE);
 9610   format %{ &quot;CLIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9611   opcode(CLFI_ZOPC, BRCL_ZOPC);
 9612   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9613   ins_pipe(pipe_class_dummy);
 9614   ins_short_branch(0);
 9615 %}
 9616 
 9617 // LONG REG/IMM operands
 9618 instruct cmpb_RegL_imm_Far(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9619   match(If boolnode (CmpL src1 src2));
 9620   effect(USE labl, KILL cr);
 9621   predicate(VM_Version::has_CompareBranch());
 9622   ins_cost(BRANCH_COST+DEFAULT_COST);
 9623   // TODO: s390 port size(FIXED_SIZE);
 9624   format %{ &quot;CGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9625   opcode(CGHI_ZOPC, BRCL_ZOPC);
 9626   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9627   ins_pipe(pipe_class_dummy);
 9628   ins_short_branch(0);
 9629 %}
 9630 
 9631 // PTR REG-imm operands
 9632 
 9633 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9634 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9635 // will not shorten.
 9636 
 9637 instruct cmpb_RegP_immP_Far(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9638   match(If boolnode (CmpP src1 src2));
 9639   effect(USE labl, KILL cr);
 9640   predicate(VM_Version::has_CompareBranch());
 9641   ins_cost(BRANCH_COST+DEFAULT_COST);
 9642   // TODO: s390 port size(FIXED_SIZE);
 9643   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9644   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9645   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9646   ins_pipe(pipe_class_dummy);
 9647   ins_short_branch(0);
 9648 %}
 9649 
 9650 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9651 instruct cmpb_RegN_immP0_Far(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9652   match(If boolnode (CmpP (DecodeN src1) src2));
 9653   effect(USE labl, KILL cr);
 9654   predicate(VM_Version::has_CompareBranch());
 9655   ins_cost(BRANCH_COST+DEFAULT_COST);
 9656   // TODO: s390 port size(FIXED_SIZE);
 9657   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9658   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9659   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9660   ins_pipe(pipe_class_dummy);
 9661   ins_short_branch(0);
 9662 %}
 9663 
 9664 instruct cmpb_RegN_immN_Far(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9665   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9666   effect(USE labl, KILL cr);
 9667   predicate(VM_Version::has_CompareBranch());
 9668   ins_cost(BRANCH_COST+DEFAULT_COST);
 9669   // TODO: s390 port size(FIXED_SIZE);
 9670   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9671   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9672   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9673   ins_pipe(pipe_class_dummy);
 9674   ins_short_branch(0);
 9675 %}
 9676 
 9677 // ============================================================================
 9678 // Long Compare
 9679 
 9680 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9681 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)). Note the
 9682 // difference between &#39;Y&#39; and &#39;0L&#39;. The tree-matches for the CmpI sections
 9683 // are collapsed internally in the ADLC&#39;s dfa-gen code. The match for
 9684 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9685 // foo match ends up with the wrong leaf. One fix is to not match both
 9686 // reg-reg and reg-zero forms of long-compare. This is unfortunate because
 9687 // both forms beat the trinary form of long-compare and both are very useful
 9688 // on platforms which have few registers.
 9689 
 9690 // Manifest a CmpL3 result in an integer register. Very painful.
 9691 // This is the test to avoid.
 9692 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr) %{
 9693   match(Set dst (CmpL3 src1 src2));
 9694   effect(KILL cr);
 9695   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9696   size(24);
 9697   format %{ &quot;CmpL3 $dst,$src1,$src2&quot; %}
 9698   ins_encode %{
 9699     Label done;
 9700     // compare registers
 9701     __ z_cgr($src1$$Register, $src2$$Register);
 9702     // Convert condition code into -1,0,1, where
 9703     // -1 means less
 9704     //  0 means equal
 9705     //  1 means greater.
 9706     if (VM_Version::has_LoadStoreConditional()) {
 9707       Register one       = Z_R0_scratch;
 9708       Register minus_one = Z_R1_scratch;
 9709       __ z_lghi(minus_one, -1);
 9710       __ z_lghi(one, 1);
 9711       __ z_lghi( $dst$$Register, 0);
 9712       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9713       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLow);
 9714     } else {
 9715       __ clear_reg($dst$$Register, true, false);
 9716       __ z_bre(done);
 9717       __ z_lhi($dst$$Register, 1);
 9718       __ z_brh(done);
 9719       __ z_lhi($dst$$Register, -1);
 9720     }
 9721     __ bind(done);
 9722   %}
 9723   ins_pipe(pipe_class_dummy);
 9724 %}
 9725 
 9726 // ============================================================================
 9727 // Safepoint Instruction
 9728 
 9729 instruct safePoint() %{
 9730   match(SafePoint);
 9731   predicate(false);
 9732   // TODO: s390 port size(FIXED_SIZE);
 9733   format %{ &quot;UNIMPLEMENTED Safepoint_ &quot; %}
 9734   ins_encode(enc_unimplemented());
 9735   ins_pipe(pipe_class_dummy);
 9736 %}
 9737 
 9738 instruct safePoint_poll(iRegP poll, flagsReg cr) %{
 9739   match(SafePoint poll);
 9740   effect(USE poll, KILL cr); // R0 is killed, too.
 9741   // TODO: s390 port size(FIXED_SIZE);
 9742   format %{ &quot;TM      #0[,$poll],#111\t # Safepoint: poll for GC&quot; %}
 9743   ins_encode %{
 9744     // Mark the code position where the load from the safepoint
 9745     // polling page was emitted as relocInfo::poll_type.
 9746     __ relocate(relocInfo::poll_type);
 9747     __ load_from_polling_page($poll$$Register);
 9748   %}
 9749   ins_pipe(pipe_class_dummy);
 9750 %}
 9751 
 9752 // ============================================================================
 9753 
 9754 // Call Instructions
 9755 
 9756 // Call Java Static Instruction
 9757 instruct CallStaticJavaDirect_dynTOC(method meth) %{
 9758   match(CallStaticJava);
 9759   effect(USE meth);
 9760   ins_cost(CALL_COST);
 9761   // TODO: s390 port size(VARIABLE_SIZE);
 9762   format %{ &quot;CALL,static dynTOC $meth; ==&gt; &quot; %}
 9763   ins_encode( z_enc_java_static_call(meth) );
 9764   ins_pipe(pipe_class_dummy);
 9765   ins_alignment(2);
 9766 %}
 9767 
 9768 // Call Java Dynamic Instruction
 9769 instruct CallDynamicJavaDirect_dynTOC(method meth) %{
 9770   match(CallDynamicJava);
 9771   effect(USE meth);
 9772   ins_cost(CALL_COST);
 9773   // TODO: s390 port size(VARIABLE_SIZE);
 9774   format %{ &quot;CALL,dynamic dynTOC $meth; ==&gt; &quot; %}
 9775   ins_encode(z_enc_java_dynamic_call(meth));
 9776   ins_pipe(pipe_class_dummy);
 9777   ins_alignment(2);
 9778 %}
 9779 
 9780 // Call Runtime Instruction
 9781 instruct CallRuntimeDirect(method meth) %{
 9782   match(CallRuntime);
 9783   effect(USE meth);
 9784   ins_cost(CALL_COST);
 9785   // TODO: s390 port size(VARIABLE_SIZE);
 9786   ins_num_consts(1);
 9787   ins_alignment(2);
 9788   format %{ &quot;CALL,runtime&quot; %}
 9789   ins_encode( z_enc_java_to_runtime_call(meth) );
 9790   ins_pipe(pipe_class_dummy);
 9791 %}
 9792 
 9793 // Call runtime without safepoint - same as CallRuntime
 9794 instruct CallLeafDirect(method meth) %{
 9795   match(CallLeaf);
 9796   effect(USE meth);
 9797   ins_cost(CALL_COST);
 9798   // TODO: s390 port size(VARIABLE_SIZE);
 9799   ins_num_consts(1);
 9800   ins_alignment(2);
 9801   format %{ &quot;CALL,runtime leaf $meth&quot; %}
 9802   ins_encode( z_enc_java_to_runtime_call(meth) );
 9803   ins_pipe(pipe_class_dummy);
 9804 %}
 9805 
 9806 // Call runtime without safepoint - same as CallLeaf
 9807 instruct CallLeafNoFPDirect(method meth) %{
 9808   match(CallLeafNoFP);
 9809   effect(USE meth);
 9810   ins_cost(CALL_COST);
 9811   // TODO: s390 port size(VARIABLE_SIZE);
 9812   ins_num_consts(1);
 9813   format %{ &quot;CALL,runtime leaf nofp $meth&quot; %}
 9814   ins_encode( z_enc_java_to_runtime_call(meth) );
 9815   ins_pipe(pipe_class_dummy);
 9816   ins_alignment(2);
 9817 %}
 9818 
 9819 // Tail Call; Jump from runtime stub to Java code.
 9820 // Also known as an &#39;interprocedural jump&#39;.
 9821 // Target of jump will eventually return to caller.
 9822 // TailJump below removes the return address.
 9823 instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
 9824   match(TailCall jump_target method_oop);
 9825   ins_cost(CALL_COST);
 9826   size(2);
 9827   format %{ &quot;Jmp     $jump_target\t # $method_oop holds method oop&quot; %}
 9828   ins_encode %{ __ z_br($jump_target$$Register); %}
 9829   ins_pipe(pipe_class_dummy);
 9830 %}
 9831 
 9832 // Return Instruction
 9833 instruct Ret() %{
 9834   match(Return);
 9835   size(2);
 9836   format %{ &quot;BR(Z_R14) // branch to link register&quot; %}
 9837   ins_encode %{ __ z_br(Z_R14); %}
 9838   ins_pipe(pipe_class_dummy);
 9839 %}
 9840 
 9841 // Tail Jump; remove the return address; jump to target.
 9842 // TailCall above leaves the return address around.
 9843 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9844 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9845 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9846 // in %i0.
 9847 instruct tailjmpInd(iRegP jump_target, rarg1RegP ex_oop) %{
 9848   match(TailJump jump_target ex_oop);
 9849   ins_cost(CALL_COST);
 9850   size(8);
 9851   format %{ &quot;TailJump $jump_target&quot; %}
 9852   ins_encode %{
 9853     __ z_lg(Z_ARG2/* issuing pc */, _z_abi(return_pc), Z_SP);
 9854     __ z_br($jump_target$$Register);
 9855   %}
 9856   ins_pipe(pipe_class_dummy);
 9857 %}
 9858 
 9859 // Create exception oop: created by stack-crawling runtime code.
 9860 // Created exception is now available to this handler, and is setup
 9861 // just prior to jumping to this handler. No code emitted.
 9862 instruct CreateException(rarg1RegP ex_oop) %{
 9863   match(Set ex_oop (CreateEx));
 9864   ins_cost(0);
 9865   size(0);
 9866   format %{ &quot;# exception oop; no code emitted&quot; %}
 9867   ins_encode(/*empty*/);
 9868   ins_pipe(pipe_class_dummy);
 9869 %}
 9870 
 9871 // Rethrow exception: The exception oop will come in the first
 9872 // argument position. Then JUMP (not call) to the rethrow stub code.
 9873 instruct RethrowException() %{
 9874   match(Rethrow);
 9875   ins_cost(CALL_COST);
 9876   // TODO: s390 port size(VARIABLE_SIZE);
 9877   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9878   ins_encode %{
 9879     cbuf.set_insts_mark();
 9880     __ load_const_optimized(Z_R1_scratch, (address)OptoRuntime::rethrow_stub());
 9881     __ z_br(Z_R1_scratch);
 9882   %}
 9883   ins_pipe(pipe_class_dummy);
 9884 %}
 9885 
 9886 // Die now.
 9887 instruct ShouldNotReachHere() %{
 9888   match(Halt);
 9889   ins_cost(CALL_COST);
 9890   size(2);
 9891   format %{ &quot;ILLTRAP; ShouldNotReachHere&quot; %}
 9892   ins_encode %{ __ z_illtrap(); %}
 9893   ins_pipe(pipe_class_dummy);
 9894 %}
 9895 
 9896 // ============================================================================
 9897 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
 9898 // array for an instance of the superklass. Set a hidden internal cache on a
 9899 // hit (cache is checked with exposed code in gen_subtype_check()). Return
 9900 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
 9901 instruct partialSubtypeCheck(rarg1RegP index, rarg2RegP sub, rarg3RegP super, flagsReg pcc,
 9902                              rarg4RegP scratch1, rarg5RegP scratch2) %{
 9903   match(Set index (PartialSubtypeCheck sub super));
 9904   effect(KILL pcc, KILL scratch1, KILL scratch2);
 9905   ins_cost(10 * DEFAULT_COST);
 9906   // TODO: s390 port size(FIXED_SIZE);
 9907   format %{ &quot;  CALL   PartialSubtypeCheck\n&quot; %}
 9908   ins_encode %{
 9909     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9910     __ load_const_optimized(Z_ARG4, stub_address);
 9911     __ z_basr(Z_R14, Z_ARG4);
 9912   %}
 9913   ins_pipe(pipe_class_dummy);
 9914 %}
 9915 
 9916 instruct partialSubtypeCheck_vs_zero(flagsReg pcc, rarg2RegP sub, rarg3RegP super, immP0 zero,
 9917                                      rarg1RegP index, rarg4RegP scratch1, rarg5RegP scratch2) %{
 9918   match(Set pcc (CmpI (PartialSubtypeCheck sub super) zero));
 9919   effect(KILL scratch1, KILL scratch2, KILL index);
 9920   ins_cost(10 * DEFAULT_COST);
 9921   // TODO: s390 port size(FIXED_SIZE);
 9922   format %{ &quot;CALL   PartialSubtypeCheck_vs_zero\n&quot; %}
 9923   ins_encode %{
 9924     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9925     __ load_const_optimized(Z_ARG4, stub_address);
 9926     __ z_basr(Z_R14, Z_ARG4);
 9927   %}
 9928   ins_pipe(pipe_class_dummy);
 9929 %}
 9930 
 9931 // ============================================================================
 9932 // inlined locking and unlocking
 9933 
 9934 instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9935   match(Set pcc (FastLock oop box));
 9936   effect(TEMP tmp1, TEMP tmp2);
 9937   ins_cost(100);
 9938   // TODO: s390 port size(VARIABLE_SIZE); // Uses load_const_optimized.
 9939   format %{ &quot;FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9940   ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9941                                              UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9942   ins_pipe(pipe_class_dummy);
 9943 %}
 9944 
 9945 instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9946   match(Set pcc (FastUnlock oop box));
 9947   effect(TEMP tmp1, TEMP tmp2);
 9948   ins_cost(100);
 9949   // TODO: s390 port size(FIXED_SIZE);  // emitted code depends on UseBiasedLocking being on/off.
 9950   format %{ &quot;FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9951   ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9952                                                UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9953   ins_pipe(pipe_class_dummy);
 9954 %}
 9955 
 9956 instruct inlineCallClearArrayConst(SSlenDW cnt, iRegP_N2P base, Universe dummy, flagsReg cr) %{
 9957   match(Set dummy (ClearArray cnt base));
 9958   effect(KILL cr);
 9959   ins_cost(100);
 9960   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to varying #instructions.
 9961   format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
 9962   ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
 9963   ins_pipe(pipe_class_dummy);
 9964 %}
 9965 
 9966 instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9967   match(Set dummy (ClearArray cnt base));
 9968   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9969   ins_cost(200);
 9970   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
 9971   format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
 9972   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $tmpL$$Register); %}
 9973   ins_pipe(pipe_class_dummy);
 9974 %}
 9975 
 9976 instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9977   match(Set dummy (ClearArray cnt base));
 9978   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9979   ins_cost(300);
 9980   // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
 9981   format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
 9982   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $tmpL$$Register); %}
 9983   ins_pipe(pipe_class_dummy);
 9984 %}
 9985 
 9986 // ============================================================================
 9987 // CompactStrings
 9988 
 9989 // String equals
 9990 instruct string_equalsL(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
 9991   match(Set result (StrEquals (Binary str1 str2) cnt));
 9992   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
 9993   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
 9994   ins_cost(300);
 9995   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
 9996   ins_encode %{
 9997     __ array_equals(false, $str1$$Register, $str2$$Register,
 9998                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
 9999                     $result$$Register, true /* byte */);
10000   %}
10001   ins_pipe(pipe_class_dummy);
10002 %}
10003 
10004 instruct string_equalsU(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10005   match(Set result (StrEquals (Binary str1 str2) cnt));
10006   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10007   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10008   ins_cost(300);
10009   format %{ &quot;String Equals char[] $str1,$str2,$cnt -&gt; $result&quot; %}
10010   ins_encode %{
10011     __ array_equals(false, $str1$$Register, $str2$$Register,
10012                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
10013                     $result$$Register, false /* byte */);
10014   %}
10015   ins_pipe(pipe_class_dummy);
10016 %}
10017 
10018 instruct string_equals_imm(iRegP str1, iRegP str2, uimmI8 cnt, iRegI result, flagsReg cr) %{
10019   match(Set result (StrEquals (Binary str1 str2) cnt));
10020   effect(KILL cr); // R0 is killed, too.
10021   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10022   ins_cost(100);
10023   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
10024   ins_encode %{
10025     const int cnt_imm = $cnt$$constant;
10026     if (cnt_imm) { __ z_clc(0, cnt_imm - 1, $str1$$Register, 0, $str2$$Register); }
10027     __ z_lhi($result$$Register, 1);
10028     if (cnt_imm) {
10029       if (VM_Version::has_LoadStoreConditional()) {
10030         __ z_lhi(Z_R0_scratch, 0);
10031         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10032       } else {
10033         Label Lskip;
10034         __ z_bre(Lskip);
10035         __ clear_reg($result$$Register);
10036         __ bind(Lskip);
10037       }
10038     }
10039   %}
10040   ins_pipe(pipe_class_dummy);
10041 %}
10042 
10043 instruct string_equalsC_imm(iRegP str1, iRegP str2, immI8 cnt, iRegI result, flagsReg cr) %{
10044   match(Set result (StrEquals (Binary str1 str2) cnt));
10045   effect(KILL cr); // R0 is killed, too.
10046   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10047   ins_cost(100);
10048   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result&quot; %}
10049   ins_encode %{
10050     const int cnt_imm = $cnt$$constant; // positive immI8 (7 bits used)
10051     if (cnt_imm) { __ z_clc(0, (cnt_imm &lt;&lt; 1) - 1, $str1$$Register, 0, $str2$$Register); }
10052     __ z_lhi($result$$Register, 1);
10053     if (cnt_imm) {
10054       if (VM_Version::has_LoadStoreConditional()) {
10055         __ z_lhi(Z_R0_scratch, 0);
10056         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10057       } else {
10058         Label Lskip;
10059         __ z_bre(Lskip);
10060         __ clear_reg($result$$Register);
10061         __ bind(Lskip);
10062       }
10063     }
10064   %}
10065   ins_pipe(pipe_class_dummy);
10066 %}
10067 
10068 // Array equals
10069 instruct array_equalsB(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10070   match(Set result (AryEq ary1 ary2));
10071   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10072   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10073   ins_cost(300);
10074   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10075   ins_encode %{
10076     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10077                     noreg, $oddReg$$Register, $evenReg$$Register,
10078                     $result$$Register, true /* byte */);
10079   %}
10080   ins_pipe(pipe_class_dummy);
10081 %}
10082 
10083 instruct array_equalsC(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10084   match(Set result (AryEq ary1 ary2));
10085   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10086   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10087   ins_cost(300);
10088   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10089   ins_encode %{
10090     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10091                     noreg, $oddReg$$Register, $evenReg$$Register,
10092                     $result$$Register, false /* byte */);
10093   %}
10094   ins_pipe(pipe_class_dummy);
10095 %}
10096 
10097 // String CompareTo
10098 instruct string_compareL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10099   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10100   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10101   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10102   ins_cost(300);
10103   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10104   ins_encode %{
10105     __ string_compare($str1$$Register, $str2$$Register,
10106                       $cnt1$$Register, $cnt2$$Register,
10107                       $oddReg$$Register, $evenReg$$Register,
10108                       $result$$Register, StrIntrinsicNode::LL);
10109   %}
10110   ins_pipe(pipe_class_dummy);
10111 %}
10112 
10113 instruct string_compareU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10114   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10115   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10116   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10117   ins_cost(300);
10118   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10119   ins_encode %{
10120     __ string_compare($str1$$Register, $str2$$Register,
10121                       $cnt1$$Register, $cnt2$$Register,
10122                       $oddReg$$Register, $evenReg$$Register,
10123                       $result$$Register, StrIntrinsicNode::UU);
10124   %}
10125   ins_pipe(pipe_class_dummy);
10126 %}
10127 
10128 instruct string_compareLU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10129   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10130   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10131   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10132   ins_cost(300);
10133   format %{ &quot;String Compare byte[],char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10134   ins_encode %{
10135     __ string_compare($str1$$Register, $str2$$Register,
10136                       $cnt1$$Register, $cnt2$$Register,
10137                       $oddReg$$Register, $evenReg$$Register,
10138                       $result$$Register, StrIntrinsicNode::LU);
10139   %}
10140   ins_pipe(pipe_class_dummy);
10141 %}
10142 
10143 instruct string_compareUL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10144   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10145   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10146   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10147   ins_cost(300);
10148   format %{ &quot;String Compare char[],byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10149   ins_encode %{
10150     __ string_compare($str2$$Register, $str1$$Register,
10151                       $cnt2$$Register, $cnt1$$Register,
10152                       $oddReg$$Register, $evenReg$$Register,
10153                       $result$$Register, StrIntrinsicNode::UL);
10154   %}
10155   ins_pipe(pipe_class_dummy);
10156 %}
10157 
10158 // String IndexOfChar
10159 instruct indexOfChar_U(iRegP haystack, iRegI haycnt, iRegI ch, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10160   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
10161   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10162   ins_cost(200);
10163   format %{ &quot;String IndexOfChar [0..$haycnt]($haystack), $ch -&gt; $result&quot; %}
10164   ins_encode %{
10165     __ string_indexof_char($result$$Register,
10166                            $haystack$$Register, $haycnt$$Register,
10167                            $ch$$Register, 0 /* unused, ch is in register */,
10168                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10169   %}
10170   ins_pipe(pipe_class_dummy);
10171 %}
10172 
10173 instruct indexOf_imm1_U(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10174   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10175   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10176   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10177   ins_cost(200);
10178   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10179   ins_encode %{
10180     immPOper *needleOper = (immPOper *)$needle;
10181     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10182     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10183     jchar chr;
10184 #ifdef VM_LITTLE_ENDIAN
10185     Unimplemented();
10186 #else
10187     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
10188            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
10189 #endif
10190     __ string_indexof_char($result$$Register,
10191                            $haystack$$Register, $haycnt$$Register,
10192                            noreg, chr,
10193                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10194   %}
10195   ins_pipe(pipe_class_dummy);
10196 %}
10197 
10198 instruct indexOf_imm1_L(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10199   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10200   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10201   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10202   ins_cost(200);
10203   format %{ &quot;String IndexOf L [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10204   ins_encode %{
10205     immPOper *needleOper = (immPOper *)$needle;
10206     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10207     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10208     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10209     __ string_indexof_char($result$$Register,
10210                            $haystack$$Register, $haycnt$$Register,
10211                            noreg, chr,
10212                            $oddReg$$Register, $evenReg$$Register, true /*is_byte*/);
10213   %}
10214   ins_pipe(pipe_class_dummy);
10215 %}
10216 
10217 instruct indexOf_imm1_UL(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10218   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10219   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10220   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10221   ins_cost(200);
10222   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10223   ins_encode %{
10224     immPOper *needleOper = (immPOper *)$needle;
10225     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10226     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10227     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10228     __ string_indexof_char($result$$Register,
10229                            $haystack$$Register, $haycnt$$Register,
10230                            noreg, chr,
10231                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10232   %}
10233   ins_pipe(pipe_class_dummy);
10234 %}
10235 
10236 // String IndexOf
10237 instruct indexOf_imm_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10238   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10239   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10240   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10241   ins_cost(250);
10242   format %{ &quot;String IndexOf U [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10243   ins_encode %{
10244     __ string_indexof($result$$Register,
10245                       $haystack$$Register, $haycnt$$Register,
10246                       $needle$$Register, noreg, $needlecntImm$$constant,
10247                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10248   %}
10249   ins_pipe(pipe_class_dummy);
10250 %}
10251 
10252 instruct indexOf_imm_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10253   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10254   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10255   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10256   ins_cost(250);
10257   format %{ &quot;String IndexOf L [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10258   ins_encode %{
10259     __ string_indexof($result$$Register,
10260                       $haystack$$Register, $haycnt$$Register,
10261                       $needle$$Register, noreg, $needlecntImm$$constant,
10262                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10263   %}
10264   ins_pipe(pipe_class_dummy);
10265 %}
10266 
10267 instruct indexOf_imm_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10268   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10269   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10270   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10271   ins_cost(250);
10272   format %{ &quot;String IndexOf UL [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10273   ins_encode %{
10274     __ string_indexof($result$$Register,
10275                       $haystack$$Register, $haycnt$$Register,
10276                       $needle$$Register, noreg, $needlecntImm$$constant,
10277                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10278   %}
10279   ins_pipe(pipe_class_dummy);
10280 %}
10281 
10282 instruct indexOf_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10283   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10284   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10285   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10286   ins_cost(300);
10287   format %{ &quot;String IndexOf U [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10288   ins_encode %{
10289     __ string_indexof($result$$Register,
10290                       $haystack$$Register, $haycnt$$Register,
10291                       $needle$$Register, $needlecnt$$Register, 0,
10292                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10293   %}
10294   ins_pipe(pipe_class_dummy);
10295 %}
10296 
10297 instruct indexOf_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10298   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10299   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10300   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10301   ins_cost(300);
10302   format %{ &quot;String IndexOf L [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10303   ins_encode %{
10304     __ string_indexof($result$$Register,
10305                       $haystack$$Register, $haycnt$$Register,
10306                       $needle$$Register, $needlecnt$$Register, 0,
10307                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10308   %}
10309   ins_pipe(pipe_class_dummy);
10310 %}
10311 
10312 instruct indexOf_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10313   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10314   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10315   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10316   ins_cost(300);
10317   format %{ &quot;String IndexOf UL [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10318   ins_encode %{
10319     __ string_indexof($result$$Register,
10320                       $haystack$$Register, $haycnt$$Register,
10321                       $needle$$Register, $needlecnt$$Register, 0,
10322                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10323   %}
10324   ins_pipe(pipe_class_dummy);
10325 %}
10326 
10327 // char[] to byte[] compression
10328 instruct string_compress(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10329   match(Set result (StrCompressedCopy src (Binary dst len)));
10330   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10331   ins_cost(300);
10332   format %{ &quot;String Compress $src-&gt;$dst($len) -&gt; $result&quot; %}
10333   ins_encode %{
10334     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10335                        $tmp$$Register, false);
10336   %}
10337   ins_pipe(pipe_class_dummy);
10338 %}
10339 
10340 // byte[] to char[] inflation. trot implementation is shorter, but slower than the unrolled icm(h) loop.
10341 //instruct string_inflate_trot(Universe dummy, iRegP src, revenRegP dst, roddRegI len, iRegI tmp, flagsReg cr) %{
10342 //  match(Set dummy (StrInflatedCopy src (Binary dst len)));
10343 //  effect(USE_KILL dst, USE_KILL len, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10344 //  predicate(VM_Version::has_ETF2Enhancements());
10345 //  ins_cost(300);
10346 //  format %{ &quot;String Inflate (trot) $dst,$src($len)&quot; %}
10347 //  ins_encode %{
10348 //    __ string_inflate_trot($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10349 //  %}
10350 //  ins_pipe(pipe_class_dummy);
10351 //%}
10352 
10353 // byte[] to char[] inflation
10354 instruct string_inflate(Universe dummy, iRegP src, iRegP dst, iRegI len, iRegI tmp, flagsReg cr) %{
10355   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10356   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10357   ins_cost(300);
10358   format %{ &quot;String Inflate $src-&gt;$dst($len)&quot; %}
10359   ins_encode %{
10360     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10361   %}
10362   ins_pipe(pipe_class_dummy);
10363 %}
10364 
10365 // byte[] to char[] inflation
10366 instruct string_inflate_const(Universe dummy, iRegP src, iRegP dst, iRegI tmp, immI len, flagsReg cr) %{
10367   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10368   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10369   ins_cost(300);
10370   format %{ &quot;String Inflate (constLen) $src-&gt;$dst($len)&quot; %}
10371   ins_encode %{
10372     __ string_inflate_const($src$$Register, $dst$$Register, $tmp$$Register, $len$$constant);
10373   %}
10374   ins_pipe(pipe_class_dummy);
10375 %}
10376 
10377 // StringCoding.java intrinsics
10378 instruct has_negatives(rarg5RegP ary1, iRegI len, iRegI result, roddRegI oddReg, revenRegI evenReg, iRegI tmp, flagsReg cr) %{
10379   match(Set result (HasNegatives ary1 len));
10380   effect(TEMP_DEF result, USE_KILL ary1, TEMP oddReg, TEMP evenReg, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10381   ins_cost(300);
10382   format %{ &quot;has negatives byte[] $ary1($len) -&gt; $result&quot; %}
10383   ins_encode %{
10384     __ has_negatives($result$$Register, $ary1$$Register, $len$$Register,
10385                      $oddReg$$Register, $evenReg$$Register, $tmp$$Register);
10386   %}
10387   ins_pipe(pipe_class_dummy);
10388 %}
10389 
10390 // encode char[] to byte[] in ISO_8859_1
10391 instruct encode_iso_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10392   match(Set result (EncodeISOArray src (Binary dst len)));
10393   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10394   ins_cost(300);
10395   format %{ &quot;Encode array $src-&gt;$dst($len) -&gt; $result&quot; %}
10396   ins_encode %{
10397     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10398                        $tmp$$Register, true);
10399   %}
10400   ins_pipe(pipe_class_dummy);
10401 %}
10402 
10403 
10404 //----------PEEPHOLE RULES-----------------------------------------------------
10405 // These must follow all instruction definitions as they use the names
10406 // defined in the instructions definitions.
10407 //
10408 // peepmatch (root_instr_name [preceeding_instruction]*);
10409 //
10410 // peepconstraint %{
10411 // (instruction_number.operand_name relational_op instruction_number.operand_name
10412 //  [, ...]);
10413 // // instruction numbers are zero-based using left to right order in peepmatch
10414 //
10415 // peepreplace (instr_name([instruction_number.operand_name]*));
10416 // // provide an instruction_number.operand_name for each operand that appears
10417 // // in the replacement instruction&#39;s match rule
10418 //
10419 // ---------VM FLAGS---------------------------------------------------------
10420 //
10421 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10422 //
10423 // Each peephole rule is given an identifying number starting with zero and
10424 // increasing by one in the order seen by the parser. An individual peephole
10425 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10426 // on the command-line.
10427 //
10428 // ---------CURRENT LIMITATIONS----------------------------------------------
10429 //
10430 // Only match adjacent instructions in same basic block
10431 // Only equality constraints
10432 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10433 // Only one replacement instruction
10434 //
10435 // ---------EXAMPLE----------------------------------------------------------
10436 //
10437 // // pertinent parts of existing instructions in architecture description
10438 // instruct movI(eRegI dst, eRegI src) %{
10439 //   match(Set dst (CopyI src));
10440 // %}
10441 //
10442 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10443 //   match(Set dst (AddI dst src));
10444 //   effect(KILL cr);
10445 // %}
10446 //
10447 // // Change (inc mov) to lea
10448 // peephole %{
10449 //   // increment preceeded by register-register move
10450 //   peepmatch (incI_eReg movI);
10451 //   // require that the destination register of the increment
10452 //   // match the destination register of the move
10453 //   peepconstraint (0.dst == 1.dst);
10454 //   // construct a replacement instruction that sets
10455 //   // the destination to (move&#39;s source register + one)
10456 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10457 // %}
10458 //
10459 // Implementation no longer uses movX instructions since
10460 // machine-independent system no longer uses CopyX nodes.
10461 //
10462 // peephole %{
10463 //   peepmatch (incI_eReg movI);
10464 //   peepconstraint (0.dst == 1.dst);
10465 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10466 // %}
10467 //
10468 // peephole %{
10469 //   peepmatch (decI_eReg movI);
10470 //   peepconstraint (0.dst == 1.dst);
10471 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10472 // %}
10473 //
10474 // peephole %{
10475 //   peepmatch (addI_eReg_imm movI);
10476 //   peepconstraint (0.dst == 1.dst);
10477 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10478 // %}
10479 //
10480 // peephole %{
10481 //   peepmatch (addP_eReg_imm movP);
10482 //   peepconstraint (0.dst == 1.dst);
10483 //   peepreplace (leaP_eReg_immI(0.dst 1.src 0.src));
10484 // %}
10485 
10486 
10487 //  This peephole rule does not work, probably because ADLC can&#39;t handle two effects:
10488 //  Effect 1 is defining 0.op1 and effect 2 is setting CC
10489 // condense a load from memory and subsequent test for zero
10490 // into a single, more efficient ICM instruction.
10491 // peephole %{
10492 //   peepmatch (compI_iReg_imm0 loadI);
10493 //   peepconstraint (1.dst == 0.op1);
10494 //   peepreplace (loadtest15_iReg_mem(0.op1 0.op1 1.mem));
10495 // %}
10496 
10497 // // Change load of spilled value to only a spill
10498 // instruct storeI(memory mem, eRegI src) %{
10499 //   match(Set mem (StoreI mem src));
10500 // %}
10501 //
10502 // instruct loadI(eRegI dst, memory mem) %{
10503 //   match(Set dst (LoadI mem));
10504 // %}
10505 //
10506 peephole %{
10507   peepmatch (loadI storeI);
10508   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10509   peepreplace (storeI(1.mem 1.mem 1.src));
10510 %}
10511 
10512 peephole %{
10513   peepmatch (loadL storeL);
10514   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10515   peepreplace (storeL(1.mem 1.mem 1.src));
10516 %}
10517 
10518 peephole %{
10519   peepmatch (loadP storeP);
10520   peepconstraint (1.src == 0.dst, 1.dst == 0.mem);
10521   peepreplace (storeP(1.dst 1.dst 1.src));
10522 %}
10523 
10524 //----------SUPERWORD RULES---------------------------------------------------
10525 
10526 //  Expand rules for special cases
10527 
10528 instruct expand_storeF(stackSlotF mem, regF src) %{
10529   // No match rule, false predicate, for expand only.
10530   effect(DEF mem, USE src);
10531   predicate(false);
10532   ins_cost(MEMORY_REF_COST);
10533   // TODO: s390 port size(FIXED_SIZE);
10534   format %{ &quot;STE      $src,$mem\t # replicate(float2stack)&quot; %}
10535   opcode(STE_ZOPC, STE_ZOPC);
10536   ins_encode(z_form_rt_mem(src, mem));
10537   ins_pipe(pipe_class_dummy);
10538 %}
10539 
10540 instruct expand_LoadLogical_I2L(iRegL dst, stackSlotF mem) %{
10541   // No match rule, false predicate, for expand only.
10542   effect(DEF dst, USE mem);
10543   predicate(false);
10544   ins_cost(MEMORY_REF_COST);
10545   // TODO: s390 port size(FIXED_SIZE);
10546   format %{ &quot;LLGF     $dst,$mem\t # replicate(stack2reg(unsigned))&quot; %}
10547   opcode(LLGF_ZOPC, LLGF_ZOPC);
10548   ins_encode(z_form_rt_mem(dst, mem));
10549   ins_pipe(pipe_class_dummy);
10550 %}
10551 
10552 // Replicate scalar int to packed int values (8 Bytes)
10553 instruct expand_Repl2I_reg(iRegL dst, iRegL src) %{
10554   // Dummy match rule, false predicate, for expand only.
10555   match(Set dst (ConvI2L src));
10556   predicate(false);
10557   ins_cost(DEFAULT_COST);
10558   // TODO: s390 port size(FIXED_SIZE);
10559   format %{ &quot;REPLIC2F $dst,$src\t # replicate(pack2F)&quot; %}
10560   ins_encode %{
10561     if ($dst$$Register == $src$$Register) {
10562       __ z_sllg(Z_R0_scratch, $src$$Register, 64-32);
10563       __ z_ogr($dst$$Register, Z_R0_scratch);
10564     }  else {
10565       __ z_sllg($dst$$Register, $src$$Register, 64-32);
10566       __ z_ogr( $dst$$Register, $src$$Register);
10567     }
10568   %}
10569   ins_pipe(pipe_class_dummy);
10570 %}
10571 
10572 // Replication
10573 
10574 // Exploit rotate_then_insert, if available
10575 // Replicate scalar byte to packed byte values (8 Bytes).
10576 instruct Repl8B_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10577   match(Set dst (ReplicateB src));
10578   effect(KILL cr);
10579   predicate((n-&gt;as_Vector()-&gt;length() == 8));
10580   format %{ &quot;REPLIC8B $dst,$src\t # pack8B&quot; %}
10581   ins_encode %{
10582     if ($dst$$Register != $src$$Register) {
10583       __ z_lgr($dst$$Register, $src$$Register);
10584     }
10585     __ rotate_then_insert($dst$$Register, $dst$$Register, 48, 55,  8, false);
10586     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10587     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10588   %}
10589   ins_pipe(pipe_class_dummy);
10590 %}
10591 
10592 // Replicate scalar byte to packed byte values (8 Bytes).
10593 instruct Repl8B_imm(iRegL dst, immB_n0m1 src) %{
10594   match(Set dst (ReplicateB src));
10595   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10596   ins_should_rematerialize(true);
10597   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm&quot; %}
10598   ins_encode %{
10599     int64_t  Isrc8 = $src$$constant &amp; 0x000000ff;
10600     int64_t Isrc16 =  Isrc8 &lt;&lt;  8 |  Isrc8;
10601     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10602     assert(Isrc8 != 0x000000ff &amp;&amp; Isrc8 != 0, &quot;should be handled by other match rules.&quot;);
10603 
10604     __ z_llilf($dst$$Register, Isrc32);
10605     __ z_iihf($dst$$Register, Isrc32);
10606   %}
10607   ins_pipe(pipe_class_dummy);
10608 %}
10609 
10610 // Replicate scalar byte to packed byte values (8 Bytes).
10611 instruct Repl8B_imm0(iRegL dst, immI_0 src) %{
10612   match(Set dst (ReplicateB src));
10613   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10614   ins_should_rematerialize(true);
10615   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm0&quot; %}
10616   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10617   ins_pipe(pipe_class_dummy);
10618 %}
10619 
10620 // Replicate scalar byte to packed byte values (8 Bytes).
10621 instruct Repl8B_immm1(iRegL dst, immB_minus1 src) %{
10622   match(Set dst (ReplicateB src));
10623   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10624   ins_should_rematerialize(true);
10625   format %{ &quot;REPLIC8B $dst,$src\t # pack8B immm1&quot; %}
10626   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10627   ins_pipe(pipe_class_dummy);
10628 %}
10629 
10630 // Exploit rotate_then_insert, if available
10631 // Replicate scalar short to packed short values (8 Bytes).
10632 instruct Repl4S_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10633   match(Set dst (ReplicateS src));
10634   effect(KILL cr);
10635   predicate((n-&gt;as_Vector()-&gt;length() == 4));
10636   format %{ &quot;REPLIC4S $dst,$src\t # pack4S&quot; %}
10637   ins_encode %{
10638     if ($dst$$Register != $src$$Register) {
10639       __ z_lgr($dst$$Register, $src$$Register);
10640     }
10641     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10642     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10643   %}
10644   ins_pipe(pipe_class_dummy);
10645 %}
10646 
10647 // Replicate scalar short to packed short values (8 Bytes).
10648 instruct Repl4S_imm(iRegL dst, immS_n0m1 src) %{
10649   match(Set dst (ReplicateS src));
10650   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10651   ins_should_rematerialize(true);
10652   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm&quot; %}
10653   ins_encode %{
10654     int64_t Isrc16 = $src$$constant &amp; 0x0000ffff;
10655     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10656     assert(Isrc16 != 0x0000ffff &amp;&amp; Isrc16 != 0, &quot;Repl4S_imm: (src == &quot; INT64_FORMAT
10657            &quot;) should be handled by other match rules.&quot;, $src$$constant);
10658 
10659     __ z_llilf($dst$$Register, Isrc32);
10660     __ z_iihf($dst$$Register, Isrc32);
10661   %}
10662   ins_pipe(pipe_class_dummy);
10663 %}
10664 
10665 // Replicate scalar short to packed short values (8 Bytes).
10666 instruct Repl4S_imm0(iRegL dst, immI_0 src) %{
10667   match(Set dst (ReplicateS src));
10668   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10669   ins_should_rematerialize(true);
10670   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm0&quot; %}
10671   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10672   ins_pipe(pipe_class_dummy);
10673 %}
10674 
10675 // Replicate scalar short to packed short values (8 Bytes).
10676 instruct Repl4S_immm1(iRegL dst, immS_minus1 src) %{
10677   match(Set dst (ReplicateS src));
10678   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10679   ins_should_rematerialize(true);
10680   format %{ &quot;REPLIC4S $dst,$src\t # pack4S immm1&quot; %}
10681   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10682   ins_pipe(pipe_class_dummy);
10683 %}
10684 
10685 // Exploit rotate_then_insert, if available.
10686 // Replicate scalar int to packed int values (8 Bytes).
10687 instruct Repl2I_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10688   match(Set dst (ReplicateI src));
10689   effect(KILL cr);
10690   predicate((n-&gt;as_Vector()-&gt;length() == 2));
10691   format %{ &quot;REPLIC2I $dst,$src\t # pack2I&quot; %}
10692   ins_encode %{
10693     if ($dst$$Register != $src$$Register) {
10694       __ z_lgr($dst$$Register, $src$$Register);
10695     }
10696     __ rotate_then_insert($dst$$Register, $dst$$Register, 0, 31, 32, false);
10697   %}
10698   ins_pipe(pipe_class_dummy);
10699 %}
10700 
10701 // Replicate scalar int to packed int values (8 Bytes).
10702 instruct Repl2I_imm(iRegL dst, immI_n0m1 src) %{
10703   match(Set dst (ReplicateI src));
10704   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10705   ins_should_rematerialize(true);
10706   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm&quot; %}
10707   ins_encode %{
10708     int64_t Isrc32 = $src$$constant;
10709     assert(Isrc32 != -1 &amp;&amp; Isrc32 != 0, &quot;should be handled by other match rules.&quot;);
10710 
10711     __ z_llilf($dst$$Register, Isrc32);
10712     __ z_iihf($dst$$Register, Isrc32);
10713   %}
10714   ins_pipe(pipe_class_dummy);
10715 %}
10716 
10717 // Replicate scalar int to packed int values (8 Bytes).
10718 instruct Repl2I_imm0(iRegL dst, immI_0 src) %{
10719   match(Set dst (ReplicateI src));
10720   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10721   ins_should_rematerialize(true);
10722   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm0&quot; %}
10723   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10724   ins_pipe(pipe_class_dummy);
10725 %}
10726 
10727 // Replicate scalar int to packed int values (8 Bytes).
10728 instruct Repl2I_immm1(iRegL dst, immI_minus1 src) %{
10729   match(Set dst (ReplicateI src));
10730   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10731   ins_should_rematerialize(true);
10732   format %{ &quot;REPLIC2I $dst,$src\t # pack2I immm1&quot; %}
10733   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10734   ins_pipe(pipe_class_dummy);
10735 %}
10736 
10737 //
10738 
10739 instruct Repl2F_reg_indirect(iRegL dst, regF src, flagsReg cr) %{
10740   match(Set dst (ReplicateF src));
10741   effect(KILL cr);
10742   predicate(!VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10743   format %{ &quot;REPLIC2F $dst,$src\t # pack2F indirect&quot; %}
10744   expand %{
10745     stackSlotF tmp;
10746     iRegL      tmp2;
10747     expand_storeF(tmp, src);
10748     expand_LoadLogical_I2L(tmp2, tmp);
10749     expand_Repl2I_reg(dst, tmp2);
10750   %}
10751 %}
10752 
10753 // Replicate scalar float to packed float values in GREG (8 Bytes).
10754 instruct Repl2F_reg_direct(iRegL dst, regF src, flagsReg cr) %{
10755   match(Set dst (ReplicateF src));
10756   effect(KILL cr);
10757   predicate(VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10758   format %{ &quot;REPLIC2F $dst,$src\t # pack2F direct&quot; %}
10759   ins_encode %{
10760     assert(VM_Version::has_FPSupportEnhancements(), &quot;encoder should never be called on old H/W&quot;);
10761     __ z_lgdr($dst$$Register, $src$$FloatRegister);
10762 
10763     __ z_srlg(Z_R0_scratch, $dst$$Register, 32);  // Floats are left-justified in 64bit reg.
10764     __ z_iilf($dst$$Register, 0);                 // Save a &quot;result not ready&quot; stall.
10765     __ z_ogr($dst$$Register, Z_R0_scratch);
10766   %}
10767   ins_pipe(pipe_class_dummy);
10768 %}
10769 
10770 // Replicate scalar float immediate to packed float values in GREG (8 Bytes).
10771 instruct Repl2F_imm(iRegL dst, immF src) %{
10772   match(Set dst (ReplicateF src));
10773   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10774   ins_should_rematerialize(true);
10775   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm&quot; %}
10776   ins_encode %{
10777     union {
10778       int   Isrc32;
10779       float Fsrc32;
10780     };
10781     Fsrc32 = $src$$constant;
10782     __ z_llilf($dst$$Register, Isrc32);
10783     __ z_iihf($dst$$Register, Isrc32);
10784   %}
10785   ins_pipe(pipe_class_dummy);
10786 %}
10787 
10788 // Replicate scalar float immediate zeroes to packed float values in GREG (8 Bytes).
10789 // Do this only for &#39;real&#39; zeroes, especially don&#39;t loose sign of negative zeroes.
10790 instruct Repl2F_imm0(iRegL dst, immFp0 src) %{
10791   match(Set dst (ReplicateF src));
10792   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10793   ins_should_rematerialize(true);
10794   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm0&quot; %}
10795   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10796   ins_pipe(pipe_class_dummy);
10797 %}
10798 
10799 // Store
10800 
10801 // Store Aligned Packed Byte register to memory (8 Bytes).
10802 instruct storeA8B(memory mem, iRegL src) %{
10803   match(Set mem (StoreVector mem src));
10804   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10805   ins_cost(MEMORY_REF_COST);
10806   // TODO: s390 port size(VARIABLE_SIZE);
10807   format %{ &quot;STG     $src,$mem\t # ST(packed8B)&quot; %}
10808   opcode(STG_ZOPC, STG_ZOPC);
10809   ins_encode(z_form_rt_mem_opt(src, mem));
10810   ins_pipe(pipe_class_dummy);
10811 %}
10812 
10813 // Load
10814 
10815 instruct loadV8(iRegL dst, memory mem) %{
10816   match(Set dst (LoadVector mem));
10817   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10818   ins_cost(MEMORY_REF_COST);
10819   // TODO: s390 port size(VARIABLE_SIZE);
10820   format %{ &quot;LG      $dst,$mem\t # L(packed8B)&quot; %}
10821   opcode(LG_ZOPC, LG_ZOPC);
10822   ins_encode(z_form_rt_mem_opt(dst, mem));
10823   ins_pipe(pipe_class_dummy);
10824 %}
10825 
10826 //----------POPULATION COUNT RULES--------------------------------------------
10827 
10828 // Byte reverse
10829 
10830 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
10831   match(Set dst (ReverseBytesI src));
10832   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10833   ins_cost(DEFAULT_COST);
10834   size(4);
10835   format %{ &quot;LRVR    $dst,$src\t # byte reverse int&quot; %}
10836   opcode(LRVR_ZOPC);
10837   ins_encode(z_rreform(dst, src));
10838   ins_pipe(pipe_class_dummy);
10839 %}
10840 
10841 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
10842   match(Set dst (ReverseBytesL src));
10843   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10844   ins_cost(DEFAULT_COST);
10845   // TODO: s390 port size(FIXED_SIZE);
10846   format %{ &quot;LRVGR   $dst,$src\t # byte reverse long&quot; %}
10847   opcode(LRVGR_ZOPC);
10848   ins_encode(z_rreform(dst, src));
10849   ins_pipe(pipe_class_dummy);
10850 %}
10851 
10852 // Leading zeroes
10853 
10854 // The instruction FLOGR (Find Leftmost One in Grande (64bit) Register)
10855 // returns the bit position of the leftmost 1 in the 64bit source register.
10856 // As the bits are numbered from left to right (0..63), the returned
10857 // position index is equivalent to the number of leading zeroes.
10858 // If no 1-bit is found (i.e. the regsiter contains zero), the instruction
10859 // returns position 64. That&#39;s exactly what we need.
10860 
10861 instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10862   match(Set dst (CountLeadingZerosI src));
10863   effect(KILL tmp, KILL cr);
10864   ins_cost(3 * DEFAULT_COST);
10865   size(14);
10866   format %{ &quot;SLLG    $dst,$src,32\t # no need to always count 32 zeroes first\n\t&quot;
10867             &quot;IILH    $dst,0x8000 \t # insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;
10868             &quot;FLOGR   $dst,$dst&quot;
10869          %}
10870   ins_encode %{
10871     // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
10872     // iteration to find the leftmost &quot;1&quot; bit.
10873     //
10874     // The prior implementation zero-extended the 32-bit argument to 64 bit,
10875     // thus forcing &quot;FLOGR&quot; to count 32 bits of which we know they are zero.
10876     // We could gain measurable speedup in micro benchmark:
10877     //
10878     //               leading   trailing
10879     //   z10:   int     2.04       1.68
10880     //         long     1.00       1.02
10881     //   z196:  int     0.99       1.23
10882     //         long     1.00       1.11
10883     //
10884     // By shifting the argument into the high-word instead of zero-extending it.
10885     // The add&#39;l branch on condition (taken for a zero argument, very infrequent,
10886     // good prediction) is well compensated for by the savings.
10887     //
10888     // We leave the previous implementation in for some time in the future when
10889     // the &quot;FLOGR&quot; instruction may become less iterative.
10890 
10891     // Version 2: shows 62%(z9), 204%(z10), -1%(z196) improvement over original
10892     __ z_sllg($dst$$Register, $src$$Register, 32); // No need to always count 32 zeroes first.
10893     __ z_iilh($dst$$Register, 0x8000);   // Insert &quot;stop bit&quot; to force result 32 for zero src.
10894     __ z_flogr($dst$$Register, $dst$$Register);
10895   %}
10896   ins_pipe(pipe_class_dummy);
10897 %}
10898 
10899 instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
10900   match(Set dst (CountLeadingZerosL src));
10901   effect(KILL tmp, KILL cr);
10902   ins_cost(DEFAULT_COST);
10903   size(4);
10904   format %{ &quot;FLOGR   $dst,$src \t # count leading zeros (long)\n\t&quot; %}
10905   ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
10906   ins_pipe(pipe_class_dummy);
10907 %}
10908 
10909 // trailing zeroes
10910 
10911 // We transform the trailing zeroes problem to a leading zeroes problem
10912 // such that can use the FLOGR instruction to our advantage.
10913 
10914 // With
10915 //   tmp1 = src - 1
10916 // we flip all trailing zeroes to ones and the rightmost one to zero.
10917 // All other bits remain unchanged.
10918 // With the complement
10919 //   tmp2 = ~src
10920 // we get all ones in the trailing zeroes positions. Thus,
10921 //   tmp3 = tmp1 &amp; tmp2
10922 // yields ones in the trailing zeroes positions and zeroes elsewhere.
10923 // Now we can apply FLOGR and get 64-(trailing zeroes).
10924 instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10925   match(Set dst (CountTrailingZerosI src));
10926   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10927   ins_cost(8 * DEFAULT_COST);
10928   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10929   format %{ &quot;LLGFR   $dst,$src  \t # clear upper 32 bits (we are dealing with int)\n\t&quot;
10930             &quot;LCGFR   $tmp,$src  \t # load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;
10931             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10932             &quot;AGHI    $tmp,-1    \t # tmp2 = -src-1 = ~src\n\t&quot;
10933             &quot;NGR     $dst,$tmp  \t # tmp3 = tmp1&amp;tmp2\n\t&quot;
10934             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (int)\n\t&quot;
10935             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10936             &quot;LCR     $dst,$dst  \t # res = -tmp4&quot;
10937          %}
10938   ins_encode %{
10939     Register Rdst = $dst$$Register;
10940     Register Rsrc = $src$$Register;
10941     // Rtmp only needed for for zero-argument shortcut. With kill effect in
10942     // match rule Rsrc = roddReg would be possible, saving one register.
10943     Register Rtmp = $tmp$$Register;
10944 
10945     assert_different_registers(Rdst, Rsrc, Rtmp);
10946 
10947     // Algorithm:
10948     // - Isolate the least significant (rightmost) set bit using (src &amp; (-src)).
10949     //   All other bits in the result are zero.
10950     // - Find the &quot;leftmost one&quot; bit position in the single-bit result from previous step.
10951     // - 63-(&quot;leftmost one&quot; bit position) gives the # of trailing zeros.
10952 
10953     // Version 2: shows 79%(z9), 68%(z10), 23%(z196) improvement over original.
10954     Label done;
10955     __ load_const_optimized(Rdst, 32); // Prepare for shortcut (zero argument), result will be 32.
10956     __ z_lcgfr(Rtmp, Rsrc);
10957     __ z_bre(done);                    // Taken very infrequently, good prediction, no BHT entry.
10958 
10959     __ z_nr(Rtmp, Rsrc);               // (src) &amp; (-src) leaves nothing but least significant bit.
10960     __ z_ahi(Rtmp,  -1);               // Subtract one to fill all trailing zero positions with ones.
10961                                        // Use 32bit op to prevent borrow propagation (case Rdst = 0x80000000)
10962                                        // into upper half of reg. Not relevant with sllg below.
10963     __ z_sllg(Rdst, Rtmp, 32);         // Shift interesting contents to upper half of register.
10964     __ z_bre(done);                    // Shortcut for argument = 1, result will be 0.
10965                                        // Depends on CC set by ahi above.
10966                                        // Taken very infrequently, good prediction, no BHT entry.
10967                                        // Branch delayed to have Rdst set correctly (Rtmp == 0(32bit)
10968                                        // after SLLG Rdst == 0(64bit)).
10969     __ z_flogr(Rdst, Rdst);            // Kills tmp which is the oddReg for dst.
10970     __ add2reg(Rdst,  -32);            // 32-pos(leftmost1) is #trailing zeros
10971     __ z_lcgfr(Rdst, Rdst);            // Provide 64bit result at no cost.
10972     __ bind(done);
10973   %}
10974   ins_pipe(pipe_class_dummy);
10975 %}
10976 
10977 instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
10978   match(Set dst (CountTrailingZerosL src));
10979   effect(TEMP_DEF dst, KILL tmp, KILL cr);
10980   ins_cost(8 * DEFAULT_COST);
10981   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10982   format %{ &quot;LCGR    $dst,$src  \t # preserve src\n\t&quot;
10983             &quot;NGR     $dst,$src  \t #\n\t&quot;
10984             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10985             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (long), kill $tmp\n\t&quot;
10986             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10987             &quot;LCR     $dst,$dst  \t #&quot;
10988          %}
10989   ins_encode %{
10990     Register Rdst = $dst$$Register;
10991     Register Rsrc = $src$$Register;
10992     assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
10993 
10994     // New version: shows 5%(z9), 2%(z10), 11%(z196) improvement over original.
10995     __ z_lcgr(Rdst, Rsrc);
10996     __ z_ngr(Rdst, Rsrc);
10997     __ add2reg(Rdst,   -1);
10998     __ z_flogr(Rdst, Rdst); // Kills tmp which is the oddReg for dst.
10999     __ add2reg(Rdst,  -64);
11000     __ z_lcgfr(Rdst, Rdst); // Provide 64bit result at no cost.
11001   %}
11002   ins_pipe(pipe_class_dummy);
11003 %}
11004 
11005 
11006 // bit count
11007 
11008 instruct popCountI(iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
11009   match(Set dst (PopCountI src));
11010   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11011   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11012   ins_cost(DEFAULT_COST);
11013   size(24);
11014   format %{ &quot;POPCNT  $dst,$src\t # pop count int&quot; %}
11015   ins_encode %{
11016     Register Rdst = $dst$$Register;
11017     Register Rsrc = $src$$Register;
11018     Register Rtmp = $tmp$$Register;
11019 
11020     // Prefer compile-time assertion over run-time SIGILL.
11021     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11022     assert_different_registers(Rdst, Rtmp);
11023 
11024     // Version 2: shows 10%(z196) improvement over original.
11025     __ z_popcnt(Rdst, Rsrc);
11026     __ z_srlg(Rtmp, Rdst, 16); // calc  byte4+byte6 and byte5+byte7
11027     __ z_alr(Rdst, Rtmp);      //   into byte6 and byte7
11028     __ z_srlg(Rtmp, Rdst,  8); // calc (byte4+byte6) + (byte5+byte7)
11029     __ z_alr(Rdst, Rtmp);      //   into byte7
11030     __ z_llgcr(Rdst, Rdst);    // zero-extend sum
11031   %}
11032   ins_pipe(pipe_class_dummy);
11033 %}
11034 
11035 instruct popCountL(iRegI dst, iRegL src, iRegL tmp, flagsReg cr) %{
11036   match(Set dst (PopCountL src));
11037   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11038   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11039   ins_cost(DEFAULT_COST);
11040   // TODO: s390 port size(FIXED_SIZE);
11041   format %{ &quot;POPCNT  $dst,$src\t # pop count long&quot; %}
11042   ins_encode %{
11043     Register Rdst = $dst$$Register;
11044     Register Rsrc = $src$$Register;
11045     Register Rtmp = $tmp$$Register;
11046 
11047     // Prefer compile-time assertion over run-time SIGILL.
11048     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11049     assert_different_registers(Rdst, Rtmp);
11050 
11051     // Original version. Using LA instead of algr seems to be a really bad idea (-35%).
11052     __ z_popcnt(Rdst, Rsrc);
11053     __ z_ahhlr(Rdst, Rdst, Rdst);
11054     __ z_sllg(Rtmp, Rdst, 16);
11055     __ z_algr(Rdst, Rtmp);
11056     __ z_sllg(Rtmp, Rdst,  8);
11057     __ z_algr(Rdst, Rtmp);
11058     __ z_srlg(Rdst, Rdst, 56);
11059   %}
11060   ins_pipe(pipe_class_dummy);
11061 %}
11062 
11063 //----------SMARTSPILL RULES---------------------------------------------------
11064 // These must follow all instruction definitions as they use the names
11065 // defined in the instructions definitions.
11066 
11067 // ============================================================================
11068 // TYPE PROFILING RULES
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ppc/vm_version_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;nativeInst_s390.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;

  42 #include &quot;vmreg_s390.inline.hpp&quot;
  43 
  44 #define __ _masm-&gt;
  45 
  46 #ifndef PRODUCT
  47 #undef __
  48 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm) : _masm)-&gt;
  49 #endif
  50 
  51 //------------------------------------------------------------
  52 
  53 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  54   // Not used on ZARCH_64
  55   ShouldNotCallThis();
  56   return false;
  57 }
  58 
  59 LIR_Opr LIR_Assembler::receiverOpr() {
  60   return FrameMap::Z_R2_oop_opr;
  61 }
</pre>
<hr />
<pre>
1781           __ z_ogr(l_lo, r_lo);
1782           break;
1783         case lir_logic_xor:
1784           __ z_xgr(l_lo, r_lo);
1785           break;
1786         default: ShouldNotReachHere();
1787       }
1788     }
1789 
1790     Register dst_lo = dst-&gt;as_register_lo();
1791 
1792     move_regs(l_lo, dst_lo);
1793   }
1794 }
1795 
1796 // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
1797 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
1798   if (left-&gt;is_double_cpu()) {
1799     // 64 bit integer case
1800     assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
<span class="line-modified">1801     assert(right-&gt;is_double_cpu() || is_power_of_2_long(right-&gt;as_jlong()),</span>
1802            &quot;right must be register or power of 2 constant&quot;);
1803     assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
1804 
1805     Register lreg = left-&gt;as_register_lo();
1806     Register dreg = result-&gt;as_register_lo();
1807 
1808     if (right-&gt;is_constant()) {
1809       // Convert division by a power of two into some shifts and logical operations.
1810       Register treg1 = Z_R0_scratch;
1811       Register treg2 = Z_R1_scratch;
1812       jlong divisor = right-&gt;as_jlong();
1813       jlong log_divisor = log2_long(right-&gt;as_jlong());
1814 
1815       if (divisor == min_jlong) {
1816         // Min_jlong is special. Result is &#39;0&#39; except for min_jlong/min_jlong = 1.
1817         if (dreg == lreg) {
1818           NearLabel done;
1819           __ load_const_optimized(treg2, min_jlong);
1820           __ z_cgr(lreg, treg2);
1821           __ z_lghi(dreg, 0);           // Preserves condition code.
</pre>
</td>
<td>
<hr />
<pre>
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;nativeInst_s390.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 #include &quot;vmreg_s390.inline.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 #ifndef PRODUCT
  48 #undef __
  49 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm) : _masm)-&gt;
  50 #endif
  51 
  52 //------------------------------------------------------------
  53 
  54 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  55   // Not used on ZARCH_64
  56   ShouldNotCallThis();
  57   return false;
  58 }
  59 
  60 LIR_Opr LIR_Assembler::receiverOpr() {
  61   return FrameMap::Z_R2_oop_opr;
  62 }
</pre>
<hr />
<pre>
1782           __ z_ogr(l_lo, r_lo);
1783           break;
1784         case lir_logic_xor:
1785           __ z_xgr(l_lo, r_lo);
1786           break;
1787         default: ShouldNotReachHere();
1788       }
1789     }
1790 
1791     Register dst_lo = dst-&gt;as_register_lo();
1792 
1793     move_regs(l_lo, dst_lo);
1794   }
1795 }
1796 
1797 // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
1798 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
1799   if (left-&gt;is_double_cpu()) {
1800     // 64 bit integer case
1801     assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
<span class="line-modified">1802     assert(right-&gt;is_double_cpu() || is_power_of_2(right-&gt;as_jlong()),</span>
1803            &quot;right must be register or power of 2 constant&quot;);
1804     assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
1805 
1806     Register lreg = left-&gt;as_register_lo();
1807     Register dreg = result-&gt;as_register_lo();
1808 
1809     if (right-&gt;is_constant()) {
1810       // Convert division by a power of two into some shifts and logical operations.
1811       Register treg1 = Z_R0_scratch;
1812       Register treg2 = Z_R1_scratch;
1813       jlong divisor = right-&gt;as_jlong();
1814       jlong log_divisor = log2_long(right-&gt;as_jlong());
1815 
1816       if (divisor == min_jlong) {
1817         // Min_jlong is special. Result is &#39;0&#39; except for min_jlong/min_jlong = 1.
1818         if (dreg == lreg) {
1819           NearLabel done;
1820           __ load_const_optimized(treg2, min_jlong);
1821           __ z_cgr(lreg, treg2);
1822           __ z_lghi(dreg, 0);           // Preserves condition code.
</pre>
</td>
</tr>
</table>
<center><a href="../ppc/vm_version_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
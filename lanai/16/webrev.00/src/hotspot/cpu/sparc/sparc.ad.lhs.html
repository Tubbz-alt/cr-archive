<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // SPARC Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 register %{
   32 //----------Architecture Description Register Definitions----------------------
   33 // General Registers
   34 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   35 //                   ideal register type, encoding, vm name );
   36 // Register Save Types:
   37 //
   38 // NS  = No-Save:       The register allocator assumes that these registers
   39 //                      can be used without saving upon entry to the method, &amp;
   40 //                      that they do not need to be saved at call sites.
   41 //
   42 // SOC = Save-On-Call:  The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method,
   44 //                      but that they must be saved at call sites.
   45 //
   46 // SOE = Save-On-Entry: The register allocator assumes that these registers
   47 //                      must be saved before using them upon entry to the
   48 //                      method, but they do not need to be saved at call
   49 //                      sites.
   50 //
   51 // AS  = Always-Save:   The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, &amp; that they must be saved at call sites.
   54 //
   55 // Ideal Register Type is used to determine how to save &amp; restore a
   56 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   57 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   58 //
   59 // The encoding number is the actual bit-pattern placed into the opcodes.
   60 
   61 
   62 // ----------------------------
   63 // Integer/Long Registers
   64 // ----------------------------
   65 
   66 // Need to expose the hi/lo aspect of 64-bit registers
   67 // This register set is used for both the 64-bit build and
   68 // the 32-bit build with 1-register longs.
   69 
   70 // Global Registers 0-7
   71 reg_def R_G0H( NS,  NS, Op_RegI,128, G0-&gt;as_VMReg()-&gt;next());
   72 reg_def R_G0 ( NS,  NS, Op_RegI,  0, G0-&gt;as_VMReg());
   73 reg_def R_G1H(SOC, SOC, Op_RegI,129, G1-&gt;as_VMReg()-&gt;next());
   74 reg_def R_G1 (SOC, SOC, Op_RegI,  1, G1-&gt;as_VMReg());
   75 reg_def R_G2H( NS,  NS, Op_RegI,130, G2-&gt;as_VMReg()-&gt;next());
   76 reg_def R_G2 ( NS,  NS, Op_RegI,  2, G2-&gt;as_VMReg());
   77 reg_def R_G3H(SOC, SOC, Op_RegI,131, G3-&gt;as_VMReg()-&gt;next());
   78 reg_def R_G3 (SOC, SOC, Op_RegI,  3, G3-&gt;as_VMReg());
   79 reg_def R_G4H(SOC, SOC, Op_RegI,132, G4-&gt;as_VMReg()-&gt;next());
   80 reg_def R_G4 (SOC, SOC, Op_RegI,  4, G4-&gt;as_VMReg());
   81 reg_def R_G5H(SOC, SOC, Op_RegI,133, G5-&gt;as_VMReg()-&gt;next());
   82 reg_def R_G5 (SOC, SOC, Op_RegI,  5, G5-&gt;as_VMReg());
   83 reg_def R_G6H( NS,  NS, Op_RegI,134, G6-&gt;as_VMReg()-&gt;next());
   84 reg_def R_G6 ( NS,  NS, Op_RegI,  6, G6-&gt;as_VMReg());
   85 reg_def R_G7H( NS,  NS, Op_RegI,135, G7-&gt;as_VMReg()-&gt;next());
   86 reg_def R_G7 ( NS,  NS, Op_RegI,  7, G7-&gt;as_VMReg());
   87 
   88 // Output Registers 0-7
   89 reg_def R_O0H(SOC, SOC, Op_RegI,136, O0-&gt;as_VMReg()-&gt;next());
   90 reg_def R_O0 (SOC, SOC, Op_RegI,  8, O0-&gt;as_VMReg());
   91 reg_def R_O1H(SOC, SOC, Op_RegI,137, O1-&gt;as_VMReg()-&gt;next());
   92 reg_def R_O1 (SOC, SOC, Op_RegI,  9, O1-&gt;as_VMReg());
   93 reg_def R_O2H(SOC, SOC, Op_RegI,138, O2-&gt;as_VMReg()-&gt;next());
   94 reg_def R_O2 (SOC, SOC, Op_RegI, 10, O2-&gt;as_VMReg());
   95 reg_def R_O3H(SOC, SOC, Op_RegI,139, O3-&gt;as_VMReg()-&gt;next());
   96 reg_def R_O3 (SOC, SOC, Op_RegI, 11, O3-&gt;as_VMReg());
   97 reg_def R_O4H(SOC, SOC, Op_RegI,140, O4-&gt;as_VMReg()-&gt;next());
   98 reg_def R_O4 (SOC, SOC, Op_RegI, 12, O4-&gt;as_VMReg());
   99 reg_def R_O5H(SOC, SOC, Op_RegI,141, O5-&gt;as_VMReg()-&gt;next());
  100 reg_def R_O5 (SOC, SOC, Op_RegI, 13, O5-&gt;as_VMReg());
  101 reg_def R_SPH( NS,  NS, Op_RegI,142, SP-&gt;as_VMReg()-&gt;next());
  102 reg_def R_SP ( NS,  NS, Op_RegI, 14, SP-&gt;as_VMReg());
  103 reg_def R_O7H(SOC, SOC, Op_RegI,143, O7-&gt;as_VMReg()-&gt;next());
  104 reg_def R_O7 (SOC, SOC, Op_RegI, 15, O7-&gt;as_VMReg());
  105 
  106 // Local Registers 0-7
  107 reg_def R_L0H( NS,  NS, Op_RegI,144, L0-&gt;as_VMReg()-&gt;next());
  108 reg_def R_L0 ( NS,  NS, Op_RegI, 16, L0-&gt;as_VMReg());
  109 reg_def R_L1H( NS,  NS, Op_RegI,145, L1-&gt;as_VMReg()-&gt;next());
  110 reg_def R_L1 ( NS,  NS, Op_RegI, 17, L1-&gt;as_VMReg());
  111 reg_def R_L2H( NS,  NS, Op_RegI,146, L2-&gt;as_VMReg()-&gt;next());
  112 reg_def R_L2 ( NS,  NS, Op_RegI, 18, L2-&gt;as_VMReg());
  113 reg_def R_L3H( NS,  NS, Op_RegI,147, L3-&gt;as_VMReg()-&gt;next());
  114 reg_def R_L3 ( NS,  NS, Op_RegI, 19, L3-&gt;as_VMReg());
  115 reg_def R_L4H( NS,  NS, Op_RegI,148, L4-&gt;as_VMReg()-&gt;next());
  116 reg_def R_L4 ( NS,  NS, Op_RegI, 20, L4-&gt;as_VMReg());
  117 reg_def R_L5H( NS,  NS, Op_RegI,149, L5-&gt;as_VMReg()-&gt;next());
  118 reg_def R_L5 ( NS,  NS, Op_RegI, 21, L5-&gt;as_VMReg());
  119 reg_def R_L6H( NS,  NS, Op_RegI,150, L6-&gt;as_VMReg()-&gt;next());
  120 reg_def R_L6 ( NS,  NS, Op_RegI, 22, L6-&gt;as_VMReg());
  121 reg_def R_L7H( NS,  NS, Op_RegI,151, L7-&gt;as_VMReg()-&gt;next());
  122 reg_def R_L7 ( NS,  NS, Op_RegI, 23, L7-&gt;as_VMReg());
  123 
  124 // Input Registers 0-7
  125 reg_def R_I0H( NS,  NS, Op_RegI,152, I0-&gt;as_VMReg()-&gt;next());
  126 reg_def R_I0 ( NS,  NS, Op_RegI, 24, I0-&gt;as_VMReg());
  127 reg_def R_I1H( NS,  NS, Op_RegI,153, I1-&gt;as_VMReg()-&gt;next());
  128 reg_def R_I1 ( NS,  NS, Op_RegI, 25, I1-&gt;as_VMReg());
  129 reg_def R_I2H( NS,  NS, Op_RegI,154, I2-&gt;as_VMReg()-&gt;next());
  130 reg_def R_I2 ( NS,  NS, Op_RegI, 26, I2-&gt;as_VMReg());
  131 reg_def R_I3H( NS,  NS, Op_RegI,155, I3-&gt;as_VMReg()-&gt;next());
  132 reg_def R_I3 ( NS,  NS, Op_RegI, 27, I3-&gt;as_VMReg());
  133 reg_def R_I4H( NS,  NS, Op_RegI,156, I4-&gt;as_VMReg()-&gt;next());
  134 reg_def R_I4 ( NS,  NS, Op_RegI, 28, I4-&gt;as_VMReg());
  135 reg_def R_I5H( NS,  NS, Op_RegI,157, I5-&gt;as_VMReg()-&gt;next());
  136 reg_def R_I5 ( NS,  NS, Op_RegI, 29, I5-&gt;as_VMReg());
  137 reg_def R_FPH( NS,  NS, Op_RegI,158, FP-&gt;as_VMReg()-&gt;next());
  138 reg_def R_FP ( NS,  NS, Op_RegI, 30, FP-&gt;as_VMReg());
  139 reg_def R_I7H( NS,  NS, Op_RegI,159, I7-&gt;as_VMReg()-&gt;next());
  140 reg_def R_I7 ( NS,  NS, Op_RegI, 31, I7-&gt;as_VMReg());
  141 
  142 // ----------------------------
  143 // Float/Double Registers
  144 // ----------------------------
  145 
  146 // Float Registers
  147 reg_def R_F0 ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg());
  148 reg_def R_F1 ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg());
  149 reg_def R_F2 ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg());
  150 reg_def R_F3 ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg());
  151 reg_def R_F4 ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg());
  152 reg_def R_F5 ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg());
  153 reg_def R_F6 ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg());
  154 reg_def R_F7 ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg());
  155 reg_def R_F8 ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg());
  156 reg_def R_F9 ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg());
  157 reg_def R_F10( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg());
  158 reg_def R_F11( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg());
  159 reg_def R_F12( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg());
  160 reg_def R_F13( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg());
  161 reg_def R_F14( SOC, SOC, Op_RegF, 14, F14-&gt;as_VMReg());
  162 reg_def R_F15( SOC, SOC, Op_RegF, 15, F15-&gt;as_VMReg());
  163 reg_def R_F16( SOC, SOC, Op_RegF, 16, F16-&gt;as_VMReg());
  164 reg_def R_F17( SOC, SOC, Op_RegF, 17, F17-&gt;as_VMReg());
  165 reg_def R_F18( SOC, SOC, Op_RegF, 18, F18-&gt;as_VMReg());
  166 reg_def R_F19( SOC, SOC, Op_RegF, 19, F19-&gt;as_VMReg());
  167 reg_def R_F20( SOC, SOC, Op_RegF, 20, F20-&gt;as_VMReg());
  168 reg_def R_F21( SOC, SOC, Op_RegF, 21, F21-&gt;as_VMReg());
  169 reg_def R_F22( SOC, SOC, Op_RegF, 22, F22-&gt;as_VMReg());
  170 reg_def R_F23( SOC, SOC, Op_RegF, 23, F23-&gt;as_VMReg());
  171 reg_def R_F24( SOC, SOC, Op_RegF, 24, F24-&gt;as_VMReg());
  172 reg_def R_F25( SOC, SOC, Op_RegF, 25, F25-&gt;as_VMReg());
  173 reg_def R_F26( SOC, SOC, Op_RegF, 26, F26-&gt;as_VMReg());
  174 reg_def R_F27( SOC, SOC, Op_RegF, 27, F27-&gt;as_VMReg());
  175 reg_def R_F28( SOC, SOC, Op_RegF, 28, F28-&gt;as_VMReg());
  176 reg_def R_F29( SOC, SOC, Op_RegF, 29, F29-&gt;as_VMReg());
  177 reg_def R_F30( SOC, SOC, Op_RegF, 30, F30-&gt;as_VMReg());
  178 reg_def R_F31( SOC, SOC, Op_RegF, 31, F31-&gt;as_VMReg());
  179 
  180 // Double Registers
  181 // The rules of ADL require that double registers be defined in pairs.
  182 // Each pair must be two 32-bit values, but not necessarily a pair of
  183 // single float registers.  In each pair, ADLC-assigned register numbers
  184 // must be adjacent, with the lower number even.  Finally, when the
  185 // CPU stores such a register pair to memory, the word associated with
  186 // the lower ADLC-assigned number must be stored to the lower address.
  187 
  188 // These definitions specify the actual bit encodings of the sparc
  189 // double fp register numbers.  FloatRegisterImpl in register_sparc.hpp
  190 // wants 0-63, so we have to convert every time we want to use fp regs
  191 // with the macroassembler, using reg_to_DoubleFloatRegister_object().
  192 // 255 is a flag meaning &quot;don&#39;t go here&quot;.
  193 // I believe we can&#39;t handle callee-save doubles D32 and up until
  194 // the place in the sparc stack crawler that asserts on the 255 is
  195 // fixed up.
  196 reg_def R_D32 (SOC, SOC, Op_RegD,  1, F32-&gt;as_VMReg());
  197 reg_def R_D32x(SOC, SOC, Op_RegD,255, F32-&gt;as_VMReg()-&gt;next());
  198 reg_def R_D34 (SOC, SOC, Op_RegD,  3, F34-&gt;as_VMReg());
  199 reg_def R_D34x(SOC, SOC, Op_RegD,255, F34-&gt;as_VMReg()-&gt;next());
  200 reg_def R_D36 (SOC, SOC, Op_RegD,  5, F36-&gt;as_VMReg());
  201 reg_def R_D36x(SOC, SOC, Op_RegD,255, F36-&gt;as_VMReg()-&gt;next());
  202 reg_def R_D38 (SOC, SOC, Op_RegD,  7, F38-&gt;as_VMReg());
  203 reg_def R_D38x(SOC, SOC, Op_RegD,255, F38-&gt;as_VMReg()-&gt;next());
  204 reg_def R_D40 (SOC, SOC, Op_RegD,  9, F40-&gt;as_VMReg());
  205 reg_def R_D40x(SOC, SOC, Op_RegD,255, F40-&gt;as_VMReg()-&gt;next());
  206 reg_def R_D42 (SOC, SOC, Op_RegD, 11, F42-&gt;as_VMReg());
  207 reg_def R_D42x(SOC, SOC, Op_RegD,255, F42-&gt;as_VMReg()-&gt;next());
  208 reg_def R_D44 (SOC, SOC, Op_RegD, 13, F44-&gt;as_VMReg());
  209 reg_def R_D44x(SOC, SOC, Op_RegD,255, F44-&gt;as_VMReg()-&gt;next());
  210 reg_def R_D46 (SOC, SOC, Op_RegD, 15, F46-&gt;as_VMReg());
  211 reg_def R_D46x(SOC, SOC, Op_RegD,255, F46-&gt;as_VMReg()-&gt;next());
  212 reg_def R_D48 (SOC, SOC, Op_RegD, 17, F48-&gt;as_VMReg());
  213 reg_def R_D48x(SOC, SOC, Op_RegD,255, F48-&gt;as_VMReg()-&gt;next());
  214 reg_def R_D50 (SOC, SOC, Op_RegD, 19, F50-&gt;as_VMReg());
  215 reg_def R_D50x(SOC, SOC, Op_RegD,255, F50-&gt;as_VMReg()-&gt;next());
  216 reg_def R_D52 (SOC, SOC, Op_RegD, 21, F52-&gt;as_VMReg());
  217 reg_def R_D52x(SOC, SOC, Op_RegD,255, F52-&gt;as_VMReg()-&gt;next());
  218 reg_def R_D54 (SOC, SOC, Op_RegD, 23, F54-&gt;as_VMReg());
  219 reg_def R_D54x(SOC, SOC, Op_RegD,255, F54-&gt;as_VMReg()-&gt;next());
  220 reg_def R_D56 (SOC, SOC, Op_RegD, 25, F56-&gt;as_VMReg());
  221 reg_def R_D56x(SOC, SOC, Op_RegD,255, F56-&gt;as_VMReg()-&gt;next());
  222 reg_def R_D58 (SOC, SOC, Op_RegD, 27, F58-&gt;as_VMReg());
  223 reg_def R_D58x(SOC, SOC, Op_RegD,255, F58-&gt;as_VMReg()-&gt;next());
  224 reg_def R_D60 (SOC, SOC, Op_RegD, 29, F60-&gt;as_VMReg());
  225 reg_def R_D60x(SOC, SOC, Op_RegD,255, F60-&gt;as_VMReg()-&gt;next());
  226 reg_def R_D62 (SOC, SOC, Op_RegD, 31, F62-&gt;as_VMReg());
  227 reg_def R_D62x(SOC, SOC, Op_RegD,255, F62-&gt;as_VMReg()-&gt;next());
  228 
  229 
  230 // ----------------------------
  231 // Special Registers
  232 // Condition Codes Flag Registers
  233 // I tried to break out ICC and XCC but it&#39;s not very pretty.
  234 // Every Sparc instruction which defs/kills one also kills the other.
  235 // Hence every compare instruction which defs one kind of flags ends
  236 // up needing a kill of the other.
  237 reg_def CCR (SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  238 
  239 reg_def FCC0(SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  240 reg_def FCC1(SOC, SOC,  Op_RegFlags, 1, VMRegImpl::Bad());
  241 reg_def FCC2(SOC, SOC,  Op_RegFlags, 2, VMRegImpl::Bad());
  242 reg_def FCC3(SOC, SOC,  Op_RegFlags, 3, VMRegImpl::Bad());
  243 
  244 // ----------------------------
  245 // Specify the enum values for the registers.  These enums are only used by the
  246 // OptoReg &quot;class&quot;. We can convert these enum values at will to VMReg when needed
  247 // for visibility to the rest of the vm. The order of this enum influences the
  248 // register allocator so having the freedom to set this order and not be stuck
  249 // with the order that is natural for the rest of the vm is worth it.
  250 alloc_class chunk0(
  251   R_L0,R_L0H, R_L1,R_L1H, R_L2,R_L2H, R_L3,R_L3H, R_L4,R_L4H, R_L5,R_L5H, R_L6,R_L6H, R_L7,R_L7H,
  252   R_G0,R_G0H, R_G1,R_G1H, R_G2,R_G2H, R_G3,R_G3H, R_G4,R_G4H, R_G5,R_G5H, R_G6,R_G6H, R_G7,R_G7H,
  253   R_O7,R_O7H, R_SP,R_SPH, R_O0,R_O0H, R_O1,R_O1H, R_O2,R_O2H, R_O3,R_O3H, R_O4,R_O4H, R_O5,R_O5H,
  254   R_I0,R_I0H, R_I1,R_I1H, R_I2,R_I2H, R_I3,R_I3H, R_I4,R_I4H, R_I5,R_I5H, R_FP,R_FPH, R_I7,R_I7H);
  255 
  256 // Note that a register is not allocatable unless it is also mentioned
  257 // in a widely-used reg_class below.  Thus, R_G7 and R_G0 are outside i_reg.
  258 
  259 alloc_class chunk1(
  260   // The first registers listed here are those most likely to be used
  261   // as temporaries.  We move F0..F7 away from the front of the list,
  262   // to reduce the likelihood of interferences with parameters and
  263   // return values.  Likewise, we avoid using F0/F1 for parameters,
  264   // since they are used for return values.
  265   // This FPU fine-tuning is worth about 1% on the SPEC geomean.
  266   R_F8 ,R_F9 ,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  267   R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,
  268   R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,R_F30,R_F31,
  269   R_F0 ,R_F1 ,R_F2 ,R_F3 ,R_F4 ,R_F5 ,R_F6 ,R_F7 , // used for arguments and return values
  270   R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,
  271   R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  272   R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,
  273   R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x);
  274 
  275 alloc_class chunk2(CCR, FCC0, FCC1, FCC2, FCC3);
  276 
  277 //----------Architecture Description Register Classes--------------------------
  278 // Several register classes are automatically defined based upon information in
  279 // this architecture description.
  280 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  281 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  282 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  283 //
  284 
  285 // G0 is not included in integer class since it has special meaning.
  286 reg_class g0_reg(R_G0);
  287 
  288 // ----------------------------
  289 // Integer Register Classes
  290 // ----------------------------
  291 // Exclusions from i_reg:
  292 // R_G0: hardwired zero
  293 // R_G2: reserved by HotSpot to the TLS register (invariant within Java)
  294 // R_G6: reserved by Solaris ABI to tools
  295 // R_G7: reserved by Solaris ABI to libthread
  296 // R_O7: Used as a temp in many encodings
  297 reg_class int_reg(R_G1,R_G3,R_G4,R_G5,R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  298 
  299 // Class for all integer registers, except the G registers.  This is used for
  300 // encodings which use G registers as temps.  The regular inputs to such
  301 // instructions use a &quot;notemp_&quot; prefix, as a hack to ensure that the allocator
  302 // will not put an input into a temp register.
  303 reg_class notemp_int_reg(R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  304 
  305 reg_class g1_regI(R_G1);
  306 reg_class g3_regI(R_G3);
  307 reg_class g4_regI(R_G4);
  308 reg_class o0_regI(R_O0);
  309 reg_class o7_regI(R_O7);
  310 
  311 // ----------------------------
  312 // Pointer Register Classes
  313 // ----------------------------
  314 // 64-bit build means 64-bit pointers means hi/lo pairs
  315 reg_class ptr_reg(            R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  316                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  317                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  318                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  319 // Lock encodings use G3 and G4 internally
  320 reg_class lock_ptr_reg(       R_G1H,R_G1,                                     R_G5H,R_G5,
  321                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  322                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  323                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  324 // Special class for storeP instructions, which can store SP or RPC to TLS.
  325 // It is also used for memory addressing, allowing direct TLS addressing.
  326 reg_class sp_ptr_reg(         R_G1H,R_G1, R_G2H,R_G2, R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  327                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5, R_SPH,R_SP,
  328                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  329                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5, R_FPH,R_FP );
  330 // R_L7 is the lowest-priority callee-save (i.e., NS) register
  331 // We use it to save R_G2 across calls out of Java.
  332 reg_class l7_regP(R_L7H,R_L7);
  333 
  334 // Other special pointer regs
  335 reg_class g1_regP(R_G1H,R_G1);
  336 reg_class g2_regP(R_G2H,R_G2);
  337 reg_class g3_regP(R_G3H,R_G3);
  338 reg_class g4_regP(R_G4H,R_G4);
  339 reg_class g5_regP(R_G5H,R_G5);
  340 reg_class i0_regP(R_I0H,R_I0);
  341 reg_class o0_regP(R_O0H,R_O0);
  342 reg_class o1_regP(R_O1H,R_O1);
  343 reg_class o2_regP(R_O2H,R_O2);
  344 reg_class o7_regP(R_O7H,R_O7);
  345 
  346 
  347 // ----------------------------
  348 // Long Register Classes
  349 // ----------------------------
  350 // Longs in 1 register.  Aligned adjacent hi/lo pairs.
  351 // Note:  O7 is never in this class; it is sometimes used as an encoding temp.
  352 reg_class long_reg(             R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5
  353                    ,R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5
  354 // 64-bit, longs in 1 register: use all 64-bit integer registers
  355                    ,R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7
  356                    ,R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5
  357                   );
  358 
  359 reg_class g1_regL(R_G1H,R_G1);
  360 reg_class g3_regL(R_G3H,R_G3);
  361 reg_class o2_regL(R_O2H,R_O2);
  362 reg_class o7_regL(R_O7H,R_O7);
  363 
  364 // ----------------------------
  365 // Special Class for Condition Code Flags Register
  366 reg_class int_flags(CCR);
  367 reg_class float_flags(FCC0,FCC1,FCC2,FCC3);
  368 reg_class float_flag0(FCC0);
  369 
  370 
  371 // ----------------------------
  372 // Float Point Register Classes
  373 // ----------------------------
  374 // Skip F30/F31, they are reserved for mem-mem copies
  375 reg_class sflt_reg(R_F0,R_F1,R_F2,R_F3,R_F4,R_F5,R_F6,R_F7,R_F8,R_F9,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  376 
  377 // Paired floating point registers--they show up in the same order as the floats,
  378 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  379 reg_class dflt_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  380                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,
  381                    /* Use extra V9 double registers; this AD file does not support V8 */
  382                    R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  383                    R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x
  384                    );
  385 
  386 // Paired floating point registers--they show up in the same order as the floats,
  387 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  388 // This class is usable for mis-aligned loads as happen in I2C adapters.
  389 reg_class dflt_low_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  390                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  391 %}
  392 
  393 //----------DEFINITION BLOCK---------------------------------------------------
  394 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  395 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  396 // Format:
  397 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  398 // Generated Code in ad_&lt;arch&gt;.hpp
  399 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  400 //        // value == &lt;int_value&gt;
  401 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  402 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  403 //
  404 definitions %{
  405 // The default cost (of an ALU instruction).
  406   int_def DEFAULT_COST      (    100,     100);
  407   int_def HUGE_COST         (1000000, 1000000);
  408 
  409 // Memory refs are twice as expensive as run-of-the-mill.
  410   int_def MEMORY_REF_COST   (    200, DEFAULT_COST * 2);
  411 
  412 // Branches are even more expensive.
  413   int_def BRANCH_COST       (    300, DEFAULT_COST * 3);
  414   int_def CALL_COST         (    300, DEFAULT_COST * 3);
  415 %}
  416 
  417 
  418 //----------SOURCE BLOCK-------------------------------------------------------
  419 // This is a block of C++ code which provides values, functions, and
  420 // definitions necessary in the rest of the architecture description
  421 source_hpp %{
  422 // Header information of the source block.
  423 // Method declarations/definitions which are used outside
  424 // the ad-scope can conveniently be defined here.
  425 //
  426 // To keep related declarations/definitions/uses close together,
  427 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  428 
  429 // Must be visible to the DFA in dfa_sparc.cpp
  430 extern bool can_branch_register( Node *bol, Node *cmp );
  431 
  432 extern bool use_block_zeroing(Node* count);
  433 
  434 // Macros to extract hi &amp; lo halves from a long pair.
  435 // G0 is not part of any long pair, so assert on that.
  436 // Prevents accidentally using G1 instead of G0.
  437 #define LONG_HI_REG(x) (x)
  438 #define LONG_LO_REG(x) (x)
  439 
  440 class CallStubImpl {
  441 
  442   //--------------------------------------------------------------
  443   //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
  444   //--------------------------------------------------------------
  445 
  446  public:
  447   // Size of call trampoline stub.
  448   static uint size_call_trampoline() {
  449     return 0; // no call trampolines on this platform
  450   }
  451 
  452   // number of relocations needed by a call trampoline stub
  453   static uint reloc_call_trampoline() {
  454     return 0; // no call trampolines on this platform
  455   }
  456 };
  457 
  458 class HandlerImpl {
  459 
  460  public:
  461 
  462   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  463   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  464 
  465   static uint size_exception_handler() {
  466     return ( NativeJump::instruction_size ); // sethi;jmp;nop
  467   }
  468 
  469   static uint size_deopt_handler() {
  470     return ( 4+  NativeJump::instruction_size ); // save;sethi;jmp;restore
  471   }
  472 };
  473 
  474 %}
  475 
  476 source %{
  477 #define __ _masm.
  478 
  479 // tertiary op of a LoadP or StoreP encoding
  480 #define REGP_OP true
  481 
  482 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding);
  483 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding);
  484 static Register reg_to_register_object(int register_encoding);
  485 
  486 // Used by the DFA in dfa_sparc.cpp.
  487 // Check for being able to use a V9 branch-on-register.  Requires a
  488 // compare-vs-zero, equal/not-equal, of a value which was zero- or sign-
  489 // extended.  Doesn&#39;t work following an integer ADD, for example, because of
  490 // overflow (-1 incremented yields 0 plus a carry in the high-order word).  On
  491 // 32-bit V9 systems, interrupts currently blow away the high-order 32 bits and
  492 // replace them with zero, which could become sign-extension in a different OS
  493 // release.  There&#39;s no obvious reason why an interrupt will ever fill these
  494 // bits with non-zero junk (the registers are reloaded with standard LD
  495 // instructions which either zero-fill or sign-fill).
  496 bool can_branch_register( Node *bol, Node *cmp ) {
  497   if( !BranchOnRegister ) return false;
  498   if( cmp-&gt;Opcode() == Op_CmpP )
  499     return true;  // No problems with pointer compares
  500   if( cmp-&gt;Opcode() == Op_CmpL )
  501     return true;  // No problems with long compares
  502 
  503   if( !SparcV9RegsHiBitsZero ) return false;
  504   if( bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne &amp;&amp;
  505       bol-&gt;as_Bool()-&gt;_test._test != BoolTest::eq )
  506      return false;
  507 
  508   // Check for comparing against a &#39;safe&#39; value.  Any operation which
  509   // clears out the high word is safe.  Thus, loads and certain shifts
  510   // are safe, as are non-negative constants.  Any operation which
  511   // preserves zero bits in the high word is safe as long as each of its
  512   // inputs are safe.  Thus, phis and bitwise booleans are safe if their
  513   // inputs are safe.  At present, the only important case to recognize
  514   // seems to be loads.  Constants should fold away, and shifts &amp;
  515   // logicals can use the &#39;cc&#39; forms.
  516   Node *x = cmp-&gt;in(1);
  517   if( x-&gt;is_Load() ) return true;
  518   if( x-&gt;is_Phi() ) {
  519     for( uint i = 1; i &lt; x-&gt;req(); i++ )
  520       if( !x-&gt;in(i)-&gt;is_Load() )
  521         return false;
  522     return true;
  523   }
  524   return false;
  525 }
  526 
  527 bool use_block_zeroing(Node* count) {
  528   // Use BIS for zeroing if count is not constant
  529   // or it is &gt;= BlockZeroingLowLimit.
  530   return UseBlockZeroing &amp;&amp; (count-&gt;find_intptr_t_con(BlockZeroingLowLimit) &gt;= BlockZeroingLowLimit);
  531 }
  532 
  533 // ****************************************************************************
  534 
  535 // REQUIRED FUNCTIONALITY
  536 
  537 // !!!!! Special hack to get all type of calls to specify the byte offset
  538 //       from the start of the call to the point where the return address
  539 //       will point.
  540 //       The &quot;return address&quot; is the address of the call instruction, plus 8.
  541 
  542 int MachCallStaticJavaNode::ret_addr_offset() {
  543   int offset = NativeCall::instruction_size;  // call; delay slot
  544   if (_method_handle_invoke)
  545     offset += 4;  // restore SP
  546   return offset;
  547 }
  548 
  549 int MachCallDynamicJavaNode::ret_addr_offset() {
  550   int vtable_index = this-&gt;_vtable_index;
  551   if (vtable_index &lt; 0) {
  552     // must be invalid_vtable_index, not nonvirtual_vtable_index
  553     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
  554     return (NativeMovConstReg::instruction_size +
  555            NativeCall::instruction_size);  // sethi; setlo; call; delay slot
  556   } else {
  557     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  558     int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
  559     int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
  560     int klass_load_size;
  561     if (UseCompressedClassPointers) {
  562       assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
  563       klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
  564     } else {
  565       klass_load_size = 1*BytesPerInstWord;
  566     }
  567     if (Assembler::is_simm13(v_off)) {
  568       return klass_load_size +
  569              (2*BytesPerInstWord +           // ld_ptr, ld_ptr
  570              NativeCall::instruction_size);  // call; delay slot
  571     } else {
  572       return klass_load_size +
  573              (4*BytesPerInstWord +           // set_hi, set, ld_ptr, ld_ptr
  574              NativeCall::instruction_size);  // call; delay slot
  575     }
  576   }
  577 }
  578 
  579 int MachCallRuntimeNode::ret_addr_offset() {
  580   if (MacroAssembler::is_far_target(entry_point())) {
  581     return NativeFarCall::instruction_size;
  582   } else {
  583     return NativeCall::instruction_size;
  584   }
  585 }
  586 
  587 // Indicate if the safepoint node needs the polling page as an input.
  588 // Since Sparc does not have absolute addressing, it does.
  589 bool SafePointNode::needs_polling_address_input() {
  590   return true;
  591 }
  592 
  593 // emit an interrupt that is caught by the debugger (for debugging compiler)
  594 void emit_break(CodeBuffer &amp;cbuf) {
  595   MacroAssembler _masm(&amp;cbuf);
  596   __ breakpoint_trap();
  597 }
  598 
  599 #ifndef PRODUCT
  600 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  601   st-&gt;print(&quot;TA&quot;);
  602 }
  603 #endif
  604 
  605 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  606   emit_break(cbuf);
  607 }
  608 
  609 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  610   return MachNode::size(ra_);
  611 }
  612 
  613 // Traceable jump
  614 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
  615   MacroAssembler _masm(&amp;cbuf);
  616   Register rdest = reg_to_register_object(jump_target);
  617   __ JMP(rdest, 0);
  618   __ delayed()-&gt;nop();
  619 }
  620 
  621 // Traceable jump and set exception pc
  622 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
  623   MacroAssembler _masm(&amp;cbuf);
  624   Register rdest = reg_to_register_object(jump_target);
  625   __ JMP(rdest, 0);
  626   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  627 }
  628 
  629 void emit_nop(CodeBuffer &amp;cbuf) {
  630   MacroAssembler _masm(&amp;cbuf);
  631   __ nop();
  632 }
  633 
  634 void emit_illtrap(CodeBuffer &amp;cbuf) {
  635   MacroAssembler _masm(&amp;cbuf);
  636   __ illtrap(0);
  637 }
  638 
  639 
  640 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  641   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  642 
  643   intptr_t offset = 0;
  644   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  645   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  646   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  647   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  648   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  649   atype = atype-&gt;add_offset(offset);
  650   assert(disp32 == offset, &quot;wrong disp32&quot;);
  651   return atype-&gt;_offset;
  652 }
  653 
  654 
  655 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
  656   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  657 
  658   intptr_t offset = 0;
  659   Node* addr = n-&gt;in(2);
  660   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  661   if (addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP) {
  662     Node* a = addr-&gt;in(2/*AddPNode::Address*/);
  663     Node* o = addr-&gt;in(3/*AddPNode::Offset*/);
  664     offset = o-&gt;is_Con() ? o-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() : Type::OffsetBot;
  665     atype = a-&gt;bottom_type()-&gt;is_ptr()-&gt;add_offset(offset);
  666     assert(atype-&gt;isa_oop_ptr(), &quot;still an oop&quot;);
  667   }
  668   offset = atype-&gt;is_ptr()-&gt;_offset;
  669   if (offset != Type::OffsetBot)  offset += disp32;
  670   return offset;
  671 }
  672 
  673 static inline jlong replicate_immI(int con, int count, int width) {
  674   // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
  675   assert(count*width == 8 &amp;&amp; width &lt;= 4, &quot;sanity&quot;);
  676   int bit_width = width * 8;
  677   jlong val = con;
  678   val &amp;= (((jlong) 1) &lt;&lt; bit_width) - 1;  // mask off sign bits
  679   for (int i = 0; i &lt; count - 1; i++) {
  680     val |= (val &lt;&lt; bit_width);
  681   }
  682   return val;
  683 }
  684 
  685 static inline jlong replicate_immF(float con) {
  686   // Replicate float con 2 times and pack into vector.
  687   int val = *((int*)&amp;con);
  688   jlong lval = val;
  689   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
  690   return lval;
  691 }
  692 
  693 // Standard Sparc opcode form2 field breakdown
  694 static inline void emit2_19(CodeBuffer &amp;cbuf, int f30, int f29, int f25, int f22, int f20, int f19, int f0 ) {
  695   f0 &amp;= (1&lt;&lt;19)-1;     // Mask displacement to 19 bits
  696   int op = (f30 &lt;&lt; 30) |
  697            (f29 &lt;&lt; 29) |
  698            (f25 &lt;&lt; 25) |
  699            (f22 &lt;&lt; 22) |
  700            (f20 &lt;&lt; 20) |
  701            (f19 &lt;&lt; 19) |
  702            (f0  &lt;&lt;  0);
  703   cbuf.insts()-&gt;emit_int32(op);
  704 }
  705 
  706 // Standard Sparc opcode form2 field breakdown
  707 static inline void emit2_22(CodeBuffer &amp;cbuf, int f30, int f25, int f22, int f0 ) {
  708   f0 &gt;&gt;= 10;           // Drop 10 bits
  709   f0 &amp;= (1&lt;&lt;22)-1;     // Mask displacement to 22 bits
  710   int op = (f30 &lt;&lt; 30) |
  711            (f25 &lt;&lt; 25) |
  712            (f22 &lt;&lt; 22) |
  713            (f0  &lt;&lt;  0);
  714   cbuf.insts()-&gt;emit_int32(op);
  715 }
  716 
  717 // Standard Sparc opcode form3 field breakdown
  718 static inline void emit3(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int f5, int f0 ) {
  719   int op = (f30 &lt;&lt; 30) |
  720            (f25 &lt;&lt; 25) |
  721            (f19 &lt;&lt; 19) |
  722            (f14 &lt;&lt; 14) |
  723            (f5  &lt;&lt;  5) |
  724            (f0  &lt;&lt;  0);
  725   cbuf.insts()-&gt;emit_int32(op);
  726 }
  727 
  728 // Standard Sparc opcode form3 field breakdown
  729 static inline void emit3_simm13(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm13 ) {
  730   simm13 &amp;= (1&lt;&lt;13)-1; // Mask to 13 bits
  731   int op = (f30 &lt;&lt; 30) |
  732            (f25 &lt;&lt; 25) |
  733            (f19 &lt;&lt; 19) |
  734            (f14 &lt;&lt; 14) |
  735            (1   &lt;&lt; 13) | // bit to indicate immediate-mode
  736            (simm13&lt;&lt;0);
  737   cbuf.insts()-&gt;emit_int32(op);
  738 }
  739 
  740 static inline void emit3_simm10(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm10 ) {
  741   simm10 &amp;= (1&lt;&lt;10)-1; // Mask to 10 bits
  742   emit3_simm13(cbuf,f30,f25,f19,f14,simm10);
  743 }
  744 
  745 #ifdef ASSERT
  746 // Helper function for VerifyOops in emit_form3_mem_reg
  747 void verify_oops_warning(const MachNode *n, int ideal_op, int mem_op) {
  748   warning(&quot;VerifyOops encountered unexpected instruction:&quot;);
  749   n-&gt;dump(2);
  750   warning(&quot;Instruction has ideal_Opcode==Op_%s and op_ld==Op_%s \n&quot;, NodeClassNames[ideal_op], NodeClassNames[mem_op]);
  751 }
  752 #endif
  753 
  754 
  755 void emit_form3_mem_reg(CodeBuffer &amp;cbuf, PhaseRegAlloc* ra, const MachNode* n, int primary, int tertiary,
  756                         int src1_enc, int disp32, int src2_enc, int dst_enc) {
  757 
  758 #ifdef ASSERT
  759   // The following code implements the +VerifyOops feature.
  760   // It verifies oop values which are loaded into or stored out of
  761   // the current method activation.  +VerifyOops complements techniques
  762   // like ScavengeALot, because it eagerly inspects oops in transit,
  763   // as they enter or leave the stack, as opposed to ScavengeALot,
  764   // which inspects oops &quot;at rest&quot;, in the stack or heap, at safepoints.
  765   // For this reason, +VerifyOops can sometimes detect bugs very close
  766   // to their point of creation.  It can also serve as a cross-check
  767   // on the validity of oop maps, when used toegether with ScavengeALot.
  768 
  769   // It would be good to verify oops at other points, especially
  770   // when an oop is used as a base pointer for a load or store.
  771   // This is presently difficult, because it is hard to know when
  772   // a base address is biased or not.  (If we had such information,
  773   // it would be easy and useful to make a two-argument version of
  774   // verify_oop which unbiases the base, and performs verification.)
  775 
  776   assert((uint)tertiary == 0xFFFFFFFF || tertiary == REGP_OP, &quot;valid tertiary&quot;);
  777   bool is_verified_oop_base  = false;
  778   bool is_verified_oop_load  = false;
  779   bool is_verified_oop_store = false;
  780   int tmp_enc = -1;
  781   if (VerifyOops &amp;&amp; src1_enc != R_SP_enc) {
  782     // classify the op, mainly for an assert check
  783     int st_op = 0, ld_op = 0;
  784     switch (primary) {
  785     case Assembler::stb_op3:  st_op = Op_StoreB; break;
  786     case Assembler::sth_op3:  st_op = Op_StoreC; break;
  787     case Assembler::stx_op3:  // may become StoreP or stay StoreI or StoreD0
  788     case Assembler::stw_op3:  st_op = Op_StoreI; break;
  789     case Assembler::std_op3:  st_op = Op_StoreL; break;
  790     case Assembler::stf_op3:  st_op = Op_StoreF; break;
  791     case Assembler::stdf_op3: st_op = Op_StoreD; break;
  792 
  793     case Assembler::ldsb_op3: ld_op = Op_LoadB; break;
  794     case Assembler::ldub_op3: ld_op = Op_LoadUB; break;
  795     case Assembler::lduh_op3: ld_op = Op_LoadUS; break;
  796     case Assembler::ldsh_op3: ld_op = Op_LoadS; break;
  797     case Assembler::ldx_op3:  // may become LoadP or stay LoadI
  798     case Assembler::ldsw_op3: // may become LoadP or stay LoadI
  799     case Assembler::lduw_op3: ld_op = Op_LoadI; break;
  800     case Assembler::ldd_op3:  ld_op = Op_LoadL; break;
  801     case Assembler::ldf_op3:  ld_op = Op_LoadF; break;
  802     case Assembler::lddf_op3: ld_op = Op_LoadD; break;
  803     case Assembler::prefetch_op3: ld_op = Op_LoadI; break;
  804 
  805     default: ShouldNotReachHere();
  806     }
  807     if (tertiary == REGP_OP) {
  808       if      (st_op == Op_StoreI)  st_op = Op_StoreP;
  809       else if (ld_op == Op_LoadI)   ld_op = Op_LoadP;
  810       else                          ShouldNotReachHere();
  811       if (st_op) {
  812         // a store
  813         // inputs are (0:control, 1:memory, 2:address, 3:value)
  814         Node* n2 = n-&gt;in(3);
  815         if (n2 != NULL) {
  816           const Type* t = n2-&gt;bottom_type();
  817           is_verified_oop_store = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  818         }
  819       } else {
  820         // a load
  821         const Type* t = n-&gt;bottom_type();
  822         is_verified_oop_load = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  823       }
  824     }
  825 
  826     if (ld_op) {
  827       // a Load
  828       // inputs are (0:control, 1:memory, 2:address)
  829       if (!(n-&gt;ideal_Opcode()==ld_op)       &amp;&amp; // Following are special cases
  830           !(n-&gt;ideal_Opcode()==Op_LoadPLocked &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  831           !(n-&gt;ideal_Opcode()==Op_LoadI     &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  832           !(n-&gt;ideal_Opcode()==Op_LoadF     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  833           !(n-&gt;ideal_Opcode()==Op_LoadRange &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  834           !(n-&gt;ideal_Opcode()==Op_LoadKlass &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  835           !(n-&gt;ideal_Opcode()==Op_LoadL     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  836           !(n-&gt;ideal_Opcode()==Op_LoadL_unaligned &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  837           !(n-&gt;ideal_Opcode()==Op_LoadD_unaligned &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  838           !(n-&gt;ideal_Opcode()==Op_ConvI2F   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  839           !(n-&gt;ideal_Opcode()==Op_ConvI2D   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  840           !(n-&gt;ideal_Opcode()==Op_PrefetchAllocation &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  841           !(n-&gt;ideal_Opcode()==Op_LoadVector &amp;&amp; ld_op==Op_LoadD) &amp;&amp;
  842           !(n-&gt;rule() == loadUB_rule)) {
  843         verify_oops_warning(n, n-&gt;ideal_Opcode(), ld_op);
  844       }
  845     } else if (st_op) {
  846       // a Store
  847       // inputs are (0:control, 1:memory, 2:address, 3:value)
  848       if (!(n-&gt;ideal_Opcode()==st_op)    &amp;&amp; // Following are special cases
  849           !(n-&gt;ideal_Opcode()==Op_StoreCM &amp;&amp; st_op==Op_StoreB) &amp;&amp;
  850           !(n-&gt;ideal_Opcode()==Op_StoreI &amp;&amp; st_op==Op_StoreF) &amp;&amp;
  851           !(n-&gt;ideal_Opcode()==Op_StoreF &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  852           !(n-&gt;ideal_Opcode()==Op_StoreL &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  853           !(n-&gt;ideal_Opcode()==Op_StoreVector &amp;&amp; st_op==Op_StoreD) &amp;&amp;
  854           !(n-&gt;ideal_Opcode()==Op_StoreD &amp;&amp; st_op==Op_StoreI &amp;&amp; n-&gt;rule() == storeD0_rule)) {
  855         verify_oops_warning(n, n-&gt;ideal_Opcode(), st_op);
  856       }
  857     }
  858 
  859     if (src2_enc == R_G0_enc &amp;&amp; n-&gt;rule() != loadUB_rule &amp;&amp; n-&gt;ideal_Opcode() != Op_StoreCM ) {
  860       Node* addr = n-&gt;in(2);
  861       if (!(addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP)) {
  862         const TypeOopPtr* atype = addr-&gt;bottom_type()-&gt;isa_instptr();  // %%% oopptr?
  863         if (atype != NULL) {
  864           intptr_t offset = get_offset_from_base(n, atype, disp32);
  865           intptr_t offset_2 = get_offset_from_base_2(n, atype, disp32);
  866           if (offset != offset_2) {
  867             get_offset_from_base(n, atype, disp32);
  868             get_offset_from_base_2(n, atype, disp32);
  869           }
  870           assert(offset == offset_2, &quot;different offsets&quot;);
  871           if (offset == disp32) {
  872             // we now know that src1 is a true oop pointer
  873             is_verified_oop_base = true;
  874             if (ld_op &amp;&amp; src1_enc == dst_enc &amp;&amp; ld_op != Op_LoadF &amp;&amp; ld_op != Op_LoadD) {
  875               if( primary == Assembler::ldd_op3 ) {
  876                 is_verified_oop_base = false; // Cannot &#39;ldd&#39; into O7
  877               } else {
  878                 tmp_enc = dst_enc;
  879                 dst_enc = R_O7_enc; // Load into O7; preserve source oop
  880                 assert(src1_enc != dst_enc, &quot;&quot;);
  881               }
  882             }
  883           }
  884           if (st_op &amp;&amp; (( offset == oopDesc::klass_offset_in_bytes())
  885                        || offset == oopDesc::mark_offset_in_bytes())) {
  886                       // loading the mark should not be allowed either, but
  887                       // we don&#39;t check this since it conflicts with InlineObjectHash
  888                       // usage of LoadINode to get the mark. We could keep the
  889                       // check if we create a new LoadMarkNode
  890             // but do not verify the object before its header is initialized
  891             ShouldNotReachHere();
  892           }
  893         }
  894       }
  895     }
  896   }
  897 #endif
  898 
  899   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  900              | (dst_enc        &lt;&lt; 25)
  901              | (primary        &lt;&lt; 19)
  902              | (src1_enc       &lt;&lt; 14);
  903 
  904   uint index = src2_enc;
  905   int disp = disp32;
  906 
  907   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  908     disp += STACK_BIAS;
  909     // Check that stack offset fits, load into O7 if not
  910     if (!Assembler::is_simm13(disp)) {
  911       MacroAssembler _masm(&amp;cbuf);
  912       __ set(disp, O7);
  913       if (index != R_G0_enc) {
  914         __ add(O7, reg_to_register_object(index), O7);
  915       }
  916       index = R_O7_enc;
  917       disp = 0;
  918     }
  919   }
  920 
  921   if( disp == 0 ) {
  922     // use reg-reg form
  923     // bit 13 is already zero
  924     instr |= index;
  925   } else {
  926     // use reg-imm form
  927     instr |= 0x00002000;          // set bit 13 to one
  928     instr |= disp &amp; 0x1FFF;
  929   }
  930 
  931   cbuf.insts()-&gt;emit_int32(instr);
  932 
  933 #ifdef ASSERT
  934   if (VerifyOops) {
  935     MacroAssembler _masm(&amp;cbuf);
  936     if (is_verified_oop_base) {
  937       __ verify_oop(reg_to_register_object(src1_enc));
  938     }
  939     if (is_verified_oop_store) {
  940       __ verify_oop(reg_to_register_object(dst_enc));
  941     }
  942     if (tmp_enc != -1) {
  943       __ mov(O7, reg_to_register_object(tmp_enc));
  944     }
  945     if (is_verified_oop_load) {
  946       __ verify_oop(reg_to_register_object(dst_enc));
  947     }
  948   }
  949 #endif
  950 }
  951 
  952 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  953   // The method which records debug information at every safepoint
  954   // expects the call to be the first instruction in the snippet as
  955   // it creates a PcDesc structure which tracks the offset of a call
  956   // from the start of the codeBlob. This offset is computed as
  957   // code_end() - code_begin() of the code which has been emitted
  958   // so far.
  959   // In this particular case we have skirted around the problem by
  960   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  961   // may bite us again at some other point and a cleaner/generic
  962   // solution using relocations would be needed.
  963   MacroAssembler _masm(&amp;cbuf);
  964   __ set_inst_mark();
  965 
  966   // We flush the current window just so that there is a valid stack copy
  967   // the fact that the current window becomes active again instantly is
  968   // not a problem there is nothing live in it.
  969 
  970 #ifdef ASSERT
  971   int startpos = __ offset();
  972 #endif /* ASSERT */
  973 
  974   __ call((address)entry_point, rspec);
  975 
  976   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  977   else __ delayed()-&gt;nop();
  978 
  979   if (preserve_g2)   __ mov(L7, G2);
  980 
  981 #ifdef ASSERT
  982   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
  983     // Trash argument dump slots.
  984     __ set(0xb0b8ac0db0b8ac0d, G1);
  985     __ mov(G1, G5);
  986     __ stx(G1, SP, STACK_BIAS + 0x80);
  987     __ stx(G1, SP, STACK_BIAS + 0x88);
  988     __ stx(G1, SP, STACK_BIAS + 0x90);
  989     __ stx(G1, SP, STACK_BIAS + 0x98);
  990     __ stx(G1, SP, STACK_BIAS + 0xA0);
  991     __ stx(G1, SP, STACK_BIAS + 0xA8);
  992   }
  993 #endif /*ASSERT*/
  994 }
  995 
  996 //=============================================================================
  997 // REQUIRED FUNCTIONALITY for encoding
  998 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  999 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1000 
 1001 
 1002 //=============================================================================
 1003 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1004 
<a name="1" id="anc1"></a><span class="line-modified"> 1005 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
 1006   if (UseRDPCForConstantTableBase) {
 1007     // The table base offset might be less but then it fits into
 1008     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1009     return Assembler::min_simm13();
 1010   } else {
 1011     int offset = -(size() / 2);
 1012     if (!Assembler::is_simm13(offset)) {
 1013       offset = Assembler::min_simm13();
 1014     }
 1015     return offset;
 1016   }
 1017 }
 1018 
 1019 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1020 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1021   ShouldNotReachHere();
 1022 }
 1023 
 1024 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1025   Compile* C = ra_-&gt;C;
<a name="2" id="anc2"></a><span class="line-modified"> 1026   Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
 1027   MacroAssembler _masm(&amp;cbuf);
 1028 
 1029   Register r = as_Register(ra_-&gt;get_encode(this));
 1030   CodeSection* consts_section = __ code()-&gt;consts();
 1031   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1032   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1033 
 1034   if (UseRDPCForConstantTableBase) {
 1035     // For the following RDPC logic to work correctly the consts
 1036     // section must be allocated right before the insts section.  This
 1037     // assert checks for that.  The layout and the SECT_* constants
 1038     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1039     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1040     int insts_offset = __ offset();
 1041 
 1042     // Layout:
 1043     //
 1044     // |----------- consts section ------------|----------- insts section -----------...
 1045     // |------ constant table -----|- padding -|------------------x----
 1046     //                                                            \ current PC (RDPC instruction)
 1047     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1048     //                                                            \ table base
 1049     // The table base offset is later added to the load displacement
 1050     // so it has to be negative.
 1051     int table_base_offset = -(consts_size + insts_offset);
 1052     int disp;
 1053 
 1054     // If the displacement from the current PC to the constant table
 1055     // base fits into simm13 we set the constant table base to the
 1056     // current PC.
 1057     if (Assembler::is_simm13(table_base_offset)) {
 1058       constant_table.set_table_base_offset(table_base_offset);
 1059       disp = 0;
 1060     } else {
 1061       // Otherwise we set the constant table base offset to the
 1062       // maximum negative displacement of load instructions to keep
 1063       // the disp as small as possible:
 1064       //
 1065       // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1066       // |&lt;--------- min_simm13 ---------&gt;|&lt;-------- disp ---------&gt;|
 1067       //                                  \ table base
 1068       table_base_offset = Assembler::min_simm13();
 1069       constant_table.set_table_base_offset(table_base_offset);
 1070       disp = (consts_size + insts_offset) + table_base_offset;
 1071     }
 1072 
 1073     __ rdpc(r);
 1074 
 1075     if (disp == 0) {
 1076       // Emitting an additional &#39;nop&#39; instruction in order not to cause a code
 1077       // size adjustment in the code following the table setup (if the instruction
 1078       // immediately following after this section is a CTI).
 1079       __ nop();
 1080     }
 1081     else {
 1082       assert(r != O7, &quot;need temporary&quot;);
 1083       __ sub(r, __ ensure_simm13_or_reg(disp, O7), r);
 1084     }
 1085   }
 1086   else {
 1087     // Materialize the constant table base.
 1088     address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
 1089     RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
 1090     AddressLiteral base(baseaddr, rspec);
 1091     __ set(base, r);
 1092   }
 1093 }
 1094 
 1095 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
 1096   if (UseRDPCForConstantTableBase) {
 1097     // This is really the worst case but generally it&#39;s only 1 instruction.
 1098     return (1 /*rdpc*/ + 1 /*sub*/ + MacroAssembler::worst_case_insts_for_set()) * BytesPerInstWord;
 1099   } else {
 1100     return MacroAssembler::worst_case_insts_for_set() * BytesPerInstWord;
 1101   }
 1102 }
 1103 
 1104 #ifndef PRODUCT
 1105 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1106   char reg[128];
 1107   ra_-&gt;dump_register(this, reg);
 1108   if (UseRDPCForConstantTableBase) {
 1109     st-&gt;print(&quot;RDPC   %s\t! constant table base&quot;, reg);
 1110   } else {
 1111     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1112   }
 1113 }
 1114 #endif
 1115 
 1116 
 1117 //=============================================================================
 1118 
 1119 #ifndef PRODUCT
 1120 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1121   Compile* C = ra_-&gt;C;
 1122 
 1123   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1124     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1125   }
 1126 
 1127   if( VerifyThread ) {
 1128     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1129   }
 1130 
<a name="3" id="anc3"></a><span class="line-modified"> 1131   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 1132   int bangsize = C-&gt;bang_size_in_bytes();</span>
 1133 
 1134   // Calls to C2R adapters often do not accept exceptional returns.
 1135   // We require that their callers must bang for them.  But be careful, because
 1136   // some VM calls (such as call site linkage) can use several kilobytes of
 1137   // stack.  But the stack safety zone should account for that.
 1138   // See bugs 4446381, 4468289, 4497237.
<a name="4" id="anc4"></a><span class="line-modified"> 1139   if (C-&gt;need_stack_bang(bangsize)) {</span>
 1140     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1141   }
 1142 
 1143   if (Assembler::is_simm13(-framesize)) {
 1144     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1145   } else {
 1146     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1147     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1148     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1149   }
 1150 
 1151 }
 1152 #endif
 1153 
 1154 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1155   Compile* C = ra_-&gt;C;
 1156   MacroAssembler _masm(&amp;cbuf);
 1157 
 1158   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1159     __ nop();
 1160   }
 1161 
 1162   __ verify_thread();
 1163 
<a name="5" id="anc5"></a><span class="line-modified"> 1164   size_t framesize = C-&gt;frame_size_in_bytes();</span>
 1165   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1166   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<a name="6" id="anc6"></a><span class="line-modified"> 1167   int bangsize = C-&gt;bang_size_in_bytes();</span>
 1168 
 1169   // Calls to C2R adapters often do not accept exceptional returns.
 1170   // We require that their callers must bang for them.  But be careful, because
 1171   // some VM calls (such as call site linkage) can use several kilobytes of
 1172   // stack.  But the stack safety zone should account for that.
 1173   // See bugs 4446381, 4468289, 4497237.
<a name="7" id="anc7"></a><span class="line-modified"> 1174   if (C-&gt;need_stack_bang(bangsize)) {</span>
 1175     __ generate_stack_overflow_check(bangsize);
 1176   }
 1177 
 1178   if (Assembler::is_simm13(-framesize)) {
 1179     __ save(SP, -framesize, SP);
 1180   } else {
 1181     __ sethi(-framesize &amp; ~0x3ff, G3);
 1182     __ add(G3, -framesize &amp; 0x3ff, G3);
 1183     __ save(SP, G3, SP);
 1184   }
<a name="8" id="anc8"></a><span class="line-modified"> 1185   C-&gt;set_frame_complete( __ offset() );</span>
 1186 
 1187   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1188     // NOTE: We set the table base offset here because users might be
 1189     // emitted before MachConstantBaseNode.
<a name="9" id="anc9"></a><span class="line-modified"> 1190     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
 1191     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1192   }
 1193 }
 1194 
 1195 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1196   return MachNode::size(ra_);
 1197 }
 1198 
 1199 int MachPrologNode::reloc() const {
 1200   return 10; // a large enough number
 1201 }
 1202 
 1203 //=============================================================================
 1204 #ifndef PRODUCT
 1205 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1206   Compile* C = ra_-&gt;C;
 1207 
 1208   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1209     if (SafepointMechanism::uses_global_page_poll()) {
 1210       st-&gt;print(&quot;SETHI  #PollAddr,L0\t! Load Polling address\n\t&quot;);
 1211     } else {
 1212       st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);
 1213     }
 1214     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1215   }
 1216 
 1217   if(do_polling()) {
 1218     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1219       st-&gt;print(&quot;NOP\n\t&quot;);
 1220     }
 1221     st-&gt;print(&quot;RET\n\t&quot;);
 1222   }
 1223 
 1224   st-&gt;print(&quot;RESTORE&quot;);
 1225 }
 1226 #endif
 1227 
 1228 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1229   MacroAssembler _masm(&amp;cbuf);
 1230   Compile* C = ra_-&gt;C;
 1231 
 1232   __ verify_thread();
 1233 
 1234   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1235     __ reserved_stack_check();
 1236   }
 1237 
 1238   // If this does safepoint polling, then do it here
 1239   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1240     if (SafepointMechanism::uses_thread_local_poll()) {
 1241       __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
 1242     } else {
 1243       AddressLiteral polling_page(os::get_polling_page());
 1244       __ sethi(polling_page, L0);
 1245     }
 1246     __ relocate(relocInfo::poll_return_type);
 1247     __ ld_ptr(L0, 0, G0);
 1248   }
 1249 
 1250   // If this is a return, then stuff the restore in the delay slot
 1251   if(do_polling()) {
 1252     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1253       // Insert extra padding for the case when the epilogue is preceded by
 1254       // a cbcond jump, which can&#39;t be followed by a CTI instruction
 1255       __ nop();
 1256     }
 1257     __ ret();
 1258     __ delayed()-&gt;restore();
 1259   } else {
 1260     __ restore();
 1261   }
 1262 }
 1263 
 1264 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1265   return MachNode::size(ra_);
 1266 }
 1267 
 1268 int MachEpilogNode::reloc() const {
 1269   return 16; // a large enough number
 1270 }
 1271 
 1272 const Pipeline * MachEpilogNode::pipeline() const {
 1273   return MachNode::pipeline_class();
 1274 }
 1275 
 1276 int MachEpilogNode::safepoint_offset() const {
 1277   assert(SafepointMechanism::uses_global_page_poll(), &quot;sanity&quot;);
 1278   assert( do_polling(), &quot;no return for this epilog node&quot;);
 1279   return MacroAssembler::insts_for_sethi(os::get_polling_page()) * BytesPerInstWord;
 1280 }
 1281 
 1282 //=============================================================================
 1283 
 1284 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
 1285 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1286 static enum RC rc_class( OptoReg::Name reg ) {
 1287   if (!OptoReg::is_valid(reg)) return rc_bad;
 1288   if (OptoReg::is_stack(reg)) return rc_stack;
 1289   VMReg r = OptoReg::as_VMReg(reg);
 1290   if (r-&gt;is_Register()) return rc_int;
 1291   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
 1292   return rc_float;
 1293 }
 1294 
 1295 #ifndef PRODUCT
 1296 ATTRIBUTE_PRINTF(2, 3)
 1297 static void print_helper(outputStream* st, const char* format, ...) {
 1298   const int tab_size = 8;
 1299   if (st-&gt;position() &gt; tab_size) {
 1300     st-&gt;cr();
 1301     st-&gt;sp();
 1302   }
 1303   va_list ap;
 1304   va_start(ap, format);
 1305   st-&gt;vprint(format, ap);
 1306   va_end(ap);
 1307 }
 1308 #endif // !PRODUCT
 1309 
 1310 static void impl_helper(const MachNode* mach, CodeBuffer* cbuf, PhaseRegAlloc* ra, bool is_load, int offset, int reg, int opcode, const char *op_str, outputStream* st) {
 1311   if (cbuf) {
 1312     emit_form3_mem_reg(*cbuf, ra, mach, opcode, -1, R_SP_enc, offset, 0, Matcher::_regEncode[reg]);
 1313   }
 1314 #ifndef PRODUCT
 1315   else {
 1316     if (is_load) {
 1317       print_helper(st, &quot;%s   [R_SP + #%d],R_%s\t! spill&quot;, op_str, offset, OptoReg::regname(reg));
 1318     } else {
 1319       print_helper(st, &quot;%s   R_%s,[R_SP + #%d]\t! spill&quot;, op_str, OptoReg::regname(reg), offset);
 1320     }
 1321   }
 1322 #endif
 1323 }
 1324 
 1325 static void impl_mov_helper(CodeBuffer *cbuf, int src, int dst, int op1, int op2, const char *op_str, outputStream* st) {
 1326   if (cbuf) {
 1327     emit3(*cbuf, Assembler::arith_op, Matcher::_regEncode[dst], op1, 0, op2, Matcher::_regEncode[src]);
 1328   }
 1329 #ifndef PRODUCT
 1330   else {
 1331     print_helper(st, &quot;%s  R_%s,R_%s\t! spill&quot;, op_str, OptoReg::regname(src), OptoReg::regname(dst));
 1332   }
 1333 #endif
 1334 }
 1335 
 1336 static void mach_spill_copy_implementation_helper(const MachNode* mach,
 1337                                                   CodeBuffer *cbuf,
 1338                                                   PhaseRegAlloc *ra_,
 1339                                                   outputStream* st) {
 1340   // Get registers to move
 1341   OptoReg::Name src_second = ra_-&gt;get_reg_second(mach-&gt;in(1));
 1342   OptoReg::Name src_first  = ra_-&gt;get_reg_first(mach-&gt;in(1));
 1343   OptoReg::Name dst_second = ra_-&gt;get_reg_second(mach);
 1344   OptoReg::Name dst_first  = ra_-&gt;get_reg_first(mach);
 1345 
 1346   enum RC src_second_rc = rc_class(src_second);
 1347   enum RC src_first_rc  = rc_class(src_first);
 1348   enum RC dst_second_rc = rc_class(dst_second);
 1349   enum RC dst_first_rc  = rc_class(dst_first);
 1350 
 1351   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot;);
 1352 
 1353   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1354     return; // Self copy, no move
 1355   }
 1356 
 1357   // --------------------------------------
 1358   // Check for mem-mem move.  Load into unused float registers and fall into
 1359   // the float-store case.
 1360   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
 1361     int offset = ra_-&gt;reg2offset(src_first);
 1362     // Further check for aligned-adjacent pair, so we can use a double load
 1363     if ((src_first&amp;1) == 0 &amp;&amp; src_first+1 == src_second) {
 1364       src_second    = OptoReg::Name(R_F31_num);
 1365       src_second_rc = rc_float;
 1366       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1367     } else {
 1368       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1369     }
 1370     src_first    = OptoReg::Name(R_F30_num);
 1371     src_first_rc = rc_float;
 1372   }
 1373 
 1374   if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) {
 1375     int offset = ra_-&gt;reg2offset(src_second);
 1376     impl_helper(mach, cbuf, ra_, true, offset, R_F31_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1377     src_second    = OptoReg::Name(R_F31_num);
 1378     src_second_rc = rc_float;
 1379   }
 1380 
 1381   // --------------------------------------
 1382   // Check for float-&gt;int copy; requires a trip through memory
 1383   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &lt; 3) {
 1384     int offset = frame::register_save_words*wordSize;
 1385     if (cbuf) {
 1386       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::sub_op3, R_SP_enc, 16);
 1387       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1388       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1389       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::add_op3, R_SP_enc, 16);
 1390     }
 1391 #ifndef PRODUCT
 1392     else {
 1393       print_helper(st, &quot;SUB    R_SP,16,R_SP&quot;);
 1394       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1395       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1396       print_helper(st, &quot;ADD    R_SP,16,R_SP&quot;);
 1397     }
 1398 #endif
 1399   }
 1400 
 1401   // Check for float-&gt;int copy on T4
 1402   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &gt;= 3) {
 1403     // Further check for aligned-adjacent pair, so we can use a double move
 1404     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1405       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mdtox_opf, &quot;MOVDTOX&quot;, st);
 1406       return;
 1407     }
 1408     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mstouw_opf, &quot;MOVSTOUW&quot;, st);
 1409   }
 1410   // Check for int-&gt;float copy on T4
 1411   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_float &amp;&amp; UseVIS &gt;= 3) {
 1412     // Further check for aligned-adjacent pair, so we can use a double move
 1413     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1414       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mxtod_opf, &quot;MOVXTOD&quot;, st);
 1415       return;
 1416     }
 1417     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mwtos_opf, &quot;MOVWTOS&quot;, st);
 1418   }
 1419 
 1420   // --------------------------------------
 1421   // In the 32-bit 1-reg-longs build ONLY, I see mis-aligned long destinations.
 1422   // In such cases, I have to do the big-endian swap.  For aligned targets, the
 1423   // hardware does the flop for me.  Doubles are always aligned, so no problem
 1424   // there.  Misaligned sources only come from native-long-returns (handled
 1425   // special below).
 1426 
 1427   // --------------------------------------
 1428   // Check for integer reg-reg copy
 1429   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int) {
 1430     // Else normal reg-reg copy
 1431     assert(src_second != dst_first, &quot;smashed second before evacuating it&quot;);
 1432     impl_mov_helper(cbuf, src_first, dst_first, Assembler::or_op3, 0, &quot;MOV  &quot;, st);
 1433     assert((src_first &amp; 1) == 0 &amp;&amp; (dst_first &amp; 1) == 0, &quot;never move second-halves of int registers&quot;);
 1434     // This moves an aligned adjacent pair.
 1435     // See if we are done.
 1436     if (src_first + 1 == src_second &amp;&amp; dst_first + 1 == dst_second) {
 1437       return;
 1438     }
 1439   }
 1440 
 1441   // Check for integer store
 1442   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack) {
 1443     int offset = ra_-&gt;reg2offset(dst_first);
 1444     // Further check for aligned-adjacent pair, so we can use a double store
 1445     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1446       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stx_op3, &quot;STX &quot;, st);
 1447       return;
 1448     }
 1449     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stw_op3, &quot;STW &quot;, st);
 1450   }
 1451 
 1452   // Check for integer load
 1453   if (dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack) {
 1454     int offset = ra_-&gt;reg2offset(src_first);
 1455     // Further check for aligned-adjacent pair, so we can use a double load
 1456     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1457       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldx_op3, &quot;LDX &quot;, st);
 1458       return;
 1459     }
 1460     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1461   }
 1462 
 1463   // Check for float reg-reg copy
 1464   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float) {
 1465     // Further check for aligned-adjacent pair, so we can use a double move
 1466     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1467       impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovd_opf, &quot;FMOVD&quot;, st);
 1468       return;
 1469     }
 1470     impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovs_opf, &quot;FMOVS&quot;, st);
 1471   }
 1472 
 1473   // Check for float store
 1474   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack) {
 1475     int offset = ra_-&gt;reg2offset(dst_first);
 1476     // Further check for aligned-adjacent pair, so we can use a double store
 1477     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1478       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stdf_op3, &quot;STDF&quot;, st);
 1479       return;
 1480     }
 1481     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stf_op3, &quot;STF &quot;, st);
 1482   }
 1483 
 1484   // Check for float load
 1485   if (dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack) {
 1486     int offset = ra_-&gt;reg2offset(src_first);
 1487     // Further check for aligned-adjacent pair, so we can use a double load
 1488     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1489       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1490       return;
 1491     }
 1492     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1493   }
 1494 
 1495   // --------------------------------------------------------------------
 1496   // Check for hi bits still needing moving.  Only happens for misaligned
 1497   // arguments to native calls.
 1498   if (src_second == dst_second) {
 1499     return; // Self copy; no move
 1500   }
 1501   assert(src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot;);
 1502 
 1503   Unimplemented();
 1504 }
 1505 
 1506 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf,
 1507                                        PhaseRegAlloc *ra_,
 1508                                        bool do_size,
 1509                                        outputStream* st) const {
 1510   assert(!do_size, &quot;not supported&quot;);
 1511   mach_spill_copy_implementation_helper(this, cbuf, ra_, st);
 1512   return 0;
 1513 }
 1514 
 1515 #ifndef PRODUCT
 1516 void MachSpillCopyNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1517   implementation( NULL, ra_, false, st );
 1518 }
 1519 #endif
 1520 
 1521 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1522   implementation( &amp;cbuf, ra_, false, NULL );
 1523 }
 1524 
 1525 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1526   return MachNode::size(ra_);
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1532   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1533 }
 1534 #endif
 1535 
 1536 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
 1537   MacroAssembler _masm(&amp;cbuf);
 1538   for (int i = 0; i &lt; _count; i += 1) {
 1539     __ nop();
 1540   }
 1541 }
 1542 
 1543 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1544   return 4 * _count;
 1545 }
 1546 
 1547 
 1548 //=============================================================================
 1549 #ifndef PRODUCT
 1550 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1551   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1552   int reg = ra_-&gt;get_reg_first(this);
 1553   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1554 }
 1555 #endif
 1556 
 1557 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1558   MacroAssembler _masm(&amp;cbuf);
 1559   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1560   int reg = ra_-&gt;get_encode(this);
 1561 
 1562   if (Assembler::is_simm13(offset)) {
 1563      __ add(SP, offset, reg_to_register_object(reg));
 1564   } else {
 1565      __ set(offset, O7);
 1566      __ add(SP, O7, reg_to_register_object(reg));
 1567   }
 1568 }
 1569 
 1570 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1571   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1572   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<a name="10" id="anc10"></a><span class="line-modified"> 1573   return ra_-&gt;C-&gt;scratch_emit_size(this);</span>
 1574 }
 1575 
 1576 //=============================================================================
 1577 #ifndef PRODUCT
 1578 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1579   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1580   if (UseCompressedClassPointers) {
 1581     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1582     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1583     if (CompressedKlassPointers::base() != 0) {
 1584       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1585       if (CompressedKlassPointers::shift() != 0) {
 1586         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1587       }
 1588       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1589       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1590     } else {
 1591       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1592     }
 1593   } else {
 1594     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1595   }
 1596   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1597   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1598 }
 1599 #endif
 1600 
 1601 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1602   MacroAssembler _masm(&amp;cbuf);
 1603   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1604   Register temp_reg   = G3;
 1605   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1606 
 1607   // Load klass from receiver
 1608   __ load_klass(O0, temp_reg);
 1609   // Compare against expected klass
 1610   __ cmp(temp_reg, G5_ic_reg);
 1611   // Branch to miss code, checks xcc or icc depending
 1612   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1613 }
 1614 
 1615 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1616   return MachNode::size(ra_);
 1617 }
 1618 
 1619 
 1620 //=============================================================================
 1621 
 1622 
 1623 // Emit exception handler code.
 1624 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1625   Register temp_reg = G3;
 1626   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
 1627   MacroAssembler _masm(&amp;cbuf);
 1628 
 1629   address base = __ start_a_stub(size_exception_handler());
 1630   if (base == NULL) {
 1631     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1632     return 0;  // CodeBuffer::expand failed
 1633   }
 1634 
 1635   int offset = __ offset();
 1636 
 1637   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1638   __ delayed()-&gt;nop();
 1639 
 1640   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1641 
 1642   __ end_a_stub();
 1643 
 1644   return offset;
 1645 }
 1646 
 1647 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1648   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1649   // at a poll and everything (including G3) can be live.
 1650   Register temp_reg = L0;
 1651   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
 1652   MacroAssembler _masm(&amp;cbuf);
 1653 
 1654   address base = __ start_a_stub(size_deopt_handler());
 1655   if (base == NULL) {
 1656     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1657     return 0;  // CodeBuffer::expand failed
 1658   }
 1659 
 1660   int offset = __ offset();
 1661   __ save_frame(0);
 1662   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1663   __ delayed()-&gt;restore();
 1664 
 1665   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1666 
 1667   __ end_a_stub();
 1668   return offset;
 1669 
 1670 }
 1671 
 1672 // Given a register encoding, produce a Integer Register object
 1673 static Register reg_to_register_object(int register_encoding) {
 1674   assert(L5-&gt;encoding() == R_L5_enc &amp;&amp; G1-&gt;encoding() == R_G1_enc, &quot;right coding&quot;);
 1675   return as_Register(register_encoding);
 1676 }
 1677 
 1678 // Given a register encoding, produce a single-precision Float Register object
 1679 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding) {
 1680   assert(F5-&gt;encoding(FloatRegisterImpl::S) == R_F5_enc &amp;&amp; F12-&gt;encoding(FloatRegisterImpl::S) == R_F12_enc, &quot;right coding&quot;);
 1681   return as_SingleFloatRegister(register_encoding);
 1682 }
 1683 
 1684 // Given a register encoding, produce a double-precision Float Register object
 1685 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding) {
 1686   assert(F4-&gt;encoding(FloatRegisterImpl::D) == R_F4_enc, &quot;right coding&quot;);
 1687   assert(F32-&gt;encoding(FloatRegisterImpl::D) == R_D32_enc, &quot;right coding&quot;);
 1688   return as_DoubleFloatRegister(register_encoding);
 1689 }
 1690 
 1691 const bool Matcher::match_rule_supported(int opcode) {
 1692   if (!has_match_rule(opcode))
 1693     return false;
 1694 
 1695   switch (opcode) {
 1696   case Op_CountLeadingZerosI:
 1697   case Op_CountLeadingZerosL:
 1698   case Op_CountTrailingZerosI:
 1699   case Op_CountTrailingZerosL:
 1700   case Op_PopCountI:
 1701   case Op_PopCountL:
 1702     if (!UsePopCountInstruction)
 1703       return false;
 1704   case Op_CompareAndSwapL:
 1705   case Op_CompareAndSwapP:
 1706     if (!VM_Version::supports_cx8())
 1707       return false;
 1708     break;
 1709   }
 1710 
 1711   return true;  // Per default match rules are supported.
 1712 }
 1713 
 1714 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1715 
 1716   // TODO
 1717   // identify extra cases that we might want to provide match rules for
 1718   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 1719   bool ret_value = match_rule_supported(opcode);
 1720   // Add rules here.
 1721 
 1722   return ret_value;  // Per default match rules are supported.
 1723 }
 1724 
 1725 const bool Matcher::has_predicated_vectors(void) {
 1726   return false;
 1727 }
 1728 
 1729 const int Matcher::float_pressure(int default_pressure_threshold) {
 1730   return default_pressure_threshold;
 1731 }
 1732 
 1733 int Matcher::regnum_to_fpu_offset(int regnum) {
 1734   return regnum - 32; // The FP registers are in the second chunk
 1735 }
 1736 
 1737 #ifdef ASSERT
 1738 address last_rethrow = NULL;  // debugging aid for Rethrow encoding
 1739 #endif
 1740 
 1741 // Vector width in bytes
 1742 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1743   assert(MaxVectorSize == 8, &quot;&quot;);
 1744   return 8;
 1745 }
 1746 
 1747 // Vector ideal reg
 1748 const uint Matcher::vector_ideal_reg(int size) {
 1749   assert(MaxVectorSize == 8, &quot;&quot;);
 1750   return Op_RegD;
 1751 }
 1752 
 1753 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1754   fatal(&quot;vector shift is not supported&quot;);
 1755   return Node::NotAMachineReg;
 1756 }
 1757 
 1758 // Limits on vector size (number of elements) loaded into vector.
 1759 const int Matcher::max_vector_size(const BasicType bt) {
 1760   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1761   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1762 }
 1763 
 1764 const int Matcher::min_vector_size(const BasicType bt) {
 1765   return max_vector_size(bt); // Same as max.
 1766 }
 1767 
 1768 // SPARC doesn&#39;t support misaligned vectors store/load.
 1769 const bool Matcher::misaligned_vectors_ok() {
 1770   return false;
 1771 }
 1772 
 1773 // Current (2013) SPARC platforms need to read original key
 1774 // to construct decryption expanded key
 1775 const bool Matcher::pass_original_key_for_aes() {
 1776   return true;
 1777 }
 1778 
 1779 // NOTE: All currently supported SPARC HW provides fast conversion.
 1780 const bool Matcher::convL2FSupported(void) { return true; }
 1781 
 1782 // Is this branch offset short enough that a short branch can be used?
 1783 //
 1784 // NOTE: If the platform does not provide any short branch variants, then
 1785 //       this method should return false for offset 0.
 1786 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1787   // The passed offset is relative to address of the branch.
 1788   // Don&#39;t need to adjust the offset.
 1789   return UseCBCond &amp;&amp; Assembler::is_simm12(offset);
 1790 }
 1791 
 1792 const bool Matcher::isSimpleConstant64(jlong value) {
 1793   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1794   // Depends on optimizations in MacroAssembler::setx.
 1795   int hi = (int)(value &gt;&gt; 32);
 1796   int lo = (int)(value &amp; ~0);
 1797   return (hi == 0) || (hi == -1) || (lo == 0);
 1798 }
 1799 
 1800 // No scaling for the parameter the ClearArray node.
 1801 const bool Matcher::init_array_count_is_in_bytes = true;
 1802 
 1803 // No additional cost for CMOVL.
 1804 const int Matcher::long_cmove_cost() { return 0; }
 1805 
 1806 // CMOVF/CMOVD are expensive on e.g., T4 and SPARC64.
 1807 const int Matcher::float_cmove_cost() {
 1808   return VM_Version::has_fast_cmove() ? 0 : ConditionalMoveLimit;
 1809 }
 1810 
 1811 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1812 const bool Matcher::require_postalloc_expand = false;
 1813 
 1814 // Do we need to mask the count passed to shift instructions or does
 1815 // the cpu only look at the lower 5/6 bits anyway?
 1816 const bool Matcher::need_masked_shift_count = false;
 1817 
 1818 // No support for generic vector operands.
 1819 const bool Matcher::supports_generic_vector_operands  = false;
 1820 
 1821 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1822   ShouldNotReachHere(); // generic vector operands not supported
 1823   return NULL;
 1824 }
 1825 
 1826 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1827   ShouldNotReachHere();  // generic vector operands not supported
 1828   return false;
 1829 }
 1830 
 1831 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1832   ShouldNotReachHere();  // generic vector operands not supported
 1833   return false;
 1834 }
 1835 
 1836 bool Matcher::narrow_oop_use_complex_address() {
 1837   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1838   return false;
 1839 }
 1840 
 1841 bool Matcher::narrow_klass_use_complex_address() {
 1842   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1843   return false;
 1844 }
 1845 
 1846 bool Matcher::const_oop_prefer_decode() {
 1847   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1848   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1849   // return CompressedOops::base() == NULL;
 1850   return true;
 1851 }
 1852 
 1853 bool Matcher::const_klass_prefer_decode() {
 1854   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1855   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1856   // return CompressedKlassPointers::base() == NULL;
 1857   return true;
 1858 }
 1859 
 1860 // Is it better to copy float constants, or load them directly from memory?
 1861 // Intel can load a float constant from a direct address, requiring no
 1862 // extra registers.  Most RISCs will have to materialize an address into a
 1863 // register first, so they would do better to copy the constant from stack.
 1864 const bool Matcher::rematerialize_float_constants = false;
 1865 
 1866 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1867 // needed.  Else we split the double into 2 integer pieces and move it
 1868 // piece-by-piece.  Only happens when passing doubles into C code as the
 1869 // Java calling convention forces doubles to be aligned.
 1870 const bool Matcher::misaligned_doubles_ok = true;
 1871 
 1872 // No-op on SPARC.
 1873 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1874 }
 1875 
<a name="11" id="anc11"></a><span class="line-modified"> 1876 // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed"> 1877 // to implement the UseStrictFP mode.</span>
 1878 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1879 
 1880 // Are floats converted to double when stored to stack during deoptimization?
 1881 // Sparc does not handle callee-save floats.
 1882 bool Matcher::float_in_double() { return false; }
 1883 
 1884 // Do ints take an entire long register or just half?
 1885 // Note that we if-def off of _LP64.
 1886 // The relevant question is how the int is callee-saved.  In _LP64
 1887 // the whole long is written but de-opt&#39;ing will have to extract
 1888 // the relevant 32 bits, in not-_LP64 only the low 32 bits is written.
 1889 const bool Matcher::int_in_long = true;
 1890 
 1891 // Return whether or not this register is ever used as an argument.  This
 1892 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1893 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1894 // arguments in those registers not be available to the callee.
 1895 bool Matcher::can_be_java_arg( int reg ) {
 1896   // Standard sparc 6 args in registers
 1897   if( reg == R_I0_num ||
 1898       reg == R_I1_num ||
 1899       reg == R_I2_num ||
 1900       reg == R_I3_num ||
 1901       reg == R_I4_num ||
 1902       reg == R_I5_num ) return true;
 1903   // 64-bit builds can pass 64-bit pointers and longs in
 1904   // the high I registers
 1905   if( reg == R_I0H_num ||
 1906       reg == R_I1H_num ||
 1907       reg == R_I2H_num ||
 1908       reg == R_I3H_num ||
 1909       reg == R_I4H_num ||
 1910       reg == R_I5H_num ) return true;
 1911 
 1912   if ((UseCompressedOops) &amp;&amp; (reg == R_G6_num || reg == R_G6H_num)) {
 1913     return true;
 1914   }
 1915 
 1916   // A few float args in registers
 1917   if( reg &gt;= R_F0_num &amp;&amp; reg &lt;= R_F7_num ) return true;
 1918 
 1919   return false;
 1920 }
 1921 
 1922 bool Matcher::is_spillable_arg( int reg ) {
 1923   return can_be_java_arg(reg);
 1924 }
 1925 
 1926 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1927   // Use hardware SDIVX instruction when it is
 1928   // faster than a code which use multiply.
 1929   return VM_Version::has_fast_idiv();
 1930 }
 1931 
 1932 // Register for DIVI projection of divmodI
 1933 RegMask Matcher::divI_proj_mask() {
 1934   ShouldNotReachHere();
 1935   return RegMask();
 1936 }
 1937 
 1938 // Register for MODI projection of divmodI
 1939 RegMask Matcher::modI_proj_mask() {
 1940   ShouldNotReachHere();
 1941   return RegMask();
 1942 }
 1943 
 1944 // Register for DIVL projection of divmodL
 1945 RegMask Matcher::divL_proj_mask() {
 1946   ShouldNotReachHere();
 1947   return RegMask();
 1948 }
 1949 
 1950 // Register for MODL projection of divmodL
 1951 RegMask Matcher::modL_proj_mask() {
 1952   ShouldNotReachHere();
 1953   return RegMask();
 1954 }
 1955 
 1956 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1957   return L7_REGP_mask();
 1958 }
 1959 
 1960 
 1961 const bool Matcher::convi2l_type_required = true;
 1962 
 1963 // Should the Matcher clone shifts on addressing modes, expecting them
 1964 // to be subsumed into complex addressing expressions or compute them
 1965 // into registers?
 1966 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1967   return clone_base_plus_offset_address(m, mstack, address_visited);
 1968 }
 1969 
 1970 void Compile::reshape_address(AddPNode* addp) {
 1971 }
 1972 
 1973 %}
 1974 
 1975 
 1976 // The intptr_t operand types, defined by textual substitution.
 1977 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
 1978 #define immX      immL
 1979 #define immX13    immL13
 1980 #define immX13m7  immL13m7
 1981 #define iRegX     iRegL
 1982 #define g1RegX    g1RegL
 1983 
 1984 //----------ENCODING BLOCK-----------------------------------------------------
 1985 // This block specifies the encoding classes used by the compiler to output
 1986 // byte streams.  Encoding classes are parameterized macros used by
 1987 // Machine Instruction Nodes in order to generate the bit encoding of the
 1988 // instruction.  Operands specify their base encoding interface with the
 1989 // interface keyword.  There are currently supported four interfaces,
 1990 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1991 // operand to generate a function which returns its register number when
 1992 // queried.   CONST_INTER causes an operand to generate a function which
 1993 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1994 // operand to generate four functions which return the Base Register, the
 1995 // Index Register, the Scale Value, and the Offset Value of the operand when
 1996 // queried.  COND_INTER causes an operand to generate six functions which
 1997 // return the encoding code (ie - encoding bits for the instruction)
 1998 // associated with each basic boolean condition for a conditional instruction.
 1999 //
 2000 // Instructions specify two basic values for encoding.  Again, a function
 2001 // is available to check if the constant displacement is an oop. They use the
 2002 // ins_encode keyword to specify their encoding classes (which must be
 2003 // a sequence of enc_class names, and their parameters, specified in
 2004 // the encoding block), and they use the
 2005 // opcode keyword to specify, in order, their primary, secondary, and
 2006 // tertiary opcode.  Only the opcode sections which a particular instruction
 2007 // needs for encoding need to be specified.
 2008 encode %{
 2009   enc_class enc_untested %{
 2010 #ifdef ASSERT
 2011     MacroAssembler _masm(&amp;cbuf);
 2012     __ untested(&quot;encoding&quot;);
 2013 #endif
 2014   %}
 2015 
 2016   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2017     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2018                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2019   %}
 2020 
 2021   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2022     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2023                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2024   %}
 2025 
 2026   enc_class form3_mem_prefetch_read( memory mem ) %{
 2027     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2028                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2029   %}
 2030 
 2031   enc_class form3_mem_prefetch_write( memory mem ) %{
 2032     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2033                        $mem$$base, $mem$$disp, $mem$$index, 2/*prefetch function many-writes*/);
 2034   %}
 2035 
 2036   enc_class form3_mem_reg_long_unaligned_marshal( memory mem, iRegL reg ) %{
 2037     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2038     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2039     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2040     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, R_O7_enc );
 2041     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg );
 2042     emit3_simm13( cbuf, Assembler::arith_op, $reg$$reg, Assembler::sllx_op3, $reg$$reg, 0x1020 );
 2043     emit3( cbuf, Assembler::arith_op, $reg$$reg, Assembler::or_op3, $reg$$reg, 0, R_O7_enc );
 2044   %}
 2045 
 2046   enc_class form3_mem_reg_double_unaligned( memory mem, RegD_low reg ) %{
 2047     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2048     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2049     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2050     // Load long with 2 instructions
 2051     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg+0 );
 2052     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, $reg$$reg+1 );
 2053   %}
 2054 
 2055   //%%% form3_mem_plus_4_reg is a hack--get rid of it
 2056   enc_class form3_mem_plus_4_reg( memory mem, iRegI dst ) %{
 2057     guarantee($mem$$disp, &quot;cannot offset a reg-reg operand by 4&quot;);
 2058     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp + 4, $mem$$index, $dst$$reg);
 2059   %}
 2060 
 2061   enc_class form3_g0_rs2_rd_move( iRegI rs2, iRegI rd ) %{
 2062     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2063     if( $rs2$$reg != $rd$$reg )
 2064       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, $rs2$$reg );
 2065   %}
 2066 
 2067   // Target lo half of long
 2068   enc_class form3_g0_rs2_rd_move_lo( iRegI rs2, iRegL rd ) %{
 2069     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2070     if( $rs2$$reg != LONG_LO_REG($rd$$reg) )
 2071       emit3( cbuf, Assembler::arith_op, LONG_LO_REG($rd$$reg), Assembler::or_op3, 0, 0, $rs2$$reg );
 2072   %}
 2073 
 2074   // Source lo half of long
 2075   enc_class form3_g0_rs2_rd_move_lo2( iRegL rs2, iRegI rd ) %{
 2076     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2077     if( LONG_LO_REG($rs2$$reg) != $rd$$reg )
 2078       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_LO_REG($rs2$$reg) );
 2079   %}
 2080 
 2081   // Target hi half of long
 2082   enc_class form3_rs1_rd_copysign_hi( iRegI rs1, iRegL rd ) %{
 2083     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 31 );
 2084   %}
 2085 
 2086   // Source lo half of long, and leave it sign extended.
 2087   enc_class form3_rs1_rd_signextend_lo1( iRegL rs1, iRegI rd ) %{
 2088     // Sign extend low half
 2089     emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 0, 0 );
 2090   %}
 2091 
 2092   // Source hi half of long, and leave it sign extended.
 2093   enc_class form3_rs1_rd_copy_hi1( iRegL rs1, iRegI rd ) %{
 2094     // Shift high half to low half
 2095     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::srlx_op3, $rs1$$reg, 32 );
 2096   %}
 2097 
 2098   // Source hi half of long
 2099   enc_class form3_g0_rs2_rd_move_hi2( iRegL rs2, iRegI rd ) %{
 2100     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2101     if( LONG_HI_REG($rs2$$reg) != $rd$$reg )
 2102       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_HI_REG($rs2$$reg) );
 2103   %}
 2104 
 2105   enc_class form3_rs1_rs2_rd( iRegI rs1, iRegI rs2, iRegI rd ) %{
 2106     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0, $rs2$$reg );
 2107   %}
 2108 
 2109   enc_class enc_to_bool( iRegI src, iRegI dst ) %{
 2110     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, 0, 0, $src$$reg );
 2111     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::addc_op3 , 0, 0 );
 2112   %}
 2113 
 2114   enc_class enc_ltmask( iRegI p, iRegI q, iRegI dst ) %{
 2115     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, $p$$reg, 0, $q$$reg );
 2116     // clear if nothing else is happening
 2117     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  0 );
 2118     // blt,a,pn done
 2119     emit2_19    ( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less, Assembler::bp_op2, Assembler::icc, 0/*predict not taken*/, 2 );
 2120     // mov dst,-1 in delay slot
 2121     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2122   %}
 2123 
 2124   enc_class form3_rs1_imm5_rd( iRegI rs1, immU5 imm5, iRegI rd ) %{
 2125     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $imm5$$constant &amp; 0x1F );
 2126   %}
 2127 
 2128   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2129     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2130   %}
 2131 
 2132   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2133     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2134   %}
 2135 
 2136   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2137     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2138   %}
 2139 
 2140   enc_class move_return_pc_to_o1() %{
 2141     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2142   %}
 2143 
 2144   /* %%% merge with enc_to_bool */
 2145   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
 2146     MacroAssembler _masm(&amp;cbuf);
 2147 
 2148     Register   src_reg = reg_to_register_object($src$$reg);
 2149     Register   dst_reg = reg_to_register_object($dst$$reg);
 2150     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2151   %}
 2152 
 2153   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2154     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
 2155     MacroAssembler _masm(&amp;cbuf);
 2156 
 2157     Register   p_reg = reg_to_register_object($p$$reg);
 2158     Register   q_reg = reg_to_register_object($q$$reg);
 2159     Register   y_reg = reg_to_register_object($y$$reg);
 2160     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2161 
 2162     __ subcc( p_reg, q_reg,   p_reg );
 2163     __ add  ( p_reg, y_reg, tmp_reg );
 2164     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2165   %}
 2166 
 2167   enc_class form_d2i_helper(regD src, regF dst) %{
 2168     // fcmp %fcc0,$src,$src
 2169     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2170     // branch %fcc0 not-nan, predict taken
 2171     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2172     // fdtoi $src,$dst
 2173     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2174     // fitos $dst,$dst (if nan)
 2175     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2176     // clear $dst (if nan)
 2177     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2178     // carry on here...
 2179   %}
 2180 
 2181   enc_class form_d2l_helper(regD src, regD dst) %{
 2182     // fcmp %fcc0,$src,$src  check for NAN
 2183     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2184     // branch %fcc0 not-nan, predict taken
 2185     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2186     // fdtox $src,$dst   convert in delay slot
 2187     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtox_opf, $src$$reg );
 2188     // fxtod $dst,$dst  (if nan)
 2189     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2190     // clear $dst (if nan)
 2191     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2192     // carry on here...
 2193   %}
 2194 
 2195   enc_class form_f2i_helper(regF src, regF dst) %{
 2196     // fcmps %fcc0,$src,$src
 2197     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2198     // branch %fcc0 not-nan, predict taken
 2199     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2200     // fstoi $src,$dst
 2201     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstoi_opf, $src$$reg );
 2202     // fitos $dst,$dst (if nan)
 2203     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2204     // clear $dst (if nan)
 2205     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2206     // carry on here...
 2207   %}
 2208 
 2209   enc_class form_f2l_helper(regF src, regD dst) %{
 2210     // fcmps %fcc0,$src,$src
 2211     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2212     // branch %fcc0 not-nan, predict taken
 2213     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2214     // fstox $src,$dst
 2215     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstox_opf, $src$$reg );
 2216     // fxtod $dst,$dst (if nan)
 2217     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2218     // clear $dst (if nan)
 2219     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2220     // carry on here...
 2221   %}
 2222 
 2223   enc_class form3_opf_rs2F_rdF(regF rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2224   enc_class form3_opf_rs2F_rdD(regF rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2225   enc_class form3_opf_rs2D_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2226   enc_class form3_opf_rs2D_rdD(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2227 
 2228   enc_class form3_opf_rs2D_lo_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg+1); %}
 2229 
 2230   enc_class form3_opf_rs2D_hi_rdD_hi(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2231   enc_class form3_opf_rs2D_lo_rdD_lo(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg+1,$primary,0,$tertiary,$rs2$$reg+1); %}
 2232 
 2233   enc_class form3_opf_rs1F_rs2F_rdF( regF rs1, regF rs2, regF rd ) %{
 2234     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2235   %}
 2236 
 2237   enc_class form3_opf_rs1D_rs2D_rdD( regD rs1, regD rs2, regD rd ) %{
 2238     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2239   %}
 2240 
 2241   enc_class form3_opf_rs1F_rs2F_fcc( regF rs1, regF rs2, flagsRegF fcc ) %{
 2242     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2243   %}
 2244 
 2245   enc_class form3_opf_rs1D_rs2D_fcc( regD rs1, regD rs2, flagsRegF fcc ) %{
 2246     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2247   %}
 2248 
 2249   enc_class form3_convI2F(regF rs2, regF rd) %{
 2250     emit3(cbuf,Assembler::arith_op,$rd$$reg,Assembler::fpop1_op3,0,$secondary,$rs2$$reg);
 2251   %}
 2252 
 2253   // Encloding class for traceable jumps
 2254   enc_class form_jmpl(g3RegP dest) %{
 2255     emit_jmpl(cbuf, $dest$$reg);
 2256   %}
 2257 
 2258   enc_class form_jmpl_set_exception_pc(g1RegP dest) %{
 2259     emit_jmpl_set_exception_pc(cbuf, $dest$$reg);
 2260   %}
 2261 
 2262   enc_class form2_nop() %{
 2263     emit_nop(cbuf);
 2264   %}
 2265 
 2266   enc_class form2_illtrap() %{
 2267     emit_illtrap(cbuf);
 2268   %}
 2269 
 2270 
 2271   // Compare longs and convert into -1, 0, 1.
 2272   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2273     // CMP $src1,$src2
 2274     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2275     // blt,a,pn done
 2276     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2277     // mov dst,-1 in delay slot
 2278     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2279     // bgt,a,pn done
 2280     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2281     // mov dst,1 in delay slot
 2282     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2283     // CLR    $dst
 2284     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2285   %}
 2286 
 2287   enc_class enc_PartialSubtypeCheck() %{
 2288     MacroAssembler _masm(&amp;cbuf);
 2289     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2290     __ delayed()-&gt;nop();
 2291   %}
 2292 
 2293   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
 2294     MacroAssembler _masm(&amp;cbuf);
 2295     Label* L = $labl$$label;
 2296     Assembler::Predict predict_taken =
 2297       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2298 
 2299     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2300     __ delayed()-&gt;nop();
 2301   %}
 2302 
 2303   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
 2304     MacroAssembler _masm(&amp;cbuf);
 2305     Label* L = $labl$$label;
 2306     Assembler::Predict predict_taken =
 2307       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2308 
 2309     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2310     __ delayed()-&gt;nop();
 2311   %}
 2312 
 2313   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2314     int op = (Assembler::arith_op &lt;&lt; 30) |
 2315              ($dst$$reg &lt;&lt; 25) |
 2316              (Assembler::movcc_op3 &lt;&lt; 19) |
 2317              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2318              ($cmp$$cmpcode &lt;&lt; 14) |
 2319              (0 &lt;&lt; 13) |                    // select register move
 2320              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2321              ($src$$reg &lt;&lt; 0);
 2322     cbuf.insts()-&gt;emit_int32(op);
 2323   %}
 2324 
 2325   enc_class enc_cmov_imm( cmpOp cmp, iRegI dst, immI11 src, immI pcc ) %{
 2326     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2327     int op = (Assembler::arith_op &lt;&lt; 30) |
 2328              ($dst$$reg &lt;&lt; 25) |
 2329              (Assembler::movcc_op3 &lt;&lt; 19) |
 2330              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2331              ($cmp$$cmpcode &lt;&lt; 14) |
 2332              (1 &lt;&lt; 13) |                    // select immediate move
 2333              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39;
 2334              (simm11 &lt;&lt; 0);
 2335     cbuf.insts()-&gt;emit_int32(op);
 2336   %}
 2337 
 2338   enc_class enc_cmov_reg_f( cmpOpF cmp, iRegI dst, iRegI src, flagsRegF fcc ) %{
 2339     int op = (Assembler::arith_op &lt;&lt; 30) |
 2340              ($dst$$reg &lt;&lt; 25) |
 2341              (Assembler::movcc_op3 &lt;&lt; 19) |
 2342              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2343              ($cmp$$cmpcode &lt;&lt; 14) |
 2344              (0 &lt;&lt; 13) |                    // select register move
 2345              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2346              ($src$$reg &lt;&lt; 0);
 2347     cbuf.insts()-&gt;emit_int32(op);
 2348   %}
 2349 
 2350   enc_class enc_cmov_imm_f( cmpOp cmp, iRegI dst, immI11 src, flagsRegF fcc ) %{
 2351     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2352     int op = (Assembler::arith_op &lt;&lt; 30) |
 2353              ($dst$$reg &lt;&lt; 25) |
 2354              (Assembler::movcc_op3 &lt;&lt; 19) |
 2355              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2356              ($cmp$$cmpcode &lt;&lt; 14) |
 2357              (1 &lt;&lt; 13) |                    // select immediate move
 2358              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2359              (simm11 &lt;&lt; 0);
 2360     cbuf.insts()-&gt;emit_int32(op);
 2361   %}
 2362 
 2363   enc_class enc_cmovf_reg( cmpOp cmp, regD dst, regD src, immI pcc ) %{
 2364     int op = (Assembler::arith_op &lt;&lt; 30) |
 2365              ($dst$$reg &lt;&lt; 25) |
 2366              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2367              (0 &lt;&lt; 18) |
 2368              ($cmp$$cmpcode &lt;&lt; 14) |
 2369              (1 &lt;&lt; 13) |                    // select register move
 2370              ($pcc$$constant &lt;&lt; 11) |       // cc1-cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2371              ($primary &lt;&lt; 5) |              // select single, double or quad
 2372              ($src$$reg &lt;&lt; 0);
 2373     cbuf.insts()-&gt;emit_int32(op);
 2374   %}
 2375 
 2376   enc_class enc_cmovff_reg( cmpOpF cmp, flagsRegF fcc, regD dst, regD src ) %{
 2377     int op = (Assembler::arith_op &lt;&lt; 30) |
 2378              ($dst$$reg &lt;&lt; 25) |
 2379              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2380              (0 &lt;&lt; 18) |
 2381              ($cmp$$cmpcode &lt;&lt; 14) |
 2382              ($fcc$$reg &lt;&lt; 11) |            // cc2-cc0 bits for &#39;fccX&#39;
 2383              ($primary &lt;&lt; 5) |              // select single, double or quad
 2384              ($src$$reg &lt;&lt; 0);
 2385     cbuf.insts()-&gt;emit_int32(op);
 2386   %}
 2387 
 2388   // Used by the MIN/MAX encodings.  Same as a CMOV, but
 2389   // the condition comes from opcode-field instead of an argument.
 2390   enc_class enc_cmov_reg_minmax( iRegI dst, iRegI src ) %{
 2391     int op = (Assembler::arith_op &lt;&lt; 30) |
 2392              ($dst$$reg &lt;&lt; 25) |
 2393              (Assembler::movcc_op3 &lt;&lt; 19) |
 2394              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2395              ($primary &lt;&lt; 14) |
 2396              (0 &lt;&lt; 13) |                    // select register move
 2397              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2398              ($src$$reg &lt;&lt; 0);
 2399     cbuf.insts()-&gt;emit_int32(op);
 2400   %}
 2401 
 2402   enc_class enc_cmov_reg_minmax_long( iRegL dst, iRegL src ) %{
 2403     int op = (Assembler::arith_op &lt;&lt; 30) |
 2404              ($dst$$reg &lt;&lt; 25) |
 2405              (Assembler::movcc_op3 &lt;&lt; 19) |
 2406              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2407              ($primary &lt;&lt; 14) |
 2408              (0 &lt;&lt; 13) |                    // select register move
 2409              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2410              ($src$$reg &lt;&lt; 0);
 2411     cbuf.insts()-&gt;emit_int32(op);
 2412   %}
 2413 
 2414   enc_class Set13( immI13 src, iRegI rd ) %{
 2415     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2416   %}
 2417 
 2418   enc_class SetHi22( immI src, iRegI rd ) %{
 2419     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2420   %}
 2421 
 2422   enc_class Set32( immI src, iRegI rd ) %{
 2423     MacroAssembler _masm(&amp;cbuf);
 2424     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2425   %}
 2426 
 2427   enc_class call_epilog %{
 2428     if( VerifyStackAtCalls ) {
 2429       MacroAssembler _masm(&amp;cbuf);
<a name="12" id="anc12"></a><span class="line-modified"> 2430       int framesize = ra_-&gt;C-&gt;frame_size_in_bytes();</span>
 2431       Register temp_reg = G3;
 2432       __ add(SP, framesize, temp_reg);
 2433       __ cmp(temp_reg, FP);
 2434       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2435     }
 2436   %}
 2437 
 2438   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2439   // to G1 so the register allocator will not have to deal with the misaligned register
 2440   // pair.
 2441   enc_class adjust_long_from_native_call %{
 2442   %}
 2443 
 2444   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2445     // CALL directly to the runtime
 2446     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2447     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2448   %}
 2449 
 2450   enc_class preserve_SP %{
 2451     MacroAssembler _masm(&amp;cbuf);
 2452     __ mov(SP, L7_mh_SP_save);
 2453   %}
 2454 
 2455   enc_class restore_SP %{
 2456     MacroAssembler _masm(&amp;cbuf);
 2457     __ mov(L7_mh_SP_save, SP);
 2458   %}
 2459 
 2460   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2461     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2462     // who we intended to call.
 2463     if (!_method) {
 2464       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2465     } else {
 2466       int method_index = resolved_method_index(cbuf);
 2467       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2468                                                   : static_call_Relocation::spec(method_index);
 2469       emit_call_reloc(cbuf, $meth$$method, rspec);
 2470 
 2471       // Emit stub for static call.
 2472       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2473       if (stub == NULL) {
 2474         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2475         return;
 2476       }
 2477     }
 2478   %}
 2479 
 2480   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 2481     MacroAssembler _masm(&amp;cbuf);
 2482     __ set_inst_mark();
 2483     int vtable_index = this-&gt;_vtable_index;
 2484     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2485     if (vtable_index &lt; 0) {
 2486       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2487       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2488       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2489       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2490       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2491       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2492     } else {
 2493       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2494       // Just go thru the vtable
 2495       // get receiver klass (receiver already checked for non-null)
 2496       // If we end up going thru a c2i adapter interpreter expects method in G5
 2497       int off = __ offset();
 2498       __ load_klass(O0, G3_scratch);
 2499       int klass_load_size;
 2500       if (UseCompressedClassPointers) {
 2501         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 2502         klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
 2503       } else {
 2504         klass_load_size = 1*BytesPerInstWord;
 2505       }
 2506       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
 2507       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 2508       if (Assembler::is_simm13(v_off)) {
 2509         __ ld_ptr(G3, v_off, G5_method);
 2510       } else {
 2511         // Generate 2 instructions
 2512         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2513         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2514         // ld_ptr, set_hi, set
 2515         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2516                &quot;Unexpected instruction size(s)&quot;);
 2517         __ ld_ptr(G3, G5_method, G5_method);
 2518       }
 2519       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2520       // However it may very well end up in handle_wrong_method if the
 2521       // method is abstract for the particular class.
 2522       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2523       // jump to target (either compiled code or c2iadapter)
 2524       __ jmpl(G3_scratch, G0, O7);
 2525       __ delayed()-&gt;nop();
 2526     }
 2527   %}
 2528 
 2529   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 2530     MacroAssembler _masm(&amp;cbuf);
 2531 
 2532     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2533     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2534                               // we might be calling a C2I adapter which needs it.
 2535 
 2536     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2537     // Load nmethod
 2538     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2539 
 2540     // CALL to compiled java, indirect the contents of G3
 2541     __ set_inst_mark();
 2542     __ callr(temp_reg, G0);
 2543     __ delayed()-&gt;nop();
 2544   %}
 2545 
 2546 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
 2547     MacroAssembler _masm(&amp;cbuf);
 2548     Register Rdividend = reg_to_register_object($src1$$reg);
 2549     Register Rdivisor = reg_to_register_object($src2$$reg);
 2550     Register Rresult = reg_to_register_object($dst$$reg);
 2551 
 2552     __ sra(Rdivisor, 0, Rdivisor);
 2553     __ sra(Rdividend, 0, Rdividend);
 2554     __ sdivx(Rdividend, Rdivisor, Rresult);
 2555 %}
 2556 
 2557 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
 2558     MacroAssembler _masm(&amp;cbuf);
 2559 
 2560     Register Rdividend = reg_to_register_object($src1$$reg);
 2561     int divisor = $imm$$constant;
 2562     Register Rresult = reg_to_register_object($dst$$reg);
 2563 
 2564     __ sra(Rdividend, 0, Rdividend);
 2565     __ sdivx(Rdividend, divisor, Rresult);
 2566 %}
 2567 
 2568 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
 2569     MacroAssembler _masm(&amp;cbuf);
 2570     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2571     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2572     Register Rdst  = reg_to_register_object($dst$$reg);
 2573 
 2574     __ sra( Rsrc1, 0, Rsrc1 );
 2575     __ sra( Rsrc2, 0, Rsrc2 );
 2576     __ mulx( Rsrc1, Rsrc2, Rdst );
 2577     __ srlx( Rdst, 32, Rdst );
 2578 %}
 2579 
 2580 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
 2581     MacroAssembler _masm(&amp;cbuf);
 2582     Register Rdividend = reg_to_register_object($src1$$reg);
 2583     Register Rdivisor = reg_to_register_object($src2$$reg);
 2584     Register Rresult = reg_to_register_object($dst$$reg);
 2585     Register Rscratch = reg_to_register_object($scratch$$reg);
 2586 
 2587     assert(Rdividend != Rscratch, &quot;&quot;);
 2588     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2589 
 2590     __ sra(Rdividend, 0, Rdividend);
 2591     __ sra(Rdivisor, 0, Rdivisor);
 2592     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2593     __ mulx(Rscratch, Rdivisor, Rscratch);
 2594     __ sub(Rdividend, Rscratch, Rresult);
 2595 %}
 2596 
 2597 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
 2598     MacroAssembler _masm(&amp;cbuf);
 2599 
 2600     Register Rdividend = reg_to_register_object($src1$$reg);
 2601     int divisor = $imm$$constant;
 2602     Register Rresult = reg_to_register_object($dst$$reg);
 2603     Register Rscratch = reg_to_register_object($scratch$$reg);
 2604 
 2605     assert(Rdividend != Rscratch, &quot;&quot;);
 2606 
 2607     __ sra(Rdividend, 0, Rdividend);
 2608     __ sdivx(Rdividend, divisor, Rscratch);
 2609     __ mulx(Rscratch, divisor, Rscratch);
 2610     __ sub(Rdividend, Rscratch, Rresult);
 2611 %}
 2612 
 2613 enc_class fabss (sflt_reg dst, sflt_reg src) %{
 2614     MacroAssembler _masm(&amp;cbuf);
 2615 
 2616     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2617     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2618 
 2619     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2620 %}
 2621 
 2622 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
 2623     MacroAssembler _masm(&amp;cbuf);
 2624 
 2625     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2626     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2627 
 2628     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2629 %}
 2630 
 2631 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
 2632     MacroAssembler _masm(&amp;cbuf);
 2633 
 2634     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2635     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2636 
 2637     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2638 %}
 2639 
 2640 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
 2641     MacroAssembler _masm(&amp;cbuf);
 2642 
 2643     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2644     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2645 
 2646     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2647 %}
 2648 
 2649 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
 2650     MacroAssembler _masm(&amp;cbuf);
 2651 
 2652     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2653     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2654 
 2655     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2656 %}
 2657 
 2658 
 2659 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2660     MacroAssembler _masm(&amp;cbuf);
 2661 
 2662     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2663     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2664     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2665     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2666 
 2667     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2668 %}
 2669 
 2670 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2671     MacroAssembler _masm(&amp;cbuf);
 2672 
 2673     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2674     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2675     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2676     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2677 
 2678     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2679 %}
 2680 
 2681 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2682     MacroAssembler _masm(&amp;cbuf);
 2683 
 2684     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2685     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2686     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2687     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2688 
 2689     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2690 %}
 2691 
 2692 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2693     MacroAssembler _masm(&amp;cbuf);
 2694 
 2695     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2696     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2697     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2698     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2699 
 2700     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2701 %}
 2702 
 2703 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2704     MacroAssembler _masm(&amp;cbuf);
 2705 
 2706     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2707     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2708     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2709     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2710 
 2711     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2712 %}
 2713 
 2714 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2715     MacroAssembler _masm(&amp;cbuf);
 2716 
 2717     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2718     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2719     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2720     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2721 
 2722     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2723 %}
 2724 
 2725 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2726     MacroAssembler _masm(&amp;cbuf);
 2727 
 2728     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2729     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2730     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2731     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2732 
 2733     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2734 %}
 2735 
 2736 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2737     MacroAssembler _masm(&amp;cbuf);
 2738 
 2739     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2740     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2741     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2742     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2743 
 2744     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2745 %}
 2746 
 2747 
 2748 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
 2749     MacroAssembler _masm(&amp;cbuf);
 2750 
 2751     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2752     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2753 
 2754     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2755 %}
 2756 
 2757 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
 2758     MacroAssembler _masm(&amp;cbuf);
 2759 
 2760     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2761     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2762 
 2763     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2764 %}
 2765 
 2766 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
 2767     MacroAssembler _masm(&amp;cbuf);
 2768 
 2769     Register Roop  = reg_to_register_object($oop$$reg);
 2770     Register Rbox  = reg_to_register_object($box$$reg);
 2771     Register Rscratch = reg_to_register_object($scratch$$reg);
 2772     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2773 
 2774     assert(Roop  != Rscratch, &quot;&quot;);
 2775     assert(Roop  != Rmark, &quot;&quot;);
 2776     assert(Rbox  != Rscratch, &quot;&quot;);
 2777     assert(Rbox  != Rmark, &quot;&quot;);
 2778 
 2779     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2780 %}
 2781 
 2782 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
 2783     MacroAssembler _masm(&amp;cbuf);
 2784 
 2785     Register Roop  = reg_to_register_object($oop$$reg);
 2786     Register Rbox  = reg_to_register_object($box$$reg);
 2787     Register Rscratch = reg_to_register_object($scratch$$reg);
 2788     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2789 
 2790     assert(Roop  != Rscratch, &quot;&quot;);
 2791     assert(Roop  != Rmark, &quot;&quot;);
 2792     assert(Rbox  != Rscratch, &quot;&quot;);
 2793     assert(Rbox  != Rmark, &quot;&quot;);
 2794 
 2795     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2796   %}
 2797 
 2798   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
 2799     MacroAssembler _masm(&amp;cbuf);
 2800     Register Rmem = reg_to_register_object($mem$$reg);
 2801     Register Rold = reg_to_register_object($old$$reg);
 2802     Register Rnew = reg_to_register_object($new$$reg);
 2803 
 2804     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2805     __ cmp( Rold, Rnew );
 2806   %}
 2807 
 2808   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2809     Register Rmem = reg_to_register_object($mem$$reg);
 2810     Register Rold = reg_to_register_object($old$$reg);
 2811     Register Rnew = reg_to_register_object($new$$reg);
 2812 
 2813     MacroAssembler _masm(&amp;cbuf);
 2814     __ mov(Rnew, O7);
 2815     __ casx(Rmem, Rold, O7);
 2816     __ cmp( Rold, O7 );
 2817   %}
 2818 
 2819   // raw int cas, used for compareAndSwap
 2820   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2821     Register Rmem = reg_to_register_object($mem$$reg);
 2822     Register Rold = reg_to_register_object($old$$reg);
 2823     Register Rnew = reg_to_register_object($new$$reg);
 2824 
 2825     MacroAssembler _masm(&amp;cbuf);
 2826     __ mov(Rnew, O7);
 2827     __ cas(Rmem, Rold, O7);
 2828     __ cmp( Rold, O7 );
 2829   %}
 2830 
 2831   // raw int cas without using tmp register for compareAndExchange
 2832   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2833     Register Rmem = reg_to_register_object($mem$$reg);
 2834     Register Rold = reg_to_register_object($old$$reg);
 2835     Register Rnew = reg_to_register_object($new$$reg);
 2836 
 2837     MacroAssembler _masm(&amp;cbuf);
 2838     __ cas(Rmem, Rold, Rnew);
 2839   %}
 2840 
 2841   // 64-bit cas without using tmp register for compareAndExchange
 2842   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2843     Register Rmem = reg_to_register_object($mem$$reg);
 2844     Register Rold = reg_to_register_object($old$$reg);
 2845     Register Rnew = reg_to_register_object($new$$reg);
 2846 
 2847     MacroAssembler _masm(&amp;cbuf);
 2848     __ casx(Rmem, Rold, Rnew);
 2849   %}
 2850 
 2851   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2852     Register Rres = reg_to_register_object($res$$reg);
 2853 
 2854     MacroAssembler _masm(&amp;cbuf);
 2855     __ mov(1, Rres);
 2856     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2857   %}
 2858 
 2859   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2860     Register Rres = reg_to_register_object($res$$reg);
 2861 
 2862     MacroAssembler _masm(&amp;cbuf);
 2863     __ mov(1, Rres);
 2864     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2865   %}
 2866 
 2867   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
 2868     MacroAssembler _masm(&amp;cbuf);
 2869     Register Rdst = reg_to_register_object($dst$$reg);
 2870     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2871                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2872     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2873                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2874 
 2875     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2876     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2877   %}
 2878 
 2879   enc_class enc_rethrow() %{
 2880     cbuf.set_insts_mark();
 2881     Register temp_reg = G3;
 2882     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2883     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
 2884     MacroAssembler _masm(&amp;cbuf);
 2885 #ifdef ASSERT
 2886     __ save_frame(0);
 2887     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2888     __ sethi(last_rethrow_addrlit, L1);
 2889     Address addr(L1, last_rethrow_addrlit.low10());
 2890     __ rdpc(L2);
 2891     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2892     __ st_ptr(L2, addr);
 2893     __ restore();
 2894 #endif
 2895     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2896     __ delayed()-&gt;nop();
 2897   %}
 2898 
 2899   enc_class emit_mem_nop() %{
 2900     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2901     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2902   %}
 2903 
 2904   enc_class emit_fadd_nop() %{
 2905     // Generates the instruction FMOVS f31,f31
 2906     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2907   %}
 2908 
 2909   enc_class emit_br_nop() %{
 2910     // Generates the instruction BPN,PN .
 2911     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2912   %}
 2913 
 2914   enc_class enc_membar_acquire %{
 2915     MacroAssembler _masm(&amp;cbuf);
 2916     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2917   %}
 2918 
 2919   enc_class enc_membar_release %{
 2920     MacroAssembler _masm(&amp;cbuf);
 2921     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2922   %}
 2923 
 2924   enc_class enc_membar_volatile %{
 2925     MacroAssembler _masm(&amp;cbuf);
 2926     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2927   %}
 2928 
 2929 %}
 2930 
 2931 //----------FRAME--------------------------------------------------------------
 2932 // Definition of frame structure and management information.
 2933 //
 2934 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2935 //                             |   (to get allocators register number
 2936 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2937 //  r   CALLER     |        |
 2938 //  o     |        +--------+      pad to even-align allocators stack-slot
 2939 //  w     V        |  pad0  |        numbers; owned by CALLER
 2940 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2941 //  h     ^        |   in   |  5
 2942 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2943 //  |     |        |        |  3
 2944 //  |     |        +--------+
 2945 //  V     |        | old out|      Empty on Intel, window on Sparc
 2946 //        |    old |preserve|      Must be even aligned.
 2947 //        |     SP-+--------+----&gt; Matcher::_old_SP, 8 (or 16 in LP64)-byte aligned
 2948 //        |        |   in   |  3   area for Intel ret address
 2949 //     Owned by    |preserve|      Empty on Sparc.
 2950 //       SELF      +--------+
 2951 //        |        |  pad2  |  2   pad to align old SP
 2952 //        |        +--------+  1
 2953 //        |        | locks  |  0
 2954 //        |        +--------+----&gt; VMRegImpl::stack0, 8 (or 16 in LP64)-byte aligned
 2955 //        |        |  pad1  | 11   pad to align new SP
 2956 //        |        +--------+
 2957 //        |        |        | 10
 2958 //        |        | spills |  9   spills
 2959 //        V        |        |  8   (pad0 slot for callee)
 2960 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2961 //        ^        |  out   |  7
 2962 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2963 //     Owned by    +--------+
 2964 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2965 //        |    new |preserve|      Must be even-aligned.
 2966 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2967 //        |        |        |
 2968 //
 2969 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2970 //         known from SELF&#39;s arguments and the Java calling convention.
 2971 //         Region 6-7 is determined per call site.
 2972 // Note 2: If the calling convention leaves holes in the incoming argument
 2973 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2974 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2975 //         incoming area, as the Java calling convention is completely under
 2976 //         the control of the AD file.  Doubles can be sorted and packed to
 2977 //         avoid holes.  Holes in the outgoing arguments may be necessary for
 2978 //         varargs C calling conventions.
 2979 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2980 //         even aligned with pad0 as needed.
 2981 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2982 //         region 6-11 is even aligned; it may be padded out more so that
 2983 //         the region from SP to FP meets the minimum stack alignment.
 2984 
 2985 frame %{
 2986   // What direction does stack grow in (assumed to be same for native &amp; Java)
 2987   stack_direction(TOWARDS_LOW);
 2988 
 2989   // These two registers define part of the calling convention
 2990   // between compiled code and the interpreter.
 2991   inline_cache_reg(R_G5);                // Inline Cache Register or Method* for I2C
 2992   interpreter_method_oop_reg(R_G5);      // Method Oop Register when calling interpreter
 2993 
 2994   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 2995   cisc_spilling_operand_name(indOffset);
 2996 
 2997   // Number of stack slots consumed by a Monitor enter
 2998   sync_stack_slots(2);
 2999 
 3000   // Compiled code&#39;s Frame Pointer
 3001   frame_pointer(R_SP);
 3002 
 3003   // Stack alignment requirement
 3004   stack_alignment(StackAlignmentInBytes);
 3005   //  LP64: Alignment size in bytes (128-bit -&gt; 16 bytes)
 3006   // !LP64: Alignment size in bytes (64-bit  -&gt;  8 bytes)
 3007 
 3008   // Number of stack slots between incoming argument block and the start of
 3009   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3010   // EPILOG must remove this many slots.
 3011   in_preserve_stack_slots(0);
 3012 
 3013   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3014   // for calls to C.  Supports the var-args backing area for register parms.
 3015   // ADLC doesn&#39;t support parsing expressions, so I folded the math by hand.
 3016   // (callee_register_argument_save_area_words (6) + callee_aggregate_return_pointer_words (0)) * 2-stack-slots-per-word
 3017   varargs_C_out_slots_killed(12);
 3018 
 3019   // The after-PROLOG location of the return address.  Location of
 3020   // return address specifies a type (REG or STACK) and a number
 3021   // representing the register number (i.e. - use a register name) or
 3022   // stack slot.
 3023   return_addr(REG R_I7);          // Ret Addr is in register I7
 3024 
 3025   // Body of function which returns an OptoRegs array locating
 3026   // arguments either in registers or in stack slots for calling
 3027   // java
 3028   calling_convention %{
 3029     (void) SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);
 3030 
 3031   %}
 3032 
 3033   // Body of function which returns an OptoRegs array locating
 3034   // arguments either in registers or in stack slots for calling
 3035   // C.
 3036   c_calling_convention %{
 3037     // This is obviously always outgoing
 3038     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3039   %}
 3040 
 3041   // Location of native (C/C++) and interpreter return values.  This is specified to
 3042   // be the  same as Java.  In the 32-bit VM, long values are actually returned from
 3043   // native calls in O0:O1 and returned to the interpreter in I0:I1.  The copying
 3044   // to and from the register pairs is done by the appropriate call and epilog
 3045   // opcodes.  This simplifies the register allocator.
 3046   c_return_value %{
 3047     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3048     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3049     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3050     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3051     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3052     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3053                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3054   %}
 3055 
 3056   // Location of compiled Java return values.  Same as C
 3057   return_value %{
 3058     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3059     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3060     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3061     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3062     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3063     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3064                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3065   %}
 3066 
 3067 %}
 3068 
 3069 
 3070 //----------ATTRIBUTES---------------------------------------------------------
 3071 //----------Operand Attributes-------------------------------------------------
 3072 op_attrib op_cost(1);          // Required cost attribute
 3073 
 3074 //----------Instruction Attributes---------------------------------------------
 3075 ins_attrib ins_cost(DEFAULT_COST); // Required cost attribute
 3076 ins_attrib ins_size(32);           // Required size attribute (in bits)
 3077 
 3078 // avoid_back_to_back attribute is an expression that must return
 3079 // one of the following values defined in MachNode:
 3080 // AVOID_NONE   - instruction can be placed anywhere
 3081 // AVOID_BEFORE - instruction cannot be placed after an
 3082 //                instruction with MachNode::AVOID_AFTER
 3083 // AVOID_AFTER  - the next instruction cannot be the one
 3084 //                with MachNode::AVOID_BEFORE
 3085 // AVOID_BEFORE_AND_AFTER - BEFORE and AFTER attributes at
 3086 //                          the same time
 3087 ins_attrib ins_avoid_back_to_back(MachNode::AVOID_NONE);
 3088 
 3089 ins_attrib ins_short_branch(0);    // Required flag: is this instruction a
 3090                                    // non-matching short branch variant of some
 3091                                                             // long branch?
 3092 
 3093 //----------OPERANDS-----------------------------------------------------------
 3094 // Operand definitions must precede instruction definitions for correct parsing
 3095 // in the ADLC because operands constitute user defined types which are used in
 3096 // instruction definitions.
 3097 
 3098 //----------Simple Operands----------------------------------------------------
 3099 // Immediate Operands
 3100 // Integer Immediate: 32-bit
 3101 operand immI() %{
 3102   match(ConI);
 3103 
 3104   op_cost(0);
 3105   // formats are generated automatically for constants and base registers
 3106   format %{ %}
 3107   interface(CONST_INTER);
 3108 %}
 3109 
 3110 // Integer Immediate: 0-bit
 3111 operand immI0() %{
 3112   predicate(n-&gt;get_int() == 0);
 3113   match(ConI);
 3114   op_cost(0);
 3115 
 3116   format %{ %}
 3117   interface(CONST_INTER);
 3118 %}
 3119 
 3120 // Integer Immediate: 5-bit
 3121 operand immI5() %{
 3122   predicate(Assembler::is_simm5(n-&gt;get_int()));
 3123   match(ConI);
 3124   op_cost(0);
 3125   format %{ %}
 3126   interface(CONST_INTER);
 3127 %}
 3128 
 3129 // Integer Immediate: 8-bit
 3130 operand immI8() %{
 3131   predicate(Assembler::is_simm8(n-&gt;get_int()));
 3132   match(ConI);
 3133   op_cost(0);
 3134   format %{ %}
 3135   interface(CONST_INTER);
 3136 %}
 3137 
 3138 // Integer Immediate: the value 10
 3139 operand immI10() %{
 3140   predicate(n-&gt;get_int() == 10);
 3141   match(ConI);
 3142   op_cost(0);
 3143 
 3144   format %{ %}
 3145   interface(CONST_INTER);
 3146 %}
 3147 
 3148 // Integer Immediate: 11-bit
 3149 operand immI11() %{
 3150   predicate(Assembler::is_simm11(n-&gt;get_int()));
 3151   match(ConI);
 3152   op_cost(0);
 3153   format %{ %}
 3154   interface(CONST_INTER);
 3155 %}
 3156 
 3157 // Integer Immediate: 13-bit
 3158 operand immI13() %{
 3159   predicate(Assembler::is_simm13(n-&gt;get_int()));
 3160   match(ConI);
 3161   op_cost(0);
 3162 
 3163   format %{ %}
 3164   interface(CONST_INTER);
 3165 %}
 3166 
 3167 // Integer Immediate: 13-bit minus 7
 3168 operand immI13m7() %{
 3169   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; ((n-&gt;get_int() + 7) &lt;= 4095));
 3170   match(ConI);
 3171   op_cost(0);
 3172 
 3173   format %{ %}
 3174   interface(CONST_INTER);
 3175 %}
 3176 
 3177 // Integer Immediate: 16-bit
 3178 operand immI16() %{
 3179   predicate(Assembler::is_simm16(n-&gt;get_int()));
 3180   match(ConI);
 3181   op_cost(0);
 3182   format %{ %}
 3183   interface(CONST_INTER);
 3184 %}
 3185 
 3186 // Integer Immediate: the values 1-31
 3187 operand immI_1_31() %{
 3188   predicate(n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3189   match(ConI);
 3190   op_cost(0);
 3191 
 3192   format %{ %}
 3193   interface(CONST_INTER);
 3194 %}
 3195 
 3196 // Integer Immediate: the values 32-63
 3197 operand immI_32_63() %{
 3198   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3199   match(ConI);
 3200   op_cost(0);
 3201 
 3202   format %{ %}
 3203   interface(CONST_INTER);
 3204 %}
 3205 
 3206 // Immediates for special shifts (sign extend)
 3207 
 3208 // Integer Immediate: the value 16
 3209 operand immI_16() %{
 3210   predicate(n-&gt;get_int() == 16);
 3211   match(ConI);
 3212   op_cost(0);
 3213 
 3214   format %{ %}
 3215   interface(CONST_INTER);
 3216 %}
 3217 
 3218 // Integer Immediate: the value 24
 3219 operand immI_24() %{
 3220   predicate(n-&gt;get_int() == 24);
 3221   match(ConI);
 3222   op_cost(0);
 3223 
 3224   format %{ %}
 3225   interface(CONST_INTER);
 3226 %}
 3227 // Integer Immediate: the value 255
 3228 operand immI_255() %{
 3229   predicate( n-&gt;get_int() == 255 );
 3230   match(ConI);
 3231   op_cost(0);
 3232 
 3233   format %{ %}
 3234   interface(CONST_INTER);
 3235 %}
 3236 
 3237 // Integer Immediate: the value 65535
 3238 operand immI_65535() %{
 3239   predicate(n-&gt;get_int() == 65535);
 3240   match(ConI);
 3241   op_cost(0);
 3242 
 3243   format %{ %}
 3244   interface(CONST_INTER);
 3245 %}
 3246 
 3247 // Integer Immediate: the values 0-31
 3248 operand immU5() %{
 3249   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3250   match(ConI);
 3251   op_cost(0);
 3252 
 3253   format %{ %}
 3254   interface(CONST_INTER);
 3255 %}
 3256 
 3257 // Integer Immediate: 6-bit
 3258 operand immU6() %{
 3259   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3260   match(ConI);
 3261   op_cost(0);
 3262   format %{ %}
 3263   interface(CONST_INTER);
 3264 %}
 3265 
 3266 // Unsigned Integer Immediate: 12-bit (non-negative that fits in simm13)
 3267 operand immU12() %{
 3268   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; Assembler::is_simm13(n-&gt;get_int()));
 3269   match(ConI);
 3270   op_cost(0);
 3271 
 3272   format %{ %}
 3273   interface(CONST_INTER);
 3274 %}
 3275 
 3276 // Unsigned Long Immediate: 12-bit (non-negative that fits in simm13)
 3277 operand immUL12() %{
 3278   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() == (int)n-&gt;get_long()) &amp;&amp; Assembler::is_simm13((int)n-&gt;get_long()));
 3279   match(ConL);
 3280   op_cost(0);
 3281 
 3282   format %{ %}
 3283   interface(CONST_INTER);
 3284 %}
 3285 
 3286 // Integer Immediate non-negative
 3287 operand immU31()
 3288 %{
 3289   predicate(n-&gt;get_int() &gt;= 0);
 3290   match(ConI);
 3291 
 3292   op_cost(0);
 3293   format %{ %}
 3294   interface(CONST_INTER);
 3295 %}
 3296 
 3297 // Long Immediate: the value FF
 3298 operand immL_FF() %{
 3299   predicate( n-&gt;get_long() == 0xFFL );
 3300   match(ConL);
 3301   op_cost(0);
 3302 
 3303   format %{ %}
 3304   interface(CONST_INTER);
 3305 %}
 3306 
 3307 // Long Immediate: the value FFFF
 3308 operand immL_FFFF() %{
 3309   predicate( n-&gt;get_long() == 0xFFFFL );
 3310   match(ConL);
 3311   op_cost(0);
 3312 
 3313   format %{ %}
 3314   interface(CONST_INTER);
 3315 %}
 3316 
 3317 // Pointer Immediate: 32 or 64-bit
 3318 operand immP() %{
 3319   match(ConP);
 3320 
 3321   op_cost(5);
 3322   // formats are generated automatically for constants and base registers
 3323   format %{ %}
 3324   interface(CONST_INTER);
 3325 %}
 3326 
 3327 // Pointer Immediate: 64-bit
 3328 operand immP_set() %{
 3329   predicate(!VM_Version::has_fast_ld());
 3330   match(ConP);
 3331 
 3332   op_cost(5);
 3333   // formats are generated automatically for constants and base registers
 3334   format %{ %}
 3335   interface(CONST_INTER);
 3336 %}
 3337 
 3338 // Pointer Immediate: 64-bit
 3339 // From Niagara2 processors on a load should be better than materializing.
 3340 operand immP_load() %{
 3341   predicate(VM_Version::has_fast_ld() &amp;&amp; (n-&gt;bottom_type()-&gt;isa_oop_ptr() || (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &gt; 3)));
 3342   match(ConP);
 3343 
 3344   op_cost(5);
 3345   // formats are generated automatically for constants and base registers
 3346   format %{ %}
 3347   interface(CONST_INTER);
 3348 %}
 3349 
 3350 // Pointer Immediate: 64-bit
 3351 operand immP_no_oop_cheap() %{
 3352   predicate(VM_Version::has_fast_ld() &amp;&amp; !n-&gt;bottom_type()-&gt;isa_oop_ptr() &amp;&amp; (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &lt;= 3));
 3353   match(ConP);
 3354 
 3355   op_cost(5);
 3356   // formats are generated automatically for constants and base registers
 3357   format %{ %}
 3358   interface(CONST_INTER);
 3359 %}
 3360 
 3361 operand immP13() %{
 3362   predicate((-4096 &lt; n-&gt;get_ptr()) &amp;&amp; (n-&gt;get_ptr() &lt;= 4095));
 3363   match(ConP);
 3364   op_cost(0);
 3365 
 3366   format %{ %}
 3367   interface(CONST_INTER);
 3368 %}
 3369 
 3370 operand immP0() %{
 3371   predicate(n-&gt;get_ptr() == 0);
 3372   match(ConP);
 3373   op_cost(0);
 3374 
 3375   format %{ %}
 3376   interface(CONST_INTER);
 3377 %}
 3378 
 3379 operand immP_poll() %{
 3380   predicate(n-&gt;get_ptr() != 0 &amp;&amp; n-&gt;get_ptr() == (intptr_t)os::get_polling_page());
 3381   match(ConP);
 3382 
 3383   // formats are generated automatically for constants and base registers
 3384   format %{ %}
 3385   interface(CONST_INTER);
 3386 %}
 3387 
 3388 // Pointer Immediate
 3389 operand immN()
 3390 %{
 3391   match(ConN);
 3392 
 3393   op_cost(10);
 3394   format %{ %}
 3395   interface(CONST_INTER);
 3396 %}
 3397 
 3398 operand immNKlass()
 3399 %{
 3400   match(ConNKlass);
 3401 
 3402   op_cost(10);
 3403   format %{ %}
 3404   interface(CONST_INTER);
 3405 %}
 3406 
 3407 // NULL Pointer Immediate
 3408 operand immN0()
 3409 %{
 3410   predicate(n-&gt;get_narrowcon() == 0);
 3411   match(ConN);
 3412 
 3413   op_cost(0);
 3414   format %{ %}
 3415   interface(CONST_INTER);
 3416 %}
 3417 
 3418 operand immL() %{
 3419   match(ConL);
 3420   op_cost(40);
 3421   // formats are generated automatically for constants and base registers
 3422   format %{ %}
 3423   interface(CONST_INTER);
 3424 %}
 3425 
 3426 operand immL0() %{
 3427   predicate(n-&gt;get_long() == 0L);
 3428   match(ConL);
 3429   op_cost(0);
 3430   // formats are generated automatically for constants and base registers
 3431   format %{ %}
 3432   interface(CONST_INTER);
 3433 %}
 3434 
 3435 // Integer Immediate: 5-bit
 3436 operand immL5() %{
 3437   predicate(n-&gt;get_long() == (int)n-&gt;get_long() &amp;&amp; Assembler::is_simm5((int)n-&gt;get_long()));
 3438   match(ConL);
 3439   op_cost(0);
 3440   format %{ %}
 3441   interface(CONST_INTER);
 3442 %}
 3443 
 3444 // Long Immediate: 13-bit
 3445 operand immL13() %{
 3446   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 4095L));
 3447   match(ConL);
 3448   op_cost(0);
 3449 
 3450   format %{ %}
 3451   interface(CONST_INTER);
 3452 %}
 3453 
 3454 // Long Immediate: 13-bit minus 7
 3455 operand immL13m7() %{
 3456   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; ((n-&gt;get_long() + 7L) &lt;= 4095L));
 3457   match(ConL);
 3458   op_cost(0);
 3459 
 3460   format %{ %}
 3461   interface(CONST_INTER);
 3462 %}
 3463 
 3464 // Long Immediate: low 32-bit mask
 3465 operand immL_32bits() %{
 3466   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3467   match(ConL);
 3468   op_cost(0);
 3469 
 3470   format %{ %}
 3471   interface(CONST_INTER);
 3472 %}
 3473 
 3474 // Long Immediate: cheap (materialize in &lt;= 3 instructions)
 3475 operand immL_cheap() %{
 3476   predicate(!VM_Version::has_fast_ld() || MacroAssembler::insts_for_set64(n-&gt;get_long()) &lt;= 3);
 3477   match(ConL);
 3478   op_cost(0);
 3479 
 3480   format %{ %}
 3481   interface(CONST_INTER);
 3482 %}
 3483 
 3484 // Long Immediate: expensive (materialize in &gt; 3 instructions)
 3485 operand immL_expensive() %{
 3486   predicate(VM_Version::has_fast_ld() &amp;&amp; MacroAssembler::insts_for_set64(n-&gt;get_long()) &gt; 3);
 3487   match(ConL);
 3488   op_cost(0);
 3489 
 3490   format %{ %}
 3491   interface(CONST_INTER);
 3492 %}
 3493 
 3494 // Double Immediate
 3495 operand immD() %{
 3496   match(ConD);
 3497 
 3498   op_cost(40);
 3499   format %{ %}
 3500   interface(CONST_INTER);
 3501 %}
 3502 
 3503 // Double Immediate: +0.0d
 3504 operand immD0() %{
 3505   predicate(jlong_cast(n-&gt;getd()) == 0);
 3506   match(ConD);
 3507 
 3508   op_cost(0);
 3509   format %{ %}
 3510   interface(CONST_INTER);
 3511 %}
 3512 
 3513 // Float Immediate
 3514 operand immF() %{
 3515   match(ConF);
 3516 
 3517   op_cost(20);
 3518   format %{ %}
 3519   interface(CONST_INTER);
 3520 %}
 3521 
 3522 // Float Immediate: +0.0f
 3523 operand immF0() %{
 3524   predicate(jint_cast(n-&gt;getf()) == 0);
 3525   match(ConF);
 3526 
 3527   op_cost(0);
 3528   format %{ %}
 3529   interface(CONST_INTER);
 3530 %}
 3531 
 3532 // Integer Register Operands
 3533 // Integer Register
 3534 operand iRegI() %{
 3535   constraint(ALLOC_IN_RC(int_reg));
 3536   match(RegI);
 3537 
 3538   match(notemp_iRegI);
 3539   match(g1RegI);
 3540   match(o0RegI);
 3541   match(iRegIsafe);
 3542 
 3543   format %{ %}
 3544   interface(REG_INTER);
 3545 %}
 3546 
 3547 operand notemp_iRegI() %{
 3548   constraint(ALLOC_IN_RC(notemp_int_reg));
 3549   match(RegI);
 3550 
 3551   match(o0RegI);
 3552 
 3553   format %{ %}
 3554   interface(REG_INTER);
 3555 %}
 3556 
 3557 operand o0RegI() %{
 3558   constraint(ALLOC_IN_RC(o0_regI));
 3559   match(iRegI);
 3560 
 3561   format %{ %}
 3562   interface(REG_INTER);
 3563 %}
 3564 
 3565 // Pointer Register
 3566 operand iRegP() %{
 3567   constraint(ALLOC_IN_RC(ptr_reg));
 3568   match(RegP);
 3569 
 3570   match(lock_ptr_RegP);
 3571   match(g1RegP);
 3572   match(g2RegP);
 3573   match(g3RegP);
 3574   match(g4RegP);
 3575   match(i0RegP);
 3576   match(o0RegP);
 3577   match(o1RegP);
 3578   match(l7RegP);
 3579 
 3580   format %{ %}
 3581   interface(REG_INTER);
 3582 %}
 3583 
 3584 operand sp_ptr_RegP() %{
 3585   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3586   match(RegP);
 3587   match(iRegP);
 3588 
 3589   format %{ %}
 3590   interface(REG_INTER);
 3591 %}
 3592 
 3593 operand lock_ptr_RegP() %{
 3594   constraint(ALLOC_IN_RC(lock_ptr_reg));
 3595   match(RegP);
 3596   match(i0RegP);
 3597   match(o0RegP);
 3598   match(o1RegP);
 3599   match(l7RegP);
 3600 
 3601   format %{ %}
 3602   interface(REG_INTER);
 3603 %}
 3604 
 3605 operand g1RegP() %{
 3606   constraint(ALLOC_IN_RC(g1_regP));
 3607   match(iRegP);
 3608 
 3609   format %{ %}
 3610   interface(REG_INTER);
 3611 %}
 3612 
 3613 operand g2RegP() %{
 3614   constraint(ALLOC_IN_RC(g2_regP));
 3615   match(iRegP);
 3616 
 3617   format %{ %}
 3618   interface(REG_INTER);
 3619 %}
 3620 
 3621 operand g3RegP() %{
 3622   constraint(ALLOC_IN_RC(g3_regP));
 3623   match(iRegP);
 3624 
 3625   format %{ %}
 3626   interface(REG_INTER);
 3627 %}
 3628 
 3629 operand g1RegI() %{
 3630   constraint(ALLOC_IN_RC(g1_regI));
 3631   match(iRegI);
 3632 
 3633   format %{ %}
 3634   interface(REG_INTER);
 3635 %}
 3636 
 3637 operand g3RegI() %{
 3638   constraint(ALLOC_IN_RC(g3_regI));
 3639   match(iRegI);
 3640 
 3641   format %{ %}
 3642   interface(REG_INTER);
 3643 %}
 3644 
 3645 operand g4RegI() %{
 3646   constraint(ALLOC_IN_RC(g4_regI));
 3647   match(iRegI);
 3648 
 3649   format %{ %}
 3650   interface(REG_INTER);
 3651 %}
 3652 
 3653 operand g4RegP() %{
 3654   constraint(ALLOC_IN_RC(g4_regP));
 3655   match(iRegP);
 3656 
 3657   format %{ %}
 3658   interface(REG_INTER);
 3659 %}
 3660 
 3661 operand i0RegP() %{
 3662   constraint(ALLOC_IN_RC(i0_regP));
 3663   match(iRegP);
 3664 
 3665   format %{ %}
 3666   interface(REG_INTER);
 3667 %}
 3668 
 3669 operand o0RegP() %{
 3670   constraint(ALLOC_IN_RC(o0_regP));
 3671   match(iRegP);
 3672 
 3673   format %{ %}
 3674   interface(REG_INTER);
 3675 %}
 3676 
 3677 operand o1RegP() %{
 3678   constraint(ALLOC_IN_RC(o1_regP));
 3679   match(iRegP);
 3680 
 3681   format %{ %}
 3682   interface(REG_INTER);
 3683 %}
 3684 
 3685 operand o2RegP() %{
 3686   constraint(ALLOC_IN_RC(o2_regP));
 3687   match(iRegP);
 3688 
 3689   format %{ %}
 3690   interface(REG_INTER);
 3691 %}
 3692 
 3693 operand o7RegP() %{
 3694   constraint(ALLOC_IN_RC(o7_regP));
 3695   match(iRegP);
 3696 
 3697   format %{ %}
 3698   interface(REG_INTER);
 3699 %}
 3700 
 3701 operand l7RegP() %{
 3702   constraint(ALLOC_IN_RC(l7_regP));
 3703   match(iRegP);
 3704 
 3705   format %{ %}
 3706   interface(REG_INTER);
 3707 %}
 3708 
 3709 operand o7RegI() %{
 3710   constraint(ALLOC_IN_RC(o7_regI));
 3711   match(iRegI);
 3712 
 3713   format %{ %}
 3714   interface(REG_INTER);
 3715 %}
 3716 
 3717 operand iRegN() %{
 3718   constraint(ALLOC_IN_RC(int_reg));
 3719   match(RegN);
 3720 
 3721   format %{ %}
 3722   interface(REG_INTER);
 3723 %}
 3724 
 3725 // Long Register
 3726 operand iRegL() %{
 3727   constraint(ALLOC_IN_RC(long_reg));
 3728   match(RegL);
 3729 
 3730   format %{ %}
 3731   interface(REG_INTER);
 3732 %}
 3733 
 3734 operand o2RegL() %{
 3735   constraint(ALLOC_IN_RC(o2_regL));
 3736   match(iRegL);
 3737 
 3738   format %{ %}
 3739   interface(REG_INTER);
 3740 %}
 3741 
 3742 operand o7RegL() %{
 3743   constraint(ALLOC_IN_RC(o7_regL));
 3744   match(iRegL);
 3745 
 3746   format %{ %}
 3747   interface(REG_INTER);
 3748 %}
 3749 
 3750 operand g1RegL() %{
 3751   constraint(ALLOC_IN_RC(g1_regL));
 3752   match(iRegL);
 3753 
 3754   format %{ %}
 3755   interface(REG_INTER);
 3756 %}
 3757 
 3758 operand g3RegL() %{
 3759   constraint(ALLOC_IN_RC(g3_regL));
 3760   match(iRegL);
 3761 
 3762   format %{ %}
 3763   interface(REG_INTER);
 3764 %}
 3765 
 3766 // Int Register safe
 3767 // This is 64bit safe
 3768 operand iRegIsafe() %{
 3769   constraint(ALLOC_IN_RC(long_reg));
 3770 
 3771   match(iRegI);
 3772 
 3773   format %{ %}
 3774   interface(REG_INTER);
 3775 %}
 3776 
 3777 // Condition Code Flag Register
 3778 operand flagsReg() %{
 3779   constraint(ALLOC_IN_RC(int_flags));
 3780   match(RegFlags);
 3781 
 3782   format %{ &quot;ccr&quot; %} // both ICC and XCC
 3783   interface(REG_INTER);
 3784 %}
 3785 
 3786 // Condition Code Register, unsigned comparisons.
 3787 operand flagsRegU() %{
 3788   constraint(ALLOC_IN_RC(int_flags));
 3789   match(RegFlags);
 3790 
 3791   format %{ &quot;icc_U&quot; %}
 3792   interface(REG_INTER);
 3793 %}
 3794 
 3795 // Condition Code Register, pointer comparisons.
 3796 operand flagsRegP() %{
 3797   constraint(ALLOC_IN_RC(int_flags));
 3798   match(RegFlags);
 3799 
 3800   format %{ &quot;xcc_P&quot; %}
 3801   interface(REG_INTER);
 3802 %}
 3803 
 3804 // Condition Code Register, long comparisons.
 3805 operand flagsRegL() %{
 3806   constraint(ALLOC_IN_RC(int_flags));
 3807   match(RegFlags);
 3808 
 3809   format %{ &quot;xcc_L&quot; %}
 3810   interface(REG_INTER);
 3811 %}
 3812 
 3813 // Condition Code Register, unsigned long comparisons.
 3814 operand flagsRegUL() %{
 3815   constraint(ALLOC_IN_RC(int_flags));
 3816   match(RegFlags);
 3817 
 3818   format %{ &quot;xcc_UL&quot; %}
 3819   interface(REG_INTER);
 3820 %}
 3821 
 3822 // Condition Code Register, floating comparisons, unordered same as &quot;less&quot;.
 3823 operand flagsRegF() %{
 3824   constraint(ALLOC_IN_RC(float_flags));
 3825   match(RegFlags);
 3826   match(flagsRegF0);
 3827 
 3828   format %{ %}
 3829   interface(REG_INTER);
 3830 %}
 3831 
 3832 operand flagsRegF0() %{
 3833   constraint(ALLOC_IN_RC(float_flag0));
 3834   match(RegFlags);
 3835 
 3836   format %{ %}
 3837   interface(REG_INTER);
 3838 %}
 3839 
 3840 
 3841 // Condition Code Flag Register used by long compare
 3842 operand flagsReg_long_LTGE() %{
 3843   constraint(ALLOC_IN_RC(int_flags));
 3844   match(RegFlags);
 3845   format %{ &quot;icc_LTGE&quot; %}
 3846   interface(REG_INTER);
 3847 %}
 3848 operand flagsReg_long_EQNE() %{
 3849   constraint(ALLOC_IN_RC(int_flags));
 3850   match(RegFlags);
 3851   format %{ &quot;icc_EQNE&quot; %}
 3852   interface(REG_INTER);
 3853 %}
 3854 operand flagsReg_long_LEGT() %{
 3855   constraint(ALLOC_IN_RC(int_flags));
 3856   match(RegFlags);
 3857   format %{ &quot;icc_LEGT&quot; %}
 3858   interface(REG_INTER);
 3859 %}
 3860 
 3861 
 3862 operand regD() %{
 3863   constraint(ALLOC_IN_RC(dflt_reg));
 3864   match(RegD);
 3865 
 3866   match(regD_low);
 3867 
 3868   format %{ %}
 3869   interface(REG_INTER);
 3870 %}
 3871 
 3872 operand regF() %{
 3873   constraint(ALLOC_IN_RC(sflt_reg));
 3874   match(RegF);
 3875 
 3876   format %{ %}
 3877   interface(REG_INTER);
 3878 %}
 3879 
 3880 operand regD_low() %{
 3881   constraint(ALLOC_IN_RC(dflt_low_reg));
 3882   match(regD);
 3883 
 3884   format %{ %}
 3885   interface(REG_INTER);
 3886 %}
 3887 
 3888 // Special Registers
 3889 
 3890 // Method Register
 3891 operand inline_cache_regP(iRegP reg) %{
 3892   constraint(ALLOC_IN_RC(g5_regP)); // G5=inline_cache_reg but uses 2 bits instead of 1
 3893   match(reg);
 3894   format %{ %}
 3895   interface(REG_INTER);
 3896 %}
 3897 
 3898 operand interpreter_method_oop_regP(iRegP reg) %{
 3899   constraint(ALLOC_IN_RC(g5_regP)); // G5=interpreter_method_oop_reg but uses 2 bits instead of 1
 3900   match(reg);
 3901   format %{ %}
 3902   interface(REG_INTER);
 3903 %}
 3904 
 3905 
 3906 //----------Complex Operands---------------------------------------------------
 3907 // Indirect Memory Reference
 3908 operand indirect(sp_ptr_RegP reg) %{
 3909   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3910   match(reg);
 3911 
 3912   op_cost(100);
 3913   format %{ &quot;[$reg]&quot; %}
 3914   interface(MEMORY_INTER) %{
 3915     base($reg);
 3916     index(0x0);
 3917     scale(0x0);
 3918     disp(0x0);
 3919   %}
 3920 %}
 3921 
 3922 // Indirect with simm13 Offset
 3923 operand indOffset13(sp_ptr_RegP reg, immX13 offset) %{
 3924   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3925   match(AddP reg offset);
 3926 
 3927   op_cost(100);
 3928   format %{ &quot;[$reg + $offset]&quot; %}
 3929   interface(MEMORY_INTER) %{
 3930     base($reg);
 3931     index(0x0);
 3932     scale(0x0);
 3933     disp($offset);
 3934   %}
 3935 %}
 3936 
 3937 // Indirect with simm13 Offset minus 7
 3938 operand indOffset13m7(sp_ptr_RegP reg, immX13m7 offset) %{
 3939   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3940   match(AddP reg offset);
 3941 
 3942   op_cost(100);
 3943   format %{ &quot;[$reg + $offset]&quot; %}
 3944   interface(MEMORY_INTER) %{
 3945     base($reg);
 3946     index(0x0);
 3947     scale(0x0);
 3948     disp($offset);
 3949   %}
 3950 %}
 3951 
 3952 // Note:  Intel has a swapped version also, like this:
 3953 //operand indOffsetX(iRegI reg, immP offset) %{
 3954 //  constraint(ALLOC_IN_RC(int_reg));
 3955 //  match(AddP offset reg);
 3956 //
 3957 //  op_cost(100);
 3958 //  format %{ &quot;[$reg + $offset]&quot; %}
 3959 //  interface(MEMORY_INTER) %{
 3960 //    base($reg);
 3961 //    index(0x0);
 3962 //    scale(0x0);
 3963 //    disp($offset);
 3964 //  %}
 3965 //%}
 3966 //// However, it doesn&#39;t make sense for SPARC, since
 3967 // we have no particularly good way to embed oops in
 3968 // single instructions.
 3969 
 3970 // Indirect with Register Index
 3971 operand indIndex(iRegP addr, iRegX index) %{
 3972   constraint(ALLOC_IN_RC(ptr_reg));
 3973   match(AddP addr index);
 3974 
 3975   op_cost(100);
 3976   format %{ &quot;[$addr + $index]&quot; %}
 3977   interface(MEMORY_INTER) %{
 3978     base($addr);
 3979     index($index);
 3980     scale(0x0);
 3981     disp(0x0);
 3982   %}
 3983 %}
 3984 
 3985 //----------Special Memory Operands--------------------------------------------
 3986 // Stack Slot Operand - This operand is used for loading and storing temporary
 3987 //                      values on the stack where a match requires a value to
 3988 //                      flow through memory.
 3989 operand stackSlotI(sRegI reg) %{
 3990   constraint(ALLOC_IN_RC(stack_slots));
 3991   op_cost(100);
 3992   //match(RegI);
 3993   format %{ &quot;[$reg]&quot; %}
 3994   interface(MEMORY_INTER) %{
 3995     base(0xE);   // R_SP
 3996     index(0x0);
 3997     scale(0x0);
 3998     disp($reg);  // Stack Offset
 3999   %}
 4000 %}
 4001 
 4002 operand stackSlotP(sRegP reg) %{
 4003   constraint(ALLOC_IN_RC(stack_slots));
 4004   op_cost(100);
 4005   //match(RegP);
 4006   format %{ &quot;[$reg]&quot; %}
 4007   interface(MEMORY_INTER) %{
 4008     base(0xE);   // R_SP
 4009     index(0x0);
 4010     scale(0x0);
 4011     disp($reg);  // Stack Offset
 4012   %}
 4013 %}
 4014 
 4015 operand stackSlotF(sRegF reg) %{
 4016   constraint(ALLOC_IN_RC(stack_slots));
 4017   op_cost(100);
 4018   //match(RegF);
 4019   format %{ &quot;[$reg]&quot; %}
 4020   interface(MEMORY_INTER) %{
 4021     base(0xE);   // R_SP
 4022     index(0x0);
 4023     scale(0x0);
 4024     disp($reg);  // Stack Offset
 4025   %}
 4026 %}
 4027 operand stackSlotD(sRegD reg) %{
 4028   constraint(ALLOC_IN_RC(stack_slots));
 4029   op_cost(100);
 4030   //match(RegD);
 4031   format %{ &quot;[$reg]&quot; %}
 4032   interface(MEMORY_INTER) %{
 4033     base(0xE);   // R_SP
 4034     index(0x0);
 4035     scale(0x0);
 4036     disp($reg);  // Stack Offset
 4037   %}
 4038 %}
 4039 operand stackSlotL(sRegL reg) %{
 4040   constraint(ALLOC_IN_RC(stack_slots));
 4041   op_cost(100);
 4042   //match(RegL);
 4043   format %{ &quot;[$reg]&quot; %}
 4044   interface(MEMORY_INTER) %{
 4045     base(0xE);   // R_SP
 4046     index(0x0);
 4047     scale(0x0);
 4048     disp($reg);  // Stack Offset
 4049   %}
 4050 %}
 4051 
 4052 // Operands for expressing Control Flow
 4053 // NOTE:  Label is a predefined operand which should not be redefined in
 4054 //        the AD file.  It is generically handled within the ADLC.
 4055 
 4056 //----------Conditional Branch Operands----------------------------------------
 4057 // Comparison Op  - This is the operation of the comparison, and is limited to
 4058 //                  the following set of codes:
 4059 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4060 //
 4061 // Other attributes of the comparison, such as unsignedness, are specified
 4062 // by the comparison instruction that sets a condition code flags register.
 4063 // That result is represented by a flags operand whose subtype is appropriate
 4064 // to the unsignedness (etc.) of the comparison.
 4065 //
 4066 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4067 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4068 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4069 
 4070 operand cmpOp() %{
 4071   match(Bool);
 4072 
 4073   format %{ &quot;&quot; %}
 4074   interface(COND_INTER) %{
 4075     equal(0x1);
 4076     not_equal(0x9);
 4077     less(0x3);
 4078     greater_equal(0xB);
 4079     less_equal(0x2);
 4080     greater(0xA);
 4081     overflow(0x7);
 4082     no_overflow(0xF);
 4083   %}
 4084 %}
 4085 
 4086 // Comparison Op, unsigned
 4087 operand cmpOpU() %{
 4088   match(Bool);
 4089   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4090             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4091 
 4092   format %{ &quot;u&quot; %}
 4093   interface(COND_INTER) %{
 4094     equal(0x1);
 4095     not_equal(0x9);
 4096     less(0x5);
 4097     greater_equal(0xD);
 4098     less_equal(0x4);
 4099     greater(0xC);
 4100     overflow(0x7);
 4101     no_overflow(0xF);
 4102   %}
 4103 %}
 4104 
 4105 // Comparison Op, pointer (same as unsigned)
 4106 operand cmpOpP() %{
 4107   match(Bool);
 4108   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4109             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4110 
 4111   format %{ &quot;p&quot; %}
 4112   interface(COND_INTER) %{
 4113     equal(0x1);
 4114     not_equal(0x9);
 4115     less(0x5);
 4116     greater_equal(0xD);
 4117     less_equal(0x4);
 4118     greater(0xC);
 4119     overflow(0x7);
 4120     no_overflow(0xF);
 4121   %}
 4122 %}
 4123 
 4124 // Comparison Op, branch-register encoding
 4125 operand cmpOp_reg() %{
 4126   match(Bool);
 4127   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4128             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4129 
 4130   format %{ &quot;&quot; %}
 4131   interface(COND_INTER) %{
 4132     equal        (0x1);
 4133     not_equal    (0x5);
 4134     less         (0x3);
 4135     greater_equal(0x7);
 4136     less_equal   (0x2);
 4137     greater      (0x6);
 4138     overflow(0x7); // not supported
 4139     no_overflow(0xF); // not supported
 4140   %}
 4141 %}
 4142 
 4143 // Comparison Code, floating, unordered same as less
 4144 operand cmpOpF() %{
 4145   match(Bool);
 4146   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4147             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4148 
 4149   format %{ &quot;fl&quot; %}
 4150   interface(COND_INTER) %{
 4151     equal(0x9);
 4152     not_equal(0x1);
 4153     less(0x3);
 4154     greater_equal(0xB);
 4155     less_equal(0xE);
 4156     greater(0x6);
 4157 
 4158     overflow(0x7); // not supported
 4159     no_overflow(0xF); // not supported
 4160   %}
 4161 %}
 4162 
 4163 // Used by long compare
 4164 operand cmpOp_commute() %{
 4165   match(Bool);
 4166   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4167             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4168 
 4169   format %{ &quot;&quot; %}
 4170   interface(COND_INTER) %{
 4171     equal(0x1);
 4172     not_equal(0x9);
 4173     less(0xA);
 4174     greater_equal(0x2);
 4175     less_equal(0xB);
 4176     greater(0x3);
 4177     overflow(0x7);
 4178     no_overflow(0xF);
 4179   %}
 4180 %}
 4181 
 4182 //----------OPERAND CLASSES----------------------------------------------------
 4183 // Operand Classes are groups of operands that are used to simplify
 4184 // instruction definitions by not requiring the AD writer to specify separate
 4185 // instructions for every form of operand when the instruction accepts
 4186 // multiple operand types with the same basic encoding and format.  The classic
 4187 // case of this is memory operands.
 4188 opclass memory( indirect, indOffset13, indIndex );
 4189 opclass indIndexMemory( indIndex );
 4190 
 4191 //----------PIPELINE-----------------------------------------------------------
 4192 pipeline %{
 4193 
 4194 //----------ATTRIBUTES---------------------------------------------------------
 4195 attributes %{
 4196   fixed_size_instructions;           // Fixed size instructions
 4197   branch_has_delay_slot;             // Branch has delay slot following
 4198   max_instructions_per_bundle = 4;   // Up to 4 instructions per bundle
 4199   instruction_unit_size = 4;         // An instruction is 4 bytes long
 4200   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4201   instruction_fetch_units = 1;       // of 16 bytes
 4202 
 4203   // List of nop instructions
 4204   nops( Nop_A0, Nop_A1, Nop_MS, Nop_FA, Nop_BR );
 4205 %}
 4206 
 4207 //----------RESOURCES----------------------------------------------------------
 4208 // Resources are the functional units available to the machine
 4209 resources(A0, A1, MS, BR, FA, FM, IDIV, FDIV, IALU = A0 | A1);
 4210 
 4211 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4212 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4213 
 4214 pipe_desc(A, P, F, B, I, J, S, R, E, C, M, W, X, T, D);
 4215 
 4216 //----------PIPELINE CLASSES---------------------------------------------------
 4217 // Pipeline Classes describe the stages in which input and output are
 4218 // referenced by the hardware pipeline.
 4219 
 4220 // Integer ALU reg-reg operation
 4221 pipe_class ialu_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4222     single_instruction;
 4223     dst   : E(write);
 4224     src1  : R(read);
 4225     src2  : R(read);
 4226     IALU  : R;
 4227 %}
 4228 
 4229 // Integer ALU reg-reg long operation
 4230 pipe_class ialu_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 4231     instruction_count(2);
 4232     dst   : E(write);
 4233     src1  : R(read);
 4234     src2  : R(read);
 4235     IALU  : R;
 4236     IALU  : R;
 4237 %}
 4238 
 4239 // Integer ALU reg-reg long dependent operation
 4240 pipe_class ialu_reg_reg_2_dep(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 4241     instruction_count(1); multiple_bundles;
 4242     dst   : E(write);
 4243     src1  : R(read);
 4244     src2  : R(read);
 4245     cr    : E(write);
 4246     IALU  : R(2);
 4247 %}
 4248 
 4249 // Integer ALU reg-imm operaion
 4250 pipe_class ialu_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4251     single_instruction;
 4252     dst   : E(write);
 4253     src1  : R(read);
 4254     IALU  : R;
 4255 %}
 4256 
 4257 // Integer ALU reg-reg operation with condition code
 4258 pipe_class ialu_cc_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 4259     single_instruction;
 4260     dst   : E(write);
 4261     cr    : E(write);
 4262     src1  : R(read);
 4263     src2  : R(read);
 4264     IALU  : R;
 4265 %}
 4266 
 4267 // Integer ALU reg-imm operation with condition code
 4268 pipe_class ialu_cc_reg_imm(iRegI dst, iRegI src1, immI13 src2, flagsReg cr) %{
 4269     single_instruction;
 4270     dst   : E(write);
 4271     cr    : E(write);
 4272     src1  : R(read);
 4273     IALU  : R;
 4274 %}
 4275 
 4276 // Integer ALU zero-reg operation
 4277 pipe_class ialu_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 4278     single_instruction;
 4279     dst   : E(write);
 4280     src2  : R(read);
 4281     IALU  : R;
 4282 %}
 4283 
 4284 // Integer ALU zero-reg operation with condition code only
 4285 pipe_class ialu_cconly_zero_reg(flagsReg cr, iRegI src) %{
 4286     single_instruction;
 4287     cr    : E(write);
 4288     src   : R(read);
 4289     IALU  : R;
 4290 %}
 4291 
 4292 // Integer ALU reg-reg operation with condition code only
 4293 pipe_class ialu_cconly_reg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4294     single_instruction;
 4295     cr    : E(write);
 4296     src1  : R(read);
 4297     src2  : R(read);
 4298     IALU  : R;
 4299 %}
 4300 
 4301 // Integer ALU reg-imm operation with condition code only
 4302 pipe_class ialu_cconly_reg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4303     single_instruction;
 4304     cr    : E(write);
 4305     src1  : R(read);
 4306     IALU  : R;
 4307 %}
 4308 
 4309 // Integer ALU reg-reg-zero operation with condition code only
 4310 pipe_class ialu_cconly_reg_reg_zero(flagsReg cr, iRegI src1, iRegI src2, immI0 zero) %{
 4311     single_instruction;
 4312     cr    : E(write);
 4313     src1  : R(read);
 4314     src2  : R(read);
 4315     IALU  : R;
 4316 %}
 4317 
 4318 // Integer ALU reg-imm-zero operation with condition code only
 4319 pipe_class ialu_cconly_reg_imm_zero(flagsReg cr, iRegI src1, immI13 src2, immI0 zero) %{
 4320     single_instruction;
 4321     cr    : E(write);
 4322     src1  : R(read);
 4323     IALU  : R;
 4324 %}
 4325 
 4326 // Integer ALU reg-reg operation with condition code, src1 modified
 4327 pipe_class ialu_cc_rwreg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4328     single_instruction;
 4329     cr    : E(write);
 4330     src1  : E(write);
 4331     src1  : R(read);
 4332     src2  : R(read);
 4333     IALU  : R;
 4334 %}
 4335 
 4336 // Integer ALU reg-imm operation with condition code, src1 modified
 4337 pipe_class ialu_cc_rwreg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4338     single_instruction;
 4339     cr    : E(write);
 4340     src1  : E(write);
 4341     src1  : R(read);
 4342     IALU  : R;
 4343 %}
 4344 
 4345 pipe_class cmpL_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr ) %{
 4346     multiple_bundles;
 4347     dst   : E(write)+4;
 4348     cr    : E(write);
 4349     src1  : R(read);
 4350     src2  : R(read);
 4351     IALU  : R(3);
 4352     BR    : R(2);
 4353 %}
 4354 
 4355 // Integer ALU operation
 4356 pipe_class ialu_none(iRegI dst) %{
 4357     single_instruction;
 4358     dst   : E(write);
 4359     IALU  : R;
 4360 %}
 4361 
 4362 // Integer ALU reg operation
 4363 pipe_class ialu_reg(iRegI dst, iRegI src) %{
 4364     single_instruction; may_have_no_code;
 4365     dst   : E(write);
 4366     src   : R(read);
 4367     IALU  : R;
 4368 %}
 4369 
 4370 // Integer ALU reg conditional operation
 4371 // This instruction has a 1 cycle stall, and cannot execute
 4372 // in the same cycle as the instruction setting the condition
 4373 // code. We kludge this by pretending to read the condition code
 4374 // 1 cycle earlier, and by marking the functional units as busy
 4375 // for 2 cycles with the result available 1 cycle later than
 4376 // is really the case.
 4377 pipe_class ialu_reg_flags( iRegI op2_out, iRegI op2_in, iRegI op1, flagsReg cr ) %{
 4378     single_instruction;
 4379     op2_out : C(write);
 4380     op1     : R(read);
 4381     cr      : R(read);       // This is really E, with a 1 cycle stall
 4382     BR      : R(2);
 4383     MS      : R(2);
 4384 %}
 4385 
 4386 pipe_class ialu_clr_and_mover( iRegI dst, iRegP src ) %{
 4387     instruction_count(1); multiple_bundles;
 4388     dst     : C(write)+1;
 4389     src     : R(read)+1;
 4390     IALU    : R(1);
 4391     BR      : E(2);
 4392     MS      : E(2);
 4393 %}
 4394 
 4395 // Integer ALU reg operation
 4396 pipe_class ialu_move_reg_L_to_I(iRegI dst, iRegL src) %{
 4397     single_instruction; may_have_no_code;
 4398     dst   : E(write);
 4399     src   : R(read);
 4400     IALU  : R;
 4401 %}
 4402 pipe_class ialu_move_reg_I_to_L(iRegL dst, iRegI src) %{
 4403     single_instruction; may_have_no_code;
 4404     dst   : E(write);
 4405     src   : R(read);
 4406     IALU  : R;
 4407 %}
 4408 
 4409 // Two integer ALU reg operations
 4410 pipe_class ialu_reg_2(iRegL dst, iRegL src) %{
 4411     instruction_count(2);
 4412     dst   : E(write);
 4413     src   : R(read);
 4414     A0    : R;
 4415     A1    : R;
 4416 %}
 4417 
 4418 // Two integer ALU reg operations
 4419 pipe_class ialu_move_reg_L_to_L(iRegL dst, iRegL src) %{
 4420     instruction_count(2); may_have_no_code;
 4421     dst   : E(write);
 4422     src   : R(read);
 4423     A0    : R;
 4424     A1    : R;
 4425 %}
 4426 
 4427 // Integer ALU imm operation
 4428 pipe_class ialu_imm(iRegI dst, immI13 src) %{
 4429     single_instruction;
 4430     dst   : E(write);
 4431     IALU  : R;
 4432 %}
 4433 
 4434 // Integer ALU reg-reg with carry operation
 4435 pipe_class ialu_reg_reg_cy(iRegI dst, iRegI src1, iRegI src2, iRegI cy) %{
 4436     single_instruction;
 4437     dst   : E(write);
 4438     src1  : R(read);
 4439     src2  : R(read);
 4440     IALU  : R;
 4441 %}
 4442 
 4443 // Integer ALU cc operation
 4444 pipe_class ialu_cc(iRegI dst, flagsReg cc) %{
 4445     single_instruction;
 4446     dst   : E(write);
 4447     cc    : R(read);
 4448     IALU  : R;
 4449 %}
 4450 
 4451 // Integer ALU cc / second IALU operation
 4452 pipe_class ialu_reg_ialu( iRegI dst, iRegI src ) %{
 4453     instruction_count(1); multiple_bundles;
 4454     dst   : E(write)+1;
 4455     src   : R(read);
 4456     IALU  : R;
 4457 %}
 4458 
 4459 // Integer ALU cc / second IALU operation
 4460 pipe_class ialu_reg_reg_ialu( iRegI dst, iRegI p, iRegI q ) %{
 4461     instruction_count(1); multiple_bundles;
 4462     dst   : E(write)+1;
 4463     p     : R(read);
 4464     q     : R(read);
 4465     IALU  : R;
 4466 %}
 4467 
 4468 // Integer ALU hi-lo-reg operation
 4469 pipe_class ialu_hi_lo_reg(iRegI dst, immI src) %{
 4470     instruction_count(1); multiple_bundles;
 4471     dst   : E(write)+1;
 4472     IALU  : R(2);
 4473 %}
 4474 
 4475 // Float ALU hi-lo-reg operation (with temp)
 4476 pipe_class ialu_hi_lo_reg_temp(regF dst, immF src, g3RegP tmp) %{
 4477     instruction_count(1); multiple_bundles;
 4478     dst   : E(write)+1;
 4479     IALU  : R(2);
 4480 %}
 4481 
 4482 // Long Constant
 4483 pipe_class loadConL( iRegL dst, immL src ) %{
 4484     instruction_count(2); multiple_bundles;
 4485     dst   : E(write)+1;
 4486     IALU  : R(2);
 4487     IALU  : R(2);
 4488 %}
 4489 
 4490 // Pointer Constant
 4491 pipe_class loadConP( iRegP dst, immP src ) %{
 4492     instruction_count(0); multiple_bundles;
 4493     fixed_latency(6);
 4494 %}
 4495 
 4496 // Polling Address
 4497 pipe_class loadConP_poll( iRegP dst, immP_poll src ) %{
 4498     instruction_count(0); multiple_bundles;
 4499     fixed_latency(6);
 4500 %}
 4501 
 4502 // Long Constant small
 4503 pipe_class loadConLlo( iRegL dst, immL src ) %{
 4504     instruction_count(2);
 4505     dst   : E(write);
 4506     IALU  : R;
 4507     IALU  : R;
 4508 %}
 4509 
 4510 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 4511 pipe_class loadConFD(regF dst, immF src, g3RegP tmp) %{
 4512     instruction_count(1); multiple_bundles;
 4513     src   : R(read);
 4514     dst   : M(write)+1;
 4515     IALU  : R;
 4516     MS    : E;
 4517 %}
 4518 
 4519 // Integer ALU nop operation
 4520 pipe_class ialu_nop() %{
 4521     single_instruction;
 4522     IALU  : R;
 4523 %}
 4524 
 4525 // Integer ALU nop operation
 4526 pipe_class ialu_nop_A0() %{
 4527     single_instruction;
 4528     A0    : R;
 4529 %}
 4530 
 4531 // Integer ALU nop operation
 4532 pipe_class ialu_nop_A1() %{
 4533     single_instruction;
 4534     A1    : R;
 4535 %}
 4536 
 4537 // Integer Multiply reg-reg operation
 4538 pipe_class imul_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4539     single_instruction;
 4540     dst   : E(write);
 4541     src1  : R(read);
 4542     src2  : R(read);
 4543     MS    : R(5);
 4544 %}
 4545 
 4546 // Integer Multiply reg-imm operation
 4547 pipe_class imul_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4548     single_instruction;
 4549     dst   : E(write);
 4550     src1  : R(read);
 4551     MS    : R(5);
 4552 %}
 4553 
 4554 pipe_class mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4555     single_instruction;
 4556     dst   : E(write)+4;
 4557     src1  : R(read);
 4558     src2  : R(read);
 4559     MS    : R(6);
 4560 %}
 4561 
 4562 pipe_class mulL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4563     single_instruction;
 4564     dst   : E(write)+4;
 4565     src1  : R(read);
 4566     MS    : R(6);
 4567 %}
 4568 
 4569 // Integer Divide reg-reg
 4570 pipe_class sdiv_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI temp, flagsReg cr) %{
 4571     instruction_count(1); multiple_bundles;
 4572     dst   : E(write);
 4573     temp  : E(write);
 4574     src1  : R(read);
 4575     src2  : R(read);
 4576     temp  : R(read);
 4577     MS    : R(38);
 4578 %}
 4579 
 4580 // Integer Divide reg-imm
 4581 pipe_class sdiv_reg_imm(iRegI dst, iRegI src1, immI13 src2, iRegI temp, flagsReg cr) %{
 4582     instruction_count(1); multiple_bundles;
 4583     dst   : E(write);
 4584     temp  : E(write);
 4585     src1  : R(read);
 4586     temp  : R(read);
 4587     MS    : R(38);
 4588 %}
 4589 
 4590 // Long Divide
 4591 pipe_class divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4592     dst  : E(write)+71;
 4593     src1 : R(read);
 4594     src2 : R(read)+1;
 4595     MS   : R(70);
 4596 %}
 4597 
 4598 pipe_class divL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4599     dst  : E(write)+71;
 4600     src1 : R(read);
 4601     MS   : R(70);
 4602 %}
 4603 
 4604 // Floating Point Add Float
 4605 pipe_class faddF_reg_reg(regF dst, regF src1, regF src2) %{
 4606     single_instruction;
 4607     dst   : X(write);
 4608     src1  : E(read);
 4609     src2  : E(read);
 4610     FA    : R;
 4611 %}
 4612 
 4613 // Floating Point Add Double
 4614 pipe_class faddD_reg_reg(regD dst, regD src1, regD src2) %{
 4615     single_instruction;
 4616     dst   : X(write);
 4617     src1  : E(read);
 4618     src2  : E(read);
 4619     FA    : R;
 4620 %}
 4621 
 4622 // Floating Point Conditional Move based on integer flags
 4623 pipe_class int_conditional_float_move (cmpOp cmp, flagsReg cr, regF dst, regF src) %{
 4624     single_instruction;
 4625     dst   : X(write);
 4626     src   : E(read);
 4627     cr    : R(read);
 4628     FA    : R(2);
 4629     BR    : R(2);
 4630 %}
 4631 
 4632 // Floating Point Conditional Move based on integer flags
 4633 pipe_class int_conditional_double_move (cmpOp cmp, flagsReg cr, regD dst, regD src) %{
 4634     single_instruction;
 4635     dst   : X(write);
 4636     src   : E(read);
 4637     cr    : R(read);
 4638     FA    : R(2);
 4639     BR    : R(2);
 4640 %}
 4641 
 4642 // Floating Point Multiply Float
 4643 pipe_class fmulF_reg_reg(regF dst, regF src1, regF src2) %{
 4644     single_instruction;
 4645     dst   : X(write);
 4646     src1  : E(read);
 4647     src2  : E(read);
 4648     FM    : R;
 4649 %}
 4650 
 4651 // Floating Point Multiply Double
 4652 pipe_class fmulD_reg_reg(regD dst, regD src1, regD src2) %{
 4653     single_instruction;
 4654     dst   : X(write);
 4655     src1  : E(read);
 4656     src2  : E(read);
 4657     FM    : R;
 4658 %}
 4659 
 4660 // Floating Point Divide Float
 4661 pipe_class fdivF_reg_reg(regF dst, regF src1, regF src2) %{
 4662     single_instruction;
 4663     dst   : X(write);
 4664     src1  : E(read);
 4665     src2  : E(read);
 4666     FM    : R;
 4667     FDIV  : C(14);
 4668 %}
 4669 
 4670 // Floating Point Divide Double
 4671 pipe_class fdivD_reg_reg(regD dst, regD src1, regD src2) %{
 4672     single_instruction;
 4673     dst   : X(write);
 4674     src1  : E(read);
 4675     src2  : E(read);
 4676     FM    : R;
 4677     FDIV  : C(17);
 4678 %}
 4679 
 4680 // Fused floating-point multiply-add float.
 4681 pipe_class fmaF_regx4(regF dst, regF src1, regF src2, regF src3) %{
 4682     single_instruction;
 4683     dst   : X(write);
 4684     src1  : E(read);
 4685     src2  : E(read);
 4686     src3  : E(read);
 4687     FM    : R;
 4688 %}
 4689 
 4690 // Fused gloating-point multiply-add double.
 4691 pipe_class fmaD_regx4(regD dst, regD src1, regD src2, regD src3) %{
 4692     single_instruction;
 4693     dst   : X(write);
 4694     src1  : E(read);
 4695     src2  : E(read);
 4696     src3  : E(read);
 4697     FM    : R;
 4698 %}
 4699 
 4700 // Floating Point Move/Negate/Abs Float
 4701 pipe_class faddF_reg(regF dst, regF src) %{
 4702     single_instruction;
 4703     dst   : W(write);
 4704     src   : E(read);
 4705     FA    : R(1);
 4706 %}
 4707 
 4708 // Floating Point Move/Negate/Abs Double
 4709 pipe_class faddD_reg(regD dst, regD src) %{
 4710     single_instruction;
 4711     dst   : W(write);
 4712     src   : E(read);
 4713     FA    : R;
 4714 %}
 4715 
 4716 // Floating Point Convert F-&gt;D
 4717 pipe_class fcvtF2D(regD dst, regF src) %{
 4718     single_instruction;
 4719     dst   : X(write);
 4720     src   : E(read);
 4721     FA    : R;
 4722 %}
 4723 
 4724 // Floating Point Convert I-&gt;D
 4725 pipe_class fcvtI2D(regD dst, regF src) %{
 4726     single_instruction;
 4727     dst   : X(write);
 4728     src   : E(read);
 4729     FA    : R;
 4730 %}
 4731 
 4732 // Floating Point Convert LHi-&gt;D
 4733 pipe_class fcvtLHi2D(regD dst, regD src) %{
 4734     single_instruction;
 4735     dst   : X(write);
 4736     src   : E(read);
 4737     FA    : R;
 4738 %}
 4739 
 4740 // Floating Point Convert L-&gt;D
 4741 pipe_class fcvtL2D(regD dst, regF src) %{
 4742     single_instruction;
 4743     dst   : X(write);
 4744     src   : E(read);
 4745     FA    : R;
 4746 %}
 4747 
 4748 // Floating Point Convert L-&gt;F
 4749 pipe_class fcvtL2F(regD dst, regF src) %{
 4750     single_instruction;
 4751     dst   : X(write);
 4752     src   : E(read);
 4753     FA    : R;
 4754 %}
 4755 
 4756 // Floating Point Convert D-&gt;F
 4757 pipe_class fcvtD2F(regD dst, regF src) %{
 4758     single_instruction;
 4759     dst   : X(write);
 4760     src   : E(read);
 4761     FA    : R;
 4762 %}
 4763 
 4764 // Floating Point Convert I-&gt;L
 4765 pipe_class fcvtI2L(regD dst, regF src) %{
 4766     single_instruction;
 4767     dst   : X(write);
 4768     src   : E(read);
 4769     FA    : R;
 4770 %}
 4771 
 4772 // Floating Point Convert D-&gt;F
 4773 pipe_class fcvtD2I(regF dst, regD src, flagsReg cr) %{
 4774     instruction_count(1); multiple_bundles;
 4775     dst   : X(write)+6;
 4776     src   : E(read);
 4777     FA    : R;
 4778 %}
 4779 
 4780 // Floating Point Convert D-&gt;L
 4781 pipe_class fcvtD2L(regD dst, regD src, flagsReg cr) %{
 4782     instruction_count(1); multiple_bundles;
 4783     dst   : X(write)+6;
 4784     src   : E(read);
 4785     FA    : R;
 4786 %}
 4787 
 4788 // Floating Point Convert F-&gt;I
 4789 pipe_class fcvtF2I(regF dst, regF src, flagsReg cr) %{
 4790     instruction_count(1); multiple_bundles;
 4791     dst   : X(write)+6;
 4792     src   : E(read);
 4793     FA    : R;
 4794 %}
 4795 
 4796 // Floating Point Convert F-&gt;L
 4797 pipe_class fcvtF2L(regD dst, regF src, flagsReg cr) %{
 4798     instruction_count(1); multiple_bundles;
 4799     dst   : X(write)+6;
 4800     src   : E(read);
 4801     FA    : R;
 4802 %}
 4803 
 4804 // Floating Point Convert I-&gt;F
 4805 pipe_class fcvtI2F(regF dst, regF src) %{
 4806     single_instruction;
 4807     dst   : X(write);
 4808     src   : E(read);
 4809     FA    : R;
 4810 %}
 4811 
 4812 // Floating Point Compare
 4813 pipe_class faddF_fcc_reg_reg_zero(flagsRegF cr, regF src1, regF src2, immI0 zero) %{
 4814     single_instruction;
 4815     cr    : X(write);
 4816     src1  : E(read);
 4817     src2  : E(read);
 4818     FA    : R;
 4819 %}
 4820 
 4821 // Floating Point Compare
 4822 pipe_class faddD_fcc_reg_reg_zero(flagsRegF cr, regD src1, regD src2, immI0 zero) %{
 4823     single_instruction;
 4824     cr    : X(write);
 4825     src1  : E(read);
 4826     src2  : E(read);
 4827     FA    : R;
 4828 %}
 4829 
 4830 // Floating Add Nop
 4831 pipe_class fadd_nop() %{
 4832     single_instruction;
 4833     FA  : R;
 4834 %}
 4835 
 4836 // Integer Store to Memory
 4837 pipe_class istore_mem_reg(memory mem, iRegI src) %{
 4838     single_instruction;
 4839     mem   : R(read);
 4840     src   : C(read);
 4841     MS    : R;
 4842 %}
 4843 
 4844 // Integer Store to Memory
 4845 pipe_class istore_mem_spORreg(memory mem, sp_ptr_RegP src) %{
 4846     single_instruction;
 4847     mem   : R(read);
 4848     src   : C(read);
 4849     MS    : R;
 4850 %}
 4851 
 4852 // Integer Store Zero to Memory
 4853 pipe_class istore_mem_zero(memory mem, immI0 src) %{
 4854     single_instruction;
 4855     mem   : R(read);
 4856     MS    : R;
 4857 %}
 4858 
 4859 // Special Stack Slot Store
 4860 pipe_class istore_stk_reg(stackSlotI stkSlot, iRegI src) %{
 4861     single_instruction;
 4862     stkSlot : R(read);
 4863     src     : C(read);
 4864     MS      : R;
 4865 %}
 4866 
 4867 // Special Stack Slot Store
 4868 pipe_class lstoreI_stk_reg(stackSlotL stkSlot, iRegI src) %{
 4869     instruction_count(2); multiple_bundles;
 4870     stkSlot : R(read);
 4871     src     : C(read);
 4872     MS      : R(2);
 4873 %}
 4874 
 4875 // Float Store
 4876 pipe_class fstoreF_mem_reg(memory mem, RegF src) %{
 4877     single_instruction;
 4878     mem : R(read);
 4879     src : C(read);
 4880     MS  : R;
 4881 %}
 4882 
 4883 // Float Store
 4884 pipe_class fstoreF_mem_zero(memory mem, immF0 src) %{
 4885     single_instruction;
 4886     mem : R(read);
 4887     MS  : R;
 4888 %}
 4889 
 4890 // Double Store
 4891 pipe_class fstoreD_mem_reg(memory mem, RegD src) %{
 4892     instruction_count(1);
 4893     mem : R(read);
 4894     src : C(read);
 4895     MS  : R;
 4896 %}
 4897 
 4898 // Double Store
 4899 pipe_class fstoreD_mem_zero(memory mem, immD0 src) %{
 4900     single_instruction;
 4901     mem : R(read);
 4902     MS  : R;
 4903 %}
 4904 
 4905 // Special Stack Slot Float Store
 4906 pipe_class fstoreF_stk_reg(stackSlotI stkSlot, RegF src) %{
 4907     single_instruction;
 4908     stkSlot : R(read);
 4909     src     : C(read);
 4910     MS      : R;
 4911 %}
 4912 
 4913 // Special Stack Slot Double Store
 4914 pipe_class fstoreD_stk_reg(stackSlotI stkSlot, RegD src) %{
 4915     single_instruction;
 4916     stkSlot : R(read);
 4917     src     : C(read);
 4918     MS      : R;
 4919 %}
 4920 
 4921 // Integer Load (when sign bit propagation not needed)
 4922 pipe_class iload_mem(iRegI dst, memory mem) %{
 4923     single_instruction;
 4924     mem : R(read);
 4925     dst : C(write);
 4926     MS  : R;
 4927 %}
 4928 
 4929 // Integer Load from stack operand
 4930 pipe_class iload_stkD(iRegI dst, stackSlotD mem ) %{
 4931     single_instruction;
 4932     mem : R(read);
 4933     dst : C(write);
 4934     MS  : R;
 4935 %}
 4936 
 4937 // Integer Load (when sign bit propagation or masking is needed)
 4938 pipe_class iload_mask_mem(iRegI dst, memory mem) %{
 4939     single_instruction;
 4940     mem : R(read);
 4941     dst : M(write);
 4942     MS  : R;
 4943 %}
 4944 
 4945 // Float Load
 4946 pipe_class floadF_mem(regF dst, memory mem) %{
 4947     single_instruction;
 4948     mem : R(read);
 4949     dst : M(write);
 4950     MS  : R;
 4951 %}
 4952 
 4953 // Float Load
 4954 pipe_class floadD_mem(regD dst, memory mem) %{
 4955     instruction_count(1); multiple_bundles; // Again, unaligned argument is only multiple case
 4956     mem : R(read);
 4957     dst : M(write);
 4958     MS  : R;
 4959 %}
 4960 
 4961 // Float Load
 4962 pipe_class floadF_stk(regF dst, stackSlotI stkSlot) %{
 4963     single_instruction;
 4964     stkSlot : R(read);
 4965     dst : M(write);
 4966     MS  : R;
 4967 %}
 4968 
 4969 // Float Load
 4970 pipe_class floadD_stk(regD dst, stackSlotI stkSlot) %{
 4971     single_instruction;
 4972     stkSlot : R(read);
 4973     dst : M(write);
 4974     MS  : R;
 4975 %}
 4976 
 4977 // Memory Nop
 4978 pipe_class mem_nop() %{
 4979     single_instruction;
 4980     MS  : R;
 4981 %}
 4982 
 4983 pipe_class sethi(iRegP dst, immI src) %{
 4984     single_instruction;
 4985     dst  : E(write);
 4986     IALU : R;
 4987 %}
 4988 
 4989 pipe_class loadPollP(iRegP poll) %{
 4990     single_instruction;
 4991     poll : R(read);
 4992     MS   : R;
 4993 %}
 4994 
 4995 pipe_class br(Universe br, label labl) %{
 4996     single_instruction_with_delay_slot;
 4997     BR  : R;
 4998 %}
 4999 
 5000 pipe_class br_cc(Universe br, cmpOp cmp, flagsReg cr, label labl) %{
 5001     single_instruction_with_delay_slot;
 5002     cr    : E(read);
 5003     BR    : R;
 5004 %}
 5005 
 5006 pipe_class br_reg(Universe br, cmpOp cmp, iRegI op1, label labl) %{
 5007     single_instruction_with_delay_slot;
 5008     op1 : E(read);
 5009     BR  : R;
 5010     MS  : R;
 5011 %}
 5012 
 5013 // Compare and branch
 5014 pipe_class cmp_br_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 5015     instruction_count(2); has_delay_slot;
 5016     cr    : E(write);
 5017     src1  : R(read);
 5018     src2  : R(read);
 5019     IALU  : R;
 5020     BR    : R;
 5021 %}
 5022 
 5023 // Compare and branch
 5024 pipe_class cmp_br_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI13 src2, label labl, flagsReg cr) %{
 5025     instruction_count(2); has_delay_slot;
 5026     cr    : E(write);
 5027     src1  : R(read);
 5028     IALU  : R;
 5029     BR    : R;
 5030 %}
 5031 
 5032 // Compare and branch using cbcond
 5033 pipe_class cbcond_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl) %{
 5034     single_instruction;
 5035     src1  : E(read);
 5036     src2  : E(read);
 5037     IALU  : R;
 5038     BR    : R;
 5039 %}
 5040 
 5041 // Compare and branch using cbcond
 5042 pipe_class cbcond_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI5 src2, label labl) %{
 5043     single_instruction;
 5044     src1  : E(read);
 5045     IALU  : R;
 5046     BR    : R;
 5047 %}
 5048 
 5049 pipe_class br_fcc(Universe br, cmpOpF cc, flagsReg cr, label labl) %{
 5050     single_instruction_with_delay_slot;
 5051     cr    : E(read);
 5052     BR    : R;
 5053 %}
 5054 
 5055 pipe_class br_nop() %{
 5056     single_instruction;
 5057     BR  : R;
 5058 %}
 5059 
 5060 pipe_class simple_call(method meth) %{
 5061     instruction_count(2); multiple_bundles; force_serialization;
 5062     fixed_latency(100);
 5063     BR  : R(1);
 5064     MS  : R(1);
 5065     A0  : R(1);
 5066 %}
 5067 
 5068 pipe_class compiled_call(method meth) %{
 5069     instruction_count(1); multiple_bundles; force_serialization;
 5070     fixed_latency(100);
 5071     MS  : R(1);
 5072 %}
 5073 
 5074 pipe_class call(method meth) %{
 5075     instruction_count(0); multiple_bundles; force_serialization;
 5076     fixed_latency(100);
 5077 %}
 5078 
 5079 pipe_class tail_call(Universe ignore, label labl) %{
 5080     single_instruction; has_delay_slot;
 5081     fixed_latency(100);
 5082     BR  : R(1);
 5083     MS  : R(1);
 5084 %}
 5085 
 5086 pipe_class ret(Universe ignore) %{
 5087     single_instruction; has_delay_slot;
 5088     BR  : R(1);
 5089     MS  : R(1);
 5090 %}
 5091 
 5092 pipe_class ret_poll(g3RegP poll) %{
 5093     instruction_count(3); has_delay_slot;
 5094     poll : E(read);
 5095     MS   : R;
 5096 %}
 5097 
 5098 // The real do-nothing guy
 5099 pipe_class empty( ) %{
 5100     instruction_count(0);
 5101 %}
 5102 
 5103 pipe_class long_memory_op() %{
 5104     instruction_count(0); multiple_bundles; force_serialization;
 5105     fixed_latency(25);
 5106     MS  : R(1);
 5107 %}
 5108 
 5109 // Check-cast
 5110 pipe_class partial_subtype_check_pipe(Universe ignore, iRegP array, iRegP match ) %{
 5111     array : R(read);
 5112     match  : R(read);
 5113     IALU   : R(2);
 5114     BR     : R(2);
 5115     MS     : R;
 5116 %}
 5117 
 5118 // Convert FPU flags into +1,0,-1
 5119 pipe_class floating_cmp( iRegI dst, regF src1, regF src2 ) %{
 5120     src1  : E(read);
 5121     src2  : E(read);
 5122     dst   : E(write);
 5123     FA    : R;
 5124     MS    : R(2);
 5125     BR    : R(2);
 5126 %}
 5127 
 5128 // Compare for p &lt; q, and conditionally add y
 5129 pipe_class cadd_cmpltmask( iRegI p, iRegI q, iRegI y ) %{
 5130     p     : E(read);
 5131     q     : E(read);
 5132     y     : E(read);
 5133     IALU  : R(3)
 5134 %}
 5135 
 5136 // Perform a compare, then move conditionally in a branch delay slot.
 5137 pipe_class min_max( iRegI src2, iRegI srcdst ) %{
 5138     src2   : E(read);
 5139     srcdst : E(read);
 5140     IALU   : R;
 5141     BR     : R;
 5142 %}
 5143 
 5144 // Define the class for the Nop node
 5145 define %{
 5146    MachNop = ialu_nop;
 5147 %}
 5148 
 5149 %}
 5150 
 5151 //----------INSTRUCTIONS-------------------------------------------------------
 5152 
 5153 //------------Special Stack Slot instructions - no match rules-----------------
 5154 instruct stkI_to_regF(regF dst, stackSlotI src) %{
 5155   // No match rule to avoid chain rule match.
 5156   effect(DEF dst, USE src);
 5157   ins_cost(MEMORY_REF_COST);
 5158   format %{ &quot;LDF    $src,$dst\t! stkI to regF&quot; %}
 5159   opcode(Assembler::ldf_op3);
 5160   ins_encode(simple_form3_mem_reg(src, dst));
 5161   ins_pipe(floadF_stk);
 5162 %}
 5163 
 5164 instruct stkL_to_regD(regD dst, stackSlotL src) %{
 5165   // No match rule to avoid chain rule match.
 5166   effect(DEF dst, USE src);
 5167   ins_cost(MEMORY_REF_COST);
 5168   format %{ &quot;LDDF   $src,$dst\t! stkL to regD&quot; %}
 5169   opcode(Assembler::lddf_op3);
 5170   ins_encode(simple_form3_mem_reg(src, dst));
 5171   ins_pipe(floadD_stk);
 5172 %}
 5173 
 5174 instruct regF_to_stkI(stackSlotI dst, regF src) %{
 5175   // No match rule to avoid chain rule match.
 5176   effect(DEF dst, USE src);
 5177   ins_cost(MEMORY_REF_COST);
 5178   format %{ &quot;STF    $src,$dst\t! regF to stkI&quot; %}
 5179   opcode(Assembler::stf_op3);
 5180   ins_encode(simple_form3_mem_reg(dst, src));
 5181   ins_pipe(fstoreF_stk_reg);
 5182 %}
 5183 
 5184 instruct regD_to_stkL(stackSlotL dst, regD src) %{
 5185   // No match rule to avoid chain rule match.
 5186   effect(DEF dst, USE src);
 5187   ins_cost(MEMORY_REF_COST);
 5188   format %{ &quot;STDF   $src,$dst\t! regD to stkL&quot; %}
 5189   opcode(Assembler::stdf_op3);
 5190   ins_encode(simple_form3_mem_reg(dst, src));
 5191   ins_pipe(fstoreD_stk_reg);
 5192 %}
 5193 
 5194 instruct regI_to_stkLHi(stackSlotL dst, iRegI src) %{
 5195   effect(DEF dst, USE src);
 5196   ins_cost(MEMORY_REF_COST*2);
 5197   format %{ &quot;STW    $src,$dst.hi\t! long\n\t&quot;
 5198             &quot;STW    R_G0,$dst.lo&quot; %}
 5199   opcode(Assembler::stw_op3);
 5200   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, R_G0));
 5201   ins_pipe(lstoreI_stk_reg);
 5202 %}
 5203 
 5204 instruct regL_to_stkD(stackSlotD dst, iRegL src) %{
 5205   // No match rule to avoid chain rule match.
 5206   effect(DEF dst, USE src);
 5207   ins_cost(MEMORY_REF_COST);
 5208   format %{ &quot;STX    $src,$dst\t! regL to stkD&quot; %}
 5209   opcode(Assembler::stx_op3);
 5210   ins_encode(simple_form3_mem_reg( dst, src ) );
 5211   ins_pipe(istore_stk_reg);
 5212 %}
 5213 
 5214 //---------- Chain stack slots between similar types --------
 5215 
 5216 // Load integer from stack slot
 5217 instruct stkI_to_regI( iRegI dst, stackSlotI src ) %{
 5218   match(Set dst src);
 5219   ins_cost(MEMORY_REF_COST);
 5220 
 5221   format %{ &quot;LDUW   $src,$dst\t!stk&quot; %}
 5222   opcode(Assembler::lduw_op3);
 5223   ins_encode(simple_form3_mem_reg( src, dst ) );
 5224   ins_pipe(iload_mem);
 5225 %}
 5226 
 5227 // Store integer to stack slot
 5228 instruct regI_to_stkI( stackSlotI dst, iRegI src ) %{
 5229   match(Set dst src);
 5230   ins_cost(MEMORY_REF_COST);
 5231 
 5232   format %{ &quot;STW    $src,$dst\t!stk&quot; %}
 5233   opcode(Assembler::stw_op3);
 5234   ins_encode(simple_form3_mem_reg( dst, src ) );
 5235   ins_pipe(istore_mem_reg);
 5236 %}
 5237 
 5238 // Load long from stack slot
 5239 instruct stkL_to_regL( iRegL dst, stackSlotL src ) %{
 5240   match(Set dst src);
 5241 
 5242   ins_cost(MEMORY_REF_COST);
 5243   format %{ &quot;LDX    $src,$dst\t! long&quot; %}
 5244   opcode(Assembler::ldx_op3);
 5245   ins_encode(simple_form3_mem_reg( src, dst ) );
 5246   ins_pipe(iload_mem);
 5247 %}
 5248 
 5249 // Store long to stack slot
 5250 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 5251   match(Set dst src);
 5252 
 5253   ins_cost(MEMORY_REF_COST);
 5254   format %{ &quot;STX    $src,$dst\t! long&quot; %}
 5255   opcode(Assembler::stx_op3);
 5256   ins_encode(simple_form3_mem_reg( dst, src ) );
 5257   ins_pipe(istore_mem_reg);
 5258 %}
 5259 
 5260 // Load pointer from stack slot, 64-bit encoding
 5261 instruct stkP_to_regP( iRegP dst, stackSlotP src ) %{
 5262   match(Set dst src);
 5263   ins_cost(MEMORY_REF_COST);
 5264   format %{ &quot;LDX    $src,$dst\t!ptr&quot; %}
 5265   opcode(Assembler::ldx_op3);
 5266   ins_encode(simple_form3_mem_reg( src, dst ) );
 5267   ins_pipe(iload_mem);
 5268 %}
 5269 
 5270 // Store pointer to stack slot
 5271 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 5272   match(Set dst src);
 5273   ins_cost(MEMORY_REF_COST);
 5274   format %{ &quot;STX    $src,$dst\t!ptr&quot; %}
 5275   opcode(Assembler::stx_op3);
 5276   ins_encode(simple_form3_mem_reg( dst, src ) );
 5277   ins_pipe(istore_mem_reg);
 5278 %}
 5279 
 5280 //------------Special Nop instructions for bundling - no match rules-----------
 5281 // Nop using the A0 functional unit
 5282 instruct Nop_A0() %{
 5283   ins_cost(0);
 5284 
 5285   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5286   opcode(Assembler::or_op3, Assembler::arith_op);
 5287   ins_encode( form2_nop() );
 5288   ins_pipe(ialu_nop_A0);
 5289 %}
 5290 
 5291 // Nop using the A1 functional unit
 5292 instruct Nop_A1( ) %{
 5293   ins_cost(0);
 5294 
 5295   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5296   opcode(Assembler::or_op3, Assembler::arith_op);
 5297   ins_encode( form2_nop() );
 5298   ins_pipe(ialu_nop_A1);
 5299 %}
 5300 
 5301 // Nop using the memory functional unit
 5302 instruct Nop_MS( ) %{
 5303   ins_cost(0);
 5304 
 5305   format %{ &quot;NOP    ! Memory Pipeline&quot; %}
 5306   ins_encode( emit_mem_nop );
 5307   ins_pipe(mem_nop);
 5308 %}
 5309 
 5310 // Nop using the floating add functional unit
 5311 instruct Nop_FA( ) %{
 5312   ins_cost(0);
 5313 
 5314   format %{ &quot;NOP    ! Floating Add Pipeline&quot; %}
 5315   ins_encode( emit_fadd_nop );
 5316   ins_pipe(fadd_nop);
 5317 %}
 5318 
 5319 // Nop using the branch functional unit
 5320 instruct Nop_BR( ) %{
 5321   ins_cost(0);
 5322 
 5323   format %{ &quot;NOP    ! Branch Pipeline&quot; %}
 5324   ins_encode( emit_br_nop );
 5325   ins_pipe(br_nop);
 5326 %}
 5327 
 5328 //----------Load/Store/Move Instructions---------------------------------------
 5329 //----------Load Instructions--------------------------------------------------
 5330 // Load Byte (8bit signed)
 5331 instruct loadB(iRegI dst, memory mem) %{
 5332   match(Set dst (LoadB mem));
 5333   ins_cost(MEMORY_REF_COST);
 5334 
 5335   size(4);
 5336   format %{ &quot;LDSB   $mem,$dst\t! byte&quot; %}
 5337   ins_encode %{
 5338     __ ldsb($mem$$Address, $dst$$Register);
 5339   %}
 5340   ins_pipe(iload_mask_mem);
 5341 %}
 5342 
 5343 // Load Byte (8bit signed) into a Long Register
 5344 instruct loadB2L(iRegL dst, memory mem) %{
 5345   match(Set dst (ConvI2L (LoadB mem)));
 5346   ins_cost(MEMORY_REF_COST);
 5347 
 5348   size(4);
 5349   format %{ &quot;LDSB   $mem,$dst\t! byte -&gt; long&quot; %}
 5350   ins_encode %{
 5351     __ ldsb($mem$$Address, $dst$$Register);
 5352   %}
 5353   ins_pipe(iload_mask_mem);
 5354 %}
 5355 
 5356 // Load Unsigned Byte (8bit UNsigned) into an int reg
 5357 instruct loadUB(iRegI dst, memory mem) %{
 5358   match(Set dst (LoadUB mem));
 5359   ins_cost(MEMORY_REF_COST);
 5360 
 5361   size(4);
 5362   format %{ &quot;LDUB   $mem,$dst\t! ubyte&quot; %}
 5363   ins_encode %{
 5364     __ ldub($mem$$Address, $dst$$Register);
 5365   %}
 5366   ins_pipe(iload_mem);
 5367 %}
 5368 
 5369 // Load Unsigned Byte (8bit UNsigned) into a Long Register
 5370 instruct loadUB2L(iRegL dst, memory mem) %{
 5371   match(Set dst (ConvI2L (LoadUB mem)));
 5372   ins_cost(MEMORY_REF_COST);
 5373 
 5374   size(4);
 5375   format %{ &quot;LDUB   $mem,$dst\t! ubyte -&gt; long&quot; %}
 5376   ins_encode %{
 5377     __ ldub($mem$$Address, $dst$$Register);
 5378   %}
 5379   ins_pipe(iload_mem);
 5380 %}
 5381 
 5382 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 5383 instruct loadUB2L_immI(iRegL dst, memory mem, immI mask) %{
 5384   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5385   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5386 
 5387   size(2*4);
 5388   format %{ &quot;LDUB   $mem,$dst\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5389             &quot;AND    $dst,right_n_bits($mask, 8),$dst&quot; %}
 5390   ins_encode %{
 5391     __ ldub($mem$$Address, $dst$$Register);
 5392     __ and3($dst$$Register, $mask$$constant &amp; right_n_bits(8), $dst$$Register);
 5393   %}
 5394   ins_pipe(iload_mem);
 5395 %}
 5396 
 5397 // Load Short (16bit signed)
 5398 instruct loadS(iRegI dst, memory mem) %{
 5399   match(Set dst (LoadS mem));
 5400   ins_cost(MEMORY_REF_COST);
 5401 
 5402   size(4);
 5403   format %{ &quot;LDSH   $mem,$dst\t! short&quot; %}
 5404   ins_encode %{
 5405     __ ldsh($mem$$Address, $dst$$Register);
 5406   %}
 5407   ins_pipe(iload_mask_mem);
 5408 %}
 5409 
 5410 // Load Short (16 bit signed) to Byte (8 bit signed)
 5411 instruct loadS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5412   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5413   ins_cost(MEMORY_REF_COST);
 5414 
 5415   size(4);
 5416 
 5417   format %{ &quot;LDSB   $mem+1,$dst\t! short -&gt; byte&quot; %}
 5418   ins_encode %{
 5419     __ ldsb($mem$$Address, $dst$$Register, 1);
 5420   %}
 5421   ins_pipe(iload_mask_mem);
 5422 %}
 5423 
 5424 // Load Short (16bit signed) into a Long Register
 5425 instruct loadS2L(iRegL dst, memory mem) %{
 5426   match(Set dst (ConvI2L (LoadS mem)));
 5427   ins_cost(MEMORY_REF_COST);
 5428 
 5429   size(4);
 5430   format %{ &quot;LDSH   $mem,$dst\t! short -&gt; long&quot; %}
 5431   ins_encode %{
 5432     __ ldsh($mem$$Address, $dst$$Register);
 5433   %}
 5434   ins_pipe(iload_mask_mem);
 5435 %}
 5436 
 5437 // Load Unsigned Short/Char (16bit UNsigned)
 5438 instruct loadUS(iRegI dst, memory mem) %{
 5439   match(Set dst (LoadUS mem));
 5440   ins_cost(MEMORY_REF_COST);
 5441 
 5442   size(4);
 5443   format %{ &quot;LDUH   $mem,$dst\t! ushort/char&quot; %}
 5444   ins_encode %{
 5445     __ lduh($mem$$Address, $dst$$Register);
 5446   %}
 5447   ins_pipe(iload_mem);
 5448 %}
 5449 
 5450 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5451 instruct loadUS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5452   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5453   ins_cost(MEMORY_REF_COST);
 5454 
 5455   size(4);
 5456   format %{ &quot;LDSB   $mem+1,$dst\t! ushort -&gt; byte&quot; %}
 5457   ins_encode %{
 5458     __ ldsb($mem$$Address, $dst$$Register, 1);
 5459   %}
 5460   ins_pipe(iload_mask_mem);
 5461 %}
 5462 
 5463 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register
 5464 instruct loadUS2L(iRegL dst, memory mem) %{
 5465   match(Set dst (ConvI2L (LoadUS mem)));
 5466   ins_cost(MEMORY_REF_COST);
 5467 
 5468   size(4);
 5469   format %{ &quot;LDUH   $mem,$dst\t! ushort/char -&gt; long&quot; %}
 5470   ins_encode %{
 5471     __ lduh($mem$$Address, $dst$$Register);
 5472   %}
 5473   ins_pipe(iload_mem);
 5474 %}
 5475 
 5476 // Load Unsigned Short/Char (16bit UNsigned) with mask 0xFF into a Long Register
 5477 instruct loadUS2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5478   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5479   ins_cost(MEMORY_REF_COST);
 5480 
 5481   size(4);
 5482   format %{ &quot;LDUB   $mem+1,$dst\t! ushort/char &amp; 0xFF -&gt; long&quot; %}
 5483   ins_encode %{
 5484     __ ldub($mem$$Address, $dst$$Register, 1);  // LSB is index+1 on BE
 5485   %}
 5486   ins_pipe(iload_mem);
 5487 %}
 5488 
 5489 // Load Unsigned Short/Char (16bit UNsigned) with a 13-bit mask into a Long Register
 5490 instruct loadUS2L_immI13(iRegL dst, memory mem, immI13 mask) %{
 5491   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5492   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5493 
 5494   size(2*4);
 5495   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 13-bit mask -&gt; long\n\t&quot;
 5496             &quot;AND    $dst,$mask,$dst&quot; %}
 5497   ins_encode %{
 5498     Register Rdst = $dst$$Register;
 5499     __ lduh($mem$$Address, Rdst);
 5500     __ and3(Rdst, $mask$$constant, Rdst);
 5501   %}
 5502   ins_pipe(iload_mem);
 5503 %}
 5504 
 5505 // Load Unsigned Short/Char (16bit UNsigned) with a 32-bit mask into a Long Register
 5506 instruct loadUS2L_immI(iRegL dst, memory mem, immI mask, iRegL tmp) %{
 5507   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5508   effect(TEMP dst, TEMP tmp);
 5509   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5510 
 5511   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5512             &quot;SET    right_n_bits($mask, 16),$tmp\n\t&quot;
 5513             &quot;AND    $dst,$tmp,$dst&quot; %}
 5514   ins_encode %{
 5515     Register Rdst = $dst$$Register;
 5516     Register Rtmp = $tmp$$Register;
 5517     __ lduh($mem$$Address, Rdst);
 5518     __ set($mask$$constant &amp; right_n_bits(16), Rtmp);
 5519     __ and3(Rdst, Rtmp, Rdst);
 5520   %}
 5521   ins_pipe(iload_mem);
 5522 %}
 5523 
 5524 // Load Integer
 5525 instruct loadI(iRegI dst, memory mem) %{
 5526   match(Set dst (LoadI mem));
 5527   ins_cost(MEMORY_REF_COST);
 5528 
 5529   size(4);
 5530   format %{ &quot;LDUW   $mem,$dst\t! int&quot; %}
 5531   ins_encode %{
 5532     __ lduw($mem$$Address, $dst$$Register);
 5533   %}
 5534   ins_pipe(iload_mem);
 5535 %}
 5536 
 5537 // Load Integer to Byte (8 bit signed)
 5538 instruct loadI2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5539   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5540   ins_cost(MEMORY_REF_COST);
 5541 
 5542   size(4);
 5543 
 5544   format %{ &quot;LDSB   $mem+3,$dst\t! int -&gt; byte&quot; %}
 5545   ins_encode %{
 5546     __ ldsb($mem$$Address, $dst$$Register, 3);
 5547   %}
 5548   ins_pipe(iload_mask_mem);
 5549 %}
 5550 
 5551 // Load Integer to Unsigned Byte (8 bit UNsigned)
 5552 instruct loadI2UB(iRegI dst, indOffset13m7 mem, immI_255 mask) %{
 5553   match(Set dst (AndI (LoadI mem) mask));
 5554   ins_cost(MEMORY_REF_COST);
 5555 
 5556   size(4);
 5557 
 5558   format %{ &quot;LDUB   $mem+3,$dst\t! int -&gt; ubyte&quot; %}
 5559   ins_encode %{
 5560     __ ldub($mem$$Address, $dst$$Register, 3);
 5561   %}
 5562   ins_pipe(iload_mask_mem);
 5563 %}
 5564 
 5565 // Load Integer to Short (16 bit signed)
 5566 instruct loadI2S(iRegI dst, indOffset13m7 mem, immI_16 sixteen) %{
 5567   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5568   ins_cost(MEMORY_REF_COST);
 5569 
 5570   size(4);
 5571 
 5572   format %{ &quot;LDSH   $mem+2,$dst\t! int -&gt; short&quot; %}
 5573   ins_encode %{
 5574     __ ldsh($mem$$Address, $dst$$Register, 2);
 5575   %}
 5576   ins_pipe(iload_mask_mem);
 5577 %}
 5578 
 5579 // Load Integer to Unsigned Short (16 bit UNsigned)
 5580 instruct loadI2US(iRegI dst, indOffset13m7 mem, immI_65535 mask) %{
 5581   match(Set dst (AndI (LoadI mem) mask));
 5582   ins_cost(MEMORY_REF_COST);
 5583 
 5584   size(4);
 5585 
 5586   format %{ &quot;LDUH   $mem+2,$dst\t! int -&gt; ushort/char&quot; %}
 5587   ins_encode %{
 5588     __ lduh($mem$$Address, $dst$$Register, 2);
 5589   %}
 5590   ins_pipe(iload_mask_mem);
 5591 %}
 5592 
 5593 // Load Integer into a Long Register
 5594 instruct loadI2L(iRegL dst, memory mem) %{
 5595   match(Set dst (ConvI2L (LoadI mem)));
 5596   ins_cost(MEMORY_REF_COST);
 5597 
 5598   size(4);
 5599   format %{ &quot;LDSW   $mem,$dst\t! int -&gt; long&quot; %}
 5600   ins_encode %{
 5601     __ ldsw($mem$$Address, $dst$$Register);
 5602   %}
 5603   ins_pipe(iload_mask_mem);
 5604 %}
 5605 
 5606 // Load Integer with mask 0xFF into a Long Register
 5607 instruct loadI2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5608   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5609   ins_cost(MEMORY_REF_COST);
 5610 
 5611   size(4);
 5612   format %{ &quot;LDUB   $mem+3,$dst\t! int &amp; 0xFF -&gt; long&quot; %}
 5613   ins_encode %{
 5614     __ ldub($mem$$Address, $dst$$Register, 3);  // LSB is index+3 on BE
 5615   %}
 5616   ins_pipe(iload_mem);
 5617 %}
 5618 
 5619 // Load Integer with mask 0xFFFF into a Long Register
 5620 instruct loadI2L_immI_65535(iRegL dst, indOffset13m7 mem, immI_65535 mask) %{
 5621   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5622   ins_cost(MEMORY_REF_COST);
 5623 
 5624   size(4);
 5625   format %{ &quot;LDUH   $mem+2,$dst\t! int &amp; 0xFFFF -&gt; long&quot; %}
 5626   ins_encode %{
 5627     __ lduh($mem$$Address, $dst$$Register, 2);  // LSW is index+2 on BE
 5628   %}
 5629   ins_pipe(iload_mem);
 5630 %}
 5631 
 5632 // Load Integer with a 12-bit mask into a Long Register
 5633 instruct loadI2L_immU12(iRegL dst, memory mem, immU12 mask) %{
 5634   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5635   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5636 
 5637   size(2*4);
 5638   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 12-bit mask -&gt; long\n\t&quot;
 5639             &quot;AND    $dst,$mask,$dst&quot; %}
 5640   ins_encode %{
 5641     Register Rdst = $dst$$Register;
 5642     __ lduw($mem$$Address, Rdst);
 5643     __ and3(Rdst, $mask$$constant, Rdst);
 5644   %}
 5645   ins_pipe(iload_mem);
 5646 %}
 5647 
 5648 // Load Integer with a 31-bit mask into a Long Register
 5649 instruct loadI2L_immU31(iRegL dst, memory mem, immU31 mask, iRegL tmp) %{
 5650   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5651   effect(TEMP dst, TEMP tmp);
 5652   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5653 
 5654   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 31-bit mask -&gt; long\n\t&quot;
 5655             &quot;SET    $mask,$tmp\n\t&quot;
 5656             &quot;AND    $dst,$tmp,$dst&quot; %}
 5657   ins_encode %{
 5658     Register Rdst = $dst$$Register;
 5659     Register Rtmp = $tmp$$Register;
 5660     __ lduw($mem$$Address, Rdst);
 5661     __ set($mask$$constant, Rtmp);
 5662     __ and3(Rdst, Rtmp, Rdst);
 5663   %}
 5664   ins_pipe(iload_mem);
 5665 %}
 5666 
 5667 // Load Unsigned Integer into a Long Register
 5668 instruct loadUI2L(iRegL dst, memory mem, immL_32bits mask) %{
 5669   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5670   ins_cost(MEMORY_REF_COST);
 5671 
 5672   size(4);
 5673   format %{ &quot;LDUW   $mem,$dst\t! uint -&gt; long&quot; %}
 5674   ins_encode %{
 5675     __ lduw($mem$$Address, $dst$$Register);
 5676   %}
 5677   ins_pipe(iload_mem);
 5678 %}
 5679 
 5680 // Load Long - aligned
 5681 instruct loadL(iRegL dst, memory mem ) %{
 5682   match(Set dst (LoadL mem));
 5683   ins_cost(MEMORY_REF_COST);
 5684 
 5685   size(4);
 5686   format %{ &quot;LDX    $mem,$dst\t! long&quot; %}
 5687   ins_encode %{
 5688     __ ldx($mem$$Address, $dst$$Register);
 5689   %}
 5690   ins_pipe(iload_mem);
 5691 %}
 5692 
 5693 // Load Long - UNaligned
 5694 instruct loadL_unaligned(iRegL dst, memory mem, o7RegI tmp) %{
 5695   match(Set dst (LoadL_unaligned mem));
 5696   effect(KILL tmp);
 5697   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5698   format %{ &quot;LDUW   $mem+4,R_O7\t! misaligned long\n&quot;
 5699           &quot;\tLDUW   $mem  ,$dst\n&quot;
 5700           &quot;\tSLLX   #32, $dst, $dst\n&quot;
 5701           &quot;\tOR     $dst, R_O7, $dst&quot; %}
 5702   opcode(Assembler::lduw_op3);
 5703   ins_encode(form3_mem_reg_long_unaligned_marshal( mem, dst ));
 5704   ins_pipe(iload_mem);
 5705 %}
 5706 
 5707 // Load Range
 5708 instruct loadRange(iRegI dst, memory mem) %{
 5709   match(Set dst (LoadRange mem));
 5710   ins_cost(MEMORY_REF_COST);
 5711 
 5712   format %{ &quot;LDUW   $mem,$dst\t! range&quot; %}
 5713   opcode(Assembler::lduw_op3);
 5714   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5715   ins_pipe(iload_mem);
 5716 %}
 5717 
 5718 // Load Integer into %f register (for fitos/fitod)
 5719 instruct loadI_freg(regF dst, memory mem) %{
 5720   match(Set dst (LoadI mem));
 5721   ins_cost(MEMORY_REF_COST);
 5722 
 5723   format %{ &quot;LDF    $mem,$dst\t! for fitos/fitod&quot; %}
 5724   opcode(Assembler::ldf_op3);
 5725   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5726   ins_pipe(floadF_mem);
 5727 %}
 5728 
 5729 // Load Pointer
 5730 instruct loadP(iRegP dst, memory mem) %{
 5731   match(Set dst (LoadP mem));
 5732   ins_cost(MEMORY_REF_COST);
 5733   size(4);
 5734 
 5735   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 5736   ins_encode %{
 5737     __ ldx($mem$$Address, $dst$$Register);
 5738   %}
 5739   ins_pipe(iload_mem);
 5740 %}
 5741 
 5742 // Load Compressed Pointer
 5743 instruct loadN(iRegN dst, memory mem) %{
 5744   match(Set dst (LoadN mem));
 5745   ins_cost(MEMORY_REF_COST);
 5746   size(4);
 5747 
 5748   format %{ &quot;LDUW   $mem,$dst\t! compressed ptr&quot; %}
 5749   ins_encode %{
 5750     __ lduw($mem$$Address, $dst$$Register);
 5751   %}
 5752   ins_pipe(iload_mem);
 5753 %}
 5754 
 5755 // Load Klass Pointer
 5756 instruct loadKlass(iRegP dst, memory mem) %{
 5757   match(Set dst (LoadKlass mem));
 5758   ins_cost(MEMORY_REF_COST);
 5759   size(4);
 5760 
 5761   format %{ &quot;LDX    $mem,$dst\t! klass ptr&quot; %}
 5762   ins_encode %{
 5763     __ ldx($mem$$Address, $dst$$Register);
 5764   %}
 5765   ins_pipe(iload_mem);
 5766 %}
 5767 
 5768 // Load narrow Klass Pointer
 5769 instruct loadNKlass(iRegN dst, memory mem) %{
 5770   match(Set dst (LoadNKlass mem));
 5771   ins_cost(MEMORY_REF_COST);
 5772   size(4);
 5773 
 5774   format %{ &quot;LDUW   $mem,$dst\t! compressed klass ptr&quot; %}
 5775   ins_encode %{
 5776     __ lduw($mem$$Address, $dst$$Register);
 5777   %}
 5778   ins_pipe(iload_mem);
 5779 %}
 5780 
 5781 // Load Double
 5782 instruct loadD(regD dst, memory mem) %{
 5783   match(Set dst (LoadD mem));
 5784   ins_cost(MEMORY_REF_COST);
 5785 
 5786   format %{ &quot;LDDF   $mem,$dst&quot; %}
 5787   opcode(Assembler::lddf_op3);
 5788   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5789   ins_pipe(floadD_mem);
 5790 %}
 5791 
 5792 // Load Double - UNaligned
 5793 instruct loadD_unaligned(regD_low dst, memory mem ) %{
 5794   match(Set dst (LoadD_unaligned mem));
 5795   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5796   format %{ &quot;LDF    $mem  ,$dst.hi\t! misaligned double\n&quot;
 5797           &quot;\tLDF    $mem+4,$dst.lo\t!&quot; %}
 5798   opcode(Assembler::ldf_op3);
 5799   ins_encode( form3_mem_reg_double_unaligned( mem, dst ));
 5800   ins_pipe(iload_mem);
 5801 %}
 5802 
 5803 // Load Float
 5804 instruct loadF(regF dst, memory mem) %{
 5805   match(Set dst (LoadF mem));
 5806   ins_cost(MEMORY_REF_COST);
 5807 
 5808   format %{ &quot;LDF    $mem,$dst&quot; %}
 5809   opcode(Assembler::ldf_op3);
 5810   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5811   ins_pipe(floadF_mem);
 5812 %}
 5813 
 5814 // Load Constant
 5815 instruct loadConI( iRegI dst, immI src ) %{
 5816   match(Set dst src);
 5817   ins_cost(DEFAULT_COST * 3/2);
 5818   format %{ &quot;SET    $src,$dst&quot; %}
 5819   ins_encode( Set32(src, dst) );
 5820   ins_pipe(ialu_hi_lo_reg);
 5821 %}
 5822 
 5823 instruct loadConI13( iRegI dst, immI13 src ) %{
 5824   match(Set dst src);
 5825 
 5826   size(4);
 5827   format %{ &quot;MOV    $src,$dst&quot; %}
 5828   ins_encode( Set13( src, dst ) );
 5829   ins_pipe(ialu_imm);
 5830 %}
 5831 
 5832 instruct loadConP_set(iRegP dst, immP_set con) %{
 5833   match(Set dst con);
 5834   ins_cost(DEFAULT_COST * 3/2);
 5835   format %{ &quot;SET    $con,$dst\t! ptr&quot; %}
 5836   ins_encode %{
 5837     relocInfo::relocType constant_reloc = _opnds[1]-&gt;constant_reloc();
 5838       intptr_t val = $con$$constant;
 5839     if (constant_reloc == relocInfo::oop_type) {
 5840       __ set_oop_constant((jobject) val, $dst$$Register);
 5841     } else if (constant_reloc == relocInfo::metadata_type) {
 5842       __ set_metadata_constant((Metadata*)val, $dst$$Register);
 5843     } else {          // non-oop pointers, e.g. card mark base, heap top
 5844       assert(constant_reloc == relocInfo::none, &quot;unexpected reloc type&quot;);
 5845       __ set(val, $dst$$Register);
 5846     }
 5847   %}
 5848   ins_pipe(loadConP);
 5849 %}
 5850 
 5851 instruct loadConP_load(iRegP dst, immP_load con) %{
 5852   match(Set dst con);
 5853   ins_cost(MEMORY_REF_COST);
 5854   format %{ &quot;LD     [$constanttablebase + $constantoffset],$dst\t! load from constant table: ptr=$con&quot; %}
 5855   ins_encode %{
 5856     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5857     __ ld_ptr($constanttablebase, con_offset, $dst$$Register);
 5858   %}
 5859   ins_pipe(loadConP);
 5860 %}
 5861 
 5862 instruct loadConP_no_oop_cheap(iRegP dst, immP_no_oop_cheap con) %{
 5863   match(Set dst con);
 5864   ins_cost(DEFAULT_COST * 3/2);
 5865   format %{ &quot;SET    $con,$dst\t! non-oop ptr&quot; %}
 5866   ins_encode %{
 5867     if (_opnds[1]-&gt;constant_reloc() == relocInfo::metadata_type) {
 5868       __ set_metadata_constant((Metadata*)$con$$constant, $dst$$Register);
 5869     } else {
 5870       __ set($con$$constant, $dst$$Register);
 5871     }
 5872   %}
 5873   ins_pipe(loadConP);
 5874 %}
 5875 
 5876 instruct loadConP0(iRegP dst, immP0 src) %{
 5877   match(Set dst src);
 5878 
 5879   size(4);
 5880   format %{ &quot;CLR    $dst\t!ptr&quot; %}
 5881   ins_encode %{
 5882     __ clr($dst$$Register);
 5883   %}
 5884   ins_pipe(ialu_imm);
 5885 %}
 5886 
 5887 instruct loadConP_poll(iRegP dst, immP_poll src) %{
 5888   match(Set dst src);
 5889   ins_cost(DEFAULT_COST);
 5890   format %{ &quot;SET    $src,$dst\t!ptr&quot; %}
 5891   ins_encode %{
 5892     AddressLiteral polling_page(os::get_polling_page());
 5893     __ sethi(polling_page, reg_to_register_object($dst$$reg));
 5894   %}
 5895   ins_pipe(loadConP_poll);
 5896 %}
 5897 
 5898 instruct loadConN0(iRegN dst, immN0 src) %{
 5899   match(Set dst src);
 5900 
 5901   size(4);
 5902   format %{ &quot;CLR    $dst\t! compressed NULL ptr&quot; %}
 5903   ins_encode %{
 5904     __ clr($dst$$Register);
 5905   %}
 5906   ins_pipe(ialu_imm);
 5907 %}
 5908 
 5909 instruct loadConN(iRegN dst, immN src) %{
 5910   match(Set dst src);
 5911   ins_cost(DEFAULT_COST * 3/2);
 5912   format %{ &quot;SET    $src,$dst\t! compressed ptr&quot; %}
 5913   ins_encode %{
 5914     Register dst = $dst$$Register;
 5915     __ set_narrow_oop((jobject)$src$$constant, dst);
 5916   %}
 5917   ins_pipe(ialu_hi_lo_reg);
 5918 %}
 5919 
 5920 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 5921   match(Set dst src);
 5922   ins_cost(DEFAULT_COST * 3/2);
 5923   format %{ &quot;SET    $src,$dst\t! compressed klass ptr&quot; %}
 5924   ins_encode %{
 5925     Register dst = $dst$$Register;
 5926     __ set_narrow_klass((Klass*)$src$$constant, dst);
 5927   %}
 5928   ins_pipe(ialu_hi_lo_reg);
 5929 %}
 5930 
 5931 // Materialize long value (predicated by immL_cheap).
 5932 instruct loadConL_set64(iRegL dst, immL_cheap con, o7RegL tmp) %{
 5933   match(Set dst con);
 5934   effect(KILL tmp);
 5935   ins_cost(DEFAULT_COST * 3);
 5936   format %{ &quot;SET64   $con,$dst KILL $tmp\t! cheap long&quot; %}
 5937   ins_encode %{
 5938     __ set64($con$$constant, $dst$$Register, $tmp$$Register);
 5939   %}
 5940   ins_pipe(loadConL);
 5941 %}
 5942 
 5943 // Load long value from constant table (predicated by immL_expensive).
 5944 instruct loadConL_ldx(iRegL dst, immL_expensive con) %{
 5945   match(Set dst con);
 5946   ins_cost(MEMORY_REF_COST);
 5947   format %{ &quot;LDX     [$constanttablebase + $constantoffset],$dst\t! load from constant table: long=$con&quot; %}
 5948   ins_encode %{
 5949       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5950     __ ldx($constanttablebase, con_offset, $dst$$Register);
 5951   %}
 5952   ins_pipe(loadConL);
 5953 %}
 5954 
 5955 instruct loadConL0( iRegL dst, immL0 src ) %{
 5956   match(Set dst src);
 5957   ins_cost(DEFAULT_COST);
 5958   size(4);
 5959   format %{ &quot;CLR    $dst\t! long&quot; %}
 5960   ins_encode( Set13( src, dst ) );
 5961   ins_pipe(ialu_imm);
 5962 %}
 5963 
 5964 instruct loadConL13( iRegL dst, immL13 src ) %{
 5965   match(Set dst src);
 5966   ins_cost(DEFAULT_COST * 2);
 5967 
 5968   size(4);
 5969   format %{ &quot;MOV    $src,$dst\t! long&quot; %}
 5970   ins_encode( Set13( src, dst ) );
 5971   ins_pipe(ialu_imm);
 5972 %}
 5973 
 5974 instruct loadConF(regF dst, immF con, o7RegI tmp) %{
 5975   match(Set dst con);
 5976   effect(KILL tmp);
 5977   format %{ &quot;LDF    [$constanttablebase + $constantoffset],$dst\t! load from constant table: float=$con&quot; %}
 5978   ins_encode %{
 5979       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5980     __ ldf(FloatRegisterImpl::S, $constanttablebase, con_offset, $dst$$FloatRegister);
 5981   %}
 5982   ins_pipe(loadConFD);
 5983 %}
 5984 
 5985 instruct loadConD(regD dst, immD con, o7RegI tmp) %{
 5986   match(Set dst con);
 5987   effect(KILL tmp);
 5988   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: double=$con&quot; %}
 5989   ins_encode %{
 5990     // XXX This is a quick fix for 6833573.
 5991     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset($con), $dst$$FloatRegister);
 5992     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5993     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
 5994   %}
 5995   ins_pipe(loadConFD);
 5996 %}
 5997 
 5998 // Prefetch instructions for allocation.
 5999 // Must be safe to execute with invalid address (cannot fault).
 6000 
 6001 instruct prefetchAlloc( memory mem ) %{
 6002   predicate(AllocatePrefetchInstr == 0);
 6003   match( PrefetchAllocation mem );
 6004   ins_cost(MEMORY_REF_COST);
 6005 
 6006   format %{ &quot;PREFETCH $mem,2\t! Prefetch allocation&quot; %}
 6007   opcode(Assembler::prefetch_op3);
 6008   ins_encode( form3_mem_prefetch_write( mem ) );
 6009   ins_pipe(iload_mem);
 6010 %}
 6011 
 6012 // Use BIS instruction to prefetch for allocation.
 6013 // Could fault, need space at the end of TLAB.
 6014 instruct prefetchAlloc_bis( iRegP dst ) %{
 6015   predicate(AllocatePrefetchInstr == 1);
 6016   match( PrefetchAllocation dst );
 6017   ins_cost(MEMORY_REF_COST);
 6018   size(4);
 6019 
 6020   format %{ &quot;STXA   [$dst]\t! // Prefetch allocation using BIS&quot; %}
 6021   ins_encode %{
 6022     __ stxa(G0, $dst$$Register, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
 6023   %}
 6024   ins_pipe(istore_mem_reg);
 6025 %}
 6026 
 6027 // Next code is used for finding next cache line address to prefetch.
 6028 instruct cacheLineAdr( iRegP dst, iRegP src, immL13 mask ) %{
 6029   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
 6030   ins_cost(DEFAULT_COST);
 6031   size(4);
 6032 
 6033   format %{ &quot;AND    $src,$mask,$dst\t! next cache line address&quot; %}
 6034   ins_encode %{
 6035     __ and3($src$$Register, $mask$$constant, $dst$$Register);
 6036   %}
 6037   ins_pipe(ialu_reg_imm);
 6038 %}
 6039 
 6040 //----------Store Instructions-------------------------------------------------
 6041 // Store Byte
 6042 instruct storeB(memory mem, iRegI src) %{
 6043   match(Set mem (StoreB mem src));
 6044   ins_cost(MEMORY_REF_COST);
 6045 
 6046   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6047   opcode(Assembler::stb_op3);
 6048   ins_encode(simple_form3_mem_reg( mem, src ) );
 6049   ins_pipe(istore_mem_reg);
 6050 %}
 6051 
 6052 instruct storeB0(memory mem, immI0 src) %{
 6053   match(Set mem (StoreB mem src));
 6054   ins_cost(MEMORY_REF_COST);
 6055 
 6056   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6057   opcode(Assembler::stb_op3);
 6058   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6059   ins_pipe(istore_mem_zero);
 6060 %}
 6061 
 6062 instruct storeCM0(memory mem, immI0 src) %{
 6063   match(Set mem (StoreCM mem src));
 6064   ins_cost(MEMORY_REF_COST);
 6065 
 6066   format %{ &quot;STB    $src,$mem\t! CMS card-mark byte 0&quot; %}
 6067   opcode(Assembler::stb_op3);
 6068   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6069   ins_pipe(istore_mem_zero);
 6070 %}
 6071 
 6072 // Store Char/Short
 6073 instruct storeC(memory mem, iRegI src) %{
 6074   match(Set mem (StoreC mem src));
 6075   ins_cost(MEMORY_REF_COST);
 6076 
 6077   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6078   opcode(Assembler::sth_op3);
 6079   ins_encode(simple_form3_mem_reg( mem, src ) );
 6080   ins_pipe(istore_mem_reg);
 6081 %}
 6082 
 6083 instruct storeC0(memory mem, immI0 src) %{
 6084   match(Set mem (StoreC mem src));
 6085   ins_cost(MEMORY_REF_COST);
 6086 
 6087   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6088   opcode(Assembler::sth_op3);
 6089   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6090   ins_pipe(istore_mem_zero);
 6091 %}
 6092 
 6093 // Store Integer
 6094 instruct storeI(memory mem, iRegI src) %{
 6095   match(Set mem (StoreI mem src));
 6096   ins_cost(MEMORY_REF_COST);
 6097 
 6098   format %{ &quot;STW    $src,$mem&quot; %}
 6099   opcode(Assembler::stw_op3);
 6100   ins_encode(simple_form3_mem_reg( mem, src ) );
 6101   ins_pipe(istore_mem_reg);
 6102 %}
 6103 
 6104 // Store Long
 6105 instruct storeL(memory mem, iRegL src) %{
 6106   match(Set mem (StoreL mem src));
 6107   ins_cost(MEMORY_REF_COST);
 6108   format %{ &quot;STX    $src,$mem\t! long&quot; %}
 6109   opcode(Assembler::stx_op3);
 6110   ins_encode(simple_form3_mem_reg( mem, src ) );
 6111   ins_pipe(istore_mem_reg);
 6112 %}
 6113 
 6114 instruct storeI0(memory mem, immI0 src) %{
 6115   match(Set mem (StoreI mem src));
 6116   ins_cost(MEMORY_REF_COST);
 6117 
 6118   format %{ &quot;STW    $src,$mem&quot; %}
 6119   opcode(Assembler::stw_op3);
 6120   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6121   ins_pipe(istore_mem_zero);
 6122 %}
 6123 
 6124 instruct storeL0(memory mem, immL0 src) %{
 6125   match(Set mem (StoreL mem src));
 6126   ins_cost(MEMORY_REF_COST);
 6127 
 6128   format %{ &quot;STX    $src,$mem&quot; %}
 6129   opcode(Assembler::stx_op3);
 6130   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6131   ins_pipe(istore_mem_zero);
 6132 %}
 6133 
 6134 // Store Integer from float register (used after fstoi)
 6135 instruct storeI_Freg(memory mem, regF src) %{
 6136   match(Set mem (StoreI mem src));
 6137   ins_cost(MEMORY_REF_COST);
 6138 
 6139   format %{ &quot;STF    $src,$mem\t! after fstoi/fdtoi&quot; %}
 6140   opcode(Assembler::stf_op3);
 6141   ins_encode(simple_form3_mem_reg( mem, src ) );
 6142   ins_pipe(fstoreF_mem_reg);
 6143 %}
 6144 
 6145 // Store Pointer
 6146 instruct storeP(memory dst, sp_ptr_RegP src) %{
 6147   match(Set dst (StoreP dst src));
 6148   ins_cost(MEMORY_REF_COST);
 6149 
 6150   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6151   opcode(Assembler::stx_op3, 0, REGP_OP);
 6152   ins_encode( form3_mem_reg( dst, src ) );
 6153   ins_pipe(istore_mem_spORreg);
 6154 %}
 6155 
 6156 instruct storeP0(memory dst, immP0 src) %{
 6157   match(Set dst (StoreP dst src));
 6158   ins_cost(MEMORY_REF_COST);
 6159 
 6160   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6161   opcode(Assembler::stx_op3, 0, REGP_OP);
 6162   ins_encode( form3_mem_reg( dst, R_G0 ) );
 6163   ins_pipe(istore_mem_zero);
 6164 %}
 6165 
 6166 // Store Compressed Pointer
 6167 instruct storeN(memory dst, iRegN src) %{
 6168    match(Set dst (StoreN dst src));
 6169    ins_cost(MEMORY_REF_COST);
 6170    size(4);
 6171 
 6172    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6173    ins_encode %{
 6174      Register base = as_Register($dst$$base);
 6175      Register index = as_Register($dst$$index);
 6176      Register src = $src$$Register;
 6177      if (index != G0) {
 6178        __ stw(src, base, index);
 6179      } else {
 6180        __ stw(src, base, $dst$$disp);
 6181      }
 6182    %}
 6183    ins_pipe(istore_mem_spORreg);
 6184 %}
 6185 
 6186 instruct storeNKlass(memory dst, iRegN src) %{
 6187    match(Set dst (StoreNKlass dst src));
 6188    ins_cost(MEMORY_REF_COST);
 6189    size(4);
 6190 
 6191    format %{ &quot;STW    $src,$dst\t! compressed klass ptr&quot; %}
 6192    ins_encode %{
 6193      Register base = as_Register($dst$$base);
 6194      Register index = as_Register($dst$$index);
 6195      Register src = $src$$Register;
 6196      if (index != G0) {
 6197        __ stw(src, base, index);
 6198      } else {
 6199        __ stw(src, base, $dst$$disp);
 6200      }
 6201    %}
 6202    ins_pipe(istore_mem_spORreg);
 6203 %}
 6204 
 6205 instruct storeN0(memory dst, immN0 src) %{
 6206    match(Set dst (StoreN dst src));
 6207    ins_cost(MEMORY_REF_COST);
 6208    size(4);
 6209 
 6210    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6211    ins_encode %{
 6212      Register base = as_Register($dst$$base);
 6213      Register index = as_Register($dst$$index);
 6214      if (index != G0) {
 6215        __ stw(0, base, index);
 6216      } else {
 6217        __ stw(0, base, $dst$$disp);
 6218      }
 6219    %}
 6220    ins_pipe(istore_mem_zero);
 6221 %}
 6222 
 6223 // Store Double
 6224 instruct storeD( memory mem, regD src) %{
 6225   match(Set mem (StoreD mem src));
 6226   ins_cost(MEMORY_REF_COST);
 6227 
 6228   format %{ &quot;STDF   $src,$mem&quot; %}
 6229   opcode(Assembler::stdf_op3);
 6230   ins_encode(simple_form3_mem_reg( mem, src ) );
 6231   ins_pipe(fstoreD_mem_reg);
 6232 %}
 6233 
 6234 instruct storeD0( memory mem, immD0 src) %{
 6235   match(Set mem (StoreD mem src));
 6236   ins_cost(MEMORY_REF_COST);
 6237 
 6238   format %{ &quot;STX    $src,$mem&quot; %}
 6239   opcode(Assembler::stx_op3);
 6240   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6241   ins_pipe(fstoreD_mem_zero);
 6242 %}
 6243 
 6244 // Store Float
 6245 instruct storeF( memory mem, regF src) %{
 6246   match(Set mem (StoreF mem src));
 6247   ins_cost(MEMORY_REF_COST);
 6248 
 6249   format %{ &quot;STF    $src,$mem&quot; %}
 6250   opcode(Assembler::stf_op3);
 6251   ins_encode(simple_form3_mem_reg( mem, src ) );
 6252   ins_pipe(fstoreF_mem_reg);
 6253 %}
 6254 
 6255 instruct storeF0( memory mem, immF0 src) %{
 6256   match(Set mem (StoreF mem src));
 6257   ins_cost(MEMORY_REF_COST);
 6258 
 6259   format %{ &quot;STW    $src,$mem\t! storeF0&quot; %}
 6260   opcode(Assembler::stw_op3);
 6261   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6262   ins_pipe(fstoreF_mem_zero);
 6263 %}
 6264 
 6265 // Convert oop pointer into compressed form
 6266 instruct encodeHeapOop(iRegN dst, iRegP src) %{
 6267   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6268   match(Set dst (EncodeP src));
 6269   format %{ &quot;encode_heap_oop $src, $dst&quot; %}
 6270   ins_encode %{
 6271     __ encode_heap_oop($src$$Register, $dst$$Register);
 6272   %}
 6273   ins_avoid_back_to_back(CompressedOops::base() == NULL ? AVOID_NONE : AVOID_BEFORE);
 6274   ins_pipe(ialu_reg);
 6275 %}
 6276 
 6277 instruct encodeHeapOop_not_null(iRegN dst, iRegP src) %{
 6278   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6279   match(Set dst (EncodeP src));
 6280   format %{ &quot;encode_heap_oop_not_null $src, $dst&quot; %}
 6281   ins_encode %{
 6282     __ encode_heap_oop_not_null($src$$Register, $dst$$Register);
 6283   %}
 6284   ins_pipe(ialu_reg);
 6285 %}
 6286 
 6287 instruct decodeHeapOop(iRegP dst, iRegN src) %{
 6288   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6289             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant);
 6290   match(Set dst (DecodeN src));
 6291   format %{ &quot;decode_heap_oop $src, $dst&quot; %}
 6292   ins_encode %{
 6293     __ decode_heap_oop($src$$Register, $dst$$Register);
 6294   %}
 6295   ins_pipe(ialu_reg);
 6296 %}
 6297 
 6298 instruct decodeHeapOop_not_null(iRegP dst, iRegN src) %{
 6299   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 6300             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant);
 6301   match(Set dst (DecodeN src));
 6302   format %{ &quot;decode_heap_oop_not_null $src, $dst&quot; %}
 6303   ins_encode %{
 6304     __ decode_heap_oop_not_null($src$$Register, $dst$$Register);
 6305   %}
 6306   ins_pipe(ialu_reg);
 6307 %}
 6308 
 6309 instruct encodeKlass_not_null(iRegN dst, iRegP src) %{
 6310   match(Set dst (EncodePKlass src));
 6311   format %{ &quot;encode_klass_not_null $src, $dst&quot; %}
 6312   ins_encode %{
 6313     __ encode_klass_not_null($src$$Register, $dst$$Register);
 6314   %}
 6315   ins_pipe(ialu_reg);
 6316 %}
 6317 
 6318 instruct decodeKlass_not_null(iRegP dst, iRegN src) %{
 6319   match(Set dst (DecodeNKlass src));
 6320   format %{ &quot;decode_klass_not_null $src, $dst&quot; %}
 6321   ins_encode %{
 6322     __ decode_klass_not_null($src$$Register, $dst$$Register);
 6323   %}
 6324   ins_pipe(ialu_reg);
 6325 %}
 6326 
 6327 //----------MemBar Instructions-----------------------------------------------
 6328 // Memory barrier flavors
 6329 
 6330 instruct membar_acquire() %{
 6331   match(MemBarAcquire);
 6332   match(LoadFence);
 6333   ins_cost(4*MEMORY_REF_COST);
 6334 
 6335   size(0);
 6336   format %{ &quot;MEMBAR-acquire&quot; %}
 6337   ins_encode( enc_membar_acquire );
 6338   ins_pipe(long_memory_op);
 6339 %}
 6340 
 6341 instruct membar_acquire_lock() %{
 6342   match(MemBarAcquireLock);
 6343   ins_cost(0);
 6344 
 6345   size(0);
 6346   format %{ &quot;!MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 6347   ins_encode( );
 6348   ins_pipe(empty);
 6349 %}
 6350 
 6351 instruct membar_release() %{
 6352   match(MemBarRelease);
 6353   match(StoreFence);
 6354   ins_cost(4*MEMORY_REF_COST);
 6355 
 6356   size(0);
 6357   format %{ &quot;MEMBAR-release&quot; %}
 6358   ins_encode( enc_membar_release );
 6359   ins_pipe(long_memory_op);
 6360 %}
 6361 
 6362 instruct membar_release_lock() %{
 6363   match(MemBarReleaseLock);
 6364   ins_cost(0);
 6365 
 6366   size(0);
 6367   format %{ &quot;!MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 6368   ins_encode( );
 6369   ins_pipe(empty);
 6370 %}
 6371 
 6372 instruct membar_volatile() %{
 6373   match(MemBarVolatile);
 6374   ins_cost(4*MEMORY_REF_COST);
 6375 
 6376   size(4);
 6377   format %{ &quot;MEMBAR-volatile&quot; %}
 6378   ins_encode( enc_membar_volatile );
 6379   ins_pipe(long_memory_op);
 6380 %}
 6381 
 6382 instruct unnecessary_membar_volatile() %{
 6383   match(MemBarVolatile);
 6384   predicate(Matcher::post_store_load_barrier(n));
 6385   ins_cost(0);
 6386 
 6387   size(0);
 6388   format %{ &quot;!MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6389   ins_encode( );
 6390   ins_pipe(empty);
 6391 %}
 6392 
 6393 instruct membar_storestore() %{
 6394   match(MemBarStoreStore);
 6395   ins_cost(0);
 6396 
 6397   size(0);
 6398   format %{ &quot;!MEMBAR-storestore (empty encoding)&quot; %}
 6399   ins_encode( );
 6400   ins_pipe(empty);
 6401 %}
 6402 
 6403 //----------Register Move Instructions-----------------------------------------
 6404 instruct roundDouble_nop(regD dst) %{
 6405   match(Set dst (RoundDouble dst));
 6406   ins_cost(0);
 6407   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6408   ins_encode( );
 6409   ins_pipe(empty);
 6410 %}
 6411 
 6412 
 6413 instruct roundFloat_nop(regF dst) %{
 6414   match(Set dst (RoundFloat dst));
 6415   ins_cost(0);
 6416   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6417   ins_encode( );
 6418   ins_pipe(empty);
 6419 %}
 6420 
 6421 
 6422 // Cast Index to Pointer for unsafe natives
 6423 instruct castX2P(iRegX src, iRegP dst) %{
 6424   match(Set dst (CastX2P src));
 6425 
 6426   format %{ &quot;MOV    $src,$dst\t! IntX-&gt;Ptr&quot; %}
 6427   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6428   ins_pipe(ialu_reg);
 6429 %}
 6430 
 6431 // Cast Pointer to Index for unsafe natives
 6432 instruct castP2X(iRegP src, iRegX dst) %{
 6433   match(Set dst (CastP2X src));
 6434 
 6435   format %{ &quot;MOV    $src,$dst\t! Ptr-&gt;IntX&quot; %}
 6436   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6437   ins_pipe(ialu_reg);
 6438 %}
 6439 
 6440 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 6441   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6442   match(Set stkSlot src);   // chain rule
 6443   ins_cost(MEMORY_REF_COST);
 6444   format %{ &quot;STDF   $src,$stkSlot\t!stk&quot; %}
 6445   opcode(Assembler::stdf_op3);
 6446   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6447   ins_pipe(fstoreD_stk_reg);
 6448 %}
 6449 
 6450 instruct ldfSSD(regD dst, stackSlotD stkSlot) %{
 6451   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6452   match(Set dst stkSlot);   // chain rule
 6453   ins_cost(MEMORY_REF_COST);
 6454   format %{ &quot;LDDF   $stkSlot,$dst\t!stk&quot; %}
 6455   opcode(Assembler::lddf_op3);
 6456   ins_encode(simple_form3_mem_reg(stkSlot, dst));
 6457   ins_pipe(floadD_stk);
 6458 %}
 6459 
 6460 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 6461   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6462   match(Set stkSlot src);   // chain rule
 6463   ins_cost(MEMORY_REF_COST);
 6464   format %{ &quot;STF   $src,$stkSlot\t!stk&quot; %}
 6465   opcode(Assembler::stf_op3);
 6466   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6467   ins_pipe(fstoreF_stk_reg);
 6468 %}
 6469 
 6470 //----------Conditional Move---------------------------------------------------
 6471 // Conditional move
 6472 instruct cmovIP_reg(cmpOpP cmp, flagsRegP pcc, iRegI dst, iRegI src) %{
 6473   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6474   ins_cost(150);
 6475   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6476   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6477   ins_pipe(ialu_reg);
 6478 %}
 6479 
 6480 instruct cmovIP_imm(cmpOpP cmp, flagsRegP pcc, iRegI dst, immI11 src) %{
 6481   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6482   ins_cost(140);
 6483   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6484   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6485   ins_pipe(ialu_imm);
 6486 %}
 6487 
 6488 instruct cmovII_reg(cmpOp cmp, flagsReg icc, iRegI dst, iRegI src) %{
 6489   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6490   ins_cost(150);
 6491   size(4);
 6492   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6493   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6494   ins_pipe(ialu_reg);
 6495 %}
 6496 
 6497 instruct cmovII_imm(cmpOp cmp, flagsReg icc, iRegI dst, immI11 src) %{
 6498   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6499   ins_cost(140);
 6500   size(4);
 6501   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6502   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6503   ins_pipe(ialu_imm);
 6504 %}
 6505 
 6506 instruct cmovIIu_reg(cmpOpU cmp, flagsRegU icc, iRegI dst, iRegI src) %{
 6507   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6508   ins_cost(150);
 6509   size(4);
 6510   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6511   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6512   ins_pipe(ialu_reg);
 6513 %}
 6514 
 6515 instruct cmovIIu_imm(cmpOpU cmp, flagsRegU icc, iRegI dst, immI11 src) %{
 6516   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6517   ins_cost(140);
 6518   size(4);
 6519   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6520   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6521   ins_pipe(ialu_imm);
 6522 %}
 6523 
 6524 instruct cmovIF_reg(cmpOpF cmp, flagsRegF fcc, iRegI dst, iRegI src) %{
 6525   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6526   ins_cost(150);
 6527   size(4);
 6528   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6529   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6530   ins_pipe(ialu_reg);
 6531 %}
 6532 
 6533 instruct cmovIF_imm(cmpOpF cmp, flagsRegF fcc, iRegI dst, immI11 src) %{
 6534   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6535   ins_cost(140);
 6536   size(4);
 6537   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6538   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6539   ins_pipe(ialu_imm);
 6540 %}
 6541 
 6542 // Conditional move for RegN. Only cmov(reg,reg).
 6543 instruct cmovNP_reg(cmpOpP cmp, flagsRegP pcc, iRegN dst, iRegN src) %{
 6544   match(Set dst (CMoveN (Binary cmp pcc) (Binary dst src)));
 6545   ins_cost(150);
 6546   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6547   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6548   ins_pipe(ialu_reg);
 6549 %}
 6550 
 6551 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6552 instruct cmovNI_reg(cmpOp cmp, flagsReg icc, iRegN dst, iRegN src) %{
 6553   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6554   ins_cost(150);
 6555   size(4);
 6556   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6557   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6558   ins_pipe(ialu_reg);
 6559 %}
 6560 
 6561 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6562 instruct cmovNIu_reg(cmpOpU cmp, flagsRegU icc, iRegN dst, iRegN src) %{
 6563   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6564   ins_cost(150);
 6565   size(4);
 6566   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6567   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6568   ins_pipe(ialu_reg);
 6569 %}
 6570 
 6571 instruct cmovNF_reg(cmpOpF cmp, flagsRegF fcc, iRegN dst, iRegN src) %{
 6572   match(Set dst (CMoveN (Binary cmp fcc) (Binary dst src)));
 6573   ins_cost(150);
 6574   size(4);
 6575   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6576   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6577   ins_pipe(ialu_reg);
 6578 %}
 6579 
 6580 // Conditional move
 6581 instruct cmovPP_reg(cmpOpP cmp, flagsRegP pcc, iRegP dst, iRegP src) %{
 6582   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6583   ins_cost(150);
 6584   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6585   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6586   ins_pipe(ialu_reg);
 6587 %}
 6588 
 6589 instruct cmovPP_imm(cmpOpP cmp, flagsRegP pcc, iRegP dst, immP0 src) %{
 6590   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6591   ins_cost(140);
 6592   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6593   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6594   ins_pipe(ialu_imm);
 6595 %}
 6596 
 6597 // This instruction also works with CmpN so we don&#39;t need cmovPN_reg.
 6598 instruct cmovPI_reg(cmpOp cmp, flagsReg icc, iRegP dst, iRegP src) %{
 6599   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6600   ins_cost(150);
 6601 
 6602   size(4);
 6603   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6604   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6605   ins_pipe(ialu_reg);
 6606 %}
 6607 
 6608 instruct cmovPIu_reg(cmpOpU cmp, flagsRegU icc, iRegP dst, iRegP src) %{
 6609   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6610   ins_cost(150);
 6611 
 6612   size(4);
 6613   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6614   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6615   ins_pipe(ialu_reg);
 6616 %}
 6617 
 6618 instruct cmovPI_imm(cmpOp cmp, flagsReg icc, iRegP dst, immP0 src) %{
 6619   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6620   ins_cost(140);
 6621 
 6622   size(4);
 6623   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6624   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6625   ins_pipe(ialu_imm);
 6626 %}
 6627 
 6628 instruct cmovPIu_imm(cmpOpU cmp, flagsRegU icc, iRegP dst, immP0 src) %{
 6629   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6630   ins_cost(140);
 6631 
 6632   size(4);
 6633   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6634   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6635   ins_pipe(ialu_imm);
 6636 %}
 6637 
 6638 instruct cmovPF_reg(cmpOpF cmp, flagsRegF fcc, iRegP dst, iRegP src) %{
 6639   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6640   ins_cost(150);
 6641   size(4);
 6642   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6643   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6644   ins_pipe(ialu_imm);
 6645 %}
 6646 
 6647 instruct cmovPF_imm(cmpOpF cmp, flagsRegF fcc, iRegP dst, immP0 src) %{
 6648   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6649   ins_cost(140);
 6650   size(4);
 6651   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6652   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6653   ins_pipe(ialu_imm);
 6654 %}
 6655 
 6656 // Conditional move
 6657 instruct cmovFP_reg(cmpOpP cmp, flagsRegP pcc, regF dst, regF src) %{
 6658   match(Set dst (CMoveF (Binary cmp pcc) (Binary dst src)));
 6659   ins_cost(150);
 6660   opcode(0x101);
 6661   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6662   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6663   ins_pipe(int_conditional_float_move);
 6664 %}
 6665 
 6666 instruct cmovFI_reg(cmpOp cmp, flagsReg icc, regF dst, regF src) %{
 6667   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6668   ins_cost(150);
 6669 
 6670   size(4);
 6671   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6672   opcode(0x101);
 6673   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6674   ins_pipe(int_conditional_float_move);
 6675 %}
 6676 
 6677 instruct cmovFIu_reg(cmpOpU cmp, flagsRegU icc, regF dst, regF src) %{
 6678   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6679   ins_cost(150);
 6680 
 6681   size(4);
 6682   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6683   opcode(0x101);
 6684   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6685   ins_pipe(int_conditional_float_move);
 6686 %}
 6687 
 6688 // Conditional move,
 6689 instruct cmovFF_reg(cmpOpF cmp, flagsRegF fcc, regF dst, regF src) %{
 6690   match(Set dst (CMoveF (Binary cmp fcc) (Binary dst src)));
 6691   ins_cost(150);
 6692   size(4);
 6693   format %{ &quot;FMOVF$cmp $fcc,$src,$dst&quot; %}
 6694   opcode(0x1);
 6695   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6696   ins_pipe(int_conditional_double_move);
 6697 %}
 6698 
 6699 // Conditional move
 6700 instruct cmovDP_reg(cmpOpP cmp, flagsRegP pcc, regD dst, regD src) %{
 6701   match(Set dst (CMoveD (Binary cmp pcc) (Binary dst src)));
 6702   ins_cost(150);
 6703   size(4);
 6704   opcode(0x102);
 6705   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6706   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6707   ins_pipe(int_conditional_double_move);
 6708 %}
 6709 
 6710 instruct cmovDI_reg(cmpOp cmp, flagsReg icc, regD dst, regD src) %{
 6711   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6712   ins_cost(150);
 6713 
 6714   size(4);
 6715   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6716   opcode(0x102);
 6717   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6718   ins_pipe(int_conditional_double_move);
 6719 %}
 6720 
 6721 instruct cmovDIu_reg(cmpOpU cmp, flagsRegU icc, regD dst, regD src) %{
 6722   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6723   ins_cost(150);
 6724 
 6725   size(4);
 6726   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6727   opcode(0x102);
 6728   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6729   ins_pipe(int_conditional_double_move);
 6730 %}
 6731 
 6732 // Conditional move,
 6733 instruct cmovDF_reg(cmpOpF cmp, flagsRegF fcc, regD dst, regD src) %{
 6734   match(Set dst (CMoveD (Binary cmp fcc) (Binary dst src)));
 6735   ins_cost(150);
 6736   size(4);
 6737   format %{ &quot;FMOVD$cmp $fcc,$src,$dst&quot; %}
 6738   opcode(0x2);
 6739   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6740   ins_pipe(int_conditional_double_move);
 6741 %}
 6742 
 6743 // Conditional move
 6744 instruct cmovLP_reg(cmpOpP cmp, flagsRegP pcc, iRegL dst, iRegL src) %{
 6745   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6746   ins_cost(150);
 6747   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6748   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6749   ins_pipe(ialu_reg);
 6750 %}
 6751 
 6752 instruct cmovLP_imm(cmpOpP cmp, flagsRegP pcc, iRegL dst, immI11 src) %{
 6753   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6754   ins_cost(140);
 6755   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6756   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6757   ins_pipe(ialu_imm);
 6758 %}
 6759 
 6760 instruct cmovLI_reg(cmpOp cmp, flagsReg icc, iRegL dst, iRegL src) %{
 6761   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6762   ins_cost(150);
 6763 
 6764   size(4);
 6765   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6766   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6767   ins_pipe(ialu_reg);
 6768 %}
 6769 
 6770 
 6771 instruct cmovLIu_reg(cmpOpU cmp, flagsRegU icc, iRegL dst, iRegL src) %{
 6772   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6773   ins_cost(150);
 6774 
 6775   size(4);
 6776   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6777   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6778   ins_pipe(ialu_reg);
 6779 %}
 6780 
 6781 
 6782 instruct cmovLF_reg(cmpOpF cmp, flagsRegF fcc, iRegL dst, iRegL src) %{
 6783   match(Set dst (CMoveL (Binary cmp fcc) (Binary dst src)));
 6784   ins_cost(150);
 6785 
 6786   size(4);
 6787   format %{ &quot;MOV$cmp  $fcc,$src,$dst\t! long&quot; %}
 6788   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6789   ins_pipe(ialu_reg);
 6790 %}
 6791 
 6792 
 6793 
 6794 //----------OS and Locking Instructions----------------------------------------
 6795 
 6796 // This name is KNOWN by the ADLC and cannot be changed.
 6797 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 6798 // for this guy.
 6799 instruct tlsLoadP(g2RegP dst) %{
 6800   match(Set dst (ThreadLocal));
 6801 
 6802   size(0);
 6803   ins_cost(0);
 6804   format %{ &quot;# TLS is in G2&quot; %}
 6805   ins_encode( /*empty encoding*/ );
 6806   ins_pipe(ialu_none);
 6807 %}
 6808 
 6809 instruct checkCastPP( iRegP dst ) %{
 6810   match(Set dst (CheckCastPP dst));
 6811 
 6812   size(0);
 6813   format %{ &quot;# checkcastPP of $dst&quot; %}
 6814   ins_encode( /*empty encoding*/ );
 6815   ins_pipe(empty);
 6816 %}
 6817 
 6818 
 6819 instruct castPP( iRegP dst ) %{
 6820   match(Set dst (CastPP dst));
 6821   format %{ &quot;# castPP of $dst&quot; %}
 6822   ins_encode( /*empty encoding*/ );
 6823   ins_pipe(empty);
 6824 %}
 6825 
 6826 instruct castII( iRegI dst ) %{
 6827   match(Set dst (CastII dst));
 6828   format %{ &quot;# castII of $dst&quot; %}
 6829   ins_encode( /*empty encoding*/ );
 6830   ins_cost(0);
 6831   ins_pipe(empty);
 6832 %}
 6833 
 6834 instruct castLL( iRegL dst ) %{
 6835   match(Set dst (CastLL dst));
 6836   format %{ &quot;# castLL of $dst&quot; %}
 6837   ins_encode( /*empty encoding*/ );
 6838   ins_cost(0);
 6839   ins_pipe(empty);
 6840 %}
 6841 
 6842 //----------Arithmetic Instructions--------------------------------------------
 6843 // Addition Instructions
 6844 // Register Addition
 6845 instruct addI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6846   match(Set dst (AddI src1 src2));
 6847 
 6848   size(4);
 6849   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6850   ins_encode %{
 6851     __ add($src1$$Register, $src2$$Register, $dst$$Register);
 6852   %}
 6853   ins_pipe(ialu_reg_reg);
 6854 %}
 6855 
 6856 // Immediate Addition
 6857 instruct addI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 6858   match(Set dst (AddI src1 src2));
 6859 
 6860   size(4);
 6861   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6862   opcode(Assembler::add_op3, Assembler::arith_op);
 6863   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6864   ins_pipe(ialu_reg_imm);
 6865 %}
 6866 
 6867 // Pointer Register Addition
 6868 instruct addP_reg_reg(iRegP dst, iRegP src1, iRegX src2) %{
 6869   match(Set dst (AddP src1 src2));
 6870 
 6871   size(4);
 6872   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6873   opcode(Assembler::add_op3, Assembler::arith_op);
 6874   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6875   ins_pipe(ialu_reg_reg);
 6876 %}
 6877 
 6878 // Pointer Immediate Addition
 6879 instruct addP_reg_imm13(iRegP dst, iRegP src1, immX13 src2) %{
 6880   match(Set dst (AddP src1 src2));
 6881 
 6882   size(4);
 6883   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6884   opcode(Assembler::add_op3, Assembler::arith_op);
 6885   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6886   ins_pipe(ialu_reg_imm);
 6887 %}
 6888 
 6889 // Long Addition
 6890 instruct addL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 6891   match(Set dst (AddL src1 src2));
 6892 
 6893   size(4);
 6894   format %{ &quot;ADD    $src1,$src2,$dst\t! long&quot; %}
 6895   opcode(Assembler::add_op3, Assembler::arith_op);
 6896   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6897   ins_pipe(ialu_reg_reg);
 6898 %}
 6899 
 6900 instruct addL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 6901   match(Set dst (AddL src1 con));
 6902 
 6903   size(4);
 6904   format %{ &quot;ADD    $src1,$con,$dst&quot; %}
 6905   opcode(Assembler::add_op3, Assembler::arith_op);
 6906   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 6907   ins_pipe(ialu_reg_imm);
 6908 %}
 6909 
 6910 //----------Conditional_store--------------------------------------------------
 6911 // Conditional-store of the updated heap-top.
 6912 // Used during allocation of the shared heap.
 6913 // Sets flags (EQ) on success.  Implemented with a CASA on Sparc.
 6914 
 6915 // LoadP-locked.  Same as a regular pointer load when used with a compare-swap
 6916 instruct loadPLocked(iRegP dst, memory mem) %{
 6917   match(Set dst (LoadPLocked mem));
 6918   ins_cost(MEMORY_REF_COST);
 6919 
 6920   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 6921   opcode(Assembler::ldx_op3, 0, REGP_OP);
 6922   ins_encode( form3_mem_reg( mem, dst ) );
 6923   ins_pipe(iload_mem);
 6924 %}
 6925 
 6926 instruct storePConditional( iRegP heap_top_ptr, iRegP oldval, g3RegP newval, flagsRegP pcc ) %{
 6927   match(Set pcc (StorePConditional heap_top_ptr (Binary oldval newval)));
 6928   effect( KILL newval );
 6929   format %{ &quot;CASA   [$heap_top_ptr],$oldval,R_G3\t! If $oldval==[$heap_top_ptr] Then store R_G3 into [$heap_top_ptr], set R_G3=[$heap_top_ptr] in any case\n\t&quot;
 6930             &quot;CMP    R_G3,$oldval\t\t! See if we made progress&quot;  %}
 6931   ins_encode( enc_cas(heap_top_ptr,oldval,newval) );
 6932   ins_pipe( long_memory_op );
 6933 %}
 6934 
 6935 // Conditional-store of an int value.
 6936 instruct storeIConditional( iRegP mem_ptr, iRegI oldval, g3RegI newval, flagsReg icc ) %{
 6937   match(Set icc (StoreIConditional mem_ptr (Binary oldval newval)));
 6938   effect( KILL newval );
 6939   format %{ &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6940             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6941   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6942   ins_pipe( long_memory_op );
 6943 %}
 6944 
 6945 // Conditional-store of a long value.
 6946 instruct storeLConditional( iRegP mem_ptr, iRegL oldval, g3RegL newval, flagsRegL xcc ) %{
 6947   match(Set xcc (StoreLConditional mem_ptr (Binary oldval newval)));
 6948   effect( KILL newval );
 6949   format %{ &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6950             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6951   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6952   ins_pipe( long_memory_op );
 6953 %}
 6954 
 6955 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 6956 
 6957 instruct compareAndSwapL_bool(iRegP mem_ptr, iRegL oldval, iRegL newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6958   predicate(VM_Version::supports_cx8());
 6959   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 6960   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 6961   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6962   format %{
 6963             &quot;MOV    $newval,O7\n\t&quot;
 6964             &quot;CASXA  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6965             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6966             &quot;MOV    1,$res\n\t&quot;
 6967             &quot;MOVne  xcc,R_G0,$res&quot;
 6968   %}
 6969   ins_encode( enc_casx(mem_ptr, oldval, newval),
 6970               enc_lflags_ne_to_boolean(res) );
 6971   ins_pipe( long_memory_op );
 6972 %}
 6973 
 6974 
 6975 instruct compareAndSwapI_bool(iRegP mem_ptr, iRegI oldval, iRegI newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6976   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 6977   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 6978   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6979   format %{
 6980             &quot;MOV    $newval,O7\n\t&quot;
 6981             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6982             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6983             &quot;MOV    1,$res\n\t&quot;
 6984             &quot;MOVne  icc,R_G0,$res&quot;
 6985   %}
 6986   ins_encode( enc_casi(mem_ptr, oldval, newval),
 6987               enc_iflags_ne_to_boolean(res) );
 6988   ins_pipe( long_memory_op );
 6989 %}
 6990 
 6991 instruct compareAndSwapP_bool(iRegP mem_ptr, iRegP oldval, iRegP newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6992   predicate(VM_Version::supports_cx8());
 6993   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 6994   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 6995   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6996   format %{
 6997             &quot;MOV    $newval,O7\n\t&quot;
 6998             &quot;CASA_PTR  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6999             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 7000             &quot;MOV    1,$res\n\t&quot;
 7001             &quot;MOVne  xcc,R_G0,$res&quot;
 7002   %}
 7003   ins_encode( enc_casx(mem_ptr, oldval, newval),
 7004               enc_lflags_ne_to_boolean(res) );
 7005   ins_pipe( long_memory_op );
 7006 %}
 7007 
 7008 instruct compareAndSwapN_bool(iRegP mem_ptr, iRegN oldval, iRegN newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 7009   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7010   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7011   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 7012   format %{
 7013             &quot;MOV    $newval,O7\n\t&quot;
 7014             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 7015             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 7016             &quot;MOV    1,$res\n\t&quot;
 7017             &quot;MOVne  icc,R_G0,$res&quot;
 7018   %}
 7019   ins_encode( enc_casi(mem_ptr, oldval, newval),
 7020               enc_iflags_ne_to_boolean(res) );
 7021   ins_pipe( long_memory_op );
 7022 %}
 7023 
 7024 instruct compareAndExchangeI(iRegP mem_ptr, iRegI oldval, iRegI newval)
 7025 %{
 7026   match(Set newval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7027   effect( USE mem_ptr );
 7028 
 7029   format %{
 7030             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7031   %}
 7032   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7033   ins_pipe( long_memory_op );
 7034 %}
 7035 
 7036 instruct compareAndExchangeL(iRegP mem_ptr, iRegL oldval, iRegL newval)
 7037 %{
 7038   match(Set newval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7039   effect( USE mem_ptr );
 7040 
 7041   format %{
 7042             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7043   %}
 7044   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7045   ins_pipe( long_memory_op );
 7046 %}
 7047 
 7048 instruct compareAndExchangeP(iRegP mem_ptr, iRegP oldval, iRegP newval)
 7049 %{
 7050   match(Set newval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7051   effect( USE mem_ptr );
 7052 
 7053   format %{
 7054             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7055   %}
 7056   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7057   ins_pipe( long_memory_op );
 7058 %}
 7059 
 7060 instruct compareAndExchangeN(iRegP mem_ptr, iRegN oldval, iRegN newval)
 7061 %{
 7062   match(Set newval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7063   effect( USE mem_ptr );
 7064 
 7065   format %{
 7066             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7067   %}
 7068   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7069   ins_pipe( long_memory_op );
 7070 %}
 7071 
 7072 instruct xchgI( memory mem, iRegI newval) %{
 7073   match(Set newval (GetAndSetI mem newval));
 7074   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7075   size(4);
 7076   ins_encode %{
 7077     __ swap($mem$$Address, $newval$$Register);
 7078   %}
 7079   ins_pipe( long_memory_op );
 7080 %}
 7081 
 7082 
 7083 instruct xchgN( memory mem, iRegN newval) %{
 7084   match(Set newval (GetAndSetN mem newval));
 7085   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7086   size(4);
 7087   ins_encode %{
 7088     __ swap($mem$$Address, $newval$$Register);
 7089   %}
 7090   ins_pipe( long_memory_op );
 7091 %}
 7092 
 7093 //---------------------
 7094 // Subtraction Instructions
 7095 // Register Subtraction
 7096 instruct subI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7097   match(Set dst (SubI src1 src2));
 7098 
 7099   size(4);
 7100   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7101   opcode(Assembler::sub_op3, Assembler::arith_op);
 7102   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7103   ins_pipe(ialu_reg_reg);
 7104 %}
 7105 
 7106 // Immediate Subtraction
 7107 instruct subI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7108   match(Set dst (SubI src1 src2));
 7109 
 7110   size(4);
 7111   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7112   opcode(Assembler::sub_op3, Assembler::arith_op);
 7113   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7114   ins_pipe(ialu_reg_imm);
 7115 %}
 7116 
 7117 instruct subI_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 7118   match(Set dst (SubI zero src2));
 7119 
 7120   size(4);
 7121   format %{ &quot;NEG    $src2,$dst&quot; %}
 7122   opcode(Assembler::sub_op3, Assembler::arith_op);
 7123   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7124   ins_pipe(ialu_zero_reg);
 7125 %}
 7126 
 7127 // Long subtraction
 7128 instruct subL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7129   match(Set dst (SubL src1 src2));
 7130 
 7131   size(4);
 7132   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7133   opcode(Assembler::sub_op3, Assembler::arith_op);
 7134   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7135   ins_pipe(ialu_reg_reg);
 7136 %}
 7137 
 7138 // Immediate Subtraction
 7139 instruct subL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7140   match(Set dst (SubL src1 con));
 7141 
 7142   size(4);
 7143   format %{ &quot;SUB    $src1,$con,$dst\t! long&quot; %}
 7144   opcode(Assembler::sub_op3, Assembler::arith_op);
 7145   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7146   ins_pipe(ialu_reg_imm);
 7147 %}
 7148 
 7149 // Long negation
 7150 instruct negL_reg_reg(iRegL dst, immL0 zero, iRegL src2) %{
 7151   match(Set dst (SubL zero src2));
 7152 
 7153   size(4);
 7154   format %{ &quot;NEG    $src2,$dst\t! long&quot; %}
 7155   opcode(Assembler::sub_op3, Assembler::arith_op);
 7156   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7157   ins_pipe(ialu_zero_reg);
 7158 %}
 7159 
 7160 // Multiplication Instructions
 7161 // Integer Multiplication
 7162 // Register Multiplication
 7163 instruct mulI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7164   match(Set dst (MulI src1 src2));
 7165 
 7166   size(4);
 7167   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7168   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7169   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7170   ins_pipe(imul_reg_reg);
 7171 %}
 7172 
 7173 // Immediate Multiplication
 7174 instruct mulI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7175   match(Set dst (MulI src1 src2));
 7176 
 7177   size(4);
 7178   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7179   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7180   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7181   ins_pipe(imul_reg_imm);
 7182 %}
 7183 
 7184 instruct mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7185   match(Set dst (MulL src1 src2));
 7186   ins_cost(DEFAULT_COST * 5);
 7187   size(4);
 7188   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7189   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7190   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7191   ins_pipe(mulL_reg_reg);
 7192 %}
 7193 
 7194 // Immediate Multiplication
 7195 instruct mulL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7196   match(Set dst (MulL src1 src2));
 7197   ins_cost(DEFAULT_COST * 5);
 7198   size(4);
 7199   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7200   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7201   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7202   ins_pipe(mulL_reg_imm);
 7203 %}
 7204 
 7205 // Integer Division
 7206 // Register Division
 7207 instruct divI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2) %{
 7208   match(Set dst (DivI src1 src2));
 7209   ins_cost((2+71)*DEFAULT_COST);
 7210 
 7211   format %{ &quot;SRA     $src2,0,$src2\n\t&quot;
 7212             &quot;SRA     $src1,0,$src1\n\t&quot;
 7213             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7214   ins_encode( idiv_reg( src1, src2, dst ) );
 7215   ins_pipe(sdiv_reg_reg);
 7216 %}
 7217 
 7218 // Immediate Division
 7219 instruct divI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2) %{
 7220   match(Set dst (DivI src1 src2));
 7221   ins_cost((2+71)*DEFAULT_COST);
 7222 
 7223   format %{ &quot;SRA     $src1,0,$src1\n\t&quot;
 7224             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7225   ins_encode( idiv_imm( src1, src2, dst ) );
 7226   ins_pipe(sdiv_reg_imm);
 7227 %}
 7228 
 7229 //----------Div-By-10-Expansion------------------------------------------------
 7230 // Extract hi bits of a 32x32-&gt;64 bit multiply.
 7231 // Expand rule only, not matched
 7232 instruct mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2 ) %{
 7233   effect( DEF dst, USE src1, USE src2 );
 7234   format %{ &quot;MULX   $src1,$src2,$dst\t! Used in div-by-10\n\t&quot;
 7235             &quot;SRLX   $dst,#32,$dst\t\t! Extract only hi word of result&quot; %}
 7236   ins_encode( enc_mul_hi(dst,src1,src2));
 7237   ins_pipe(sdiv_reg_reg);
 7238 %}
 7239 
 7240 // Magic constant, reciprocal of 10
 7241 instruct loadConI_x66666667(iRegIsafe dst) %{
 7242   effect( DEF dst );
 7243 
 7244   size(8);
 7245   format %{ &quot;SET    0x66666667,$dst\t! Used in div-by-10&quot; %}
 7246   ins_encode( Set32(0x66666667, dst) );
 7247   ins_pipe(ialu_hi_lo_reg);
 7248 %}
 7249 
 7250 // Register Shift Right Arithmetic Long by 32-63
 7251 instruct sra_31( iRegI dst, iRegI src ) %{
 7252   effect( DEF dst, USE src );
 7253   format %{ &quot;SRA    $src,31,$dst\t! Used in div-by-10&quot; %}
 7254   ins_encode( form3_rs1_rd_copysign_hi(src,dst) );
 7255   ins_pipe(ialu_reg_reg);
 7256 %}
 7257 
 7258 // Arithmetic Shift Right by 8-bit immediate
 7259 instruct sra_reg_2( iRegI dst, iRegI src ) %{
 7260   effect( DEF dst, USE src );
 7261   format %{ &quot;SRA    $src,2,$dst\t! Used in div-by-10&quot; %}
 7262   opcode(Assembler::sra_op3, Assembler::arith_op);
 7263   ins_encode( form3_rs1_simm13_rd( src, 0x2, dst ) );
 7264   ins_pipe(ialu_reg_imm);
 7265 %}
 7266 
 7267 // Integer DIV with 10
 7268 instruct divI_10( iRegI dst, iRegIsafe src, immI10 div ) %{
 7269   match(Set dst (DivI src div));
 7270   ins_cost((6+6)*DEFAULT_COST);
 7271   expand %{
 7272     iRegIsafe tmp1;               // Killed temps;
 7273     iRegIsafe tmp2;               // Killed temps;
 7274     iRegI tmp3;                   // Killed temps;
 7275     iRegI tmp4;                   // Killed temps;
 7276     loadConI_x66666667( tmp1 );   // SET  0x66666667 -&gt; tmp1
 7277     mul_hi( tmp2, src, tmp1 );    // MUL  hibits(src * tmp1) -&gt; tmp2
 7278     sra_31( tmp3, src );          // SRA  src,31 -&gt; tmp3
 7279     sra_reg_2( tmp4, tmp2 );      // SRA  tmp2,2 -&gt; tmp4
 7280     subI_reg_reg( dst,tmp4,tmp3); // SUB  tmp4 - tmp3 -&gt; dst
 7281   %}
 7282 %}
 7283 
 7284 // Register Long Division
 7285 instruct divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7286   match(Set dst (DivL src1 src2));
 7287   ins_cost(DEFAULT_COST*71);
 7288   size(4);
 7289   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7290   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7291   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7292   ins_pipe(divL_reg_reg);
 7293 %}
 7294 
 7295 // Register Long Division
 7296 instruct divL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7297   match(Set dst (DivL src1 src2));
 7298   ins_cost(DEFAULT_COST*71);
 7299   size(4);
 7300   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7301   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7302   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7303   ins_pipe(divL_reg_imm);
 7304 %}
 7305 
 7306 // Integer Remainder
 7307 // Register Remainder
 7308 instruct modI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2, o7RegP temp, flagsReg ccr ) %{
 7309   match(Set dst (ModI src1 src2));
 7310   effect( KILL ccr, KILL temp);
 7311 
 7312   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7313   ins_encode( irem_reg(src1, src2, dst, temp) );
 7314   ins_pipe(sdiv_reg_reg);
 7315 %}
 7316 
 7317 // Immediate Remainder
 7318 instruct modI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2, o7RegP temp, flagsReg ccr ) %{
 7319   match(Set dst (ModI src1 src2));
 7320   effect( KILL ccr, KILL temp);
 7321 
 7322   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7323   ins_encode( irem_imm(src1, src2, dst, temp) );
 7324   ins_pipe(sdiv_reg_imm);
 7325 %}
 7326 
 7327 // Register Long Remainder
 7328 instruct divL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7329   effect(DEF dst, USE src1, USE src2);
 7330   size(4);
 7331   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7332   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7333   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7334   ins_pipe(divL_reg_reg);
 7335 %}
 7336 
 7337 // Register Long Division
 7338 instruct divL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7339   effect(DEF dst, USE src1, USE src2);
 7340   size(4);
 7341   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7342   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7343   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7344   ins_pipe(divL_reg_imm);
 7345 %}
 7346 
 7347 instruct mulL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7348   effect(DEF dst, USE src1, USE src2);
 7349   size(4);
 7350   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7351   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7352   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7353   ins_pipe(mulL_reg_reg);
 7354 %}
 7355 
 7356 // Immediate Multiplication
 7357 instruct mulL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7358   effect(DEF dst, USE src1, USE src2);
 7359   size(4);
 7360   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7361   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7362   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7363   ins_pipe(mulL_reg_imm);
 7364 %}
 7365 
 7366 instruct subL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7367   effect(DEF dst, USE src1, USE src2);
 7368   size(4);
 7369   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7370   opcode(Assembler::sub_op3, Assembler::arith_op);
 7371   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7372   ins_pipe(ialu_reg_reg);
 7373 %}
 7374 
 7375 instruct subL_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 7376   effect(DEF dst, USE src1, USE src2);
 7377   size(4);
 7378   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7379   opcode(Assembler::sub_op3, Assembler::arith_op);
 7380   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7381   ins_pipe(ialu_reg_reg);
 7382 %}
 7383 
 7384 // Register Long Remainder
 7385 instruct modL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7386   match(Set dst (ModL src1 src2));
 7387   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7388   expand %{
 7389     iRegL tmp1;
 7390     iRegL tmp2;
 7391     divL_reg_reg_1(tmp1, src1, src2);
 7392     mulL_reg_reg_1(tmp2, tmp1, src2);
 7393     subL_reg_reg_1(dst,  src1, tmp2);
 7394   %}
 7395 %}
 7396 
 7397 // Register Long Remainder
 7398 instruct modL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7399   match(Set dst (ModL src1 src2));
 7400   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7401   expand %{
 7402     iRegL tmp1;
 7403     iRegL tmp2;
 7404     divL_reg_imm13_1(tmp1, src1, src2);
 7405     mulL_reg_imm13_1(tmp2, tmp1, src2);
 7406     subL_reg_reg_2  (dst,  src1, tmp2);
 7407   %}
 7408 %}
 7409 
 7410 // Integer Shift Instructions
 7411 // Register Shift Left
 7412 instruct shlI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7413   match(Set dst (LShiftI src1 src2));
 7414 
 7415   size(4);
 7416   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7417   opcode(Assembler::sll_op3, Assembler::arith_op);
 7418   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7419   ins_pipe(ialu_reg_reg);
 7420 %}
 7421 
 7422 // Register Shift Left Immediate
 7423 instruct shlI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7424   match(Set dst (LShiftI src1 src2));
 7425 
 7426   size(4);
 7427   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7428   opcode(Assembler::sll_op3, Assembler::arith_op);
 7429   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7430   ins_pipe(ialu_reg_imm);
 7431 %}
 7432 
 7433 // Register Shift Left
 7434 instruct shlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7435   match(Set dst (LShiftL src1 src2));
 7436 
 7437   size(4);
 7438   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7439   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7440   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7441   ins_pipe(ialu_reg_reg);
 7442 %}
 7443 
 7444 // Register Shift Left Immediate
 7445 instruct shlL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7446   match(Set dst (LShiftL src1 src2));
 7447 
 7448   size(4);
 7449   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7450   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7451   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7452   ins_pipe(ialu_reg_imm);
 7453 %}
 7454 
 7455 // Register Arithmetic Shift Right
 7456 instruct sarI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7457   match(Set dst (RShiftI src1 src2));
 7458   size(4);
 7459   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7460   opcode(Assembler::sra_op3, Assembler::arith_op);
 7461   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7462   ins_pipe(ialu_reg_reg);
 7463 %}
 7464 
 7465 // Register Arithmetic Shift Right Immediate
 7466 instruct sarI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7467   match(Set dst (RShiftI src1 src2));
 7468 
 7469   size(4);
 7470   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7471   opcode(Assembler::sra_op3, Assembler::arith_op);
 7472   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7473   ins_pipe(ialu_reg_imm);
 7474 %}
 7475 
 7476 // Register Shift Right Arithmatic Long
 7477 instruct sarL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7478   match(Set dst (RShiftL src1 src2));
 7479 
 7480   size(4);
 7481   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7482   opcode(Assembler::srax_op3, Assembler::arith_op);
 7483   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7484   ins_pipe(ialu_reg_reg);
 7485 %}
 7486 
 7487 // Register Shift Left Immediate
 7488 instruct sarL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7489   match(Set dst (RShiftL src1 src2));
 7490 
 7491   size(4);
 7492   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7493   opcode(Assembler::srax_op3, Assembler::arith_op);
 7494   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7495   ins_pipe(ialu_reg_imm);
 7496 %}
 7497 
 7498 // Register Shift Right
 7499 instruct shrI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7500   match(Set dst (URShiftI src1 src2));
 7501 
 7502   size(4);
 7503   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7504   opcode(Assembler::srl_op3, Assembler::arith_op);
 7505   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7506   ins_pipe(ialu_reg_reg);
 7507 %}
 7508 
 7509 // Register Shift Right Immediate
 7510 instruct shrI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7511   match(Set dst (URShiftI src1 src2));
 7512 
 7513   size(4);
 7514   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7515   opcode(Assembler::srl_op3, Assembler::arith_op);
 7516   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7517   ins_pipe(ialu_reg_imm);
 7518 %}
 7519 
 7520 // Register Shift Right
 7521 instruct shrL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7522   match(Set dst (URShiftL src1 src2));
 7523 
 7524   size(4);
 7525   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7526   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7527   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7528   ins_pipe(ialu_reg_reg);
 7529 %}
 7530 
 7531 // Register Shift Right Immediate
 7532 instruct shrL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7533   match(Set dst (URShiftL src1 src2));
 7534 
 7535   size(4);
 7536   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7537   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7538   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7539   ins_pipe(ialu_reg_imm);
 7540 %}
 7541 
 7542 // Register Shift Right Immediate with a CastP2X
 7543 instruct shrP_reg_imm6(iRegL dst, iRegP src1, immU6 src2) %{
 7544   match(Set dst (URShiftL (CastP2X src1) src2));
 7545   size(4);
 7546   format %{ &quot;SRLX   $src1,$src2,$dst\t! Cast ptr $src1 to long and shift&quot; %}
 7547   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7548   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7549   ins_pipe(ialu_reg_imm);
 7550 %}
 7551 
 7552 
 7553 //----------Floating Point Arithmetic Instructions-----------------------------
 7554 
 7555 //  Add float single precision
 7556 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 7557   match(Set dst (AddF src1 src2));
 7558 
 7559   size(4);
 7560   format %{ &quot;FADDS  $src1,$src2,$dst&quot; %}
 7561   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fadds_opf);
 7562   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7563   ins_pipe(faddF_reg_reg);
 7564 %}
 7565 
 7566 //  Add float double precision
 7567 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 7568   match(Set dst (AddD src1 src2));
 7569 
 7570   size(4);
 7571   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 7572   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 7573   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7574   ins_pipe(faddD_reg_reg);
 7575 %}
 7576 
 7577 //  Sub float single precision
 7578 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 7579   match(Set dst (SubF src1 src2));
 7580 
 7581   size(4);
 7582   format %{ &quot;FSUBS  $src1,$src2,$dst&quot; %}
 7583   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubs_opf);
 7584   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7585   ins_pipe(faddF_reg_reg);
 7586 %}
 7587 
 7588 //  Sub float double precision
 7589 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 7590   match(Set dst (SubD src1 src2));
 7591 
 7592   size(4);
 7593   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 7594   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 7595   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7596   ins_pipe(faddD_reg_reg);
 7597 %}
 7598 
 7599 //  Mul float single precision
 7600 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 7601   match(Set dst (MulF src1 src2));
 7602 
 7603   size(4);
 7604   format %{ &quot;FMULS  $src1,$src2,$dst&quot; %}
 7605   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuls_opf);
 7606   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7607   ins_pipe(fmulF_reg_reg);
 7608 %}
 7609 
 7610 //  Mul float double precision
 7611 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 7612   match(Set dst (MulD src1 src2));
 7613 
 7614   size(4);
 7615   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 7616   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 7617   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7618   ins_pipe(fmulD_reg_reg);
 7619 %}
 7620 
 7621 //  Div float single precision
 7622 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 7623   match(Set dst (DivF src1 src2));
 7624 
 7625   size(4);
 7626   format %{ &quot;FDIVS  $src1,$src2,$dst&quot; %}
 7627   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivs_opf);
 7628   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7629   ins_pipe(fdivF_reg_reg);
 7630 %}
 7631 
 7632 //  Div float double precision
 7633 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 7634   match(Set dst (DivD src1 src2));
 7635 
 7636   size(4);
 7637   format %{ &quot;FDIVD  $src1,$src2,$dst&quot; %}
 7638   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivd_opf);
 7639   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7640   ins_pipe(fdivD_reg_reg);
 7641 %}
 7642 
 7643 //  Absolute float double precision
 7644 instruct absD_reg(regD dst, regD src) %{
 7645   match(Set dst (AbsD src));
 7646 
 7647   format %{ &quot;FABSd  $src,$dst&quot; %}
 7648   ins_encode(fabsd(dst, src));
 7649   ins_pipe(faddD_reg);
 7650 %}
 7651 
 7652 //  Absolute float single precision
 7653 instruct absF_reg(regF dst, regF src) %{
 7654   match(Set dst (AbsF src));
 7655 
 7656   format %{ &quot;FABSs  $src,$dst&quot; %}
 7657   ins_encode(fabss(dst, src));
 7658   ins_pipe(faddF_reg);
 7659 %}
 7660 
 7661 instruct negF_reg(regF dst, regF src) %{
 7662   match(Set dst (NegF src));
 7663 
 7664   size(4);
 7665   format %{ &quot;FNEGs  $src,$dst&quot; %}
 7666   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fnegs_opf);
 7667   ins_encode(form3_opf_rs2F_rdF(src, dst));
 7668   ins_pipe(faddF_reg);
 7669 %}
 7670 
 7671 instruct negD_reg(regD dst, regD src) %{
 7672   match(Set dst (NegD src));
 7673 
 7674   format %{ &quot;FNEGd  $src,$dst&quot; %}
 7675   ins_encode(fnegd(dst, src));
 7676   ins_pipe(faddD_reg);
 7677 %}
 7678 
 7679 //  Sqrt float double precision
 7680 instruct sqrtF_reg_reg(regF dst, regF src) %{
 7681   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7682 
 7683   size(4);
 7684   format %{ &quot;FSQRTS $src,$dst&quot; %}
 7685   ins_encode(fsqrts(dst, src));
 7686   ins_pipe(fdivF_reg_reg);
 7687 %}
 7688 
 7689 //  Sqrt float double precision
 7690 instruct sqrtD_reg_reg(regD dst, regD src) %{
 7691   match(Set dst (SqrtD src));
 7692 
 7693   size(4);
 7694   format %{ &quot;FSQRTD $src,$dst&quot; %}
 7695   ins_encode(fsqrtd(dst, src));
 7696   ins_pipe(fdivD_reg_reg);
 7697 %}
 7698 
 7699 // Single/Double precision fused floating-point multiply-add (d = a * b + c).
 7700 instruct fmaF_regx4(regF dst, regF a, regF b, regF c) %{
 7701   predicate(UseFMA);
 7702   match(Set dst (FmaF c (Binary a b)));
 7703   format %{ &quot;fmadds $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7704   ins_encode(fmadds(dst, a, b, c));
 7705   ins_pipe(fmaF_regx4);
 7706 %}
 7707 
 7708 instruct fmaD_regx4(regD dst, regD a, regD b, regD c) %{
 7709   predicate(UseFMA);
 7710   match(Set dst (FmaD c (Binary a b)));
 7711   format %{ &quot;fmaddd $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7712   ins_encode(fmaddd(dst, a, b, c));
 7713   ins_pipe(fmaD_regx4);
 7714 %}
 7715 
 7716 // Additional patterns matching complement versions that we can map directly to
 7717 // variants of the fused multiply-add instructions.
 7718 
 7719 // Single/Double precision fused floating-point multiply-sub (d = a * b - c)
 7720 instruct fmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7721   predicate(UseFMA);
 7722   match(Set dst (FmaF (NegF c) (Binary a b)));
 7723   format %{ &quot;fmsubs $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7724   ins_encode(fmsubs(dst, a, b, c));
 7725   ins_pipe(fmaF_regx4);
 7726 %}
 7727 
 7728 instruct fmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7729   predicate(UseFMA);
 7730   match(Set dst (FmaD (NegD c) (Binary a b)));
 7731   format %{ &quot;fmsubd $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7732   ins_encode(fmsubd(dst, a, b, c));
 7733   ins_pipe(fmaD_regx4);
 7734 %}
 7735 
 7736 // Single/Double precision fused floating-point neg. multiply-add,
 7737 //      d = -1 * a * b - c = -(a * b + c)
 7738 instruct fnmaddF_regx4(regF dst, regF a, regF b, regF c) %{
 7739   predicate(UseFMA);
 7740   match(Set dst (FmaF (NegF c) (Binary (NegF a) b)));
 7741   match(Set dst (FmaF (NegF c) (Binary a (NegF b))));
 7742   format %{ &quot;fnmadds $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7743   ins_encode(fnmadds(dst, a, b, c));
 7744   ins_pipe(fmaF_regx4);
 7745 %}
 7746 
 7747 instruct fnmaddD_regx4(regD dst, regD a, regD b, regD c) %{
 7748   predicate(UseFMA);
 7749   match(Set dst (FmaD (NegD c) (Binary (NegD a) b)));
 7750   match(Set dst (FmaD (NegD c) (Binary a (NegD b))));
 7751   format %{ &quot;fnmaddd $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7752   ins_encode(fnmaddd(dst, a, b, c));
 7753   ins_pipe(fmaD_regx4);
 7754 %}
 7755 
 7756 // Single/Double precision fused floating-point neg. multiply-sub,
 7757 //      d = -1 * a * b + c = -(a * b - c)
 7758 instruct fnmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7759   predicate(UseFMA);
 7760   match(Set dst (FmaF c (Binary (NegF a) b)));
 7761   match(Set dst (FmaF c (Binary a (NegF b))));
 7762   format %{ &quot;fnmsubs $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7763   ins_encode(fnmsubs(dst, a, b, c));
 7764   ins_pipe(fmaF_regx4);
 7765 %}
 7766 
 7767 instruct fnmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7768   predicate(UseFMA);
 7769   match(Set dst (FmaD c (Binary (NegD a) b)));
 7770   match(Set dst (FmaD c (Binary a (NegD b))));
 7771   format %{ &quot;fnmsubd $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7772   ins_encode(fnmsubd(dst, a, b, c));
 7773   ins_pipe(fmaD_regx4);
 7774 %}
 7775 
 7776 //----------Logical Instructions-----------------------------------------------
 7777 // And Instructions
 7778 // Register And
 7779 instruct andI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7780   match(Set dst (AndI src1 src2));
 7781 
 7782   size(4);
 7783   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7784   opcode(Assembler::and_op3, Assembler::arith_op);
 7785   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7786   ins_pipe(ialu_reg_reg);
 7787 %}
 7788 
 7789 // Immediate And
 7790 instruct andI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7791   match(Set dst (AndI src1 src2));
 7792 
 7793   size(4);
 7794   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7795   opcode(Assembler::and_op3, Assembler::arith_op);
 7796   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7797   ins_pipe(ialu_reg_imm);
 7798 %}
 7799 
 7800 // Register And Long
 7801 instruct andL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7802   match(Set dst (AndL src1 src2));
 7803 
 7804   ins_cost(DEFAULT_COST);
 7805   size(4);
 7806   format %{ &quot;AND    $src1,$src2,$dst\t! long&quot; %}
 7807   opcode(Assembler::and_op3, Assembler::arith_op);
 7808   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7809   ins_pipe(ialu_reg_reg);
 7810 %}
 7811 
 7812 instruct andL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7813   match(Set dst (AndL src1 con));
 7814 
 7815   ins_cost(DEFAULT_COST);
 7816   size(4);
 7817   format %{ &quot;AND    $src1,$con,$dst\t! long&quot; %}
 7818   opcode(Assembler::and_op3, Assembler::arith_op);
 7819   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7820   ins_pipe(ialu_reg_imm);
 7821 %}
 7822 
 7823 // Or Instructions
 7824 // Register Or
 7825 instruct orI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7826   match(Set dst (OrI src1 src2));
 7827 
 7828   size(4);
 7829   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7830   opcode(Assembler::or_op3, Assembler::arith_op);
 7831   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7832   ins_pipe(ialu_reg_reg);
 7833 %}
 7834 
 7835 // Immediate Or
 7836 instruct orI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7837   match(Set dst (OrI src1 src2));
 7838 
 7839   size(4);
 7840   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7841   opcode(Assembler::or_op3, Assembler::arith_op);
 7842   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7843   ins_pipe(ialu_reg_imm);
 7844 %}
 7845 
 7846 // Register Or Long
 7847 instruct orL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7848   match(Set dst (OrL src1 src2));
 7849 
 7850   ins_cost(DEFAULT_COST);
 7851   size(4);
 7852   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7853   opcode(Assembler::or_op3, Assembler::arith_op);
 7854   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7855   ins_pipe(ialu_reg_reg);
 7856 %}
 7857 
 7858 instruct orL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7859   match(Set dst (OrL src1 con));
 7860   ins_cost(DEFAULT_COST*2);
 7861 
 7862   ins_cost(DEFAULT_COST);
 7863   size(4);
 7864   format %{ &quot;OR     $src1,$con,$dst\t! long&quot; %}
 7865   opcode(Assembler::or_op3, Assembler::arith_op);
 7866   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7867   ins_pipe(ialu_reg_imm);
 7868 %}
 7869 
 7870 instruct orL_reg_castP2X(iRegL dst, iRegL src1, sp_ptr_RegP src2) %{
 7871   match(Set dst (OrL src1 (CastP2X src2)));
 7872 
 7873   ins_cost(DEFAULT_COST);
 7874   size(4);
 7875   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7876   opcode(Assembler::or_op3, Assembler::arith_op);
 7877   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7878   ins_pipe(ialu_reg_reg);
 7879 %}
 7880 
 7881 // Xor Instructions
 7882 // Register Xor
 7883 instruct xorI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7884   match(Set dst (XorI src1 src2));
 7885 
 7886   size(4);
 7887   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7888   opcode(Assembler::xor_op3, Assembler::arith_op);
 7889   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7890   ins_pipe(ialu_reg_reg);
 7891 %}
 7892 
 7893 // Immediate Xor
 7894 instruct xorI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7895   match(Set dst (XorI src1 src2));
 7896 
 7897   size(4);
 7898   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7899   opcode(Assembler::xor_op3, Assembler::arith_op);
 7900   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7901   ins_pipe(ialu_reg_imm);
 7902 %}
 7903 
 7904 // Register Xor Long
 7905 instruct xorL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7906   match(Set dst (XorL src1 src2));
 7907 
 7908   ins_cost(DEFAULT_COST);
 7909   size(4);
 7910   format %{ &quot;XOR    $src1,$src2,$dst\t! long&quot; %}
 7911   opcode(Assembler::xor_op3, Assembler::arith_op);
 7912   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7913   ins_pipe(ialu_reg_reg);
 7914 %}
 7915 
 7916 instruct xorL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7917   match(Set dst (XorL src1 con));
 7918 
 7919   ins_cost(DEFAULT_COST);
 7920   size(4);
 7921   format %{ &quot;XOR    $src1,$con,$dst\t! long&quot; %}
 7922   opcode(Assembler::xor_op3, Assembler::arith_op);
 7923   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7924   ins_pipe(ialu_reg_imm);
 7925 %}
 7926 
 7927 //----------Convert to Boolean-------------------------------------------------
 7928 // Nice hack for 32-bit tests but doesn&#39;t work for
 7929 // 64-bit pointers.
 7930 instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{
 7931   match(Set dst (Conv2B src));
 7932   effect( KILL ccr );
 7933   ins_cost(DEFAULT_COST*2);
 7934   format %{ &quot;CMP    R_G0,$src\n\t&quot;
 7935             &quot;ADDX   R_G0,0,$dst&quot; %}
 7936   ins_encode( enc_to_bool( src, dst ) );
 7937   ins_pipe(ialu_reg_ialu);
 7938 %}
 7939 
 7940 instruct convP2B( iRegI dst, iRegP src ) %{
 7941   match(Set dst (Conv2B src));
 7942   ins_cost(DEFAULT_COST*2);
 7943   format %{ &quot;MOV    $src,$dst\n\t&quot;
 7944             &quot;MOVRNZ $src,1,$dst&quot; %}
 7945   ins_encode( form3_g0_rs2_rd_move( src, dst ), enc_convP2B( dst, src ) );
 7946   ins_pipe(ialu_clr_and_mover);
 7947 %}
 7948 
 7949 instruct cmpLTMask0( iRegI dst, iRegI src, immI0 zero, flagsReg ccr ) %{
 7950   match(Set dst (CmpLTMask src zero));
 7951   effect(KILL ccr);
 7952   size(4);
 7953   format %{ &quot;SRA    $src,#31,$dst\t# cmpLTMask0&quot; %}
 7954   ins_encode %{
 7955     __ sra($src$$Register, 31, $dst$$Register);
 7956   %}
 7957   ins_pipe(ialu_reg_imm);
 7958 %}
 7959 
 7960 instruct cmpLTMask_reg_reg( iRegI dst, iRegI p, iRegI q, flagsReg ccr ) %{
 7961   match(Set dst (CmpLTMask p q));
 7962   effect( KILL ccr );
 7963   ins_cost(DEFAULT_COST*4);
 7964   format %{ &quot;CMP    $p,$q\n\t&quot;
 7965             &quot;MOV    #0,$dst\n\t&quot;
 7966             &quot;BLT,a  .+8\n\t&quot;
 7967             &quot;MOV    #-1,$dst&quot; %}
 7968   ins_encode( enc_ltmask(p,q,dst) );
 7969   ins_pipe(ialu_reg_reg_ialu);
 7970 %}
 7971 
 7972 instruct cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp, flagsReg ccr ) %{
 7973   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 7974   effect(KILL ccr, TEMP tmp);
 7975   ins_cost(DEFAULT_COST*3);
 7976 
 7977   format %{ &quot;SUBcc  $p,$q,$p\t! p&#39; = p-q\n\t&quot;
 7978             &quot;ADD    $p,$y,$tmp\t! g3=p-q+y\n\t&quot;
 7979             &quot;MOVlt  $tmp,$p\t! p&#39; &lt; 0 ? p&#39;+y : p&#39;&quot; %}
 7980   ins_encode(enc_cadd_cmpLTMask(p, q, y, tmp));
 7981   ins_pipe(cadd_cmpltmask);
 7982 %}
 7983 
 7984 instruct and_cmpLTMask(iRegI p, iRegI q, iRegI y, flagsReg ccr) %{
 7985   match(Set p (AndI (CmpLTMask p q) y));
 7986   effect(KILL ccr);
 7987   ins_cost(DEFAULT_COST*3);
 7988 
 7989   format %{ &quot;CMP  $p,$q\n\t&quot;
 7990             &quot;MOV  $y,$p\n\t&quot;
 7991             &quot;MOVge G0,$p&quot; %}
 7992   ins_encode %{
 7993     __ cmp($p$$Register, $q$$Register);
 7994     __ mov($y$$Register, $p$$Register);
 7995     __ movcc(Assembler::greaterEqual, false, Assembler::icc, G0, $p$$Register);
 7996   %}
 7997   ins_pipe(ialu_reg_reg_ialu);
 7998 %}
 7999 
 8000 //-----------------------------------------------------------------
 8001 // Direct raw moves between float and general registers using VIS3.
 8002 
 8003 //  ins_pipe(faddF_reg);
 8004 instruct MoveF2I_reg_reg(iRegI dst, regF src) %{
 8005   predicate(UseVIS &gt;= 3);
 8006   match(Set dst (MoveF2I src));
 8007 
 8008   format %{ &quot;MOVSTOUW $src,$dst\t! MoveF2I&quot; %}
 8009   ins_encode %{
 8010     __ movstouw($src$$FloatRegister, $dst$$Register);
 8011   %}
 8012   ins_pipe(ialu_reg_reg);
 8013 %}
 8014 
 8015 instruct MoveI2F_reg_reg(regF dst, iRegI src) %{
 8016   predicate(UseVIS &gt;= 3);
 8017   match(Set dst (MoveI2F src));
 8018 
 8019   format %{ &quot;MOVWTOS $src,$dst\t! MoveI2F&quot; %}
 8020   ins_encode %{
 8021     __ movwtos($src$$Register, $dst$$FloatRegister);
 8022   %}
 8023   ins_pipe(ialu_reg_reg);
 8024 %}
 8025 
 8026 instruct MoveD2L_reg_reg(iRegL dst, regD src) %{
 8027   predicate(UseVIS &gt;= 3);
 8028   match(Set dst (MoveD2L src));
 8029 
 8030   format %{ &quot;MOVDTOX $src,$dst\t! MoveD2L&quot; %}
 8031   ins_encode %{
 8032     __ movdtox(as_DoubleFloatRegister($src$$reg), $dst$$Register);
 8033   %}
 8034   ins_pipe(ialu_reg_reg);
 8035 %}
 8036 
 8037 instruct MoveL2D_reg_reg(regD dst, iRegL src) %{
 8038   predicate(UseVIS &gt;= 3);
 8039   match(Set dst (MoveL2D src));
 8040 
 8041   format %{ &quot;MOVXTOD $src,$dst\t! MoveL2D&quot; %}
 8042   ins_encode %{
 8043     __ movxtod($src$$Register, as_DoubleFloatRegister($dst$$reg));
 8044   %}
 8045   ins_pipe(ialu_reg_reg);
 8046 %}
 8047 
 8048 
 8049 // Raw moves between float and general registers using stack.
 8050 
 8051 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8052   match(Set dst (MoveF2I src));
 8053   effect(DEF dst, USE src);
 8054   ins_cost(MEMORY_REF_COST);
 8055 
 8056   format %{ &quot;LDUW   $src,$dst\t! MoveF2I&quot; %}
 8057   opcode(Assembler::lduw_op3);
 8058   ins_encode(simple_form3_mem_reg( src, dst ) );
 8059   ins_pipe(iload_mem);
 8060 %}
 8061 
 8062 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8063   match(Set dst (MoveI2F src));
 8064   effect(DEF dst, USE src);
 8065   ins_cost(MEMORY_REF_COST);
 8066 
 8067   format %{ &quot;LDF    $src,$dst\t! MoveI2F&quot; %}
 8068   opcode(Assembler::ldf_op3);
 8069   ins_encode(simple_form3_mem_reg(src, dst));
 8070   ins_pipe(floadF_stk);
 8071 %}
 8072 
 8073 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8074   match(Set dst (MoveD2L src));
 8075   effect(DEF dst, USE src);
 8076   ins_cost(MEMORY_REF_COST);
 8077 
 8078   format %{ &quot;LDX    $src,$dst\t! MoveD2L&quot; %}
 8079   opcode(Assembler::ldx_op3);
 8080   ins_encode(simple_form3_mem_reg( src, dst ) );
 8081   ins_pipe(iload_mem);
 8082 %}
 8083 
 8084 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8085   match(Set dst (MoveL2D src));
 8086   effect(DEF dst, USE src);
 8087   ins_cost(MEMORY_REF_COST);
 8088 
 8089   format %{ &quot;LDDF   $src,$dst\t! MoveL2D&quot; %}
 8090   opcode(Assembler::lddf_op3);
 8091   ins_encode(simple_form3_mem_reg(src, dst));
 8092   ins_pipe(floadD_stk);
 8093 %}
 8094 
 8095 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
 8096   match(Set dst (MoveF2I src));
 8097   effect(DEF dst, USE src);
 8098   ins_cost(MEMORY_REF_COST);
 8099 
 8100   format %{ &quot;STF   $src,$dst\t! MoveF2I&quot; %}
 8101   opcode(Assembler::stf_op3);
 8102   ins_encode(simple_form3_mem_reg(dst, src));
 8103   ins_pipe(fstoreF_stk_reg);
 8104 %}
 8105 
 8106 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8107   match(Set dst (MoveI2F src));
 8108   effect(DEF dst, USE src);
 8109   ins_cost(MEMORY_REF_COST);
 8110 
 8111   format %{ &quot;STW    $src,$dst\t! MoveI2F&quot; %}
 8112   opcode(Assembler::stw_op3);
 8113   ins_encode(simple_form3_mem_reg( dst, src ) );
 8114   ins_pipe(istore_mem_reg);
 8115 %}
 8116 
 8117 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8118   match(Set dst (MoveD2L src));
 8119   effect(DEF dst, USE src);
 8120   ins_cost(MEMORY_REF_COST);
 8121 
 8122   format %{ &quot;STDF   $src,$dst\t! MoveD2L&quot; %}
 8123   opcode(Assembler::stdf_op3);
 8124   ins_encode(simple_form3_mem_reg(dst, src));
 8125   ins_pipe(fstoreD_stk_reg);
 8126 %}
 8127 
 8128 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8129   match(Set dst (MoveL2D src));
 8130   effect(DEF dst, USE src);
 8131   ins_cost(MEMORY_REF_COST);
 8132 
 8133   format %{ &quot;STX    $src,$dst\t! MoveL2D&quot; %}
 8134   opcode(Assembler::stx_op3);
 8135   ins_encode(simple_form3_mem_reg( dst, src ) );
 8136   ins_pipe(istore_mem_reg);
 8137 %}
 8138 
 8139 
 8140 //----------Arithmetic Conversion Instructions---------------------------------
 8141 // The conversions operations are all Alpha sorted.  Please keep it that way!
 8142 
 8143 instruct convD2F_reg(regF dst, regD src) %{
 8144   match(Set dst (ConvD2F src));
 8145   size(4);
 8146   format %{ &quot;FDTOS  $src,$dst&quot; %}
 8147   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdtos_opf);
 8148   ins_encode(form3_opf_rs2D_rdF(src, dst));
 8149   ins_pipe(fcvtD2F);
 8150 %}
 8151 
 8152 
 8153 // Convert a double to an int in a float register.
 8154 // If the double is a NAN, stuff a zero in instead.
 8155 instruct convD2I_helper(regF dst, regD src, flagsRegF0 fcc0) %{
 8156   effect(DEF dst, USE src, KILL fcc0);
 8157   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8158             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8159             &quot;FDTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8160             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8161             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8162       &quot;skip:&quot; %}
 8163   ins_encode(form_d2i_helper(src,dst));
 8164   ins_pipe(fcvtD2I);
 8165 %}
 8166 
 8167 instruct convD2I_stk(stackSlotI dst, regD src) %{
 8168   match(Set dst (ConvD2I src));
 8169   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8170   expand %{
 8171     regF tmp;
 8172     convD2I_helper(tmp, src);
 8173     regF_to_stkI(dst, tmp);
 8174   %}
 8175 %}
 8176 
 8177 instruct convD2I_reg(iRegI dst, regD src) %{
 8178   predicate(UseVIS &gt;= 3);
 8179   match(Set dst (ConvD2I src));
 8180   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8181   expand %{
 8182     regF tmp;
 8183     convD2I_helper(tmp, src);
 8184     MoveF2I_reg_reg(dst, tmp);
 8185   %}
 8186 %}
 8187 
 8188 
 8189 // Convert a double to a long in a double register.
 8190 // If the double is a NAN, stuff a zero in instead.
 8191 instruct convD2L_helper(regD dst, regD src, flagsRegF0 fcc0) %{
 8192   effect(DEF dst, USE src, KILL fcc0);
 8193   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8194             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8195             &quot;FDTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8196             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8197             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8198       &quot;skip:&quot; %}
 8199   ins_encode(form_d2l_helper(src,dst));
 8200   ins_pipe(fcvtD2L);
 8201 %}
 8202 
 8203 instruct convD2L_stk(stackSlotL dst, regD src) %{
 8204   match(Set dst (ConvD2L src));
 8205   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8206   expand %{
 8207     regD tmp;
 8208     convD2L_helper(tmp, src);
 8209     regD_to_stkL(dst, tmp);
 8210   %}
 8211 %}
 8212 
 8213 instruct convD2L_reg(iRegL dst, regD src) %{
 8214   predicate(UseVIS &gt;= 3);
 8215   match(Set dst (ConvD2L src));
 8216   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8217   expand %{
 8218     regD tmp;
 8219     convD2L_helper(tmp, src);
 8220     MoveD2L_reg_reg(dst, tmp);
 8221   %}
 8222 %}
 8223 
 8224 
 8225 instruct convF2D_reg(regD dst, regF src) %{
 8226   match(Set dst (ConvF2D src));
 8227   format %{ &quot;FSTOD  $src,$dst&quot; %}
 8228   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fstod_opf);
 8229   ins_encode(form3_opf_rs2F_rdD(src, dst));
 8230   ins_pipe(fcvtF2D);
 8231 %}
 8232 
 8233 
 8234 // Convert a float to an int in a float register.
 8235 // If the float is a NAN, stuff a zero in instead.
 8236 instruct convF2I_helper(regF dst, regF src, flagsRegF0 fcc0) %{
 8237   effect(DEF dst, USE src, KILL fcc0);
 8238   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8239             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8240             &quot;FSTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8241             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8242             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8243       &quot;skip:&quot; %}
 8244   ins_encode(form_f2i_helper(src,dst));
 8245   ins_pipe(fcvtF2I);
 8246 %}
 8247 
 8248 instruct convF2I_stk(stackSlotI dst, regF src) %{
 8249   match(Set dst (ConvF2I src));
 8250   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8251   expand %{
 8252     regF tmp;
 8253     convF2I_helper(tmp, src);
 8254     regF_to_stkI(dst, tmp);
 8255   %}
 8256 %}
 8257 
 8258 instruct convF2I_reg(iRegI dst, regF src) %{
 8259   predicate(UseVIS &gt;= 3);
 8260   match(Set dst (ConvF2I src));
 8261   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8262   expand %{
 8263     regF tmp;
 8264     convF2I_helper(tmp, src);
 8265     MoveF2I_reg_reg(dst, tmp);
 8266   %}
 8267 %}
 8268 
 8269 
 8270 // Convert a float to a long in a float register.
 8271 // If the float is a NAN, stuff a zero in instead.
 8272 instruct convF2L_helper(regD dst, regF src, flagsRegF0 fcc0) %{
 8273   effect(DEF dst, USE src, KILL fcc0);
 8274   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8275             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8276             &quot;FSTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8277             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8278             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8279       &quot;skip:&quot; %}
 8280   ins_encode(form_f2l_helper(src,dst));
 8281   ins_pipe(fcvtF2L);
 8282 %}
 8283 
 8284 instruct convF2L_stk(stackSlotL dst, regF src) %{
 8285   match(Set dst (ConvF2L src));
 8286   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8287   expand %{
 8288     regD tmp;
 8289     convF2L_helper(tmp, src);
 8290     regD_to_stkL(dst, tmp);
 8291   %}
 8292 %}
 8293 
 8294 instruct convF2L_reg(iRegL dst, regF src) %{
 8295   predicate(UseVIS &gt;= 3);
 8296   match(Set dst (ConvF2L src));
 8297   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8298   expand %{
 8299     regD tmp;
 8300     convF2L_helper(tmp, src);
 8301     MoveD2L_reg_reg(dst, tmp);
 8302   %}
 8303 %}
 8304 
 8305 
 8306 instruct convI2D_helper(regD dst, regF tmp) %{
 8307   effect(USE tmp, DEF dst);
 8308   format %{ &quot;FITOD  $tmp,$dst&quot; %}
 8309   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8310   ins_encode(form3_opf_rs2F_rdD(tmp, dst));
 8311   ins_pipe(fcvtI2D);
 8312 %}
 8313 
 8314 instruct convI2D_stk(stackSlotI src, regD dst) %{
 8315   match(Set dst (ConvI2D src));
 8316   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8317   expand %{
 8318     regF tmp;
 8319     stkI_to_regF(tmp, src);
 8320     convI2D_helper(dst, tmp);
 8321   %}
 8322 %}
 8323 
 8324 instruct convI2D_reg(regD_low dst, iRegI src) %{
 8325   predicate(UseVIS &gt;= 3);
 8326   match(Set dst (ConvI2D src));
 8327   expand %{
 8328     regF tmp;
 8329     MoveI2F_reg_reg(tmp, src);
 8330     convI2D_helper(dst, tmp);
 8331   %}
 8332 %}
 8333 
 8334 instruct convI2D_mem(regD_low dst, memory mem) %{
 8335   match(Set dst (ConvI2D (LoadI mem)));
 8336   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8337   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8338             &quot;FITOD  $dst,$dst&quot; %}
 8339   opcode(Assembler::ldf_op3, Assembler::fitod_opf);
 8340   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8341   ins_pipe(floadF_mem);
 8342 %}
 8343 
 8344 
 8345 instruct convI2F_helper(regF dst, regF tmp) %{
 8346   effect(DEF dst, USE tmp);
 8347   format %{ &quot;FITOS  $tmp,$dst&quot; %}
 8348   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitos_opf);
 8349   ins_encode(form3_opf_rs2F_rdF(tmp, dst));
 8350   ins_pipe(fcvtI2F);
 8351 %}
 8352 
 8353 instruct convI2F_stk(regF dst, stackSlotI src) %{
 8354   match(Set dst (ConvI2F src));
 8355   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8356   expand %{
 8357     regF tmp;
 8358     stkI_to_regF(tmp,src);
 8359     convI2F_helper(dst, tmp);
 8360   %}
 8361 %}
 8362 
 8363 instruct convI2F_reg(regF dst, iRegI src) %{
 8364   predicate(UseVIS &gt;= 3);
 8365   match(Set dst (ConvI2F src));
 8366   ins_cost(DEFAULT_COST);
 8367   expand %{
 8368     regF tmp;
 8369     MoveI2F_reg_reg(tmp, src);
 8370     convI2F_helper(dst, tmp);
 8371   %}
 8372 %}
 8373 
 8374 instruct convI2F_mem( regF dst, memory mem ) %{
 8375   match(Set dst (ConvI2F (LoadI mem)));
 8376   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8377   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8378             &quot;FITOS  $dst,$dst&quot; %}
 8379   opcode(Assembler::ldf_op3, Assembler::fitos_opf);
 8380   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8381   ins_pipe(floadF_mem);
 8382 %}
 8383 
 8384 
 8385 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8386   match(Set dst (ConvI2L src));
 8387   size(4);
 8388   format %{ &quot;SRA    $src,0,$dst\t! int-&gt;long&quot; %}
 8389   opcode(Assembler::sra_op3, Assembler::arith_op);
 8390   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8391   ins_pipe(ialu_reg_reg);
 8392 %}
 8393 
 8394 // Zero-extend convert int to long
 8395 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask ) %{
 8396   match(Set dst (AndL (ConvI2L src) mask) );
 8397   size(4);
 8398   format %{ &quot;SRL    $src,0,$dst\t! zero-extend int to long&quot; %}
 8399   opcode(Assembler::srl_op3, Assembler::arith_op);
 8400   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8401   ins_pipe(ialu_reg_reg);
 8402 %}
 8403 
 8404 // Zero-extend long
 8405 instruct zerox_long(iRegL dst, iRegL src, immL_32bits mask ) %{
 8406   match(Set dst (AndL src mask) );
 8407   size(4);
 8408   format %{ &quot;SRL    $src,0,$dst\t! zero-extend long&quot; %}
 8409   opcode(Assembler::srl_op3, Assembler::arith_op);
 8410   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8411   ins_pipe(ialu_reg_reg);
 8412 %}
 8413 
 8414 
 8415 //-----------
 8416 // Long to Double conversion using V8 opcodes.
 8417 // Still useful because cheetah traps and becomes
 8418 // amazingly slow for some common numbers.
 8419 
 8420 // Magic constant, 0x43300000
 8421 instruct loadConI_x43300000(iRegI dst) %{
 8422   effect(DEF dst);
 8423   size(4);
 8424   format %{ &quot;SETHI  HI(0x43300000),$dst\t! 2^52&quot; %}
 8425   ins_encode(SetHi22(0x43300000, dst));
 8426   ins_pipe(ialu_none);
 8427 %}
 8428 
 8429 // Magic constant, 0x41f00000
 8430 instruct loadConI_x41f00000(iRegI dst) %{
 8431   effect(DEF dst);
 8432   size(4);
 8433   format %{ &quot;SETHI  HI(0x41f00000),$dst\t! 2^32&quot; %}
 8434   ins_encode(SetHi22(0x41f00000, dst));
 8435   ins_pipe(ialu_none);
 8436 %}
 8437 
 8438 // Construct a double from two float halves
 8439 instruct regDHi_regDLo_to_regD(regD_low dst, regD_low src1, regD_low src2) %{
 8440   effect(DEF dst, USE src1, USE src2);
 8441   size(8);
 8442   format %{ &quot;FMOVS  $src1.hi,$dst.hi\n\t&quot;
 8443             &quot;FMOVS  $src2.lo,$dst.lo&quot; %}
 8444   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmovs_opf);
 8445   ins_encode(form3_opf_rs2D_hi_rdD_hi(src1, dst), form3_opf_rs2D_lo_rdD_lo(src2, dst));
 8446   ins_pipe(faddD_reg_reg);
 8447 %}
 8448 
 8449 // Convert integer in high half of a double register (in the lower half of
 8450 // the double register file) to double
 8451 instruct convI2D_regDHi_regD(regD dst, regD_low src) %{
 8452   effect(DEF dst, USE src);
 8453   size(4);
 8454   format %{ &quot;FITOD  $src,$dst&quot; %}
 8455   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8456   ins_encode(form3_opf_rs2D_rdD(src, dst));
 8457   ins_pipe(fcvtLHi2D);
 8458 %}
 8459 
 8460 // Add float double precision
 8461 instruct addD_regD_regD(regD dst, regD src1, regD src2) %{
 8462   effect(DEF dst, USE src1, USE src2);
 8463   size(4);
 8464   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 8465   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 8466   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8467   ins_pipe(faddD_reg_reg);
 8468 %}
 8469 
 8470 // Sub float double precision
 8471 instruct subD_regD_regD(regD dst, regD src1, regD src2) %{
 8472   effect(DEF dst, USE src1, USE src2);
 8473   size(4);
 8474   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 8475   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 8476   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8477   ins_pipe(faddD_reg_reg);
 8478 %}
 8479 
 8480 // Mul float double precision
 8481 instruct mulD_regD_regD(regD dst, regD src1, regD src2) %{
 8482   effect(DEF dst, USE src1, USE src2);
 8483   size(4);
 8484   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 8485   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 8486   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8487   ins_pipe(fmulD_reg_reg);
 8488 %}
 8489 
 8490 // Long to Double conversion using fast fxtof
 8491 instruct convL2D_helper(regD dst, regD tmp) %{
 8492   effect(DEF dst, USE tmp);
 8493   size(4);
 8494   format %{ &quot;FXTOD  $tmp,$dst&quot; %}
 8495   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtod_opf);
 8496   ins_encode(form3_opf_rs2D_rdD(tmp, dst));
 8497   ins_pipe(fcvtL2D);
 8498 %}
 8499 
 8500 instruct convL2D_stk_fast_fxtof(regD dst, stackSlotL src) %{
 8501   match(Set dst (ConvL2D src));
 8502   ins_cost(DEFAULT_COST + 3 * MEMORY_REF_COST);
 8503   expand %{
 8504     regD tmp;
 8505     stkL_to_regD(tmp, src);
 8506     convL2D_helper(dst, tmp);
 8507   %}
 8508 %}
 8509 
 8510 instruct convL2D_reg(regD dst, iRegL src) %{
 8511   predicate(UseVIS &gt;= 3);
 8512   match(Set dst (ConvL2D src));
 8513   expand %{
 8514     regD tmp;
 8515     MoveL2D_reg_reg(tmp, src);
 8516     convL2D_helper(dst, tmp);
 8517   %}
 8518 %}
 8519 
 8520 // Long to Float conversion using fast fxtof
 8521 instruct convL2F_helper(regF dst, regD tmp) %{
 8522   effect(DEF dst, USE tmp);
 8523   size(4);
 8524   format %{ &quot;FXTOS  $tmp,$dst&quot; %}
 8525   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtos_opf);
 8526   ins_encode(form3_opf_rs2D_rdF(tmp, dst));
 8527   ins_pipe(fcvtL2F);
 8528 %}
 8529 
 8530 instruct convL2F_stk_fast_fxtof(regF dst, stackSlotL src) %{
 8531   match(Set dst (ConvL2F src));
 8532   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8533   expand %{
 8534     regD tmp;
 8535     stkL_to_regD(tmp, src);
 8536     convL2F_helper(dst, tmp);
 8537   %}
 8538 %}
 8539 
 8540 instruct convL2F_reg(regF dst, iRegL src) %{
 8541   predicate(UseVIS &gt;= 3);
 8542   match(Set dst (ConvL2F src));
 8543   ins_cost(DEFAULT_COST);
 8544   expand %{
 8545     regD tmp;
 8546     MoveL2D_reg_reg(tmp, src);
 8547     convL2F_helper(dst, tmp);
 8548   %}
 8549 %}
 8550 
 8551 //-----------
 8552 
 8553 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8554   match(Set dst (ConvL2I src));
 8555   size(4);
 8556   format %{ &quot;SRA    $src,R_G0,$dst\t! long-&gt;int&quot; %}
 8557   ins_encode( form3_rs1_rd_signextend_lo1( src, dst ) );
 8558   ins_pipe(ialu_reg);
 8559 %}
 8560 
 8561 // Register Shift Right Immediate
 8562 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt) %{
 8563   match(Set dst (ConvL2I (RShiftL src cnt)));
 8564 
 8565   size(4);
 8566   format %{ &quot;SRAX   $src,$cnt,$dst&quot; %}
 8567   opcode(Assembler::srax_op3, Assembler::arith_op);
 8568   ins_encode( form3_sd_rs1_imm6_rd( src, cnt, dst ) );
 8569   ins_pipe(ialu_reg_imm);
 8570 %}
 8571 
 8572 //----------Control Flow Instructions------------------------------------------
 8573 // Compare Instructions
 8574 // Compare Integers
 8575 instruct compI_iReg(flagsReg icc, iRegI op1, iRegI op2) %{
 8576   match(Set icc (CmpI op1 op2));
 8577   effect( DEF icc, USE op1, USE op2 );
 8578 
 8579   size(4);
 8580   format %{ &quot;CMP    $op1,$op2&quot; %}
 8581   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8582   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8583   ins_pipe(ialu_cconly_reg_reg);
 8584 %}
 8585 
 8586 instruct compU_iReg(flagsRegU icc, iRegI op1, iRegI op2) %{
 8587   match(Set icc (CmpU op1 op2));
 8588 
 8589   size(4);
 8590   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8591   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8592   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8593   ins_pipe(ialu_cconly_reg_reg);
 8594 %}
 8595 
 8596 instruct compUL_iReg(flagsRegUL xcc, iRegL op1, iRegL op2) %{
 8597   match(Set xcc (CmpUL op1 op2));
 8598   effect(DEF xcc, USE op1, USE op2);
 8599 
 8600   size(4);
 8601   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8602   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8603   ins_encode(form3_rs1_rs2_rd(op1, op2, R_G0));
 8604   ins_pipe(ialu_cconly_reg_reg);
 8605 %}
 8606 
 8607 instruct compI_iReg_imm13(flagsReg icc, iRegI op1, immI13 op2) %{
 8608   match(Set icc (CmpI op1 op2));
 8609   effect( DEF icc, USE op1 );
 8610 
 8611   size(4);
 8612   format %{ &quot;CMP    $op1,$op2&quot; %}
 8613   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8614   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8615   ins_pipe(ialu_cconly_reg_imm);
 8616 %}
 8617 
 8618 instruct testI_reg_reg( flagsReg icc, iRegI op1, iRegI op2, immI0 zero ) %{
 8619   match(Set icc (CmpI (AndI op1 op2) zero));
 8620 
 8621   size(4);
 8622   format %{ &quot;BTST   $op2,$op1&quot; %}
 8623   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8624   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8625   ins_pipe(ialu_cconly_reg_reg_zero);
 8626 %}
 8627 
 8628 instruct testI_reg_imm( flagsReg icc, iRegI op1, immI13 op2, immI0 zero ) %{
 8629   match(Set icc (CmpI (AndI op1 op2) zero));
 8630 
 8631   size(4);
 8632   format %{ &quot;BTST   $op2,$op1&quot; %}
 8633   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8634   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8635   ins_pipe(ialu_cconly_reg_imm_zero);
 8636 %}
 8637 
 8638 instruct compL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2 ) %{
 8639   match(Set xcc (CmpL op1 op2));
 8640   effect( DEF xcc, USE op1, USE op2 );
 8641 
 8642   size(4);
 8643   format %{ &quot;CMP    $op1,$op2\t\t! long&quot; %}
 8644   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8645   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8646   ins_pipe(ialu_cconly_reg_reg);
 8647 %}
 8648 
 8649 instruct compL_reg_con(flagsRegL xcc, iRegL op1, immL13 con) %{
 8650   match(Set xcc (CmpL op1 con));
 8651   effect( DEF xcc, USE op1, USE con );
 8652 
 8653   size(4);
 8654   format %{ &quot;CMP    $op1,$con\t\t! long&quot; %}
 8655   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8656   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8657   ins_pipe(ialu_cconly_reg_reg);
 8658 %}
 8659 
 8660 instruct testL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2, immL0 zero) %{
 8661   match(Set xcc (CmpL (AndL op1 op2) zero));
 8662   effect( DEF xcc, USE op1, USE op2 );
 8663 
 8664   size(4);
 8665   format %{ &quot;BTST   $op1,$op2\t\t! long&quot; %}
 8666   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8667   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8668   ins_pipe(ialu_cconly_reg_reg);
 8669 %}
 8670 
 8671 // useful for checking the alignment of a pointer:
 8672 instruct testL_reg_con(flagsRegL xcc, iRegL op1, immL13 con, immL0 zero) %{
 8673   match(Set xcc (CmpL (AndL op1 con) zero));
 8674   effect( DEF xcc, USE op1, USE con );
 8675 
 8676   size(4);
 8677   format %{ &quot;BTST   $op1,$con\t\t! long&quot; %}
 8678   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8679   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8680   ins_pipe(ialu_cconly_reg_reg);
 8681 %}
 8682 
 8683 instruct compU_iReg_imm13(flagsRegU icc, iRegI op1, immU12 op2 ) %{
 8684   match(Set icc (CmpU op1 op2));
 8685 
 8686   size(4);
 8687   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8688   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8689   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8690   ins_pipe(ialu_cconly_reg_imm);
 8691 %}
 8692 
 8693 instruct compUL_iReg_imm13(flagsRegUL xcc, iRegL op1, immUL12 op2) %{
 8694   match(Set xcc (CmpUL op1 op2));
 8695   effect(DEF xcc, USE op1, USE op2);
 8696 
 8697   size(4);
 8698   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8699   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8700   ins_encode(form3_rs1_simm13_rd(op1, op2, R_G0));
 8701   ins_pipe(ialu_cconly_reg_imm);
 8702 %}
 8703 
 8704 // Compare Pointers
 8705 instruct compP_iRegP(flagsRegP pcc, iRegP op1, iRegP op2 ) %{
 8706   match(Set pcc (CmpP op1 op2));
 8707 
 8708   size(4);
 8709   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8710   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8711   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8712   ins_pipe(ialu_cconly_reg_reg);
 8713 %}
 8714 
 8715 instruct compP_iRegP_imm13(flagsRegP pcc, iRegP op1, immP13 op2 ) %{
 8716   match(Set pcc (CmpP op1 op2));
 8717 
 8718   size(4);
 8719   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8720   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8721   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8722   ins_pipe(ialu_cconly_reg_imm);
 8723 %}
 8724 
 8725 // Compare Narrow oops
 8726 instruct compN_iRegN(flagsReg icc, iRegN op1, iRegN op2 ) %{
 8727   match(Set icc (CmpN op1 op2));
 8728 
 8729   size(4);
 8730   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8731   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8732   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8733   ins_pipe(ialu_cconly_reg_reg);
 8734 %}
 8735 
 8736 instruct compN_iRegN_immN0(flagsReg icc, iRegN op1, immN0 op2 ) %{
 8737   match(Set icc (CmpN op1 op2));
 8738 
 8739   size(4);
 8740   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8741   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8742   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8743   ins_pipe(ialu_cconly_reg_imm);
 8744 %}
 8745 
 8746 //----------Max and Min--------------------------------------------------------
 8747 // Min Instructions
 8748 // Conditional move for min
 8749 instruct cmovI_reg_lt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8750   effect( USE_DEF op2, USE op1, USE icc );
 8751 
 8752   size(4);
 8753   format %{ &quot;MOVlt  icc,$op1,$op2\t! min&quot; %}
 8754   opcode(Assembler::less);
 8755   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8756   ins_pipe(ialu_reg_flags);
 8757 %}
 8758 
 8759 // Min Register with Register.
 8760 instruct minI_eReg(iRegI op1, iRegI op2) %{
 8761   match(Set op2 (MinI op1 op2));
 8762   ins_cost(DEFAULT_COST*2);
 8763   expand %{
 8764     flagsReg icc;
 8765     compI_iReg(icc,op1,op2);
 8766     cmovI_reg_lt(op2,op1,icc);
 8767   %}
 8768 %}
 8769 
 8770 // Max Instructions
 8771 // Conditional move for max
 8772 instruct cmovI_reg_gt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8773   effect( USE_DEF op2, USE op1, USE icc );
 8774   format %{ &quot;MOVgt  icc,$op1,$op2\t! max&quot; %}
 8775   opcode(Assembler::greater);
 8776   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8777   ins_pipe(ialu_reg_flags);
 8778 %}
 8779 
 8780 // Max Register with Register
 8781 instruct maxI_eReg(iRegI op1, iRegI op2) %{
 8782   match(Set op2 (MaxI op1 op2));
 8783   ins_cost(DEFAULT_COST*2);
 8784   expand %{
 8785     flagsReg icc;
 8786     compI_iReg(icc,op1,op2);
 8787     cmovI_reg_gt(op2,op1,icc);
 8788   %}
 8789 %}
 8790 
 8791 
 8792 //----------Float Compares----------------------------------------------------
 8793 // Compare floating, generate condition code
 8794 instruct cmpF_cc(flagsRegF fcc, regF src1, regF src2) %{
 8795   match(Set fcc (CmpF src1 src2));
 8796 
 8797   size(4);
 8798   format %{ &quot;FCMPs  $fcc,$src1,$src2&quot; %}
 8799   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmps_opf);
 8800   ins_encode( form3_opf_rs1F_rs2F_fcc( src1, src2, fcc ) );
 8801   ins_pipe(faddF_fcc_reg_reg_zero);
 8802 %}
 8803 
 8804 instruct cmpD_cc(flagsRegF fcc, regD src1, regD src2) %{
 8805   match(Set fcc (CmpD src1 src2));
 8806 
 8807   size(4);
 8808   format %{ &quot;FCMPd  $fcc,$src1,$src2&quot; %}
 8809   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmpd_opf);
 8810   ins_encode( form3_opf_rs1D_rs2D_fcc( src1, src2, fcc ) );
 8811   ins_pipe(faddD_fcc_reg_reg_zero);
 8812 %}
 8813 
 8814 
 8815 // Compare floating, generate -1,0,1
 8816 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsRegF0 fcc0) %{
 8817   match(Set dst (CmpF3 src1 src2));
 8818   effect(KILL fcc0);
 8819   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8820   format %{ &quot;fcmpl  $dst,$src1,$src2&quot; %}
 8821   // Primary = float
 8822   opcode( true );
 8823   ins_encode( floating_cmp( dst, src1, src2 ) );
 8824   ins_pipe( floating_cmp );
 8825 %}
 8826 
 8827 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsRegF0 fcc0) %{
 8828   match(Set dst (CmpD3 src1 src2));
 8829   effect(KILL fcc0);
 8830   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8831   format %{ &quot;dcmpl  $dst,$src1,$src2&quot; %}
 8832   // Primary = double (not float)
 8833   opcode( false );
 8834   ins_encode( floating_cmp( dst, src1, src2 ) );
 8835   ins_pipe( floating_cmp );
 8836 %}
 8837 
 8838 //----------Branches---------------------------------------------------------
 8839 // Jump
 8840 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8841 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8842   match(Jump switch_val);
 8843   effect(TEMP table);
 8844 
 8845   ins_cost(350);
 8846 
 8847   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8848              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8849              &quot;JUMP   O7&quot; %}
 8850   ins_encode %{
 8851     // Calculate table address into a register.
 8852     Register table_reg;
 8853     Register label_reg = O7;
 8854     // If we are calculating the size of this instruction don&#39;t trust
 8855     // zero offsets because they might change when
 8856     // MachConstantBaseNode decides to optimize the constant table
 8857     // base.
<a name="13" id="anc13"></a><span class="line-modified"> 8858     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;in_scratch_emit_size()) {</span>
 8859       table_reg = $constanttablebase;
 8860     } else {
 8861       table_reg = O7;
 8862       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8863       __ add($constanttablebase, con_offset, table_reg);
 8864     }
 8865 
 8866     // Jump to base address + switch value
 8867     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8868     __ jmp(label_reg, G0);
 8869     __ delayed()-&gt;nop();
 8870   %}
 8871   ins_pipe(ialu_reg_reg);
 8872 %}
 8873 
 8874 // Direct Branch.  Use V8 version with longer range.
 8875 instruct branch(label labl) %{
 8876   match(Goto);
 8877   effect(USE labl);
 8878 
 8879   size(8);
 8880   ins_cost(BRANCH_COST);
 8881   format %{ &quot;BA     $labl&quot; %}
 8882   ins_encode %{
 8883     Label* L = $labl$$label;
 8884     __ ba(*L);
 8885     __ delayed()-&gt;nop();
 8886   %}
 8887   ins_avoid_back_to_back(AVOID_BEFORE);
 8888   ins_pipe(br);
 8889 %}
 8890 
 8891 // Direct Branch, short with no delay slot
 8892 instruct branch_short(label labl) %{
 8893   match(Goto);
 8894   predicate(UseCBCond);
 8895   effect(USE labl);
 8896 
 8897   size(4); // Assuming no NOP inserted.
 8898   ins_cost(BRANCH_COST);
 8899   format %{ &quot;BA     $labl\t! short branch&quot; %}
 8900   ins_encode %{
 8901     Label* L = $labl$$label;
 8902     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 8903     __ ba_short(*L);
 8904   %}
 8905   ins_short_branch(1);
 8906   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 8907   ins_pipe(cbcond_reg_imm);
 8908 %}
 8909 
 8910 // Conditional Direct Branch
 8911 instruct branchCon(cmpOp cmp, flagsReg icc, label labl) %{
 8912   match(If cmp icc);
 8913   effect(USE labl);
 8914 
 8915   size(8);
 8916   ins_cost(BRANCH_COST);
 8917   format %{ &quot;BP$cmp   $icc,$labl&quot; %}
 8918   // Prim = bits 24-22, Secnd = bits 31-30
 8919   ins_encode( enc_bp( labl, cmp, icc ) );
 8920   ins_avoid_back_to_back(AVOID_BEFORE);
 8921   ins_pipe(br_cc);
 8922 %}
 8923 
 8924 instruct branchConU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8925   match(If cmp icc);
 8926   effect(USE labl);
 8927 
 8928   ins_cost(BRANCH_COST);
 8929   format %{ &quot;BP$cmp  $icc,$labl&quot; %}
 8930   // Prim = bits 24-22, Secnd = bits 31-30
 8931   ins_encode( enc_bp( labl, cmp, icc ) );
 8932   ins_avoid_back_to_back(AVOID_BEFORE);
 8933   ins_pipe(br_cc);
 8934 %}
 8935 
 8936 instruct branchConP(cmpOpP cmp, flagsRegP pcc, label labl) %{
 8937   match(If cmp pcc);
 8938   effect(USE labl);
 8939 
 8940   size(8);
 8941   ins_cost(BRANCH_COST);
 8942   format %{ &quot;BP$cmp  $pcc,$labl&quot; %}
 8943   ins_encode %{
 8944     Label* L = $labl$$label;
 8945     Assembler::Predict predict_taken =
 8946       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8947 
 8948     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 8949     __ delayed()-&gt;nop();
 8950   %}
 8951   ins_avoid_back_to_back(AVOID_BEFORE);
 8952   ins_pipe(br_cc);
 8953 %}
 8954 
 8955 instruct branchConF(cmpOpF cmp, flagsRegF fcc, label labl) %{
 8956   match(If cmp fcc);
 8957   effect(USE labl);
 8958 
 8959   size(8);
 8960   ins_cost(BRANCH_COST);
 8961   format %{ &quot;FBP$cmp $fcc,$labl&quot; %}
 8962   ins_encode %{
 8963     Label* L = $labl$$label;
 8964     Assembler::Predict predict_taken =
 8965       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8966 
 8967     __ fbp( (Assembler::Condition)($cmp$$cmpcode), false, (Assembler::CC)($fcc$$reg), predict_taken, *L);
 8968     __ delayed()-&gt;nop();
 8969   %}
 8970   ins_avoid_back_to_back(AVOID_BEFORE);
 8971   ins_pipe(br_fcc);
 8972 %}
 8973 
 8974 instruct branchLoopEnd(cmpOp cmp, flagsReg icc, label labl) %{
 8975   match(CountedLoopEnd cmp icc);
 8976   effect(USE labl);
 8977 
 8978   size(8);
 8979   ins_cost(BRANCH_COST);
 8980   format %{ &quot;BP$cmp   $icc,$labl\t! Loop end&quot; %}
 8981   // Prim = bits 24-22, Secnd = bits 31-30
 8982   ins_encode( enc_bp( labl, cmp, icc ) );
 8983   ins_avoid_back_to_back(AVOID_BEFORE);
 8984   ins_pipe(br_cc);
 8985 %}
 8986 
 8987 instruct branchLoopEndU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8988   match(CountedLoopEnd cmp icc);
 8989   effect(USE labl);
 8990 
 8991   size(8);
 8992   ins_cost(BRANCH_COST);
 8993   format %{ &quot;BP$cmp  $icc,$labl\t! Loop end&quot; %}
 8994   // Prim = bits 24-22, Secnd = bits 31-30
 8995   ins_encode( enc_bp( labl, cmp, icc ) );
 8996   ins_avoid_back_to_back(AVOID_BEFORE);
 8997   ins_pipe(br_cc);
 8998 %}
 8999 
 9000 // Compare and branch instructions
 9001 instruct cmpI_reg_branch(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9002   match(If cmp (CmpI op1 op2));
 9003   effect(USE labl, KILL icc);
 9004 
 9005   size(12);
 9006   ins_cost(BRANCH_COST);
 9007   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9008             &quot;BP$cmp   $labl&quot; %}
 9009   ins_encode %{
 9010     Label* L = $labl$$label;
 9011     Assembler::Predict predict_taken =
 9012       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9013     __ cmp($op1$$Register, $op2$$Register);
 9014     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9015     __ delayed()-&gt;nop();
 9016   %}
 9017   ins_pipe(cmp_br_reg_reg);
 9018 %}
 9019 
 9020 instruct cmpI_imm_branch(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9021   match(If cmp (CmpI op1 op2));
 9022   effect(USE labl, KILL icc);
 9023 
 9024   size(12);
 9025   ins_cost(BRANCH_COST);
 9026   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9027             &quot;BP$cmp   $labl&quot; %}
 9028   ins_encode %{
 9029     Label* L = $labl$$label;
 9030     Assembler::Predict predict_taken =
 9031       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9032     __ cmp($op1$$Register, $op2$$constant);
 9033     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9034     __ delayed()-&gt;nop();
 9035   %}
 9036   ins_pipe(cmp_br_reg_imm);
 9037 %}
 9038 
 9039 instruct cmpU_reg_branch(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9040   match(If cmp (CmpU op1 op2));
 9041   effect(USE labl, KILL icc);
 9042 
 9043   size(12);
 9044   ins_cost(BRANCH_COST);
 9045   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9046             &quot;BP$cmp  $labl&quot; %}
 9047   ins_encode %{
 9048     Label* L = $labl$$label;
 9049     Assembler::Predict predict_taken =
 9050       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9051     __ cmp($op1$$Register, $op2$$Register);
 9052     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9053     __ delayed()-&gt;nop();
 9054   %}
 9055   ins_pipe(cmp_br_reg_reg);
 9056 %}
 9057 
 9058 instruct cmpU_imm_branch(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9059   match(If cmp (CmpU op1 op2));
 9060   effect(USE labl, KILL icc);
 9061 
 9062   size(12);
 9063   ins_cost(BRANCH_COST);
 9064   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9065             &quot;BP$cmp  $labl&quot; %}
 9066   ins_encode %{
 9067     Label* L = $labl$$label;
 9068     Assembler::Predict predict_taken =
 9069       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9070     __ cmp($op1$$Register, $op2$$constant);
 9071     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9072     __ delayed()-&gt;nop();
 9073   %}
 9074   ins_pipe(cmp_br_reg_imm);
 9075 %}
 9076 
 9077 instruct cmpUL_reg_branch(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9078   match(If cmp (CmpUL op1 op2));
 9079   effect(USE labl, KILL xcc);
 9080 
 9081   size(12);
 9082   ins_cost(BRANCH_COST);
 9083   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9084             &quot;BP$cmp   $labl&quot; %}
 9085   ins_encode %{
 9086     Label* L = $labl$$label;
 9087     Assembler::Predict predict_taken =
 9088       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9089     __ cmp($op1$$Register, $op2$$Register);
 9090     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9091     __ delayed()-&gt;nop();
 9092   %}
 9093   ins_pipe(cmp_br_reg_reg);
 9094 %}
 9095 
 9096 instruct cmpUL_imm_branch(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9097   match(If cmp (CmpUL op1 op2));
 9098   effect(USE labl, KILL xcc);
 9099 
 9100   size(12);
 9101   ins_cost(BRANCH_COST);
 9102   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9103             &quot;BP$cmp   $labl&quot; %}
 9104   ins_encode %{
 9105     Label* L = $labl$$label;
 9106     Assembler::Predict predict_taken =
 9107       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9108     __ cmp($op1$$Register, $op2$$constant);
 9109     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9110     __ delayed()-&gt;nop();
 9111   %}
 9112   ins_pipe(cmp_br_reg_imm);
 9113 %}
 9114 
 9115 instruct cmpL_reg_branch(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9116   match(If cmp (CmpL op1 op2));
 9117   effect(USE labl, KILL xcc);
 9118 
 9119   size(12);
 9120   ins_cost(BRANCH_COST);
 9121   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9122             &quot;BP$cmp   $labl&quot; %}
 9123   ins_encode %{
 9124     Label* L = $labl$$label;
 9125     Assembler::Predict predict_taken =
 9126       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9127     __ cmp($op1$$Register, $op2$$Register);
 9128     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9129     __ delayed()-&gt;nop();
 9130   %}
 9131   ins_pipe(cmp_br_reg_reg);
 9132 %}
 9133 
 9134 instruct cmpL_imm_branch(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9135   match(If cmp (CmpL op1 op2));
 9136   effect(USE labl, KILL xcc);
 9137 
 9138   size(12);
 9139   ins_cost(BRANCH_COST);
 9140   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9141             &quot;BP$cmp   $labl&quot; %}
 9142   ins_encode %{
 9143     Label* L = $labl$$label;
 9144     Assembler::Predict predict_taken =
 9145       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9146     __ cmp($op1$$Register, $op2$$constant);
 9147     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9148     __ delayed()-&gt;nop();
 9149   %}
 9150   ins_pipe(cmp_br_reg_imm);
 9151 %}
 9152 
 9153 // Compare Pointers and branch
 9154 instruct cmpP_reg_branch(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9155   match(If cmp (CmpP op1 op2));
 9156   effect(USE labl, KILL pcc);
 9157 
 9158   size(12);
 9159   ins_cost(BRANCH_COST);
 9160   format %{ &quot;CMP    $op1,$op2\t! ptr\n\t&quot;
 9161             &quot;B$cmp   $labl&quot; %}
 9162   ins_encode %{
 9163     Label* L = $labl$$label;
 9164     Assembler::Predict predict_taken =
 9165       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9166     __ cmp($op1$$Register, $op2$$Register);
 9167     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9168     __ delayed()-&gt;nop();
 9169   %}
 9170   ins_pipe(cmp_br_reg_reg);
 9171 %}
 9172 
 9173 instruct cmpP_null_branch(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9174   match(If cmp (CmpP op1 null));
 9175   effect(USE labl, KILL pcc);
 9176 
 9177   size(12);
 9178   ins_cost(BRANCH_COST);
 9179   format %{ &quot;CMP    $op1,0\t! ptr\n\t&quot;
 9180             &quot;B$cmp   $labl&quot; %}
 9181   ins_encode %{
 9182     Label* L = $labl$$label;
 9183     Assembler::Predict predict_taken =
 9184       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9185     __ cmp($op1$$Register, G0);
 9186     // bpr() is not used here since it has shorter distance.
 9187     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9188     __ delayed()-&gt;nop();
 9189   %}
 9190   ins_pipe(cmp_br_reg_reg);
 9191 %}
 9192 
 9193 instruct cmpN_reg_branch(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9194   match(If cmp (CmpN op1 op2));
 9195   effect(USE labl, KILL icc);
 9196 
 9197   size(12);
 9198   ins_cost(BRANCH_COST);
 9199   format %{ &quot;CMP    $op1,$op2\t! compressed ptr\n\t&quot;
 9200             &quot;BP$cmp   $labl&quot; %}
 9201   ins_encode %{
 9202     Label* L = $labl$$label;
 9203     Assembler::Predict predict_taken =
 9204       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9205     __ cmp($op1$$Register, $op2$$Register);
 9206     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9207     __ delayed()-&gt;nop();
 9208   %}
 9209   ins_pipe(cmp_br_reg_reg);
 9210 %}
 9211 
 9212 instruct cmpN_null_branch(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9213   match(If cmp (CmpN op1 null));
 9214   effect(USE labl, KILL icc);
 9215 
 9216   size(12);
 9217   ins_cost(BRANCH_COST);
 9218   format %{ &quot;CMP    $op1,0\t! compressed ptr\n\t&quot;
 9219             &quot;BP$cmp   $labl&quot; %}
 9220   ins_encode %{
 9221     Label* L = $labl$$label;
 9222     Assembler::Predict predict_taken =
 9223       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9224     __ cmp($op1$$Register, G0);
 9225     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9226     __ delayed()-&gt;nop();
 9227   %}
 9228   ins_pipe(cmp_br_reg_reg);
 9229 %}
 9230 
 9231 // Loop back branch
 9232 instruct cmpI_reg_branchLoopEnd(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9233   match(CountedLoopEnd cmp (CmpI op1 op2));
 9234   effect(USE labl, KILL icc);
 9235 
 9236   size(12);
 9237   ins_cost(BRANCH_COST);
 9238   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9239             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9240   ins_encode %{
 9241     Label* L = $labl$$label;
 9242     Assembler::Predict predict_taken =
 9243       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9244     __ cmp($op1$$Register, $op2$$Register);
 9245     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9246     __ delayed()-&gt;nop();
 9247   %}
 9248   ins_pipe(cmp_br_reg_reg);
 9249 %}
 9250 
 9251 instruct cmpI_imm_branchLoopEnd(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9252   match(CountedLoopEnd cmp (CmpI op1 op2));
 9253   effect(USE labl, KILL icc);
 9254 
 9255   size(12);
 9256   ins_cost(BRANCH_COST);
 9257   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9258             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9259   ins_encode %{
 9260     Label* L = $labl$$label;
 9261     Assembler::Predict predict_taken =
 9262       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9263     __ cmp($op1$$Register, $op2$$constant);
 9264     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9265     __ delayed()-&gt;nop();
 9266   %}
 9267   ins_pipe(cmp_br_reg_imm);
 9268 %}
 9269 
 9270 // Short compare and branch instructions
 9271 instruct cmpI_reg_branch_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9272   match(If cmp (CmpI op1 op2));
 9273   predicate(UseCBCond);
 9274   effect(USE labl, KILL icc);
 9275 
 9276   size(4); // Assuming no NOP inserted.
 9277   ins_cost(BRANCH_COST);
 9278   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9279   ins_encode %{
 9280     Label* L = $labl$$label;
 9281     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9282     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9283   %}
 9284   ins_short_branch(1);
 9285   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9286   ins_pipe(cbcond_reg_reg);
 9287 %}
 9288 
 9289 instruct cmpI_imm_branch_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9290   match(If cmp (CmpI op1 op2));
 9291   predicate(UseCBCond);
 9292   effect(USE labl, KILL icc);
 9293 
 9294   size(4); // Assuming no NOP inserted.
 9295   ins_cost(BRANCH_COST);
 9296   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9297   ins_encode %{
 9298     Label* L = $labl$$label;
 9299     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9300     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9301   %}
 9302   ins_short_branch(1);
 9303   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9304   ins_pipe(cbcond_reg_imm);
 9305 %}
 9306 
 9307 instruct cmpU_reg_branch_short(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9308   match(If cmp (CmpU op1 op2));
 9309   predicate(UseCBCond);
 9310   effect(USE labl, KILL icc);
 9311 
 9312   size(4); // Assuming no NOP inserted.
 9313   ins_cost(BRANCH_COST);
 9314   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9315   ins_encode %{
 9316     Label* L = $labl$$label;
 9317     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9318     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9319   %}
 9320   ins_short_branch(1);
 9321   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9322   ins_pipe(cbcond_reg_reg);
 9323 %}
 9324 
 9325 instruct cmpU_imm_branch_short(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9326   match(If cmp (CmpU op1 op2));
 9327   predicate(UseCBCond);
 9328   effect(USE labl, KILL icc);
 9329 
 9330   size(4); // Assuming no NOP inserted.
 9331   ins_cost(BRANCH_COST);
 9332   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9333   ins_encode %{
 9334     Label* L = $labl$$label;
 9335     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9336     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9337   %}
 9338   ins_short_branch(1);
 9339   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9340   ins_pipe(cbcond_reg_imm);
 9341 %}
 9342 
 9343 instruct cmpUL_reg_branch_short(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9344   match(If cmp (CmpUL op1 op2));
 9345   predicate(UseCBCond);
 9346   effect(USE labl, KILL xcc);
 9347 
 9348   size(4);
 9349   ins_cost(BRANCH_COST);
 9350   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9351   ins_encode %{
 9352     Label* L = $labl$$label;
 9353     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9354     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9355   %}
 9356   ins_short_branch(1);
 9357   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9358   ins_pipe(cbcond_reg_reg);
 9359 %}
 9360 
 9361 instruct cmpUL_imm_branch_short(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9362   match(If cmp (CmpUL op1 op2));
 9363   predicate(UseCBCond);
 9364   effect(USE labl, KILL xcc);
 9365 
 9366   size(4);
 9367   ins_cost(BRANCH_COST);
 9368   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9369   ins_encode %{
 9370     Label* L = $labl$$label;
 9371     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9372     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9373   %}
 9374   ins_short_branch(1);
 9375   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9376   ins_pipe(cbcond_reg_imm);
 9377 %}
 9378 
 9379 instruct cmpL_reg_branch_short(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9380   match(If cmp (CmpL op1 op2));
 9381   predicate(UseCBCond);
 9382   effect(USE labl, KILL xcc);
 9383 
 9384   size(4); // Assuming no NOP inserted.
 9385   ins_cost(BRANCH_COST);
 9386   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9387   ins_encode %{
 9388     Label* L = $labl$$label;
 9389     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9390     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9391   %}
 9392   ins_short_branch(1);
 9393   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9394   ins_pipe(cbcond_reg_reg);
 9395 %}
 9396 
 9397 instruct cmpL_imm_branch_short(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9398   match(If cmp (CmpL op1 op2));
 9399   predicate(UseCBCond);
 9400   effect(USE labl, KILL xcc);
 9401 
 9402   size(4); // Assuming no NOP inserted.
 9403   ins_cost(BRANCH_COST);
 9404   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9405   ins_encode %{
 9406     Label* L = $labl$$label;
 9407     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9408     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9409   %}
 9410   ins_short_branch(1);
 9411   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9412   ins_pipe(cbcond_reg_imm);
 9413 %}
 9414 
 9415 // Compare Pointers and branch
 9416 instruct cmpP_reg_branch_short(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9417   match(If cmp (CmpP op1 op2));
 9418   predicate(UseCBCond);
 9419   effect(USE labl, KILL pcc);
 9420 
 9421   size(4); // Assuming no NOP inserted.
 9422   ins_cost(BRANCH_COST);
 9423   format %{ &quot;CXB$cmp $op1,$op2,$labl\t! ptr&quot; %}
 9424   ins_encode %{
 9425     Label* L = $labl$$label;
 9426     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9427     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, $op2$$Register, *L);
 9428   %}
 9429   ins_short_branch(1);
 9430   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9431   ins_pipe(cbcond_reg_reg);
 9432 %}
 9433 
 9434 instruct cmpP_null_branch_short(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9435   match(If cmp (CmpP op1 null));
 9436   predicate(UseCBCond);
 9437   effect(USE labl, KILL pcc);
 9438 
 9439   size(4); // Assuming no NOP inserted.
 9440   ins_cost(BRANCH_COST);
 9441   format %{ &quot;CXB$cmp $op1,0,$labl\t! ptr&quot; %}
 9442   ins_encode %{
 9443     Label* L = $labl$$label;
 9444     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9445     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, G0, *L);
 9446   %}
 9447   ins_short_branch(1);
 9448   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9449   ins_pipe(cbcond_reg_reg);
 9450 %}
 9451 
 9452 instruct cmpN_reg_branch_short(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9453   match(If cmp (CmpN op1 op2));
 9454   predicate(UseCBCond);
 9455   effect(USE labl, KILL icc);
 9456 
 9457   size(4); // Assuming no NOP inserted.
 9458   ins_cost(BRANCH_COST);
 9459   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! compressed ptr&quot; %}
 9460   ins_encode %{
 9461     Label* L = $labl$$label;
 9462     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9463     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9464   %}
 9465   ins_short_branch(1);
 9466   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9467   ins_pipe(cbcond_reg_reg);
 9468 %}
 9469 
 9470 instruct cmpN_null_branch_short(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9471   match(If cmp (CmpN op1 null));
 9472   predicate(UseCBCond);
 9473   effect(USE labl, KILL icc);
 9474 
 9475   size(4); // Assuming no NOP inserted.
 9476   ins_cost(BRANCH_COST);
 9477   format %{ &quot;CWB$cmp  $op1,0,$labl\t! compressed ptr&quot; %}
 9478   ins_encode %{
 9479     Label* L = $labl$$label;
 9480     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9481     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, G0, *L);
 9482   %}
 9483   ins_short_branch(1);
 9484   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9485   ins_pipe(cbcond_reg_reg);
 9486 %}
 9487 
 9488 // Loop back branch
 9489 instruct cmpI_reg_branchLoopEnd_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9490   match(CountedLoopEnd cmp (CmpI op1 op2));
 9491   predicate(UseCBCond);
 9492   effect(USE labl, KILL icc);
 9493 
 9494   size(4); // Assuming no NOP inserted.
 9495   ins_cost(BRANCH_COST);
 9496   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9497   ins_encode %{
 9498     Label* L = $labl$$label;
 9499     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9500     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9501   %}
 9502   ins_short_branch(1);
 9503   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9504   ins_pipe(cbcond_reg_reg);
 9505 %}
 9506 
 9507 instruct cmpI_imm_branchLoopEnd_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9508   match(CountedLoopEnd cmp (CmpI op1 op2));
 9509   predicate(UseCBCond);
 9510   effect(USE labl, KILL icc);
 9511 
 9512   size(4); // Assuming no NOP inserted.
 9513   ins_cost(BRANCH_COST);
 9514   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9515   ins_encode %{
 9516     Label* L = $labl$$label;
 9517     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9518     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9519   %}
 9520   ins_short_branch(1);
 9521   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9522   ins_pipe(cbcond_reg_imm);
 9523 %}
 9524 
 9525 // Branch-on-register tests all 64 bits.  We assume that values
 9526 // in 64-bit registers always remains zero or sign extended
 9527 // unless our code munges the high bits.  Interrupts can chop
 9528 // the high order bits to zero or sign at any time.
 9529 instruct branchCon_regI(cmpOp_reg cmp, iRegI op1, immI0 zero, label labl) %{
 9530   match(If cmp (CmpI op1 zero));
 9531   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9532   effect(USE labl);
 9533 
 9534   size(8);
 9535   ins_cost(BRANCH_COST);
 9536   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9537   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9538   ins_avoid_back_to_back(AVOID_BEFORE);
 9539   ins_pipe(br_reg);
 9540 %}
 9541 
 9542 instruct branchCon_regP(cmpOp_reg cmp, iRegP op1, immP0 null, label labl) %{
 9543   match(If cmp (CmpP op1 null));
 9544   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9545   effect(USE labl);
 9546 
 9547   size(8);
 9548   ins_cost(BRANCH_COST);
 9549   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9550   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9551   ins_avoid_back_to_back(AVOID_BEFORE);
 9552   ins_pipe(br_reg);
 9553 %}
 9554 
 9555 instruct branchCon_regL(cmpOp_reg cmp, iRegL op1, immL0 zero, label labl) %{
 9556   match(If cmp (CmpL op1 zero));
 9557   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9558   effect(USE labl);
 9559 
 9560   size(8);
 9561   ins_cost(BRANCH_COST);
 9562   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9563   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9564   ins_avoid_back_to_back(AVOID_BEFORE);
 9565   ins_pipe(br_reg);
 9566 %}
 9567 
 9568 
 9569 // ============================================================================
 9570 // Long Compare
 9571 //
 9572 // Currently we hold longs in 2 registers.  Comparing such values efficiently
 9573 // is tricky.  The flavor of compare used depends on whether we are testing
 9574 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
 9575 // The GE test is the negated LT test.  The LE test can be had by commuting
 9576 // the operands (yielding a GE test) and then negating; negate again for the
 9577 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
 9578 // NE test is negated from that.
 9579 
 9580 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9581 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
 9582 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
 9583 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
 9584 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9585 // foo match ends up with the wrong leaf.  One fix is to not match both
 9586 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
 9587 // both forms beat the trinary form of long-compare and both are very useful
 9588 // on Intel which has so few registers.
 9589 
 9590 instruct branchCon_long(cmpOp cmp, flagsRegL xcc, label labl) %{
 9591   match(If cmp xcc);
 9592   effect(USE labl);
 9593 
 9594   size(8);
 9595   ins_cost(BRANCH_COST);
 9596   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9597   ins_encode %{
 9598     Label* L = $labl$$label;
 9599     Assembler::Predict predict_taken =
 9600       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9601 
 9602     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9603     __ delayed()-&gt;nop();
 9604   %}
 9605   ins_avoid_back_to_back(AVOID_BEFORE);
 9606   ins_pipe(br_cc);
 9607 %}
 9608 
 9609 instruct branchConU_long(cmpOpU cmp, flagsRegUL xcc, label labl) %{
 9610   match(If cmp xcc);
 9611   effect(USE labl);
 9612 
 9613   size(8);
 9614   ins_cost(BRANCH_COST);
 9615   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9616   ins_encode %{
 9617     Label* L = $labl$$label;
 9618     Assembler::Predict predict_taken =
 9619       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9620 
 9621     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9622     __ delayed()-&gt;nop();
 9623   %}
 9624   ins_avoid_back_to_back(AVOID_BEFORE);
 9625   ins_pipe(br_cc);
 9626 %}
 9627 
 9628 // Manifest a CmpL3 result in an integer register.  Very painful.
 9629 // This is the test to avoid.
 9630 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg ccr ) %{
 9631   match(Set dst (CmpL3 src1 src2) );
 9632   effect( KILL ccr );
 9633   ins_cost(6*DEFAULT_COST);
 9634   size(24);
 9635   format %{ &quot;CMP    $src1,$src2\t\t! long\n&quot;
 9636           &quot;\tBLT,a,pn done\n&quot;
 9637           &quot;\tMOV    -1,$dst\t! delay slot\n&quot;
 9638           &quot;\tBGT,a,pn done\n&quot;
 9639           &quot;\tMOV    1,$dst\t! delay slot\n&quot;
 9640           &quot;\tCLR    $dst\n&quot;
 9641     &quot;done:&quot;     %}
 9642   ins_encode( cmpl_flag(src1,src2,dst) );
 9643   ins_pipe(cmpL_reg);
 9644 %}
 9645 
 9646 // Conditional move
 9647 instruct cmovLL_reg(cmpOp cmp, flagsRegL xcc, iRegL dst, iRegL src) %{
 9648   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9649   ins_cost(150);
 9650   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9651   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9652   ins_pipe(ialu_reg);
 9653 %}
 9654 
 9655 instruct cmovLL_imm(cmpOp cmp, flagsRegL xcc, iRegL dst, immL0 src) %{
 9656   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9657   ins_cost(140);
 9658   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9659   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9660   ins_pipe(ialu_imm);
 9661 %}
 9662 
 9663 instruct cmovIL_reg(cmpOp cmp, flagsRegL xcc, iRegI dst, iRegI src) %{
 9664   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9665   ins_cost(150);
 9666   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9667   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9668   ins_pipe(ialu_reg);
 9669 %}
 9670 
 9671 instruct cmovIL_imm(cmpOp cmp, flagsRegL xcc, iRegI dst, immI11 src) %{
 9672   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9673   ins_cost(140);
 9674   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9675   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9676   ins_pipe(ialu_imm);
 9677 %}
 9678 
 9679 instruct cmovNL_reg(cmpOp cmp, flagsRegL xcc, iRegN dst, iRegN src) %{
 9680   match(Set dst (CMoveN (Binary cmp xcc) (Binary dst src)));
 9681   ins_cost(150);
 9682   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9683   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9684   ins_pipe(ialu_reg);
 9685 %}
 9686 
 9687 instruct cmovPL_reg(cmpOp cmp, flagsRegL xcc, iRegP dst, iRegP src) %{
 9688   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9689   ins_cost(150);
 9690   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9691   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9692   ins_pipe(ialu_reg);
 9693 %}
 9694 
 9695 instruct cmovPL_imm(cmpOp cmp, flagsRegL xcc, iRegP dst, immP0 src) %{
 9696   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9697   ins_cost(140);
 9698   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9699   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9700   ins_pipe(ialu_imm);
 9701 %}
 9702 
 9703 instruct cmovFL_reg(cmpOp cmp, flagsRegL xcc, regF dst, regF src) %{
 9704   match(Set dst (CMoveF (Binary cmp xcc) (Binary dst src)));
 9705   ins_cost(150);
 9706   opcode(0x101);
 9707   format %{ &quot;FMOVS$cmp $xcc,$src,$dst&quot; %}
 9708   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9709   ins_pipe(int_conditional_float_move);
 9710 %}
 9711 
 9712 instruct cmovDL_reg(cmpOp cmp, flagsRegL xcc, regD dst, regD src) %{
 9713   match(Set dst (CMoveD (Binary cmp xcc) (Binary dst src)));
 9714   ins_cost(150);
 9715   opcode(0x102);
 9716   format %{ &quot;FMOVD$cmp $xcc,$src,$dst&quot; %}
 9717   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9718   ins_pipe(int_conditional_float_move);
 9719 %}
 9720 
 9721 // ============================================================================
 9722 // Safepoint Instruction
 9723 instruct safePoint_poll(iRegP poll) %{
 9724   match(SafePoint poll);
 9725   effect(USE poll);
 9726 
 9727   size(4);
 9728   format %{ &quot;LDX    [$poll],R_G0\t! Safepoint: poll for GC&quot; %}
 9729   ins_encode %{
 9730     __ relocate(relocInfo::poll_type);
 9731     __ ld_ptr($poll$$Register, 0, G0);
 9732   %}
 9733   ins_pipe(loadPollP);
 9734 %}
 9735 
 9736 // ============================================================================
 9737 // Call Instructions
 9738 // Call Java Static Instruction
 9739 instruct CallStaticJavaDirect( method meth ) %{
 9740   match(CallStaticJava);
 9741   predicate(! ((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9742   effect(USE meth);
 9743 
 9744   size(8);
 9745   ins_cost(CALL_COST);
 9746   format %{ &quot;CALL,static  ; NOP ==&gt; &quot; %}
 9747   ins_encode( Java_Static_Call( meth ), call_epilog );
 9748   ins_avoid_back_to_back(AVOID_BEFORE);
 9749   ins_pipe(simple_call);
 9750 %}
 9751 
 9752 // Call Java Static Instruction (method handle version)
 9753 instruct CallStaticJavaHandle(method meth, l7RegP l7_mh_SP_save) %{
 9754   match(CallStaticJava);
 9755   predicate(((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9756   effect(USE meth, KILL l7_mh_SP_save);
 9757 
 9758   size(16);
 9759   ins_cost(CALL_COST);
 9760   format %{ &quot;CALL,static/MethodHandle&quot; %}
 9761   ins_encode(preserve_SP, Java_Static_Call(meth), restore_SP, call_epilog);
 9762   ins_pipe(simple_call);
 9763 %}
 9764 
 9765 // Call Java Dynamic Instruction
 9766 instruct CallDynamicJavaDirect( method meth ) %{
 9767   match(CallDynamicJava);
 9768   effect(USE meth);
 9769 
 9770   ins_cost(CALL_COST);
 9771   format %{ &quot;SET    (empty),R_G5\n\t&quot;
 9772             &quot;CALL,dynamic  ; NOP ==&gt; &quot; %}
 9773   ins_encode( Java_Dynamic_Call( meth ), call_epilog );
 9774   ins_pipe(call);
 9775 %}
 9776 
 9777 // Call Runtime Instruction
 9778 instruct CallRuntimeDirect(method meth, l7RegP l7) %{
 9779   match(CallRuntime);
 9780   effect(USE meth, KILL l7);
 9781   ins_cost(CALL_COST);
 9782   format %{ &quot;CALL,runtime&quot; %}
 9783   ins_encode( Java_To_Runtime( meth ),
 9784               call_epilog, adjust_long_from_native_call );
 9785   ins_avoid_back_to_back(AVOID_BEFORE);
 9786   ins_pipe(simple_call);
 9787 %}
 9788 
 9789 // Call runtime without safepoint - same as CallRuntime
 9790 instruct CallLeafDirect(method meth, l7RegP l7) %{
 9791   match(CallLeaf);
 9792   effect(USE meth, KILL l7);
 9793   ins_cost(CALL_COST);
 9794   format %{ &quot;CALL,runtime leaf&quot; %}
 9795   ins_encode( Java_To_Runtime( meth ),
 9796               call_epilog,
 9797               adjust_long_from_native_call );
 9798   ins_avoid_back_to_back(AVOID_BEFORE);
 9799   ins_pipe(simple_call);
 9800 %}
 9801 
 9802 // Call runtime without safepoint - same as CallLeaf
 9803 instruct CallLeafNoFPDirect(method meth, l7RegP l7) %{
 9804   match(CallLeafNoFP);
 9805   effect(USE meth, KILL l7);
 9806   ins_cost(CALL_COST);
 9807   format %{ &quot;CALL,runtime leaf nofp&quot; %}
 9808   ins_encode( Java_To_Runtime( meth ),
 9809               call_epilog,
 9810               adjust_long_from_native_call );
 9811   ins_avoid_back_to_back(AVOID_BEFORE);
 9812   ins_pipe(simple_call);
 9813 %}
 9814 
 9815 // Tail Call; Jump from runtime stub to Java code.
 9816 // Also known as an &#39;interprocedural jump&#39;.
 9817 // Target of jump will eventually return to caller.
 9818 // TailJump below removes the return address.
 9819 instruct TailCalljmpInd(g3RegP jump_target, inline_cache_regP method_oop) %{
 9820   match(TailCall jump_target method_oop );
 9821 
 9822   ins_cost(CALL_COST);
 9823   format %{ &quot;Jmp     $jump_target  ; NOP \t! $method_oop holds method oop&quot; %}
 9824   ins_encode(form_jmpl(jump_target));
 9825   ins_avoid_back_to_back(AVOID_BEFORE);
 9826   ins_pipe(tail_call);
 9827 %}
 9828 
 9829 
 9830 // Return Instruction
 9831 instruct Ret() %{
 9832   match(Return);
 9833 
 9834   // The epilogue node did the ret already.
 9835   size(0);
 9836   format %{ &quot;! return&quot; %}
 9837   ins_encode();
 9838   ins_pipe(empty);
 9839 %}
 9840 
 9841 
 9842 // Tail Jump; remove the return address; jump to target.
 9843 // TailCall above leaves the return address around.
 9844 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9845 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9846 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9847 // in %i0.
 9848 instruct tailjmpInd(g1RegP jump_target, i0RegP ex_oop) %{
 9849   match( TailJump jump_target ex_oop );
 9850   ins_cost(CALL_COST);
 9851   format %{ &quot;! discard R_O7\n\t&quot;
 9852             &quot;Jmp     $jump_target  ; ADD O7,8,O1 \t! $ex_oop holds exc. oop&quot; %}
 9853   ins_encode(form_jmpl_set_exception_pc(jump_target));
 9854   // opcode(Assembler::jmpl_op3, Assembler::arith_op);
 9855   // The hack duplicates the exception oop into G3, so that CreateEx can use it there.
 9856   // ins_encode( form3_rs1_simm13_rd( jump_target, 0x00, R_G0 ), move_return_pc_to_o1() );
 9857   ins_avoid_back_to_back(AVOID_BEFORE);
 9858   ins_pipe(tail_call);
 9859 %}
 9860 
 9861 // Create exception oop: created by stack-crawling runtime code.
 9862 // Created exception is now available to this handler, and is setup
 9863 // just prior to jumping to this handler.  No code emitted.
 9864 instruct CreateException( o0RegP ex_oop )
 9865 %{
 9866   match(Set ex_oop (CreateEx));
 9867   ins_cost(0);
 9868 
 9869   size(0);
 9870   // use the following format syntax
 9871   format %{ &quot;! exception oop is in R_O0; no code emitted&quot; %}
 9872   ins_encode();
 9873   ins_pipe(empty);
 9874 %}
 9875 
 9876 
 9877 // Rethrow exception:
 9878 // The exception oop will come in the first argument position.
 9879 // Then JUMP (not call) to the rethrow stub code.
 9880 instruct RethrowException()
 9881 %{
 9882   match(Rethrow);
 9883   ins_cost(CALL_COST);
 9884 
 9885   // use the following format syntax
 9886   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9887   ins_encode(enc_rethrow);
 9888   ins_avoid_back_to_back(AVOID_BEFORE);
 9889   ins_pipe(tail_call);
 9890 %}
 9891 
 9892 
 9893 // Die now
 9894 instruct ShouldNotReachHere( )
 9895 %{
 9896   match(Halt);
 9897   ins_cost(CALL_COST);
 9898 
 9899   size(4);
 9900   // Use the following format syntax
 9901   format %{ &quot;ILLTRAP   ; ShouldNotReachHere&quot; %}
 9902   ins_encode( form2_illtrap() );
 9903   ins_pipe(tail_call);
 9904 %}
 9905 
 9906 // ============================================================================
 9907 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
 9908 // array for an instance of the superklass.  Set a hidden internal cache on a
 9909 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
 9910 // not zero for a miss or zero for a hit.  The encoding ALSO sets flags.
 9911 instruct partialSubtypeCheck( o0RegP index, o1RegP sub, o2RegP super, flagsRegP pcc, o7RegP o7 ) %{
 9912   match(Set index (PartialSubtypeCheck sub super));
 9913   effect( KILL pcc, KILL o7 );
 9914   ins_cost(DEFAULT_COST*10);
 9915   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP&quot; %}
 9916   ins_encode( enc_PartialSubtypeCheck() );
 9917   ins_avoid_back_to_back(AVOID_BEFORE);
 9918   ins_pipe(partial_subtype_check_pipe);
 9919 %}
 9920 
 9921 instruct partialSubtypeCheck_vs_zero( flagsRegP pcc, o1RegP sub, o2RegP super, immP0 zero, o0RegP idx, o7RegP o7 ) %{
 9922   match(Set pcc (CmpP (PartialSubtypeCheck sub super) zero));
 9923   effect( KILL idx, KILL o7 );
 9924   ins_cost(DEFAULT_COST*10);
 9925   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP\t# (sets condition codes)&quot; %}
 9926   ins_encode( enc_PartialSubtypeCheck() );
 9927   ins_avoid_back_to_back(AVOID_BEFORE);
 9928   ins_pipe(partial_subtype_check_pipe);
 9929 %}
 9930 
 9931 
 9932 // ============================================================================
 9933 // inlined locking and unlocking
 9934 
 9935 instruct cmpFastLock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9936   match(Set pcc (FastLock object box));
 9937 
 9938   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9939   ins_cost(100);
 9940 
 9941   format %{ &quot;FASTLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9942   ins_encode( Fast_Lock(object, box, scratch, scratch2) );
 9943   ins_pipe(long_memory_op);
 9944 %}
 9945 
 9946 
 9947 instruct cmpFastUnlock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9948   match(Set pcc (FastUnlock object box));
 9949   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9950   ins_cost(100);
 9951 
 9952   format %{ &quot;FASTUNLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9953   ins_encode( Fast_Unlock(object, box, scratch, scratch2) );
 9954   ins_pipe(long_memory_op);
 9955 %}
 9956 
 9957 // The encodings are generic.
 9958 instruct clear_array(iRegX cnt, iRegP base, iRegX temp, Universe dummy, flagsReg ccr) %{
 9959   predicate(!use_block_zeroing(n-&gt;in(2)) );
 9960   match(Set dummy (ClearArray cnt base));
 9961   effect(TEMP temp, KILL ccr);
 9962   ins_cost(300);
 9963   format %{ &quot;MOV    $cnt,$temp\n&quot;
 9964     &quot;loop:   SUBcc  $temp,8,$temp\t! Count down a dword of bytes\n&quot;
 9965     &quot;        BRge   loop\t\t! Clearing loop\n&quot;
 9966     &quot;        STX    G0,[$base+$temp]\t! delay slot&quot; %}
 9967 
 9968   ins_encode %{
 9969     // Compiler ensures base is doubleword aligned and cnt is count of doublewords
 9970     Register nof_bytes_arg    = $cnt$$Register;
 9971     Register nof_bytes_tmp    = $temp$$Register;
 9972     Register base_pointer_arg = $base$$Register;
 9973 
 9974     Label loop;
 9975     __ mov(nof_bytes_arg, nof_bytes_tmp);
 9976 
 9977     // Loop and clear, walking backwards through the array.
 9978     // nof_bytes_tmp (if &gt;0) is always the number of bytes to zero
 9979     __ bind(loop);
 9980     __ deccc(nof_bytes_tmp, 8);
 9981     __ br(Assembler::greaterEqual, true, Assembler::pt, loop);
 9982     __ delayed()-&gt; stx(G0, base_pointer_arg, nof_bytes_tmp);
 9983     // %%%% this mini-loop must not cross a cache boundary!
 9984   %}
 9985   ins_pipe(long_memory_op);
 9986 %}
 9987 
 9988 instruct clear_array_bis(g1RegX cnt, o0RegP base, Universe dummy, flagsReg ccr) %{
 9989   predicate(use_block_zeroing(n-&gt;in(2)));
 9990   match(Set dummy (ClearArray cnt base));
 9991   effect(USE_KILL cnt, USE_KILL base, KILL ccr);
 9992   ins_cost(300);
 9993   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
 9994 
 9995   ins_encode %{
 9996 
 9997     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
 9998     Register to    = $base$$Register;
 9999     Register count = $cnt$$Register;
10000 
10001     Label Ldone;
10002     __ nop(); // Separate short branches
10003     // Use BIS for zeroing (temp is not used).
10004     __ bis_zeroing(to, count, G0, Ldone);
10005     __ bind(Ldone);
10006 
10007   %}
10008   ins_pipe(long_memory_op);
10009 %}
10010 
10011 instruct clear_array_bis_2(g1RegX cnt, o0RegP base, iRegX tmp, Universe dummy, flagsReg ccr) %{
10012   predicate(use_block_zeroing(n-&gt;in(2)) &amp;&amp; !Assembler::is_simm13((int)BlockZeroingLowLimit));
10013   match(Set dummy (ClearArray cnt base));
10014   effect(TEMP tmp, USE_KILL cnt, USE_KILL base, KILL ccr);
10015   ins_cost(300);
10016   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
10017 
10018   ins_encode %{
10019 
10020     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
10021     Register to    = $base$$Register;
10022     Register count = $cnt$$Register;
10023     Register temp  = $tmp$$Register;
10024 
10025     Label Ldone;
10026     __ nop(); // Separate short branches
10027     // Use BIS for zeroing
10028     __ bis_zeroing(to, count, temp, Ldone);
10029     __ bind(Ldone);
10030 
10031   %}
10032   ins_pipe(long_memory_op);
10033 %}
10034 
10035 instruct string_compareL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10036                          o7RegI tmp, flagsReg ccr) %{
10037   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10038   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10039   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10040   ins_cost(300);
10041   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10042   ins_encode %{
10043     __ string_compare($str1$$Register, $str2$$Register,
10044                       $cnt1$$Register, $cnt2$$Register,
10045                       $tmp$$Register, $tmp$$Register,
10046                       $result$$Register, StrIntrinsicNode::LL);
10047   %}
10048   ins_pipe(long_memory_op);
10049 %}
10050 
10051 instruct string_compareU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10052                          o7RegI tmp, flagsReg ccr) %{
10053   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10054   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10055   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10056   ins_cost(300);
10057   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10058   ins_encode %{
10059     __ string_compare($str1$$Register, $str2$$Register,
10060                       $cnt1$$Register, $cnt2$$Register,
10061                       $tmp$$Register, $tmp$$Register,
10062                       $result$$Register, StrIntrinsicNode::UU);
10063   %}
10064   ins_pipe(long_memory_op);
10065 %}
10066 
10067 instruct string_compareLU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10068                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10069   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10070   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10071   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10072   ins_cost(300);
10073   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10074   ins_encode %{
10075     __ string_compare($str1$$Register, $str2$$Register,
10076                       $cnt1$$Register, $cnt2$$Register,
10077                       $tmp1$$Register, $tmp2$$Register,
10078                       $result$$Register, StrIntrinsicNode::LU);
10079   %}
10080   ins_pipe(long_memory_op);
10081 %}
10082 
10083 instruct string_compareUL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10084                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10085   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10086   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10087   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10088   ins_cost(300);
10089   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10090   ins_encode %{
10091     __ string_compare($str2$$Register, $str1$$Register,
10092                       $cnt2$$Register, $cnt1$$Register,
10093                       $tmp1$$Register, $tmp2$$Register,
10094                       $result$$Register, StrIntrinsicNode::UL);
10095   %}
10096   ins_pipe(long_memory_op);
10097 %}
10098 
10099 instruct string_equalsL(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10100                         o7RegI tmp, flagsReg ccr) %{
10101   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10102   match(Set result (StrEquals (Binary str1 str2) cnt));
10103   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10104   ins_cost(300);
10105   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10106   ins_encode %{
10107     __ array_equals(false, $str1$$Register, $str2$$Register,
10108                     $cnt$$Register, $tmp$$Register,
10109                     $result$$Register, true /* byte */);
10110   %}
10111   ins_pipe(long_memory_op);
10112 %}
10113 
10114 instruct string_equalsU(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10115                         o7RegI tmp, flagsReg ccr) %{
10116   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10117   match(Set result (StrEquals (Binary str1 str2) cnt));
10118   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10119   ins_cost(300);
10120   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10121   ins_encode %{
10122     __ array_equals(false, $str1$$Register, $str2$$Register,
10123                     $cnt$$Register, $tmp$$Register,
10124                     $result$$Register, false /* byte */);
10125   %}
10126   ins_pipe(long_memory_op);
10127 %}
10128 
10129 instruct array_equalsB(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10130                        o7RegI tmp2, flagsReg ccr) %{
10131   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10132   match(Set result (AryEq ary1 ary2));
10133   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10134   ins_cost(300);
10135   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10136   ins_encode %{
10137     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10138                     $tmp1$$Register, $tmp2$$Register,
10139                     $result$$Register, true /* byte */);
10140   %}
10141   ins_pipe(long_memory_op);
10142 %}
10143 
10144 instruct array_equalsC(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10145                        o7RegI tmp2, flagsReg ccr) %{
10146   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10147   match(Set result (AryEq ary1 ary2));
10148   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10149   ins_cost(300);
10150   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10151   ins_encode %{
10152     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10153                     $tmp1$$Register, $tmp2$$Register,
10154                     $result$$Register, false /* byte */);
10155   %}
10156   ins_pipe(long_memory_op);
10157 %}
10158 
10159 instruct has_negatives(o0RegP pAryR, g3RegI iSizeR, notemp_iRegI resultR,
10160                        iRegL tmp1L, iRegL tmp2L, iRegL tmp3L, iRegL tmp4L,
10161                        flagsReg ccr)
10162 %{
10163   match(Set resultR (HasNegatives pAryR iSizeR));
10164   effect(TEMP resultR, TEMP tmp1L, TEMP tmp2L, TEMP tmp3L, TEMP tmp4L, USE pAryR, USE iSizeR, KILL ccr);
10165   format %{ &quot;has negatives byte[] $pAryR,$iSizeR -&gt; $resultR // KILL $tmp1L,$tmp2L,$tmp3L,$tmp4L&quot; %}
10166   ins_encode %{
10167     __ has_negatives($pAryR$$Register, $iSizeR$$Register,
10168                      $resultR$$Register,
10169                      $tmp1L$$Register, $tmp2L$$Register,
10170                      $tmp3L$$Register, $tmp4L$$Register);
10171   %}
10172   ins_pipe(long_memory_op);
10173 %}
10174 
10175 // char[] to byte[] compression
10176 instruct string_compress(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result, iRegL tmp, flagsReg ccr) %{
10177   predicate(UseVIS &lt; 3);
10178   match(Set result (StrCompressedCopy src (Binary dst len)));
10179   effect(TEMP result, TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10180   ins_cost(300);
10181   format %{ &quot;String Compress $src,$dst,$len -&gt; $result    // KILL $tmp&quot; %}
10182   ins_encode %{
10183     Label Ldone;
10184     __ signx($len$$Register);
10185     __ cmp_zero_and_br(Assembler::zero, $len$$Register, Ldone, false, Assembler::pn);
10186     __ delayed()-&gt;mov($len$$Register, $result$$Register); // copy count
10187     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp$$Register, Ldone);
10188     __ bind(Ldone);
10189   %}
10190   ins_pipe(long_memory_op);
10191 %}
10192 
10193 // fast char[] to byte[] compression using VIS instructions
10194 instruct string_compress_fast(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result,
10195                               iRegL tmp1, iRegL tmp2, iRegL tmp3, iRegL tmp4,
10196                               regD ftmp1, regD ftmp2, regD ftmp3, flagsReg ccr) %{
10197   predicate(UseVIS &gt;= 3);
10198   match(Set result (StrCompressedCopy src (Binary dst len)));
10199   effect(TEMP result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10200   ins_cost(300);
10201   format %{ &quot;String Compress Fast $src,$dst,$len -&gt; $result    // KILL $tmp1,$tmp2,$tmp3,$tmp4,$ftmp1,$ftmp2,$ftmp3&quot; %}
10202   ins_encode %{
10203     Label Ldone;
10204     __ signx($len$$Register);
10205     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $result$$Register,
10206                           $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register,
10207                           $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, Ldone);
10208     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10209     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp1$$Register, Ldone);
10210     __ bind(Ldone);
10211   %}
10212   ins_pipe(long_memory_op);
10213 %}
10214 
10215 // byte[] to char[] inflation
10216 instruct string_inflate(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10217                         iRegL tmp, flagsReg ccr) %{
10218   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10219   effect(TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10220   ins_cost(300);
10221   format %{ &quot;String Inflate $src,$dst,$len    // KILL $tmp&quot; %}
10222   ins_encode %{
10223     Label Ldone;
10224     __ signx($len$$Register);
10225     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10226     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10227     __ bind(Ldone);
10228   %}
10229   ins_pipe(long_memory_op);
10230 %}
10231 
10232 // fast byte[] to char[] inflation using VIS instructions
10233 instruct string_inflate_fast(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10234                              iRegL tmp, regD ftmp1, regD ftmp2, regD ftmp3, regD ftmp4, flagsReg ccr) %{
10235   predicate(UseVIS &gt;= 3);
10236   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10237   effect(TEMP tmp, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, TEMP ftmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10238   ins_cost(300);
10239   format %{ &quot;String Inflate Fast $src,$dst,$len    // KILL $tmp,$ftmp1,$ftmp2,$ftmp3,$ftmp4&quot; %}
10240   ins_encode %{
10241     Label Ldone;
10242     __ signx($len$$Register);
10243     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register,
10244                          $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, $ftmp4$$FloatRegister, Ldone);
10245     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10246     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10247     __ bind(Ldone);
10248   %}
10249   ins_pipe(long_memory_op);
10250 %}
10251 
10252 
10253 //---------- Zeros Count Instructions ------------------------------------------
10254 
10255 instruct countLeadingZerosI(iRegIsafe dst, iRegI src, iRegI tmp, flagsReg cr) %{
10256   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10257   match(Set dst (CountLeadingZerosI src));
10258   effect(TEMP dst, TEMP tmp, KILL cr);
10259 
10260   // x |= (x &gt;&gt; 1);
10261   // x |= (x &gt;&gt; 2);
10262   // x |= (x &gt;&gt; 4);
10263   // x |= (x &gt;&gt; 8);
10264   // x |= (x &gt;&gt; 16);
10265   // return (WORDBITS - popc(x));
10266   format %{ &quot;SRL     $src,1,$tmp\t! count leading zeros (int)\n\t&quot;
10267             &quot;SRL     $src,0,$dst\t! 32-bit zero extend\n\t&quot;
10268             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10269             &quot;SRL     $dst,2,$tmp\n\t&quot;
10270             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10271             &quot;SRL     $dst,4,$tmp\n\t&quot;
10272             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10273             &quot;SRL     $dst,8,$tmp\n\t&quot;
10274             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10275             &quot;SRL     $dst,16,$tmp\n\t&quot;
10276             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10277             &quot;POPC    $dst,$dst\n\t&quot;
10278             &quot;MOV     32,$tmp\n\t&quot;
10279             &quot;SUB     $tmp,$dst,$dst&quot; %}
10280   ins_encode %{
10281     Register Rdst = $dst$$Register;
10282     Register Rsrc = $src$$Register;
10283     Register Rtmp = $tmp$$Register;
10284     __ srl(Rsrc, 1,    Rtmp);
10285     __ srl(Rsrc, 0,    Rdst);
10286     __ or3(Rdst, Rtmp, Rdst);
10287     __ srl(Rdst, 2,    Rtmp);
10288     __ or3(Rdst, Rtmp, Rdst);
10289     __ srl(Rdst, 4,    Rtmp);
10290     __ or3(Rdst, Rtmp, Rdst);
10291     __ srl(Rdst, 8,    Rtmp);
10292     __ or3(Rdst, Rtmp, Rdst);
10293     __ srl(Rdst, 16,   Rtmp);
10294     __ or3(Rdst, Rtmp, Rdst);
10295     __ popc(Rdst, Rdst);
10296     __ mov(BitsPerInt, Rtmp);
10297     __ sub(Rtmp, Rdst, Rdst);
10298   %}
10299   ins_pipe(ialu_reg);
10300 %}
10301 
10302 instruct countLeadingZerosL(iRegIsafe dst, iRegL src, iRegL tmp, flagsReg cr) %{
10303   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10304   match(Set dst (CountLeadingZerosL src));
10305   effect(TEMP dst, TEMP tmp, KILL cr);
10306 
10307   // x |= (x &gt;&gt; 1);
10308   // x |= (x &gt;&gt; 2);
10309   // x |= (x &gt;&gt; 4);
10310   // x |= (x &gt;&gt; 8);
10311   // x |= (x &gt;&gt; 16);
10312   // x |= (x &gt;&gt; 32);
10313   // return (WORDBITS - popc(x));
10314   format %{ &quot;SRLX    $src,1,$tmp\t! count leading zeros (long)\n\t&quot;
10315             &quot;OR      $src,$tmp,$dst\n\t&quot;
10316             &quot;SRLX    $dst,2,$tmp\n\t&quot;
10317             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10318             &quot;SRLX    $dst,4,$tmp\n\t&quot;
10319             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10320             &quot;SRLX    $dst,8,$tmp\n\t&quot;
10321             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10322             &quot;SRLX    $dst,16,$tmp\n\t&quot;
10323             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10324             &quot;SRLX    $dst,32,$tmp\n\t&quot;
10325             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10326             &quot;POPC    $dst,$dst\n\t&quot;
10327             &quot;MOV     64,$tmp\n\t&quot;
10328             &quot;SUB     $tmp,$dst,$dst&quot; %}
10329   ins_encode %{
10330     Register Rdst = $dst$$Register;
10331     Register Rsrc = $src$$Register;
10332     Register Rtmp = $tmp$$Register;
10333     __ srlx(Rsrc, 1,    Rtmp);
10334     __ or3( Rsrc, Rtmp, Rdst);
10335     __ srlx(Rdst, 2,    Rtmp);
10336     __ or3( Rdst, Rtmp, Rdst);
10337     __ srlx(Rdst, 4,    Rtmp);
10338     __ or3( Rdst, Rtmp, Rdst);
10339     __ srlx(Rdst, 8,    Rtmp);
10340     __ or3( Rdst, Rtmp, Rdst);
10341     __ srlx(Rdst, 16,   Rtmp);
10342     __ or3( Rdst, Rtmp, Rdst);
10343     __ srlx(Rdst, 32,   Rtmp);
10344     __ or3( Rdst, Rtmp, Rdst);
10345     __ popc(Rdst, Rdst);
10346     __ mov(BitsPerLong, Rtmp);
10347     __ sub(Rtmp, Rdst, Rdst);
10348   %}
10349   ins_pipe(ialu_reg);
10350 %}
10351 
10352 instruct countTrailingZerosI(iRegIsafe dst, iRegI src, flagsReg cr) %{
10353   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10354   match(Set dst (CountTrailingZerosI src));
10355   effect(TEMP dst, KILL cr);
10356 
10357   // return popc(~x &amp; (x - 1));
10358   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (int)\n\t&quot;
10359             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10360             &quot;SRL     $dst,R_G0,$dst\n\t&quot;
10361             &quot;POPC    $dst,$dst&quot; %}
10362   ins_encode %{
10363     Register Rdst = $dst$$Register;
10364     Register Rsrc = $src$$Register;
10365     __ sub(Rsrc, 1, Rdst);
10366     __ andn(Rdst, Rsrc, Rdst);
10367     __ srl(Rdst, G0, Rdst);
10368     __ popc(Rdst, Rdst);
10369   %}
10370   ins_pipe(ialu_reg);
10371 %}
10372 
10373 instruct countTrailingZerosL(iRegIsafe dst, iRegL src, flagsReg cr) %{
10374   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10375   match(Set dst (CountTrailingZerosL src));
10376   effect(TEMP dst, KILL cr);
10377 
10378   // return popc(~x &amp; (x - 1));
10379   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (long)\n\t&quot;
10380             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10381             &quot;POPC    $dst,$dst&quot; %}
10382   ins_encode %{
10383     Register Rdst = $dst$$Register;
10384     Register Rsrc = $src$$Register;
10385     __ sub(Rsrc, 1, Rdst);
10386     __ andn(Rdst, Rsrc, Rdst);
10387     __ popc(Rdst, Rdst);
10388   %}
10389   ins_pipe(ialu_reg);
10390 %}
10391 
10392 
10393 //---------- Population Count Instructions -------------------------------------
10394 
10395 instruct popCountI(iRegIsafe dst, iRegI src) %{
10396   predicate(UsePopCountInstruction);
10397   match(Set dst (PopCountI src));
10398 
10399   format %{ &quot;SRL    $src, G0, $dst\t! clear upper word for 64 bit POPC\n\t&quot;
10400             &quot;POPC   $dst, $dst&quot; %}
10401   ins_encode %{
10402     __ srl($src$$Register, G0, $dst$$Register);
10403     __ popc($dst$$Register, $dst$$Register);
10404   %}
10405   ins_pipe(ialu_reg);
10406 %}
10407 
10408 // Note: Long.bitCount(long) returns an int.
10409 instruct popCountL(iRegIsafe dst, iRegL src) %{
10410   predicate(UsePopCountInstruction);
10411   match(Set dst (PopCountL src));
10412 
10413   format %{ &quot;POPC   $src, $dst&quot; %}
10414   ins_encode %{
10415     __ popc($src$$Register, $dst$$Register);
10416   %}
10417   ins_pipe(ialu_reg);
10418 %}
10419 
10420 
10421 // ============================================================================
10422 //------------Bytes reverse--------------------------------------------------
10423 
10424 instruct bytes_reverse_int(iRegI dst, stackSlotI src) %{
10425   match(Set dst (ReverseBytesI src));
10426 
10427   // Op cost is artificially doubled to make sure that load or store
10428   // instructions are preferred over this one which requires a spill
10429   // onto a stack slot.
10430   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10431   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10432 
10433   ins_encode %{
10434     __ set($src$$disp + STACK_BIAS, O7);
10435     __ lduwa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10436   %}
10437   ins_pipe( iload_mem );
10438 %}
10439 
10440 instruct bytes_reverse_long(iRegL dst, stackSlotL src) %{
10441   match(Set dst (ReverseBytesL src));
10442 
10443   // Op cost is artificially doubled to make sure that load or store
10444   // instructions are preferred over this one which requires a spill
10445   // onto a stack slot.
10446   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10447   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10448 
10449   ins_encode %{
10450     __ set($src$$disp + STACK_BIAS, O7);
10451     __ ldxa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10452   %}
10453   ins_pipe( iload_mem );
10454 %}
10455 
10456 instruct bytes_reverse_unsigned_short(iRegI dst, stackSlotI src) %{
10457   match(Set dst (ReverseBytesUS src));
10458 
10459   // Op cost is artificially doubled to make sure that load or store
10460   // instructions are preferred over this one which requires a spill
10461   // onto a stack slot.
10462   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10463   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10464 
10465   ins_encode %{
10466     // the value was spilled as an int so bias the load
10467     __ set($src$$disp + STACK_BIAS + 2, O7);
10468     __ lduha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10469   %}
10470   ins_pipe( iload_mem );
10471 %}
10472 
10473 instruct bytes_reverse_short(iRegI dst, stackSlotI src) %{
10474   match(Set dst (ReverseBytesS src));
10475 
10476   // Op cost is artificially doubled to make sure that load or store
10477   // instructions are preferred over this one which requires a spill
10478   // onto a stack slot.
10479   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10480   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10481 
10482   ins_encode %{
10483     // the value was spilled as an int so bias the load
10484     __ set($src$$disp + STACK_BIAS + 2, O7);
10485     __ ldsha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10486   %}
10487   ins_pipe( iload_mem );
10488 %}
10489 
10490 // Load Integer reversed byte order
10491 instruct loadI_reversed(iRegI dst, indIndexMemory src) %{
10492   match(Set dst (ReverseBytesI (LoadI src)));
10493 
10494   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
10495   size(4);
10496   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10497 
10498   ins_encode %{
10499     __ lduwa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10500   %}
10501   ins_pipe(iload_mem);
10502 %}
10503 
10504 // Load Long - aligned and reversed
10505 instruct loadL_reversed(iRegL dst, indIndexMemory src) %{
10506   match(Set dst (ReverseBytesL (LoadL src)));
10507 
10508   ins_cost(MEMORY_REF_COST);
10509   size(4);
10510   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10511 
10512   ins_encode %{
10513     __ ldxa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10514   %}
10515   ins_pipe(iload_mem);
10516 %}
10517 
10518 // Load unsigned short / char reversed byte order
10519 instruct loadUS_reversed(iRegI dst, indIndexMemory src) %{
10520   match(Set dst (ReverseBytesUS (LoadUS src)));
10521 
10522   ins_cost(MEMORY_REF_COST);
10523   size(4);
10524   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little&quot; %}
10525 
10526   ins_encode %{
10527     __ lduha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10528   %}
10529   ins_pipe(iload_mem);
10530 %}
10531 
10532 // Load short reversed byte order
10533 instruct loadS_reversed(iRegI dst, indIndexMemory src) %{
10534   match(Set dst (ReverseBytesS (LoadS src)));
10535 
10536   ins_cost(MEMORY_REF_COST);
10537   size(4);
10538   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little&quot; %}
10539 
10540   ins_encode %{
10541     __ ldsha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10542   %}
10543   ins_pipe(iload_mem);
10544 %}
10545 
10546 // Store Integer reversed byte order
10547 instruct storeI_reversed(indIndexMemory dst, iRegI src) %{
10548   match(Set dst (StoreI dst (ReverseBytesI src)));
10549 
10550   ins_cost(MEMORY_REF_COST);
10551   size(4);
10552   format %{ &quot;STWA   $src, $dst\t!asi=primary_little&quot; %}
10553 
10554   ins_encode %{
10555     __ stwa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10556   %}
10557   ins_pipe(istore_mem_reg);
10558 %}
10559 
10560 // Store Long reversed byte order
10561 instruct storeL_reversed(indIndexMemory dst, iRegL src) %{
10562   match(Set dst (StoreL dst (ReverseBytesL src)));
10563 
10564   ins_cost(MEMORY_REF_COST);
10565   size(4);
10566   format %{ &quot;STXA   $src, $dst\t!asi=primary_little&quot; %}
10567 
10568   ins_encode %{
10569     __ stxa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10570   %}
10571   ins_pipe(istore_mem_reg);
10572 %}
10573 
10574 // Store unsighed short/char reversed byte order
10575 instruct storeUS_reversed(indIndexMemory dst, iRegI src) %{
10576   match(Set dst (StoreC dst (ReverseBytesUS src)));
10577 
10578   ins_cost(MEMORY_REF_COST);
10579   size(4);
10580   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10581 
10582   ins_encode %{
10583     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10584   %}
10585   ins_pipe(istore_mem_reg);
10586 %}
10587 
10588 // Store short reversed byte order
10589 instruct storeS_reversed(indIndexMemory dst, iRegI src) %{
10590   match(Set dst (StoreC dst (ReverseBytesS src)));
10591 
10592   ins_cost(MEMORY_REF_COST);
10593   size(4);
10594   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10595 
10596   ins_encode %{
10597     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10598   %}
10599   ins_pipe(istore_mem_reg);
10600 %}
10601 
10602 // ====================VECTOR INSTRUCTIONS=====================================
10603 
10604 // Load Aligned Packed values into a Double Register
10605 instruct loadV8(regD dst, memory mem) %{
10606   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10607   match(Set dst (LoadVector mem));
10608   ins_cost(MEMORY_REF_COST);
10609   size(4);
10610   format %{ &quot;LDDF   $mem,$dst\t! load vector (8 bytes)&quot; %}
10611   ins_encode %{
10612     __ ldf(FloatRegisterImpl::D, $mem$$Address, as_DoubleFloatRegister($dst$$reg));
10613   %}
10614   ins_pipe(floadD_mem);
10615 %}
10616 
10617 // Store Vector in Double register to memory
10618 instruct storeV8(memory mem, regD src) %{
10619   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10620   match(Set mem (StoreVector mem src));
10621   ins_cost(MEMORY_REF_COST);
10622   size(4);
10623   format %{ &quot;STDF   $src,$mem\t! store vector (8 bytes)&quot; %}
10624   ins_encode %{
10625     __ stf(FloatRegisterImpl::D, as_DoubleFloatRegister($src$$reg), $mem$$Address);
10626   %}
10627   ins_pipe(fstoreD_mem_reg);
10628 %}
10629 
10630 // Store Zero into vector in memory
10631 instruct storeV8B_zero(memory mem, immI0 zero) %{
10632   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10633   match(Set mem (StoreVector mem (ReplicateB zero)));
10634   ins_cost(MEMORY_REF_COST);
10635   size(4);
10636   format %{ &quot;STX    $zero,$mem\t! store zero vector (8 bytes)&quot; %}
10637   ins_encode %{
10638     __ stx(G0, $mem$$Address);
10639   %}
10640   ins_pipe(fstoreD_mem_zero);
10641 %}
10642 
10643 instruct storeV4S_zero(memory mem, immI0 zero) %{
10644   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10645   match(Set mem (StoreVector mem (ReplicateS zero)));
10646   ins_cost(MEMORY_REF_COST);
10647   size(4);
10648   format %{ &quot;STX    $zero,$mem\t! store zero vector (4 shorts)&quot; %}
10649   ins_encode %{
10650     __ stx(G0, $mem$$Address);
10651   %}
10652   ins_pipe(fstoreD_mem_zero);
10653 %}
10654 
10655 instruct storeV2I_zero(memory mem, immI0 zero) %{
10656   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10657   match(Set mem (StoreVector mem (ReplicateI zero)));
10658   ins_cost(MEMORY_REF_COST);
10659   size(4);
10660   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 ints)&quot; %}
10661   ins_encode %{
10662     __ stx(G0, $mem$$Address);
10663   %}
10664   ins_pipe(fstoreD_mem_zero);
10665 %}
10666 
10667 instruct storeV2F_zero(memory mem, immF0 zero) %{
10668   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10669   match(Set mem (StoreVector mem (ReplicateF zero)));
10670   ins_cost(MEMORY_REF_COST);
10671   size(4);
10672   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 floats)&quot; %}
10673   ins_encode %{
10674     __ stx(G0, $mem$$Address);
10675   %}
10676   ins_pipe(fstoreD_mem_zero);
10677 %}
10678 
10679 // Replicate scalar to packed byte values into Double register
10680 instruct Repl8B_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10681   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &gt;= 3);
10682   match(Set dst (ReplicateB src));
10683   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10684   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10685             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10686             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10687             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10688             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10689             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10690             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10691             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10692   ins_encode %{
10693     Register Rsrc = $src$$Register;
10694     Register Rtmp = $tmp$$Register;
10695     Register Rtmp2 = $tmp2$$Register;
10696     __ sllx(Rsrc,    56, Rtmp);
10697     __ srlx(Rtmp,     8, Rtmp2);
10698     __ or3 (Rtmp, Rtmp2, Rtmp);
10699     __ srlx(Rtmp,    16, Rtmp2);
10700     __ or3 (Rtmp, Rtmp2, Rtmp);
10701     __ srlx(Rtmp,    32, Rtmp2);
10702     __ or3 (Rtmp, Rtmp2, Rtmp);
10703     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10704   %}
10705   ins_pipe(ialu_reg);
10706 %}
10707 
10708 // Replicate scalar to packed byte values into Double stack
10709 instruct Repl8B_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10710   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &lt; 3);
10711   match(Set dst (ReplicateB src));
10712   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10713   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10714             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10715             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10716             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10717             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10718             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10719             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10720             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10721   ins_encode %{
10722     Register Rsrc = $src$$Register;
10723     Register Rtmp = $tmp$$Register;
10724     Register Rtmp2 = $tmp2$$Register;
10725     __ sllx(Rsrc,    56, Rtmp);
10726     __ srlx(Rtmp,     8, Rtmp2);
10727     __ or3 (Rtmp, Rtmp2, Rtmp);
10728     __ srlx(Rtmp,    16, Rtmp2);
10729     __ or3 (Rtmp, Rtmp2, Rtmp);
10730     __ srlx(Rtmp,    32, Rtmp2);
10731     __ or3 (Rtmp, Rtmp2, Rtmp);
10732     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10733     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10734   %}
10735   ins_pipe(ialu_reg);
10736 %}
10737 
10738 // Replicate scalar constant to packed byte values in Double register
10739 instruct Repl8B_immI(regD dst, immI13 con, o7RegI tmp) %{
10740   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10741   match(Set dst (ReplicateB con));
10742   effect(KILL tmp);
10743   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl8B($con)&quot; %}
10744   ins_encode %{
10745     // XXX This is a quick fix for 6833573.
10746     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 8, 1)), $dst$$FloatRegister);
10747     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 8, 1)), $tmp$$Register);
10748     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10749   %}
10750   ins_pipe(loadConFD);
10751 %}
10752 
10753 // Replicate scalar to packed char/short values into Double register
10754 instruct Repl4S_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10755   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &gt;= 3);
10756   match(Set dst (ReplicateS src));
10757   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10758   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10759             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10760             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10761             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10762             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10763             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10764   ins_encode %{
10765     Register Rsrc = $src$$Register;
10766     Register Rtmp = $tmp$$Register;
10767     Register Rtmp2 = $tmp2$$Register;
10768     __ sllx(Rsrc,    48, Rtmp);
10769     __ srlx(Rtmp,    16, Rtmp2);
10770     __ or3 (Rtmp, Rtmp2, Rtmp);
10771     __ srlx(Rtmp,    32, Rtmp2);
10772     __ or3 (Rtmp, Rtmp2, Rtmp);
10773     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10774   %}
10775   ins_pipe(ialu_reg);
10776 %}
10777 
10778 // Replicate scalar to packed char/short values into Double stack
10779 instruct Repl4S_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10780   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &lt; 3);
10781   match(Set dst (ReplicateS src));
10782   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10783   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10784             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10785             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10786             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10787             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10788             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10789   ins_encode %{
10790     Register Rsrc = $src$$Register;
10791     Register Rtmp = $tmp$$Register;
10792     Register Rtmp2 = $tmp2$$Register;
10793     __ sllx(Rsrc,    48, Rtmp);
10794     __ srlx(Rtmp,    16, Rtmp2);
10795     __ or3 (Rtmp, Rtmp2, Rtmp);
10796     __ srlx(Rtmp,    32, Rtmp2);
10797     __ or3 (Rtmp, Rtmp2, Rtmp);
10798     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10799     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10800   %}
10801   ins_pipe(ialu_reg);
10802 %}
10803 
10804 // Replicate scalar constant to packed char/short values in Double register
10805 instruct Repl4S_immI(regD dst, immI con, o7RegI tmp) %{
10806   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10807   match(Set dst (ReplicateS con));
10808   effect(KILL tmp);
10809   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl4S($con)&quot; %}
10810   ins_encode %{
10811     // XXX This is a quick fix for 6833573.
10812     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 4, 2)), $dst$$FloatRegister);
10813     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 4, 2)), $tmp$$Register);
10814     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10815   %}
10816   ins_pipe(loadConFD);
10817 %}
10818 
10819 // Replicate scalar to packed int values into Double register
10820 instruct Repl2I_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10821   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &gt;= 3);
10822   match(Set dst (ReplicateI src));
10823   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10824   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10825             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10826             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10827             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10828   ins_encode %{
10829     Register Rsrc = $src$$Register;
10830     Register Rtmp = $tmp$$Register;
10831     Register Rtmp2 = $tmp2$$Register;
10832     __ sllx(Rsrc,    32, Rtmp);
10833     __ srlx(Rtmp,    32, Rtmp2);
10834     __ or3 (Rtmp, Rtmp2, Rtmp);
10835     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10836   %}
10837   ins_pipe(ialu_reg);
10838 %}
10839 
10840 // Replicate scalar to packed int values into Double stack
10841 instruct Repl2I_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10842   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &lt; 3);
10843   match(Set dst (ReplicateI src));
10844   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10845   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10846             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10847             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10848             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10849   ins_encode %{
10850     Register Rsrc = $src$$Register;
10851     Register Rtmp = $tmp$$Register;
10852     Register Rtmp2 = $tmp2$$Register;
10853     __ sllx(Rsrc,    32, Rtmp);
10854     __ srlx(Rtmp,    32, Rtmp2);
10855     __ or3 (Rtmp, Rtmp2, Rtmp);
10856     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10857     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10858   %}
10859   ins_pipe(ialu_reg);
10860 %}
10861 
10862 // Replicate scalar zero constant to packed int values in Double register
10863 instruct Repl2I_immI(regD dst, immI con, o7RegI tmp) %{
10864   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10865   match(Set dst (ReplicateI con));
10866   effect(KILL tmp);
10867   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2I($con)&quot; %}
10868   ins_encode %{
10869     // XXX This is a quick fix for 6833573.
10870     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 2, 4)), $dst$$FloatRegister);
10871     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 2, 4)), $tmp$$Register);
10872     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10873   %}
10874   ins_pipe(loadConFD);
10875 %}
10876 
10877 // Replicate scalar to packed float values into Double stack
10878 instruct Repl2F_stk(stackSlotD dst, regF src) %{
10879   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10880   match(Set dst (ReplicateF src));
10881   ins_cost(MEMORY_REF_COST*2);
10882   format %{ &quot;STF    $src,$dst.hi\t! packed2F\n\t&quot;
10883             &quot;STF    $src,$dst.lo&quot; %}
10884   opcode(Assembler::stf_op3);
10885   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, src));
10886   ins_pipe(fstoreF_stk_reg);
10887 %}
10888 
10889 // Replicate scalar zero constant to packed float values in Double register
10890 instruct Repl2F_immF(regD dst, immF con, o7RegI tmp) %{
10891   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10892   match(Set dst (ReplicateF con));
10893   effect(KILL tmp);
10894   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2F($con)&quot; %}
10895   ins_encode %{
10896     // XXX This is a quick fix for 6833573.
10897     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immF($con$$constant)), $dst$$FloatRegister);
10898     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immF($con$$constant)), $tmp$$Register);
10899     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10900   %}
10901   ins_pipe(loadConFD);
10902 %}
10903 
10904 //----------PEEPHOLE RULES-----------------------------------------------------
10905 // These must follow all instruction definitions as they use the names
10906 // defined in the instructions definitions.
10907 //
10908 // peepmatch ( root_instr_name [preceding_instruction]* );
10909 //
10910 // peepconstraint %{
10911 // (instruction_number.operand_name relational_op instruction_number.operand_name
10912 //  [, ...] );
10913 // // instruction numbers are zero-based using left to right order in peepmatch
10914 //
10915 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
10916 // // provide an instruction_number.operand_name for each operand that appears
10917 // // in the replacement instruction&#39;s match rule
10918 //
10919 // ---------VM FLAGS---------------------------------------------------------
10920 //
10921 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10922 //
10923 // Each peephole rule is given an identifying number starting with zero and
10924 // increasing by one in the order seen by the parser.  An individual peephole
10925 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10926 // on the command-line.
10927 //
10928 // ---------CURRENT LIMITATIONS----------------------------------------------
10929 //
10930 // Only match adjacent instructions in same basic block
10931 // Only equality constraints
10932 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10933 // Only one replacement instruction
10934 //
10935 // ---------EXAMPLE----------------------------------------------------------
10936 //
10937 // // pertinent parts of existing instructions in architecture description
10938 // instruct movI(eRegI dst, eRegI src) %{
10939 //   match(Set dst (CopyI src));
10940 // %}
10941 //
10942 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10943 //   match(Set dst (AddI dst src));
10944 //   effect(KILL cr);
10945 // %}
10946 //
10947 // // Change (inc mov) to lea
10948 // peephole %{
10949 //   // increment preceeded by register-register move
10950 //   peepmatch ( incI_eReg movI );
10951 //   // require that the destination register of the increment
10952 //   // match the destination register of the move
10953 //   peepconstraint ( 0.dst == 1.dst );
10954 //   // construct a replacement instruction that sets
10955 //   // the destination to ( move&#39;s source register + one )
10956 //   peepreplace ( incI_eReg_immI1( 0.dst 1.src 0.src ) );
10957 // %}
10958 //
10959 
10960 // // Change load of spilled value to only a spill
10961 // instruct storeI(memory mem, eRegI src) %{
10962 //   match(Set mem (StoreI mem src));
10963 // %}
10964 //
10965 // instruct loadI(eRegI dst, memory mem) %{
10966 //   match(Set dst (LoadI mem));
10967 // %}
10968 //
10969 // peephole %{
10970 //   peepmatch ( loadI storeI );
10971 //   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
10972 //   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
10973 // %}
10974 
10975 //----------SMARTSPILL RULES---------------------------------------------------
10976 // These must follow all instruction definitions as they use the names
10977 // defined in the instructions definitions.
10978 //
10979 // SPARC will probably not have any of these rules due to RISC instruction set.
10980 
10981 //----------PIPELINE-----------------------------------------------------------
10982 // Rules which define the behavior of the target architectures pipeline.
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
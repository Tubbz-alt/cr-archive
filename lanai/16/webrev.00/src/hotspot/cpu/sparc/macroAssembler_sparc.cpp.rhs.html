<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/accessDecorators.hpp&quot;
  36 #include &quot;oops/compressedOops.hpp&quot;
  37 #include &quot;oops/klass.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/flags/flagSetting.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/jniHandles.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.inline.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;utilities/align.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  51 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  52 #ifdef COMPILER2
  53 #include &quot;opto/intrinsicnode.hpp&quot;
  54 #endif
  55 
  56 #ifdef PRODUCT
  57 #define BLOCK_COMMENT(str) /* nothing */
  58 #define STOP(error) stop(error)
  59 #else
  60 #define BLOCK_COMMENT(str) block_comment(str)
  61 #define STOP(error) block_comment(error); stop(error)
  62 #endif
  63 
  64 // Convert the raw encoding form into the form expected by the
  65 // constructor for Address.
  66 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
  67   assert(scale == 0, &quot;not supported&quot;);
  68   RelocationHolder rspec;
  69   if (disp_reloc != relocInfo::none) {
  70     rspec = Relocation::spec_simple(disp_reloc);
  71   }
  72 
  73   Register rindex = as_Register(index);
  74   if (rindex != G0) {
  75     Address madr(as_Register(base), rindex);
  76     madr._rspec = rspec;
  77     return madr;
  78   } else {
  79     Address madr(as_Register(base), disp);
  80     madr._rspec = rspec;
  81     return madr;
  82   }
  83 }
  84 
  85 Address Argument::address_in_frame() const {
  86   // Warning: In LP64 mode disp will occupy more than 10 bits, but
  87   //          op codes such as ld or ldx, only access disp() to get
  88   //          their simm13 argument.
  89   int disp = ((_number - Argument::n_register_parameters + frame::memory_parameter_word_sp_offset) * BytesPerWord) + STACK_BIAS;
  90   if (is_in())
  91     return Address(FP, disp); // In argument.
  92   else
  93     return Address(SP, disp); // Out argument.
  94 }
  95 
  96 static const char* argumentNames[][2] = {
  97   {&quot;A0&quot;,&quot;P0&quot;}, {&quot;A1&quot;,&quot;P1&quot;}, {&quot;A2&quot;,&quot;P2&quot;}, {&quot;A3&quot;,&quot;P3&quot;}, {&quot;A4&quot;,&quot;P4&quot;},
  98   {&quot;A5&quot;,&quot;P5&quot;}, {&quot;A6&quot;,&quot;P6&quot;}, {&quot;A7&quot;,&quot;P7&quot;}, {&quot;A8&quot;,&quot;P8&quot;}, {&quot;A9&quot;,&quot;P9&quot;},
  99   {&quot;A(n&gt;9)&quot;,&quot;P(n&gt;9)&quot;}
 100 };
 101 
 102 const char* Argument::name() const {
 103   int nofArgs = sizeof argumentNames / sizeof argumentNames[0];
 104   int num = number();
 105   if (num &gt;= nofArgs)  num = nofArgs - 1;
 106   return argumentNames[num][is_in() ? 1 : 0];
 107 }
 108 
 109 #ifdef ASSERT
 110 // On RISC, there&#39;s no benefit to verifying instruction boundaries.
 111 bool AbstractAssembler::pd_check_instruction_mark() { return false; }
 112 #endif
 113 
 114 // Patch instruction inst at offset inst_pos to refer to dest_pos
 115 // and return the resulting instruction.
 116 // We should have pcs, not offsets, but since all is relative, it will work out
 117 // OK.
 118 int MacroAssembler::patched_branch(int dest_pos, int inst, int inst_pos) {
 119   int m; // mask for displacement field
 120   int v; // new value for displacement field
 121   const int word_aligned_ones = -4;
 122   switch (inv_op(inst)) {
 123   default: ShouldNotReachHere();
 124   case call_op:    m = wdisp(word_aligned_ones, 0, 30);  v = wdisp(dest_pos, inst_pos, 30); break;
 125   case branch_op:
 126     switch (inv_op2(inst)) {
 127       case fbp_op2:    m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 128       case bp_op2:     m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 129       case fb_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 130       case br_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 131       case bpr_op2: {
 132         if (is_cbcond(inst)) {
 133           m = wdisp10(word_aligned_ones, 0);
 134           v = wdisp10(dest_pos, inst_pos);
 135         } else {
 136           m = wdisp16(word_aligned_ones, 0);
 137           v = wdisp16(dest_pos, inst_pos);
 138         }
 139         break;
 140       }
 141       default: ShouldNotReachHere();
 142     }
 143   }
 144   return  inst &amp; ~m  |  v;
 145 }
 146 
 147 // Return the offset of the branch destionation of instruction inst
 148 // at offset pos.
 149 // Should have pcs, but since all is relative, it works out.
 150 int MacroAssembler::branch_destination(int inst, int pos) {
 151   int r;
 152   switch (inv_op(inst)) {
 153   default: ShouldNotReachHere();
 154   case call_op:        r = inv_wdisp(inst, pos, 30);  break;
 155   case branch_op:
 156     switch (inv_op2(inst)) {
 157       case fbp_op2:    r = inv_wdisp(  inst, pos, 19);  break;
 158       case bp_op2:     r = inv_wdisp(  inst, pos, 19);  break;
 159       case fb_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 160       case br_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 161       case bpr_op2: {
 162         if (is_cbcond(inst)) {
 163           r = inv_wdisp10(inst, pos);
 164         } else {
 165           r = inv_wdisp16(inst, pos);
 166         }
 167         break;
 168       }
 169       default: ShouldNotReachHere();
 170     }
 171   }
 172   return r;
 173 }
 174 
 175 void MacroAssembler::resolve_jobject(Register value, Register tmp) {
 176   Label done, not_weak;
 177   br_null(value, false, Assembler::pn, done); // Use NULL as-is.
 178   delayed()-&gt;andcc(value, JNIHandles::weak_tag_mask, G0); // Test for jweak
 179   brx(Assembler::zero, true, Assembler::pt, not_weak);
 180   delayed()-&gt;nop();
 181   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 182                  Address(value, -JNIHandles::weak_tag_value), value, tmp);
 183   verify_oop(value);
 184   br (Assembler::always, true, Assembler::pt, done);
 185   delayed()-&gt;nop();
 186   bind(not_weak);
 187   access_load_at(T_OBJECT, IN_NATIVE, Address(value, 0), value, tmp);
 188   verify_oop(value);
 189   bind(done);
 190 }
 191 
 192 void MacroAssembler::null_check(Register reg, int offset) {
 193   if (needs_explicit_null_check((intptr_t)offset)) {
 194     // provoke OS NULL exception if reg = NULL by
 195     // accessing M[reg] w/o changing any registers
 196     ld_ptr(reg, 0, G0);
 197   }
 198   else {
 199     // nothing to do, (later) access of M[reg + offset]
 200     // will provoke OS NULL exception if reg = NULL
 201   }
 202 }
 203 
 204 // Ring buffer jumps
 205 
 206 
 207 void MacroAssembler::jmp2(Register r1, Register r2, const char* file, int line ) {
 208   assert_not_delayed();
 209   jmpl(r1, r2, G0);
 210 }
 211 void MacroAssembler::jmp(Register r1, int offset, const char* file, int line ) {
 212   assert_not_delayed();
 213   jmp(r1, offset);
 214 }
 215 
 216 // This code sequence is relocatable to any address, even on LP64.
 217 void MacroAssembler::jumpl(const AddressLiteral&amp; addrlit, Register temp, Register d, int offset, const char* file, int line) {
 218   assert_not_delayed();
 219   // Force fixed length sethi because NativeJump and NativeFarCall don&#39;t handle
 220   // variable length instruction streams.
 221   patchable_sethi(addrlit, temp);
 222   Address a(temp, addrlit.low10() + offset);  // Add the offset to the displacement.
 223   jmpl(a.base(), a.disp(), d);
 224 }
 225 
 226 void MacroAssembler::jump(const AddressLiteral&amp; addrlit, Register temp, int offset, const char* file, int line) {
 227   jumpl(addrlit, temp, G0, offset, file, line);
 228 }
 229 
 230 
 231 // Conditional breakpoint (for assertion checks in assembly code)
 232 void MacroAssembler::breakpoint_trap(Condition c, CC cc) {
 233   trap(c, cc, G0, ST_RESERVED_FOR_USER_0);
 234 }
 235 
 236 // We want to use ST_BREAKPOINT here, but the debugger is confused by it.
 237 void MacroAssembler::breakpoint_trap() {
 238   trap(ST_RESERVED_FOR_USER_0);
 239 }
 240 
 241 void MacroAssembler::safepoint_poll(Label&amp; slow_path, bool a, Register thread_reg, Register temp_reg) {
 242   if (SafepointMechanism::uses_thread_local_poll()) {
 243     ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);
 244     // Armed page has poll bit set.
 245     and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);
 246     br_notnull(temp_reg, a, Assembler::pn, slow_path);
 247   } else {
 248     AddressLiteral sync_state(SafepointSynchronize::address_of_state());
 249 
 250     load_contents(sync_state, temp_reg);
 251     cmp(temp_reg, SafepointSynchronize::_not_synchronized);
 252     br(Assembler::notEqual, a, Assembler::pn, slow_path);
 253   }
 254 }
 255 
 256 void MacroAssembler::enter() {
 257   Unimplemented();
 258 }
 259 
 260 void MacroAssembler::leave() {
 261   Unimplemented();
 262 }
 263 
 264 // Calls to C land
 265 
 266 #ifdef ASSERT
 267 // a hook for debugging
 268 static Thread* reinitialize_thread() {
 269   return Thread::current();
 270 }
 271 #else
 272 #define reinitialize_thread Thread::current
 273 #endif
 274 
 275 #ifdef ASSERT
 276 address last_get_thread = NULL;
 277 #endif
 278 
 279 // call this when G2_thread is not known to be valid
 280 void MacroAssembler::get_thread() {
 281   save_frame(0);                // to avoid clobbering O0
 282   mov(G1, L0);                  // avoid clobbering G1
 283   mov(G5_method, L1);           // avoid clobbering G5
 284   mov(G3, L2);                  // avoid clobbering G3 also
 285   mov(G4, L5);                  // avoid clobbering G4
 286 #ifdef ASSERT
 287   AddressLiteral last_get_thread_addrlit(&amp;last_get_thread);
 288   set(last_get_thread_addrlit, L3);
 289   rdpc(L4);
 290   inc(L4, 3 * BytesPerInstWord); // skip rdpc + inc + st_ptr to point L4 at call  st_ptr(L4, L3, 0);
 291 #endif
 292   call(CAST_FROM_FN_PTR(address, reinitialize_thread), relocInfo::runtime_call_type);
 293   delayed()-&gt;nop();
 294   mov(L0, G1);
 295   mov(L1, G5_method);
 296   mov(L2, G3);
 297   mov(L5, G4);
 298   restore(O0, 0, G2_thread);
 299 }
 300 
 301 static Thread* verify_thread_subroutine(Thread* gthread_value) {
 302   Thread* correct_value = Thread::current();
 303   guarantee(gthread_value == correct_value, &quot;G2_thread value must be the thread&quot;);
 304   return correct_value;
 305 }
 306 
 307 void MacroAssembler::verify_thread() {
 308   if (VerifyThread) {
 309     // NOTE: this chops off the heads of the 64-bit O registers.
 310     // make sure G2_thread contains the right value
 311     save_frame_and_mov(0, Lmethod, Lmethod);   // to avoid clobbering O0 (and propagate Lmethod)
 312     mov(G1, L1);                // avoid clobbering G1
 313     // G2 saved below
 314     mov(G3, L3);                // avoid clobbering G3
 315     mov(G4, L4);                // avoid clobbering G4
 316     mov(G5_method, L5);         // avoid clobbering G5_method
 317     call(CAST_FROM_FN_PTR(address,verify_thread_subroutine), relocInfo::runtime_call_type);
 318     delayed()-&gt;mov(G2_thread, O0);
 319 
 320     mov(L1, G1);                // Restore G1
 321     // G2 restored below
 322     mov(L3, G3);                // restore G3
 323     mov(L4, G4);                // restore G4
 324     mov(L5, G5_method);         // restore G5_method
 325     restore(O0, 0, G2_thread);
 326   }
 327 }
 328 
 329 
 330 void MacroAssembler::save_thread(const Register thread_cache) {
 331   verify_thread();
 332   if (thread_cache-&gt;is_valid()) {
 333     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 334     mov(G2_thread, thread_cache);
 335   }
 336   if (VerifyThread) {
 337     // smash G2_thread, as if the VM were about to anyway
 338     set(0x67676767, G2_thread);
 339   }
 340 }
 341 
 342 
 343 void MacroAssembler::restore_thread(const Register thread_cache) {
 344   if (thread_cache-&gt;is_valid()) {
 345     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 346     mov(thread_cache, G2_thread);
 347     verify_thread();
 348   } else {
 349     // do it the slow way
 350     get_thread();
 351   }
 352 }
 353 
 354 
 355 // %%% maybe get rid of [re]set_last_Java_frame
 356 void MacroAssembler::set_last_Java_frame(Register last_java_sp, Register last_Java_pc) {
 357   assert_not_delayed();
 358   Address flags(G2_thread, JavaThread::frame_anchor_offset() +
 359                            JavaFrameAnchor::flags_offset());
 360   Address pc_addr(G2_thread, JavaThread::last_Java_pc_offset());
 361 
 362   // Always set last_Java_pc and flags first because once last_Java_sp is visible
 363   // has_last_Java_frame is true and users will look at the rest of the fields.
 364   // (Note: flags should always be zero before we get here so doesn&#39;t need to be set.)
 365 
 366 #ifdef ASSERT
 367   // Verify that flags was zeroed on return to Java
 368   Label PcOk;
 369   save_frame(0);                // to avoid clobbering O0
 370   ld_ptr(pc_addr, L0);
 371   br_null_short(L0, Assembler::pt, PcOk);
 372   STOP(&quot;last_Java_pc not zeroed before leaving Java&quot;);
 373   bind(PcOk);
 374 
 375   // Verify that flags was zeroed on return to Java
 376   Label FlagsOk;
 377   ld(flags, L0);
 378   tst(L0);
 379   br(Assembler::zero, false, Assembler::pt, FlagsOk);
 380   delayed() -&gt; restore();
 381   STOP(&quot;flags not zeroed before leaving Java&quot;);
 382   bind(FlagsOk);
 383 #endif /* ASSERT */
 384   //
 385   // When returning from calling out from Java mode the frame anchor&#39;s last_Java_pc
 386   // will always be set to NULL. It is set here so that if we are doing a call to
 387   // native (not VM) that we capture the known pc and don&#39;t have to rely on the
 388   // native call having a standard frame linkage where we can find the pc.
 389 
 390   if (last_Java_pc-&gt;is_valid()) {
 391     st_ptr(last_Java_pc, pc_addr);
 392   }
 393 
 394 #ifdef ASSERT
 395   // Make sure that we have an odd stack
 396   Label StackOk;
 397   andcc(last_java_sp, 0x01, G0);
 398   br(Assembler::notZero, false, Assembler::pt, StackOk);
 399   delayed()-&gt;nop();
 400   STOP(&quot;Stack Not Biased in set_last_Java_frame&quot;);
 401   bind(StackOk);
 402 #endif // ASSERT
 403   assert( last_java_sp != G4_scratch, &quot;bad register usage in set_last_Java_frame&quot;);
 404   add( last_java_sp, STACK_BIAS, G4_scratch );
 405   st_ptr(G4_scratch, G2_thread, JavaThread::last_Java_sp_offset());
 406 }
 407 
 408 void MacroAssembler::reset_last_Java_frame(void) {
 409   assert_not_delayed();
 410 
 411   Address sp_addr(G2_thread, JavaThread::last_Java_sp_offset());
 412   Address pc_addr(G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 413   Address flags  (G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::flags_offset());
 414 
 415 #ifdef ASSERT
 416   // check that it WAS previously set
 417     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod to helper frame
 418     ld_ptr(sp_addr, L0);
 419     tst(L0);
 420     breakpoint_trap(Assembler::zero, Assembler::ptr_cc);
 421     restore();
 422 #endif // ASSERT
 423 
 424   st_ptr(G0, sp_addr);
 425   // Always return last_Java_pc to zero
 426   st_ptr(G0, pc_addr);
 427   // Always null flags after return to Java
 428   st(G0, flags);
 429 }
 430 
 431 
 432 void MacroAssembler::call_VM_base(
 433   Register        oop_result,
 434   Register        thread_cache,
 435   Register        last_java_sp,
 436   address         entry_point,
 437   int             number_of_arguments,
 438   bool            check_exceptions)
 439 {
 440   assert_not_delayed();
 441 
 442   // determine last_java_sp register
 443   if (!last_java_sp-&gt;is_valid()) {
 444     last_java_sp = SP;
 445   }
 446   // debugging support
 447   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 448 
 449   // 64-bit last_java_sp is biased!
 450   set_last_Java_frame(last_java_sp, noreg);
 451   if (VerifyThread)  mov(G2_thread, O0); // about to be smashed; pass early
 452   save_thread(thread_cache);
 453   // do the call
 454   call(entry_point, relocInfo::runtime_call_type);
 455   if (!VerifyThread)
 456     delayed()-&gt;mov(G2_thread, O0);  // pass thread as first argument
 457   else
 458     delayed()-&gt;nop();             // (thread already passed)
 459   restore_thread(thread_cache);
 460   reset_last_Java_frame();
 461 
 462   // check for pending exceptions. use Gtemp as scratch register.
 463   if (check_exceptions) {
 464     check_and_forward_exception(Gtemp);
 465   }
 466 
 467 #ifdef ASSERT
 468   set(badHeapWordVal, G3);
 469   set(badHeapWordVal, G4);
 470   set(badHeapWordVal, G5);
 471 #endif
 472 
 473   // get oop result if there is one and reset the value in the thread
 474   if (oop_result-&gt;is_valid()) {
 475     get_vm_result(oop_result);
 476   }
 477 }
 478 
 479 void MacroAssembler::check_and_forward_exception(Register scratch_reg)
 480 {
 481   Label L;
 482 
 483   check_and_handle_popframe(scratch_reg);
 484   check_and_handle_earlyret(scratch_reg);
 485 
 486   Address exception_addr(G2_thread, Thread::pending_exception_offset());
 487   ld_ptr(exception_addr, scratch_reg);
 488   br_null_short(scratch_reg, pt, L);
 489   // we use O7 linkage so that forward_exception_entry has the issuing PC
 490   call(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
 491   delayed()-&gt;nop();
 492   bind(L);
 493 }
 494 
 495 
 496 void MacroAssembler::check_and_handle_popframe(Register scratch_reg) {
 497 }
 498 
 499 
 500 void MacroAssembler::check_and_handle_earlyret(Register scratch_reg) {
 501 }
 502 
 503 
 504 void MacroAssembler::call_VM(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 505   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 506 }
 507 
 508 
 509 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions) {
 510   // O0 is reserved for the thread
 511   mov(arg_1, O1);
 512   call_VM(oop_result, entry_point, 1, check_exceptions);
 513 }
 514 
 515 
 516 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 517   // O0 is reserved for the thread
 518   mov(arg_1, O1);
 519   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 520   call_VM(oop_result, entry_point, 2, check_exceptions);
 521 }
 522 
 523 
 524 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 525   // O0 is reserved for the thread
 526   mov(arg_1, O1);
 527   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 528   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 529   call_VM(oop_result, entry_point, 3, check_exceptions);
 530 }
 531 
 532 
 533 
 534 // Note: The following call_VM overloadings are useful when a &quot;save&quot;
 535 // has already been performed by a stub, and the last Java frame is
 536 // the previous one.  In that case, last_java_sp must be passed as FP
 537 // instead of SP.
 538 
 539 
 540 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments, bool check_exceptions) {
 541   call_VM_base(oop_result, noreg, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 542 }
 543 
 544 
 545 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions) {
 546   // O0 is reserved for the thread
 547   mov(arg_1, O1);
 548   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 549 }
 550 
 551 
 552 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 553   // O0 is reserved for the thread
 554   mov(arg_1, O1);
 555   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 556   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 557 }
 558 
 559 
 560 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 561   // O0 is reserved for the thread
 562   mov(arg_1, O1);
 563   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 564   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 565   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 566 }
 567 
 568 
 569 
 570 void MacroAssembler::call_VM_leaf_base(Register thread_cache, address entry_point, int number_of_arguments) {
 571   assert_not_delayed();
 572   save_thread(thread_cache);
 573   // do the call
 574   call(entry_point, relocInfo::runtime_call_type);
 575   delayed()-&gt;nop();
 576   restore_thread(thread_cache);
 577 #ifdef ASSERT
 578   set(badHeapWordVal, G3);
 579   set(badHeapWordVal, G4);
 580   set(badHeapWordVal, G5);
 581 #endif
 582 }
 583 
 584 
 585 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, int number_of_arguments) {
 586   call_VM_leaf_base(thread_cache, entry_point, number_of_arguments);
 587 }
 588 
 589 
 590 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1) {
 591   mov(arg_1, O0);
 592   call_VM_leaf(thread_cache, entry_point, 1);
 593 }
 594 
 595 
 596 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2) {
 597   mov(arg_1, O0);
 598   mov(arg_2, O1); assert(arg_2 != O0, &quot;smashed argument&quot;);
 599   call_VM_leaf(thread_cache, entry_point, 2);
 600 }
 601 
 602 
 603 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2, Register arg_3) {
 604   mov(arg_1, O0);
 605   mov(arg_2, O1); assert(arg_2 != O0,                &quot;smashed argument&quot;);
 606   mov(arg_3, O2); assert(arg_3 != O0 &amp;&amp; arg_3 != O1, &quot;smashed argument&quot;);
 607   call_VM_leaf(thread_cache, entry_point, 3);
 608 }
 609 
 610 
 611 void MacroAssembler::get_vm_result(Register oop_result) {
 612   verify_thread();
 613   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 614   ld_ptr(    vm_result_addr, oop_result);
 615   st_ptr(G0, vm_result_addr);
 616   verify_oop(oop_result);
 617 }
 618 
 619 
 620 void MacroAssembler::get_vm_result_2(Register metadata_result) {
 621   verify_thread();
 622   Address vm_result_addr_2(G2_thread, JavaThread::vm_result_2_offset());
 623   ld_ptr(vm_result_addr_2, metadata_result);
 624   st_ptr(G0, vm_result_addr_2);
 625 }
 626 
 627 
 628 // We require that C code which does not return a value in vm_result will
 629 // leave it undisturbed.
 630 void MacroAssembler::set_vm_result(Register oop_result) {
 631   verify_thread();
 632   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 633   verify_oop(oop_result);
 634 
 635 # ifdef ASSERT
 636     // Check that we are not overwriting any other oop.
 637     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod
 638     ld_ptr(vm_result_addr, L0);
 639     tst(L0);
 640     restore();
 641     breakpoint_trap(notZero, Assembler::ptr_cc);
 642     // }
 643 # endif
 644 
 645   st_ptr(oop_result, vm_result_addr);
 646 }
 647 
 648 
 649 void MacroAssembler::ic_call(address entry, bool emit_delay, jint method_index) {
 650   RelocationHolder rspec = virtual_call_Relocation::spec(pc(), method_index);
 651   patchable_set((intptr_t)Universe::non_oop_word(), G5_inline_cache_reg);
 652   relocate(rspec);
 653   call(entry, relocInfo::none);
 654   if (emit_delay) {
 655     delayed()-&gt;nop();
 656   }
 657 }
 658 
 659 
 660 void MacroAssembler::internal_sethi(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 661   address save_pc;
 662   int shiftcnt;
 663 #ifdef VALIDATE_PIPELINE
 664   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 665 #endif
 666   v9_dep();
 667   save_pc = pc();
 668 
 669   int msb32 = (int) (addrlit.value() &gt;&gt; 32);
 670   int lsb32 = (int) (addrlit.value());
 671 
 672   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0) {
 673     Assembler::sethi(lsb32, d, addrlit.rspec());
 674   }
 675   else if (msb32 == -1) {
 676     Assembler::sethi(~lsb32, d, addrlit.rspec());
 677     xor3(d, ~low10(~0), d);
 678   }
 679   else {
 680     Assembler::sethi(msb32, d, addrlit.rspec());  // msb 22-bits
 681     if (msb32 &amp; 0x3ff)                            // Any bits?
 682       or3(d, msb32 &amp; 0x3ff, d);                   // msb 32-bits are now in lsb 32
 683     if (lsb32 &amp; 0xFFFFFC00) {                     // done?
 684       if ((lsb32 &gt;&gt; 20) &amp; 0xfff) {                // Any bits set?
 685         sllx(d, 12, d);                           // Make room for next 12 bits
 686         or3(d, (lsb32 &gt;&gt; 20) &amp; 0xfff, d);         // Or in next 12
 687         shiftcnt = 0;                             // We already shifted
 688       }
 689       else
 690         shiftcnt = 12;
 691       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff) {
 692         sllx(d, shiftcnt + 10, d);                // Make room for last 10 bits
 693         or3(d, (lsb32 &gt;&gt; 10) &amp; 0x3ff, d);         // Or in next 10
 694         shiftcnt = 0;
 695       }
 696       else
 697         shiftcnt = 10;
 698       sllx(d, shiftcnt + 10, d);                  // Shift leaving disp field 0&#39;d
 699     }
 700     else
 701       sllx(d, 32, d);
 702   }
 703   // Pad out the instruction sequence so it can be patched later.
 704   if (ForceRelocatable || (addrlit.rtype() != relocInfo::none &amp;&amp;
 705                            addrlit.rtype() != relocInfo::runtime_call_type)) {
 706     while (pc() &lt; (save_pc + (7 * BytesPerInstWord)))
 707       nop();
 708   }
 709 }
 710 
 711 
 712 void MacroAssembler::sethi(const AddressLiteral&amp; addrlit, Register d) {
 713   internal_sethi(addrlit, d, false);
 714 }
 715 
 716 
 717 void MacroAssembler::patchable_sethi(const AddressLiteral&amp; addrlit, Register d) {
 718   internal_sethi(addrlit, d, true);
 719 }
 720 
 721 
 722 int MacroAssembler::insts_for_sethi(address a, bool worst_case) {
 723   if (worst_case)  return 7;
 724   intptr_t iaddr = (intptr_t) a;
 725   int msb32 = (int) (iaddr &gt;&gt; 32);
 726   int lsb32 = (int) (iaddr);
 727   int count;
 728   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0)
 729     count = 1;
 730   else if (msb32 == -1)
 731     count = 2;
 732   else {
 733     count = 2;
 734     if (msb32 &amp; 0x3ff)
 735       count++;
 736     if (lsb32 &amp; 0xFFFFFC00 ) {
 737       if ((lsb32 &gt;&gt; 20) &amp; 0xfff)  count += 2;
 738       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff)  count += 2;
 739     }
 740   }
 741   return count;
 742 }
 743 
 744 int MacroAssembler::worst_case_insts_for_set() {
 745   return insts_for_sethi(NULL, true) + 1;
 746 }
 747 
 748 
 749 // Keep in sync with MacroAssembler::insts_for_internal_set
 750 void MacroAssembler::internal_set(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 751   intptr_t value = addrlit.value();
 752 
 753   if (!ForceRelocatable &amp;&amp; addrlit.rspec().type() == relocInfo::none) {
 754     // can optimize
 755     if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 756       or3(G0, value, d); // setsw (this leaves upper 32 bits sign-extended)
 757       return;
 758     }
 759     if (inv_hi22(hi22(value)) == value) {
 760       sethi(addrlit, d);
 761       return;
 762     }
 763   }
 764   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 765   internal_sethi(addrlit, d, ForceRelocatable);
 766   if (ForceRelocatable || addrlit.rspec().type() != relocInfo::none || addrlit.low10() != 0) {
 767     add(d, addrlit.low10(), d, addrlit.rspec());
 768   }
 769 }
 770 
 771 // Keep in sync with MacroAssembler::internal_set
 772 int MacroAssembler::insts_for_internal_set(intptr_t value) {
 773   // can optimize
 774   if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 775     return 1;
 776   }
 777   if (inv_hi22(hi22(value)) == value) {
 778     return insts_for_sethi((address) value);
 779   }
 780   int count = insts_for_sethi((address) value);
 781   AddressLiteral al(value);
 782   if (al.low10() != 0) {
 783     count++;
 784   }
 785   return count;
 786 }
 787 
 788 void MacroAssembler::set(const AddressLiteral&amp; al, Register d) {
 789   internal_set(al, d, false);
 790 }
 791 
 792 void MacroAssembler::set(intptr_t value, Register d) {
 793   AddressLiteral al(value);
 794   internal_set(al, d, false);
 795 }
 796 
 797 void MacroAssembler::set(address addr, Register d, RelocationHolder const&amp; rspec) {
 798   AddressLiteral al(addr, rspec);
 799   internal_set(al, d, false);
 800 }
 801 
 802 void MacroAssembler::patchable_set(const AddressLiteral&amp; al, Register d) {
 803   internal_set(al, d, true);
 804 }
 805 
 806 void MacroAssembler::patchable_set(intptr_t value, Register d) {
 807   AddressLiteral al(value);
 808   internal_set(al, d, true);
 809 }
 810 
 811 
 812 void MacroAssembler::set64(jlong value, Register d, Register tmp) {
 813   assert_not_delayed();
 814   v9_dep();
 815 
 816   int hi = (int)(value &gt;&gt; 32);
 817   int lo = (int)(value &amp; ~0);
 818   int bits_33to2 = (int)((value &gt;&gt; 2) &amp; ~0);
 819   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 820   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 821     or3(G0, lo, d);
 822   } else if (hi == 0) {
 823     Assembler::sethi(lo, d);   // hardware version zero-extends to upper 32
 824     if (low10(lo) != 0)
 825       or3(d, low10(lo), d);
 826   }
 827   else if ((hi &gt;&gt; 2) == 0) {
 828     Assembler::sethi(bits_33to2, d);  // hardware version zero-extends to upper 32
 829     sllx(d, 2, d);
 830     if (low12(lo) != 0)
 831       or3(d, low12(lo), d);
 832   }
 833   else if (hi == -1) {
 834     Assembler::sethi(~lo, d);  // hardware version zero-extends to upper 32
 835     xor3(d, low10(lo) ^ ~low10(~0), d);
 836   }
 837   else if (lo == 0) {
 838     if (Assembler::is_simm13(hi)) {
 839       or3(G0, hi, d);
 840     } else {
 841       Assembler::sethi(hi, d);   // hardware version zero-extends to upper 32
 842       if (low10(hi) != 0)
 843         or3(d, low10(hi), d);
 844     }
 845     sllx(d, 32, d);
 846   }
 847   else {
 848     Assembler::sethi(hi, tmp);
 849     Assembler::sethi(lo,   d); // macro assembler version sign-extends
 850     if (low10(hi) != 0)
 851       or3 (tmp, low10(hi), tmp);
 852     if (low10(lo) != 0)
 853       or3 (  d, low10(lo),   d);
 854     sllx(tmp, 32, tmp);
 855     or3 (d, tmp, d);
 856   }
 857 }
 858 
 859 int MacroAssembler::insts_for_set64(jlong value) {
 860   v9_dep();
 861 
 862   int hi = (int) (value &gt;&gt; 32);
 863   int lo = (int) (value &amp; ~0);
 864   int count = 0;
 865 
 866   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 867   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 868     count++;
 869   } else if (hi == 0) {
 870     count++;
 871     if (low10(lo) != 0)
 872       count++;
 873   }
 874   else if (hi == -1) {
 875     count += 2;
 876   }
 877   else if (lo == 0) {
 878     if (Assembler::is_simm13(hi)) {
 879       count++;
 880     } else {
 881       count++;
 882       if (low10(hi) != 0)
 883         count++;
 884     }
 885     count++;
 886   }
 887   else {
 888     count += 2;
 889     if (low10(hi) != 0)
 890       count++;
 891     if (low10(lo) != 0)
 892       count++;
 893     count += 2;
 894   }
 895   return count;
 896 }
 897 
 898 // compute size in bytes of sparc frame, given
 899 // number of extraWords
 900 int MacroAssembler::total_frame_size_in_bytes(int extraWords) {
 901 
 902   int nWords = frame::memory_parameter_word_sp_offset;
 903 
 904   nWords += extraWords;
 905 
 906   if (nWords &amp; 1) ++nWords; // round up to double-word
 907 
 908   return nWords * BytesPerWord;
 909 }
 910 
 911 
 912 // save_frame: given number of &quot;extra&quot; words in frame,
 913 // issue approp. save instruction (p 200, v8 manual)
 914 
 915 void MacroAssembler::save_frame(int extraWords) {
 916   int delta = -total_frame_size_in_bytes(extraWords);
 917   if (is_simm13(delta)) {
 918     save(SP, delta, SP);
 919   } else {
 920     set(delta, G3_scratch);
 921     save(SP, G3_scratch, SP);
 922   }
 923 }
 924 
 925 
 926 void MacroAssembler::save_frame_c1(int size_in_bytes) {
 927   if (is_simm13(-size_in_bytes)) {
 928     save(SP, -size_in_bytes, SP);
 929   } else {
 930     set(-size_in_bytes, G3_scratch);
 931     save(SP, G3_scratch, SP);
 932   }
 933 }
 934 
 935 
 936 void MacroAssembler::save_frame_and_mov(int extraWords,
 937                                         Register s1, Register d1,
 938                                         Register s2, Register d2) {
 939   assert_not_delayed();
 940 
 941   // The trick here is to use precisely the same memory word
 942   // that trap handlers also use to save the register.
 943   // This word cannot be used for any other purpose, but
 944   // it works fine to save the register&#39;s value, whether or not
 945   // an interrupt flushes register windows at any given moment!
 946   Address s1_addr;
 947   if (s1-&gt;is_valid() &amp;&amp; (s1-&gt;is_in() || s1-&gt;is_local())) {
 948     s1_addr = s1-&gt;address_in_saved_window();
 949     st_ptr(s1, s1_addr);
 950   }
 951 
 952   Address s2_addr;
 953   if (s2-&gt;is_valid() &amp;&amp; (s2-&gt;is_in() || s2-&gt;is_local())) {
 954     s2_addr = s2-&gt;address_in_saved_window();
 955     st_ptr(s2, s2_addr);
 956   }
 957 
 958   save_frame(extraWords);
 959 
 960   if (s1_addr.base() == SP) {
 961     ld_ptr(s1_addr.after_save(), d1);
 962   } else if (s1-&gt;is_valid()) {
 963     mov(s1-&gt;after_save(), d1);
 964   }
 965 
 966   if (s2_addr.base() == SP) {
 967     ld_ptr(s2_addr.after_save(), d2);
 968   } else if (s2-&gt;is_valid()) {
 969     mov(s2-&gt;after_save(), d2);
 970   }
 971 }
 972 
 973 
 974 AddressLiteral MacroAssembler::allocate_metadata_address(Metadata* obj) {
 975   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 976   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
 977   RelocationHolder rspec = metadata_Relocation::spec(index);
 978   return AddressLiteral((address)obj, rspec);
 979 }
 980 
 981 AddressLiteral MacroAssembler::constant_metadata_address(Metadata* obj) {
 982   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 983   int index = oop_recorder()-&gt;find_index(obj);
 984   RelocationHolder rspec = metadata_Relocation::spec(index);
 985   return AddressLiteral((address)obj, rspec);
 986 }
 987 
 988 
 989 AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
 990 #ifdef ASSERT
 991   {
 992     ThreadInVMfromUnknown tiv;
 993     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 994     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
 995   }
 996 #endif
 997   int oop_index = oop_recorder()-&gt;find_index(obj);
 998   return AddressLiteral(obj, oop_Relocation::spec(oop_index));
 999 }
1000 
1001 void  MacroAssembler::set_narrow_oop(jobject obj, Register d) {
1002   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1003   int oop_index = oop_recorder()-&gt;find_index(obj);
1004   RelocationHolder rspec = oop_Relocation::spec(oop_index);
1005 
1006   assert_not_delayed();
1007   // Relocation with special format (see relocInfo_sparc.hpp).
1008   relocate(rspec, 1);
1009   // Assembler::sethi(0x3fffff, d);
1010   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(0x3fffff) );
1011   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1012   add(d, 0x3ff, d);
1013 
1014 }
1015 
1016 void  MacroAssembler::set_narrow_klass(Klass* k, Register d) {
1017   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1018   int klass_index = oop_recorder()-&gt;find_index(k);
1019   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
1020   narrowOop encoded_k = CompressedKlassPointers::encode(k);
1021 
1022   assert_not_delayed();
1023   // Relocation with special format (see relocInfo_sparc.hpp).
1024   relocate(rspec, 1);
1025   // Assembler::sethi(encoded_k, d);
1026   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(encoded_k) );
1027   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1028   add(d, low10(encoded_k), d);
1029 
1030 }
1031 
1032 void MacroAssembler::align(int modulus) {
1033   while (offset() % modulus != 0) nop();
1034 }
1035 
1036 void RegistersForDebugging::print(outputStream* s) {
1037   FlagSetting fs(Debugging, true);
1038   int j;
1039   for (j = 0; j &lt; 8; ++j) {
1040     if (j != 6) { s-&gt;print(&quot;i%d = &quot;, j); os::print_location(s, i[j]); }
1041     else        { s-&gt;print( &quot;fp = &quot;   ); os::print_location(s, i[j]); }
1042   }
1043   s-&gt;cr();
1044 
1045   for (j = 0;  j &lt; 8;  ++j) {
1046     s-&gt;print(&quot;l%d = &quot;, j); os::print_location(s, l[j]);
1047   }
1048   s-&gt;cr();
1049 
1050   for (j = 0; j &lt; 8; ++j) {
1051     if (j != 6) { s-&gt;print(&quot;o%d = &quot;, j); os::print_location(s, o[j]); }
1052     else        { s-&gt;print( &quot;sp = &quot;   ); os::print_location(s, o[j]); }
1053   }
1054   s-&gt;cr();
1055 
1056   for (j = 0; j &lt; 8; ++j) {
1057     s-&gt;print(&quot;g%d = &quot;, j); os::print_location(s, g[j]);
1058   }
1059   s-&gt;cr();
1060 
1061   // print out floats with compression
1062   for (j = 0; j &lt; 32; ) {
1063     jfloat val = f[j];
1064     int last = j;
1065     for ( ;  last+1 &lt; 32;  ++last ) {
1066       char b1[1024], b2[1024];
1067       sprintf(b1, &quot;%f&quot;, val);
1068       sprintf(b2, &quot;%f&quot;, f[last+1]);
1069       if (strcmp(b1, b2))
1070         break;
1071     }
1072     s-&gt;print(&quot;f%d&quot;, j);
1073     if ( j != last )  s-&gt;print(&quot; - f%d&quot;, last);
1074     s-&gt;print(&quot; = %f&quot;, val);
1075     s-&gt;fill_to(25);
1076     s-&gt;print_cr(&quot; (0x%x)&quot;, *(int*)&amp;val);
1077     j = last + 1;
1078   }
1079   s-&gt;cr();
1080 
1081   // and doubles (evens only)
1082   for (j = 0; j &lt; 32; ) {
1083     jdouble val = d[j];
1084     int last = j;
1085     for ( ;  last+1 &lt; 32;  ++last ) {
1086       char b1[1024], b2[1024];
1087       sprintf(b1, &quot;%f&quot;, val);
1088       sprintf(b2, &quot;%f&quot;, d[last+1]);
1089       if (strcmp(b1, b2))
1090         break;
1091     }
1092     s-&gt;print(&quot;d%d&quot;, 2 * j);
1093     if ( j != last )  s-&gt;print(&quot; - d%d&quot;, last);
1094     s-&gt;print(&quot; = %f&quot;, val);
1095     s-&gt;fill_to(30);
1096     s-&gt;print(&quot;(0x%x)&quot;, *(int*)&amp;val);
1097     s-&gt;fill_to(42);
1098     s-&gt;print_cr(&quot;(0x%x)&quot;, *(1 + (int*)&amp;val));
1099     j = last + 1;
1100   }
1101   s-&gt;cr();
1102 }
1103 
1104 void RegistersForDebugging::save_registers(MacroAssembler* a) {
1105   a-&gt;sub(FP, align_up(sizeof(RegistersForDebugging), sizeof(jdouble)) - STACK_BIAS, O0);
1106   a-&gt;flushw();
1107   int i;
1108   for (i = 0; i &lt; 8; ++i) {
1109     a-&gt;ld_ptr(as_iRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, i_offset(i));
1110     a-&gt;ld_ptr(as_lRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, l_offset(i));
1111     a-&gt;st_ptr(as_oRegister(i)-&gt;after_save(), O0, o_offset(i));
1112     a-&gt;st_ptr(as_gRegister(i)-&gt;after_save(), O0, g_offset(i));
1113   }
1114   for (i = 0;  i &lt; 32; ++i) {
1115     a-&gt;stf(FloatRegisterImpl::S, as_FloatRegister(i), O0, f_offset(i));
1116   }
1117   for (i = 0; i &lt; 64; i += 2) {
1118     a-&gt;stf(FloatRegisterImpl::D, as_FloatRegister(i), O0, d_offset(i));
1119   }
1120 }
1121 
1122 void RegistersForDebugging::restore_registers(MacroAssembler* a, Register r) {
1123   for (int i = 1; i &lt; 8;  ++i) {
1124     a-&gt;ld_ptr(r, g_offset(i), as_gRegister(i));
1125   }
1126   for (int j = 0; j &lt; 32; ++j) {
1127     a-&gt;ldf(FloatRegisterImpl::S, O0, f_offset(j), as_FloatRegister(j));
1128   }
1129   for (int k = 0; k &lt; 64; k += 2) {
1130     a-&gt;ldf(FloatRegisterImpl::D, O0, d_offset(k), as_FloatRegister(k));
1131   }
1132 }
1133 
1134 void MacroAssembler::_verify_oop(Register reg, const char* msg, const char * file, int line) {
1135   // plausibility check for oops
1136   if (!VerifyOops) return;
1137 
1138   if (reg == G0)  return;       // always NULL, which is always an oop
1139 
1140   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1141   char buffer[64];
1142 #ifdef COMPILER1
1143   if (CommentedAssembly) {
1144     snprintf(buffer, sizeof(buffer), &quot;verify_oop at %d&quot;, offset());
1145     block_comment(buffer);
1146   }
1147 #endif
1148 
1149   const char* real_msg = NULL;
1150   {
1151     ResourceMark rm;
1152     stringStream ss;
1153     ss.print(&quot;%s at offset %d (%s:%d)&quot;, msg, offset(), file, line);
1154     real_msg = code_string(ss.as_string());
1155   }
1156 
1157   // Call indirectly to solve generation ordering problem
1158   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1159 
1160   // Make some space on stack above the current register window.
1161   // Enough to hold 8 64-bit registers.
1162   add(SP,-8*8,SP);
1163 
1164   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1165   // of 64-bit longs in the 32-bit build.
1166   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1167   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1168   mov(reg,O0); // Move arg into O0; arg might be in O7 which is about to be crushed
1169   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1170 
1171   // Size of set() should stay the same
1172   patchable_set((intptr_t)real_msg, O1);
1173   // Load address to call to into O7
1174   load_ptr_contents(a, O7);
1175   // Register call to verify_oop_subroutine
1176   callr(O7, G0);
1177   delayed()-&gt;nop();
1178   // recover frame size
1179   add(SP, 8*8,SP);
1180   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1181 }
1182 
1183 void MacroAssembler::_verify_oop_addr(Address addr, const char* msg, const char * file, int line) {
1184   // plausibility check for oops
1185   if (!VerifyOops) return;
1186 
1187   const char* real_msg = NULL;
1188   {
1189     ResourceMark rm;
1190     stringStream ss;
1191     ss.print(&quot;%s at SP+%d (%s:%d)&quot;, msg, addr.disp(), file, line);
1192     real_msg = code_string(ss.as_string());
1193   }
1194 
1195   // Call indirectly to solve generation ordering problem
1196   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1197 
1198   // Make some space on stack above the current register window.
1199   // Enough to hold 8 64-bit registers.
1200   add(SP,-8*8,SP);
1201 
1202   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1203   // of 64-bit longs in the 32-bit build.
1204   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1205   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1206   ld_ptr(addr.base(), addr.disp() + 8*8, O0); // Load arg into O0; arg might be in O7 which is about to be crushed
1207   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1208 
1209   // Size of set() should stay the same
1210   patchable_set((intptr_t)real_msg, O1);
1211   // Load address to call to into O7
1212   load_ptr_contents(a, O7);
1213   // Register call to verify_oop_subroutine
1214   callr(O7, G0);
1215   delayed()-&gt;nop();
1216   // recover frame size
1217   add(SP, 8*8,SP);
1218 }
1219 
1220 // side-door communication with signalHandler in os_solaris.cpp
1221 address MacroAssembler::_verify_oop_implicit_branch[3] = { NULL };
1222 
1223 // This macro is expanded just once; it creates shared code.  Contract:
1224 // receives an oop in O0.  Must restore O0 &amp; O7 from TLS.  Must not smash ANY
1225 // registers, including flags.  May not use a register &#39;save&#39;, as this blows
1226 // the high bits of the O-regs if they contain Long values.  Acts as a &#39;leaf&#39;
1227 // call.
1228 void MacroAssembler::verify_oop_subroutine() {
1229   // Leaf call; no frame.
1230   Label succeed, fail, null_or_fail;
1231 
1232   // O0 and O7 were saved already (O0 in O0&#39;s TLS home, O7 in O5&#39;s TLS home).
1233   // O0 is now the oop to be checked.  O7 is the return address.
1234   Register O0_obj = O0;
1235 
1236   // Save some more registers for temps.
1237   stx(O2,SP,frame::register_save_words*wordSize+STACK_BIAS+2*8);
1238   stx(O3,SP,frame::register_save_words*wordSize+STACK_BIAS+3*8);
1239   stx(O4,SP,frame::register_save_words*wordSize+STACK_BIAS+4*8);
1240   stx(O5,SP,frame::register_save_words*wordSize+STACK_BIAS+5*8);
1241 
1242   // Save flags
1243   Register O5_save_flags = O5;
1244   rdccr( O5_save_flags );
1245 
1246   { // count number of verifies
1247     Register O2_adr   = O2;
1248     Register O3_accum = O3;
1249     inc_counter(StubRoutines::verify_oop_count_addr(), O2_adr, O3_accum);
1250   }
1251 
1252   Register O2_mask = O2;
1253   Register O3_bits = O3;
1254   Register O4_temp = O4;
1255 
1256   // mark lower end of faulting range
1257   assert(_verify_oop_implicit_branch[0] == NULL, &quot;set once&quot;);
1258   _verify_oop_implicit_branch[0] = pc();
1259 
1260   // We can&#39;t check the mark oop because it could be in the process of
1261   // locking or unlocking while this is running.
1262   set(Universe::verify_oop_mask (), O2_mask);
1263   set(Universe::verify_oop_bits (), O3_bits);
1264 
1265   // assert((obj &amp; oop_mask) == oop_bits);
1266   and3(O0_obj, O2_mask, O4_temp);
1267   cmp_and_brx_short(O4_temp, O3_bits, notEqual, pn, null_or_fail);
1268 
1269   if ((NULL_WORD &amp; Universe::verify_oop_mask()) == Universe::verify_oop_bits()) {
1270     // the null_or_fail case is useless; must test for null separately
1271     br_null_short(O0_obj, pn, succeed);
1272   }
1273 
1274   // Check the Klass* of this object for being in the right area of memory.
1275   // Cannot do the load in the delay above slot in case O0 is null
1276   load_klass(O0_obj, O0_obj);
1277   // assert((klass != NULL)
1278   br_null_short(O0_obj, pn, fail);
1279 
1280   wrccr( O5_save_flags ); // Restore CCR&#39;s
1281 
1282   // mark upper end of faulting range
1283   _verify_oop_implicit_branch[1] = pc();
1284 
1285   //-----------------------
1286   // all tests pass
1287   bind(succeed);
1288 
1289   // Restore prior 64-bit registers
1290   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+0*8,O0);
1291   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+1*8,O1);
1292   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+2*8,O2);
1293   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+3*8,O3);
1294   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+4*8,O4);
1295   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+5*8,O5);
1296 
1297   retl();                       // Leaf return; restore prior O7 in delay slot
1298   delayed()-&gt;ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+7*8,O7);
1299 
1300   //-----------------------
1301   bind(null_or_fail);           // nulls are less common but OK
1302   br_null(O0_obj, false, pt, succeed);
1303   delayed()-&gt;wrccr( O5_save_flags ); // Restore CCR&#39;s
1304 
1305   //-----------------------
1306   // report failure:
1307   bind(fail);
1308   _verify_oop_implicit_branch[2] = pc();
1309 
1310   wrccr( O5_save_flags ); // Restore CCR&#39;s
1311 
1312   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1313 
1314   // stop_subroutine expects message pointer in I1.
1315   mov(I1, O1);
1316 
1317   // Restore prior 64-bit registers
1318   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+0*8,I0);
1319   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+1*8,I1);
1320   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+2*8,I2);
1321   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+3*8,I3);
1322   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+4*8,I4);
1323   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+5*8,I5);
1324 
1325   // factor long stop-sequence into subroutine to save space
1326   assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1327 
1328   // call indirectly to solve generation ordering problem
1329   AddressLiteral al(StubRoutines::Sparc::stop_subroutine_entry_address());
1330   load_ptr_contents(al, O5);
1331   jmpl(O5, 0, O7);
1332   delayed()-&gt;nop();
1333 }
1334 
1335 
1336 void MacroAssembler::stop(const char* msg) {
1337   // save frame first to get O7 for return address
1338   // add one word to size in case struct is odd number of words long
1339   // It must be doubleword-aligned for storing doubles into it.
1340 
1341     save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1342 
1343     // stop_subroutine expects message pointer in I1.
1344     // Size of set() should stay the same
1345     patchable_set((intptr_t)msg, O1);
1346 
1347     // factor long stop-sequence into subroutine to save space
1348     assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1349 
1350     // call indirectly to solve generation ordering problem
1351     AddressLiteral a(StubRoutines::Sparc::stop_subroutine_entry_address());
1352     load_ptr_contents(a, O5);
1353     jmpl(O5, 0, O7);
1354     delayed()-&gt;nop();
1355 
1356     breakpoint_trap();   // make stop actually stop rather than writing
1357                          // unnoticeable results in the output files.
1358 
1359     // restore(); done in callee to save space!
1360 }
1361 
1362 
1363 void MacroAssembler::warn(const char* msg) {
1364   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1365   RegistersForDebugging::save_registers(this);
1366   mov(O0, L0);
1367   // Size of set() should stay the same
1368   patchable_set((intptr_t)msg, O0);
1369   call( CAST_FROM_FN_PTR(address, warning) );
1370   delayed()-&gt;nop();
1371 //  ret();
1372 //  delayed()-&gt;restore();
1373   RegistersForDebugging::restore_registers(this, L0);
1374   restore();
1375 }
1376 
1377 
1378 void MacroAssembler::untested(const char* what) {
1379   // We must be able to turn interactive prompting off
1380   // in order to run automated test scripts on the VM
1381   // Use the flag ShowMessageBoxOnError
1382 
1383   const char* b = NULL;
1384   {
1385     ResourceMark rm;
1386     stringStream ss;
1387     ss.print(&quot;untested: %s&quot;, what);
1388     b = code_string(ss.as_string());
1389   }
1390   if (ShowMessageBoxOnError) { STOP(b); }
1391   else                       { warn(b); }
1392 }
1393 
1394 
1395 void MacroAssembler::unimplemented(const char* what) {
1396   const char* buf = NULL;
1397   {
1398     ResourceMark rm;
1399     stringStream ss;
1400     ss.print(&quot;unimplemented: %s&quot;, what);
1401     buf = code_string(ss.as_string());
1402   }
1403   stop(buf);
1404 }
1405 
1406 
1407 void MacroAssembler::stop_subroutine() {
1408   RegistersForDebugging::save_registers(this);
1409 
1410   // for the sake of the debugger, stick a PC on the current frame
1411   // (this assumes that the caller has performed an extra &quot;save&quot;)
1412   mov(I7, L7);
1413   add(O7, -7 * BytesPerInt, I7);
1414 
1415   save_frame(); // one more save to free up another O7 register
1416   mov(I0, O1); // addr of reg save area
1417 
1418   // We expect pointer to message in I1. Caller must set it up in O1
1419   mov(I1, O0); // get msg
1420   call (CAST_FROM_FN_PTR(address, MacroAssembler::debug), relocInfo::runtime_call_type);
1421   delayed()-&gt;nop();
1422 
1423   restore();
1424 
1425   RegistersForDebugging::restore_registers(this, O0);
1426 
1427   save_frame(0);
1428   call(CAST_FROM_FN_PTR(address,breakpoint));
1429   delayed()-&gt;nop();
1430   restore();
1431 
1432   mov(L7, I7);
1433   retl();
1434   delayed()-&gt;restore(); // see stop above
1435 }
1436 
1437 
1438 void MacroAssembler::debug(char* msg, RegistersForDebugging* regs) {
1439   if ( ShowMessageBoxOnError ) {
1440     JavaThread* thread = JavaThread::current();
1441     JavaThreadState saved_state = thread-&gt;thread_state();
1442     thread-&gt;set_thread_state(_thread_in_vm);
1443       {
1444         // In order to get locks work, we need to fake a in_VM state
1445         ttyLocker ttyl;
1446         ::tty-&gt;print_cr(&quot;EXECUTION STOPPED: %s\n&quot;, msg);
1447         if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
1448         BytecodeCounter::print();
1449         }
1450         if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;))
1451           regs-&gt;print(::tty);
1452       }
1453     BREAKPOINT;
1454       ThreadStateTransition::transition(JavaThread::current(), _thread_in_vm, saved_state);
1455   }
1456   else {
1457      ::tty-&gt;print_cr(&quot;=============== DEBUG MESSAGE: %s ================\n&quot;, msg);
1458   }
1459   assert(false, &quot;DEBUG MESSAGE: %s&quot;, msg);
1460 }
1461 
1462 
1463 void MacroAssembler::calc_mem_param_words(Register Rparam_words, Register Rresult) {
1464   subcc( Rparam_words, Argument::n_register_parameters, Rresult); // how many mem words?
1465   Label no_extras;
1466   br( negative, true, pt, no_extras ); // if neg, clear reg
1467   delayed()-&gt;set(0, Rresult);          // annuled, so only if taken
1468   bind( no_extras );
1469 }
1470 
1471 
1472 void MacroAssembler::calc_frame_size(Register Rextra_words, Register Rresult) {
1473   add(Rextra_words, frame::memory_parameter_word_sp_offset, Rresult);
1474   bclr(1, Rresult);
1475   sll(Rresult, LogBytesPerWord, Rresult);  // Rresult has total frame bytes
1476 }
1477 
1478 
1479 void MacroAssembler::calc_frame_size_and_save(Register Rextra_words, Register Rresult) {
1480   calc_frame_size(Rextra_words, Rresult);
1481   neg(Rresult);
1482   save(SP, Rresult, SP);
1483 }
1484 
1485 
1486 // ---------------------------------------------------------
1487 Assembler::RCondition cond2rcond(Assembler::Condition c) {
1488   switch (c) {
1489     /*case zero: */
1490     case Assembler::equal:        return Assembler::rc_z;
1491     case Assembler::lessEqual:    return Assembler::rc_lez;
1492     case Assembler::less:         return Assembler::rc_lz;
1493     /*case notZero:*/
1494     case Assembler::notEqual:     return Assembler::rc_nz;
1495     case Assembler::greater:      return Assembler::rc_gz;
1496     case Assembler::greaterEqual: return Assembler::rc_gez;
1497   }
1498   ShouldNotReachHere();
1499   return Assembler::rc_z;
1500 }
1501 
1502 // compares (32 bit) register with zero and branches.  NOT FOR USE WITH 64-bit POINTERS
1503 void MacroAssembler::cmp_zero_and_br(Condition c, Register s1, Label&amp; L, bool a, Predict p) {
1504   tst(s1);
1505   br (c, a, p, L);
1506 }
1507 
1508 // Compares a pointer register with zero and branches on null.
1509 // Does a test &amp; branch on 32-bit systems and a register-branch on 64-bit.
1510 void MacroAssembler::br_null( Register s1, bool a, Predict p, Label&amp; L ) {
1511   assert_not_delayed();
1512   bpr( rc_z, a, p, s1, L );
1513 }
1514 
1515 void MacroAssembler::br_notnull( Register s1, bool a, Predict p, Label&amp; L ) {
1516   assert_not_delayed();
1517   bpr( rc_nz, a, p, s1, L );
1518 }
1519 
1520 // Compare registers and branch with nop in delay slot or cbcond without delay slot.
1521 
1522 // Compare integer (32 bit) values (icc only).
1523 void MacroAssembler::cmp_and_br_short(Register s1, Register s2, Condition c,
1524                                       Predict p, Label&amp; L) {
1525   assert_not_delayed();
1526   if (use_cbcond(L)) {
1527     Assembler::cbcond(c, icc, s1, s2, L);
1528   } else {
1529     cmp(s1, s2);
1530     br(c, false, p, L);
1531     delayed()-&gt;nop();
1532   }
1533 }
1534 
1535 // Compare integer (32 bit) values (icc only).
1536 void MacroAssembler::cmp_and_br_short(Register s1, int simm13a, Condition c,
1537                                       Predict p, Label&amp; L) {
1538   assert_not_delayed();
1539   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1540     Assembler::cbcond(c, icc, s1, simm13a, L);
1541   } else {
1542     cmp(s1, simm13a);
1543     br(c, false, p, L);
1544     delayed()-&gt;nop();
1545   }
1546 }
1547 
1548 // Branch that tests xcc in LP64 and icc in !LP64
1549 void MacroAssembler::cmp_and_brx_short(Register s1, Register s2, Condition c,
1550                                        Predict p, Label&amp; L) {
1551   assert_not_delayed();
1552   if (use_cbcond(L)) {
1553     Assembler::cbcond(c, ptr_cc, s1, s2, L);
1554   } else {
1555     cmp(s1, s2);
1556     brx(c, false, p, L);
1557     delayed()-&gt;nop();
1558   }
1559 }
1560 
1561 // Branch that tests xcc in LP64 and icc in !LP64
1562 void MacroAssembler::cmp_and_brx_short(Register s1, int simm13a, Condition c,
1563                                        Predict p, Label&amp; L) {
1564   assert_not_delayed();
1565   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1566     Assembler::cbcond(c, ptr_cc, s1, simm13a, L);
1567   } else {
1568     cmp(s1, simm13a);
1569     brx(c, false, p, L);
1570     delayed()-&gt;nop();
1571   }
1572 }
1573 
1574 // Short branch version for compares a pointer with zero.
1575 
1576 void MacroAssembler::br_null_short(Register s1, Predict p, Label&amp; L) {
1577   assert_not_delayed();
1578   if (use_cbcond(L)) {
1579     Assembler::cbcond(zero, ptr_cc, s1, 0, L);
1580   } else {
1581     br_null(s1, false, p, L);
1582     delayed()-&gt;nop();
1583   }
1584 }
1585 
1586 void MacroAssembler::br_notnull_short(Register s1, Predict p, Label&amp; L) {
1587   assert_not_delayed();
1588   if (use_cbcond(L)) {
1589     Assembler::cbcond(notZero, ptr_cc, s1, 0, L);
1590   } else {
1591     br_notnull(s1, false, p, L);
1592     delayed()-&gt;nop();
1593   }
1594 }
1595 
1596 // Unconditional short branch
1597 void MacroAssembler::ba_short(Label&amp; L) {
1598   assert_not_delayed();
1599   if (use_cbcond(L)) {
1600     Assembler::cbcond(equal, icc, G0, G0, L);
1601   } else {
1602     br(always, false, pt, L);
1603     delayed()-&gt;nop();
1604   }
1605 }
1606 
1607 // Branch if &#39;icc&#39; says zero or not (i.e. icc.z == 1|0).
1608 
1609 void MacroAssembler::br_icc_zero(bool iszero, Predict p, Label &amp;L) {
1610   assert_not_delayed();
1611   Condition cf = (iszero ? Assembler::zero : Assembler::notZero);
1612   br(cf, false, p, L);
1613   delayed()-&gt;nop();
1614 }
1615 
1616 // instruction sequences factored across compiler &amp; interpreter
1617 
1618 
1619 void MacroAssembler::lcmp( Register Ra_hi, Register Ra_low,
1620                            Register Rb_hi, Register Rb_low,
1621                            Register Rresult) {
1622 
1623   Label check_low_parts, done;
1624 
1625   cmp(Ra_hi, Rb_hi );  // compare hi parts
1626   br(equal, true, pt, check_low_parts);
1627   delayed()-&gt;cmp(Ra_low, Rb_low); // test low parts
1628 
1629   // And, with an unsigned comparison, it does not matter if the numbers
1630   // are negative or not.
1631   // E.g., -2 cmp -1: the low parts are 0xfffffffe and 0xffffffff.
1632   // The second one is bigger (unsignedly).
1633 
1634   // Other notes:  The first move in each triplet can be unconditional
1635   // (and therefore probably prefetchable).
1636   // And the equals case for the high part does not need testing,
1637   // since that triplet is reached only after finding the high halves differ.
1638 
1639   mov(-1, Rresult);
1640   ba(done);
1641   delayed()-&gt;movcc(greater, false, icc,  1, Rresult);
1642 
1643   bind(check_low_parts);
1644 
1645   mov(                               -1, Rresult);
1646   movcc(equal,           false, icc,  0, Rresult);
1647   movcc(greaterUnsigned, false, icc,  1, Rresult);
1648 
1649   bind(done);
1650 }
1651 
1652 void MacroAssembler::lneg( Register Rhi, Register Rlow ) {
1653   subcc(  G0, Rlow, Rlow );
1654   subc(   G0, Rhi,  Rhi  );
1655 }
1656 
1657 void MacroAssembler::lshl( Register Rin_high,  Register Rin_low,
1658                            Register Rcount,
1659                            Register Rout_high, Register Rout_low,
1660                            Register Rtemp ) {
1661 
1662 
1663   Register Ralt_count = Rtemp;
1664   Register Rxfer_bits = Rtemp;
1665 
1666   assert( Ralt_count != Rin_high
1667       &amp;&amp;  Ralt_count != Rin_low
1668       &amp;&amp;  Ralt_count != Rcount
1669       &amp;&amp;  Rxfer_bits != Rin_low
1670       &amp;&amp;  Rxfer_bits != Rin_high
1671       &amp;&amp;  Rxfer_bits != Rcount
1672       &amp;&amp;  Rxfer_bits != Rout_low
1673       &amp;&amp;  Rout_low   != Rin_high,
1674         &quot;register alias checks&quot;);
1675 
1676   Label big_shift, done;
1677 
1678   // This code can be optimized to use the 64 bit shifts in V9.
1679   // Here we use the 32 bit shifts.
1680 
1681   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1682   subcc(Rcount,   31, Ralt_count);
1683   br(greater, true, pn, big_shift);
1684   delayed()-&gt;dec(Ralt_count);
1685 
1686   // shift &lt; 32 bits, Ralt_count = Rcount-31
1687 
1688   // We get the transfer bits by shifting right by 32-count the low
1689   // register. This is done by shifting right by 31-count and then by one
1690   // more to take care of the special (rare) case where count is zero
1691   // (shifting by 32 would not work).
1692 
1693   neg(Ralt_count);
1694 
1695   // The order of the next two instructions is critical in the case where
1696   // Rin and Rout are the same and should not be reversed.
1697 
1698   srl(Rin_low, Ralt_count, Rxfer_bits); // shift right by 31-count
1699   if (Rcount != Rout_low) {
1700     sll(Rin_low, Rcount, Rout_low); // low half
1701   }
1702   sll(Rin_high, Rcount, Rout_high);
1703   if (Rcount == Rout_low) {
1704     sll(Rin_low, Rcount, Rout_low); // low half
1705   }
1706   srl(Rxfer_bits, 1, Rxfer_bits ); // shift right by one more
1707   ba(done);
1708   delayed()-&gt;or3(Rout_high, Rxfer_bits, Rout_high);   // new hi value: or in shifted old hi part and xfer from low
1709 
1710   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1711   bind(big_shift);
1712   sll(Rin_low, Ralt_count, Rout_high  );
1713   clr(Rout_low);
1714 
1715   bind(done);
1716 }
1717 
1718 
1719 void MacroAssembler::lshr( Register Rin_high,  Register Rin_low,
1720                            Register Rcount,
1721                            Register Rout_high, Register Rout_low,
1722                            Register Rtemp ) {
1723 
1724   Register Ralt_count = Rtemp;
1725   Register Rxfer_bits = Rtemp;
1726 
1727   assert( Ralt_count != Rin_high
1728       &amp;&amp;  Ralt_count != Rin_low
1729       &amp;&amp;  Ralt_count != Rcount
1730       &amp;&amp;  Rxfer_bits != Rin_low
1731       &amp;&amp;  Rxfer_bits != Rin_high
1732       &amp;&amp;  Rxfer_bits != Rcount
1733       &amp;&amp;  Rxfer_bits != Rout_high
1734       &amp;&amp;  Rout_high  != Rin_low,
1735         &quot;register alias checks&quot;);
1736 
1737   Label big_shift, done;
1738 
1739   // This code can be optimized to use the 64 bit shifts in V9.
1740   // Here we use the 32 bit shifts.
1741 
1742   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1743   subcc(Rcount,   31, Ralt_count);
1744   br(greater, true, pn, big_shift);
1745   delayed()-&gt;dec(Ralt_count);
1746 
1747   // shift &lt; 32 bits, Ralt_count = Rcount-31
1748 
1749   // We get the transfer bits by shifting left by 32-count the high
1750   // register. This is done by shifting left by 31-count and then by one
1751   // more to take care of the special (rare) case where count is zero
1752   // (shifting by 32 would not work).
1753 
1754   neg(Ralt_count);
1755   if (Rcount != Rout_low) {
1756     srl(Rin_low, Rcount, Rout_low);
1757   }
1758 
1759   // The order of the next two instructions is critical in the case where
1760   // Rin and Rout are the same and should not be reversed.
1761 
1762   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1763   sra(Rin_high,     Rcount, Rout_high ); // high half
1764   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1765   if (Rcount == Rout_low) {
1766     srl(Rin_low, Rcount, Rout_low);
1767   }
1768   ba(done);
1769   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1770 
1771   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1772   bind(big_shift);
1773 
1774   sra(Rin_high, Ralt_count, Rout_low);
1775   sra(Rin_high,         31, Rout_high); // sign into hi
1776 
1777   bind( done );
1778 }
1779 
1780 
1781 
1782 void MacroAssembler::lushr( Register Rin_high,  Register Rin_low,
1783                             Register Rcount,
1784                             Register Rout_high, Register Rout_low,
1785                             Register Rtemp ) {
1786 
1787   Register Ralt_count = Rtemp;
1788   Register Rxfer_bits = Rtemp;
1789 
1790   assert( Ralt_count != Rin_high
1791       &amp;&amp;  Ralt_count != Rin_low
1792       &amp;&amp;  Ralt_count != Rcount
1793       &amp;&amp;  Rxfer_bits != Rin_low
1794       &amp;&amp;  Rxfer_bits != Rin_high
1795       &amp;&amp;  Rxfer_bits != Rcount
1796       &amp;&amp;  Rxfer_bits != Rout_high
1797       &amp;&amp;  Rout_high  != Rin_low,
1798         &quot;register alias checks&quot;);
1799 
1800   Label big_shift, done;
1801 
1802   // This code can be optimized to use the 64 bit shifts in V9.
1803   // Here we use the 32 bit shifts.
1804 
1805   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1806   subcc(Rcount,   31, Ralt_count);
1807   br(greater, true, pn, big_shift);
1808   delayed()-&gt;dec(Ralt_count);
1809 
1810   // shift &lt; 32 bits, Ralt_count = Rcount-31
1811 
1812   // We get the transfer bits by shifting left by 32-count the high
1813   // register. This is done by shifting left by 31-count and then by one
1814   // more to take care of the special (rare) case where count is zero
1815   // (shifting by 32 would not work).
1816 
1817   neg(Ralt_count);
1818   if (Rcount != Rout_low) {
1819     srl(Rin_low, Rcount, Rout_low);
1820   }
1821 
1822   // The order of the next two instructions is critical in the case where
1823   // Rin and Rout are the same and should not be reversed.
1824 
1825   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1826   srl(Rin_high,     Rcount, Rout_high ); // high half
1827   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1828   if (Rcount == Rout_low) {
1829     srl(Rin_low, Rcount, Rout_low);
1830   }
1831   ba(done);
1832   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1833 
1834   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1835   bind(big_shift);
1836 
1837   srl(Rin_high, Ralt_count, Rout_low);
1838   clr(Rout_high);
1839 
1840   bind( done );
1841 }
1842 
1843 void MacroAssembler::lcmp( Register Ra, Register Rb, Register Rresult) {
1844   cmp(Ra, Rb);
1845   mov(-1, Rresult);
1846   movcc(equal,   false, xcc,  0, Rresult);
1847   movcc(greater, false, xcc,  1, Rresult);
1848 }
1849 
1850 
1851 void MacroAssembler::load_sized_value(Address src, Register dst, size_t size_in_bytes, bool is_signed) {
1852   switch (size_in_bytes) {
1853   case  8:  ld_long(src, dst); break;
1854   case  4:  ld(     src, dst); break;
1855   case  2:  is_signed ? ldsh(src, dst) : lduh(src, dst); break;
1856   case  1:  is_signed ? ldsb(src, dst) : ldub(src, dst); break;
1857   default:  ShouldNotReachHere();
1858   }
1859 }
1860 
1861 void MacroAssembler::store_sized_value(Register src, Address dst, size_t size_in_bytes) {
1862   switch (size_in_bytes) {
1863   case  8:  st_long(src, dst); break;
1864   case  4:  st(     src, dst); break;
1865   case  2:  sth(    src, dst); break;
1866   case  1:  stb(    src, dst); break;
1867   default:  ShouldNotReachHere();
1868   }
1869 }
1870 
1871 
1872 void MacroAssembler::float_cmp( bool is_float, int unordered_result,
1873                                 FloatRegister Fa, FloatRegister Fb,
1874                                 Register Rresult) {
1875   if (is_float) {
1876     fcmp(FloatRegisterImpl::S, fcc0, Fa, Fb);
1877   } else {
1878     fcmp(FloatRegisterImpl::D, fcc0, Fa, Fb);
1879   }
1880 
1881   if (unordered_result == 1) {
1882     mov(                                    -1, Rresult);
1883     movcc(f_equal,              true, fcc0,  0, Rresult);
1884     movcc(f_unorderedOrGreater, true, fcc0,  1, Rresult);
1885   } else {
1886     mov(                                    -1, Rresult);
1887     movcc(f_equal,              true, fcc0,  0, Rresult);
1888     movcc(f_greater,            true, fcc0,  1, Rresult);
1889   }
1890 }
1891 
1892 
1893 void MacroAssembler::save_all_globals_into_locals() {
1894   mov(G1,L1);
1895   mov(G2,L2);
1896   mov(G3,L3);
1897   mov(G4,L4);
1898   mov(G5,L5);
1899   mov(G6,L6);
1900   mov(G7,L7);
1901 }
1902 
1903 void MacroAssembler::restore_globals_from_locals() {
1904   mov(L1,G1);
1905   mov(L2,G2);
1906   mov(L3,G3);
1907   mov(L4,G4);
1908   mov(L5,G5);
1909   mov(L6,G6);
1910   mov(L7,G7);
1911 }
1912 
1913 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
1914                                                       Register tmp,
1915                                                       int offset) {
1916   intptr_t value = *delayed_value_addr;
1917   if (value != 0)
1918     return RegisterOrConstant(value + offset);
1919 
1920   // load indirectly to solve generation ordering problem
1921   AddressLiteral a(delayed_value_addr);
1922   load_ptr_contents(a, tmp);
1923 
1924 #ifdef ASSERT
1925   tst(tmp);
1926   breakpoint_trap(zero, xcc);
1927 #endif
1928 
1929   if (offset != 0)
1930     add(tmp, offset, tmp);
1931 
1932   return RegisterOrConstant(tmp);
1933 }
1934 
1935 
1936 RegisterOrConstant MacroAssembler::regcon_andn_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1937   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1938   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1939       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1940     // Do nothing, just move value.
1941     if (s1.is_register()) {
1942       if (d.is_constant())  d = temp;
1943       mov(s1.as_register(), d.as_register());
1944       return d;
1945     } else {
1946       return s1;
1947     }
1948   }
1949 
1950   if (s1.is_register()) {
1951     assert_different_registers(s1.as_register(), temp);
1952     if (d.is_constant())  d = temp;
1953     andn(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
1954     return d;
1955   } else {
1956     if (s2.is_register()) {
1957       assert_different_registers(s2.as_register(), temp);
1958       if (d.is_constant())  d = temp;
1959       set(s1.as_constant(), temp);
1960       andn(temp, s2.as_register(), d.as_register());
1961       return d;
1962     } else {
1963       intptr_t res = s1.as_constant() &amp; ~s2.as_constant();
1964       return res;
1965     }
1966   }
1967 }
1968 
1969 RegisterOrConstant MacroAssembler::regcon_inc_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1970   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1971   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1972       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1973     // Do nothing, just move value.
1974     if (s1.is_register()) {
1975       if (d.is_constant())  d = temp;
1976       mov(s1.as_register(), d.as_register());
1977       return d;
1978     } else {
1979       return s1;
1980     }
1981   }
1982 
1983   if (s1.is_register()) {
1984     assert_different_registers(s1.as_register(), temp);
1985     if (d.is_constant())  d = temp;
1986     add(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
1987     return d;
1988   } else {
1989     if (s2.is_register()) {
1990       assert_different_registers(s2.as_register(), temp);
1991       if (d.is_constant())  d = temp;
1992       add(s2.as_register(), ensure_simm13_or_reg(s1, temp), d.as_register());
1993       return d;
1994     } else {
1995       intptr_t res = s1.as_constant() + s2.as_constant();
1996       return res;
1997     }
1998   }
1999 }
2000 
2001 RegisterOrConstant MacroAssembler::regcon_sll_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
2002   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
2003   if (!is_simm13(s2.constant_or_zero()))
2004     s2 = (s2.as_constant() &amp; 0xFF);
2005   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
2006       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
2007     // Do nothing, just move value.
2008     if (s1.is_register()) {
2009       if (d.is_constant())  d = temp;
2010       mov(s1.as_register(), d.as_register());
2011       return d;
2012     } else {
2013       return s1;
2014     }
2015   }
2016 
2017   if (s1.is_register()) {
2018     assert_different_registers(s1.as_register(), temp);
2019     if (d.is_constant())  d = temp;
2020     sll_ptr(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
2021     return d;
2022   } else {
2023     if (s2.is_register()) {
2024       assert_different_registers(s2.as_register(), temp);
2025       if (d.is_constant())  d = temp;
2026       set(s1.as_constant(), temp);
2027       sll_ptr(temp, s2.as_register(), d.as_register());
2028       return d;
2029     } else {
2030       intptr_t res = s1.as_constant() &lt;&lt; s2.as_constant();
2031       return res;
2032     }
2033   }
2034 }
2035 
2036 
2037 // Look up the method for a megamorphic invokeinterface call.
2038 // The target method is determined by &lt;intf_klass, itable_index&gt;.
2039 // The receiver klass is in recv_klass.
2040 // On success, the result will be in method_result, and execution falls through.
2041 // On failure, execution transfers to the given label.
2042 void MacroAssembler::lookup_interface_method(Register recv_klass,
2043                                              Register intf_klass,
2044                                              RegisterOrConstant itable_index,
2045                                              Register method_result,
2046                                              Register scan_temp,
2047                                              Register sethi_temp,
2048                                              Label&amp; L_no_such_interface,
2049                                              bool return_method) {
2050   assert_different_registers(recv_klass, intf_klass, method_result, scan_temp);
2051   assert(!return_method || itable_index.is_constant() || itable_index.as_register() == method_result,
2052          &quot;caller must use same register for non-constant itable index as for method&quot;);
2053 
2054   Label L_no_such_interface_restore;
2055   bool did_save = false;
2056   if (scan_temp == noreg || sethi_temp == noreg) {
2057     Register recv_2 = recv_klass-&gt;is_global() ? recv_klass : L0;
2058     Register intf_2 = intf_klass-&gt;is_global() ? intf_klass : L1;
2059     assert(method_result-&gt;is_global(), &quot;must be able to return value&quot;);
2060     scan_temp  = L2;
2061     sethi_temp = L3;
2062     save_frame_and_mov(0, recv_klass, recv_2, intf_klass, intf_2);
2063     recv_klass = recv_2;
2064     intf_klass = intf_2;
2065     did_save = true;
2066   }
2067 
2068   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
2069   int vtable_base = in_bytes(Klass::vtable_start_offset());
2070   int scan_step   = itableOffsetEntry::size() * wordSize;
2071   int vte_size    = vtableEntry::size_in_bytes();
2072 
2073   lduw(recv_klass, in_bytes(Klass::vtable_length_offset()), scan_temp);
2074   // %%% We should store the aligned, prescaled offset in the klassoop.
2075   // Then the next several instructions would fold away.
2076 
2077   int itb_offset = vtable_base;
2078   int itb_scale = exact_log2(vtableEntry::size_in_bytes());
2079   sll(scan_temp, itb_scale,  scan_temp);
2080   add(scan_temp, itb_offset, scan_temp);
2081   add(recv_klass, scan_temp, scan_temp);
2082 
2083   if (return_method) {
2084     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
2085     RegisterOrConstant itable_offset = itable_index;
2086     itable_offset = regcon_sll_ptr(itable_index, exact_log2(itableMethodEntry::size() * wordSize), itable_offset);
2087     itable_offset = regcon_inc_ptr(itable_offset, itableMethodEntry::method_offset_in_bytes(), itable_offset);
2088     add(recv_klass, ensure_simm13_or_reg(itable_offset, sethi_temp), recv_klass);
2089   }
2090 
2091   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
2092   //   if (scan-&gt;interface() == intf) {
2093   //     result = (klass + scan-&gt;offset() + itable_index);
2094   //   }
2095   // }
2096   Label L_search, L_found_method;
2097 
2098   for (int peel = 1; peel &gt;= 0; peel--) {
2099     // %%%% Could load both offset and interface in one ldx, if they were
2100     // in the opposite order.  This would save a load.
2101     ld_ptr(scan_temp, itableOffsetEntry::interface_offset_in_bytes(), method_result);
2102 
2103     // Check that this entry is non-null.  A null entry means that
2104     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
2105     // same as when the caller was compiled.
2106     bpr(Assembler::rc_z, false, Assembler::pn, method_result, did_save ? L_no_such_interface_restore : L_no_such_interface);
2107     delayed()-&gt;cmp(method_result, intf_klass);
2108 
2109     if (peel) {
2110       brx(Assembler::equal,    false, Assembler::pt, L_found_method);
2111     } else {
2112       brx(Assembler::notEqual, false, Assembler::pn, L_search);
2113       // (invert the test to fall through to found_method...)
2114     }
2115     delayed()-&gt;add(scan_temp, scan_step, scan_temp);
2116 
2117     if (!peel)  break;
2118 
2119     bind(L_search);
2120   }
2121 
2122   bind(L_found_method);
2123 
2124   if (return_method) {
2125     // Got a hit.
2126     int ito_offset = itableOffsetEntry::offset_offset_in_bytes();
2127     // scan_temp[-scan_step] points to the vtable offset we need
2128     ito_offset -= scan_step;
2129     lduw(scan_temp, ito_offset, scan_temp);
2130     ld_ptr(recv_klass, scan_temp, method_result);
2131   }
2132 
2133   if (did_save) {
2134     Label L_done;
2135     ba(L_done);
2136     delayed()-&gt;restore();
2137 
2138     bind(L_no_such_interface_restore);
2139     ba(L_no_such_interface);
2140     delayed()-&gt;restore();
2141 
2142     bind(L_done);
2143   }
2144 }
2145 
2146 
2147 // virtual method calling
2148 void MacroAssembler::lookup_virtual_method(Register recv_klass,
2149                                            RegisterOrConstant vtable_index,
2150                                            Register method_result) {
2151   assert_different_registers(recv_klass, method_result, vtable_index.register_or_noreg());
2152   Register sethi_temp = method_result;
2153   const int base = in_bytes(Klass::vtable_start_offset()) +
2154                    // method pointer offset within the vtable entry:
2155                    vtableEntry::method_offset_in_bytes();
2156   RegisterOrConstant vtable_offset = vtable_index;
2157   // Each of the following three lines potentially generates an instruction.
2158   // But the total number of address formation instructions will always be
2159   // at most two, and will often be zero.  In any case, it will be optimal.
2160   // If vtable_index is a register, we will have (sll_ptr N,x; inc_ptr B,x; ld_ptr k,x).
2161   // If vtable_index is a constant, we will have at most (set B+X&lt;&lt;N,t; ld_ptr k,t).
2162   vtable_offset = regcon_sll_ptr(vtable_index, exact_log2(vtableEntry::size_in_bytes()), vtable_offset);
2163   vtable_offset = regcon_inc_ptr(vtable_offset, base, vtable_offset, sethi_temp);
2164   Address vtable_entry_addr(recv_klass, ensure_simm13_or_reg(vtable_offset, sethi_temp));
2165   ld_ptr(vtable_entry_addr, method_result);
2166 }
2167 
2168 
2169 void MacroAssembler::check_klass_subtype(Register sub_klass,
2170                                          Register super_klass,
2171                                          Register temp_reg,
2172                                          Register temp2_reg,
2173                                          Label&amp; L_success) {
2174   Register sub_2 = sub_klass;
2175   Register sup_2 = super_klass;
2176   if (!sub_2-&gt;is_global())  sub_2 = L0;
2177   if (!sup_2-&gt;is_global())  sup_2 = L1;
2178   bool did_save = false;
2179   if (temp_reg == noreg || temp2_reg == noreg) {
2180     temp_reg = L2;
2181     temp2_reg = L3;
2182     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2183     sub_klass = sub_2;
2184     super_klass = sup_2;
2185     did_save = true;
2186   }
2187   Label L_failure, L_pop_to_failure, L_pop_to_success;
2188   check_klass_subtype_fast_path(sub_klass, super_klass,
2189                                 temp_reg, temp2_reg,
2190                                 (did_save ? &amp;L_pop_to_success : &amp;L_success),
2191                                 (did_save ? &amp;L_pop_to_failure : &amp;L_failure), NULL);
2192 
2193   if (!did_save)
2194     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2195   check_klass_subtype_slow_path(sub_2, sup_2,
2196                                 L2, L3, L4, L5,
2197                                 NULL, &amp;L_pop_to_failure);
2198 
2199   // on success:
2200   bind(L_pop_to_success);
2201   restore();
2202   ba_short(L_success);
2203 
2204   // on failure:
2205   bind(L_pop_to_failure);
2206   restore();
2207   bind(L_failure);
2208 }
2209 
2210 
2211 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
2212                                                    Register super_klass,
2213                                                    Register temp_reg,
2214                                                    Register temp2_reg,
2215                                                    Label* L_success,
2216                                                    Label* L_failure,
2217                                                    Label* L_slow_path,
2218                                         RegisterOrConstant super_check_offset) {
2219   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2220   int sco_offset = in_bytes(Klass::super_check_offset_offset());
2221 
2222   bool must_load_sco  = (super_check_offset.constant_or_zero() == -1);
2223   bool need_slow_path = (must_load_sco ||
2224                          super_check_offset.constant_or_zero() == sco_offset);
2225 
2226   assert_different_registers(sub_klass, super_klass, temp_reg);
2227   if (super_check_offset.is_register()) {
2228     assert_different_registers(sub_klass, super_klass, temp_reg,
2229                                super_check_offset.as_register());
2230   } else if (must_load_sco) {
2231     assert(temp2_reg != noreg, &quot;supply either a temp or a register offset&quot;);
2232   }
2233 
2234   Label L_fallthrough;
2235   int label_nulls = 0;
2236   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2237   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2238   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
2239   assert(label_nulls &lt;= 1 ||
2240          (L_slow_path == &amp;L_fallthrough &amp;&amp; label_nulls &lt;= 2 &amp;&amp; !need_slow_path),
2241          &quot;at most one NULL in the batch, usually&quot;);
2242 
2243   // If the pointers are equal, we are done (e.g., String[] elements).
2244   // This self-check enables sharing of secondary supertype arrays among
2245   // non-primary types such as array-of-interface.  Otherwise, each such
2246   // type would need its own customized SSA.
2247   // We move this check to the front of the fast path because many
2248   // type checks are in fact trivially successful in this manner,
2249   // so we get a nicely predicted branch right at the start of the check.
2250   cmp(super_klass, sub_klass);
2251   brx(Assembler::equal, false, Assembler::pn, *L_success);
2252   delayed()-&gt;nop();
2253 
2254   // Check the supertype display:
2255   if (must_load_sco) {
2256     // The super check offset is always positive...
2257     lduw(super_klass, sco_offset, temp2_reg);
2258     super_check_offset = RegisterOrConstant(temp2_reg);
2259     // super_check_offset is register.
2260     assert_different_registers(sub_klass, super_klass, temp_reg, super_check_offset.as_register());
2261   }
2262   ld_ptr(sub_klass, super_check_offset, temp_reg);
2263   cmp(super_klass, temp_reg);
2264 
2265   // This check has worked decisively for primary supers.
2266   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
2267   // (Secondary supers are interfaces and very deeply nested subtypes.)
2268   // This works in the same check above because of a tricky aliasing
2269   // between the super_cache and the primary super display elements.
2270   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
2271   // Note that the cache is updated below if it does not help us find
2272   // what we need immediately.
2273   // So if it was a primary super, we can just fail immediately.
2274   // Otherwise, it&#39;s the slow path for us (no success at this point).
2275 
2276   // Hacked ba(), which may only be used just before L_fallthrough.
2277 #define FINAL_JUMP(label)            \
2278   if (&amp;(label) != &amp;L_fallthrough) {  \
2279     ba(label);  delayed()-&gt;nop();    \
2280   }
2281 
2282   if (super_check_offset.is_register()) {
2283     brx(Assembler::equal, false, Assembler::pn, *L_success);
2284     delayed()-&gt;cmp(super_check_offset.as_register(), sc_offset);
2285 
2286     if (L_failure == &amp;L_fallthrough) {
2287       brx(Assembler::equal, false, Assembler::pt, *L_slow_path);
2288       delayed()-&gt;nop();
2289     } else {
2290       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2291       delayed()-&gt;nop();
2292       FINAL_JUMP(*L_slow_path);
2293     }
2294   } else if (super_check_offset.as_constant() == sc_offset) {
2295     // Need a slow path; fast failure is impossible.
2296     if (L_slow_path == &amp;L_fallthrough) {
2297       brx(Assembler::equal, false, Assembler::pt, *L_success);
2298       delayed()-&gt;nop();
2299     } else {
2300       brx(Assembler::notEqual, false, Assembler::pn, *L_slow_path);
2301       delayed()-&gt;nop();
2302       FINAL_JUMP(*L_success);
2303     }
2304   } else {
2305     // No slow path; it&#39;s a fast decision.
2306     if (L_failure == &amp;L_fallthrough) {
2307       brx(Assembler::equal, false, Assembler::pt, *L_success);
2308       delayed()-&gt;nop();
2309     } else {
2310       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2311       delayed()-&gt;nop();
2312       FINAL_JUMP(*L_success);
2313     }
2314   }
2315 
2316   bind(L_fallthrough);
2317 
2318 #undef FINAL_JUMP
2319 }
2320 
2321 
2322 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
2323                                                    Register super_klass,
2324                                                    Register count_temp,
2325                                                    Register scan_temp,
2326                                                    Register scratch_reg,
2327                                                    Register coop_reg,
2328                                                    Label* L_success,
2329                                                    Label* L_failure) {
2330   assert_different_registers(sub_klass, super_klass,
2331                              count_temp, scan_temp, scratch_reg, coop_reg);
2332 
2333   Label L_fallthrough, L_loop;
2334   int label_nulls = 0;
2335   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2336   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2337   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
2338 
2339   // a couple of useful fields in sub_klass:
2340   int ss_offset = in_bytes(Klass::secondary_supers_offset());
2341   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2342 
2343   // Do a linear scan of the secondary super-klass chain.
2344   // This code is rarely used, so simplicity is a virtue here.
2345 
2346 #ifndef PRODUCT
2347   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
2348   inc_counter((address) pst_counter, count_temp, scan_temp);
2349 #endif
2350 
2351   // We will consult the secondary-super array.
2352   ld_ptr(sub_klass, ss_offset, scan_temp);
2353 
2354   Register search_key = super_klass;
2355 
2356   // Load the array length.  (Positive movl does right thing on LP64.)
2357   lduw(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes(), count_temp);
2358 
2359   // Check for empty secondary super list
2360   tst(count_temp);
2361 
2362   // In the array of super classes elements are pointer sized.
2363   int element_size = wordSize;
2364 
2365   // Top of search loop
2366   bind(L_loop);
2367   br(Assembler::equal, false, Assembler::pn, *L_failure);
2368   delayed()-&gt;add(scan_temp, element_size, scan_temp);
2369 
2370   // Skip the array header in all array accesses.
2371   int elem_offset = Array&lt;Klass*&gt;::base_offset_in_bytes();
2372   elem_offset -= element_size;   // the scan pointer was pre-incremented also
2373 
2374   // Load next super to check
2375     ld_ptr( scan_temp, elem_offset, scratch_reg );
2376 
2377   // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
2378   cmp(scratch_reg, search_key);
2379 
2380   // A miss means we are NOT a subtype and need to keep looping
2381   brx(Assembler::notEqual, false, Assembler::pn, L_loop);
2382   delayed()-&gt;deccc(count_temp); // decrement trip counter in delay slot
2383 
2384   // Success.  Cache the super we found and proceed in triumph.
2385   st_ptr(super_klass, sub_klass, sc_offset);
2386 
2387   if (L_success != &amp;L_fallthrough) {
2388     ba(*L_success);
2389     delayed()-&gt;nop();
2390   }
2391 
2392   bind(L_fallthrough);
2393 }
2394 
2395 
2396 RegisterOrConstant MacroAssembler::argument_offset(RegisterOrConstant arg_slot,
2397                                                    Register temp_reg,
2398                                                    int extra_slot_offset) {
2399   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
2400   int stackElementSize = Interpreter::stackElementSize;
2401   int offset = extra_slot_offset * stackElementSize;
2402   if (arg_slot.is_constant()) {
2403     offset += arg_slot.as_constant() * stackElementSize;
2404     return offset;
2405   } else {
2406     assert(temp_reg != noreg, &quot;must specify&quot;);
2407     sll_ptr(arg_slot.as_register(), exact_log2(stackElementSize), temp_reg);
2408     if (offset != 0)
2409       add(temp_reg, offset, temp_reg);
2410     return temp_reg;
2411   }
2412 }
2413 
2414 
2415 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
2416                                          Register temp_reg,
2417                                          int extra_slot_offset) {
2418   return Address(Gargs, argument_offset(arg_slot, temp_reg, extra_slot_offset));
2419 }
2420 
2421 
2422 void MacroAssembler::biased_locking_enter(Register obj_reg, Register mark_reg,
2423                                           Register temp_reg,
2424                                           Label&amp; done, Label* slow_case,
2425                                           BiasedLockingCounters* counters) {
2426   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
2427 
2428   if (PrintBiasedLockingStatistics) {
2429     assert_different_registers(obj_reg, mark_reg, temp_reg, O7);
2430     if (counters == NULL)
2431       counters = BiasedLocking::counters();
2432   }
2433 
2434   Label cas_label;
2435 
2436   // Biased locking
2437   // See whether the lock is currently biased toward our thread and
2438   // whether the epoch is still valid
2439   // Note that the runtime guarantees sufficient alignment of JavaThread
2440   // pointers to allow age to be placed into low bits
2441   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
2442   and3(mark_reg, markWord::biased_lock_mask_in_place, temp_reg);
2443   cmp_and_brx_short(temp_reg, markWord::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);
2444 
2445   load_klass(obj_reg, temp_reg);
2446   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2447   or3(G2_thread, temp_reg, temp_reg);
2448   xor3(mark_reg, temp_reg, temp_reg);
2449   andcc(temp_reg, ~((int) markWord::age_mask_in_place), temp_reg);
2450   if (counters != NULL) {
2451     cond_inc(Assembler::equal, (address) counters-&gt;biased_lock_entry_count_addr(), mark_reg, temp_reg);
2452     // Reload mark_reg as we may need it later
2453     ld_ptr(Address(obj_reg, oopDesc::mark_offset_in_bytes()), mark_reg);
2454   }
2455   brx(Assembler::equal, true, Assembler::pt, done);
2456   delayed()-&gt;nop();
2457 
2458   Label try_revoke_bias;
2459   Label try_rebias;
2460   Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());
2461   assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2462 
2463   // At this point we know that the header has the bias pattern and
2464   // that we are not the bias owner in the current epoch. We need to
2465   // figure out more details about the state of the header in order to
2466   // know what operations can be legally performed on the object&#39;s
2467   // header.
2468 
2469   // If the low three bits in the xor result aren&#39;t clear, that means
2470   // the prototype header is no longer biased and we have to revoke
2471   // the bias on this object.
2472   btst(markWord::biased_lock_mask_in_place, temp_reg);
2473   brx(Assembler::notZero, false, Assembler::pn, try_revoke_bias);
2474 
2475   // Biasing is still enabled for this data type. See whether the
2476   // epoch of the current bias is still valid, meaning that the epoch
2477   // bits of the mark word are equal to the epoch bits of the
2478   // prototype header. (Note that the prototype header&#39;s epoch bits
2479   // only change at a safepoint.) If not, attempt to rebias the object
2480   // toward the current thread. Note that we must be absolutely sure
2481   // that the current epoch is invalid in order to do this because
2482   // otherwise the manipulations it performs on the mark word are
2483   // illegal.
2484   delayed()-&gt;btst(markWord::epoch_mask_in_place, temp_reg);
2485   brx(Assembler::notZero, false, Assembler::pn, try_rebias);
2486 
2487   // The epoch of the current bias is still valid but we know nothing
2488   // about the owner; it might be set or it might be clear. Try to
2489   // acquire the bias of the object using an atomic operation. If this
2490   // fails we will go in to the runtime to revoke the object&#39;s bias.
2491   // Note that we first construct the presumed unbiased header so we
2492   // don&#39;t accidentally blow away another thread&#39;s valid bias.
2493   delayed()-&gt;and3(mark_reg,
2494                   markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place,
2495                   mark_reg);
2496   or3(G2_thread, mark_reg, temp_reg);
2497   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2498   // If the biasing toward our thread failed, this means that
2499   // another thread succeeded in biasing it toward itself and we
2500   // need to revoke that bias. The revocation will occur in the
2501   // interpreter runtime in the slow case.
2502   cmp(mark_reg, temp_reg);
2503   if (counters != NULL) {
2504     cond_inc(Assembler::zero, (address) counters-&gt;anonymously_biased_lock_entry_count_addr(), mark_reg, temp_reg);
2505   }
2506   if (slow_case != NULL) {
2507     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2508     delayed()-&gt;nop();
2509   }
2510   ba_short(done);
2511 
2512   bind(try_rebias);
2513   // At this point we know the epoch has expired, meaning that the
2514   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
2515   // circumstances _only_, we are allowed to use the current header&#39;s
2516   // value as the comparison value when doing the cas to acquire the
2517   // bias in the current epoch. In other words, we allow transfer of
2518   // the bias from one thread to another directly in this situation.
2519   //
2520   // FIXME: due to a lack of registers we currently blow away the age
2521   // bits in this situation. Should attempt to preserve them.
2522   load_klass(obj_reg, temp_reg);
2523   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2524   or3(G2_thread, temp_reg, temp_reg);
2525   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2526   // If the biasing toward our thread failed, this means that
2527   // another thread succeeded in biasing it toward itself and we
2528   // need to revoke that bias. The revocation will occur in the
2529   // interpreter runtime in the slow case.
2530   cmp(mark_reg, temp_reg);
2531   if (counters != NULL) {
2532     cond_inc(Assembler::zero, (address) counters-&gt;rebiased_lock_entry_count_addr(), mark_reg, temp_reg);
2533   }
2534   if (slow_case != NULL) {
2535     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2536     delayed()-&gt;nop();
2537   }
2538   ba_short(done);
2539 
2540   bind(try_revoke_bias);
2541   // The prototype mark in the klass doesn&#39;t have the bias bit set any
2542   // more, indicating that objects of this data type are not supposed
2543   // to be biased any more. We are going to try to reset the mark of
2544   // this object to the prototype value and fall through to the
2545   // CAS-based locking scheme. Note that if our CAS fails, it means
2546   // that another thread raced us for the privilege of revoking the
2547   // bias of this particular object, so it&#39;s okay to continue in the
2548   // normal locking code.
2549   //
2550   // FIXME: due to a lack of registers we currently blow away the age
2551   // bits in this situation. Should attempt to preserve them.
2552   load_klass(obj_reg, temp_reg);
2553   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2554   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2555   // Fall through to the normal CAS-based lock, because no matter what
2556   // the result of the above CAS, some thread must have succeeded in
2557   // removing the bias bit from the object&#39;s header.
2558   if (counters != NULL) {
2559     cmp(mark_reg, temp_reg);
2560     cond_inc(Assembler::zero, (address) counters-&gt;revoked_lock_entry_count_addr(), mark_reg, temp_reg);
2561   }
2562 
2563   bind(cas_label);
2564 }
2565 
2566 void MacroAssembler::biased_locking_exit (Address mark_addr, Register temp_reg, Label&amp; done,
2567                                           bool allow_delay_slot_filling) {
2568   // Check for biased locking unlock case, which is a no-op
2569   // Note: we do not have to check the thread ID for two reasons.
2570   // First, the interpreter checks for IllegalMonitorStateException at
2571   // a higher level. Second, if the bias was revoked while we held the
2572   // lock, the object could not be rebiased toward another thread, so
2573   // the bias bit would be clear.
2574   ld_ptr(mark_addr, temp_reg);
2575   and3(temp_reg, markWord::biased_lock_mask_in_place, temp_reg);
2576   cmp(temp_reg, markWord::biased_lock_pattern);
2577   brx(Assembler::equal, allow_delay_slot_filling, Assembler::pt, done);
2578   delayed();
2579   if (!allow_delay_slot_filling) {
2580     nop();
2581   }
2582 }
2583 
2584 
2585 // compiler_lock_object() and compiler_unlock_object() are direct transliterations
2586 // of i486.ad fast_lock() and fast_unlock().  See those methods for detailed comments.
2587 // The code could be tightened up considerably.
2588 //
2589 // box-&gt;dhw disposition - post-conditions at DONE_LABEL.
2590 // -   Successful inflated lock:  box-&gt;dhw != 0.
2591 //     Any non-zero value suffices.
2592 //     Consider G2_thread, rsp, boxReg, or markWord::unused_mark()
2593 // -   Successful Stack-lock: box-&gt;dhw == mark.
2594 //     box-&gt;dhw must contain the displaced mark word value
2595 // -   Failure -- icc.ZFlag == 0 and box-&gt;dhw is undefined.
2596 //     The slow-path enter() is responsible for setting
2597 //     box-&gt;dhw = NonZero (typically markWord::unused_mark()).
2598 // -   Biased: box-&gt;dhw is undefined
2599 //
2600 // SPARC refworkload performance - specifically jetstream and scimark - are
2601 // extremely sensitive to the size of the code emitted by compiler_lock_object
2602 // and compiler_unlock_object.  Critically, the key factor is code size, not path
2603 // length.  (Simply experiments to pad CLO with unexecuted NOPs demonstrte the
2604 // effect).
2605 
2606 
2607 void MacroAssembler::compiler_lock_object(Register Roop, Register Rmark,
2608                                           Register Rbox, Register Rscratch,
2609                                           BiasedLockingCounters* counters,
2610                                           bool try_bias) {
2611    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2612 
2613    verify_oop(Roop);
2614    Label done ;
2615 
2616    if (counters != NULL) {
2617      inc_counter((address) counters-&gt;total_entry_count_addr(), Rmark, Rscratch);
2618    }
2619 
2620    // Aggressively avoid the Store-before-CAS penalty
2621    // Defer the store into box-&gt;dhw until after the CAS
2622    Label IsInflated, Recursive ;
2623 
2624 // Anticipate CAS -- Avoid RTS-&gt;RTO upgrade
2625 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2626 
2627    ld_ptr(mark_addr, Rmark);           // fetch obj-&gt;mark
2628    // Triage: biased, stack-locked, neutral, inflated
2629 
2630    if (try_bias) {
2631      biased_locking_enter(Roop, Rmark, Rscratch, done, NULL, counters);
2632      // Invariant: if control reaches this point in the emitted stream
2633      // then Rmark has not been modified.
2634    }
2635    andcc(Rmark, 2, G0);
2636    brx(Assembler::notZero, false, Assembler::pn, IsInflated);
2637    delayed()-&gt;                         // Beware - dangling delay-slot
2638 
2639    // Try stack-lock acquisition.
2640    // Transiently install BUSY (0) encoding in the mark word.
2641    // if the CAS of 0 into the mark was successful then we execute:
2642    //   ST box-&gt;dhw  = mark   -- save fetched mark in on-stack basiclock box
2643    //   ST obj-&gt;mark = box    -- overwrite transient 0 value
2644    // This presumes TSO, of course.
2645 
2646    mov(0, Rscratch);
2647    or3(Rmark, markWord::unlocked_value, Rmark);
2648    assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2649    cas_ptr(mark_addr.base(), Rmark, Rscratch);
2650 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2651    cmp(Rscratch, Rmark);
2652    brx(Assembler::notZero, false, Assembler::pn, Recursive);
2653    delayed()-&gt;st_ptr(Rmark, Rbox, BasicLock::displaced_header_offset_in_bytes());
2654    if (counters != NULL) {
2655      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2656    }
2657    ba(done);
2658    delayed()-&gt;st_ptr(Rbox, mark_addr);
2659 
2660    bind(Recursive);
2661    // Stack-lock attempt failed - check for recursive stack-lock.
2662    // Tests show that we can remove the recursive case with no impact
2663    // on refworkload 0.83.  If we need to reduce the size of the code
2664    // emitted by compiler_lock_object() the recursive case is perfect
2665    // candidate.
2666    //
2667    // A more extreme idea is to always inflate on stack-lock recursion.
2668    // This lets us eliminate the recursive checks in compiler_lock_object
2669    // and compiler_unlock_object and the (box-&gt;dhw == 0) encoding.
2670    // A brief experiment - requiring changes to synchronizer.cpp, interpreter,
2671    // and showed a performance *increase*.  In the same experiment I eliminated
2672    // the fast-path stack-lock code from the interpreter and always passed
2673    // control to the &quot;slow&quot; operators in synchronizer.cpp.
2674 
2675    // RScratch contains the fetched obj-&gt;mark value from the failed CAS.
2676    sub(Rscratch, STACK_BIAS, Rscratch);
2677    sub(Rscratch, SP, Rscratch);
2678    assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
2679    andcc(Rscratch, 0xfffff003, Rscratch);
2680    if (counters != NULL) {
2681      // Accounting needs the Rscratch register
2682      st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2683      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2684      ba_short(done);
2685    } else {
2686      ba(done);
2687      delayed()-&gt;st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2688    }
2689 
2690    bind   (IsInflated);
2691 
2692    // Try to CAS m-&gt;owner from null to Self
2693    // Invariant: if we acquire the lock then _recursions should be 0.
2694    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2695    mov(G2_thread, Rscratch);
2696    cas_ptr(Rmark, G0, Rscratch);
2697    andcc(Rscratch, Rscratch, G0);             // set ICCs for done: icc.zf iff success
2698    // set icc.zf : 1=success 0=failure
2699    // ST box-&gt;displaced_header = NonZero.
2700    // Any non-zero value suffices:
2701    //    markWord::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.
2702    st_ptr(Rbox, Rbox, BasicLock::displaced_header_offset_in_bytes());
2703    // Intentional fall-through into done
2704 
2705    bind   (done);
2706 }
2707 
2708 void MacroAssembler::compiler_unlock_object(Register Roop, Register Rmark,
2709                                             Register Rbox, Register Rscratch,
2710                                             bool try_bias) {
2711    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2712 
2713    Label done ;
2714 
2715    // Beware ... If the aggregate size of the code emitted by CLO and CUO is
2716    // is too large performance rolls abruptly off a cliff.
2717    // This could be related to inlining policies, code cache management, or
2718    // I$ effects.
2719    Label LStacked ;
2720 
2721    if (try_bias) {
2722       // TODO: eliminate redundant LDs of obj-&gt;mark
2723       biased_locking_exit(mark_addr, Rscratch, done);
2724    }
2725 
2726    ld_ptr(Roop, oopDesc::mark_offset_in_bytes(), Rmark);
2727    ld_ptr(Rbox, BasicLock::displaced_header_offset_in_bytes(), Rscratch);
2728    andcc(Rscratch, Rscratch, G0);
2729    brx(Assembler::zero, false, Assembler::pn, done);
2730    delayed()-&gt;nop();      // consider: relocate fetch of mark, above, into this DS
2731    andcc(Rmark, 2, G0);
2732    brx(Assembler::zero, false, Assembler::pt, LStacked);
2733    delayed()-&gt;nop();
2734 
2735    // It&#39;s inflated
2736    // Conceptually we need a #loadstore|#storestore &quot;release&quot; MEMBAR before
2737    // the ST of 0 into _owner which releases the lock.  This prevents loads
2738    // and stores within the critical section from reordering (floating)
2739    // past the store that releases the lock.  But TSO is a strong memory model
2740    // and that particular flavor of barrier is a noop, so we can safely elide it.
2741    // Note that we use 1-0 locking by default for the inflated case.  We
2742    // close the resultant (and rare) race by having contended threads in
2743    // monitorenter periodically poll _owner.
2744 
2745    // 1-0 form : avoids CAS and MEMBAR in the common case
2746    // Do not bother to ratify that m-&gt;Owner == Self.
2747    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), Rbox);
2748    orcc(Rbox, G0, G0);
2749    brx(Assembler::notZero, false, Assembler::pn, done);
2750    delayed()-&gt;
2751    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)), Rscratch);
2752    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)), Rbox);
2753    orcc(Rbox, Rscratch, G0);
2754    brx(Assembler::zero, false, Assembler::pt, done);
2755    delayed()-&gt;
2756    st_ptr(G0, Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
2757 
2758    membar(StoreLoad);
2759    // Check that _succ is (or remains) non-zero
2760    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), Rscratch);
2761    andcc(Rscratch, Rscratch, G0);
2762    brx(Assembler::notZero, false, Assembler::pt, done);
2763    delayed()-&gt;andcc(G0, G0, G0);
2764    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2765    mov(G2_thread, Rscratch);
2766    cas_ptr(Rmark, G0, Rscratch);
2767    cmp(Rscratch, G0);
2768    // invert icc.zf and goto done
2769    // A slightly better v8+/v9 idiom would be the following:
2770    //   movrnz Rscratch,1,Rscratch
2771    //   ba done
2772    //   xorcc Rscratch,1,G0
2773    // In v8+ mode the idiom would be valid IFF Rscratch was a G or O register
2774    brx(Assembler::notZero, false, Assembler::pt, done);
2775    delayed()-&gt;cmp(G0, G0);
2776    br(Assembler::always, false, Assembler::pt, done);
2777    delayed()-&gt;cmp(G0, 1);
2778 
2779    bind   (LStacked);
2780    // Consider: we could replace the expensive CAS in the exit
2781    // path with a simple ST of the displaced mark value fetched from
2782    // the on-stack basiclock box.  That admits a race where a thread T2
2783    // in the slow lock path -- inflating with monitor M -- could race a
2784    // thread T1 in the fast unlock path, resulting in a missed wakeup for T2.
2785    // More precisely T1 in the stack-lock unlock path could &quot;stomp&quot; the
2786    // inflated mark value M installed by T2, resulting in an orphan
2787    // object monitor M and T2 becoming stranded.  We can remedy that situation
2788    // by having T2 periodically poll the object&#39;s mark word using timed wait
2789    // operations.  If T2 discovers that a stomp has occurred it vacates
2790    // the monitor M and wakes any other threads stranded on the now-orphan M.
2791    // In addition the monitor scavenger, which performs deflation,
2792    // would also need to check for orpan monitors and stranded threads.
2793    //
2794    // Finally, inflation is also used when T2 needs to assign a hashCode
2795    // to O and O is stack-locked by T1.  The &quot;stomp&quot; race could cause
2796    // an assigned hashCode value to be lost.  We can avoid that condition
2797    // and provide the necessary hashCode stability invariants by ensuring
2798    // that hashCode generation is idempotent between copying GCs.
2799    // For example we could compute the hashCode of an object O as
2800    // O&#39;s heap address XOR some high quality RNG value that is refreshed
2801    // at GC-time.  The monitor scavenger would install the hashCode
2802    // found in any orphan monitors.  Again, the mechanism admits a
2803    // lost-update &quot;stomp&quot; WAW race but detects and recovers as needed.
2804    //
2805    // A prototype implementation showed excellent results, although
2806    // the scavenger and timeout code was rather involved.
2807 
2808    cas_ptr(mark_addr.base(), Rbox, Rscratch);
2809    cmp(Rbox, Rscratch);
2810    // Intentional fall through into done ...
2811 
2812    bind(done);
2813 }
2814 
2815 void MacroAssembler::verify_tlab() {
2816 #ifdef ASSERT
2817   if (UseTLAB &amp;&amp; VerifyOops) {
2818     Label next, next2, ok;
2819     Register t1 = L0;
2820     Register t2 = L1;
2821     Register t3 = L2;
2822 
2823     save_frame(0);
2824     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2825     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_start_offset()), t2);
2826     or3(t1, t2, t3);
2827     cmp_and_br_short(t1, t2, Assembler::greaterEqual, Assembler::pn, next);
2828     STOP(&quot;assert(top &gt;= start)&quot;);
2829     should_not_reach_here();
2830 
2831     bind(next);
2832     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2833     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), t2);
2834     or3(t3, t2, t3);
2835     cmp_and_br_short(t1, t2, Assembler::lessEqual, Assembler::pn, next2);
2836     STOP(&quot;assert(top &lt;= end)&quot;);
2837     should_not_reach_here();
2838 
2839     bind(next2);
2840     and3(t3, MinObjAlignmentInBytesMask, t3);
2841     cmp_and_br_short(t3, 0, Assembler::lessEqual, Assembler::pn, ok);
2842     STOP(&quot;assert(aligned)&quot;);
2843     should_not_reach_here();
2844 
2845     bind(ok);
2846     restore();
2847   }
2848 #endif
2849 }
2850 
2851 
2852 void MacroAssembler::eden_allocate(
2853   Register obj,                        // result: pointer to object after successful allocation
2854   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2855   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2856   Register t1,                         // temp register
2857   Register t2,                         // temp register
2858   Label&amp;   slow_case                   // continuation point if fast allocation fails
2859 ){
2860   // make sure arguments make sense
2861   assert_different_registers(obj, var_size_in_bytes, t1, t2);
2862   assert(0 &lt;= con_size_in_bytes &amp;&amp; Assembler::is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
2863   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
2864 
2865   if (!Universe::heap()-&gt;supports_inline_contig_alloc()) {
2866     // No allocation in the shared eden.
2867     ba(slow_case);
2868     delayed()-&gt;nop();
2869   } else {
2870     // get eden boundaries
2871     // note: we need both top &amp; top_addr!
2872     const Register top_addr = t1;
2873     const Register end      = t2;
2874 
2875     CollectedHeap* ch = Universe::heap();
2876     set((intx)ch-&gt;top_addr(), top_addr);
2877     intx delta = (intx)ch-&gt;end_addr() - (intx)ch-&gt;top_addr();
2878     ld_ptr(top_addr, delta, end);
2879     ld_ptr(top_addr, 0, obj);
2880 
2881     // try to allocate
2882     Label retry;
2883     bind(retry);
2884 #ifdef ASSERT
2885     // make sure eden top is properly aligned
2886     {
2887       Label L;
2888       btst(MinObjAlignmentInBytesMask, obj);
2889       br(Assembler::zero, false, Assembler::pt, L);
2890       delayed()-&gt;nop();
2891       STOP(&quot;eden top is not properly aligned&quot;);
2892       bind(L);
2893     }
2894 #endif // ASSERT
2895     const Register free = end;
2896     sub(end, obj, free);                                   // compute amount of free space
2897     if (var_size_in_bytes-&gt;is_valid()) {
2898       // size is unknown at compile time
2899       cmp(free, var_size_in_bytes);
2900       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2901       delayed()-&gt;add(obj, var_size_in_bytes, end);
2902     } else {
2903       // size is known at compile time
2904       cmp(free, con_size_in_bytes);
2905       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2906       delayed()-&gt;add(obj, con_size_in_bytes, end);
2907     }
2908     // Compare obj with the value at top_addr; if still equal, swap the value of
2909     // end with the value at top_addr. If not equal, read the value at top_addr
2910     // into end.
2911     cas_ptr(top_addr, obj, end);
2912     // if someone beat us on the allocation, try again, otherwise continue
2913     cmp(obj, end);
2914     brx(Assembler::notEqual, false, Assembler::pn, retry);
2915     delayed()-&gt;mov(end, obj);                              // nop if successfull since obj == end
2916 
2917 #ifdef ASSERT
2918     // make sure eden top is properly aligned
2919     {
2920       Label L;
2921       const Register top_addr = t1;
2922 
2923       set((intx)ch-&gt;top_addr(), top_addr);
2924       ld_ptr(top_addr, 0, top_addr);
2925       btst(MinObjAlignmentInBytesMask, top_addr);
2926       br(Assembler::zero, false, Assembler::pt, L);
2927       delayed()-&gt;nop();
2928       STOP(&quot;eden top is not properly aligned&quot;);
2929       bind(L);
2930     }
2931 #endif // ASSERT
2932   }
2933 }
2934 
2935 
2936 void MacroAssembler::tlab_allocate(
2937   Register obj,                        // result: pointer to object after successful allocation
2938   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2939   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2940   Register t1,                         // temp register
2941   Label&amp;   slow_case                   // continuation point if fast allocation fails
2942 ){
2943   // make sure arguments make sense
2944   assert_different_registers(obj, var_size_in_bytes, t1);
2945   assert(0 &lt;= con_size_in_bytes &amp;&amp; is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
2946   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
2947 
2948   const Register free  = t1;
2949 
2950   verify_tlab();
2951 
2952   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), obj);
2953 
2954   // calculate amount of free space
2955   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), free);
2956   sub(free, obj, free);
2957 
2958   Label done;
2959   if (var_size_in_bytes == noreg) {
2960     cmp(free, con_size_in_bytes);
2961   } else {
2962     cmp(free, var_size_in_bytes);
2963   }
2964   br(Assembler::less, false, Assembler::pn, slow_case);
2965   // calculate the new top pointer
2966   if (var_size_in_bytes == noreg) {
2967     delayed()-&gt;add(obj, con_size_in_bytes, free);
2968   } else {
2969     delayed()-&gt;add(obj, var_size_in_bytes, free);
2970   }
2971 
2972   bind(done);
2973 
2974 #ifdef ASSERT
2975   // make sure new free pointer is properly aligned
2976   {
2977     Label L;
2978     btst(MinObjAlignmentInBytesMask, free);
2979     br(Assembler::zero, false, Assembler::pt, L);
2980     delayed()-&gt;nop();
2981     STOP(&quot;updated TLAB free is not properly aligned&quot;);
2982     bind(L);
2983   }
2984 #endif // ASSERT
2985 
2986   // update the tlab top pointer
2987   st_ptr(free, G2_thread, in_bytes(JavaThread::tlab_top_offset()));
2988   verify_tlab();
2989 }
2990 
2991 void MacroAssembler::zero_memory(Register base, Register index) {
2992   assert_different_registers(base, index);
2993   Label loop;
2994   bind(loop);
2995   subcc(index, HeapWordSize, index);
2996   brx(Assembler::greaterEqual, true, Assembler::pt, loop);
2997   delayed()-&gt;st_ptr(G0, base, index);
2998 }
2999 
3000 void MacroAssembler::incr_allocated_bytes(RegisterOrConstant size_in_bytes,
3001                                           Register t1, Register t2) {
3002   // Bump total bytes allocated by this thread
3003   assert(t1-&gt;is_global(), &quot;must be global reg&quot;); // so all 64 bits are saved on a context switch
3004   assert_different_registers(size_in_bytes.register_or_noreg(), t1, t2);
3005   // v8 support has gone the way of the dodo
3006   ldx(G2_thread, in_bytes(JavaThread::allocated_bytes_offset()), t1);
3007   add(t1, ensure_simm13_or_reg(size_in_bytes, t2), t1);
3008   stx(t1, G2_thread, in_bytes(JavaThread::allocated_bytes_offset()));
3009 }
3010 
3011 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
3012   switch (cond) {
3013     // Note some conditions are synonyms for others
3014     case Assembler::never:                return Assembler::always;
3015     case Assembler::zero:                 return Assembler::notZero;
3016     case Assembler::lessEqual:            return Assembler::greater;
3017     case Assembler::less:                 return Assembler::greaterEqual;
3018     case Assembler::lessEqualUnsigned:    return Assembler::greaterUnsigned;
3019     case Assembler::lessUnsigned:         return Assembler::greaterEqualUnsigned;
3020     case Assembler::negative:             return Assembler::positive;
3021     case Assembler::overflowSet:          return Assembler::overflowClear;
3022     case Assembler::always:               return Assembler::never;
3023     case Assembler::notZero:              return Assembler::zero;
3024     case Assembler::greater:              return Assembler::lessEqual;
3025     case Assembler::greaterEqual:         return Assembler::less;
3026     case Assembler::greaterUnsigned:      return Assembler::lessEqualUnsigned;
3027     case Assembler::greaterEqualUnsigned: return Assembler::lessUnsigned;
3028     case Assembler::positive:             return Assembler::negative;
3029     case Assembler::overflowClear:        return Assembler::overflowSet;
3030   }
3031 
3032   ShouldNotReachHere(); return Assembler::overflowClear;
3033 }
3034 
3035 void MacroAssembler::cond_inc(Assembler::Condition cond, address counter_ptr,
3036                               Register Rtmp1, Register Rtmp2 /*, Register Rtmp3, Register Rtmp4 */) {
3037   Condition negated_cond = negate_condition(cond);
3038   Label L;
3039   brx(negated_cond, false, Assembler::pt, L);
3040   delayed()-&gt;nop();
3041   inc_counter(counter_ptr, Rtmp1, Rtmp2);
3042   bind(L);
3043 }
3044 
3045 void MacroAssembler::inc_counter(address counter_addr, Register Rtmp1, Register Rtmp2) {
3046   AddressLiteral addrlit(counter_addr);
3047   sethi(addrlit, Rtmp1);                 // Move hi22 bits into temporary register.
3048   Address addr(Rtmp1, addrlit.low10());  // Build an address with low10 bits.
3049   ld(addr, Rtmp2);
3050   inc(Rtmp2);
3051   st(Rtmp2, addr);
3052 }
3053 
3054 void MacroAssembler::inc_counter(int* counter_addr, Register Rtmp1, Register Rtmp2) {
3055   inc_counter((address) counter_addr, Rtmp1, Rtmp2);
3056 }
3057 
3058 SkipIfEqual::SkipIfEqual(
3059     MacroAssembler* masm, Register temp, const bool* flag_addr,
3060     Assembler::Condition condition) {
3061   _masm = masm;
3062   AddressLiteral flag(flag_addr);
3063   _masm-&gt;sethi(flag, temp);
3064   _masm-&gt;ldub(temp, flag.low10(), temp);
3065   _masm-&gt;tst(temp);
3066   _masm-&gt;br(condition, false, Assembler::pt, _label);
3067   _masm-&gt;delayed()-&gt;nop();
3068 }
3069 
3070 SkipIfEqual::~SkipIfEqual() {
3071   _masm-&gt;bind(_label);
3072 }
3073 
3074 void MacroAssembler::bang_stack_with_offset(int offset) {
3075   // stack grows down, caller passes positive offset
3076   assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
3077   set((-offset)+STACK_BIAS, G3_scratch);
3078   st(G0, SP, G3_scratch);
3079 }
3080 
3081 // Writes to stack successive pages until offset reached to check for
3082 // stack overflow + shadow pages.  This clobbers tsp and scratch.
3083 void MacroAssembler::bang_stack_size(Register Rsize, Register Rtsp,
3084                                      Register Rscratch) {
3085   // Use stack pointer in temp stack pointer
3086   mov(SP, Rtsp);
3087 
3088   // Bang stack for total size given plus stack shadow page size.
3089   // Bang one page at a time because a large size can overflow yellow and
3090   // red zones (the bang will fail but stack overflow handling can&#39;t tell that
3091   // it was a stack overflow bang vs a regular segv).
3092   int offset = os::vm_page_size();
3093   Register Roffset = Rscratch;
3094 
3095   Label loop;
3096   bind(loop);
3097   set((-offset)+STACK_BIAS, Rscratch);
3098   st(G0, Rtsp, Rscratch);
3099   set(offset, Roffset);
3100   sub(Rsize, Roffset, Rsize);
3101   cmp(Rsize, G0);
3102   br(Assembler::greater, false, Assembler::pn, loop);
3103   delayed()-&gt;sub(Rtsp, Roffset, Rtsp);
3104 
3105   // Bang down shadow pages too.
3106   // At this point, (tmp-0) is the last address touched, so don&#39;t
3107   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
3108   // was post-decremented.)  Skip this address by starting at i=1, and
3109   // touch a few more pages below.  N.B.  It is important to touch all
3110   // the way down to and including i=StackShadowPages.
3111   for (int i = 1; i &lt; JavaThread::stack_shadow_zone_size() / os::vm_page_size(); i++) {
3112     set((-i*offset)+STACK_BIAS, Rscratch);
3113     st(G0, Rtsp, Rscratch);
3114   }
3115 }
3116 
3117 void MacroAssembler::reserved_stack_check() {
3118   // testing if reserved zone needs to be enabled
3119   Label no_reserved_zone_enabling;
3120 
3121   ld_ptr(G2_thread, JavaThread::reserved_stack_activation_offset(), G4_scratch);
3122   cmp_and_brx_short(SP, G4_scratch, Assembler::lessUnsigned, Assembler::pt, no_reserved_zone_enabling);
3123 
3124   call_VM_leaf(L0, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), G2_thread);
3125 
3126   AddressLiteral stub(StubRoutines::throw_delayed_StackOverflowError_entry());
3127   jump_to(stub, G4_scratch);
3128   delayed()-&gt;restore();
3129 
3130   should_not_reach_here();
3131 
3132   bind(no_reserved_zone_enabling);
3133 }
3134 // ((OopHandle)result).resolve();
3135 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3136   // OopHandle::resolve is an indirection.
3137   access_load_at(T_OBJECT, IN_NATIVE, Address(result, 0), result, tmp);
3138 }
3139 
3140 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
3141   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3142   ld_ptr(method, in_bytes(Method::const_offset()), mirror);
3143   ld_ptr(mirror, in_bytes(ConstMethod::constants_offset()), mirror);
3144   ld_ptr(mirror, ConstantPool::pool_holder_offset_in_bytes(), mirror);
3145   ld_ptr(mirror, mirror_offset, mirror);
3146   resolve_oop_handle(mirror, tmp);
3147 }
3148 
3149 void MacroAssembler::load_klass(Register src_oop, Register klass) {
3150   // The number of bytes in this code is used by
3151   // MachCallDynamicJavaNode::ret_addr_offset()
3152   // if this changes, change that.
3153   if (UseCompressedClassPointers) {
3154     lduw(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3155     decode_klass_not_null(klass);
3156   } else {
3157     ld_ptr(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3158   }
3159 }
3160 
3161 void MacroAssembler::store_klass(Register klass, Register dst_oop) {
3162   if (UseCompressedClassPointers) {
3163     assert(dst_oop != klass, &quot;not enough registers&quot;);
3164     encode_klass_not_null(klass);
3165     st(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3166   } else {
3167     st_ptr(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3168   }
3169 }
3170 
3171 void MacroAssembler::store_klass_gap(Register s, Register d) {
3172   if (UseCompressedClassPointers) {
3173     assert(s != d, &quot;not enough registers&quot;);
3174     st(s, d, oopDesc::klass_gap_offset_in_bytes());
3175   }
3176 }
3177 
3178 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
3179                                      Register src, Address dst, Register tmp) {
3180   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3181   decorators = AccessInternal::decorator_fixup(decorators);
3182   bool as_raw = (decorators &amp; AS_RAW) != 0;
3183   if (as_raw) {
3184     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, src, dst, tmp);
3185   } else {
3186     bs-&gt;store_at(this, decorators, type, src, dst, tmp);
3187   }
3188 }
3189 
3190 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
3191                                     Address src, Register dst, Register tmp) {
3192   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3193   decorators = AccessInternal::decorator_fixup(decorators);
3194   bool as_raw = (decorators &amp; AS_RAW) != 0;
3195   if (as_raw) {
3196     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, src, dst, tmp);
3197   } else {
3198     bs-&gt;load_at(this, decorators, type, src, dst, tmp);
3199   }
3200 }
3201 
3202 void MacroAssembler::load_heap_oop(const Address&amp; s, Register d, Register tmp, DecoratorSet decorators) {
3203   access_load_at(T_OBJECT, IN_HEAP | decorators, s, d, tmp);
3204 }
3205 
3206 void MacroAssembler::load_heap_oop(Register s1, Register s2, Register d, Register tmp, DecoratorSet decorators) {
3207   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2), d, tmp);
3208 }
3209 
3210 void MacroAssembler::load_heap_oop(Register s1, int simm13a, Register d, Register tmp, DecoratorSet decorators) {
3211   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, simm13a), d, tmp);
3212 }
3213 
3214 void MacroAssembler::load_heap_oop(Register s1, RegisterOrConstant s2, Register d, Register tmp, DecoratorSet decorators) {
3215   if (s2.is_constant()) {
3216     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_constant()), d, tmp);
3217   } else {
3218     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_register()), d, tmp);
3219   }
3220 }
3221 
3222 void MacroAssembler::store_heap_oop(Register d, Register s1, Register s2, Register tmp, DecoratorSet decorators) {
3223   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, s2), tmp);
3224 }
3225 
3226 void MacroAssembler::store_heap_oop(Register d, Register s1, int simm13a, Register tmp, DecoratorSet decorators) {
3227   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, simm13a), tmp);
3228 }
3229 
3230 void MacroAssembler::store_heap_oop(Register d, const Address&amp; a, int offset, Register tmp, DecoratorSet decorators) {
3231   if (a.has_index()) {
3232     assert(!a.has_disp(), &quot;not supported yet&quot;);
3233     assert(offset == 0, &quot;not supported yet&quot;);
3234     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.index()), tmp);
3235   } else {
3236     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.disp() + offset), tmp);
3237   }
3238 }
3239 
3240 
3241 void MacroAssembler::encode_heap_oop(Register src, Register dst) {
3242   assert (UseCompressedOops, &quot;must be compressed&quot;);
3243   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3244   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3245   verify_oop(src);
3246   if (CompressedOops::base() == NULL) {
3247     srlx(src, LogMinObjAlignmentInBytes, dst);
3248     return;
3249   }
3250   Label done;
3251   if (src == dst) {
3252     // optimize for frequent case src == dst
3253     bpr(rc_nz, true, Assembler::pt, src, done);
3254     delayed() -&gt; sub(src, G6_heapbase, dst); // annuled if not taken
3255     bind(done);
3256     srlx(src, LogMinObjAlignmentInBytes, dst);
3257   } else {
3258     bpr(rc_z, false, Assembler::pn, src, done);
3259     delayed() -&gt; mov(G0, dst);
3260     // could be moved before branch, and annulate delay,
3261     // but may add some unneeded work decoding null
3262     sub(src, G6_heapbase, dst);
3263     srlx(dst, LogMinObjAlignmentInBytes, dst);
3264     bind(done);
3265   }
3266 }
3267 
3268 
3269 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3270   assert (UseCompressedOops, &quot;must be compressed&quot;);
3271   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3272   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3273   verify_oop(r);
3274   if (CompressedOops::base() != NULL)
3275     sub(r, G6_heapbase, r);
3276   srlx(r, LogMinObjAlignmentInBytes, r);
3277 }
3278 
3279 void MacroAssembler::encode_heap_oop_not_null(Register src, Register dst) {
3280   assert (UseCompressedOops, &quot;must be compressed&quot;);
3281   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3282   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3283   verify_oop(src);
3284   if (CompressedOops::base() == NULL) {
3285     srlx(src, LogMinObjAlignmentInBytes, dst);
3286   } else {
3287     sub(src, G6_heapbase, dst);
3288     srlx(dst, LogMinObjAlignmentInBytes, dst);
3289   }
3290 }
3291 
3292 // Same algorithm as oops.inline.hpp decode_heap_oop.
3293 void  MacroAssembler::decode_heap_oop(Register src, Register dst) {
3294   assert (UseCompressedOops, &quot;must be compressed&quot;);
3295   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3296   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3297   sllx(src, LogMinObjAlignmentInBytes, dst);
3298   if (CompressedOops::base() != NULL) {
3299     Label done;
3300     bpr(rc_nz, true, Assembler::pt, dst, done);
3301     delayed() -&gt; add(dst, G6_heapbase, dst); // annuled if not taken
3302     bind(done);
3303   }
3304   verify_oop(dst);
3305 }
3306 
3307 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3308   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3309   // pd_code_size_limit.
3310   // Also do not verify_oop as this is called by verify_oop.
3311   assert (UseCompressedOops, &quot;must be compressed&quot;);
3312   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3313   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3314   sllx(r, LogMinObjAlignmentInBytes, r);
3315   if (CompressedOops::base() != NULL)
3316     add(r, G6_heapbase, r);
3317 }
3318 
3319 void  MacroAssembler::decode_heap_oop_not_null(Register src, Register dst) {
3320   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3321   // pd_code_size_limit.
3322   // Also do not verify_oop as this is called by verify_oop.
3323   assert (UseCompressedOops, &quot;must be compressed&quot;);
3324   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3325   sllx(src, LogMinObjAlignmentInBytes, dst);
3326   if (CompressedOops::base() != NULL)
3327     add(dst, G6_heapbase, dst);
3328 }
3329 
3330 void MacroAssembler::encode_klass_not_null(Register r) {
3331   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3332   if (CompressedKlassPointers::base() != NULL) {
3333     assert(r != G6_heapbase, &quot;bad register choice&quot;);
3334     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3335     sub(r, G6_heapbase, r);
3336     if (CompressedKlassPointers::shift() != 0) {
3337       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
3338       srlx(r, LogKlassAlignmentInBytes, r);
3339     }
3340     reinit_heapbase();
3341   } else {
3342     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3343     srlx(r, CompressedKlassPointers::shift(), r);
3344   }
3345 }
3346 
3347 void MacroAssembler::encode_klass_not_null(Register src, Register dst) {
3348   if (src == dst) {
3349     encode_klass_not_null(src);
3350   } else {
3351     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3352     if (CompressedKlassPointers::base() != NULL) {
3353       set((intptr_t)CompressedKlassPointers::base(), dst);
3354       sub(src, dst, dst);
3355       if (CompressedKlassPointers::shift() != 0) {
3356         srlx(dst, LogKlassAlignmentInBytes, dst);
3357       }
3358     } else {
3359       // shift src into dst
3360       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3361       srlx(src, CompressedKlassPointers::shift(), dst);
3362     }
3363   }
3364 }
3365 
3366 // Function instr_size_for_decode_klass_not_null() counts the instructions
3367 // generated by decode_klass_not_null() and reinit_heapbase().  Hence, if
3368 // the instructions they generate change, then this method needs to be updated.
3369 int MacroAssembler::instr_size_for_decode_klass_not_null() {
3370   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3371   int num_instrs = 1;  // shift src,dst or add
3372   if (CompressedKlassPointers::base() != NULL) {
3373     // set + add + set
3374     num_instrs += insts_for_internal_set((intptr_t)CompressedKlassPointers::base()) +
3375                   insts_for_internal_set((intptr_t)CompressedOops::ptrs_base());
3376     if (CompressedKlassPointers::shift() != 0) {
3377       num_instrs += 1;  // sllx
3378     }
3379   }
3380   return num_instrs * BytesPerInstWord;
3381 }
3382 
3383 // !!! If the instructions that get generated here change then function
3384 // instr_size_for_decode_klass_not_null() needs to get updated.
3385 void  MacroAssembler::decode_klass_not_null(Register r) {
3386   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3387   // pd_code_size_limit.
3388   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3389   if (CompressedKlassPointers::base() != NULL) {
3390     assert(r != G6_heapbase, &quot;bad register choice&quot;);
3391     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3392     if (CompressedKlassPointers::shift() != 0)
3393       sllx(r, LogKlassAlignmentInBytes, r);
3394     add(r, G6_heapbase, r);
3395     reinit_heapbase();
3396   } else {
3397     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3398     sllx(r, CompressedKlassPointers::shift(), r);
3399   }
3400 }
3401 
3402 void  MacroAssembler::decode_klass_not_null(Register src, Register dst) {
3403   if (src == dst) {
3404     decode_klass_not_null(src);
3405   } else {
3406     // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3407     // pd_code_size_limit.
3408     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3409     if (CompressedKlassPointers::base() != NULL) {
3410       if (CompressedKlassPointers::shift() != 0) {
3411         assert((src != G6_heapbase) &amp;&amp; (dst != G6_heapbase), &quot;bad register choice&quot;);
3412         set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3413         sllx(src, LogKlassAlignmentInBytes, dst);
3414         add(dst, G6_heapbase, dst);
3415         reinit_heapbase();
3416       } else {
3417         set((intptr_t)CompressedKlassPointers::base(), dst);
3418         add(src, dst, dst);
3419       }
3420     } else {
3421       // shift/mov src into dst.
3422       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3423       sllx(src, CompressedKlassPointers::shift(), dst);
3424     }
3425   }
3426 }
3427 
3428 void MacroAssembler::reinit_heapbase() {
3429   if (UseCompressedOops || UseCompressedClassPointers) {
3430     if (Universe::heap() != NULL) {
3431       set((intptr_t)CompressedOops::ptrs_base(), G6_heapbase);
3432     } else {
3433       AddressLiteral base(CompressedOops::ptrs_base_addr());
3434       load_ptr_contents(base, G6_heapbase);
3435     }
3436   }
3437 }
3438 
3439 #ifdef COMPILER2
3440 
3441 // Compress char[] to byte[] by compressing 16 bytes at once. Return 0 on failure.
3442 void MacroAssembler::string_compress_16(Register src, Register dst, Register cnt, Register result,
3443                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4,
3444                                         FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, Label&amp; Ldone) {
3445   Label Lloop, Lslow;
3446   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);
3447   assert_different_registers(src, dst, cnt, tmp1, tmp2, tmp3, tmp4, result);
3448   assert_different_registers(ftmp1, ftmp2, ftmp3);
3449 
3450   // Check if cnt &gt;= 8 (= 16 bytes)
3451   cmp(cnt, 8);
3452   br(Assembler::less, false, Assembler::pn, Lslow);
3453   delayed()-&gt;mov(cnt, result); // copy count
3454 
3455   // Check for 8-byte alignment of src and dst
3456   or3(src, dst, tmp1);
3457   andcc(tmp1, 7, G0);
3458   br(Assembler::notZero, false, Assembler::pn, Lslow);
3459   delayed()-&gt;nop();
3460 
3461   // Set mask for bshuffle instruction
3462   Register mask = tmp4;
3463   set(0x13579bdf, mask);
3464   bmask(mask, G0, G0);
3465 
3466   // Set mask to 0xff00 ff00 ff00 ff00 to check for non-latin1 characters
3467   Assembler::sethi(0xff00fc00, mask); // mask = 0x0000 0000 ff00 fc00
3468   add(mask, 0x300, mask);             // mask = 0x0000 0000 ff00 ff00
3469   sllx(mask, 32, tmp1);               // tmp1 = 0xff00 ff00 0000 0000
3470   or3(mask, tmp1, mask);              // mask = 0xff00 ff00 ff00 ff00
3471 
3472   // Load first 8 bytes
3473   ldx(src, 0, tmp1);
3474 
3475   bind(Lloop);
3476   // Load next 8 bytes
3477   ldx(src, 8, tmp2);
3478 
3479   // Check for non-latin1 character by testing if the most significant byte of a char is set.
3480   // Although we have to move the data between integer and floating point registers, this is
3481   // still faster than the corresponding VIS instructions (ford/fand/fcmpd).
3482   or3(tmp1, tmp2, tmp3);
3483   btst(tmp3, mask);
3484   // annul zeroing if branch is not taken to preserve original count
3485   brx(Assembler::notZero, true, Assembler::pn, Ldone);
3486   delayed()-&gt;mov(G0, result); // 0 - failed
3487 
3488   // Move bytes into float register
3489   movxtod(tmp1, ftmp1);
3490   movxtod(tmp2, ftmp2);
3491 
3492   // Compress by copying one byte per char from ftmp1 and ftmp2 to ftmp3
3493   bshuffle(ftmp1, ftmp2, ftmp3);
3494   stf(FloatRegisterImpl::D, ftmp3, dst, 0);
3495 
3496   // Increment addresses and decrement count
3497   inc(src, 16);
3498   inc(dst, 8);
3499   dec(cnt, 8);
3500 
3501   cmp(cnt, 8);
3502   // annul LDX if branch is not taken to prevent access past end of string
3503   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);
3504   delayed()-&gt;ldx(src, 0, tmp1);
3505 
3506   // Fallback to slow version
3507   bind(Lslow);
3508 }
3509 
3510 // Compress char[] to byte[]. Return 0 on failure.
3511 void MacroAssembler::string_compress(Register src, Register dst, Register cnt, Register result, Register tmp, Label&amp; Ldone) {
3512   Label Lloop;
3513   assert_different_registers(src, dst, cnt, tmp, result);
3514 
3515   lduh(src, 0, tmp);
3516 
3517   bind(Lloop);
3518   inc(src, sizeof(jchar));
3519   cmp(tmp, 0xff);
3520   // annul zeroing if branch is not taken to preserve original count
3521   br(Assembler::greater, true, Assembler::pn, Ldone); // don&#39;t check xcc
3522   delayed()-&gt;mov(G0, result); // 0 - failed
3523   deccc(cnt);
3524   stb(tmp, dst, 0);
3525   inc(dst);
3526   // annul LDUH if branch is not taken to prevent access past end of string
3527   br(Assembler::notZero, true, Assembler::pt, Lloop);
3528   delayed()-&gt;lduh(src, 0, tmp); // hoisted
3529 }
3530 
3531 // Inflate byte[] to char[] by inflating 16 bytes at once.
3532 void MacroAssembler::string_inflate_16(Register src, Register dst, Register cnt, Register tmp,
3533                                        FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, FloatRegister ftmp4, Label&amp; Ldone) {
3534   Label Lloop, Lslow;
3535   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);
3536   assert_different_registers(src, dst, cnt, tmp);
3537   assert_different_registers(ftmp1, ftmp2, ftmp3, ftmp4);
3538 
3539   // Check if cnt &gt;= 8 (= 16 bytes)
3540   cmp(cnt, 8);
3541   br(Assembler::less, false, Assembler::pn, Lslow);
3542   delayed()-&gt;nop();
3543 
3544   // Check for 8-byte alignment of src and dst
3545   or3(src, dst, tmp);
3546   andcc(tmp, 7, G0);
3547   br(Assembler::notZero, false, Assembler::pn, Lslow);
3548   // Initialize float register to zero
3549   FloatRegister zerof = ftmp4;
3550   delayed()-&gt;fzero(FloatRegisterImpl::D, zerof);
3551 
3552   // Load first 8 bytes
3553   ldf(FloatRegisterImpl::D, src, 0, ftmp1);
3554 
3555   bind(Lloop);
3556   inc(src, 8);
3557   dec(cnt, 8);
3558 
3559   // Inflate the string by interleaving each byte from the source array
3560   // with a zero byte and storing the result in the destination array.
3561   fpmerge(zerof, ftmp1-&gt;successor(), ftmp2);
3562   stf(FloatRegisterImpl::D, ftmp2, dst, 8);
3563   fpmerge(zerof, ftmp1, ftmp3);
3564   stf(FloatRegisterImpl::D, ftmp3, dst, 0);
3565 
3566   inc(dst, 16);
3567 
3568   cmp(cnt, 8);
3569   // annul LDX if branch is not taken to prevent access past end of string
3570   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);
3571   delayed()-&gt;ldf(FloatRegisterImpl::D, src, 0, ftmp1);
3572 
3573   // Fallback to slow version
3574   bind(Lslow);
3575 }
3576 
3577 // Inflate byte[] to char[].
3578 void MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp, Label&amp; Ldone) {
3579   Label Loop;
3580   assert_different_registers(src, dst, cnt, tmp);
3581 
3582   ldub(src, 0, tmp);
3583   bind(Loop);
3584   inc(src);
3585   deccc(cnt);
3586   sth(tmp, dst, 0);
3587   inc(dst, sizeof(jchar));
3588   // annul LDUB if branch is not taken to prevent access past end of string
3589   br(Assembler::notZero, true, Assembler::pt, Loop);
3590   delayed()-&gt;ldub(src, 0, tmp); // hoisted
3591 }
3592 
3593 void MacroAssembler::string_compare(Register str1, Register str2,
3594                                     Register cnt1, Register cnt2,
3595                                     Register tmp1, Register tmp2,
3596                                     Register result, int ae) {
3597   Label Ldone, Lloop;
3598   assert_different_registers(str1, str2, cnt1, cnt2, tmp1, result);
3599   int stride1, stride2;
3600 
3601   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)
3602   // we interchange str1 and str2 in the UL case and negate the result.
3603   // Like this, str1 is always latin1 encoded, expect for the UU case.
3604 
3605   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3606     srl(cnt2, 1, cnt2);
3607   }
3608 
3609   // See if the lengths are different, and calculate min in cnt1.
3610   // Save diff in case we need it for a tie-breaker.
3611   Label Lskip;
3612   Register diff = tmp1;
3613   subcc(cnt1, cnt2, diff);
3614   br(Assembler::greater, true, Assembler::pt, Lskip);
3615   // cnt2 is shorter, so use its count:
3616   delayed()-&gt;mov(cnt2, cnt1);
3617   bind(Lskip);
3618 
3619   // Rename registers
3620   Register limit1 = cnt1;
3621   Register limit2 = limit1;
3622   Register chr1   = result;
3623   Register chr2   = cnt2;
3624   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3625     // We need an additional register to keep track of two limits
3626     assert_different_registers(str1, str2, cnt1, cnt2, tmp1, tmp2, result);
3627     limit2 = tmp2;
3628   }
3629 
3630   // Is the minimum length zero?
3631   cmp(limit1, (int)0); // use cast to resolve overloading ambiguity
3632   br(Assembler::equal, true, Assembler::pn, Ldone);
3633   // result is difference in lengths
3634   if (ae == StrIntrinsicNode::UU) {
3635     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars
3636   } else {
3637     delayed()-&gt;mov(diff, result);
3638   }
3639 
3640   // Load first characters
3641   if (ae == StrIntrinsicNode::LL) {
3642     stride1 = stride2 = sizeof(jbyte);
3643     ldub(str1, 0, chr1);
3644     ldub(str2, 0, chr2);
3645   } else if (ae == StrIntrinsicNode::UU) {
3646     stride1 = stride2 = sizeof(jchar);
3647     lduh(str1, 0, chr1);
3648     lduh(str2, 0, chr2);
3649   } else {
3650     stride1 = sizeof(jbyte);
3651     stride2 = sizeof(jchar);
3652     ldub(str1, 0, chr1);
3653     lduh(str2, 0, chr2);
3654   }
3655 
3656   // Compare first characters
3657   subcc(chr1, chr2, chr1);
3658   br(Assembler::notZero, false, Assembler::pt, Ldone);
3659   assert(chr1 == result, &quot;result must be pre-placed&quot;);
3660   delayed()-&gt;nop();
3661 
3662   // Check if the strings start at same location
3663   cmp(str1, str2);
3664   brx(Assembler::equal, true, Assembler::pn, Ldone);
3665   delayed()-&gt;mov(G0, result);  // result is zero
3666 
3667   // We have no guarantee that on 64 bit the higher half of limit is 0
3668   signx(limit1);
3669 
3670   // Get limit
3671   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3672     sll(limit1, 1, limit2);
3673     subcc(limit2, stride2, chr2);
3674   }
3675   subcc(limit1, stride1, chr1);
3676   br(Assembler::zero, true, Assembler::pn, Ldone);
3677   // result is difference in lengths
3678   if (ae == StrIntrinsicNode::UU) {
3679     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars
3680   } else {
3681     delayed()-&gt;mov(diff, result);
3682   }
3683 
3684   // Shift str1 and str2 to the end of the arrays, negate limit
3685   add(str1, limit1, str1);
3686   add(str2, limit2, str2);
3687   neg(chr1, limit1);  // limit1 = -(limit1-stride1)
3688   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3689     neg(chr2, limit2);  // limit2 = -(limit2-stride2)
3690   }
3691 
3692   // Compare the rest of the characters
3693   load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);
3694 
3695   bind(Lloop);
3696   load_sized_value(Address(str2, limit2), chr2, (ae == StrIntrinsicNode::LL) ? 1 : 2, false);
3697 
3698   subcc(chr1, chr2, chr1);
3699   br(Assembler::notZero, false, Assembler::pt, Ldone);
3700   assert(chr1 == result, &quot;result must be pre-placed&quot;);
3701   delayed()-&gt;inccc(limit1, stride1);
3702   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3703     inccc(limit2, stride2);
3704   }
3705 
3706   // annul LDUB if branch is not taken to prevent access past end of string
3707   br(Assembler::notZero, true, Assembler::pt, Lloop);
3708   delayed()-&gt;load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);
3709 
3710   // If strings are equal up to min length, return the length difference.
3711   if (ae == StrIntrinsicNode::UU) {
3712     // Divide by 2 to get number of chars
3713     sra(diff, 1, result);
3714   } else {
3715     mov(diff, result);
3716   }
3717 
3718   // Otherwise, return the difference between the first mismatched chars.
3719   bind(Ldone);
3720   if(ae == StrIntrinsicNode::UL) {
3721     // Negate result (see note above)
3722     neg(result);
3723   }
3724 }
3725 
3726 void MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2,
3727                                   Register limit, Register tmp, Register result, bool is_byte) {
3728   Label Ldone, Lloop, Lremaining;
3729   assert_different_registers(ary1, ary2, limit, tmp, result);
3730 
3731   int length_offset  = arrayOopDesc::length_offset_in_bytes();
3732   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);
3733   assert(base_offset % 8 == 0, &quot;Base offset must be 8-byte aligned&quot;);
3734 
3735   if (is_array_equ) {
3736     // return true if the same array
3737     cmp(ary1, ary2);
3738     brx(Assembler::equal, true, Assembler::pn, Ldone);
3739     delayed()-&gt;mov(1, result);  // equal
3740 
3741     br_null(ary1, true, Assembler::pn, Ldone);
3742     delayed()-&gt;clr(result);     // not equal
3743 
3744     br_null(ary2, true, Assembler::pn, Ldone);
3745     delayed()-&gt;clr(result);     // not equal
3746 
3747     // load the lengths of arrays
3748     ld(Address(ary1, length_offset), limit);
3749     ld(Address(ary2, length_offset), tmp);
3750 
3751     // return false if the two arrays are not equal length
3752     cmp(limit, tmp);
3753     br(Assembler::notEqual, true, Assembler::pn, Ldone);
3754     delayed()-&gt;clr(result);     // not equal
3755   }
3756 
3757   cmp_zero_and_br(Assembler::zero, limit, Ldone, true, Assembler::pn);
3758   delayed()-&gt;mov(1, result); // zero-length arrays are equal
3759 
3760   if (is_array_equ) {
3761     // load array addresses
3762     add(ary1, base_offset, ary1);
3763     add(ary2, base_offset, ary2);
3764     // set byte count
3765     if (!is_byte) {
3766       sll(limit, exact_log2(sizeof(jchar)), limit);
3767     }
3768   } else {
3769     // We have no guarantee that on 64 bit the higher half of limit is 0
3770     signx(limit);
3771   }
3772 
3773 #ifdef ASSERT
3774   // Sanity check for doubleword (8-byte) alignment of ary1 and ary2.
3775   // Guaranteed on 64-bit systems (see arrayOopDesc::header_size_in_bytes()).
3776   Label Laligned;
3777   or3(ary1, ary2, tmp);
3778   andcc(tmp, 7, tmp);
3779   br_null_short(tmp, Assembler::pn, Laligned);
3780   STOP(&quot;First array element is not 8-byte aligned.&quot;);
3781   should_not_reach_here();
3782   bind(Laligned);
3783 #endif
3784 
3785   // Shift ary1 and ary2 to the end of the arrays, negate limit
3786   add(ary1, limit, ary1);
3787   add(ary2, limit, ary2);
3788   neg(limit, limit);
3789 
3790   // MAIN LOOP
3791   // Load and compare array elements of size &#39;byte_width&#39; until the elements are not
3792   // equal or we reached the end of the arrays. If the size of the arrays is not a
3793   // multiple of &#39;byte_width&#39;, we simply read over the end of the array, bail out and
3794   // compare the remaining bytes below by skipping the garbage bytes.
3795   ldx(ary1, limit, result);
3796   bind(Lloop);
3797   ldx(ary2, limit, tmp);
3798   inccc(limit, 8);
3799   // Bail out if we reached the end (but still do the comparison)
3800   br(Assembler::positive, false, Assembler::pn, Lremaining);
3801   delayed()-&gt;cmp(result, tmp);
3802   // Check equality of elements
3803   brx(Assembler::equal, false, Assembler::pt, target(Lloop));
3804   delayed()-&gt;ldx(ary1, limit, result);
3805 
3806   ba(Ldone);
3807   delayed()-&gt;clr(result); // not equal
3808 
3809   // TAIL COMPARISON
3810   // We got here because we reached the end of the arrays. &#39;limit&#39; is the number of
3811   // garbage bytes we may have compared by reading over the end of the arrays. Shift
3812   // out the garbage and compare the remaining elements.
3813   bind(Lremaining);
3814   // Optimistic shortcut: elements potentially including garbage are equal
3815   brx(Assembler::equal, true, Assembler::pt, target(Ldone));
3816   delayed()-&gt;mov(1, result); // equal
3817   // Shift &#39;limit&#39; bytes to the right and compare
3818   sll(limit, 3, limit); // bytes to bits
3819   srlx(result, limit, result);
3820   srlx(tmp, limit, tmp);
3821   cmp(result, tmp);
3822   clr(result);
3823   movcc(Assembler::equal, false, xcc, 1, result);
3824 
3825   bind(Ldone);
3826 }
3827 
3828 void MacroAssembler::has_negatives(Register inp, Register size, Register result, Register t2, Register t3, Register t4, Register t5) {
3829 
3830   // test for negative bytes in input string of a given size
3831   // result 1 if found, 0 otherwise.
3832 
3833   Label Lcore, Ltail, Lreturn, Lcore_rpt;
3834 
3835   assert_different_registers(inp, size, t2, t3, t4, t5, result);
3836 
3837   Register i     = result;  // result used as integer index i until very end
3838   Register lmask = t2;      // t2 is aliased to lmask
3839 
3840   // INITIALIZATION
3841   // ===========================================================
3842   // initialize highbits mask -&gt; lmask = 0x8080808080808080  (8B/64b)
3843   // compute unaligned offset -&gt; i
3844   // compute core end index   -&gt; t5
3845   Assembler::sethi(0x80808000, t2);   //! sethi macro fails to emit optimal
3846   add(t2, 0x80, t2);
3847   sllx(t2, 32, t3);
3848   or3(t3, t2, lmask);                 // 0x8080808080808080 -&gt; lmask
3849   sra(size,0,size);
3850   andcc(inp, 0x7, i);                 // unaligned offset -&gt; i
3851   br(Assembler::zero, true, Assembler::pn, Lcore); // starts 8B aligned?
3852   delayed()-&gt;add(size, -8, t5);       // (annuled) core end index -&gt; t5
3853 
3854   // ===========================================================
3855 
3856   // UNALIGNED HEAD
3857   // ===========================================================
3858   // * unaligned head handling: grab aligned 8B containing unaligned inp(ut)
3859   // * obliterate (ignore) bytes outside string by shifting off reg ends
3860   // * compare with bitmask, short circuit return true if one or more high
3861   //   bits set.
3862   cmp(size, 0);
3863   br(Assembler::zero, true, Assembler::pn, Lreturn); // short-circuit?
3864   delayed()-&gt;mov(0,result);      // annuled so i not clobbered for following
3865   neg(i, t4);
3866   add(i, size, t5);
3867   ldx(inp, t4, t3);  // raw aligned 8B containing unaligned head -&gt; t3
3868   mov(8, t4);
3869   sub(t4, t5, t4);
3870   sra(t4, 31, t5);
3871   andn(t4, t5, t5);
3872   add(i, t5, t4);
3873   sll(t5, 3, t5);
3874   sll(t4, 3, t4);   // # bits to shift right, left -&gt; t5,t4
3875   srlx(t3, t5, t3);
3876   sllx(t3, t4, t3); // bytes outside string in 8B header obliterated -&gt; t3
3877   andcc(lmask, t3, G0);
3878   brx(Assembler::notZero, true, Assembler::pn, Lreturn); // short circuit?
3879   delayed()-&gt;mov(1,result);      // annuled so i not clobbered for following
3880   add(size, -8, t5);             // core end index -&gt; t5
3881   mov(8, t4);
3882   sub(t4, i, i);                 // # bytes examined in unalgn head (&lt;8) -&gt; i
3883   // ===========================================================
3884 
3885   // ALIGNED CORE
3886   // ===========================================================
3887   // * iterate index i over aligned 8B sections of core, comparing with
3888   //   bitmask, short circuit return true if one or more high bits set
3889   // t5 contains core end index/loop limit which is the index
3890   //     of the MSB of last (unaligned) 8B fully contained in the string.
3891   // inp   contains address of first byte in string/array
3892   // lmask contains 8B high bit mask for comparison
3893   // i     contains next index to be processed (adr. inp+i is on 8B boundary)
3894   bind(Lcore);
3895   cmp_and_br_short(i, t5, Assembler::greater, Assembler::pn, Ltail);
3896   bind(Lcore_rpt);
3897   ldx(inp, i, t3);
3898   andcc(t3, lmask, G0);
3899   brx(Assembler::notZero, true, Assembler::pn, Lreturn);
3900   delayed()-&gt;mov(1, result);    // annuled so i not clobbered for following
3901   add(i, 8, i);
3902   cmp_and_br_short(i, t5, Assembler::lessEqual, Assembler::pn, Lcore_rpt);
3903   // ===========================================================
3904 
3905   // ALIGNED TAIL (&lt;8B)
3906   // ===========================================================
3907   // handle aligned tail of 7B or less as complete 8B, obliterating end of
3908   // string bytes by shifting them off end, compare what&#39;s left with bitmask
3909   // inp   contains address of first byte in string/array
3910   // lmask contains 8B high bit mask for comparison
3911   // i     contains next index to be processed (adr. inp+i is on 8B boundary)
3912   bind(Ltail);
3913   subcc(size, i, t4);   // # of remaining bytes in string -&gt; t4
3914   // return 0 if no more remaining bytes
3915   br(Assembler::lessEqual, true, Assembler::pn, Lreturn);
3916   delayed()-&gt;mov(0, result); // annuled so i not clobbered for following
3917   ldx(inp, i, t3);       // load final 8B (aligned) containing tail -&gt; t3
3918   mov(8, t5);
3919   sub(t5, t4, t4);
3920   mov(0, result);        // ** i clobbered at this point
3921   sll(t4, 3, t4);        // bits beyond end of string          -&gt; t4
3922   srlx(t3, t4, t3);      // bytes beyond end now obliterated   -&gt; t3
3923   andcc(lmask, t3, G0);
3924   movcc(Assembler::notZero, false, xcc,  1, result);
3925   bind(Lreturn);
3926 }
3927 
3928 #endif
3929 
3930 
3931 // Use BIS for zeroing (count is in bytes).
3932 void MacroAssembler::bis_zeroing(Register to, Register count, Register temp, Label&amp; Ldone) {
3933   assert(UseBlockZeroing &amp;&amp; VM_Version::has_blk_zeroing(), &quot;only works with BIS zeroing&quot;);
3934   Register end = count;
3935   int cache_line_size = VM_Version::prefetch_data_size();
3936   assert(cache_line_size &gt; 0, &quot;cache line size should be known for this code&quot;);
3937   // Minimum count when BIS zeroing can be used since
3938   // it needs membar which is expensive.
3939   int block_zero_size  = MAX2(cache_line_size*3, (int)BlockZeroingLowLimit);
3940 
3941   Label small_loop;
3942   // Check if count is negative (dead code) or zero.
3943   // Note, count uses 64bit in 64 bit VM.
3944   cmp_and_brx_short(count, 0, Assembler::lessEqual, Assembler::pn, Ldone);
3945 
3946   // Use BIS zeroing only for big arrays since it requires membar.
3947   if (Assembler::is_simm13(block_zero_size)) { // &lt; 4096
3948     cmp(count, block_zero_size);
3949   } else {
3950     set(block_zero_size, temp);
3951     cmp(count, temp);
3952   }
3953   br(Assembler::lessUnsigned, false, Assembler::pt, small_loop);
3954   delayed()-&gt;add(to, count, end);
3955 
3956   // Note: size is &gt;= three (32 bytes) cache lines.
3957 
3958   // Clean the beginning of space up to next cache line.
3959   for (int offs = 0; offs &lt; cache_line_size; offs += 8) {
3960     stx(G0, to, offs);
3961   }
3962 
3963   // align to next cache line
3964   add(to, cache_line_size, to);
3965   and3(to, -cache_line_size, to);
3966 
3967   // Note: size left &gt;= two (32 bytes) cache lines.
3968 
3969   // BIS should not be used to zero tail (64 bytes)
3970   // to avoid zeroing a header of the following object.
3971   sub(end, (cache_line_size*2)-8, end);
3972 
3973   Label bis_loop;
3974   bind(bis_loop);
3975   stxa(G0, to, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
3976   add(to, cache_line_size, to);
3977   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, bis_loop);
3978 
3979   // BIS needs membar.
3980   membar(Assembler::StoreLoad);
3981 
3982   add(end, (cache_line_size*2)-8, end); // restore end
3983   cmp_and_brx_short(to, end, Assembler::greaterEqualUnsigned, Assembler::pn, Ldone);
3984 
3985   // Clean the tail.
3986   bind(small_loop);
3987   stx(G0, to, 0);
3988   add(to, 8, to);
3989   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, small_loop);
3990   nop(); // Separate short branches
3991 }
3992 
3993 /**
3994  * Update CRC-32[C] with a byte value according to constants in table
3995  *
3996  * @param [in,out]crc   Register containing the crc.
3997  * @param [in]val       Register containing the byte to fold into the CRC.
3998  * @param [in]table     Register containing the table of crc constants.
3999  *
4000  * uint32_t crc;
4001  * val = crc_table[(val ^ crc) &amp; 0xFF];
4002  * crc = val ^ (crc &gt;&gt; 8);
4003  */
4004 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
4005   xor3(val, crc, val);
4006   and3(val, 0xFF, val);
4007   sllx(val, 2, val);
4008   lduw(table, val, val);
4009   srlx(crc, 8, crc);
4010   xor3(val, crc, crc);
4011 }
4012 
4013 // Reverse byte order of lower 32 bits, assuming upper 32 bits all zeros
4014 void MacroAssembler::reverse_bytes_32(Register src, Register dst, Register tmp) {
4015     srlx(src, 24, dst);
4016 
4017     sllx(src, 32+8, tmp);
4018     srlx(tmp, 32+24, tmp);
4019     sllx(tmp, 8, tmp);
4020     or3(dst, tmp, dst);
4021 
4022     sllx(src, 32+16, tmp);
4023     srlx(tmp, 32+24, tmp);
4024     sllx(tmp, 16, tmp);
4025     or3(dst, tmp, dst);
4026 
4027     sllx(src, 32+24, tmp);
4028     srlx(tmp, 32, tmp);
4029     or3(dst, tmp, dst);
4030 }
4031 
4032 void MacroAssembler::movitof_revbytes(Register src, FloatRegister dst, Register tmp1, Register tmp2) {
4033   reverse_bytes_32(src, tmp1, tmp2);
4034   movxtod(tmp1, dst);
4035 }
4036 
4037 void MacroAssembler::movftoi_revbytes(FloatRegister src, Register dst, Register tmp1, Register tmp2) {
4038   movdtox(src, tmp1);
4039   reverse_bytes_32(tmp1, dst, tmp2);
4040 }
4041 
4042 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register buf, int offset) {
4043   xmulx(xcrc_hi, xK_hi, xtmp_lo);
4044   xmulxhi(xcrc_hi, xK_hi, xtmp_hi);
4045   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
4046   xmulx(xcrc_lo, xK_lo, xcrc_lo);
4047   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4048   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4049   ldxl(buf, G0, xtmp_lo);
4050   inc(buf, 8);
4051   ldxl(buf, G0, xtmp_hi);
4052   inc(buf, 8);
4053   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4054   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4055 }
4056 
4057 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register xbuf_hi, Register xbuf_lo) {
4058   mov(xcrc_lo, xtmp_lo);
4059   mov(xcrc_hi, xtmp_hi);
4060   xmulx(xtmp_hi, xK_hi, xtmp_lo);
4061   xmulxhi(xtmp_hi, xK_hi, xtmp_hi);
4062   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
4063   xmulx(xcrc_lo, xK_lo, xcrc_lo);
4064   xor3(xcrc_lo, xbuf_lo, xcrc_lo);
4065   xor3(xcrc_hi, xbuf_hi, xcrc_hi);
4066   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4067   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4068 }
4069 
4070 void MacroAssembler::fold_8bit_crc32(Register xcrc, Register table, Register xtmp, Register tmp) {
4071   and3(xcrc, 0xFF, tmp);
4072   sllx(tmp, 2, tmp);
4073   lduw(table, tmp, xtmp);
4074   srlx(xcrc, 8, xcrc);
4075   xor3(xtmp, xcrc, xcrc);
4076 }
4077 
4078 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
4079   and3(crc, 0xFF, tmp);
4080   srlx(crc, 8, crc);
4081   sllx(tmp, 2, tmp);
4082   lduw(table, tmp, tmp);
4083   xor3(tmp, crc, crc);
4084 }
4085 
4086 #define CRC32_TMP_REG_NUM 18
4087 
4088 #define CRC32_CONST_64  0x163cd6124
4089 #define CRC32_CONST_96  0x0ccaa009e
4090 #define CRC32_CONST_160 0x1751997d0
4091 #define CRC32_CONST_480 0x1c6e41596
4092 #define CRC32_CONST_544 0x154442bd4
4093 
4094 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table) {
4095 
4096   Label L_cleanup_loop, L_cleanup_check, L_align_loop, L_align_check;
4097   Label L_main_loop_prologue;
4098   Label L_fold_512b, L_fold_512b_loop, L_fold_128b;
4099   Label L_fold_tail, L_fold_tail_loop;
4100   Label L_8byte_fold_check;
4101 
4102   const Register tmp[CRC32_TMP_REG_NUM] = {L0, L1, L2, L3, L4, L5, L6, G1, I0, I1, I2, I3, I4, I5, I7, O4, O5, G3};
4103 
4104   Register const_64  = tmp[CRC32_TMP_REG_NUM-1];
4105   Register const_96  = tmp[CRC32_TMP_REG_NUM-1];
4106   Register const_160 = tmp[CRC32_TMP_REG_NUM-2];
4107   Register const_480 = tmp[CRC32_TMP_REG_NUM-1];
4108   Register const_544 = tmp[CRC32_TMP_REG_NUM-2];
4109 
4110   set(ExternalAddress(StubRoutines::crc_table_addr()), table);
4111 
4112   not1(crc); // ~c
4113   clruwu(crc); // clear upper 32 bits of crc
4114 
4115   // Check if below cutoff, proceed directly to cleanup code
4116   mov(31, G4);
4117   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
4118 
4119   // Align buffer to 8 byte boundry
4120   mov(8, O5);
4121   and3(buf, 0x7, O4);
4122   sub(O5, O4, O5);
4123   and3(O5, 0x7, O5);
4124   sub(len, O5, len);
4125   ba(L_align_check);
4126   delayed()-&gt;nop();
4127 
4128   // Alignment loop, table look up method for up to 7 bytes
4129   bind(L_align_loop);
4130   ldub(buf, 0, O4);
4131   inc(buf);
4132   dec(O5);
4133   xor3(O4, crc, O4);
4134   and3(O4, 0xFF, O4);
4135   sllx(O4, 2, O4);
4136   lduw(table, O4, O4);
4137   srlx(crc, 8, crc);
4138   xor3(O4, crc, crc);
4139   bind(L_align_check);
4140   nop();
4141   cmp_and_br_short(O5, 0, Assembler::notEqual, Assembler::pt, L_align_loop);
4142 
4143   // Aligned on 64-bit (8-byte) boundry at this point
4144   // Check if still above cutoff (31-bytes)
4145   mov(31, G4);
4146   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
4147   // At least 32 bytes left to process
4148 
4149   // Free up registers by storing them to FP registers
4150   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
4151     movxtod(tmp[i], as_FloatRegister(2*i));
4152   }
4153 
4154   // Determine which loop to enter
4155   // Shared prologue
4156   ldxl(buf, G0, tmp[0]);
4157   inc(buf, 8);
4158   ldxl(buf, G0, tmp[1]);
4159   inc(buf, 8);
4160   xor3(tmp[0], crc, tmp[0]); // Fold CRC into first few bytes
4161   and3(crc, 0, crc); // Clear out the crc register
4162   // Main loop needs 128-bytes at least
4163   mov(128, G4);
4164   mov(64, tmp[2]);
4165   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_main_loop_prologue);
4166   // Less than 64 bytes
4167   nop();
4168   cmp_and_br_short(len, tmp[2], Assembler::lessUnsigned, Assembler::pt, L_fold_tail);
4169   // Between 64 and 127 bytes
4170   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4171   set64(CRC32_CONST_160, const_160, tmp[9]);
4172   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
4173   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[4], tmp[5], buf, 16);
4174   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[6], tmp[7], buf, 32);
4175   dec(len, 48);
4176   ba(L_fold_tail);
4177   delayed()-&gt;nop();
4178 
4179   bind(L_main_loop_prologue);
4180   for (int i = 2; i &lt; 8; i++) {
4181     ldxl(buf, G0, tmp[i]);
4182     inc(buf, 8);
4183   }
4184 
4185   // Fold total 512 bits of polynomial on each iteration,
4186   // 128 bits per each of 4 parallel streams
4187   set64(CRC32_CONST_480, const_480, tmp[8]);
4188   set64(CRC32_CONST_544, const_544, tmp[9]);
4189 
4190   mov(128, G4);
4191   bind(L_fold_512b_loop);
4192   fold_128bit_crc32(tmp[1], tmp[0], const_480, const_544, tmp[9],  tmp[8],  buf,  0);
4193   fold_128bit_crc32(tmp[3], tmp[2], const_480, const_544, tmp[11], tmp[10], buf, 16);
4194   fold_128bit_crc32(tmp[5], tmp[4], const_480, const_544, tmp[13], tmp[12], buf, 32);
4195   fold_128bit_crc32(tmp[7], tmp[6], const_480, const_544, tmp[15], tmp[14], buf, 64);
4196   dec(len, 64);
4197   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_512b_loop);
4198 
4199   // Fold 512 bits to 128 bits
4200   bind(L_fold_512b);
4201   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4202   set64(CRC32_CONST_160, const_160, tmp[9]);
4203 
4204   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[3], tmp[2]);
4205   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[5], tmp[4]);
4206   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[7], tmp[6]);
4207   dec(len, 48);
4208 
4209   // Fold the rest of 128 bits data chunks
4210   bind(L_fold_tail);
4211   mov(32, G4);
4212   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_fold_128b);
4213 
4214   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4215   set64(CRC32_CONST_160, const_160, tmp[9]);
4216 
4217   bind(L_fold_tail_loop);
4218   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
4219   sub(len, 16, len);
4220   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_tail_loop);
4221 
4222   // Fold the 128 bits in tmps 0 - 1 into tmp 1
4223   bind(L_fold_128b);
4224 
4225   set64(CRC32_CONST_64, const_64, tmp[4]);
4226 
4227   xmulx(const_64, tmp[0], tmp[2]);
4228   xmulxhi(const_64, tmp[0], tmp[3]);
4229 
4230   srl(tmp[2], G0, tmp[4]);
4231   xmulx(const_64, tmp[4], tmp[4]);
4232 
4233   srlx(tmp[2], 32, tmp[2]);
4234   sllx(tmp[3], 32, tmp[3]);
4235   or3(tmp[2], tmp[3], tmp[2]);
4236 
4237   xor3(tmp[4], tmp[1], tmp[4]);
4238   xor3(tmp[4], tmp[2], tmp[1]);
4239   dec(len, 8);
4240 
4241   // Use table lookup for the 8 bytes left in tmp[1]
4242   dec(len, 8);
4243 
4244   // 8 8-bit folds to compute 32-bit CRC.
4245   for (int j = 0; j &lt; 4; j++) {
4246     fold_8bit_crc32(tmp[1], table, tmp[2], tmp[3]);
4247   }
4248   srl(tmp[1], G0, crc); // move 32 bits to general register
4249   for (int j = 0; j &lt; 4; j++) {
4250     fold_8bit_crc32(crc, table, tmp[3]);
4251   }
4252 
4253   bind(L_8byte_fold_check);
4254 
4255   // Restore int registers saved in FP registers
4256   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
4257     movdtox(as_FloatRegister(2*i), tmp[i]);
4258   }
4259 
4260   ba(L_cleanup_check);
4261   delayed()-&gt;nop();
4262 
4263   // Table look-up method for the remaining few bytes
4264   bind(L_cleanup_loop);
4265   ldub(buf, 0, O4);
4266   inc(buf);
4267   dec(len);
4268   xor3(O4, crc, O4);
4269   and3(O4, 0xFF, O4);
4270   sllx(O4, 2, O4);
4271   lduw(table, O4, O4);
4272   srlx(crc, 8, crc);
4273   xor3(O4, crc, crc);
4274   bind(L_cleanup_check);
4275   nop();
4276   cmp_and_br_short(len, 0, Assembler::greaterUnsigned, Assembler::pt, L_cleanup_loop);
4277 
4278   not1(crc);
4279 }
4280 
4281 #define CHUNK_LEN   128          /* 128 x 8B = 1KB */
4282 #define CHUNK_K1    0x1307a0206  /* reverseBits(pow(x, CHUNK_LEN*8*8*3 - 32) mod P(x)) &lt;&lt; 1 */
4283 #define CHUNK_K2    0x1a0f717c4  /* reverseBits(pow(x, CHUNK_LEN*8*8*2 - 32) mod P(x)) &lt;&lt; 1 */
4284 #define CHUNK_K3    0x0170076fa  /* reverseBits(pow(x, CHUNK_LEN*8*8*1 - 32) mod P(x)) &lt;&lt; 1 */
4285 
4286 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len, Register table) {
4287 
4288   Label L_crc32c_head, L_crc32c_aligned;
4289   Label L_crc32c_parallel, L_crc32c_parallel_loop;
4290   Label L_crc32c_serial, L_crc32c_x32_loop, L_crc32c_x8, L_crc32c_x8_loop;
4291   Label L_crc32c_done, L_crc32c_tail, L_crc32c_return;
4292 
4293   set(ExternalAddress(StubRoutines::crc32c_table_addr()), table);
4294 
4295   cmp_and_br_short(len, 0, Assembler::lessEqual, Assembler::pn, L_crc32c_return);
4296 
4297   // clear upper 32 bits of crc
4298   clruwu(crc);
4299 
4300   and3(buf, 7, G4);
4301   cmp_and_brx_short(G4, 0, Assembler::equal, Assembler::pt, L_crc32c_aligned);
4302 
4303   mov(8, G1);
4304   sub(G1, G4, G4);
4305 
4306   // ------ process the misaligned head (7 bytes or less) ------
4307   bind(L_crc32c_head);
4308 
4309   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
4310   ldub(buf, 0, G1);
4311   update_byte_crc32(crc, G1, table);
4312 
4313   inc(buf);
4314   dec(len);
4315   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pn, L_crc32c_return);
4316   dec(G4);
4317   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_head);
4318 
4319   // ------ process the 8-byte-aligned body ------
4320   bind(L_crc32c_aligned);
4321   nop();
4322   cmp_and_br_short(len, 8, Assembler::less, Assembler::pn, L_crc32c_tail);
4323 
4324   // reverse the byte order of lower 32 bits to big endian, and move to FP side
4325   movitof_revbytes(crc, F0, G1, G3);
4326 
4327   set(CHUNK_LEN*8*4, G4);
4328   cmp_and_br_short(len, G4, Assembler::less, Assembler::pt, L_crc32c_serial);
4329 
4330   // ------ process four 1KB chunks in parallel ------
4331   bind(L_crc32c_parallel);
4332 
4333   fzero(FloatRegisterImpl::D, F2);
4334   fzero(FloatRegisterImpl::D, F4);
4335   fzero(FloatRegisterImpl::D, F6);
4336 
4337   mov(CHUNK_LEN - 1, G4);
4338   bind(L_crc32c_parallel_loop);
4339   // schedule ldf&#39;s ahead of crc32c&#39;s to hide the load-use latency
4340   ldf(FloatRegisterImpl::D, buf, 0,            F8);
4341   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
4342   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
4343   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*24, F14);
4344   crc32c(F0, F8,  F0);
4345   crc32c(F2, F10, F2);
4346   crc32c(F4, F12, F4);
4347   crc32c(F6, F14, F6);
4348   inc(buf, 8);
4349   dec(G4);
4350   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_parallel_loop);
4351 
4352   ldf(FloatRegisterImpl::D, buf, 0,            F8);
4353   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
4354   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
4355   crc32c(F0, F8,  F0);
4356   crc32c(F2, F10, F2);
4357   crc32c(F4, F12, F4);
4358 
4359   inc(buf, CHUNK_LEN*24);
4360   ldfl(FloatRegisterImpl::D, buf, G0, F14);  // load in little endian
4361   inc(buf, 8);
4362 
4363   prefetch(buf, 0,            Assembler::severalReads);
4364   prefetch(buf, CHUNK_LEN*8,  Assembler::severalReads);
4365   prefetch(buf, CHUNK_LEN*16, Assembler::severalReads);
4366   prefetch(buf, CHUNK_LEN*24, Assembler::severalReads);
4367 
4368   // move to INT side, and reverse the byte order of lower 32 bits to little endian
4369   movftoi_revbytes(F0, O4, G1, G4);
4370   movftoi_revbytes(F2, O5, G1, G4);
4371   movftoi_revbytes(F4, G5, G1, G4);
4372 
4373   // combine the results of 4 chunks
4374   set64(CHUNK_K1, G3, G1);
4375   xmulx(O4, G3, O4);
4376   set64(CHUNK_K2, G3, G1);
4377   xmulx(O5, G3, O5);
4378   set64(CHUNK_K3, G3, G1);
4379   xmulx(G5, G3, G5);
4380 
4381   movdtox(F14, G4);
4382   xor3(O4, O5, O5);
4383   xor3(G5, O5, O5);
4384   xor3(G4, O5, O5);
4385 
4386   // reverse the byte order to big endian, via stack, and move to FP side
4387   // TODO: use new revb instruction
4388   add(SP, -8, G1);
4389   srlx(G1, 3, G1);
4390   sllx(G1, 3, G1);
4391   stx(O5, G1, G0);
4392   ldfl(FloatRegisterImpl::D, G1, G0, F2);  // load in little endian
4393 
4394   crc32c(F6, F2, F0);
4395 
4396   set(CHUNK_LEN*8*4, G4);
4397   sub(len, G4, len);
4398   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_parallel);
4399   nop();
4400   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_done);
4401 
4402   bind(L_crc32c_serial);
4403 
4404   mov(32, G4);
4405   cmp_and_br_short(len, G4, Assembler::less, Assembler::pn, L_crc32c_x8);
4406 
4407   // ------ process 32B chunks ------
4408   bind(L_crc32c_x32_loop);
4409   ldf(FloatRegisterImpl::D, buf, 0, F2);
4410   crc32c(F0, F2, F0);
4411   ldf(FloatRegisterImpl::D, buf, 8, F2);
4412   crc32c(F0, F2, F0);
4413   ldf(FloatRegisterImpl::D, buf, 16, F2);
4414   crc32c(F0, F2, F0);
4415   ldf(FloatRegisterImpl::D, buf, 24, F2);
4416   inc(buf, 32);
4417   crc32c(F0, F2, F0);
4418   dec(len, 32);
4419   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_x32_loop);
4420 
4421   bind(L_crc32c_x8);
4422   nop();
4423   cmp_and_br_short(len, 8, Assembler::less, Assembler::pt, L_crc32c_done);
4424 
4425   // ------ process 8B chunks ------
4426   bind(L_crc32c_x8_loop);
4427   ldf(FloatRegisterImpl::D, buf, 0, F2);
4428   inc(buf, 8);
4429   crc32c(F0, F2, F0);
4430   dec(len, 8);
4431   cmp_and_br_short(len, 8, Assembler::greaterEqual, Assembler::pt, L_crc32c_x8_loop);
4432 
4433   bind(L_crc32c_done);
4434 
4435   // move to INT side, and reverse the byte order of lower 32 bits to little endian
4436   movftoi_revbytes(F0, crc, G1, G3);
4437 
4438   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_return);
4439 
4440   // ------ process the misaligned tail (7 bytes or less) ------
4441   bind(L_crc32c_tail);
4442 
4443   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
4444   ldub(buf, 0, G1);
4445   update_byte_crc32(crc, G1, table);
4446 
4447   inc(buf);
4448   dec(len);
4449   cmp_and_br_short(len, 0, Assembler::greater, Assembler::pt, L_crc32c_tail);
4450 
4451   bind(L_crc32c_return);
4452   nop();
4453 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
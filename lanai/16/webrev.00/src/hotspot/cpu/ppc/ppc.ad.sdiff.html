<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/ppc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 1280   offsets.ret_addr_offset = __ offset() - start_offset;
 1281 
 1282   return offsets;
 1283 }
 1284 
 1285 //=============================================================================
 1286 
 1287 // Factory for creating loadConL* nodes for large/small constant pool.
 1288 
 1289 static inline jlong replicate_immF(float con) {
 1290   // Replicate float con 2 times and pack into vector.
 1291   int val = *((int*)&amp;con);
 1292   jlong lval = val;
 1293   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
 1294   return lval;
 1295 }
 1296 
 1297 //=============================================================================
 1298 
 1299 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
<span class="line-modified"> 1300 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
 1301   return 0;  // absolute addressing, no offset
 1302 }
 1303 
 1304 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
 1305 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1306   iRegPdstOper *op_dst = new iRegPdstOper();
 1307   MachNode *m1 = new loadToc_hiNode();
 1308   MachNode *m2 = new loadToc_loNode();
 1309 
 1310   m1-&gt;add_req(NULL);
 1311   m2-&gt;add_req(NULL, m1);
 1312   m1-&gt;_opnds[0] = op_dst;
 1313   m2-&gt;_opnds[0] = op_dst;
 1314   m2-&gt;_opnds[1] = op_dst;
 1315   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1316   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1317   nodes-&gt;push(m1);
 1318   nodes-&gt;push(m2);
 1319 }
 1320 
 1321 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1322   // Is postalloc expanded.
 1323   ShouldNotReachHere();
 1324 }
 1325 
 1326 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1327   return 0;
 1328 }
 1329 
 1330 #ifndef PRODUCT
 1331 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1332   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1333 }
 1334 #endif
 1335 
 1336 //=============================================================================
 1337 
 1338 #ifndef PRODUCT
 1339 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1340   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1341   const long framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1342 
 1343   st-&gt;print(&quot;PROLOG\n\t&quot;);
<span class="line-modified"> 1344   if (C-&gt;need_stack_bang(framesize)) {</span>
 1345     st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
 1346   }
 1347 
 1348   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
 1349     st-&gt;print(&quot;save return pc\n\t&quot;);
 1350     st-&gt;print(&quot;push frame %ld\n\t&quot;, -framesize);
 1351   }
 1352 }
 1353 #endif
 1354 
 1355 // Macro used instead of the common __ to emulate the pipes of PPC.
 1356 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
 1357 // micro scheduler to cope with &quot;hand written&quot; assembler like in the prolog. Though
 1358 // still no scheduling of this code is possible, the micro scheduler is aware of the
 1359 // code and can update its internal data. The following mechanism is used to achieve this:
 1360 // The micro scheduler calls size() of each compound node during scheduling. size() does a
 1361 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
 1362 #if 0 // TODO: PPC port
 1363 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1364                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
 1365                 _masm.
 1366 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1367                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
 1368 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
 1369                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
 1370 #else
 1371 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
 1372                   Unimplemented();                                                    \
 1373                 _masm.
 1374 #define ___stop if (UsePower6SchedulerPPC64)                                          \
 1375                   Unimplemented()
 1376 #define ___advance if (UsePower6SchedulerPPC64)                                       \
 1377                   Unimplemented()
 1378 #endif
 1379 
 1380 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1381   Compile* C = ra_-&gt;C;
 1382   MacroAssembler _masm(&amp;cbuf);
 1383 
<span class="line-modified"> 1384   const long framesize = C-&gt;frame_size_in_bytes();</span>
 1385   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1386 
 1387   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1388 
 1389   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1390   const Register callers_sp           = R21;
 1391   const Register push_frame_temp      = R22;
 1392   const Register toc_temp             = R23;
 1393   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1394 
 1395   if (method_is_frameless) {
 1396     // Add nop at beginning of all frameless methods to prevent any
 1397     // oop instructions from getting overwritten by make_not_entrant
 1398     // (patching attempt would fail).
 1399     ___(nop) nop();
 1400   } else {
 1401     // Get return pc.
 1402     ___(mflr) mflr(return_pc);
 1403   }
 1404 
</pre>
<hr />
<pre>
 1409     Register klass = toc_temp;
 1410 
 1411     // Notify OOP recorder (don&#39;t need the relocation)
 1412     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1413     __ load_const_optimized(klass, md.value(), R0);
 1414     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
 1415 
 1416     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
 1417     __ mtctr(klass);
 1418     __ bctr();
 1419 
 1420     __ bind(L_skip_barrier);
 1421   }
 1422 
 1423   // Calls to C2R adapters often do not accept exceptional returns.
 1424   // We require that their callers must bang for them. But be
 1425   // careful, because some VM calls (such as call site linkage) can
 1426   // use several kilobytes of stack. But the stack safety zone should
 1427   // account for that. See bugs 4446381, 4468289, 4497237.
 1428 
<span class="line-modified"> 1429   int bangsize = C-&gt;bang_size_in_bytes();</span>
 1430   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
<span class="line-modified"> 1431   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
 1432     // Unfortunately we cannot use the function provided in
 1433     // assembler.cpp as we have to emulate the pipes. So I had to
 1434     // insert the code of generate_stack_overflow_check(), see
 1435     // assembler.cpp for some illuminative comments.
 1436     const int page_size = os::vm_page_size();
 1437     int bang_end = JavaThread::stack_shadow_zone_size();
 1438 
 1439     // This is how far the previous frame&#39;s stack banging extended.
 1440     const int bang_end_safe = bang_end;
 1441 
 1442     if (bangsize &gt; page_size) {
 1443       bang_end += bangsize;
 1444     }
 1445 
 1446     int bang_offset = bang_end_safe;
 1447 
 1448     while (bang_offset &lt;= bang_end) {
 1449       // Need at least one stack bang at end of shadow zone.
 1450 
 1451       // Again I had to copy code, this time from assembler_ppc.cpp,
</pre>
<hr />
<pre>
 1465         }
 1466       } else if (Assembler::is_simm(stdoffset, 31)) {
 1467         // Use largeoffset calculations for addis &amp; ld/std.
 1468         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
 1469         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
 1470 
 1471         Register tmp = R11;
 1472         ___(addis) addis(tmp, R1_SP, hi);
 1473         if (UseLoadInstructionsForStackBangingPPC64) {
 1474           ___(ld) ld(R0, lo, tmp);
 1475         } else {
 1476           ___(std) std(R0, lo, tmp);
 1477         }
 1478       } else {
 1479         ShouldNotReachHere();
 1480       }
 1481 
 1482       bang_offset += page_size;
 1483     }
 1484     // R11 trashed
<span class="line-modified"> 1485   } // C-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging</span>
 1486 
 1487   unsigned int bytes = (unsigned int)framesize;
 1488   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
 1489   ciMethod *currMethod = C-&gt;method();
 1490 
 1491   // Optimized version for most common case.
 1492   if (UsePower6SchedulerPPC64 &amp;&amp;
 1493       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
 1494       !(false /* ConstantsALot TODO: PPC port*/)) {
 1495     ___(or) mr(callers_sp, R1_SP);
 1496     ___(std) std(return_pc, _abi(lr), R1_SP);
 1497     ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1498     return;
 1499   }
 1500 
 1501   if (!method_is_frameless) {
 1502     // Get callers sp.
 1503     ___(or) mr(callers_sp, R1_SP);
 1504 
 1505     // Push method&#39;s frame, modifies SP.
</pre>
<hr />
<pre>
 1520       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
 1521 
 1522       ___(stdux) stdux(R1_SP, R1_SP, tmp);
 1523     }
 1524   }
 1525 #if 0 // TODO: PPC port
 1526   // For testing large constant pools, emit a lot of constants to constant pool.
 1527   // &quot;Randomize&quot; const_size.
 1528   if (ConstantsALot) {
 1529     const int num_consts = const_size();
 1530     for (int i = 0; i &lt; num_consts; i++) {
 1531       __ long_constant(0xB0B5B00BBABE);
 1532     }
 1533   }
 1534 #endif
 1535   if (!method_is_frameless) {
 1536     // Save return pc.
 1537     ___(std) std(return_pc, _abi(lr), callers_sp);
 1538   }
 1539 
<span class="line-modified"> 1540   C-&gt;set_frame_complete(cbuf.insts_size());</span>
 1541 }
 1542 #undef ___
 1543 #undef ___stop
 1544 #undef ___advance
 1545 
 1546 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1547   // Variable size. determine dynamically.
 1548   return MachNode::size(ra_);
 1549 }
 1550 
 1551 int MachPrologNode::reloc() const {
 1552   // Return number of relocatable values contained in this instruction.
 1553   return 1; // 1 reloc entry for load_const(toc).
 1554 }
 1555 
 1556 //=============================================================================
 1557 
 1558 #ifndef PRODUCT
 1559 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1560   Compile* C = ra_-&gt;C;
 1561 
 1562   st-&gt;print(&quot;EPILOG\n\t&quot;);
 1563   st-&gt;print(&quot;restore return pc\n\t&quot;);
 1564   st-&gt;print(&quot;pop frame\n\t&quot;);
 1565 
 1566   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1567     st-&gt;print(&quot;touch polling page\n\t&quot;);
 1568   }
 1569 }
 1570 #endif
 1571 
 1572 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1573   Compile* C = ra_-&gt;C;
 1574   MacroAssembler _masm(&amp;cbuf);
 1575 
<span class="line-modified"> 1576   const long framesize = ((long)C-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;</span>
 1577   assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
 1578 
 1579   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
 1580   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1581   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
 1582   const Register polling_page     = R12;
 1583 
 1584   if (!method_is_frameless) {
 1585     // Restore return pc relative to callers&#39; sp.
 1586     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
 1587   }
 1588 
 1589   if (method_needs_polling) {
 1590     if (SafepointMechanism::uses_thread_local_poll()) {
 1591       __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);
 1592     } else {
 1593       __ load_const_optimized(polling_page, (long)(address) os::get_polling_page());
 1594     }
 1595   }
 1596 
</pre>
<hr />
<pre>
 2484   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 2485   return CompressedKlassPointers::base() == NULL;
 2486 }
 2487 
 2488 // Is it better to copy float constants, or load them directly from memory?
 2489 // Intel can load a float constant from a direct address, requiring no
 2490 // extra registers. Most RISCs will have to materialize an address into a
 2491 // register first, so they would do better to copy the constant from stack.
 2492 const bool Matcher::rematerialize_float_constants = false;
 2493 
 2494 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2495 // needed. Else we split the double into 2 integer pieces and move it
 2496 // piece-by-piece. Only happens when passing doubles into C code as the
 2497 // Java calling convention forces doubles to be aligned.
 2498 const bool Matcher::misaligned_doubles_ok = true;
 2499 
 2500 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2501  Unimplemented();
 2502 }
 2503 
<span class="line-modified"> 2504 // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed"> 2505 // to implement the UseStrictFP mode.</span>
 2506 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2507 
 2508 // Do floats take an entire double register or just half?
 2509 //
 2510 // A float occupies a ppc64 double register. For the allocator, a
 2511 // ppc64 double register appears as a pair of float registers.
 2512 bool Matcher::float_in_double() { return true; }
 2513 
 2514 // Do ints take an entire long register or just half?
 2515 // The relevant question is how the int is callee-saved:
 2516 // the whole long is written but de-opt&#39;ing will have to extract
 2517 // the relevant 32 bits.
 2518 const bool Matcher::int_in_long = true;
 2519 
 2520 // Constants for c2c and c calling conventions.
 2521 
 2522 const MachRegisterNumbers iarg_reg[8] = {
 2523   R3_num, R4_num, R5_num, R6_num,
 2524   R7_num, R8_num, R9_num, R10_num
 2525 };
</pre>
<hr />
<pre>
 2770     const_toc_addr = __ long_constant((jlong)$src$$constant);
 2771     if (const_toc_addr == NULL) {
 2772       ciEnv::current()-&gt;record_out_of_memory_failure();
 2773       return;
 2774     }
 2775 
 2776     // Get the constant&#39;s TOC offset.
 2777     toc_offset = __ offset_to_method_toc(const_toc_addr);
 2778 
 2779     // Keep the current instruction offset in mind.
 2780     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2781 
 2782     __ ld($dst$$Register, toc_offset, $toc$$Register);
 2783   %}
 2784 
 2785   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
 2786     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 2787 
 2788     MacroAssembler _masm(&amp;cbuf);
 2789 
<span class="line-modified"> 2790     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {</span>
 2791       address const_toc_addr;
 2792       // Create a non-oop constant, no relocation needed.
 2793       // If it is an IC, it has a virtual_call_Relocation.
 2794       const_toc_addr = __ long_constant((jlong)$src$$constant);
 2795       if (const_toc_addr == NULL) {
 2796         ciEnv::current()-&gt;record_out_of_memory_failure();
 2797         return;
 2798       }
 2799 
 2800       // Get the constant&#39;s TOC offset.
 2801       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 2802       // Store the toc offset of the constant.
 2803       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 2804 
 2805       // Also keep the current instruction offset in mind.
 2806       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2807     }
 2808 
 2809     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 2810   %}
</pre>
<hr />
<pre>
 3037       __ relocate(a.rspec());
 3038     } else {
 3039       // Create a non-oop constant, no relocation needed.
 3040       const_toc_addr = __ long_constant((jlong)$src$$constant);
 3041     }
 3042 
 3043     if (const_toc_addr == NULL) {
 3044       ciEnv::current()-&gt;record_out_of_memory_failure();
 3045       return;
 3046     }
 3047     // Get the constant&#39;s TOC offset.
 3048     toc_offset = __ offset_to_method_toc(const_toc_addr);
 3049 
 3050     __ ld($dst$$Register, toc_offset, $toc$$Register);
 3051   %}
 3052 
 3053   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
 3054     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 3055 
 3056     MacroAssembler _masm(&amp;cbuf);
<span class="line-modified"> 3057     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {</span>
 3058       intptr_t val = $src$$constant;
 3059       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3060       address const_toc_addr;
 3061       if (constant_reloc == relocInfo::oop_type) {
 3062         // Create an oop constant and a corresponding relocation.
 3063         AddressLiteral a = __ allocate_oop_address((jobject)val);
 3064         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3065         __ relocate(a.rspec());
 3066       } else if (constant_reloc == relocInfo::metadata_type) {
 3067         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3068         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3069         __ relocate(a.rspec());
 3070       } else {  // non-oop pointers, e.g. card mark base, heap top
 3071         // Create a non-oop constant, no relocation needed.
 3072         const_toc_addr = __ long_constant((jlong)$src$$constant);
 3073       }
 3074 
 3075       if (const_toc_addr == NULL) {
 3076         ciEnv::current()-&gt;record_out_of_memory_failure();
 3077         return;
</pre>
<hr />
<pre>
 3775       // stub, and the entry point might be too far away for bl, so __ pc()
 3776       // serves as dummy and the bl will be patched later.
 3777       cbuf.set_insts_mark();
 3778       __ bl(__ pc());  // Emits a relocation.
 3779 
 3780       // The stub for call to interpreter.
 3781       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 3782       if (stub == NULL) {
 3783         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3784         return;
 3785       }
 3786     }
 3787   %}
 3788 
 3789   // Second node of expanded dynamic call - the call.
 3790   enc_class enc_java_dynamic_call_sched(method meth) %{
 3791     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3792 
 3793     MacroAssembler _masm(&amp;cbuf);
 3794 
<span class="line-modified"> 3795     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {</span>
 3796       // Create a call trampoline stub for the given method.
 3797       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
 3798       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
 3799       if (entry_point_const == NULL) {
 3800         ciEnv::current()-&gt;record_out_of_memory_failure();
 3801         return;
 3802       }
 3803       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
 3804       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
 3805       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
 3806 
 3807       // Build relocation at call site with ic position as data.
 3808       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
 3809              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
 3810              &quot;must have one, but can&#39;t have both&quot;);
 3811       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
 3812              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
 3813              &quot;must contain instruction offset&quot;);
 3814       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
 3815         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
</pre>
<hr />
<pre>
 4334 
 4335 // Integer Immediate: 16-bit
 4336 operand immI16() %{
 4337   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4338   op_cost(0);
 4339   match(ConI);
 4340   format %{ %}
 4341   interface(CONST_INTER);
 4342 %}
 4343 
 4344 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4345 operand immIhi16() %{
 4346   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4347   match(ConI);
 4348   op_cost(0);
 4349   format %{ %}
 4350   interface(CONST_INTER);
 4351 %}
 4352 
 4353 operand immInegpow2() %{
<span class="line-modified"> 4354   predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n-&gt;get_int()))));</span>
 4355   match(ConI);
 4356   op_cost(0);
 4357   format %{ %}
 4358   interface(CONST_INTER);
 4359 %}
 4360 
 4361 operand immIpow2minus1() %{
<span class="line-modified"> 4362   predicate(is_power_of_2_long((((jlong) (n-&gt;get_int()))+1)));</span>
 4363   match(ConI);
 4364   op_cost(0);
 4365   format %{ %}
 4366   interface(CONST_INTER);
 4367 %}
 4368 
 4369 operand immIpowerOf2() %{
<span class="line-modified"> 4370   predicate(is_power_of_2_long((((jlong) (julong) (juint) (n-&gt;get_int())))));</span>
 4371   match(ConI);
 4372   op_cost(0);
 4373   format %{ %}
 4374   interface(CONST_INTER);
 4375 %}
 4376 
 4377 // Unsigned Integer Immediate: the values 0-31
 4378 operand uimmI5() %{
 4379   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4380   match(ConI);
 4381   op_cost(0);
 4382   format %{ %}
 4383   interface(CONST_INTER);
 4384 %}
 4385 
 4386 // Unsigned Integer Immediate: 6-bit
 4387 operand uimmI6() %{
 4388   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4389   match(ConI);
 4390   op_cost(0);
</pre>
<hr />
<pre>
 4584 
 4585 // Long Immediate: 32-bit
 4586 operand immL32() %{
 4587   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4588   match(ConL);
 4589   op_cost(0);
 4590   format %{ %}
 4591   interface(CONST_INTER);
 4592 %}
 4593 
 4594 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4595 operand immLhighest16() %{
 4596   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4597   match(ConL);
 4598   op_cost(0);
 4599   format %{ %}
 4600   interface(CONST_INTER);
 4601 %}
 4602 
 4603 operand immLnegpow2() %{
<span class="line-modified"> 4604   predicate(is_power_of_2_long((jlong)-(n-&gt;get_long())));</span>
 4605   match(ConL);
 4606   op_cost(0);
 4607   format %{ %}
 4608   interface(CONST_INTER);
 4609 %}
 4610 
 4611 operand immLpow2minus1() %{
<span class="line-modified"> 4612   predicate(is_power_of_2_long((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;</span>
 4613             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4614   match(ConL);
 4615   op_cost(0);
 4616   format %{ %}
 4617   interface(CONST_INTER);
 4618 %}
 4619 
 4620 // constant &#39;long 0&#39;.
 4621 operand immL_0() %{
 4622   predicate(n-&gt;get_long() == 0L);
 4623   match(ConL);
 4624   op_cost(0);
 4625   format %{ %}
 4626   interface(CONST_INTER);
 4627 %}
 4628 
 4629 // constat &#39; long -1&#39;.
 4630 operand immL_minus1() %{
 4631   predicate(n-&gt;get_long() == -1L);
 4632   match(ConL);
</pre>
<hr />
<pre>
 6269   ins_field_cbuf_insts_offset(int);
 6270 
 6271   format %{ &quot;ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)&quot; %}
 6272   size(4);
 6273   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
 6274   ins_pipe(pipe_class_default);
 6275 %}
 6276 
 6277 // Expand node for constant pool load: large offset.
 6278 // No constant pool entries required.
 6279 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
 6280   effect(DEF dst, USE src, USE base);
 6281   predicate(false);
 6282 
 6283   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
 6284 
 6285   format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
 6286   size(4);
 6287   ins_encode %{
 6288     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<span class="line-modified"> 6289     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6290     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6291   %}
 6292   ins_pipe(pipe_class_memory);
 6293 %}
 6294 
 6295 // Load long constant from constant table. Expand in case of
 6296 // offset &gt; 16 bit is needed.
 6297 // Adlc adds toc node MachConstantTableBase.
 6298 instruct loadConL_Ex(iRegLdst dst, immL src) %{
 6299   match(Set dst src);
 6300   ins_cost(MEMORY_REF_COST);
 6301 
 6302   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded&quot; %}
 6303   // We can not inline the enc_class for the expand as that does not support constanttablebase.
 6304   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
 6305 %}
 6306 
 6307 // Load NULL as compressed oop.
 6308 instruct loadConN0(iRegNdst dst, immN_0 src) %{
 6309   match(Set dst src);
</pre>
<hr />
<pre>
 6554   ins_num_consts(1);
 6555   ins_field_const_toc_offset(int);
 6556 
 6557   format %{ &quot;ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)&quot; %}
 6558   size(4);
 6559   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
 6560   ins_pipe(pipe_class_default);
 6561 %}
 6562 
 6563 // Expand node for constant pool load: large offset.
 6564 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
 6565   match(Set dst src);
 6566   effect(TEMP base);
 6567 
 6568   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
 6569 
 6570   format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
 6571   size(4);
 6572   ins_encode %{
 6573     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<span class="line-modified"> 6574     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6575     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6576   %}
 6577   ins_pipe(pipe_class_memory);
 6578 %}
 6579 
 6580 // Load pointer constant from constant table. Expand in case an
 6581 // offset &gt; 16 bit is needed.
 6582 // Adlc adds toc node MachConstantTableBase.
 6583 instruct loadConP_Ex(iRegPdst dst, immP src) %{
 6584   match(Set dst src);
 6585   ins_cost(MEMORY_REF_COST);
 6586 
 6587   // This rule does not use &quot;expand&quot; because then
 6588   // the result type is not known to be an Oop.  An ADLC
 6589   // enhancement will be needed to make that work - not worth it!
 6590 
 6591   // If this instruction rematerializes, it prolongs the live range
 6592   // of the toc node, causing illegal graphs.
 6593   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
 6594   ins_cannot_rematerialize(true);
</pre>
</td>
<td>
<hr />
<pre>
 1280   offsets.ret_addr_offset = __ offset() - start_offset;
 1281 
 1282   return offsets;
 1283 }
 1284 
 1285 //=============================================================================
 1286 
 1287 // Factory for creating loadConL* nodes for large/small constant pool.
 1288 
 1289 static inline jlong replicate_immF(float con) {
 1290   // Replicate float con 2 times and pack into vector.
 1291   int val = *((int*)&amp;con);
 1292   jlong lval = val;
 1293   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
 1294   return lval;
 1295 }
 1296 
 1297 //=============================================================================
 1298 
 1299 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
<span class="line-modified"> 1300 int ConstantTable::calculate_table_base_offset() const {</span>
 1301   return 0;  // absolute addressing, no offset
 1302 }
 1303 
 1304 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
 1305 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1306   iRegPdstOper *op_dst = new iRegPdstOper();
 1307   MachNode *m1 = new loadToc_hiNode();
 1308   MachNode *m2 = new loadToc_loNode();
 1309 
 1310   m1-&gt;add_req(NULL);
 1311   m2-&gt;add_req(NULL, m1);
 1312   m1-&gt;_opnds[0] = op_dst;
 1313   m2-&gt;_opnds[0] = op_dst;
 1314   m2-&gt;_opnds[1] = op_dst;
 1315   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1316   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1317   nodes-&gt;push(m1);
 1318   nodes-&gt;push(m2);
 1319 }
 1320 
 1321 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1322   // Is postalloc expanded.
 1323   ShouldNotReachHere();
 1324 }
 1325 
 1326 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1327   return 0;
 1328 }
 1329 
 1330 #ifndef PRODUCT
 1331 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1332   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1333 }
 1334 #endif
 1335 
 1336 //=============================================================================
 1337 
 1338 #ifndef PRODUCT
 1339 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1340   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1341   const long framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1342 
 1343   st-&gt;print(&quot;PROLOG\n\t&quot;);
<span class="line-modified"> 1344   if (C-&gt;output()-&gt;need_stack_bang(framesize)) {</span>
 1345     st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
 1346   }
 1347 
 1348   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
 1349     st-&gt;print(&quot;save return pc\n\t&quot;);
 1350     st-&gt;print(&quot;push frame %ld\n\t&quot;, -framesize);
 1351   }
 1352 }
 1353 #endif
 1354 
 1355 // Macro used instead of the common __ to emulate the pipes of PPC.
 1356 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
 1357 // micro scheduler to cope with &quot;hand written&quot; assembler like in the prolog. Though
 1358 // still no scheduling of this code is possible, the micro scheduler is aware of the
 1359 // code and can update its internal data. The following mechanism is used to achieve this:
 1360 // The micro scheduler calls size() of each compound node during scheduling. size() does a
 1361 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
 1362 #if 0 // TODO: PPC port
 1363 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1364                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
 1365                 _masm.
 1366 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1367                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
 1368 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
 1369                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
 1370 #else
 1371 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
 1372                   Unimplemented();                                                    \
 1373                 _masm.
 1374 #define ___stop if (UsePower6SchedulerPPC64)                                          \
 1375                   Unimplemented()
 1376 #define ___advance if (UsePower6SchedulerPPC64)                                       \
 1377                   Unimplemented()
 1378 #endif
 1379 
 1380 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1381   Compile* C = ra_-&gt;C;
 1382   MacroAssembler _masm(&amp;cbuf);
 1383 
<span class="line-modified"> 1384   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
 1385   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1386 
 1387   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1388 
 1389   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1390   const Register callers_sp           = R21;
 1391   const Register push_frame_temp      = R22;
 1392   const Register toc_temp             = R23;
 1393   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1394 
 1395   if (method_is_frameless) {
 1396     // Add nop at beginning of all frameless methods to prevent any
 1397     // oop instructions from getting overwritten by make_not_entrant
 1398     // (patching attempt would fail).
 1399     ___(nop) nop();
 1400   } else {
 1401     // Get return pc.
 1402     ___(mflr) mflr(return_pc);
 1403   }
 1404 
</pre>
<hr />
<pre>
 1409     Register klass = toc_temp;
 1410 
 1411     // Notify OOP recorder (don&#39;t need the relocation)
 1412     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1413     __ load_const_optimized(klass, md.value(), R0);
 1414     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
 1415 
 1416     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
 1417     __ mtctr(klass);
 1418     __ bctr();
 1419 
 1420     __ bind(L_skip_barrier);
 1421   }
 1422 
 1423   // Calls to C2R adapters often do not accept exceptional returns.
 1424   // We require that their callers must bang for them. But be
 1425   // careful, because some VM calls (such as call site linkage) can
 1426   // use several kilobytes of stack. But the stack safety zone should
 1427   // account for that. See bugs 4446381, 4468289, 4497237.
 1428 
<span class="line-modified"> 1429   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1430   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
<span class="line-modified"> 1431   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
 1432     // Unfortunately we cannot use the function provided in
 1433     // assembler.cpp as we have to emulate the pipes. So I had to
 1434     // insert the code of generate_stack_overflow_check(), see
 1435     // assembler.cpp for some illuminative comments.
 1436     const int page_size = os::vm_page_size();
 1437     int bang_end = JavaThread::stack_shadow_zone_size();
 1438 
 1439     // This is how far the previous frame&#39;s stack banging extended.
 1440     const int bang_end_safe = bang_end;
 1441 
 1442     if (bangsize &gt; page_size) {
 1443       bang_end += bangsize;
 1444     }
 1445 
 1446     int bang_offset = bang_end_safe;
 1447 
 1448     while (bang_offset &lt;= bang_end) {
 1449       // Need at least one stack bang at end of shadow zone.
 1450 
 1451       // Again I had to copy code, this time from assembler_ppc.cpp,
</pre>
<hr />
<pre>
 1465         }
 1466       } else if (Assembler::is_simm(stdoffset, 31)) {
 1467         // Use largeoffset calculations for addis &amp; ld/std.
 1468         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
 1469         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
 1470 
 1471         Register tmp = R11;
 1472         ___(addis) addis(tmp, R1_SP, hi);
 1473         if (UseLoadInstructionsForStackBangingPPC64) {
 1474           ___(ld) ld(R0, lo, tmp);
 1475         } else {
 1476           ___(std) std(R0, lo, tmp);
 1477         }
 1478       } else {
 1479         ShouldNotReachHere();
 1480       }
 1481 
 1482       bang_offset += page_size;
 1483     }
 1484     // R11 trashed
<span class="line-modified"> 1485   } // C-&gt;output()-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging</span>
 1486 
 1487   unsigned int bytes = (unsigned int)framesize;
 1488   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
 1489   ciMethod *currMethod = C-&gt;method();
 1490 
 1491   // Optimized version for most common case.
 1492   if (UsePower6SchedulerPPC64 &amp;&amp;
 1493       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
 1494       !(false /* ConstantsALot TODO: PPC port*/)) {
 1495     ___(or) mr(callers_sp, R1_SP);
 1496     ___(std) std(return_pc, _abi(lr), R1_SP);
 1497     ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1498     return;
 1499   }
 1500 
 1501   if (!method_is_frameless) {
 1502     // Get callers sp.
 1503     ___(or) mr(callers_sp, R1_SP);
 1504 
 1505     // Push method&#39;s frame, modifies SP.
</pre>
<hr />
<pre>
 1520       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
 1521 
 1522       ___(stdux) stdux(R1_SP, R1_SP, tmp);
 1523     }
 1524   }
 1525 #if 0 // TODO: PPC port
 1526   // For testing large constant pools, emit a lot of constants to constant pool.
 1527   // &quot;Randomize&quot; const_size.
 1528   if (ConstantsALot) {
 1529     const int num_consts = const_size();
 1530     for (int i = 0; i &lt; num_consts; i++) {
 1531       __ long_constant(0xB0B5B00BBABE);
 1532     }
 1533   }
 1534 #endif
 1535   if (!method_is_frameless) {
 1536     // Save return pc.
 1537     ___(std) std(return_pc, _abi(lr), callers_sp);
 1538   }
 1539 
<span class="line-modified"> 1540   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
 1541 }
 1542 #undef ___
 1543 #undef ___stop
 1544 #undef ___advance
 1545 
 1546 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1547   // Variable size. determine dynamically.
 1548   return MachNode::size(ra_);
 1549 }
 1550 
 1551 int MachPrologNode::reloc() const {
 1552   // Return number of relocatable values contained in this instruction.
 1553   return 1; // 1 reloc entry for load_const(toc).
 1554 }
 1555 
 1556 //=============================================================================
 1557 
 1558 #ifndef PRODUCT
 1559 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1560   Compile* C = ra_-&gt;C;
 1561 
 1562   st-&gt;print(&quot;EPILOG\n\t&quot;);
 1563   st-&gt;print(&quot;restore return pc\n\t&quot;);
 1564   st-&gt;print(&quot;pop frame\n\t&quot;);
 1565 
 1566   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1567     st-&gt;print(&quot;touch polling page\n\t&quot;);
 1568   }
 1569 }
 1570 #endif
 1571 
 1572 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1573   Compile* C = ra_-&gt;C;
 1574   MacroAssembler _masm(&amp;cbuf);
 1575 
<span class="line-modified"> 1576   const long framesize = ((long)C-&gt;output()-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;</span>
 1577   assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
 1578 
 1579   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
 1580   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1581   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
 1582   const Register polling_page     = R12;
 1583 
 1584   if (!method_is_frameless) {
 1585     // Restore return pc relative to callers&#39; sp.
 1586     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
 1587   }
 1588 
 1589   if (method_needs_polling) {
 1590     if (SafepointMechanism::uses_thread_local_poll()) {
 1591       __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);
 1592     } else {
 1593       __ load_const_optimized(polling_page, (long)(address) os::get_polling_page());
 1594     }
 1595   }
 1596 
</pre>
<hr />
<pre>
 2484   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 2485   return CompressedKlassPointers::base() == NULL;
 2486 }
 2487 
 2488 // Is it better to copy float constants, or load them directly from memory?
 2489 // Intel can load a float constant from a direct address, requiring no
 2490 // extra registers. Most RISCs will have to materialize an address into a
 2491 // register first, so they would do better to copy the constant from stack.
 2492 const bool Matcher::rematerialize_float_constants = false;
 2493 
 2494 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2495 // needed. Else we split the double into 2 integer pieces and move it
 2496 // piece-by-piece. Only happens when passing doubles into C code as the
 2497 // Java calling convention forces doubles to be aligned.
 2498 const bool Matcher::misaligned_doubles_ok = true;
 2499 
 2500 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2501  Unimplemented();
 2502 }
 2503 
<span class="line-modified"> 2504 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>

 2505 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2506 
 2507 // Do floats take an entire double register or just half?
 2508 //
 2509 // A float occupies a ppc64 double register. For the allocator, a
 2510 // ppc64 double register appears as a pair of float registers.
 2511 bool Matcher::float_in_double() { return true; }
 2512 
 2513 // Do ints take an entire long register or just half?
 2514 // The relevant question is how the int is callee-saved:
 2515 // the whole long is written but de-opt&#39;ing will have to extract
 2516 // the relevant 32 bits.
 2517 const bool Matcher::int_in_long = true;
 2518 
 2519 // Constants for c2c and c calling conventions.
 2520 
 2521 const MachRegisterNumbers iarg_reg[8] = {
 2522   R3_num, R4_num, R5_num, R6_num,
 2523   R7_num, R8_num, R9_num, R10_num
 2524 };
</pre>
<hr />
<pre>
 2769     const_toc_addr = __ long_constant((jlong)$src$$constant);
 2770     if (const_toc_addr == NULL) {
 2771       ciEnv::current()-&gt;record_out_of_memory_failure();
 2772       return;
 2773     }
 2774 
 2775     // Get the constant&#39;s TOC offset.
 2776     toc_offset = __ offset_to_method_toc(const_toc_addr);
 2777 
 2778     // Keep the current instruction offset in mind.
 2779     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2780 
 2781     __ ld($dst$$Register, toc_offset, $toc$$Register);
 2782   %}
 2783 
 2784   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
 2785     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 2786 
 2787     MacroAssembler _masm(&amp;cbuf);
 2788 
<span class="line-modified"> 2789     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 2790       address const_toc_addr;
 2791       // Create a non-oop constant, no relocation needed.
 2792       // If it is an IC, it has a virtual_call_Relocation.
 2793       const_toc_addr = __ long_constant((jlong)$src$$constant);
 2794       if (const_toc_addr == NULL) {
 2795         ciEnv::current()-&gt;record_out_of_memory_failure();
 2796         return;
 2797       }
 2798 
 2799       // Get the constant&#39;s TOC offset.
 2800       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 2801       // Store the toc offset of the constant.
 2802       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 2803 
 2804       // Also keep the current instruction offset in mind.
 2805       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2806     }
 2807 
 2808     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 2809   %}
</pre>
<hr />
<pre>
 3036       __ relocate(a.rspec());
 3037     } else {
 3038       // Create a non-oop constant, no relocation needed.
 3039       const_toc_addr = __ long_constant((jlong)$src$$constant);
 3040     }
 3041 
 3042     if (const_toc_addr == NULL) {
 3043       ciEnv::current()-&gt;record_out_of_memory_failure();
 3044       return;
 3045     }
 3046     // Get the constant&#39;s TOC offset.
 3047     toc_offset = __ offset_to_method_toc(const_toc_addr);
 3048 
 3049     __ ld($dst$$Register, toc_offset, $toc$$Register);
 3050   %}
 3051 
 3052   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
 3053     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 3054 
 3055     MacroAssembler _masm(&amp;cbuf);
<span class="line-modified"> 3056     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 3057       intptr_t val = $src$$constant;
 3058       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3059       address const_toc_addr;
 3060       if (constant_reloc == relocInfo::oop_type) {
 3061         // Create an oop constant and a corresponding relocation.
 3062         AddressLiteral a = __ allocate_oop_address((jobject)val);
 3063         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3064         __ relocate(a.rspec());
 3065       } else if (constant_reloc == relocInfo::metadata_type) {
 3066         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3067         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3068         __ relocate(a.rspec());
 3069       } else {  // non-oop pointers, e.g. card mark base, heap top
 3070         // Create a non-oop constant, no relocation needed.
 3071         const_toc_addr = __ long_constant((jlong)$src$$constant);
 3072       }
 3073 
 3074       if (const_toc_addr == NULL) {
 3075         ciEnv::current()-&gt;record_out_of_memory_failure();
 3076         return;
</pre>
<hr />
<pre>
 3774       // stub, and the entry point might be too far away for bl, so __ pc()
 3775       // serves as dummy and the bl will be patched later.
 3776       cbuf.set_insts_mark();
 3777       __ bl(__ pc());  // Emits a relocation.
 3778 
 3779       // The stub for call to interpreter.
 3780       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 3781       if (stub == NULL) {
 3782         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3783         return;
 3784       }
 3785     }
 3786   %}
 3787 
 3788   // Second node of expanded dynamic call - the call.
 3789   enc_class enc_java_dynamic_call_sched(method meth) %{
 3790     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3791 
 3792     MacroAssembler _masm(&amp;cbuf);
 3793 
<span class="line-modified"> 3794     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 3795       // Create a call trampoline stub for the given method.
 3796       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
 3797       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
 3798       if (entry_point_const == NULL) {
 3799         ciEnv::current()-&gt;record_out_of_memory_failure();
 3800         return;
 3801       }
 3802       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
 3803       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
 3804       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
 3805 
 3806       // Build relocation at call site with ic position as data.
 3807       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
 3808              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
 3809              &quot;must have one, but can&#39;t have both&quot;);
 3810       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
 3811              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
 3812              &quot;must contain instruction offset&quot;);
 3813       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
 3814         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
</pre>
<hr />
<pre>
 4333 
 4334 // Integer Immediate: 16-bit
 4335 operand immI16() %{
 4336   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4337   op_cost(0);
 4338   match(ConI);
 4339   format %{ %}
 4340   interface(CONST_INTER);
 4341 %}
 4342 
 4343 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4344 operand immIhi16() %{
 4345   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4346   match(ConI);
 4347   op_cost(0);
 4348   format %{ %}
 4349   interface(CONST_INTER);
 4350 %}
 4351 
 4352 operand immInegpow2() %{
<span class="line-modified"> 4353   predicate(is_power_of_2((jlong) (julong) (juint) (-(n-&gt;get_int()))));</span>
 4354   match(ConI);
 4355   op_cost(0);
 4356   format %{ %}
 4357   interface(CONST_INTER);
 4358 %}
 4359 
 4360 operand immIpow2minus1() %{
<span class="line-modified"> 4361   predicate(is_power_of_2((((jlong) (n-&gt;get_int()))+1)));</span>
 4362   match(ConI);
 4363   op_cost(0);
 4364   format %{ %}
 4365   interface(CONST_INTER);
 4366 %}
 4367 
 4368 operand immIpowerOf2() %{
<span class="line-modified"> 4369   predicate(is_power_of_2((((jlong) (julong) (juint) (n-&gt;get_int())))));</span>
 4370   match(ConI);
 4371   op_cost(0);
 4372   format %{ %}
 4373   interface(CONST_INTER);
 4374 %}
 4375 
 4376 // Unsigned Integer Immediate: the values 0-31
 4377 operand uimmI5() %{
 4378   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4379   match(ConI);
 4380   op_cost(0);
 4381   format %{ %}
 4382   interface(CONST_INTER);
 4383 %}
 4384 
 4385 // Unsigned Integer Immediate: 6-bit
 4386 operand uimmI6() %{
 4387   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4388   match(ConI);
 4389   op_cost(0);
</pre>
<hr />
<pre>
 4583 
 4584 // Long Immediate: 32-bit
 4585 operand immL32() %{
 4586   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4587   match(ConL);
 4588   op_cost(0);
 4589   format %{ %}
 4590   interface(CONST_INTER);
 4591 %}
 4592 
 4593 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4594 operand immLhighest16() %{
 4595   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4596   match(ConL);
 4597   op_cost(0);
 4598   format %{ %}
 4599   interface(CONST_INTER);
 4600 %}
 4601 
 4602 operand immLnegpow2() %{
<span class="line-modified"> 4603   predicate(is_power_of_2((jlong)-(n-&gt;get_long())));</span>
 4604   match(ConL);
 4605   op_cost(0);
 4606   format %{ %}
 4607   interface(CONST_INTER);
 4608 %}
 4609 
 4610 operand immLpow2minus1() %{
<span class="line-modified"> 4611   predicate(is_power_of_2((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;</span>
 4612             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4613   match(ConL);
 4614   op_cost(0);
 4615   format %{ %}
 4616   interface(CONST_INTER);
 4617 %}
 4618 
 4619 // constant &#39;long 0&#39;.
 4620 operand immL_0() %{
 4621   predicate(n-&gt;get_long() == 0L);
 4622   match(ConL);
 4623   op_cost(0);
 4624   format %{ %}
 4625   interface(CONST_INTER);
 4626 %}
 4627 
 4628 // constat &#39; long -1&#39;.
 4629 operand immL_minus1() %{
 4630   predicate(n-&gt;get_long() == -1L);
 4631   match(ConL);
</pre>
<hr />
<pre>
 6268   ins_field_cbuf_insts_offset(int);
 6269 
 6270   format %{ &quot;ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)&quot; %}
 6271   size(4);
 6272   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
 6273   ins_pipe(pipe_class_default);
 6274 %}
 6275 
 6276 // Expand node for constant pool load: large offset.
 6277 // No constant pool entries required.
 6278 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
 6279   effect(DEF dst, USE src, USE base);
 6280   predicate(false);
 6281 
 6282   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
 6283 
 6284   format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
 6285   size(4);
 6286   ins_encode %{
 6287     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<span class="line-modified"> 6288     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6289     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6290   %}
 6291   ins_pipe(pipe_class_memory);
 6292 %}
 6293 
 6294 // Load long constant from constant table. Expand in case of
 6295 // offset &gt; 16 bit is needed.
 6296 // Adlc adds toc node MachConstantTableBase.
 6297 instruct loadConL_Ex(iRegLdst dst, immL src) %{
 6298   match(Set dst src);
 6299   ins_cost(MEMORY_REF_COST);
 6300 
 6301   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded&quot; %}
 6302   // We can not inline the enc_class for the expand as that does not support constanttablebase.
 6303   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
 6304 %}
 6305 
 6306 // Load NULL as compressed oop.
 6307 instruct loadConN0(iRegNdst dst, immN_0 src) %{
 6308   match(Set dst src);
</pre>
<hr />
<pre>
 6553   ins_num_consts(1);
 6554   ins_field_const_toc_offset(int);
 6555 
 6556   format %{ &quot;ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)&quot; %}
 6557   size(4);
 6558   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
 6559   ins_pipe(pipe_class_default);
 6560 %}
 6561 
 6562 // Expand node for constant pool load: large offset.
 6563 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
 6564   match(Set dst src);
 6565   effect(TEMP base);
 6566 
 6567   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
 6568 
 6569   format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
 6570   size(4);
 6571   ins_encode %{
 6572     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<span class="line-modified"> 6573     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6574     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6575   %}
 6576   ins_pipe(pipe_class_memory);
 6577 %}
 6578 
 6579 // Load pointer constant from constant table. Expand in case an
 6580 // offset &gt; 16 bit is needed.
 6581 // Adlc adds toc node MachConstantTableBase.
 6582 instruct loadConP_Ex(iRegPdst dst, immP src) %{
 6583   match(Set dst src);
 6584   ins_cost(MEMORY_REF_COST);
 6585 
 6586   // This rule does not use &quot;expand&quot; because then
 6587   // the result type is not known to be an Oop.  An ADLC
 6588   // enhancement will be needed to make that work - not worth it!
 6589 
 6590   // If this instruction rematerializes, it prolongs the live range
 6591   // of the toc node, causing illegal graphs.
 6592   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
 6593   ins_cannot_rematerialize(true);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_ppc.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_ppc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
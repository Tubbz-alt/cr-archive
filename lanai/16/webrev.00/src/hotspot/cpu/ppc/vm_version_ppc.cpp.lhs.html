<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/vm_version_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;jvm.h&quot;
 28 #include &quot;asm/assembler.inline.hpp&quot;
 29 #include &quot;asm/macroAssembler.inline.hpp&quot;
 30 #include &quot;compiler/disassembler.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 35 #include &quot;runtime/vm_version.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 #include &quot;utilities/defaultStream.hpp&quot;
 38 #include &quot;utilities/globalDefinitions.hpp&quot;
<a name="1" id="anc1"></a>
 39 
 40 #include &lt;sys/sysinfo.h&gt;
 41 #if defined(_AIX)
 42 #include &lt;libperfstat.h&gt;
 43 #endif
 44 
 45 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
 46 #include &lt;sys/auxv.h&gt;
 47 
 48 #ifndef PPC_FEATURE2_HTM_NOSC
 49 #define PPC_FEATURE2_HTM_NOSC (1 &lt;&lt; 24)
 50 #endif
 51 #endif
 52 
 53 bool VM_Version::_is_determine_features_test_running = false;
 54 uint64_t VM_Version::_dscr_val = 0;
 55 
 56 #define MSG(flag)   \
 57   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
 58       jio_fprintf(defaultStream::error_stream(),                       \
 59                   &quot;warning: -XX:+&quot; #flag &quot; requires -XX:+UseSIGTRAP\n&quot; \
 60                   &quot;         -XX:+&quot; #flag &quot; will be disabled!\n&quot;);
 61 
 62 void VM_Version::initialize() {
 63 
 64   // Test which instructions are supported and measure cache line size.
 65   determine_features();
 66 
 67   // If PowerArchitecturePPC64 hasn&#39;t been specified explicitly determine from features.
 68   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
 69     if (VM_Version::has_darn()) {
 70       FLAG_SET_ERGO(PowerArchitecturePPC64, 9);
 71     } else if (VM_Version::has_lqarx()) {
 72       FLAG_SET_ERGO(PowerArchitecturePPC64, 8);
 73     } else if (VM_Version::has_popcntw()) {
 74       FLAG_SET_ERGO(PowerArchitecturePPC64, 7);
 75     } else if (VM_Version::has_cmpb()) {
 76       FLAG_SET_ERGO(PowerArchitecturePPC64, 6);
 77     } else if (VM_Version::has_popcntb()) {
 78       FLAG_SET_ERGO(PowerArchitecturePPC64, 5);
 79     } else {
 80       FLAG_SET_ERGO(PowerArchitecturePPC64, 0);
 81     }
 82   }
 83 
 84   bool PowerArchitecturePPC64_ok = false;
 85   switch (PowerArchitecturePPC64) {
 86     case 9: if (!VM_Version::has_darn()   ) break;
 87     case 8: if (!VM_Version::has_lqarx()  ) break;
 88     case 7: if (!VM_Version::has_popcntw()) break;
 89     case 6: if (!VM_Version::has_cmpb()   ) break;
 90     case 5: if (!VM_Version::has_popcntb()) break;
 91     case 0: PowerArchitecturePPC64_ok = true; break;
 92     default: break;
 93   }
 94   guarantee(PowerArchitecturePPC64_ok, &quot;PowerArchitecturePPC64 cannot be set to &quot;
 95             UINTX_FORMAT &quot; on this machine&quot;, PowerArchitecturePPC64);
 96 
 97   // Power 8: Configure Data Stream Control Register.
 98   if (PowerArchitecturePPC64 &gt;= 8 &amp;&amp; has_mfdscr()) {
 99     config_dscr();
100   }
101 
102   if (!UseSIGTRAP) {
103     MSG(TrapBasedICMissChecks);
104     MSG(TrapBasedNotEntrantChecks);
105     MSG(TrapBasedNullChecks);
106     FLAG_SET_ERGO(TrapBasedNotEntrantChecks, false);
107     FLAG_SET_ERGO(TrapBasedNullChecks,       false);
108     FLAG_SET_ERGO(TrapBasedICMissChecks,     false);
109   }
110 
111 #ifdef COMPILER2
112   if (!UseSIGTRAP) {
113     MSG(TrapBasedRangeChecks);
114     FLAG_SET_ERGO(TrapBasedRangeChecks, false);
115   }
116 
117   // On Power6 test for section size.
118   if (PowerArchitecturePPC64 == 6) {
119     determine_section_size();
120   // TODO: PPC port } else {
121   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
122   }
123 
124   if (PowerArchitecturePPC64 &gt;= 8) {
125     if (FLAG_IS_DEFAULT(SuperwordUseVSX)) {
126       FLAG_SET_ERGO(SuperwordUseVSX, true);
127     }
128   } else {
129     if (SuperwordUseVSX) {
130       warning(&quot;SuperwordUseVSX specified, but needs at least Power8.&quot;);
131       FLAG_SET_DEFAULT(SuperwordUseVSX, false);
132     }
133   }
134   MaxVectorSize = SuperwordUseVSX ? 16 : 8;
135 
136   if (PowerArchitecturePPC64 &gt;= 9) {
137     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstructionsPPC64)) {
138       FLAG_SET_ERGO(UseCountTrailingZerosInstructionsPPC64, true);
139     }
140     if (FLAG_IS_DEFAULT(UseCharacterCompareIntrinsics)) {
141       FLAG_SET_ERGO(UseCharacterCompareIntrinsics, true);
142     }
143   } else {
144     if (UseCountTrailingZerosInstructionsPPC64) {
145       warning(&quot;UseCountTrailingZerosInstructionsPPC64 specified, but needs at least Power9.&quot;);
146       FLAG_SET_DEFAULT(UseCountTrailingZerosInstructionsPPC64, false);
147     }
148     if (UseCharacterCompareIntrinsics) {
149       warning(&quot;UseCharacterCompareIntrinsics specified, but needs at least Power9.&quot;);
150       FLAG_SET_DEFAULT(UseCharacterCompareIntrinsics, false);
151     }
152   }
153 #endif
154 
155   // Create and print feature-string.
156   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
157   jio_snprintf(buf, sizeof(buf),
158                &quot;ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
159                (has_fsqrt()   ? &quot; fsqrt&quot;   : &quot;&quot;),
160                (has_isel()    ? &quot; isel&quot;    : &quot;&quot;),
161                (has_lxarxeh() ? &quot; lxarxeh&quot; : &quot;&quot;),
162                (has_cmpb()    ? &quot; cmpb&quot;    : &quot;&quot;),
163                (has_popcntb() ? &quot; popcntb&quot; : &quot;&quot;),
164                (has_popcntw() ? &quot; popcntw&quot; : &quot;&quot;),
165                (has_fcfids()  ? &quot; fcfids&quot;  : &quot;&quot;),
166                (has_vand()    ? &quot; vand&quot;    : &quot;&quot;),
167                (has_lqarx()   ? &quot; lqarx&quot;   : &quot;&quot;),
168                (has_vcipher() ? &quot; aes&quot;     : &quot;&quot;),
169                (has_vpmsumb() ? &quot; vpmsumb&quot; : &quot;&quot;),
170                (has_mfdscr()  ? &quot; mfdscr&quot;  : &quot;&quot;),
171                (has_vsx()     ? &quot; vsx&quot;     : &quot;&quot;),
172                (has_ldbrx()   ? &quot; ldbrx&quot;   : &quot;&quot;),
173                (has_stdbrx()  ? &quot; stdbrx&quot;  : &quot;&quot;),
174                (has_vshasig() ? &quot; sha&quot;     : &quot;&quot;),
175                (has_tm()      ? &quot; rtm&quot;     : &quot;&quot;),
176                (has_darn()    ? &quot; darn&quot;    : &quot;&quot;)
177                // Make sure number of %s matches num_features!
178               );
179   _features_string = os::strdup(buf);
180   if (Verbose) {
181     print_features();
182   }
183 
184   // PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)
185   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
186   _supports_cx8 = true;
187 
188   // Used by C1.
189   _supports_atomic_getset4 = true;
190   _supports_atomic_getadd4 = true;
191   _supports_atomic_getset8 = true;
192   _supports_atomic_getadd8 = true;
193 
<a name="2" id="anc2"></a><span class="line-removed">194   UseSSE = 0; // Only on x86 and x64</span>
<span class="line-removed">195 </span>
196   intx cache_line_size = L1_data_cache_line_size();
197 
198   if (PowerArchitecturePPC64 &gt;= 9) {
199     if (os::supports_map_sync() == true) {
200       _data_cache_line_flush_size = cache_line_size;
201     }
202   }
203 
204   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
205 
206   if (AllocatePrefetchStyle == 4) {
207     AllocatePrefetchStepSize = cache_line_size; // Need exact value.
208     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.
209     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?
210   } else {
211     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
212     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.
213     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?
214   }
215 
216   assert(AllocatePrefetchLines &gt; 0, &quot;invalid value&quot;);
217   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
218     AllocatePrefetchLines = 1; // Conservative value.
219   }
220 
221   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
222     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
223   }
224 
225   assert(AllocatePrefetchStyle &gt;= 0, &quot;AllocatePrefetchStyle should be positive&quot;);
226 
<a name="3" id="anc3"></a>



227   // If running on Power8 or newer hardware, the implementation uses the available vector instructions.
228   // In all other cases, the implementation uses only generally available instructions.
229   if (!UseCRC32Intrinsics) {
230     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
231       FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
232     }
233   }
234 
235   // Implementation does not use any of the vector instructions available with Power8.
236   // Their exploitation is still pending (aka &quot;work in progress&quot;).
237   if (!UseCRC32CIntrinsics) {
238     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
239       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
240     }
241   }
242 
243   // TODO: Provide implementation.
244   if (UseAdler32Intrinsics) {
245     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
246     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
247   }
248 
249   // The AES intrinsic stubs require AES instruction support.
250   if (has_vcipher()) {
251     if (FLAG_IS_DEFAULT(UseAES)) {
252       UseAES = true;
253     }
254   } else if (UseAES) {
255     if (!FLAG_IS_DEFAULT(UseAES))
256       warning(&quot;AES instructions are not available on this CPU&quot;);
257     FLAG_SET_DEFAULT(UseAES, false);
258   }
259 
260   if (UseAES &amp;&amp; has_vcipher()) {
261     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
262       UseAESIntrinsics = true;
263     }
264   } else if (UseAESIntrinsics) {
265     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
266       warning(&quot;AES intrinsics are not available on this CPU&quot;);
267     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
268   }
269 
270   if (UseAESCTRIntrinsics) {
271     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
272     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
273   }
274 
275   if (UseGHASHIntrinsics) {
276     warning(&quot;GHASH intrinsics are not available on this CPU&quot;);
277     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
278   }
279 
280   if (FLAG_IS_DEFAULT(UseFMA)) {
281     FLAG_SET_DEFAULT(UseFMA, true);
282   }
283 
284   if (has_vshasig()) {
285     if (FLAG_IS_DEFAULT(UseSHA)) {
286       UseSHA = true;
287     }
288   } else if (UseSHA) {
289     if (!FLAG_IS_DEFAULT(UseSHA))
290       warning(&quot;SHA instructions are not available on this CPU&quot;);
291     FLAG_SET_DEFAULT(UseSHA, false);
292   }
293 
294   if (UseSHA1Intrinsics) {
295     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
296     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
297   }
298 
299   if (UseSHA &amp;&amp; has_vshasig()) {
300     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
301       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
302     }
303   } else if (UseSHA256Intrinsics) {
304     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
305     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
306   }
307 
308   if (UseSHA &amp;&amp; has_vshasig()) {
309     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
310       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
311     }
312   } else if (UseSHA512Intrinsics) {
313     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
314     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
315   }
316 
317   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
318     FLAG_SET_DEFAULT(UseSHA, false);
319   }
320 
321 #ifdef COMPILER2
322   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
323     UseSquareToLenIntrinsic = true;
324   }
325   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
326     UseMulAddIntrinsic = true;
327   }
328   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
329     UseMultiplyToLenIntrinsic = true;
330   }
331   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
332     UseMontgomeryMultiplyIntrinsic = true;
333   }
334   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
335     UseMontgomerySquareIntrinsic = true;
336   }
337 #endif
338 
339   if (UseVectorizedMismatchIntrinsic) {
340     warning(&quot;UseVectorizedMismatchIntrinsic specified, but not available on this CPU.&quot;);
341     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
342   }
343 
344 
345   // Adjust RTM (Restricted Transactional Memory) flags.
346   if (UseRTMLocking) {
347     // If CPU or OS do not support TM:
348     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
349     // setting during arguments processing. See use_biased_locking().
350     // VM_Version_init() is executed after UseBiasedLocking is used
351     // in Thread::allocate().
352     if (PowerArchitecturePPC64 &lt; 8) {
353       vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU.&quot;);
354     }
355 
356     if (!has_tm()) {
357       vm_exit_during_initialization(&quot;RTM is not supported on this OS version.&quot;);
358     }
359   }
360 
361   if (UseRTMLocking) {
362 #if INCLUDE_RTM_OPT
363     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
364       // RTM locking should be used only for applications with
365       // high lock contention. For now we do not use it by default.
366       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
367     }
368 #else
369     // Only C2 does RTM locking optimization.
370     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
371     // setting during arguments processing. See use_biased_locking().
372     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
373 #endif
374   } else { // !UseRTMLocking
375     if (UseRTMForStackLocks) {
376       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
377         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
378       }
379       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
380     }
381     if (UseRTMDeopt) {
382       FLAG_SET_DEFAULT(UseRTMDeopt, false);
383     }
384 #ifdef COMPILER2
385     if (PrintPreciseRTMLockingStatistics) {
386       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
387     }
388 #endif
389   }
390 
391   // This machine allows unaligned memory accesses
392   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
393     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
394   }
395 
396   check_virtualizations();
397 }
398 
399 void VM_Version::check_virtualizations() {
400 #if defined(_AIX)
401   int rc = 0;
402   perfstat_partition_total_t pinfo;
403   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);
404   if (rc == 1) {
405     Abstract_VM_Version::_detected_virtualization = PowerVM;
406   }
407 #else
408   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;
409   // system_type=...qemu indicates PowerKVM
410   // e.g. system_type=IBM pSeries (emulated by qemu)
411   char line[500];
412   FILE* fp = fopen(info_file, &quot;r&quot;);
413   if (fp == NULL) {
414     return;
415   }
416   const char* system_type=&quot;system_type=&quot;;  // in case this line contains qemu, it is KVM
417   const char* num_lpars=&quot;NumLpars=&quot;; // in case of non-KVM : if this line is found it is PowerVM
418   bool num_lpars_found = false;
419 
420   while (fgets(line, sizeof(line), fp) != NULL) {
421     if (strncmp(line, system_type, strlen(system_type)) == 0) {
422       if (strstr(line, &quot;qemu&quot;) != 0) {
423         Abstract_VM_Version::_detected_virtualization = PowerKVM;
424         fclose(fp);
425         return;
426       }
427     }
428     if (strncmp(line, num_lpars, strlen(num_lpars)) == 0) {
429       num_lpars_found = true;
430     }
431   }
432   if (num_lpars_found) {
433     Abstract_VM_Version::_detected_virtualization = PowerVM;
434   } else {
435     Abstract_VM_Version::_detected_virtualization = PowerFullPartitionMode;
436   }
437   fclose(fp);
438 #endif
439 }
440 
441 void VM_Version::print_platform_virtualization_info(outputStream* st) {
442 #if defined(_AIX)
443   // more info about perfstat API see
444   // https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.prftools/idprftools_perfstat_glob_partition.htm
445   int rc = 0;
446   perfstat_partition_total_t pinfo;
447   memset(&amp;pinfo, 0, sizeof(perfstat_partition_total_t));
448   rc = perfstat_partition_total(NULL, &amp;pinfo, sizeof(perfstat_partition_total_t), 1);
449   if (rc != 1) {
450     return;
451   } else {
452     st-&gt;print_cr(&quot;Virtualization type   : PowerVM&quot;);
453   }
454   // CPU information
455   perfstat_cpu_total_t cpuinfo;
456   memset(&amp;cpuinfo, 0, sizeof(perfstat_cpu_total_t));
457   rc = perfstat_cpu_total(NULL, &amp;cpuinfo, sizeof(perfstat_cpu_total_t), 1);
458   if (rc != 1) {
459     return;
460   }
461 
462   st-&gt;print_cr(&quot;Processor description : %s&quot;, cpuinfo.description);
463   st-&gt;print_cr(&quot;Processor speed       : %llu Hz&quot;, cpuinfo.processorHZ);
464 
465   st-&gt;print_cr(&quot;LPAR partition name           : %s&quot;, pinfo.name);
466   st-&gt;print_cr(&quot;LPAR partition number         : %u&quot;, pinfo.lpar_id);
467   st-&gt;print_cr(&quot;LPAR partition type           : %s&quot;, pinfo.type.b.shared_enabled ? &quot;shared&quot; : &quot;dedicated&quot;);
468   st-&gt;print_cr(&quot;LPAR mode                     : %s&quot;, pinfo.type.b.donate_enabled ? &quot;donating&quot; : pinfo.type.b.capped ? &quot;capped&quot; : &quot;uncapped&quot;);
469   st-&gt;print_cr(&quot;LPAR partition group ID       : %u&quot;, pinfo.group_id);
470   st-&gt;print_cr(&quot;LPAR shared pool ID           : %u&quot;, pinfo.pool_id);
471 
472   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_capable ? &quot;capable&quot; : &quot;not capable&quot;);
473   st-&gt;print_cr(&quot;AMS (active memory sharing)   : %s&quot;, pinfo.type.b.ams_enabled ? &quot;on&quot; : &quot;off&quot;);
474   st-&gt;print_cr(&quot;AME (active memory expansion) : %s&quot;, pinfo.type.b.ame_enabled ? &quot;on&quot; : &quot;off&quot;);
475 
476   if (pinfo.type.b.ame_enabled) {
477     st-&gt;print_cr(&quot;AME true memory in bytes      : %llu&quot;, pinfo.true_memory);
478     st-&gt;print_cr(&quot;AME expanded memory in bytes  : %llu&quot;, pinfo.expanded_memory);
479   }
480 
481   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_capable ? &quot;capable&quot; : &quot;not capable&quot;);
482   st-&gt;print_cr(&quot;SMT : %s&quot;, pinfo.type.b.smt_enabled ? &quot;on&quot; : &quot;off&quot;);
483   int ocpus = pinfo.online_cpus &gt; 0 ?  pinfo.online_cpus : 1;
484   st-&gt;print_cr(&quot;LPAR threads              : %d&quot;, cpuinfo.ncpus/ocpus);
485   st-&gt;print_cr(&quot;LPAR online virtual cpus  : %d&quot;, pinfo.online_cpus);
486   st-&gt;print_cr(&quot;LPAR logical cpus         : %d&quot;, cpuinfo.ncpus);
487   st-&gt;print_cr(&quot;LPAR maximum virtual cpus : %u&quot;, pinfo.max_cpus);
488   st-&gt;print_cr(&quot;LPAR minimum virtual cpus : %u&quot;, pinfo.min_cpus);
489   st-&gt;print_cr(&quot;LPAR entitled capacity    : %4.2f&quot;, (double) (pinfo.entitled_proc_capacity/100.0));
490   st-&gt;print_cr(&quot;LPAR online memory        : %llu MB&quot;, pinfo.online_memory);
491   st-&gt;print_cr(&quot;LPAR maximum memory       : %llu MB&quot;, pinfo.max_memory);
492   st-&gt;print_cr(&quot;LPAR minimum memory       : %llu MB&quot;, pinfo.min_memory);
493 #else
494   const char* info_file = &quot;/proc/ppc64/lparcfg&quot;;
495   const char* kw[] = { &quot;system_type=&quot;, // qemu indicates PowerKVM
496                        &quot;partition_entitled_capacity=&quot;, // entitled processor capacity percentage
497                        &quot;partition_max_entitled_capacity=&quot;,
498                        &quot;capacity_weight=&quot;, // partition CPU weight
499                        &quot;partition_active_processors=&quot;,
500                        &quot;partition_potential_processors=&quot;,
501                        &quot;entitled_proc_capacity_available=&quot;,
502                        &quot;capped=&quot;, // 0 - uncapped, 1 - vcpus capped at entitled processor capacity percentage
503                        &quot;shared_processor_mode=&quot;, // (non)dedicated partition
504                        &quot;system_potential_processors=&quot;,
505                        &quot;pool=&quot;, // CPU-pool number
506                        &quot;pool_capacity=&quot;,
507                        &quot;NumLpars=&quot;, // on non-KVM machines, NumLpars is not found for full partition mode machines
508                        NULL };
509   if (!print_matching_lines_from_file(info_file, st, kw)) {
510     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);
511   }
512 #endif
513 }
514 
515 bool VM_Version::use_biased_locking() {
516 #if INCLUDE_RTM_OPT
517   // RTM locking is most useful when there is high lock contention and
518   // low data contention. With high lock contention the lock is usually
519   // inflated and biased locking is not suitable for that case.
520   // RTM locking code requires that biased locking is off.
521   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
522   // because it is used by Thread::allocate() which is called before
523   // VM_Version::initialize().
524   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
525     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
526       FLAG_SET_DEFAULT(UseBiasedLocking, false);
527     } else {
528       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
529       UseBiasedLocking = false;
530     }
531   }
532 #endif
533   return UseBiasedLocking;
534 }
535 
536 void VM_Version::print_features() {
537   tty-&gt;print_cr(&quot;Version: %s L1_data_cache_line_size=%d&quot;, features_string(), L1_data_cache_line_size());
<a name="4" id="anc4"></a>






538 }
539 
540 #ifdef COMPILER2
541 // Determine section size on power6: If section size is 8 instructions,
542 // there should be a difference between the two testloops of ~15 %. If
543 // no difference is detected the section is assumed to be 32 instructions.
544 void VM_Version::determine_section_size() {
545 
546   int unroll = 80;
547 
548   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
549 
550   // Allocate space for the code.
551   ResourceMark rm;
552   CodeBuffer cb(&quot;detect_section_size&quot;, code_size, 0);
553   MacroAssembler* a = new MacroAssembler(&amp;cb);
554 
555   uint32_t *code = (uint32_t *)a-&gt;pc();
556   // Emit code.
557   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
558 
559   Label l1;
560 
561   a-&gt;li(R4, 1);
562   a-&gt;sldi(R4, R4, 28);
563   a-&gt;b(l1);
564   a-&gt;align(CodeEntryAlignment);
565 
566   a-&gt;bind(l1);
567 
568   for (int i = 0; i &lt; unroll; i++) {
569     // Schleife 1
570     // ------- sector 0 ------------
571     // ;; 0
572     a-&gt;nop();                   // 1
573     a-&gt;fpnop0();                // 2
574     a-&gt;fpnop1();                // 3
575     a-&gt;addi(R4,R4, -1); // 4
576 
577     // ;;  1
578     a-&gt;nop();                   // 5
579     a-&gt;fmr(F6, F6);             // 6
580     a-&gt;fmr(F7, F7);             // 7
581     a-&gt;endgroup();              // 8
582     // ------- sector 8 ------------
583 
584     // ;;  2
585     a-&gt;nop();                   // 9
586     a-&gt;nop();                   // 10
587     a-&gt;fmr(F8, F8);             // 11
588     a-&gt;fmr(F9, F9);             // 12
589 
590     // ;;  3
591     a-&gt;nop();                   // 13
592     a-&gt;fmr(F10, F10);           // 14
593     a-&gt;fmr(F11, F11);           // 15
594     a-&gt;endgroup();              // 16
595     // -------- sector 16 -------------
596 
597     // ;;  4
598     a-&gt;nop();                   // 17
599     a-&gt;nop();                   // 18
600     a-&gt;fmr(F15, F15);           // 19
601     a-&gt;fmr(F16, F16);           // 20
602 
603     // ;;  5
604     a-&gt;nop();                   // 21
605     a-&gt;fmr(F17, F17);           // 22
606     a-&gt;fmr(F18, F18);           // 23
607     a-&gt;endgroup();              // 24
608     // ------- sector 24  ------------
609 
610     // ;;  6
611     a-&gt;nop();                   // 25
612     a-&gt;nop();                   // 26
613     a-&gt;fmr(F19, F19);           // 27
614     a-&gt;fmr(F20, F20);           // 28
615 
616     // ;;  7
617     a-&gt;nop();                   // 29
618     a-&gt;fmr(F21, F21);           // 30
619     a-&gt;fmr(F22, F22);           // 31
620     a-&gt;brnop0();                // 32
621 
622     // ------- sector 32 ------------
623   }
624 
625   // ;; 8
626   a-&gt;cmpdi(CCR0, R4, unroll);   // 33
627   a-&gt;bge(CCR0, l1);             // 34
628   a-&gt;blr();
629 
630   // Emit code.
631   void (*test2)() = (void(*)())(void *)a-&gt;function_entry();
632   // uint32_t *code = (uint32_t *)a-&gt;pc();
633 
634   Label l2;
635 
636   a-&gt;li(R4, 1);
637   a-&gt;sldi(R4, R4, 28);
638   a-&gt;b(l2);
639   a-&gt;align(CodeEntryAlignment);
640 
641   a-&gt;bind(l2);
642 
643   for (int i = 0; i &lt; unroll; i++) {
644     // Schleife 2
645     // ------- sector 0 ------------
646     // ;; 0
647     a-&gt;brnop0();                  // 1
648     a-&gt;nop();                     // 2
649     //a-&gt;cmpdi(CCR0, R4, unroll);
650     a-&gt;fpnop0();                  // 3
651     a-&gt;fpnop1();                  // 4
652     a-&gt;addi(R4,R4, -1);           // 5
653 
654     // ;; 1
655 
656     a-&gt;nop();                     // 6
657     a-&gt;fmr(F6, F6);               // 7
658     a-&gt;fmr(F7, F7);               // 8
659     // ------- sector 8 ---------------
660 
661     // ;; 2
662     a-&gt;endgroup();                // 9
663 
664     // ;; 3
665     a-&gt;nop();                     // 10
666     a-&gt;nop();                     // 11
667     a-&gt;fmr(F8, F8);               // 12
668 
669     // ;; 4
670     a-&gt;fmr(F9, F9);               // 13
671     a-&gt;nop();                     // 14
672     a-&gt;fmr(F10, F10);             // 15
673 
674     // ;; 5
675     a-&gt;fmr(F11, F11);             // 16
676     // -------- sector 16 -------------
677 
678     // ;; 6
679     a-&gt;endgroup();                // 17
680 
681     // ;; 7
682     a-&gt;nop();                     // 18
683     a-&gt;nop();                     // 19
684     a-&gt;fmr(F15, F15);             // 20
685 
686     // ;; 8
687     a-&gt;fmr(F16, F16);             // 21
688     a-&gt;nop();                     // 22
689     a-&gt;fmr(F17, F17);             // 23
690 
691     // ;; 9
692     a-&gt;fmr(F18, F18);             // 24
693     // -------- sector 24 -------------
694 
695     // ;; 10
696     a-&gt;endgroup();                // 25
697 
698     // ;; 11
699     a-&gt;nop();                     // 26
700     a-&gt;nop();                     // 27
701     a-&gt;fmr(F19, F19);             // 28
702 
703     // ;; 12
704     a-&gt;fmr(F20, F20);             // 29
705     a-&gt;nop();                     // 30
706     a-&gt;fmr(F21, F21);             // 31
707 
708     // ;; 13
709     a-&gt;fmr(F22, F22);             // 32
710   }
711 
712   // -------- sector 32 -------------
713   // ;; 14
714   a-&gt;cmpdi(CCR0, R4, unroll); // 33
715   a-&gt;bge(CCR0, l2);           // 34
716 
717   a-&gt;blr();
718   uint32_t *code_end = (uint32_t *)a-&gt;pc();
719   a-&gt;flush();
720 
721   cb.insts()-&gt;set_end((u_char*)code_end);
722 
723   double loop1_seconds,loop2_seconds, rel_diff;
724   uint64_t start1, stop1;
725 
726   start1 = os::current_thread_cpu_time(false);
727   (*test1)();
728   stop1 = os::current_thread_cpu_time(false);
729   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
730 
731 
732   start1 = os::current_thread_cpu_time(false);
733   (*test2)();
734   stop1 = os::current_thread_cpu_time(false);
735 
736   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
737 
738   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
739 
740   if (PrintAssembly || PrintStubCode) {
741     ttyLocker ttyl;
742     tty-&gt;print_cr(&quot;Decoding section size detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
743     // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.
744     Disassembler::decode(&amp;cb, (u_char*)code, (u_char*)code_end, tty);
745     tty-&gt;print_cr(&quot;Time loop1 :%f&quot;, loop1_seconds);
746     tty-&gt;print_cr(&quot;Time loop2 :%f&quot;, loop2_seconds);
747     tty-&gt;print_cr(&quot;(time2 - time1) / time1 = %f %%&quot;, rel_diff);
748 
749     if (rel_diff &gt; 12.0) {
750       tty-&gt;print_cr(&quot;Section Size 8 Instructions&quot;);
751     } else{
752       tty-&gt;print_cr(&quot;Section Size 32 Instructions or Power5&quot;);
753     }
754   }
755 
756 #if 0 // TODO: PPC port
757   // Set sector size (if not set explicitly).
758   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
759     if (rel_diff &gt; 12.0) {
760       PdScheduling::power6SectorSize = 0x20;
761     } else {
762       PdScheduling::power6SectorSize = 0x80;
763     }
764   } else if (Power6SectorSize128PPC64) {
765     PdScheduling::power6SectorSize = 0x80;
766   } else {
767     PdScheduling::power6SectorSize = 0x20;
768   }
769 #endif
770   if (UsePower6SchedulerPPC64) Unimplemented();
771 }
772 #endif // COMPILER2
773 
774 void VM_Version::determine_features() {
775 #if defined(ABI_ELFv2)
776   // 1 InstWord per call for the blr instruction.
777   const int code_size = (num_features+1+2*1)*BytesPerInstWord;
778 #else
779   // 7 InstWords for each call (function descriptor + blr instruction).
780   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
781 #endif
782   int features = 0;
783 
784   // create test area
785   enum { BUFFER_SIZE = 2*4*K }; // Needs to be &gt;=2* max cache line size (cache line size can&#39;t exceed min page size).
786   char test_area[BUFFER_SIZE];
787   char *mid_of_test_area = &amp;test_area[BUFFER_SIZE&gt;&gt;1];
788 
789   // Allocate space for the code.
790   ResourceMark rm;
791   CodeBuffer cb(&quot;detect_cpu_features&quot;, code_size, 0);
792   MacroAssembler* a = new MacroAssembler(&amp;cb);
793 
794   // Must be set to true so we can generate the test code.
795   _features = VM_Version::all_features_m;
796 
797   // Emit code.
798   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a-&gt;function_entry();
799   uint32_t *code = (uint32_t *)a-&gt;pc();
800   // Don&#39;t use R0 in ldarx.
801   // Keep R3_ARG1 unmodified, it contains &amp;field (see below).
802   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
803   a-&gt;fsqrt(F3, F4);                            // code[0]  -&gt; fsqrt_m
804   a-&gt;fsqrts(F3, F4);                           // code[1]  -&gt; fsqrts_m
805   a-&gt;isel(R7, R5, R6, 0);                      // code[2]  -&gt; isel_m
806   a-&gt;ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -&gt; lxarx_m
807   a-&gt;cmpb(R7, R5, R6);                         // code[4]  -&gt; cmpb
808   a-&gt;popcntb(R7, R5);                          // code[5]  -&gt; popcntb
809   a-&gt;popcntw(R7, R5);                          // code[6]  -&gt; popcntw
810   a-&gt;fcfids(F3, F4);                           // code[7]  -&gt; fcfids
811   a-&gt;vand(VR0, VR0, VR0);                      // code[8]  -&gt; vand
812   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
813   a-&gt;lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -&gt; lqarx_m
814   a-&gt;vcipher(VR0, VR1, VR2);                   // code[10] -&gt; vcipher
815   a-&gt;vpmsumb(VR0, VR1, VR2);                   // code[11] -&gt; vpmsumb
816   a-&gt;mfdscr(R0);                               // code[12] -&gt; mfdscr
817   a-&gt;lxvd2x(VSR0, R3_ARG1);                    // code[13] -&gt; vsx
818   a-&gt;ldbrx(R7, R3_ARG1, R4_ARG2);              // code[14] -&gt; ldbrx
819   a-&gt;stdbrx(R7, R3_ARG1, R4_ARG2);             // code[15] -&gt; stdbrx
820   a-&gt;vshasigmaw(VR0, VR1, 1, 0xF);             // code[16] -&gt; vshasig
821   // rtm is determined by OS
822   a-&gt;darn(R7);                                 // code[17] -&gt; darn
823   a-&gt;blr();
824 
825   // Emit function to set one cache line to zero. Emit function descriptor and get pointer to it.
826   void (*zero_cacheline_func_ptr)(char*) = (void(*)(char*))(void *)a-&gt;function_entry();
827   a-&gt;dcbz(R3_ARG1); // R3_ARG1 = addr
828   a-&gt;blr();
829 
830   uint32_t *code_end = (uint32_t *)a-&gt;pc();
831   a-&gt;flush();
832   _features = VM_Version::unknown_m;
833 
834   // Print the detection code.
835   if (PrintAssembly) {
836     ttyLocker ttyl;
837     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
838     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
839   }
840 
841   // Measure cache line size.
842   memset(test_area, 0xFF, BUFFER_SIZE); // Fill test area with 0xFF.
843   (*zero_cacheline_func_ptr)(mid_of_test_area); // Call function which executes dcbz to the middle.
844   int count = 0; // count zeroed bytes
845   for (int i = 0; i &lt; BUFFER_SIZE; i++) if (test_area[i] == 0) count++;
846   guarantee(is_power_of_2(count), &quot;cache line size needs to be a power of 2&quot;);
847   _L1_data_cache_line_size = count;
848 
849   // Execute code. Illegal instructions will be replaced by 0 in the signal handler.
850   VM_Version::_is_determine_features_test_running = true;
851   // We must align the first argument to 16 bytes because of the lqarx check.
852   (*test)(align_up((address)mid_of_test_area, 16), 0);
853   VM_Version::_is_determine_features_test_running = false;
854 
855   // determine which instructions are legal.
856   int feature_cntr = 0;
857   if (code[feature_cntr++]) features |= fsqrt_m;
858   if (code[feature_cntr++]) features |= fsqrts_m;
859   if (code[feature_cntr++]) features |= isel_m;
860   if (code[feature_cntr++]) features |= lxarxeh_m;
861   if (code[feature_cntr++]) features |= cmpb_m;
862   if (code[feature_cntr++]) features |= popcntb_m;
863   if (code[feature_cntr++]) features |= popcntw_m;
864   if (code[feature_cntr++]) features |= fcfids_m;
865   if (code[feature_cntr++]) features |= vand_m;
866   if (code[feature_cntr++]) features |= lqarx_m;
867   if (code[feature_cntr++]) features |= vcipher_m;
868   if (code[feature_cntr++]) features |= vpmsumb_m;
869   if (code[feature_cntr++]) features |= mfdscr_m;
870   if (code[feature_cntr++]) features |= vsx_m;
871   if (code[feature_cntr++]) features |= ldbrx_m;
872   if (code[feature_cntr++]) features |= stdbrx_m;
873   if (code[feature_cntr++]) features |= vshasig_m;
874   // feature rtm_m is determined by OS
875   if (code[feature_cntr++]) features |= darn_m;
876 
877   // Print the detection code.
878   if (PrintAssembly) {
879     ttyLocker ttyl;
880     tty-&gt;print_cr(&quot;Decoding cpu-feature detection stub at &quot; INTPTR_FORMAT &quot; after execution:&quot;, p2i(code));
881     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
882   }
883 
884   _features = features;
885 
886 #ifdef AIX
887   // To enable it on AIX it&#39;s necessary POWER8 or above and at least AIX 7.2.
888   // Actually, this is supported since AIX 7.1.. Unfortunately, this first
889   // contained bugs, so that it can only be enabled after AIX 7.1.3.30.
890   // The Java property os.version, which is used in RTM tests to decide
891   // whether the feature is available, only knows major and minor versions.
892   // We don&#39;t want to change this property, as user code might depend on it.
893   // So the tests can not check on subversion 3.30, and we only enable RTM
894   // with AIX 7.2.
895   if (has_lqarx()) { // POWER8 or above
896     if (os::Aix::os_version() &gt;= 0x07020000) { // At least AIX 7.2.
897       _features |= rtm_m;
898     }
899   }
900 #endif
901 #if defined(LINUX) &amp;&amp; defined(VM_LITTLE_ENDIAN)
902   unsigned long auxv = getauxval(AT_HWCAP2);
903 
904   if (auxv &amp; PPC_FEATURE2_HTM_NOSC) {
905     if (auxv &amp; PPC_FEATURE2_HAS_HTM) {
906       // TM on POWER8 and POWER9 in compat mode (VM) is supported by the JVM.
907       // TM on POWER9 DD2.1 NV (baremetal) is not supported by the JVM (TM on
908       // POWER9 DD2.1 NV has a few issues that need a couple of firmware
909       // and kernel workarounds, so there is a new mode only supported
910       // on non-virtualized P9 machines called HTM with no Suspend Mode).
911       // TM on POWER9 D2.2+ NV is not supported at all by Linux.
912       _features |= rtm_m;
913     }
914   }
915 #endif
916 }
917 
918 // Power 8: Configure Data Stream Control Register.
919 void VM_Version::config_dscr() {
920   // 7 InstWords for each call (function descriptor + blr instruction).
921   const int code_size = (2+2*7)*BytesPerInstWord;
922 
923   // Allocate space for the code.
924   ResourceMark rm;
925   CodeBuffer cb(&quot;config_dscr&quot;, code_size, 0);
926   MacroAssembler* a = new MacroAssembler(&amp;cb);
927 
928   // Emit code.
929   uint64_t (*get_dscr)() = (uint64_t(*)())(void *)a-&gt;function_entry();
930   uint32_t *code = (uint32_t *)a-&gt;pc();
931   a-&gt;mfdscr(R3);
932   a-&gt;blr();
933 
934   void (*set_dscr)(long) = (void(*)(long))(void *)a-&gt;function_entry();
935   a-&gt;mtdscr(R3);
936   a-&gt;blr();
937 
938   uint32_t *code_end = (uint32_t *)a-&gt;pc();
939   a-&gt;flush();
940 
941   // Print the detection code.
942   if (PrintAssembly) {
943     ttyLocker ttyl;
944     tty-&gt;print_cr(&quot;Decoding dscr configuration stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
945     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
946   }
947 
948   // Apply the configuration if needed.
949   _dscr_val = (*get_dscr)();
950   if (Verbose) {
951     tty-&gt;print_cr(&quot;dscr value was 0x%lx&quot; , _dscr_val);
952   }
953   bool change_requested = false;
954   if (DSCR_PPC64 != (uintx)-1) {
955     _dscr_val = DSCR_PPC64;
956     change_requested = true;
957   }
958   if (DSCR_DPFD_PPC64 &lt;= 7) {
959     uint64_t mask = 0x7;
960     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64) {
961       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_DPFD_PPC64);
962       change_requested = true;
963     }
964   }
965   if (DSCR_URG_PPC64 &lt;= 7) {
966     uint64_t mask = 0x7 &lt;&lt; 6;
967     if ((_dscr_val &amp; mask) != DSCR_DPFD_PPC64 &lt;&lt; 6) {
968       _dscr_val = (_dscr_val &amp; ~mask) | (DSCR_URG_PPC64 &lt;&lt; 6);
969       change_requested = true;
970     }
971   }
972   if (change_requested) {
973     (*set_dscr)(_dscr_val);
974     if (Verbose) {
975       tty-&gt;print_cr(&quot;dscr was set to 0x%lx&quot; , (*get_dscr)());
976     }
977   }
978 }
979 
980 static uint64_t saved_features = 0;
981 
982 void VM_Version::allow_all() {
983   saved_features = _features;
984   _features      = all_features_m;
985 }
986 
987 void VM_Version::revert() {
988   _features = saved_features;
989 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/arm/stubGenerator_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;assembler_arm.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;memory/universe.hpp&quot;
  32 #include &quot;nativeInst_arm.hpp&quot;
  33 #include &quot;oops/instanceOop.hpp&quot;
  34 #include &quot;oops/method.hpp&quot;
  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  42 #include &quot;runtime/stubRoutines.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 #ifdef COMPILER2
  45 #include &quot;opto/runtime.hpp&quot;
  46 #endif
  47 
  48 // Declaration and definition of StubGenerator (no .hpp file).
  49 // For a more detailed description of the stub routine structure
  50 // see the comment in stubRoutines.hpp
  51 
  52 #define __ _masm-&gt;
  53 
  54 #ifdef PRODUCT
  55 #define BLOCK_COMMENT(str) /* nothing */
  56 #else
  57 #define BLOCK_COMMENT(str) __ block_comment(str)
  58 #endif
  59 
  60 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  61 
  62 // -------------------------------------------------------------------------------------------------------------------------
  63 // Stub Code definitions
  64 
  65 // Platform dependent parameters for array copy stubs
  66 
  67 // Note: we have noticed a huge change in behavior on a microbenchmark
  68 // from platform to platform depending on the configuration.
  69 
  70 // Instead of adding a series of command line options (which
  71 // unfortunately have to be done in the shared file and cannot appear
  72 // only in the ARM port), the tested result are hard-coded here in a set
  73 // of options, selected by specifying &#39;ArmCopyPlatform&#39;
  74 
  75 // Currently, this &#39;platform&#39; is hardcoded to a value that is a good
  76 // enough trade-off.  However, one can easily modify this file to test
  77 // the hard-coded configurations or create new ones. If the gain is
  78 // significant, we could decide to either add command line options or
  79 // add code to automatically choose a configuration.
  80 
  81 // see comments below for the various configurations created
  82 #define DEFAULT_ARRAYCOPY_CONFIG 0
  83 #define TEGRA2_ARRAYCOPY_CONFIG 1
  84 #define IMX515_ARRAYCOPY_CONFIG 2
  85 
  86 // Hard coded choices (XXX: could be changed to a command line option)
  87 #define ArmCopyPlatform DEFAULT_ARRAYCOPY_CONFIG
  88 
  89 #define ArmCopyCacheLineSize 32 // not worth optimizing to 64 according to measured gains
  90 
  91 // configuration for each kind of loop
  92 typedef struct {
  93   int pld_distance;       // prefetch distance (0 =&gt; no prefetch, &lt;0: prefetch_before);
  94   bool split_ldm;         // if true, split each STM in STMs with fewer registers
  95   bool split_stm;         // if true, split each LTM in LTMs with fewer registers
  96 } arraycopy_loop_config;
  97 
  98 // configuration for all loops
  99 typedef struct {
 100   // const char *description;
 101   arraycopy_loop_config forward_aligned;
 102   arraycopy_loop_config backward_aligned;
 103   arraycopy_loop_config forward_shifted;
 104   arraycopy_loop_config backward_shifted;
 105 } arraycopy_platform_config;
 106 
 107 // configured platforms
 108 static arraycopy_platform_config arraycopy_configurations[] = {
 109   // configuration parameters for arraycopy loops
 110 
 111   // Configurations were chosen based on manual analysis of benchmark
 112   // results, minimizing overhead with respect to best results on the
 113   // different test cases.
 114 
 115   // Prefetch before is always favored since it avoids dirtying the
 116   // cache uselessly for small copies. Code for prefetch after has
 117   // been kept in case the difference is significant for some
 118   // platforms but we might consider dropping it.
 119 
 120   // distance, ldm, stm
 121   {
 122     // default: tradeoff tegra2/imx515/nv-tegra2,
 123     // Notes on benchmarking:
 124     // - not far from optimal configuration on nv-tegra2
 125     // - within 5% of optimal configuration except for backward aligned on IMX
 126     // - up to 40% from optimal configuration for backward shifted and backward align for tegra2
 127     //   but still on par with the operating system copy
 128     {-256, true,  true  }, // forward aligned
 129     {-256, true,  true  }, // backward aligned
 130     {-256, false, false }, // forward shifted
 131     {-256, true,  true  } // backward shifted
 132   },
 133   {
 134     // configuration tuned on tegra2-4.
 135     // Warning: should not be used on nv-tegra2 !
 136     // Notes:
 137     // - prefetch after gives 40% gain on backward copies on tegra2-4,
 138     //   resulting in better number than the operating system
 139     //   copy. However, this can lead to a 300% loss on nv-tegra and has
 140     //   more impact on the cache (fetches futher than what is
 141     //   copied). Use this configuration with care, in case it improves
 142     //   reference benchmarks.
 143     {-256, true,  true  }, // forward aligned
 144     {96,   false, false }, // backward aligned
 145     {-256, false, false }, // forward shifted
 146     {96,   false, false } // backward shifted
 147   },
 148   {
 149     // configuration tuned on imx515
 150     // Notes:
 151     // - smaller prefetch distance is sufficient to get good result and might be more stable
 152     // - refined backward aligned options within 5% of optimal configuration except for
 153     //   tests were the arrays fit in the cache
 154     {-160, false, false }, // forward aligned
 155     {-160, false, false }, // backward aligned
 156     {-160, false, false }, // forward shifted
 157     {-160, true,  true  } // backward shifted
 158   }
 159 };
 160 
 161 class StubGenerator: public StubCodeGenerator {
 162 
 163 #ifdef PRODUCT
 164 #define inc_counter_np(a,b,c) ((void)0)
 165 #else
 166 #define inc_counter_np(counter, t1, t2) \
 167   BLOCK_COMMENT(&quot;inc_counter &quot; #counter); \
 168   __ inc_counter(&amp;counter, t1, t2);
 169 #endif
 170 
 171  private:
 172 
 173   address generate_call_stub(address&amp; return_address) {
 174     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;call_stub&quot;);
 175     address start = __ pc();
 176 
 177 
 178     assert(frame::entry_frame_call_wrapper_offset == 0, &quot;adjust this code&quot;);
 179 
 180     __ mov(Rtemp, SP);
 181     __ push(RegisterSet(FP) | RegisterSet(LR));
 182 #ifndef __SOFTFP__
 183     __ fstmdbd(SP, FloatRegisterSet(D8, 8), writeback);
 184 #endif
 185     __ stmdb(SP, RegisterSet(R0, R2) | RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11, writeback);
 186     __ mov(Rmethod, R3);
 187     __ ldmia(Rtemp, RegisterSet(R1, R3) | Rthread); // stacked arguments
 188 
 189     // XXX: TODO
 190     // Would be better with respect to native tools if the following
 191     // setting of FP was changed to conform to the native ABI, with FP
 192     // pointing to the saved FP slot (and the corresponding modifications
 193     // for entry_frame_call_wrapper_offset and frame::real_fp).
 194     __ mov(FP, SP);
 195 
 196     {
 197       Label no_parameters, pass_parameters;
 198       __ cmp(R3, 0);
 199       __ b(no_parameters, eq);
 200 
 201       __ bind(pass_parameters);
 202       __ ldr(Rtemp, Address(R2, wordSize, post_indexed)); // Rtemp OK, unused and scratchable
 203       __ subs(R3, R3, 1);
 204       __ push(Rtemp);
 205       __ b(pass_parameters, ne);
 206       __ bind(no_parameters);
 207     }
 208 
 209     __ mov(Rsender_sp, SP);
 210     __ blx(R1);
 211     return_address = __ pc();
 212 
 213     __ add(SP, FP, wordSize); // Skip link to JavaCallWrapper
 214     __ pop(RegisterSet(R2, R3));
 215 #ifndef __ABI_HARD__
 216     __ cmp(R3, T_LONG);
 217     __ cmp(R3, T_DOUBLE, ne);
 218     __ str(R0, Address(R2));
 219     __ str(R1, Address(R2, wordSize), eq);
 220 #else
 221     Label cont, l_float, l_double;
 222 
 223     __ cmp(R3, T_DOUBLE);
 224     __ b(l_double, eq);
 225 
 226     __ cmp(R3, T_FLOAT);
 227     __ b(l_float, eq);
 228 
 229     __ cmp(R3, T_LONG);
 230     __ str(R0, Address(R2));
 231     __ str(R1, Address(R2, wordSize), eq);
 232     __ b(cont);
 233 
 234 
 235     __ bind(l_double);
 236     __ fstd(D0, Address(R2));
 237     __ b(cont);
 238 
 239     __ bind(l_float);
 240     __ fsts(S0, Address(R2));
 241 
 242     __ bind(cont);
 243 #endif
 244 
 245     __ pop(RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11);
 246 #ifndef __SOFTFP__
 247     __ fldmiad(SP, FloatRegisterSet(D8, 8), writeback);
 248 #endif
 249     __ pop(RegisterSet(FP) | RegisterSet(PC));
 250 
 251     return start;
 252   }
 253 
 254 
 255   // (in) Rexception_obj: exception oop
 256   address generate_catch_exception() {
 257     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;catch_exception&quot;);
 258     address start = __ pc();
 259 
 260     __ str(Rexception_obj, Address(Rthread, Thread::pending_exception_offset()));
 261     __ b(StubRoutines::_call_stub_return_address);
 262 
 263     return start;
 264   }
 265 
 266 
 267   // (in) Rexception_pc: return address
 268   address generate_forward_exception() {
 269     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;forward exception&quot;);
 270     address start = __ pc();
 271 
 272     __ mov(c_rarg0, Rthread);
 273     __ mov(c_rarg1, Rexception_pc);
 274     __ call_VM_leaf(CAST_FROM_FN_PTR(address,
 275                          SharedRuntime::exception_handler_for_return_address),
 276                          c_rarg0, c_rarg1);
 277     __ ldr(Rexception_obj, Address(Rthread, Thread::pending_exception_offset()));
 278     const Register Rzero = __ zero_register(Rtemp); // Rtemp OK (cleared by above call)
 279     __ str(Rzero, Address(Rthread, Thread::pending_exception_offset()));
 280 
 281 #ifdef ASSERT
 282     // make sure exception is set
 283     { Label L;
 284       __ cbnz(Rexception_obj, L);
 285       __ stop(&quot;StubRoutines::forward exception: no pending exception (2)&quot;);
 286       __ bind(L);
 287     }
 288 #endif
 289 
 290     // Verify that there is really a valid exception in RAX.
 291     __ verify_oop(Rexception_obj);
 292 
 293     __ jump(R0); // handler is returned in R0 by runtime function
 294     return start;
 295   }
 296 
 297 
 298 
 299   // Integer division shared routine
 300   //   Input:
 301   //     R0  - dividend
 302   //     R2  - divisor
 303   //   Output:
 304   //     R0  - remainder
 305   //     R1  - quotient
 306   //   Destroys:
 307   //     R2
 308   //     LR
 309   address generate_idiv_irem() {
 310     Label positive_arguments, negative_or_zero, call_slow_path;
 311     Register dividend  = R0;
 312     Register divisor   = R2;
 313     Register remainder = R0;
 314     Register quotient  = R1;
 315     Register tmp       = LR;
 316     assert(dividend == remainder, &quot;must be&quot;);
 317 
 318     address start = __ pc();
 319 
 320     // Check for special cases: divisor &lt;= 0 or dividend &lt; 0
 321     __ cmp(divisor, 0);
 322     __ orrs(quotient, dividend, divisor, ne);
 323     __ b(negative_or_zero, le);
 324 
 325     __ bind(positive_arguments);
 326     // Save return address on stack to free one extra register
 327     __ push(LR);
 328     // Approximate the mamximum order of the quotient
 329     __ clz(tmp, dividend);
 330     __ clz(quotient, divisor);
 331     __ subs(tmp, quotient, tmp);
 332     __ mov(quotient, 0);
 333     // Jump to the appropriate place in the unrolled loop below
 334     __ ldr(PC, Address(PC, tmp, lsl, 2), pl);
 335     // If divisor is greater than dividend, return immediately
 336     __ pop(PC);
 337 
 338     // Offset table
 339     Label offset_table[32];
 340     int i;
 341     for (i = 0; i &lt;= 31; i++) {
 342       __ emit_address(offset_table[i]);
 343     }
 344 
 345     // Unrolled loop of 32 division steps
 346     for (i = 31; i &gt;= 0; i--) {
 347       __ bind(offset_table[i]);
 348       __ cmp(remainder, AsmOperand(divisor, lsl, i));
 349       __ sub(remainder, remainder, AsmOperand(divisor, lsl, i), hs);
 350       __ add(quotient, quotient, 1 &lt;&lt; i, hs);
 351     }
 352     __ pop(PC);
 353 
 354     __ bind(negative_or_zero);
 355     // Find the combination of argument signs and jump to corresponding handler
 356     __ andr(quotient, dividend, 0x80000000, ne);
 357     __ orr(quotient, quotient, AsmOperand(divisor, lsr, 31), ne);
 358     __ add(PC, PC, AsmOperand(quotient, ror, 26), ne);
 359     __ str(LR, Address(Rthread, JavaThread::saved_exception_pc_offset()));
 360 
 361     // The leaf runtime function can destroy R0-R3 and R12 registers which are still alive
 362     RegisterSet saved_registers = RegisterSet(R3) | RegisterSet(R12);
 363 #if R9_IS_SCRATCHED
 364     // Safer to save R9 here since callers may have been written
 365     // assuming R9 survives. This is suboptimal but may not be worth
 366     // revisiting for this slow case.
 367 
 368     // save also R10 for alignment
 369     saved_registers = saved_registers | RegisterSet(R9, R10);
 370 #endif
 371     {
 372       // divisor == 0
 373       FixedSizeCodeBlock zero_divisor(_masm, 8, true);
 374       __ push(saved_registers);
 375       __ mov(R0, Rthread);
 376       __ mov(R1, LR);
 377       __ mov(R2, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
 378       __ b(call_slow_path);
 379     }
 380 
 381     {
 382       // divisor &gt; 0 &amp;&amp; dividend &lt; 0
 383       FixedSizeCodeBlock positive_divisor_negative_dividend(_masm, 8, true);
 384       __ push(LR);
 385       __ rsb(dividend, dividend, 0);
 386       __ bl(positive_arguments);
 387       __ rsb(remainder, remainder, 0);
 388       __ rsb(quotient, quotient, 0);
 389       __ pop(PC);
 390     }
 391 
 392     {
 393       // divisor &lt; 0 &amp;&amp; dividend &gt; 0
 394       FixedSizeCodeBlock negative_divisor_positive_dividend(_masm, 8, true);
 395       __ push(LR);
 396       __ rsb(divisor, divisor, 0);
 397       __ bl(positive_arguments);
 398       __ rsb(quotient, quotient, 0);
 399       __ pop(PC);
 400     }
 401 
 402     {
 403       // divisor &lt; 0 &amp;&amp; dividend &lt; 0
 404       FixedSizeCodeBlock negative_divisor_negative_dividend(_masm, 8, true);
 405       __ push(LR);
 406       __ rsb(dividend, dividend, 0);
 407       __ rsb(divisor, divisor, 0);
 408       __ bl(positive_arguments);
 409       __ rsb(remainder, remainder, 0);
 410       __ pop(PC);
 411     }
 412 
 413     __ bind(call_slow_path);
 414     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::continuation_for_implicit_exception));
 415     __ pop(saved_registers);
 416     __ bx(R0);
 417 
 418     return start;
 419   }
 420 
 421 
 422  // As per atomic.hpp the Atomic read-modify-write operations must be logically implemented as:
 423  //  &lt;fence&gt;; &lt;op&gt;; &lt;membar StoreLoad|StoreStore&gt;
 424  // But for load-linked/store-conditional based systems a fence here simply means
 425  // no load/store can be reordered with respect to the initial load-linked, so we have:
 426  // &lt;membar storeload|loadload&gt; ; load-linked; &lt;op&gt;; store-conditional; &lt;membar storeload|storestore&gt;
 427  // There are no memory actions in &lt;op&gt; so nothing further is needed.
 428  //
 429  // So we define the following for convenience:
 430 #define MEMBAR_ATOMIC_OP_PRE \
 431     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::LoadLoad)
 432 #define MEMBAR_ATOMIC_OP_POST \
 433     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::StoreStore)
 434 
 435   // Note: JDK 9 only supports ARMv7+ so we always have ldrexd available even though the
 436   // code below allows for it to be otherwise. The else clause indicates an ARMv5 system
 437   // for which we do not support MP and so membars are not necessary. This ARMv5 code will
 438   // be removed in the future.
 439 
 440   // Implementation of atomic_add(jint add_value, volatile jint* dest)
 441   // used by Atomic::add(volatile jint* dest, jint add_value)
 442   //
 443   // Arguments :
 444   //
 445   //      add_value:      R0
 446   //      dest:           R1
 447   //
 448   // Results:
 449   //
 450   //     R0: the new stored in dest
 451   //
 452   // Overwrites:
 453   //
 454   //     R1, R2, R3
 455   //
 456   address generate_atomic_add() {
 457     address start;
 458 
 459     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_add&quot;);
 460     Label retry;
 461     start = __ pc();
 462     Register addval    = R0;
 463     Register dest      = R1;
 464     Register prev      = R2;
 465     Register ok        = R2;
 466     Register newval    = R3;
 467 
 468     if (VM_Version::supports_ldrex()) {
 469       __ membar(MEMBAR_ATOMIC_OP_PRE, prev);
 470       __ bind(retry);
 471       __ ldrex(newval, Address(dest));
 472       __ add(newval, addval, newval);
 473       __ strex(ok, newval, Address(dest));
 474       __ cmp(ok, 0);
 475       __ b(retry, ne);
 476       __ mov (R0, newval);
 477       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 478     } else {
 479       __ bind(retry);
 480       __ ldr (prev, Address(dest));
 481       __ add(newval, addval, prev);
 482       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 483       __ b(retry, ne);
 484       __ mov (R0, newval);
 485     }
 486     __ bx(LR);
 487 
 488     return start;
 489   }
 490 
 491   // Implementation of jint atomic_xchg(jint exchange_value, volatile jint* dest)
 492   // used by Atomic::add(volatile jint* dest, jint exchange_value)
 493   //
 494   // Arguments :
 495   //
 496   //      exchange_value: R0
 497   //      dest:           R1
 498   //
 499   // Results:
 500   //
 501   //     R0: the value previously stored in dest
 502   //
 503   // Overwrites:
 504   //
 505   //     R1, R2, R3
 506   //
 507   address generate_atomic_xchg() {
 508     address start;
 509 
 510     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_xchg&quot;);
 511     start = __ pc();
 512     Register newval    = R0;
 513     Register dest      = R1;
 514     Register prev      = R2;
 515 
 516     Label retry;
 517 
 518     if (VM_Version::supports_ldrex()) {
 519       Register ok=R3;
 520       __ membar(MEMBAR_ATOMIC_OP_PRE, prev);
 521       __ bind(retry);
 522       __ ldrex(prev, Address(dest));
 523       __ strex(ok, newval, Address(dest));
 524       __ cmp(ok, 0);
 525       __ b(retry, ne);
 526       __ mov (R0, prev);
 527       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 528     } else {
 529       __ bind(retry);
 530       __ ldr (prev, Address(dest));
 531       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 532       __ b(retry, ne);
 533       __ mov (R0, prev);
 534     }
 535     __ bx(LR);
 536 
 537     return start;
 538   }
 539 
 540   // Implementation of jint atomic_cmpxchg(jint exchange_value, volatile jint *dest, jint compare_value)
 541   // used by Atomic::cmpxchg(volatile jint *dest, jint compare_value, jint exchange_value)
 542   //
 543   // Arguments :
 544   //
 545   //      compare_value:  R0
 546   //      exchange_value: R1
 547   //      dest:           R2
 548   //
 549   // Results:
 550   //
 551   //     R0: the value previously stored in dest
 552   //
 553   // Overwrites:
 554   //
 555   //     R0, R1, R2, R3, Rtemp
 556   //
 557   address generate_atomic_cmpxchg() {
 558     address start;
 559 
 560     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_cmpxchg&quot;);
 561     start = __ pc();
 562     Register cmp       = R0;
 563     Register newval    = R1;
 564     Register dest      = R2;
 565     Register temp1     = R3;
 566     Register temp2     = Rtemp; // Rtemp free (native ABI)
 567 
 568     __ membar(MEMBAR_ATOMIC_OP_PRE, temp1);
 569 
 570     // atomic_cas returns previous value in R0
 571     __ atomic_cas(temp1, temp2, cmp, newval, dest, 0);
 572 
 573     __ membar(MEMBAR_ATOMIC_OP_POST, temp1);
 574 
 575     __ bx(LR);
 576 
 577     return start;
 578   }
 579 
 580   // Support for jlong Atomic::cmpxchg(jlong exchange_value, volatile jlong *dest, jlong compare_value)
 581   // reordered before by a wrapper to (jlong compare_value, jlong exchange_value, volatile jlong *dest)
 582   //
 583   // Arguments :
 584   //
 585   //      compare_value:  R1 (High), R0 (Low)
 586   //      exchange_value: R3 (High), R2 (Low)
 587   //      dest:           SP+0
 588   //
 589   // Results:
 590   //
 591   //     R0:R1: the value previously stored in dest
 592   //
 593   // Overwrites:
 594   //
 595   address generate_atomic_cmpxchg_long() {
 596     address start;
 597 
 598     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_cmpxchg_long&quot;);
 599     start = __ pc();
 600     Register cmp_lo      = R0;
 601     Register cmp_hi      = R1;
 602     Register newval_lo   = R2;
 603     Register newval_hi   = R3;
 604     Register addr        = Rtemp;  /* After load from stack */
 605     Register temp_lo     = R4;
 606     Register temp_hi     = R5;
 607     Register temp_result = R8;
 608     assert_different_registers(cmp_lo, newval_lo, temp_lo, addr, temp_result, R7);
 609     assert_different_registers(cmp_hi, newval_hi, temp_hi, addr, temp_result, R7);
 610 
 611     __ membar(MEMBAR_ATOMIC_OP_PRE, Rtemp); // Rtemp free (native ABI)
 612 
 613     // Stack is unaligned, maintain double word alignment by pushing
 614     // odd number of regs.
 615     __ push(RegisterSet(temp_result) | RegisterSet(temp_lo, temp_hi));
 616     __ ldr(addr, Address(SP, 12));
 617 
 618     // atomic_cas64 returns previous value in temp_lo, temp_hi
 619     __ atomic_cas64(temp_lo, temp_hi, temp_result, cmp_lo, cmp_hi,
 620                     newval_lo, newval_hi, addr, 0);
 621     __ mov(R0, temp_lo);
 622     __ mov(R1, temp_hi);
 623 
 624     __ pop(RegisterSet(temp_result) | RegisterSet(temp_lo, temp_hi));
 625 
 626     __ membar(MEMBAR_ATOMIC_OP_POST, Rtemp); // Rtemp free (native ABI)
 627     __ bx(LR);
 628 
 629     return start;
 630   }
 631 
 632   address generate_atomic_load_long() {
 633     address start;
 634 
 635     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_load_long&quot;);
 636     start = __ pc();
 637     Register result_lo = R0;
 638     Register result_hi = R1;
 639     Register src       = R0;
 640 
 641     if (!os::is_MP()) {
 642       __ ldmia(src, RegisterSet(result_lo, result_hi));
 643       __ bx(LR);
 644     } else if (VM_Version::supports_ldrexd()) {
 645       __ ldrexd(result_lo, Address(src));
 646       __ clrex(); // FIXME: safe to remove?
 647       __ bx(LR);
 648     } else {
 649       __ stop(&quot;Atomic load(jlong) unsupported on this platform&quot;);
 650       __ bx(LR);
 651     }
 652 
 653     return start;
 654   }
 655 
 656   address generate_atomic_store_long() {
 657     address start;
 658 
 659     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_store_long&quot;);
 660     start = __ pc();
 661     Register newval_lo = R0;
 662     Register newval_hi = R1;
 663     Register dest      = R2;
 664     Register scratch_lo    = R2;
 665     Register scratch_hi    = R3;  /* After load from stack */
 666     Register result    = R3;
 667 
 668     if (!os::is_MP()) {
 669       __ stmia(dest, RegisterSet(newval_lo, newval_hi));
 670       __ bx(LR);
 671     } else if (VM_Version::supports_ldrexd()) {
 672       __ mov(Rtemp, dest);  // get dest to Rtemp
 673       Label retry;
 674       __ bind(retry);
 675       __ ldrexd(scratch_lo, Address(Rtemp));
 676       __ strexd(result, R0, Address(Rtemp));
 677       __ rsbs(result, result, 1);
 678       __ b(retry, eq);
 679       __ bx(LR);
 680     } else {
 681       __ stop(&quot;Atomic store(jlong) unsupported on this platform&quot;);
 682       __ bx(LR);
 683     }
 684 
 685     return start;
 686   }
 687 
 688 
 689 
 690 #ifdef COMPILER2
 691   // Support for uint StubRoutine::Arm::partial_subtype_check( Klass sub, Klass super );
 692   // Arguments :
 693   //
 694   //      ret  : R0, returned
 695   //      icc/xcc: set as R0 (depending on wordSize)
 696   //      sub  : R1, argument, not changed
 697   //      super: R2, argument, not changed
 698   //      raddr: LR, blown by call
 699   address generate_partial_subtype_check() {
 700     __ align(CodeEntryAlignment);
 701     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;partial_subtype_check&quot;);
 702     address start = __ pc();
 703 
 704     // based on SPARC check_klass_subtype_[fast|slow]_path (without CompressedOops)
 705 
 706     // R0 used as tmp_reg (in addition to return reg)
 707     Register sub_klass = R1;
 708     Register super_klass = R2;
 709     Register tmp_reg2 = R3;
 710     Register tmp_reg3 = R4;
 711 #define saved_set tmp_reg2, tmp_reg3
 712 
 713     Label L_loop, L_fail;
 714 
 715     int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
 716 
 717     // fast check should be redundant
 718 
 719     // slow check
 720     {
 721       __ raw_push(saved_set);
 722 
 723       // a couple of useful fields in sub_klass:
 724       int ss_offset = in_bytes(Klass::secondary_supers_offset());
 725 
 726       // Do a linear scan of the secondary super-klass chain.
 727       // This code is rarely used, so simplicity is a virtue here.
 728 
 729       inc_counter_np(SharedRuntime::_partial_subtype_ctr, tmp_reg2, tmp_reg3);
 730 
 731       Register scan_temp = tmp_reg2;
 732       Register count_temp = tmp_reg3;
 733 
 734       // We will consult the secondary-super array.
 735       __ ldr(scan_temp, Address(sub_klass, ss_offset));
 736 
 737       Register search_key = super_klass;
 738 
 739       // Load the array length.
 740       __ ldr_s32(count_temp, Address(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes()));
 741       __ add(scan_temp, scan_temp, Array&lt;Klass*&gt;::base_offset_in_bytes());
 742 
 743       __ add(count_temp, count_temp, 1);
 744 
 745       // Top of search loop
 746       __ bind(L_loop);
 747       // Notes:
 748       //  scan_temp starts at the array elements
 749       //  count_temp is 1+size
 750       __ subs(count_temp, count_temp, 1);
 751       __ b(L_fail, eq); // not found in the array
 752 
 753       // Load next super to check
 754       // In the array of super classes elements are pointer sized.
 755       int element_size = wordSize;
 756       __ ldr(R0, Address(scan_temp, element_size, post_indexed));
 757 
 758       // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
 759       __ subs(R0, R0, search_key); // set R0 to 0 on success (and flags to eq)
 760 
 761       // A miss means we are NOT a subtype and need to keep looping
 762       __ b(L_loop, ne);
 763 
 764       // Falling out the bottom means we found a hit; we ARE a subtype
 765 
 766       // Success.  Cache the super we found and proceed in triumph.
 767       __ str(super_klass, Address(sub_klass, sc_offset));
 768 
 769       // Return success
 770       // R0 is already 0 and flags are already set to eq
 771       __ raw_pop(saved_set);
 772       __ ret();
 773 
 774       // Return failure
 775       __ bind(L_fail);
 776       __ movs(R0, 1); // sets the flags
 777       __ raw_pop(saved_set);
 778       __ ret();
 779     }
 780     return start;
 781   }
 782 #undef saved_set
 783 #endif // COMPILER2
 784 
 785 
 786   //----------------------------------------------------------------------------------------------------
 787   // Non-destructive plausibility checks for oops
 788 
 789   address generate_verify_oop() {
 790     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;verify_oop&quot;);
 791     address start = __ pc();
 792 
 793     // Incoming arguments:
 794     //
 795     // R0: error message (char* )
 796     // R1: address of register save area
 797     // R2: oop to verify
 798     //
 799     // All registers are saved before calling this stub. However, condition flags should be saved here.
 800 
 801     const Register oop   = R2;
 802     const Register klass = R3;
 803     const Register tmp1  = R6;
 804     const Register tmp2  = R8;
 805 
 806     const Register flags     = Rtmp_save0; // R4/R19
 807     const Register ret_addr  = Rtmp_save1; // R5/R20
 808     assert_different_registers(oop, klass, tmp1, tmp2, flags, ret_addr, R7);
 809 
 810     Label exit, error;
 811     InlinedAddress verify_oop_count((address) StubRoutines::verify_oop_count_addr());
 812 
 813     __ mrs(Assembler::CPSR, flags);
 814 
 815     __ ldr_literal(tmp1, verify_oop_count);
 816     __ ldr_s32(tmp2, Address(tmp1));
 817     __ add(tmp2, tmp2, 1);
 818     __ str_32(tmp2, Address(tmp1));
 819 
 820     // make sure object is &#39;reasonable&#39;
 821     __ cbz(oop, exit);                           // if obj is NULL it is ok
 822 
 823     // Check if the oop is in the right area of memory
 824     // Note: oop_mask and oop_bits must be updated if the code is saved/reused
 825     const address oop_mask = (address) Universe::verify_oop_mask();
 826     const address oop_bits = (address) Universe::verify_oop_bits();
 827     __ mov_address(tmp1, oop_mask);
 828     __ andr(tmp2, oop, tmp1);
 829     __ mov_address(tmp1, oop_bits);
 830     __ cmp(tmp2, tmp1);
 831     __ b(error, ne);
 832 
 833     // make sure klass is &#39;reasonable&#39;
 834     __ load_klass(klass, oop);                   // get klass
 835     __ cbz(klass, error);                        // if klass is NULL it is broken
 836 
 837     // return if everything seems ok
 838     __ bind(exit);
 839 
 840     __ msr(Assembler::CPSR_f, flags);
 841 
 842     __ ret();
 843 
 844     // handle errors
 845     __ bind(error);
 846 
 847     __ mov(ret_addr, LR);                      // save return address
 848 
 849     // R0: error message
 850     // R1: register save area
 851     __ call(CAST_FROM_FN_PTR(address, MacroAssembler::debug));
 852 
 853     __ mov(LR, ret_addr);
 854     __ b(exit);
 855 
 856     __ bind_literal(verify_oop_count);
 857 
 858     return start;
 859   }
 860 
 861   //----------------------------------------------------------------------------------------------------
 862   // Array copy stubs
 863 
 864   //
 865   //  Generate overlap test for array copy stubs
 866   //
 867   //  Input:
 868   //    R0    -  array1
 869   //    R1    -  array2
 870   //    R2    -  element count, 32-bit int
 871   //
 872   //  input registers are preserved
 873   //
 874   void array_overlap_test(address no_overlap_target, int log2_elem_size, Register tmp1, Register tmp2) {
 875     assert(no_overlap_target != NULL, &quot;must be generated&quot;);
 876     array_overlap_test(no_overlap_target, NULL, log2_elem_size, tmp1, tmp2);
 877   }
 878   void array_overlap_test(Label&amp; L_no_overlap, int log2_elem_size, Register tmp1, Register tmp2) {
 879     array_overlap_test(NULL, &amp;L_no_overlap, log2_elem_size, tmp1, tmp2);
 880   }
 881   void array_overlap_test(address no_overlap_target, Label* NOLp, int log2_elem_size, Register tmp1, Register tmp2) {
 882     const Register from       = R0;
 883     const Register to         = R1;
 884     const Register count      = R2;
 885     const Register to_from    = tmp1; // to - from
 886     const Register byte_count = (log2_elem_size == 0) ? count : tmp2; // count &lt;&lt; log2_elem_size
 887     assert_different_registers(from, to, count, tmp1, tmp2);
 888 
 889     // no_overlap version works if &#39;to&#39; lower (unsigned) than &#39;from&#39;
 890     // and or &#39;to&#39; more than (count*size) from &#39;from&#39;
 891 
 892     BLOCK_COMMENT(&quot;Array Overlap Test:&quot;);
 893     __ subs(to_from, to, from);
 894     if (log2_elem_size != 0) {
 895       __ mov(byte_count, AsmOperand(count, lsl, log2_elem_size));
 896     }
 897     if (NOLp == NULL)
 898       __ b(no_overlap_target,lo);
 899     else
 900       __ b((*NOLp), lo);
 901     __ cmp(to_from, byte_count);
 902     if (NOLp == NULL)
 903       __ b(no_overlap_target, ge);
 904     else
 905       __ b((*NOLp), ge);
 906   }
 907 
 908 
 909   //   probably we should choose between &quot;prefetch-store before or after store&quot;, not &quot;before or after load&quot;.
 910   void prefetch(Register from, Register to, int offset, int to_delta = 0) {
 911     __ prefetch_read(Address(from, offset));
 912   }
 913 
 914   // Generate the inner loop for forward aligned array copy
 915   //
 916   // Arguments
 917   //      from:      src address, 64 bits  aligned
 918   //      to:        dst address, wordSize aligned
 919   //      count:     number of elements (32-bit int)
 920   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
 921   //
 922   // Return the minimum initial value for count
 923   //
 924   // Notes:
 925   // - &#39;from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
 926   // - &#39;to&#39; aligned on wordSize
 927   // - &#39;count&#39; must be greater or equal than the returned value
 928   //
 929   // Increases &#39;from&#39; and &#39;to&#39; by count*bytes_per_count.
 930   //
 931   // Scratches &#39;count&#39;, R3.
 932   // R4-R10 are preserved (saved/restored).
 933   //
 934   int generate_forward_aligned_copy_loop(Register from, Register to, Register count, int bytes_per_count, bool unsafe_copy = false) {
 935     assert (from == R0 &amp;&amp; to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
 936 
 937     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
 938     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].forward_aligned;
 939     int pld_offset = config-&gt;pld_distance;
 940     const int count_per_loop = bytes_per_loop / bytes_per_count;
 941 
 942     bool split_read= config-&gt;split_ldm;
 943     bool split_write= config-&gt;split_stm;
 944 
 945     // XXX optim: use VLDM/VSTM when available (Neon) with PLD
 946     //  NEONCopyPLD
 947     //      PLD [r1, #0xC0]
 948     //      VLDM r1!,{d0-d7}
 949     //      VSTM r0!,{d0-d7}
 950     //      SUBS r2,r2,#0x40
 951     //      BGE NEONCopyPLD
 952 
 953     __ push(RegisterSet(R4,R10));
 954 
 955     const bool prefetch_before = pld_offset &lt; 0;
 956     const bool prefetch_after = pld_offset &gt; 0;
 957 
 958     Label L_skip_pld;
 959 
 960     {
 961       // UnsafeCopyMemory page error: continue after ucm
 962       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
 963       // predecrease to exit when there is less than count_per_loop
 964       __ sub_32(count, count, count_per_loop);
 965 
 966       if (pld_offset != 0) {
 967         pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
 968 
 969         prefetch(from, to, 0);
 970 
 971         if (prefetch_before) {
 972           // If prefetch is done ahead, final PLDs that overflow the
 973           // copied area can be easily avoided. &#39;count&#39; is predecreased
 974           // by the prefetch distance to optimize the inner loop and the
 975           // outer loop skips the PLD.
 976           __ subs_32(count, count, (bytes_per_loop+pld_offset)/bytes_per_count);
 977 
 978           // skip prefetch for small copies
 979           __ b(L_skip_pld, lt);
 980         }
 981 
 982         int offset = ArmCopyCacheLineSize;
 983         while (offset &lt;= pld_offset) {
 984           prefetch(from, to, offset);
 985           offset += ArmCopyCacheLineSize;
 986         };
 987       }
 988 
 989       {
 990         // 32-bit ARM note: we have tried implementing loop unrolling to skip one
 991         // PLD with 64 bytes cache line but the gain was not significant.
 992 
 993         Label L_copy_loop;
 994         __ align(OptoLoopAlignment);
 995         __ BIND(L_copy_loop);
 996 
 997         if (prefetch_before) {
 998           prefetch(from, to, bytes_per_loop + pld_offset);
 999           __ BIND(L_skip_pld);
1000         }
1001 
1002         if (split_read) {
1003           // Split the register set in two sets so that there is less
1004           // latency between LDM and STM (R3-R6 available while R7-R10
1005           // still loading) and less register locking issue when iterating
1006           // on the first LDM.
1007           __ ldmia(from, RegisterSet(R3, R6), writeback);
1008           __ ldmia(from, RegisterSet(R7, R10), writeback);
1009         } else {
1010           __ ldmia(from, RegisterSet(R3, R10), writeback);
1011         }
1012 
1013         __ subs_32(count, count, count_per_loop);
1014 
1015         if (prefetch_after) {
1016           prefetch(from, to, pld_offset, bytes_per_loop);
1017         }
1018 
1019         if (split_write) {
1020           __ stmia(to, RegisterSet(R3, R6), writeback);
1021           __ stmia(to, RegisterSet(R7, R10), writeback);
1022         } else {
1023           __ stmia(to, RegisterSet(R3, R10), writeback);
1024         }
1025 
1026         __ b(L_copy_loop, ge);
1027 
1028         if (prefetch_before) {
1029           // the inner loop may end earlier, allowing to skip PLD for the last iterations
1030           __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);
1031           __ b(L_skip_pld, ge);
1032         }
1033       }
1034       BLOCK_COMMENT(&quot;Remaining bytes:&quot;);
1035       // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes
1036 
1037       // __ add(count, count, ...); // addition useless for the bit tests
1038       assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);
1039 
1040       __ tst(count, 16 / bytes_per_count);
1041       __ ldmia(from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes
1042       __ stmia(to, RegisterSet(R3, R6), writeback, ne);
1043 
1044       __ tst(count, 8 / bytes_per_count);
1045       __ ldmia(from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes
1046       __ stmia(to, RegisterSet(R3, R4), writeback, ne);
1047 
1048       if (bytes_per_count &lt;= 4) {
1049         __ tst(count, 4 / bytes_per_count);
1050         __ ldr(R3, Address(from, 4, post_indexed), ne); // copy 4 bytes
1051         __ str(R3, Address(to, 4, post_indexed), ne);
1052       }
1053 
1054       if (bytes_per_count &lt;= 2) {
1055         __ tst(count, 2 / bytes_per_count);
1056         __ ldrh(R3, Address(from, 2, post_indexed), ne); // copy 2 bytes
1057         __ strh(R3, Address(to, 2, post_indexed), ne);
1058       }
1059 
1060       if (bytes_per_count == 1) {
1061         __ tst(count, 1);
1062         __ ldrb(R3, Address(from, 1, post_indexed), ne);
1063         __ strb(R3, Address(to, 1, post_indexed), ne);
1064       }
1065     }
1066 
1067     __ pop(RegisterSet(R4,R10));
1068 
1069     return count_per_loop;
1070   }
1071 
1072 
1073   // Generate the inner loop for backward aligned array copy
1074   //
1075   // Arguments
1076   //      end_from:      src end address, 64 bits  aligned
1077   //      end_to:        dst end address, wordSize aligned
1078   //      count:         number of elements (32-bit int)
1079   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1080   //
1081   // Return the minimum initial value for count
1082   //
1083   // Notes:
1084   // - &#39;end_from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1085   // - &#39;end_to&#39; aligned on wordSize
1086   // - &#39;count&#39; must be greater or equal than the returned value
1087   //
1088   // Decreases &#39;end_from&#39; and &#39;end_to&#39; by count*bytes_per_count.
1089   //
1090   // Scratches &#39;count&#39;, R3.
1091   // ARM R4-R10 are preserved (saved/restored).
1092   //
1093   int generate_backward_aligned_copy_loop(Register end_from, Register end_to, Register count, int bytes_per_count, bool unsafe_copy = false) {
1094     assert (end_from == R0 &amp;&amp; end_to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1095 
1096     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
1097     const int count_per_loop = bytes_per_loop / bytes_per_count;
1098 
1099     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].backward_aligned;
1100     int pld_offset = config-&gt;pld_distance;
1101 
1102     bool split_read= config-&gt;split_ldm;
1103     bool split_write= config-&gt;split_stm;
1104 
1105     // See the forward copy variant for additional comments.
1106 
1107     __ push(RegisterSet(R4,R10));
1108 
1109     {
1110       // UnsafeCopyMemory page error: continue after ucm
1111       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
1112       __ sub_32(count, count, count_per_loop);
1113 
1114       const bool prefetch_before = pld_offset &lt; 0;
1115       const bool prefetch_after = pld_offset &gt; 0;
1116 
1117       Label L_skip_pld;
1118 
1119       if (pld_offset != 0) {
1120         pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
1121 
1122         prefetch(end_from, end_to, -wordSize);
1123 
1124         if (prefetch_before) {
1125           __ subs_32(count, count, (bytes_per_loop + pld_offset) / bytes_per_count);
1126           __ b(L_skip_pld, lt);
1127         }
1128 
1129         int offset = ArmCopyCacheLineSize;
1130         while (offset &lt;= pld_offset) {
1131           prefetch(end_from, end_to, -(wordSize + offset));
1132           offset += ArmCopyCacheLineSize;
1133         };
1134       }
1135 
1136       {
1137         // 32-bit ARM note: we have tried implementing loop unrolling to skip one
1138         // PLD with 64 bytes cache line but the gain was not significant.
1139 
1140         Label L_copy_loop;
1141         __ align(OptoLoopAlignment);
1142         __ BIND(L_copy_loop);
1143 
1144         if (prefetch_before) {
1145           prefetch(end_from, end_to, -(wordSize + bytes_per_loop + pld_offset));
1146           __ BIND(L_skip_pld);
1147         }
1148 
1149         if (split_read) {
1150           __ ldmdb(end_from, RegisterSet(R7, R10), writeback);
1151           __ ldmdb(end_from, RegisterSet(R3, R6), writeback);
1152         } else {
1153           __ ldmdb(end_from, RegisterSet(R3, R10), writeback);
1154         }
1155 
1156         __ subs_32(count, count, count_per_loop);
1157 
1158         if (prefetch_after) {
1159           prefetch(end_from, end_to, -(wordSize + pld_offset), -bytes_per_loop);
1160         }
1161 
1162         if (split_write) {
1163           __ stmdb(end_to, RegisterSet(R7, R10), writeback);
1164           __ stmdb(end_to, RegisterSet(R3, R6), writeback);
1165         } else {
1166           __ stmdb(end_to, RegisterSet(R3, R10), writeback);
1167         }
1168 
1169         __ b(L_copy_loop, ge);
1170 
1171         if (prefetch_before) {
1172           __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);
1173           __ b(L_skip_pld, ge);
1174         }
1175       }
1176       BLOCK_COMMENT(&quot;Remaining bytes:&quot;);
1177       // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes
1178 
1179       // __ add(count, count, ...); // addition useless for the bit tests
1180       assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);
1181 
1182       __ tst(count, 16 / bytes_per_count);
1183       __ ldmdb(end_from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes
1184       __ stmdb(end_to, RegisterSet(R3, R6), writeback, ne);
1185 
1186       __ tst(count, 8 / bytes_per_count);
1187       __ ldmdb(end_from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes
1188       __ stmdb(end_to, RegisterSet(R3, R4), writeback, ne);
1189 
1190       if (bytes_per_count &lt;= 4) {
1191         __ tst(count, 4 / bytes_per_count);
1192         __ ldr(R3, Address(end_from, -4, pre_indexed), ne); // copy 4 bytes
1193         __ str(R3, Address(end_to, -4, pre_indexed), ne);
1194       }
1195 
1196       if (bytes_per_count &lt;= 2) {
1197         __ tst(count, 2 / bytes_per_count);
1198         __ ldrh(R3, Address(end_from, -2, pre_indexed), ne); // copy 2 bytes
1199         __ strh(R3, Address(end_to, -2, pre_indexed), ne);
1200       }
1201 
1202       if (bytes_per_count == 1) {
1203         __ tst(count, 1);
1204         __ ldrb(R3, Address(end_from, -1, pre_indexed), ne);
1205         __ strb(R3, Address(end_to, -1, pre_indexed), ne);
1206       }
1207     }
1208     __ pop(RegisterSet(R4,R10));
1209 
1210     return count_per_loop;
1211   }
1212 
1213 
1214   // Generate the inner loop for shifted forward array copy (unaligned copy).
1215   // It can be used when bytes_per_count &lt; wordSize, i.e. byte/short copy
1216   //
1217   // Arguments
1218   //      from:      start src address, 64 bits aligned
1219   //      to:        start dst address, (now) wordSize aligned
1220   //      count:     number of elements (32-bit int)
1221   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1222   //      lsr_shift: shift applied to &#39;old&#39; value to skipped already written bytes
1223   //      lsl_shift: shift applied to &#39;new&#39; value to set the high bytes of the next write
1224   //
1225   // Return the minimum initial value for count
1226   //
1227   // Notes:
1228   // - &#39;from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1229   // - &#39;to&#39; aligned on wordSize
1230   // - &#39;count&#39; must be greater or equal than the returned value
1231   // - &#39;lsr_shift&#39; + &#39;lsl_shift&#39; = BitsPerWord
1232   // - &#39;bytes_per_count&#39; is 1 or 2
1233   //
1234   // Increases &#39;to&#39; by count*bytes_per_count.
1235   //
1236   // Scratches &#39;from&#39; and &#39;count&#39;, R3-R10, R12
1237   //
1238   // On entry:
1239   // - R12 is preloaded with the first &#39;BitsPerWord&#39; bits read just before &#39;from&#39;
1240   // - (R12 &gt;&gt; lsr_shift) is the part not yet written (just before &#39;to&#39;)
1241   // --&gt; (*to) = (R12 &gt;&gt; lsr_shift) | (*from) &lt;&lt; lsl_shift); ...
1242   //
1243   // This implementation may read more bytes than required.
1244   // Actually, it always reads exactly all data from the copied region with upper bound aligned up by wordSize,
1245   // so excessive read do not cross a word bound and is thus harmless.
1246   //
1247   int generate_forward_shifted_copy_loop(Register from, Register to, Register count, int bytes_per_count, int lsr_shift, int lsl_shift) {
1248     assert (from == R0 &amp;&amp; to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1249 
1250     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iter
1251     const int count_per_loop = bytes_per_loop / bytes_per_count;
1252 
1253     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].forward_shifted;
1254     int pld_offset = config-&gt;pld_distance;
1255 
1256     bool split_read= config-&gt;split_ldm;
1257     bool split_write= config-&gt;split_stm;
1258 
1259     const bool prefetch_before = pld_offset &lt; 0;
1260     const bool prefetch_after = pld_offset &gt; 0;
1261     Label L_skip_pld, L_last_read, L_done;
1262     if (pld_offset != 0) {
1263 
1264       pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
1265 
1266       prefetch(from, to, 0);
1267 
1268       if (prefetch_before) {
1269         __ cmp_32(count, count_per_loop);
1270         __ b(L_last_read, lt);
1271         // skip prefetch for small copies
1272         // warning: count is predecreased by the prefetch distance to optimize the inner loop
1273         __ subs_32(count, count, ((bytes_per_loop + pld_offset) / bytes_per_count) + count_per_loop);
1274         __ b(L_skip_pld, lt);
1275       }
1276 
1277       int offset = ArmCopyCacheLineSize;
1278       while (offset &lt;= pld_offset) {
1279         prefetch(from, to, offset);
1280         offset += ArmCopyCacheLineSize;
1281       };
1282     }
1283 
1284     Label L_shifted_loop;
1285 
1286     __ align(OptoLoopAlignment);
1287     __ BIND(L_shifted_loop);
1288 
1289     if (prefetch_before) {
1290       // do it early if there might be register locking issues
1291       prefetch(from, to, bytes_per_loop + pld_offset);
1292       __ BIND(L_skip_pld);
1293     } else {
1294       __ cmp_32(count, count_per_loop);
1295       __ b(L_last_read, lt);
1296     }
1297 
1298     // read 32 bytes
1299     if (split_read) {
1300       // if write is not split, use less registers in first set to reduce locking
1301       RegisterSet set1 = split_write ? RegisterSet(R4, R7) : RegisterSet(R4, R5);
1302       RegisterSet set2 = (split_write ? RegisterSet(R8, R10) : RegisterSet(R6, R10)) | R12;
1303       __ ldmia(from, set1, writeback);
1304       __ mov(R3, AsmOperand(R12, lsr, lsr_shift)); // part of R12 not yet written
1305       __ ldmia(from, set2, writeback);
1306       __ subs(count, count, count_per_loop); // XXX: should it be before the 2nd LDM ? (latency vs locking)
1307     } else {
1308       __ mov(R3, AsmOperand(R12, lsr, lsr_shift)); // part of R12 not yet written
1309       __ ldmia(from, RegisterSet(R4, R10) | R12, writeback); // Note: small latency on R4
1310       __ subs(count, count, count_per_loop);
1311     }
1312 
1313     if (prefetch_after) {
1314       // do it after the 1st ldm/ldp anyway  (no locking issues with early STM/STP)
1315       prefetch(from, to, pld_offset, bytes_per_loop);
1316     }
1317 
1318     // prepare (shift) the values in R3..R10
1319     __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift)); // merged below low bytes of next val
1320     __ logical_shift_right(R4, R4, lsr_shift); // unused part of next val
1321     __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift)); // ...
1322     __ logical_shift_right(R5, R5, lsr_shift);
1323     __ orr(R5, R5, AsmOperand(R6, lsl, lsl_shift));
1324     __ logical_shift_right(R6, R6, lsr_shift);
1325     __ orr(R6, R6, AsmOperand(R7, lsl, lsl_shift));
1326     if (split_write) {
1327       // write the first half as soon as possible to reduce stm locking
1328       __ stmia(to, RegisterSet(R3, R6), writeback, prefetch_before ? gt : ge);
1329     }
1330     __ logical_shift_right(R7, R7, lsr_shift);
1331     __ orr(R7, R7, AsmOperand(R8, lsl, lsl_shift));
1332     __ logical_shift_right(R8, R8, lsr_shift);
1333     __ orr(R8, R8, AsmOperand(R9, lsl, lsl_shift));
1334     __ logical_shift_right(R9, R9, lsr_shift);
1335     __ orr(R9, R9, AsmOperand(R10, lsl, lsl_shift));
1336     __ logical_shift_right(R10, R10, lsr_shift);
1337     __ orr(R10, R10, AsmOperand(R12, lsl, lsl_shift));
1338 
1339     if (split_write) {
1340       __ stmia(to, RegisterSet(R7, R10), writeback, prefetch_before ? gt : ge);
1341     } else {
1342       __ stmia(to, RegisterSet(R3, R10), writeback, prefetch_before ? gt : ge);
1343     }
1344     __ b(L_shifted_loop, gt); // no need to loop if 0 (when count need not be precise modulo bytes_per_loop)
1345 
1346     if (prefetch_before) {
1347       // the first loop may end earlier, allowing to skip pld at the end
1348       __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);
1349       __ stmia(to, RegisterSet(R3, R10), writeback); // stmia was skipped
1350       __ b(L_skip_pld, ge);
1351       __ adds_32(count, count, ((bytes_per_loop + pld_offset) / bytes_per_count) + count_per_loop);
1352     }
1353 
1354     __ BIND(L_last_read);
1355     __ b(L_done, eq);
1356 
1357     switch (bytes_per_count) {
1358     case 2:
1359       __ mov(R3, AsmOperand(R12, lsr, lsr_shift));
1360       __ tst(count, 8);
1361       __ ldmia(from, RegisterSet(R4, R7), writeback, ne);
1362       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1363       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1364       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1365       __ mov(R5, AsmOperand(R5, lsr, lsr_shift), ne);
1366       __ orr(R5, R5, AsmOperand(R6, lsl, lsl_shift), ne);
1367       __ mov(R6, AsmOperand(R6, lsr, lsr_shift), ne);
1368       __ orr(R6, R6, AsmOperand(R7, lsl, lsl_shift), ne);
1369       __ stmia(to, RegisterSet(R3, R6), writeback, ne);
1370       __ mov(R3, AsmOperand(R7, lsr, lsr_shift), ne);
1371 
1372       __ tst(count, 4);
1373       __ ldmia(from, RegisterSet(R4, R5), writeback, ne);
1374       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1375       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1376       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1377       __ stmia(to, RegisterSet(R3, R4), writeback, ne);
1378       __ mov(R3, AsmOperand(R5, lsr, lsr_shift), ne);
1379 
1380       __ tst(count, 2);
1381       __ ldr(R4, Address(from, 4, post_indexed), ne);
1382       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne);
1383       __ str(R3, Address(to, 4, post_indexed), ne);
1384       __ mov(R3, AsmOperand(R4, lsr, lsr_shift), ne);
1385 
1386       __ tst(count, 1);
1387       __ strh(R3, Address(to, 2, post_indexed), ne); // one last short
1388       break;
1389 
1390     case 1:
1391       __ mov(R3, AsmOperand(R12, lsr, lsr_shift));
1392       __ tst(count, 16);
1393       __ ldmia(from, RegisterSet(R4, R7), writeback, ne);
1394       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1395       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1396       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1397       __ mov(R5, AsmOperand(R5, lsr, lsr_shift), ne);
1398       __ orr(R5, R5, AsmOperand(R6, lsl, lsl_shift), ne);
1399       __ mov(R6, AsmOperand(R6, lsr, lsr_shift), ne);
1400       __ orr(R6, R6, AsmOperand(R7, lsl, lsl_shift), ne);
1401       __ stmia(to, RegisterSet(R3, R6), writeback, ne);
1402       __ mov(R3, AsmOperand(R7, lsr, lsr_shift), ne);
1403 
1404       __ tst(count, 8);
1405       __ ldmia(from, RegisterSet(R4, R5), writeback, ne);
1406       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1407       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1408       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1409       __ stmia(to, RegisterSet(R3, R4), writeback, ne);
1410       __ mov(R3, AsmOperand(R5, lsr, lsr_shift), ne);
1411 
1412       __ tst(count, 4);
1413       __ ldr(R4, Address(from, 4, post_indexed), ne);
1414       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne);
1415       __ str(R3, Address(to, 4, post_indexed), ne);
1416       __ mov(R3, AsmOperand(R4, lsr, lsr_shift), ne);
1417 
1418       __ andr(count, count, 3);
1419       __ cmp(count, 2);
1420 
1421       // Note: R3 might contain enough bytes ready to write (3 needed at most),
1422       // thus load on lsl_shift==24 is not needed (in fact forces reading
1423       // beyond source buffer end boundary)
1424       if (lsl_shift == 8) {
1425         __ ldr(R4, Address(from, 4, post_indexed), ge);
1426         __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ge);
1427       } else if (lsl_shift == 16) {
1428         __ ldr(R4, Address(from, 4, post_indexed), gt);
1429         __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), gt);
1430       }
1431 
1432       __ strh(R3, Address(to, 2, post_indexed), ge); // two last bytes
1433       __ mov(R3, AsmOperand(R3, lsr, 16), gt);
1434 
1435       __ tst(count, 1);
1436       __ strb(R3, Address(to, 1, post_indexed), ne); // one last byte
1437       break;
1438     }
1439 
1440     __ BIND(L_done);
1441     return 0; // no minimum
1442   }
1443 
1444   // Generate the inner loop for shifted backward array copy (unaligned copy).
1445   // It can be used when bytes_per_count &lt; wordSize, i.e. byte/short copy
1446   //
1447   // Arguments
1448   //      end_from:  end src address, 64 bits aligned
1449   //      end_to:    end dst address, (now) wordSize aligned
1450   //      count:     number of elements (32-bit int)
1451   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1452   //      lsl_shift: shift applied to &#39;old&#39; value to skipped already written bytes
1453   //      lsr_shift: shift applied to &#39;new&#39; value to set the low bytes of the next write
1454   //
1455   // Return the minimum initial value for count
1456   //
1457   // Notes:
1458   // - &#39;end_from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1459   // - &#39;end_to&#39; aligned on wordSize
1460   // - &#39;count&#39; must be greater or equal than the returned value
1461   // - &#39;lsr_shift&#39; + &#39;lsl_shift&#39; = &#39;BitsPerWord&#39;
1462   // - &#39;bytes_per_count&#39; is 1 or 2 on 32-bit ARM
1463   //
1464   // Decreases &#39;end_to&#39; by count*bytes_per_count.
1465   //
1466   // Scratches &#39;end_from&#39;, &#39;count&#39;, R3-R10, R12
1467   //
1468   // On entry:
1469   // - R3 is preloaded with the first &#39;BitsPerWord&#39; bits read just after &#39;from&#39;
1470   // - (R3 &lt;&lt; lsl_shift) is the part not yet written
1471   // --&gt; (*--to) = (R3 &lt;&lt; lsl_shift) | (*--from) &gt;&gt; lsr_shift); ...
1472   //
1473   // This implementation may read more bytes than required.
1474   // Actually, it always reads exactly all data from the copied region with beginning aligned down by wordSize,
1475   // so excessive read do not cross a word bound and is thus harmless.
1476   //
1477   int generate_backward_shifted_copy_loop(Register end_from, Register end_to, Register count, int bytes_per_count, int lsr_shift, int lsl_shift) {
1478     assert (end_from == R0 &amp;&amp; end_to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1479 
1480     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iter
1481     const int count_per_loop = bytes_per_loop / bytes_per_count;
1482 
1483     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].backward_shifted;
1484     int pld_offset = config-&gt;pld_distance;
1485 
1486     bool split_read= config-&gt;split_ldm;
1487     bool split_write= config-&gt;split_stm;
1488 
1489 
1490     const bool prefetch_before = pld_offset &lt; 0;
1491     const bool prefetch_after = pld_offset &gt; 0;
1492 
1493     Label L_skip_pld, L_done, L_last_read;
1494     if (pld_offset != 0) {
1495 
1496       pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
1497 
1498       prefetch(end_from, end_to, -wordSize);
1499 
1500       if (prefetch_before) {
1501         __ cmp_32(count, count_per_loop);
1502         __ b(L_last_read, lt);
1503 
1504         // skip prefetch for small copies
1505         // warning: count is predecreased by the prefetch distance to optimize the inner loop
1506         __ subs_32(count, count, ((bytes_per_loop + pld_offset)/bytes_per_count) + count_per_loop);
1507         __ b(L_skip_pld, lt);
1508       }
1509 
1510       int offset = ArmCopyCacheLineSize;
1511       while (offset &lt;= pld_offset) {
1512         prefetch(end_from, end_to, -(wordSize + offset));
1513         offset += ArmCopyCacheLineSize;
1514       };
1515     }
1516 
1517     Label L_shifted_loop;
1518     __ align(OptoLoopAlignment);
1519     __ BIND(L_shifted_loop);
1520 
1521     if (prefetch_before) {
1522       // do the 1st ldm/ldp first anyway (no locking issues with early STM/STP)
1523       prefetch(end_from, end_to, -(wordSize + bytes_per_loop + pld_offset));
1524       __ BIND(L_skip_pld);
1525     } else {
1526       __ cmp_32(count, count_per_loop);
1527       __ b(L_last_read, lt);
1528     }
1529 
1530     if (split_read) {
1531       __ ldmdb(end_from, RegisterSet(R7, R10), writeback);
1532       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1533       __ ldmdb(end_from, RegisterSet(R3, R6), writeback);
1534     } else {
1535       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1536       __ ldmdb(end_from, RegisterSet(R3, R10), writeback);
1537     }
1538 
1539     __ subs_32(count, count, count_per_loop);
1540 
1541     if (prefetch_after) { // do prefetch during ldm/ldp latency
1542       prefetch(end_from, end_to, -(wordSize + pld_offset), -bytes_per_loop);
1543     }
1544 
1545     // prepare the values in R4..R10,R12
1546     __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift)); // merged above high  bytes of prev val
1547     __ logical_shift_left(R10, R10, lsl_shift); // unused part of prev val
1548     __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift)); // ...
1549     __ logical_shift_left(R9, R9, lsl_shift);
1550     __ orr(R9, R9, AsmOperand(R8, lsr, lsr_shift));
1551     __ logical_shift_left(R8, R8, lsl_shift);
1552     __ orr(R8, R8, AsmOperand(R7, lsr, lsr_shift));
1553     __ logical_shift_left(R7, R7, lsl_shift);
1554     __ orr(R7, R7, AsmOperand(R6, lsr, lsr_shift));
1555     __ logical_shift_left(R6, R6, lsl_shift);
1556     __ orr(R6, R6, AsmOperand(R5, lsr, lsr_shift));
1557     if (split_write) {
1558       // store early to reduce locking issues
1559       __ stmdb(end_to, RegisterSet(R6, R10) | R12, writeback, prefetch_before ? gt : ge);
1560     }
1561     __ logical_shift_left(R5, R5, lsl_shift);
1562     __ orr(R5, R5, AsmOperand(R4, lsr, lsr_shift));
1563     __ logical_shift_left(R4, R4, lsl_shift);
1564     __ orr(R4, R4, AsmOperand(R3, lsr, lsr_shift));
1565 
1566     if (split_write) {
1567       __ stmdb(end_to, RegisterSet(R4, R5), writeback, prefetch_before ? gt : ge);
1568     } else {
1569       __ stmdb(end_to, RegisterSet(R4, R10) | R12, writeback, prefetch_before ? gt : ge);
1570     }
1571 
1572     __ b(L_shifted_loop, gt); // no need to loop if 0 (when count need not be precise modulo bytes_per_loop)
1573 
1574     if (prefetch_before) {
1575       // the first loop may end earlier, allowing to skip pld at the end
1576       __ cmn_32(count, ((bytes_per_loop + pld_offset)/bytes_per_count));
1577       __ stmdb(end_to, RegisterSet(R4, R10) | R12, writeback); // stmdb was skipped
1578       __ b(L_skip_pld, ge);
1579       __ adds_32(count, count, ((bytes_per_loop + pld_offset) / bytes_per_count) + count_per_loop);
1580     }
1581 
1582     __ BIND(L_last_read);
1583     __ b(L_done, eq);
1584 
1585       switch(bytes_per_count) {
1586       case 2:
1587       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1588       __ tst(count, 8);
1589       __ ldmdb(end_from, RegisterSet(R7,R10), writeback, ne);
1590       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1591       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1592       __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift),ne); // ...
1593       __ mov(R9, AsmOperand(R9, lsl, lsl_shift),ne);
1594       __ orr(R9, R9, AsmOperand(R8, lsr, lsr_shift),ne);
1595       __ mov(R8, AsmOperand(R8, lsl, lsl_shift),ne);
1596       __ orr(R8, R8, AsmOperand(R7, lsr, lsr_shift),ne);
1597       __ stmdb(end_to, RegisterSet(R8,R10)|R12, writeback, ne);
1598       __ mov(R12, AsmOperand(R7, lsl, lsl_shift), ne);
1599 
1600       __ tst(count, 4);
1601       __ ldmdb(end_from, RegisterSet(R9, R10), writeback, ne);
1602       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1603       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1604       __ orr(R10, R10, AsmOperand(R9, lsr,lsr_shift),ne); // ...
1605       __ stmdb(end_to, RegisterSet(R10)|R12, writeback, ne);
1606       __ mov(R12, AsmOperand(R9, lsl, lsl_shift), ne);
1607 
1608       __ tst(count, 2);
1609       __ ldr(R10, Address(end_from, -4, pre_indexed), ne);
1610       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1611       __ str(R12, Address(end_to, -4, pre_indexed), ne);
1612       __ mov(R12, AsmOperand(R10, lsl, lsl_shift), ne);
1613 
1614       __ tst(count, 1);
1615       __ mov(R12, AsmOperand(R12, lsr, lsr_shift),ne);
1616       __ strh(R12, Address(end_to, -2, pre_indexed), ne); // one last short
1617       break;
1618 
1619       case 1:
1620       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1621       __ tst(count, 16);
1622       __ ldmdb(end_from, RegisterSet(R7,R10), writeback, ne);
1623       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1624       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1625       __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift),ne); // ...
1626       __ mov(R9, AsmOperand(R9, lsl, lsl_shift),ne);
1627       __ orr(R9, R9, AsmOperand(R8, lsr, lsr_shift),ne);
1628       __ mov(R8, AsmOperand(R8, lsl, lsl_shift),ne);
1629       __ orr(R8, R8, AsmOperand(R7, lsr, lsr_shift),ne);
1630       __ stmdb(end_to, RegisterSet(R8,R10)|R12, writeback, ne);
1631       __ mov(R12, AsmOperand(R7, lsl, lsl_shift), ne);
1632 
1633       __ tst(count, 8);
1634       __ ldmdb(end_from, RegisterSet(R9,R10), writeback, ne);
1635       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1636       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1637       __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift),ne); // ...
1638       __ stmdb(end_to, RegisterSet(R10)|R12, writeback, ne);
1639       __ mov(R12, AsmOperand(R9, lsl, lsl_shift), ne);
1640 
1641       __ tst(count, 4);
1642       __ ldr(R10, Address(end_from, -4, pre_indexed), ne);
1643       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1644       __ str(R12, Address(end_to, -4, pre_indexed), ne);
1645       __ mov(R12, AsmOperand(R10, lsl, lsl_shift), ne);
1646 
1647       __ tst(count, 2);
1648       if (lsr_shift != 24) {
1649         // avoid useless reading R10 when we already have 3 bytes ready in R12
1650         __ ldr(R10, Address(end_from, -4, pre_indexed), ne);
1651         __ orr(R12, R12, AsmOperand(R10, lsr,lsr_shift), ne);
1652       }
1653 
1654       // Note: R12 contains enough bytes ready to write (3 needed at most)
1655       // write the 2 MSBs
1656       __ mov(R9, AsmOperand(R12, lsr, 16), ne);
1657       __ strh(R9, Address(end_to, -2, pre_indexed), ne);
1658       // promote remaining to MSB
1659       __ mov(R12, AsmOperand(R12, lsl, 16), ne);
1660 
1661       __ tst(count, 1);
1662       // write the MSB of R12
1663       __ mov(R12, AsmOperand(R12, lsr, 24), ne);
1664       __ strb(R12, Address(end_to, -1, pre_indexed), ne);
1665 
1666       break;
1667       }
1668 
1669     __ BIND(L_done);
1670     return 0; // no minimum
1671   }
1672 
1673   // This method is very useful for merging forward/backward implementations
1674   Address get_addr_with_indexing(Register base, int delta, bool forward) {
1675     if (forward) {
1676       return Address(base, delta, post_indexed);
1677     } else {
1678       return Address(base, -delta, pre_indexed);
1679     }
1680   }
1681 
1682   void load_one(Register rd, Register from, int size_in_bytes, bool forward, AsmCondition cond = al, Register rd2 = noreg) {
1683     assert_different_registers(from, rd, rd2);
1684     if (size_in_bytes &lt; 8) {
1685       Address addr = get_addr_with_indexing(from, size_in_bytes, forward);
1686       __ load_sized_value(rd, addr, size_in_bytes, false, cond);
1687     } else {
1688       assert (rd2 != noreg, &quot;second value register must be specified&quot;);
1689       assert (rd-&gt;encoding() &lt; rd2-&gt;encoding(), &quot;wrong value register set&quot;);
1690 
1691       if (forward) {
1692         __ ldmia(from, RegisterSet(rd) | rd2, writeback, cond);
1693       } else {
1694         __ ldmdb(from, RegisterSet(rd) | rd2, writeback, cond);
1695       }
1696     }
1697   }
1698 
1699   void store_one(Register rd, Register to, int size_in_bytes, bool forward, AsmCondition cond = al, Register rd2 = noreg) {
1700     assert_different_registers(to, rd, rd2);
1701     if (size_in_bytes &lt; 8) {
1702       Address addr = get_addr_with_indexing(to, size_in_bytes, forward);
1703       __ store_sized_value(rd, addr, size_in_bytes, cond);
1704     } else {
1705       assert (rd2 != noreg, &quot;second value register must be specified&quot;);
1706       assert (rd-&gt;encoding() &lt; rd2-&gt;encoding(), &quot;wrong value register set&quot;);
1707 
1708       if (forward) {
1709         __ stmia(to, RegisterSet(rd) | rd2, writeback, cond);
1710       } else {
1711         __ stmdb(to, RegisterSet(rd) | rd2, writeback, cond);
1712       }
1713     }
1714   }
1715 
1716   // Copies data from &#39;from&#39; to &#39;to&#39; in specified direction to align &#39;from&#39; by 64 bits.
1717   // (on 32-bit ARM 64-bit alignment is better for LDM).
1718   //
1719   // Arguments:
1720   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1721   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1722   //     count:             32-bit int, maximum number of elements which can be copied
1723   //     bytes_per_count:   size of an element
1724   //     forward:           specifies copy direction
1725   //
1726   // Notes:
1727   //   &#39;from&#39; and &#39;to&#39; must be aligned by &#39;bytes_per_count&#39;
1728   //   &#39;count&#39; must not be less than the returned value
1729   //   shifts &#39;from&#39; and &#39;to&#39; by the number of copied bytes in corresponding direction
1730   //   decreases &#39;count&#39; by the number of elements copied
1731   //
1732   // Returns maximum number of bytes which may be copied.
1733   int align_src(Register from, Register to, Register count, Register tmp, int bytes_per_count, bool forward) {
1734     assert_different_registers(from, to, count, tmp);
1735     if (bytes_per_count &lt; 8) {
1736       Label L_align_src;
1737       __ BIND(L_align_src);
1738       __ tst(from, 7);
1739       // ne =&gt; not aligned: copy one element and (if bytes_per_count &lt; 4) loop
1740       __ sub(count, count, 1, ne);
1741       load_one(tmp, from, bytes_per_count, forward, ne);
1742       store_one(tmp, to, bytes_per_count, forward, ne);
1743       if (bytes_per_count &lt; 4) {
1744         __ b(L_align_src, ne); // if bytes_per_count == 4, then 0 or 1 loop iterations are enough
1745       }
1746     }
1747     return 7/bytes_per_count;
1748   }
1749 
1750   // Copies &#39;count&#39; of &#39;bytes_per_count&#39;-sized elements in the specified direction.
1751   //
1752   // Arguments:
1753   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1754   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1755   //     count:             32-bit int, number of elements to be copied
1756   //     entry:             copy loop entry point
1757   //     bytes_per_count:   size of an element
1758   //     forward:           specifies copy direction
1759   //
1760   // Notes:
1761   //     shifts &#39;from&#39; and &#39;to&#39;
1762   void copy_small_array(Register from, Register to, Register count, Register tmp, Register tmp2, int bytes_per_count, bool forward, Label &amp; entry, bool unsafe_copy = false) {
1763     assert_different_registers(from, to, count, tmp);
1764 
1765     {
1766       // UnsafeCopyMemory page error: continue after ucm
1767       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
1768       __ align(OptoLoopAlignment);
1769       Label L_small_loop;
1770       __ BIND(L_small_loop);
1771       store_one(tmp, to, bytes_per_count, forward, al, tmp2);
1772       __ BIND(entry); // entry point
1773       __ subs(count, count, 1);
1774       load_one(tmp, from, bytes_per_count, forward, ge, tmp2);
1775       __ b(L_small_loop, ge);
1776     }
1777   }
1778 
1779   // Aligns &#39;to&#39; by reading one word from &#39;from&#39; and writting its part to &#39;to&#39;.
1780   //
1781   // Arguments:
1782   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1783   //     count:             32-bit int, number of elements allowed to be copied
1784   //     to_remainder:      remainder of dividing &#39;to&#39; by wordSize
1785   //     bytes_per_count:   size of an element
1786   //     forward:           specifies copy direction
1787   //     Rval:              contains an already read but not yet written word;
1788   //                        its&#39; LSBs (if forward) or MSBs (if !forward) are to be written to align &#39;to&#39;.
1789   //
1790   // Notes:
1791   //     &#39;count&#39; must not be less then the returned value
1792   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1793   //     shifts &#39;to&#39; by the number of written bytes (so that it becomes the bound of memory to be written)
1794   //     decreases &#39;count&#39; by the the number of elements written
1795   //     Rval&#39;s MSBs or LSBs remain to be written further by generate_{forward,backward}_shifted_copy_loop
1796   int align_dst(Register to, Register count, Register Rval, Register tmp,
1797                                         int to_remainder, int bytes_per_count, bool forward) {
1798     assert_different_registers(to, count, tmp, Rval);
1799 
1800     assert (0 &lt; to_remainder &amp;&amp; to_remainder &lt; wordSize, &quot;to_remainder is not valid&quot;);
1801     assert (to_remainder % bytes_per_count == 0, &quot;to must be aligned by bytes_per_count&quot;);
1802 
1803     int bytes_to_write = forward ? (wordSize - to_remainder) : to_remainder;
1804 
1805     int offset = 0;
1806 
1807     for (int l = 0; l &lt; LogBytesPerWord; ++l) {
1808       int s = (1 &lt;&lt; l);
1809       if (bytes_to_write &amp; s) {
1810         int new_offset = offset + s*BitsPerByte;
1811         if (forward) {
1812           if (offset == 0) {
1813             store_one(Rval, to, s, forward);
1814           } else {
1815             __ logical_shift_right(tmp, Rval, offset);
1816             store_one(tmp, to, s, forward);
1817           }
1818         } else {
1819           __ logical_shift_right(tmp, Rval, BitsPerWord - new_offset);
1820           store_one(tmp, to, s, forward);
1821         }
1822 
1823         offset = new_offset;
1824       }
1825     }
1826 
1827     assert (offset == bytes_to_write * BitsPerByte, &quot;all bytes must be copied&quot;);
1828 
1829     __ sub_32(count, count, bytes_to_write/bytes_per_count);
1830 
1831     return bytes_to_write / bytes_per_count;
1832   }
1833 
1834   // Copies &#39;count&#39; of elements using shifted copy loop
1835   //
1836   // Arguments:
1837   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1838   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1839   //     count:             32-bit int, number of elements to be copied
1840   //     to_remainder:      remainder of dividing &#39;to&#39; by wordSize
1841   //     bytes_per_count:   size of an element
1842   //     forward:           specifies copy direction
1843   //     Rval:              contains an already read but not yet written word
1844   //
1845   //
1846   // Notes:
1847   //     &#39;count&#39; must not be less then the returned value
1848   //     &#39;from&#39; must be aligned by wordSize
1849   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1850   //     shifts &#39;to&#39; by the number of copied bytes
1851   //
1852   // Scratches R3-R10, R12
1853   int align_dst_and_generate_shifted_copy_loop(Register from, Register to, Register count, Register Rval,
1854                                                         int to_remainder, int bytes_per_count, bool forward) {
1855 
1856     assert (0 &lt; to_remainder &amp;&amp; to_remainder &lt; wordSize, &quot;to_remainder is invalid&quot;);
1857 
1858     const Register tmp  = forward ? R3 : R12;
1859     assert_different_registers(from, to, count, Rval, tmp);
1860 
1861     int required_to_align = align_dst(to, count, Rval, tmp, to_remainder, bytes_per_count, forward);
1862 
1863     int lsr_shift = (wordSize - to_remainder) * BitsPerByte;
1864     int lsl_shift = to_remainder * BitsPerByte;
1865 
1866     int min_copy;
1867     if (forward) {
1868       min_copy = generate_forward_shifted_copy_loop(from, to, count, bytes_per_count, lsr_shift, lsl_shift);
1869     } else {
1870       min_copy = generate_backward_shifted_copy_loop(from, to, count, bytes_per_count, lsr_shift, lsl_shift);
1871     }
1872 
1873     return min_copy + required_to_align;
1874   }
1875 
1876   // Copies &#39;count&#39; of elements using shifted copy loop
1877   //
1878   // Arguments:
1879   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1880   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1881   //     count:             32-bit int, number of elements to be copied
1882   //     bytes_per_count:   size of an element
1883   //     forward:           specifies copy direction
1884   //
1885   // Notes:
1886   //     &#39;count&#39; must not be less then the returned value
1887   //     &#39;from&#39; must be aligned by wordSize
1888   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1889   //     shifts &#39;to&#39; by the number of copied bytes
1890   //
1891   // Scratches &#39;from&#39;, &#39;count&#39;, R3 and R12.
1892   // R4-R10 saved for use.
1893   int align_dst_and_generate_shifted_copy_loop(Register from, Register to, Register count, int bytes_per_count, bool forward, bool unsafe_copy = false) {
1894 
1895     const Register Rval = forward ? R12 : R3; // as generate_{forward,backward}_shifted_copy_loop expect
1896 
1897     int min_copy = 0;
1898 
1899     // Note: if {seq} is a sequence of numbers, L{seq} means that if the execution reaches this point,
1900     // then the remainder of &#39;to&#39; divided by wordSize is one of elements of {seq}.
1901 
1902     __ push(RegisterSet(R4,R10));
1903 
1904     {
1905       // UnsafeCopyMemory page error: continue after ucm
1906       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
1907       load_one(Rval, from, wordSize, forward);
1908 
1909       switch (bytes_per_count) {
1910         case 2:
1911           min_copy = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);
1912           break;
1913         case 1:
1914         {
1915           Label L1, L2, L3;
1916           int min_copy1, min_copy2, min_copy3;
1917 
1918           Label L_loop_finished;
1919 
1920           if (forward) {
1921               __ tbz(to, 0, L2);
1922               __ tbz(to, 1, L1);
1923 
1924               __ BIND(L3);
1925               min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);
1926               __ b(L_loop_finished);
1927 
1928               __ BIND(L1);
1929               min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);
1930               __ b(L_loop_finished);
1931 
1932               __ BIND(L2);
1933               min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);
1934           } else {
1935               __ tbz(to, 0, L2);
1936               __ tbnz(to, 1, L3);
1937 
1938               __ BIND(L1);
1939               min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);
1940               __ b(L_loop_finished);
1941 
1942                __ BIND(L3);
1943               min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);
1944               __ b(L_loop_finished);
1945 
1946              __ BIND(L2);
1947               min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);
1948           }
1949 
1950           min_copy = MAX2(MAX2(min_copy1, min_copy2), min_copy3);
1951 
1952           __ BIND(L_loop_finished);
1953 
1954           break;
1955         }
1956         default:
1957           ShouldNotReachHere();
1958           break;
1959       }
1960     }
1961     __ pop(RegisterSet(R4,R10));
1962 
1963     return min_copy;
1964   }
1965 
1966 #ifndef PRODUCT
1967   int * get_arraycopy_counter(int bytes_per_count) {
1968     switch (bytes_per_count) {
1969       case 1:
1970         return &amp;SharedRuntime::_jbyte_array_copy_ctr;
1971       case 2:
1972         return &amp;SharedRuntime::_jshort_array_copy_ctr;
1973       case 4:
1974         return &amp;SharedRuntime::_jint_array_copy_ctr;
1975       case 8:
1976         return &amp;SharedRuntime::_jlong_array_copy_ctr;
1977       default:
1978         ShouldNotReachHere();
1979         return NULL;
1980     }
1981   }
1982 #endif // !PRODUCT
1983 
1984   address generate_unsafecopy_common_error_exit() {
1985     address start_pc = __ pc();
1986       __ mov(R0, 0);
1987       __ ret();
1988     return start_pc;
1989   }
1990 
1991   //
1992   //  Generate stub for primitive array copy.  If &quot;aligned&quot; is true, the
1993   //  &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1994   //
1995   //  If &quot;disjoint&quot; is true, arrays are assumed to be disjoint, otherwise they may overlap and
1996   //  &quot;nooverlap_target&quot; must be specified as the address to jump if they don&#39;t.
1997   //
1998   // Arguments for generated stub:
1999   //      from:  R0
2000   //      to:    R1
2001   //      count: R2 treated as signed 32-bit int
2002   //
2003   address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = NULL) {
2004     __ align(CodeEntryAlignment);
2005     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2006     address start = __ pc();
2007 
2008     const Register from  = R0;   // source array address
2009     const Register to    = R1;   // destination array address
2010     const Register count = R2;   // elements count
2011     const Register tmp1  = R3;
2012     const Register tmp2  = R12;
2013 
2014     if (!aligned)  {
2015       BLOCK_COMMENT(&quot;Entry:&quot;);
2016     }
2017 
2018     __ zap_high_non_significant_bits(R2);
2019 
2020     if (!disjoint) {
2021       assert (nooverlap_target != NULL, &quot;must be specified for conjoint case&quot;);
2022       array_overlap_test(nooverlap_target, exact_log2(bytes_per_count), tmp1, tmp2);
2023     }
2024 
2025     inc_counter_np(*get_arraycopy_counter(bytes_per_count), tmp1, tmp2);
2026 
2027     // Conjoint case: since execution reaches this point, the arrays overlap, so performing backward copy
2028     // Disjoint case: perform forward copy
2029     bool forward = disjoint;
2030 
2031 
2032     if (!forward) {
2033       // Set &#39;from&#39; and &#39;to&#39; to upper bounds
2034       int log_bytes_per_count = exact_log2(bytes_per_count);
2035       __ add_ptr_scaled_int32(to,   to,   count, log_bytes_per_count);
2036       __ add_ptr_scaled_int32(from, from, count, log_bytes_per_count);
2037     }
2038 
2039     // There are two main copy loop implementations:
2040     //  *) The huge and complex one applicable only for large enough arrays
2041     //  *) The small and simple one applicable for any array (but not efficient for large arrays).
2042     // Currently &quot;small&quot; implementation is used if and only if the &quot;large&quot; one could not be used.
2043     // XXX optim: tune the limit higher ?
2044     // Large implementation lower applicability bound is actually determined by
2045     // aligned copy loop which require &lt;=7 bytes for src alignment, and 8 words for aligned copy loop.
2046     const int small_copy_limit = (8*wordSize + 7) / bytes_per_count;
2047 
2048     Label L_small_array;
2049     __ cmp_32(count, small_copy_limit);
2050     __ b(L_small_array, le);
2051 
2052     // Otherwise proceed with large implementation.
2053 
2054     bool from_is_aligned = (bytes_per_count &gt;= 8);
2055     if (aligned &amp;&amp; forward &amp;&amp; (HeapWordSize % 8 == 0)) {
2056         // if &#39;from&#39; is heapword aligned and HeapWordSize is divisible by 8,
2057         //  then from is aligned by 8
2058         from_is_aligned = true;
2059     }
2060 
2061     int count_required_to_align = 0;
2062     {
2063       // UnsafeCopyMemoryMark page error: continue at UnsafeCopyMemory common_error_exit
2064       UnsafeCopyMemoryMark ucmm(this, !aligned, false);
2065       count_required_to_align = from_is_aligned ? 0 : align_src(from, to, count, tmp1, bytes_per_count, forward);
2066       assert (small_copy_limit &gt;= count_required_to_align, &quot;alignment could exhaust count&quot;);
2067     }
2068 
2069     // now &#39;from&#39; is aligned
2070 
2071     bool to_is_aligned = false;
2072 
2073     if (bytes_per_count &gt;= wordSize) {
2074       // &#39;to&#39; is aligned by bytes_per_count, so it is aligned by wordSize
2075       to_is_aligned = true;
2076     } else {
2077       if (aligned &amp;&amp; (8 % HeapWordSize == 0) &amp;&amp; (HeapWordSize % wordSize == 0)) {
2078         // Originally &#39;from&#39; and &#39;to&#39; were heapword aligned;
2079         // (from - to) has not been changed, so since now &#39;from&#39; is 8-byte aligned, then it is also heapword aligned,
2080         //  so &#39;to&#39; is also heapword aligned and thus aligned by wordSize.
2081         to_is_aligned = true;
2082       }
2083     }
2084 
2085     Label L_unaligned_dst;
2086 
2087     if (!to_is_aligned) {
2088       BLOCK_COMMENT(&quot;Check dst alignment:&quot;);
2089       __ tst(to, wordSize - 1);
2090       __ b(L_unaligned_dst, ne); // &#39;to&#39; is not aligned
2091     }
2092 
2093     // &#39;from&#39; and &#39;to&#39; are properly aligned
2094 
2095     int min_copy;
2096     if (forward) {
2097       min_copy = generate_forward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned /*add UnsafeCopyMemory entry*/);
2098     } else {
2099       min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned /*add UnsafeCopyMemory entry*/);
2100     }
2101     assert(small_copy_limit &gt;= count_required_to_align + min_copy, &quot;first loop might exhaust count&quot;);
2102 
2103     if (status) {
2104       __ mov(R0, 0); // OK
2105     }
2106 
2107     __ ret();
2108 
2109     {
2110       copy_small_array(from, to, count, tmp1, tmp2, bytes_per_count, forward, L_small_array /* entry */, !aligned /*add UnsafeCopyMemory entry*/);
2111 
2112       if (status) {
2113         __ mov(R0, 0); // OK
2114       }
2115 
2116       __ ret();
2117     }
2118 
2119     if (! to_is_aligned) {
2120       __ BIND(L_unaligned_dst);
2121       int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward, !aligned /*add UnsafeCopyMemory entry*/);
2122       assert (small_copy_limit &gt;= count_required_to_align + min_copy_shifted, &quot;first loop might exhaust count&quot;);
2123 
2124       if (status) {
2125         __ mov(R0, 0); // OK
2126       }
2127 
2128       __ ret();
2129     }
2130 
2131     return start;
2132   }
2133 
2134 
2135   // Generates pattern of code to be placed after raw data copying in generate_oop_copy
2136   // Includes return from arraycopy stub.
2137   //
2138   // Arguments:
2139   //     to:       destination pointer after copying.
2140   //               if &#39;forward&#39; then &#39;to&#39; == upper bound, else &#39;to&#39; == beginning of the modified region
2141   //     count:    total number of copied elements, 32-bit int
2142   //
2143   // Blows all volatile R0-R3, Rtemp, LR) and &#39;to&#39;, &#39;count&#39;, &#39;tmp&#39; registers.
2144   void oop_arraycopy_stub_epilogue_helper(Register to, Register count, Register tmp, bool status, bool forward, DecoratorSet decorators) {
2145     assert_different_registers(to, count, tmp);
2146 
2147     if (forward) {
2148       // &#39;to&#39; is upper bound of the modified region
2149       // restore initial dst:
2150       __ sub_ptr_scaled_int32(to, to, count, LogBytesPerHeapOop);
2151     }
2152 
2153     // &#39;to&#39; is the beginning of the region
2154 
2155     BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2156     bs-&gt;arraycopy_epilogue(_masm, decorators, true, to, count, tmp);
2157 
2158     if (status) {
2159       __ mov(R0, 0); // OK
2160     }
2161 
2162     __ pop(PC);
2163   }
2164 
2165 
2166   //  Generate stub for assign-compatible oop copy.  If &quot;aligned&quot; is true, the
2167   //  &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
2168   //
2169   //  If &quot;disjoint&quot; is true, arrays are assumed to be disjoint, otherwise they may overlap and
2170   //  &quot;nooverlap_target&quot; must be specified as the address to jump if they don&#39;t.
2171   //
2172   // Arguments for generated stub:
2173   //      from:  R0
2174   //      to:    R1
2175   //      count: R2 treated as signed 32-bit int
2176   //
2177   address generate_oop_copy(bool aligned, const char * name, bool status, bool disjoint, address nooverlap_target = NULL) {
2178     __ align(CodeEntryAlignment);
2179     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2180     address start = __ pc();
2181 
2182     Register from  = R0;
2183     Register to    = R1;
2184     Register count = R2;
2185     Register tmp1  = R3;
2186     Register tmp2  = R12;
2187 
2188 
2189     if (!aligned) {
2190       BLOCK_COMMENT(&quot;Entry:&quot;);
2191     }
2192 
2193     __ zap_high_non_significant_bits(R2);
2194 
2195     if (!disjoint) {
2196       assert (nooverlap_target != NULL, &quot;must be specified for conjoint case&quot;);
2197       array_overlap_test(nooverlap_target, LogBytesPerHeapOop, tmp1, tmp2);
2198     }
2199 
2200     inc_counter_np(SharedRuntime::_oop_array_copy_ctr, tmp1, tmp2);
2201 
2202     // Conjoint case: since execution reaches this point, the arrays overlap, so performing backward copy
2203     // Disjoint case: perform forward copy
2204     bool forward = disjoint;
2205 
2206     const int bytes_per_count = BytesPerHeapOop;
2207     const int log_bytes_per_count = LogBytesPerHeapOop;
2208 
2209     const Register saved_count = LR;
2210     const int callee_saved_regs = 3; // R0-R2
2211 
2212     // LR is used later to save barrier args
2213     __ push(LR);
2214 
2215     DecoratorSet decorators = IN_HEAP | IS_ARRAY;
2216     if (disjoint) {
2217       decorators |= ARRAYCOPY_DISJOINT;
2218     }
2219     if (aligned) {
2220       decorators |= ARRAYCOPY_ALIGNED;
2221     }
2222 
2223     BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2224     bs-&gt;arraycopy_prologue(_masm, decorators, true, to, count, callee_saved_regs);
2225 
2226     // save arguments for barrier generation (after the pre barrier)
2227     __ mov(saved_count, count);
2228 
2229     if (!forward) {
2230       __ add_ptr_scaled_int32(to,   to,   count, log_bytes_per_count);
2231       __ add_ptr_scaled_int32(from, from, count, log_bytes_per_count);
2232     }
2233 
2234     // for short arrays, just do single element copy
2235     Label L_small_array;
2236     const int small_copy_limit = (8*wordSize + 7)/bytes_per_count; // XXX optim: tune the limit higher ?
2237     __ cmp_32(count, small_copy_limit);
2238     __ b(L_small_array, le);
2239 
2240     bool from_is_aligned = (bytes_per_count &gt;= 8);
2241     if (aligned &amp;&amp; forward &amp;&amp; (HeapWordSize % 8 == 0)) {
2242         // if &#39;from&#39; is heapword aligned and HeapWordSize is divisible by 8,
2243         //  then from is aligned by 8
2244         from_is_aligned = true;
2245     }
2246 
2247     int count_required_to_align = from_is_aligned ? 0 : align_src(from, to, count, tmp1, bytes_per_count, forward);
2248     assert (small_copy_limit &gt;= count_required_to_align, &quot;alignment could exhaust count&quot;);
2249 
2250     // now &#39;from&#39; is aligned
2251 
2252     bool to_is_aligned = false;
2253 
2254     if (bytes_per_count &gt;= wordSize) {
2255       // &#39;to&#39; is aligned by bytes_per_count, so it is aligned by wordSize
2256       to_is_aligned = true;
2257     } else {
2258       if (aligned &amp;&amp; (8 % HeapWordSize == 0) &amp;&amp; (HeapWordSize % wordSize == 0)) {
2259         // Originally &#39;from&#39; and &#39;to&#39; were heapword aligned;
2260         // (from - to) has not been changed, so since now &#39;from&#39; is 8-byte aligned, then it is also heapword aligned,
2261         //  so &#39;to&#39; is also heapword aligned and thus aligned by wordSize.
2262         to_is_aligned = true;
2263       }
2264     }
2265 
2266     Label L_unaligned_dst;
2267 
2268     if (!to_is_aligned) {
2269       BLOCK_COMMENT(&quot;Check dst alignment:&quot;);
2270       __ tst(to, wordSize - 1);
2271       __ b(L_unaligned_dst, ne); // &#39;to&#39; is not aligned
2272     }
2273 
2274     int min_copy;
2275     if (forward) {
2276       min_copy = generate_forward_aligned_copy_loop(from, to, count, bytes_per_count);
2277     } else {
2278       min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count);
2279     }
2280     assert(small_copy_limit &gt;= count_required_to_align + min_copy, &quot;first loop might exhaust count&quot;);
2281 
2282     oop_arraycopy_stub_epilogue_helper(to, saved_count, /* tmp */ tmp1, status, forward, decorators);
2283 
2284     {
2285       copy_small_array(from, to, count, tmp1, noreg, bytes_per_count, forward, L_small_array);
2286 
2287       oop_arraycopy_stub_epilogue_helper(to, saved_count, /* tmp */ tmp1, status, forward, decorators);
2288     }
2289 
2290     if (!to_is_aligned) {
2291       __ BIND(L_unaligned_dst);
2292       ShouldNotReachHere();
2293       int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward);
2294       assert (small_copy_limit &gt;= count_required_to_align + min_copy_shifted, &quot;first loop might exhaust count&quot;);
2295 
2296       oop_arraycopy_stub_epilogue_helper(to, saved_count, /* tmp */ tmp1, status, forward, decorators);
2297     }
2298 
2299     return start;
2300   }
2301 
2302   //  Generate &#39;unsafe&#39; array copy stub
2303   //  Though just as safe as the other stubs, it takes an unscaled
2304   //  size_t argument instead of an element count.
2305   //
2306   // Arguments for generated stub:
2307   //      from:  R0
2308   //      to:    R1
2309   //      count: R2 byte count, treated as ssize_t, can be zero
2310   //
2311   // Examines the alignment of the operands and dispatches
2312   // to a long, int, short, or byte copy loop.
2313   //
2314   address generate_unsafe_copy(const char* name) {
2315 
2316     const Register R0_from   = R0;      // source array address
2317     const Register R1_to     = R1;      // destination array address
2318     const Register R2_count  = R2;      // elements count
2319 
2320     const Register R3_bits   = R3;      // test copy of low bits
2321 
2322     __ align(CodeEntryAlignment);
2323     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2324     address start = __ pc();
2325     const Register tmp = Rtemp;
2326 
2327     // bump this on entry, not on exit:
2328     inc_counter_np(SharedRuntime::_unsafe_array_copy_ctr, R3, tmp);
2329 
2330     __ orr(R3_bits, R0_from, R1_to);
2331     __ orr(R3_bits, R2_count, R3_bits);
2332 
2333     __ tst(R3_bits, BytesPerLong-1);
2334     __ mov(R2_count,AsmOperand(R2_count,asr,LogBytesPerLong), eq);
2335     __ jump(StubRoutines::_jlong_arraycopy, relocInfo::runtime_call_type, tmp, eq);
2336 
2337     __ tst(R3_bits, BytesPerInt-1);
2338     __ mov(R2_count,AsmOperand(R2_count,asr,LogBytesPerInt), eq);
2339     __ jump(StubRoutines::_jint_arraycopy, relocInfo::runtime_call_type, tmp, eq);
2340 
2341     __ tst(R3_bits, BytesPerShort-1);
2342     __ mov(R2_count,AsmOperand(R2_count,asr,LogBytesPerShort), eq);
2343     __ jump(StubRoutines::_jshort_arraycopy, relocInfo::runtime_call_type, tmp, eq);
2344 
2345     __ jump(StubRoutines::_jbyte_arraycopy, relocInfo::runtime_call_type, tmp);
2346     return start;
2347   }
2348 
2349   // Helper for generating a dynamic type check.
2350   // Smashes only the given temp registers.
2351   void generate_type_check(Register sub_klass,
2352                            Register super_check_offset,
2353                            Register super_klass,
2354                            Register tmp1,
2355                            Register tmp2,
2356                            Register tmp3,
2357                            Label&amp; L_success) {
2358     assert_different_registers(sub_klass, super_check_offset, super_klass, tmp1, tmp2, tmp3);
2359 
2360     BLOCK_COMMENT(&quot;type_check:&quot;);
2361 
2362     // If the pointers are equal, we are done (e.g., String[] elements).
2363 
2364     __ cmp(super_klass, sub_klass);
2365     __ b(L_success, eq); // fast success
2366 
2367 
2368     Label L_loop, L_fail;
2369 
2370     int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2371 
2372     // Check the supertype display:
2373     __ ldr(tmp1, Address(sub_klass, super_check_offset));
2374     __ cmp(tmp1, super_klass);
2375     __ b(L_success, eq);
2376 
2377     __ cmp(super_check_offset, sc_offset);
2378     __ b(L_fail, ne); // failure
2379 
2380     BLOCK_COMMENT(&quot;type_check_slow_path:&quot;);
2381 
2382     // a couple of useful fields in sub_klass:
2383     int ss_offset = in_bytes(Klass::secondary_supers_offset());
2384 
2385     // Do a linear scan of the secondary super-klass chain.
2386 
2387 #ifndef PRODUCT
2388     int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
2389     __ inc_counter((address) pst_counter, tmp1, tmp2);
2390 #endif
2391 
2392     Register scan_temp = tmp1;
2393     Register count_temp = tmp2;
2394 
2395     // We will consult the secondary-super array.
2396     __ ldr(scan_temp, Address(sub_klass, ss_offset));
2397 
2398     Register search_key = super_klass;
2399 
2400     // Load the array length.
2401     __ ldr_s32(count_temp, Address(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes()));
2402     __ add(scan_temp, scan_temp, Array&lt;Klass*&gt;::base_offset_in_bytes());
2403 
2404     __ add(count_temp, count_temp, 1);
2405 
2406     // Top of search loop
2407     __ bind(L_loop);
2408     // Notes:
2409     //  scan_temp starts at the array elements
2410     //  count_temp is 1+size
2411 
2412     __ subs(count_temp, count_temp, 1);
2413     __ b(L_fail, eq); // not found
2414 
2415     // Load next super to check
2416     // In the array of super classes elements are pointer sized.
2417     int element_size = wordSize;
2418     __ ldr(tmp3, Address(scan_temp, element_size, post_indexed));
2419 
2420     // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
2421     __ cmp(tmp3, search_key);
2422 
2423     // A miss means we are NOT a subtype and need to keep looping
2424     __ b(L_loop, ne);
2425 
2426     // Falling out the bottom means we found a hit; we ARE a subtype
2427 
2428     // Success.  Cache the super we found and proceed in triumph.
2429     __ str(super_klass, Address(sub_klass, sc_offset));
2430 
2431     // Jump to success
2432     __ b(L_success);
2433 
2434     // Fall through on failure!
2435     __ bind(L_fail);
2436   }
2437 
2438   //  Generate stub for checked oop copy.
2439   //
2440   // Arguments for generated stub:
2441   //      from:  R0
2442   //      to:    R1
2443   //      count: R2 treated as signed 32-bit int
2444   //      ckoff: R3 (super_check_offset)
2445   //      ckval: R4 (super_klass)
2446   //      ret:   R0 zero for success; (-1^K) where K is partial transfer count (32-bit)
2447   //
2448   address generate_checkcast_copy(const char * name) {
2449     __ align(CodeEntryAlignment);
2450     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2451     address start = __ pc();
2452 
2453     const Register from  = R0;  // source array address
2454     const Register to    = R1;  // destination array address
2455     const Register count = R2;  // elements count
2456 
2457     const Register R3_ckoff  = R3;      // super_check_offset
2458     const Register R4_ckval  = R4;      // super_klass
2459 
2460     const int callee_saved_regs = 4; // LR saved differently
2461 
2462     Label load_element, store_element, do_epilogue, fail;
2463 
2464     BLOCK_COMMENT(&quot;Entry:&quot;);
2465 
2466     __ zap_high_non_significant_bits(R2);
2467 
2468     int pushed = 0;
2469     __ push(LR);
2470     pushed+=1;
2471 
2472     DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST;
2473 
2474     BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2475     bs-&gt;arraycopy_prologue(_masm, decorators, true, to, count, callee_saved_regs);
2476 
2477     const RegisterSet caller_saved_regs = RegisterSet(R4,R6) | RegisterSet(R8,R9) | altFP_7_11;
2478     __ push(caller_saved_regs);
2479     assert(caller_saved_regs.size() == 6, &quot;check the count&quot;);
2480     pushed+=6;
2481 
2482     __ ldr(R4_ckval,Address(SP, wordSize*pushed)); // read the argument that was on the stack
2483 
2484     // Save arguments for barrier generation (after the pre barrier):
2485     // - must be a caller saved register and not LR
2486     // - ARM32: avoid R10 in case RThread is needed
2487     const Register saved_count = altFP_7_11;
2488     __ movs(saved_count, count); // and test count
2489     __ b(load_element,ne);
2490 
2491     // nothing to copy
2492     __ mov(R0, 0);
2493 
2494     __ pop(caller_saved_regs);
2495     __ pop(PC);
2496 
2497     // ======== begin loop ========
2498     // (Loop is rotated; its entry is load_element.)
2499     __ align(OptoLoopAlignment);
2500     __ BIND(store_element);
2501     if (UseCompressedOops) {
2502       __ store_heap_oop(Address(to, BytesPerHeapOop, post_indexed), R5);  // store the oop, changes flags
2503       __ subs_32(count,count,1);
2504     } else {
2505       __ subs_32(count,count,1);
2506       __ str(R5, Address(to, BytesPerHeapOop, post_indexed));             // store the oop
2507     }
2508     __ b(do_epilogue, eq); // count exhausted
2509 
2510     // ======== loop entry is here ========
2511     __ BIND(load_element);
2512     __ load_heap_oop(R5, Address(from, BytesPerHeapOop, post_indexed));  // load the oop
2513     __ cbz(R5, store_element); // NULL
2514 
2515     __ load_klass(R6, R5);
2516 
2517     generate_type_check(R6, R3_ckoff, R4_ckval, /*tmps*/ R12, R8, R9,
2518                         // branch to this on success:
2519                         store_element);
2520     // ======== end loop ========
2521 
2522     // It was a real error; we must depend on the caller to finish the job.
2523     // Register count has number of *remaining* oops, saved_count number of *total* oops.
2524     // Emit GC store barriers for the oops we have copied
2525     // and report their number to the caller (0 or (-1^n))
2526     __ BIND(fail);
2527 
2528     // Note: fail marked by the fact that count differs from saved_count
2529 
2530     __ BIND(do_epilogue);
2531 
2532     Register copied = R4; // saved
2533     Label L_not_copied;
2534 
2535     __ subs_32(copied, saved_count, count); // copied count (in saved reg)
2536     __ b(L_not_copied, eq); // nothing was copied, skip post barrier
2537     __ sub(to, to, AsmOperand(copied, lsl, LogBytesPerHeapOop)); // initial to value
2538     __ mov(R12, copied); // count arg scratched by post barrier
2539 
2540     bs-&gt;arraycopy_epilogue(_masm, decorators, true, to, R12, R3);
2541 
2542     assert_different_registers(R3,R12,LR,copied,saved_count);
2543     inc_counter_np(SharedRuntime::_checkcast_array_copy_ctr, R3, R12);
2544 
2545     __ BIND(L_not_copied);
2546     __ cmp_32(copied, saved_count); // values preserved in saved registers
2547 
2548     __ mov(R0, 0, eq); // 0 if all copied
2549     __ mvn(R0, copied, ne); // else NOT(copied)
2550     __ pop(caller_saved_regs);
2551     __ pop(PC);
2552 
2553     return start;
2554   }
2555 
2556   // Perform range checks on the proposed arraycopy.
2557   // Kills the two temps, but nothing else.
2558   void arraycopy_range_checks(Register src,     // source array oop
2559                               Register src_pos, // source position (32-bit int)
2560                               Register dst,     // destination array oop
2561                               Register dst_pos, // destination position (32-bit int)
2562                               Register length,  // length of copy (32-bit int)
2563                               Register temp1, Register temp2,
2564                               Label&amp; L_failed) {
2565 
2566     BLOCK_COMMENT(&quot;arraycopy_range_checks:&quot;);
2567 
2568     //  if (src_pos + length &gt; arrayOop(src)-&gt;length() ) FAIL;
2569 
2570     const Register array_length = temp1;  // scratch
2571     const Register end_pos      = temp2;  // scratch
2572 
2573     __ add_32(end_pos, length, src_pos);  // src_pos + length
2574     __ ldr_s32(array_length, Address(src, arrayOopDesc::length_offset_in_bytes()));
2575     __ cmp_32(end_pos, array_length);
2576     __ b(L_failed, hi);
2577 
2578     //  if (dst_pos + length &gt; arrayOop(dst)-&gt;length() ) FAIL;
2579     __ add_32(end_pos, length, dst_pos); // dst_pos + length
2580     __ ldr_s32(array_length, Address(dst, arrayOopDesc::length_offset_in_bytes()));
2581     __ cmp_32(end_pos, array_length);
2582     __ b(L_failed, hi);
2583 
2584     BLOCK_COMMENT(&quot;arraycopy_range_checks done&quot;);
2585   }
2586 
2587   //
2588   //  Generate generic array copy stubs
2589   //
2590   //  Input:
2591   //    R0    -  src oop
2592   //    R1    -  src_pos (32-bit int)
2593   //    R2    -  dst oop
2594   //    R3    -  dst_pos (32-bit int)
2595   //    SP[0] -  element count (32-bit int)
2596   //
2597   //  Output: (32-bit int)
2598   //    R0 ==  0  -  success
2599   //    R0 &lt;   0  -  need to call System.arraycopy
2600   //
2601   address generate_generic_copy(const char *name) {
2602     Label L_failed, L_objArray;
2603 
2604     // Input registers
2605     const Register src      = R0;  // source array oop
2606     const Register src_pos  = R1;  // source position
2607     const Register dst      = R2;  // destination array oop
2608     const Register dst_pos  = R3;  // destination position
2609 
2610     // registers used as temp
2611     const Register R5_src_klass = R5; // source array klass
2612     const Register R6_dst_klass = R6; // destination array klass
2613     const Register R_lh         = altFP_7_11; // layout handler
2614     const Register R8_temp      = R8;
2615 
2616     __ align(CodeEntryAlignment);
2617     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2618     address start = __ pc();
2619 
2620     __ zap_high_non_significant_bits(R1);
2621     __ zap_high_non_significant_bits(R3);
2622     __ zap_high_non_significant_bits(R4);
2623 
2624     int pushed = 0;
2625     const RegisterSet saved_regs = RegisterSet(R4,R6) | RegisterSet(R8,R9) | altFP_7_11;
2626     __ push(saved_regs);
2627     assert(saved_regs.size() == 6, &quot;check the count&quot;);
2628     pushed+=6;
2629 
2630     // bump this on entry, not on exit:
2631     inc_counter_np(SharedRuntime::_generic_array_copy_ctr, R5, R12);
2632 
2633     const Register length   = R4;  // elements count
2634     __ ldr(length, Address(SP,4*pushed));
2635 
2636 
2637     //-----------------------------------------------------------------------
2638     // Assembler stubs will be used for this call to arraycopy
2639     // if the following conditions are met:
2640     //
2641     // (1) src and dst must not be null.
2642     // (2) src_pos must not be negative.
2643     // (3) dst_pos must not be negative.
2644     // (4) length  must not be negative.
2645     // (5) src klass and dst klass should be the same and not NULL.
2646     // (6) src and dst should be arrays.
2647     // (7) src_pos + length must not exceed length of src.
2648     // (8) dst_pos + length must not exceed length of dst.
2649     BLOCK_COMMENT(&quot;arraycopy initial argument checks&quot;);
2650 
2651     //  if (src == NULL) return -1;
2652     __ cbz(src, L_failed);
2653 
2654     //  if (src_pos &lt; 0) return -1;
2655     __ cmp_32(src_pos, 0);
2656     __ b(L_failed, lt);
2657 
2658     //  if (dst == NULL) return -1;
2659     __ cbz(dst, L_failed);
2660 
2661     //  if (dst_pos &lt; 0) return -1;
2662     __ cmp_32(dst_pos, 0);
2663     __ b(L_failed, lt);
2664 
2665     //  if (length &lt; 0) return -1;
2666     __ cmp_32(length, 0);
2667     __ b(L_failed, lt);
2668 
2669     BLOCK_COMMENT(&quot;arraycopy argument klass checks&quot;);
2670     //  get src-&gt;klass()
2671     __ load_klass(R5_src_klass, src);
2672 
2673     // Load layout helper
2674     //
2675     //  |array_tag|     | header_size | element_type |     |log2_element_size|
2676     // 32        30    24            16              8     2                 0
2677     //
2678     //   array_tag: typeArray = 0x3, objArray = 0x2, non-array = 0x0
2679     //
2680 
2681     int lh_offset = in_bytes(Klass::layout_helper_offset());
2682     __ ldr_u32(R_lh, Address(R5_src_klass, lh_offset));
2683 
2684     __ load_klass(R6_dst_klass, dst);
2685 
2686     // Handle objArrays completely differently...
2687     juint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2688     __ mov_slow(R8_temp, objArray_lh);
2689     __ cmp_32(R_lh, R8_temp);
2690     __ b(L_objArray,eq);
2691 
2692     //  if (src-&gt;klass() != dst-&gt;klass()) return -1;
2693     __ cmp(R5_src_klass, R6_dst_klass);
2694     __ b(L_failed, ne);
2695 
2696     //  if (!src-&gt;is_Array()) return -1;
2697     __ cmp_32(R_lh, Klass::_lh_neutral_value); // &lt; 0
2698     __ b(L_failed, ge);
2699 
2700     arraycopy_range_checks(src, src_pos, dst, dst_pos, length,
2701                            R8_temp, R6_dst_klass, L_failed);
2702 
2703     {
2704       // TypeArrayKlass
2705       //
2706       // src_addr = (src + array_header_in_bytes()) + (src_pos &lt;&lt; log2elemsize);
2707       // dst_addr = (dst + array_header_in_bytes()) + (dst_pos &lt;&lt; log2elemsize);
2708       //
2709 
2710       const Register R6_offset = R6_dst_klass;    // array offset
2711       const Register R12_elsize = R12;            // log2 element size
2712 
2713       __ logical_shift_right(R6_offset, R_lh, Klass::_lh_header_size_shift);
2714       __ andr(R6_offset, R6_offset, (unsigned int)Klass::_lh_header_size_mask); // array_offset
2715       __ add(src, src, R6_offset);       // src array offset
2716       __ add(dst, dst, R6_offset);       // dst array offset
2717       __ andr(R12_elsize, R_lh, (unsigned int)Klass::_lh_log2_element_size_mask); // log2 element size
2718 
2719       // next registers should be set before the jump to corresponding stub
2720       const Register from     = R0;  // source array address
2721       const Register to       = R1;  // destination array address
2722       const Register count    = R2;  // elements count
2723 
2724       // &#39;from&#39;, &#39;to&#39;, &#39;count&#39; registers should be set in this order
2725       // since they are the same as &#39;src&#39;, &#39;src_pos&#39;, &#39;dst&#39;.
2726 
2727 
2728       BLOCK_COMMENT(&quot;scale indexes to element size&quot;);
2729       __ add(from, src, AsmOperand(src_pos, lsl, R12_elsize));       // src_addr
2730       __ add(to, dst, AsmOperand(dst_pos, lsl, R12_elsize));         // dst_addr
2731 
2732       __ mov(count, length);  // length
2733 
2734       // XXX optim: avoid later push in arraycopy variants ?
2735 
2736       __ pop(saved_regs);
2737 
2738       BLOCK_COMMENT(&quot;choose copy loop based on element size&quot;);
2739       __ cmp(R12_elsize, 0);
2740       __ b(StubRoutines::_jbyte_arraycopy,eq);
2741 
2742       __ cmp(R12_elsize, LogBytesPerShort);
2743       __ b(StubRoutines::_jshort_arraycopy,eq);
2744 
2745       __ cmp(R12_elsize, LogBytesPerInt);
2746       __ b(StubRoutines::_jint_arraycopy,eq);
2747 
2748       __ b(StubRoutines::_jlong_arraycopy);
2749 
2750     }
2751 
2752     // ObjArrayKlass
2753     __ BIND(L_objArray);
2754     // live at this point:  R5_src_klass, R6_dst_klass, src[_pos], dst[_pos], length
2755 
2756     Label L_plain_copy, L_checkcast_copy;
2757     //  test array classes for subtyping
2758     __ cmp(R5_src_klass, R6_dst_klass);         // usual case is exact equality
2759     __ b(L_checkcast_copy, ne);
2760 
2761     BLOCK_COMMENT(&quot;Identically typed arrays&quot;);
2762     {
2763       // Identically typed arrays can be copied without element-wise checks.
2764       arraycopy_range_checks(src, src_pos, dst, dst_pos, length,
2765                              R8_temp, R_lh, L_failed);
2766 
2767       // next registers should be set before the jump to corresponding stub
2768       const Register from     = R0;  // source array address
2769       const Register to       = R1;  // destination array address
2770       const Register count    = R2;  // elements count
2771 
2772       __ add(src, src, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //src offset
2773       __ add(dst, dst, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //dst offset
2774       __ add_ptr_scaled_int32(from, src, src_pos, LogBytesPerHeapOop);         // src_addr
2775       __ add_ptr_scaled_int32(to, dst, dst_pos, LogBytesPerHeapOop);           // dst_addr
2776       __ BIND(L_plain_copy);
2777       __ mov(count, length);
2778 
2779       __ pop(saved_regs); // XXX optim: avoid later push in oop_arraycopy ?
2780       __ b(StubRoutines::_oop_arraycopy);
2781     }
2782 
2783     {
2784       __ BIND(L_checkcast_copy);
2785       // live at this point:  R5_src_klass, R6_dst_klass
2786 
2787       // Before looking at dst.length, make sure dst is also an objArray.
2788       __ ldr_u32(R8_temp, Address(R6_dst_klass, lh_offset));
2789       __ cmp_32(R_lh, R8_temp);
2790       __ b(L_failed, ne);
2791 
2792       // It is safe to examine both src.length and dst.length.
2793 
2794       arraycopy_range_checks(src, src_pos, dst, dst_pos, length,
2795                              R8_temp, R_lh, L_failed);
2796 
2797       // next registers should be set before the jump to corresponding stub
2798       const Register from     = R0;  // source array address
2799       const Register to       = R1;  // destination array address
2800       const Register count    = R2;  // elements count
2801 
2802       // Marshal the base address arguments now, freeing registers.
2803       __ add(src, src, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //src offset
2804       __ add(dst, dst, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //dst offset
2805       __ add_ptr_scaled_int32(from, src, src_pos, LogBytesPerHeapOop);         // src_addr
2806       __ add_ptr_scaled_int32(to, dst, dst_pos, LogBytesPerHeapOop);           // dst_addr
2807 
2808       __ mov(count, length); // length (reloaded)
2809 
2810       Register sco_temp = R3;                   // this register is free now
2811       assert_different_registers(from, to, count, sco_temp,
2812                                  R6_dst_klass, R5_src_klass);
2813 
2814       // Generate the type check.
2815       int sco_offset = in_bytes(Klass::super_check_offset_offset());
2816       __ ldr_u32(sco_temp, Address(R6_dst_klass, sco_offset));
2817       generate_type_check(R5_src_klass, sco_temp, R6_dst_klass,
2818                           R8_temp, R9,
2819                           R12,
2820                           L_plain_copy);
2821 
2822       // Fetch destination element klass from the ObjArrayKlass header.
2823       int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2824 
2825       // the checkcast_copy loop needs two extra arguments:
2826       const Register Rdst_elem_klass = R3;
2827       __ ldr(Rdst_elem_klass, Address(R6_dst_klass, ek_offset));   // dest elem klass
2828       __ pop(saved_regs); // XXX optim: avoid later push in oop_arraycopy ?
2829       __ str(Rdst_elem_klass, Address(SP,0));    // dest elem klass argument
2830       __ ldr_u32(R3, Address(Rdst_elem_klass, sco_offset));  // sco of elem klass
2831       __ b(StubRoutines::_checkcast_arraycopy);
2832     }
2833 
2834     __ BIND(L_failed);
2835 
2836     __ pop(saved_regs);
2837     __ mvn(R0, 0); // failure, with 0 copied
2838     __ ret();
2839 
2840     return start;
2841   }
2842 
2843   // Safefetch stubs.
2844   void generate_safefetch(const char* name, int size, address* entry, address* fault_pc, address* continuation_pc) {
2845     // safefetch signatures:
2846     //   int      SafeFetch32(int*      adr, int      errValue);
2847     //   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);
2848     //
2849     // arguments:
2850     //   R0 = adr
2851     //   R1 = errValue
2852     //
2853     // result:
2854     //   R0  = *adr or errValue
2855 
2856     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2857 
2858     // Entry point, pc or function descriptor.
2859     *entry = __ pc();
2860 
2861     // Load *adr into c_rarg2, may fault.
2862     *fault_pc = __ pc();
2863 
2864     switch (size) {
2865       case 4: // int32_t
2866         __ ldr_s32(R1, Address(R0));
2867         break;
2868 
2869       case 8: // int64_t
2870         Unimplemented();
2871         break;
2872 
2873       default:
2874         ShouldNotReachHere();
2875     }
2876 
2877     // return errValue or *adr
2878     *continuation_pc = __ pc();
2879     __ mov(R0, R1);
2880     __ ret();
2881   }
2882 
2883   void generate_arraycopy_stubs() {
2884 
2885     // Note:  the disjoint stubs must be generated first, some of
2886     //        the conjoint stubs use them.
2887 
2888     bool status = false; // non failing C2 stubs need not return a status in R0
2889 
2890 #ifdef TEST_C2_GENERIC_ARRAYCOPY /* Internal development flag */
2891     // With this flag, the C2 stubs are tested by generating calls to
2892     // generic_arraycopy instead of Runtime1::arraycopy
2893 
2894     // Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)
2895     // and the result is tested to see whether the arraycopy stub should
2896     // be called.
2897 
2898     // When we test arraycopy this way, we must generate extra code in the
2899     // arraycopy methods callable from C2 generic_arraycopy to set the
2900     // status to 0 for those who always succeed (calling the slow path stub might
2901     // lead to errors since the copy has already been performed).
2902 
2903     status = true; // generate a status compatible with C1 calls
2904 #endif
2905 
2906     address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();
2907     UnsafeCopyMemory::set_common_exit_stub_pc(ucm_common_error_exit);
2908 
2909     // these need always status in case they are called from generic_arraycopy
2910     StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jbyte_disjoint_arraycopy&quot;,  true, 1, true);
2911     StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(false, &quot;jshort_disjoint_arraycopy&quot;, true, 2, true);
2912     StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(false, &quot;jint_disjoint_arraycopy&quot;,   true, 4, true);
2913     StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jlong_disjoint_arraycopy&quot;,  true, 8, true);
2914     StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (false, &quot;oop_disjoint_arraycopy&quot;,    true,    true);
2915 
2916     StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jbyte_disjoint_arraycopy&quot;, status, 1, true);
2917     StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(true, &quot;arrayof_jshort_disjoint_arraycopy&quot;,status, 2, true);
2918     StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(true, &quot;arrayof_jint_disjoint_arraycopy&quot;,  status, 4, true);
2919     StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jlong_disjoint_arraycopy&quot;, status, 8, true);
2920     StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (true, &quot;arrayof_oop_disjoint_arraycopy&quot;,   status,    true);
2921 
2922     // these need always status in case they are called from generic_arraycopy
2923     StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(false, &quot;jbyte_arraycopy&quot;,  true, 1, false, StubRoutines::_jbyte_disjoint_arraycopy);
2924     StubRoutines::_jshort_arraycopy = generate_primitive_copy(false, &quot;jshort_arraycopy&quot;, true, 2, false, StubRoutines::_jshort_disjoint_arraycopy);
2925     StubRoutines::_jint_arraycopy   = generate_primitive_copy(false, &quot;jint_arraycopy&quot;,   true, 4, false, StubRoutines::_jint_disjoint_arraycopy);
2926     StubRoutines::_jlong_arraycopy  = generate_primitive_copy(false, &quot;jlong_arraycopy&quot;,  true, 8, false, StubRoutines::_jlong_disjoint_arraycopy);
2927     StubRoutines::_oop_arraycopy    = generate_oop_copy      (false, &quot;oop_arraycopy&quot;,    true,    false, StubRoutines::_oop_disjoint_arraycopy);
2928 
2929     StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(true, &quot;arrayof_jbyte_arraycopy&quot;,  status, 1, false, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);
2930     StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(true, &quot;arrayof_jshort_arraycopy&quot;, status, 2, false, StubRoutines::_arrayof_jshort_disjoint_arraycopy);
2931 #ifdef _LP64
2932     // since sizeof(jint) &lt; sizeof(HeapWord), there&#39;s a different flavor:
2933     StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(true, &quot;arrayof_jint_arraycopy&quot;,   status, 4, false, StubRoutines::_arrayof_jint_disjoint_arraycopy);
2934 #else
2935     StubRoutines::_arrayof_jint_arraycopy     = StubRoutines::_jint_arraycopy;
2936 #endif
2937     if (BytesPerHeapOop &lt; HeapWordSize) {
2938       StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (true, &quot;arrayof_oop_arraycopy&quot;,    status,    false, StubRoutines::_arrayof_oop_disjoint_arraycopy);
2939     } else {
2940       StubRoutines::_arrayof_oop_arraycopy    = StubRoutines::_oop_arraycopy;
2941     }
2942     StubRoutines::_arrayof_jlong_arraycopy    = StubRoutines::_jlong_arraycopy;
2943 
2944     StubRoutines::_checkcast_arraycopy = generate_checkcast_copy(&quot;checkcast_arraycopy&quot;);
2945     StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(&quot;unsafe_arraycopy&quot;);
2946     StubRoutines::_generic_arraycopy   = generate_generic_copy(&quot;generic_arraycopy&quot;);
2947 
2948 
2949   }
2950 
2951 #define COMPILE_CRYPTO
2952 #include &quot;stubRoutinesCrypto_arm.cpp&quot;
2953 
2954  private:
2955 
2956 #undef  __
2957 #define __ masm-&gt;
2958 
2959   //------------------------------------------------------------------------------------------------------------------------
2960   // Continuation point for throwing of implicit exceptions that are not handled in
2961   // the current activation. Fabricates an exception oop and initiates normal
2962   // exception dispatching in this frame.
2963   address generate_throw_exception(const char* name, address runtime_entry) {
2964     int insts_size = 128;
2965     int locs_size  = 32;
2966     CodeBuffer code(name, insts_size, locs_size);
2967     OopMapSet* oop_maps;
2968     int frame_size;
2969     int frame_complete;
2970 
2971     oop_maps = new OopMapSet();
2972     MacroAssembler* masm = new MacroAssembler(&amp;code);
2973 
2974     address start = __ pc();
2975 
2976     frame_size = 2;
2977     __ mov(Rexception_pc, LR);
2978     __ raw_push(FP, LR);
2979 
2980     frame_complete = __ pc() - start;
2981 
2982     // Any extra arguments are already supposed to be R1 and R2
2983     __ mov(R0, Rthread);
2984 
2985     int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);
2986     assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
2987     __ call(runtime_entry);
2988     if (pc_offset == -1) {
2989       pc_offset = __ offset();
2990     }
2991 
2992     // Generate oop map
2993     OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);
2994     oop_maps-&gt;add_gc_map(pc_offset, map);
2995     __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
2996 
2997     __ raw_pop(FP, LR);
2998     __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
2999 
3000     RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &amp;code, frame_complete,
3001                                                       frame_size, oop_maps, false);
3002     return stub-&gt;entry_point();
3003   }
3004 
3005   //---------------------------------------------------------------------------
3006   // Initialization
3007 
3008   void generate_initial() {
3009     // Generates all stubs and initializes the entry points
3010 
3011     //------------------------------------------------------------------------------------------------------------------------
3012     // entry points that exist in all platforms
3013     // Note: This is code that could be shared among different platforms - however the benefit seems to be smaller than
3014     //       the disadvantage of having a much more complicated generator structure. See also comment in stubRoutines.hpp.
3015     StubRoutines::_forward_exception_entry      = generate_forward_exception();
3016 
3017     StubRoutines::_call_stub_entry              =
3018       generate_call_stub(StubRoutines::_call_stub_return_address);
3019     // is referenced by megamorphic call
3020     StubRoutines::_catch_exception_entry        = generate_catch_exception();
3021 
3022     // stub for throwing stack overflow error used both by interpreter and compiler
3023     StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(&quot;StackOverflowError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));
3024 
3025     // integer division used both by interpreter and compiler
3026     StubRoutines::Arm::_idiv_irem_entry = generate_idiv_irem();
3027 
3028     StubRoutines::_atomic_add_entry = generate_atomic_add();
3029     StubRoutines::_atomic_xchg_entry = generate_atomic_xchg();
3030     StubRoutines::_atomic_cmpxchg_entry = generate_atomic_cmpxchg();
3031     StubRoutines::_atomic_cmpxchg_long_entry = generate_atomic_cmpxchg_long();
3032     StubRoutines::_atomic_load_long_entry = generate_atomic_load_long();
3033     StubRoutines::_atomic_store_long_entry = generate_atomic_store_long();
3034   }
3035 
3036   void generate_all() {
3037     // Generates all stubs and initializes the entry points
3038 
3039 #ifdef COMPILER2
3040     // Generate partial_subtype_check first here since its code depends on
3041     // UseZeroBaseCompressedOops which is defined after heap initialization.
3042     StubRoutines::Arm::_partial_subtype_check                = generate_partial_subtype_check();
3043 #endif
3044     // These entry points require SharedInfo::stack0 to be set up in non-core builds
3045     // and need to be relocatable, so they each fabricate a RuntimeStub internally.
3046     StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));
3047     StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));
3048     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));
3049 
3050     //------------------------------------------------------------------------------------------------------------------------
3051     // entry points that are platform specific
3052 
3053     // support for verify_oop (must happen after universe_init)
3054     StubRoutines::_verify_oop_subroutine_entry     = generate_verify_oop();
3055 
3056     // arraycopy stubs used by compilers
3057     generate_arraycopy_stubs();
3058 
3059     // Safefetch stubs.
3060     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int), &amp;StubRoutines::_safefetch32_entry,
3061                                                    &amp;StubRoutines::_safefetch32_fault_pc,
3062                                                    &amp;StubRoutines::_safefetch32_continuation_pc);
3063     assert (sizeof(int) == wordSize, &quot;32-bit architecture&quot;);
3064     StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;
3065     StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;
3066     StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;
3067 
3068 #ifdef COMPILE_CRYPTO
3069     // generate AES intrinsics code
3070     if (UseAESIntrinsics) {
3071       aes_init();
3072       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3073       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3074       StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
3075       StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
3076     }
3077 #endif // COMPILE_CRYPTO
3078   }
3079 
3080 
3081  public:
3082   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3083     if (all) {
3084       generate_all();
3085     } else {
3086       generate_initial();
3087     }
3088   }
3089 }; // end class declaration
3090 
3091 #define UCM_TABLE_MAX_ENTRIES 32
3092 void StubGenerator_generate(CodeBuffer* code, bool all) {
3093   if (UnsafeCopyMemory::_table == NULL) {
3094     UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);
3095   }
3096   StubGenerator g(code, all);
3097 }
    </pre>
  </body>
</html>
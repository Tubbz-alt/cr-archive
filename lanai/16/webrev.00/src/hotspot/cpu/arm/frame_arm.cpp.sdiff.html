<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/frame_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_globals_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/frame_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 40 #include &quot;vmreg_arm.inline.hpp&quot;
 41 #ifdef COMPILER1
 42 #include &quot;c1/c1_Runtime1.hpp&quot;
 43 #include &quot;runtime/vframeArray.hpp&quot;
 44 #endif
 45 #include &quot;prims/methodHandles.hpp&quot;
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49 }
 50 #endif
 51 
 52 
 53 // Profiling/safepoint support
 54 
 55 bool frame::safe_for_sender(JavaThread *thread) {
 56   address   sp = (address)_sp;
 57   address   fp = (address)_fp;
 58   address   unextended_sp = (address)_unextended_sp;
 59 
<span class="line-modified"> 60   static size_t stack_guard_size = os::uses_stack_guard_pages() ?</span>
<span class="line-removed"> 61     (JavaThread::stack_red_zone_size() + JavaThread::stack_yellow_zone_size()) : 0;</span>
<span class="line-removed"> 62   size_t usable_stack_size = thread-&gt;stack_size() - stack_guard_size;</span>
<span class="line-removed"> 63 </span>
 64   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 65   bool sp_safe = (sp != NULL &amp;&amp;</span>
<span class="line-removed"> 66                  (sp &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 67                  (sp &gt;= thread-&gt;stack_base() - usable_stack_size));</span>
<span class="line-removed"> 68 </span>
<span class="line-removed"> 69   if (!sp_safe) {</span>
 70     return false;
 71   }
 72 
<span class="line-modified"> 73   bool unextended_sp_safe = (unextended_sp != NULL &amp;&amp;</span>
<span class="line-removed"> 74                              (unextended_sp &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 75                              (unextended_sp &gt;= sp));</span>
<span class="line-removed"> 76   if (!unextended_sp_safe) {</span>
 77     return false;
 78   }
 79 
 80   // We know sp/unextended_sp are safe. Only fp is questionable here.
 81 
<span class="line-modified"> 82   bool fp_safe = (fp != NULL &amp;&amp;</span>
<span class="line-removed"> 83                   (fp &lt;= thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 84                   fp &gt;= sp);</span>
 85 
 86   if (_cb != NULL ) {
 87 
 88     // First check if frame is complete and tester is reliable
 89     // Unfortunately we can only check frame complete for runtime stubs and nmethod
 90     // other generic buffer blobs are more problematic so we just assume they are
 91     // ok. adapter blobs never have a frame complete and are never ok.
 92 
 93     if (!_cb-&gt;is_frame_complete_at(_pc)) {
 94       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
 95         return false;
 96       }
 97     }
 98 
 99     // Could just be some random pointer within the codeBlob
100     if (!_cb-&gt;code_contains(_pc)) {
101       return false;
102     }
103 
104     // Entry frame checks
</pre>
<hr />
<pre>
108     }
109 
110     intptr_t* sender_sp = NULL;
111     address   sender_pc = NULL;
112 
113     if (is_interpreted_frame()) {
114       // fp must be safe
115       if (!fp_safe) {
116         return false;
117       }
118 
119       sender_pc = (address) this-&gt;fp()[return_addr_offset];
120       sender_sp = (intptr_t*) addr_at(sender_sp_offset);
121 
122     } else {
123       // must be some sort of compiled/runtime frame
124       // fp does not have to be safe (although it could be check for c1?)
125 
126       sender_sp = _unextended_sp + _cb-&gt;frame_size();
127       // Is sender_sp safe?
<span class="line-modified">128       if ((address)sender_sp &gt;= thread-&gt;stack_base()) {</span>
129         return false;
130       }
131       // With our calling conventions, the return_address should
132       // end up being the word on the stack
133       sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);
134     }
135 
136     // We must always be able to find a recognizable pc
137     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
138     if (sender_pc == NULL || sender_blob == NULL) {
139       return false;
140     }
141 
142 
143     // If the potential sender is the interpreter then we can do some more checking
144     if (Interpreter::contains(sender_pc)) {
145 
146       // FP is always saved in a recognizable place in any code we generate. However
147       // only if the sender is interpreted/call_stub (c1 too?) are we certain that the saved FP
148       // is really a frame pointer.
149 
150       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">151       bool saved_fp_safe = ((address)saved_fp &lt;= thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt; sender_sp);</span>
<span class="line-removed">152 </span>
<span class="line-removed">153       if (!saved_fp_safe) {</span>
154         return false;
155       }
156 
157       // construct the potential sender
158 
159       frame sender(sender_sp, saved_fp, sender_pc);
160 
161       return sender.is_interpreted_frame_valid(thread);
162     }
163 
164     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
165       return false;
166     }
167 
168     // Could just be some random pointer within the codeBlob
169     if (!sender_blob-&gt;code_contains(sender_pc)) {
170       return false;
171     }
172 
173     // We should never be able to see an adapter if the current frame is something from code cache
174     if (sender_blob-&gt;is_adapter_blob()) {
175       return false;
176     }
177 
178     // Could be the call_stub
179     if (StubRoutines::returns_to_call_stub(sender_pc)) {
180       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">181       bool saved_fp_safe = ((address)saved_fp &lt;= thread-&gt;stack_base()) &amp;&amp; (saved_fp &gt;= sender_sp);</span>
<span class="line-removed">182 </span>
<span class="line-removed">183       if (!saved_fp_safe) {</span>
184         return false;
185       }
186 
187       // construct the potential sender
188 
189       frame sender(sender_sp, saved_fp, sender_pc);
190 
191       // Validate the JavaCallWrapper an entry frame must have
192       address jcw = (address)sender.entry_frame_call_wrapper();
193 
<span class="line-modified">194       bool jcw_safe = (jcw &lt;= thread-&gt;stack_base()) &amp;&amp; (jcw &gt; (address)sender.fp());</span>
<span class="line-removed">195 </span>
<span class="line-removed">196       return jcw_safe;</span>
197     }
198 
199     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
200     // because the return address counts against the callee&#39;s frame.
201 
202     if (sender_blob-&gt;frame_size() &lt;= 0) {
203       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
204       return false;
205     }
206 
207     // We should never be able to see anything here except an nmethod. If something in the
208     // code cache (current frame) is called by an entity within the code cache that entity
209     // should not be anything but the call stub (already covered), the interpreter (already covered)
210     // or an nmethod.
211 
212     if (!sender_blob-&gt;is_compiled()) {
213       return false;
214     }
215 
216     // Could put some more validation for the potential non-interpreted sender
</pre>
<hr />
<pre>
483   // stack frames shouldn&#39;t be much larger than max_stack elements
484 
485   if (fp() - sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
486     return false;
487   }
488 
489   // validate bci/bcp
490 
491   address bcp = interpreter_frame_bcp();
492   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
493     return false;
494   }
495 
496   // validate ConstantPoolCache*
497   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
498   if (MetaspaceObj::is_valid(cp) == false) return false;
499 
500   // validate locals
501 
502   address locals =  (address) *interpreter_frame_locals_addr();
<span class="line-modified">503 </span>
<span class="line-removed">504   if (locals &gt; thread-&gt;stack_base() || locals &lt; (address) fp()) return false;</span>
<span class="line-removed">505 </span>
<span class="line-removed">506   // We&#39;d have to be pretty unlucky to be mislead at this point</span>
<span class="line-removed">507 </span>
<span class="line-removed">508   return true;</span>
509 }
510 
511 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
512   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
513   Method* method = interpreter_frame_method();
514   BasicType type = method-&gt;result_type();
515 
516   intptr_t* res_addr;
517   if (method-&gt;is_native()) {
518     // Prior to calling into the runtime to report the method_exit both of
519     // the possible return value registers are saved.
520     // Return value registers are pushed to the native stack
521     res_addr = (intptr_t*)sp();
522 #ifdef __ABI_HARD__
523     // FP result is pushed onto a stack along with integer result registers
524     if (type == T_FLOAT || type == T_DOUBLE) {
525       res_addr += 2;
526     }
527 #endif // __ABI_HARD__
528   } else {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 40 #include &quot;vmreg_arm.inline.hpp&quot;
 41 #ifdef COMPILER1
 42 #include &quot;c1/c1_Runtime1.hpp&quot;
 43 #include &quot;runtime/vframeArray.hpp&quot;
 44 #endif
 45 #include &quot;prims/methodHandles.hpp&quot;
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49 }
 50 #endif
 51 
 52 
 53 // Profiling/safepoint support
 54 
 55 bool frame::safe_for_sender(JavaThread *thread) {
 56   address   sp = (address)_sp;
 57   address   fp = (address)_fp;
 58   address   unextended_sp = (address)_unextended_sp;
 59 
<span class="line-modified"> 60   // consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>



 61   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 62   if (!thread-&gt;is_in_usable_stack(sp)) {</span>




 63     return false;
 64   }
 65 
<span class="line-modified"> 66   if (!thread-&gt;is_in_stack_range_incl(unextended_sp, sp)) {</span>



 67     return false;
 68   }
 69 
 70   // We know sp/unextended_sp are safe. Only fp is questionable here.
 71 
<span class="line-modified"> 72   bool fp_safe = thread-&gt;is_in_stack_range_incl(fp, sp);</span>


 73 
 74   if (_cb != NULL ) {
 75 
 76     // First check if frame is complete and tester is reliable
 77     // Unfortunately we can only check frame complete for runtime stubs and nmethod
 78     // other generic buffer blobs are more problematic so we just assume they are
 79     // ok. adapter blobs never have a frame complete and are never ok.
 80 
 81     if (!_cb-&gt;is_frame_complete_at(_pc)) {
 82       if (_cb-&gt;is_compiled() || _cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
 83         return false;
 84       }
 85     }
 86 
 87     // Could just be some random pointer within the codeBlob
 88     if (!_cb-&gt;code_contains(_pc)) {
 89       return false;
 90     }
 91 
 92     // Entry frame checks
</pre>
<hr />
<pre>
 96     }
 97 
 98     intptr_t* sender_sp = NULL;
 99     address   sender_pc = NULL;
100 
101     if (is_interpreted_frame()) {
102       // fp must be safe
103       if (!fp_safe) {
104         return false;
105       }
106 
107       sender_pc = (address) this-&gt;fp()[return_addr_offset];
108       sender_sp = (intptr_t*) addr_at(sender_sp_offset);
109 
110     } else {
111       // must be some sort of compiled/runtime frame
112       // fp does not have to be safe (although it could be check for c1?)
113 
114       sender_sp = _unextended_sp + _cb-&gt;frame_size();
115       // Is sender_sp safe?
<span class="line-modified">116       if (!thread-&gt;is_in_full_stack((address)sender_sp)) {</span>
117         return false;
118       }
119       // With our calling conventions, the return_address should
120       // end up being the word on the stack
121       sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);
122     }
123 
124     // We must always be able to find a recognizable pc
125     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
126     if (sender_pc == NULL || sender_blob == NULL) {
127       return false;
128     }
129 
130 
131     // If the potential sender is the interpreter then we can do some more checking
132     if (Interpreter::contains(sender_pc)) {
133 
134       // FP is always saved in a recognizable place in any code we generate. However
135       // only if the sender is interpreted/call_stub (c1 too?) are we certain that the saved FP
136       // is really a frame pointer.
137 
138       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">139       if (!thread-&gt;is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {</span>


140         return false;
141       }
142 
143       // construct the potential sender
144 
145       frame sender(sender_sp, saved_fp, sender_pc);
146 
147       return sender.is_interpreted_frame_valid(thread);
148     }
149 
150     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
151       return false;
152     }
153 
154     // Could just be some random pointer within the codeBlob
155     if (!sender_blob-&gt;code_contains(sender_pc)) {
156       return false;
157     }
158 
159     // We should never be able to see an adapter if the current frame is something from code cache
160     if (sender_blob-&gt;is_adapter_blob()) {
161       return false;
162     }
163 
164     // Could be the call_stub
165     if (StubRoutines::returns_to_call_stub(sender_pc)) {
166       intptr_t *saved_fp = (intptr_t*)*(sender_sp - frame::sender_sp_offset + link_offset);
<span class="line-modified">167       if (!thread-&gt;is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {</span>


168         return false;
169       }
170 
171       // construct the potential sender
172 
173       frame sender(sender_sp, saved_fp, sender_pc);
174 
175       // Validate the JavaCallWrapper an entry frame must have
176       address jcw = (address)sender.entry_frame_call_wrapper();
177 
<span class="line-modified">178       return thread-&gt;is_in_stack_range_excl(jcw, (address)sender.fp());</span>


179     }
180 
181     // If the frame size is 0 something (or less) is bad because every nmethod has a non-zero frame size
182     // because the return address counts against the callee&#39;s frame.
183 
184     if (sender_blob-&gt;frame_size() &lt;= 0) {
185       assert(!sender_blob-&gt;is_compiled(), &quot;should count return address at least&quot;);
186       return false;
187     }
188 
189     // We should never be able to see anything here except an nmethod. If something in the
190     // code cache (current frame) is called by an entity within the code cache that entity
191     // should not be anything but the call stub (already covered), the interpreter (already covered)
192     // or an nmethod.
193 
194     if (!sender_blob-&gt;is_compiled()) {
195       return false;
196     }
197 
198     // Could put some more validation for the potential non-interpreted sender
</pre>
<hr />
<pre>
465   // stack frames shouldn&#39;t be much larger than max_stack elements
466 
467   if (fp() - sp() &gt; 1024 + m-&gt;max_stack()*Interpreter::stackElementSize) {
468     return false;
469   }
470 
471   // validate bci/bcp
472 
473   address bcp = interpreter_frame_bcp();
474   if (m-&gt;validate_bci_from_bcp(bcp) &lt; 0) {
475     return false;
476   }
477 
478   // validate ConstantPoolCache*
479   ConstantPoolCache* cp = *interpreter_frame_cache_addr();
480   if (MetaspaceObj::is_valid(cp) == false) return false;
481 
482   // validate locals
483 
484   address locals =  (address) *interpreter_frame_locals_addr();
<span class="line-modified">485   return thread-&gt;is_in_stack_range_incl(locals, (address)fp());</span>





486 }
487 
488 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
489   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
490   Method* method = interpreter_frame_method();
491   BasicType type = method-&gt;result_type();
492 
493   intptr_t* res_addr;
494   if (method-&gt;is_native()) {
495     // Prior to calling into the runtime to report the method_exit both of
496     // the possible return value registers are saved.
497     // Return value registers are pushed to the native stack
498     res_addr = (intptr_t*)sp();
499 #ifdef __ABI_HARD__
500     // FP result is pushed onto a stack along with integer result registers
501     if (type == T_FLOAT || type == T_DOUBLE) {
502       res_addr += 2;
503     }
504 #endif // __ABI_HARD__
505   } else {
</pre>
</td>
</tr>
</table>
<center><a href="c1_globals_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
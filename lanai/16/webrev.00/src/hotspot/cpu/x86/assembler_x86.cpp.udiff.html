<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../sparc/vm_version_sparc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -246,38 +246,34 @@</span>
  void Assembler::emit_arith_b(int op1, int op2, Register dst, int imm8) {
    assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;);
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert(isByte(imm8), &quot;not a byte&quot;);
    assert((op1 &amp; 0x01) == 0, &quot;should be 8bit operation&quot;);
<span class="udiff-line-modified-removed">-   emit_int8(op1);</span>
<span class="udiff-line-removed">-   emit_int8(op2 | encode(dst));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(op1, (op2 | encode(dst)), imm8);</span>
  }
  
  
  void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
    assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
    if (is8bit(imm32)) {
<span class="udiff-line-modified-removed">-     emit_int8(op1 | 0x02); // set sign bit</span>
<span class="udiff-line-modified-removed">-     emit_int8(op2 | encode(dst));</span>
<span class="udiff-line-modified-removed">-     emit_int8(imm32 &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+     emit_int24(op1 | 0x02,        // set sign bit</span>
<span class="udiff-line-modified-added">+                op2 | encode(dst),</span>
<span class="udiff-line-modified-added">+                imm32 &amp; 0xFF);</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8(op1);</span>
<span class="udiff-line-removed">-     emit_int8(op2 | encode(dst));</span>
<span class="udiff-line-modified-added">+     emit_int16(op1, (op2 | encode(dst)));</span>
      emit_int32(imm32);
    }
  }
  
  // Force generation of a 4 byte immediate value even if it fits into 8bit
  void Assembler::emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
    assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
<span class="udiff-line-modified-removed">-   emit_int8(op1);</span>
<span class="udiff-line-removed">-   emit_int8(op2 | encode(dst));</span>
<span class="udiff-line-modified-added">+   emit_int16(op1, (op2 | encode(dst)));</span>
    emit_int32(imm32);
  }
  
  // immediate-to-memory forms
  void Assembler::emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -295,12 +291,11 @@</span>
  }
  
  
  void Assembler::emit_arith(int op1, int op2, Register dst, Register src) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
<span class="udiff-line-modified-removed">-   emit_int8(op1);</span>
<span class="udiff-line-removed">-   emit_int8(op2 | encode(dst) &lt;&lt; 3 | encode(src));</span>
<span class="udiff-line-modified-added">+   emit_int16(op1, (op2 | encode(dst) &lt;&lt; 3 | encode(src)));</span>
  }
  
  
  bool Assembler::query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
                                             int cur_tuple_type, int in_size_in_bits, int cur_encoding) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -478,77 +473,75 @@</span>
  
  void Assembler::emit_operand(Register reg, Register base, Register index,
                               Address::ScaleFactor scale, int disp,
                               RelocationHolder const&amp; rspec,
                               int rip_relative_correction) {
<span class="udiff-line-modified-removed">-   relocInfo::relocType rtype = (relocInfo::relocType) rspec.type();</span>
<span class="udiff-line-modified-added">+   bool no_relocation = (rspec.type() == relocInfo::none);</span>
  
    // Encode the registers as needed in the fields they are used in
<span class="udiff-line-removed">- </span>
    int regenc = encode(reg) &lt;&lt; 3;
<span class="udiff-line-removed">-   int indexenc = index-&gt;is_valid() ? encode(index) &lt;&lt; 3 : 0;</span>
<span class="udiff-line-removed">-   int baseenc = base-&gt;is_valid() ? encode(base) : 0;</span>
<span class="udiff-line-removed">- </span>
    if (base-&gt;is_valid()) {
<span class="udiff-line-added">+     int baseenc = encode(base);</span>
      if (index-&gt;is_valid()) {
        assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
        // [base + index*scale + disp]
<span class="udiff-line-modified-removed">-       if (disp == 0 &amp;&amp; rtype == relocInfo::none  &amp;&amp;</span>
<span class="udiff-line-modified-added">+       int indexenc = encode(index) &lt;&lt; 3;</span>
<span class="udiff-line-added">+       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
            base != rbp LP64_ONLY(&amp;&amp; base != r13)) {
          // [base + index*scale]
          // [00 reg 100][ss index base]
          assert(index != rsp, &quot;illegal addressing mode&quot;);
<span class="udiff-line-modified-removed">-         emit_int8(0x04 | regenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
<span class="udiff-line-modified-removed">-       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
<span class="udiff-line-modified-added">+         emit_int16((0x04 | regenc),</span>
<span class="udiff-line-modified-added">+                    (scale &lt;&lt; 6 | indexenc | baseenc));</span>
<span class="udiff-line-modified-added">+       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
          // [base + index*scale + imm8]
          // [01 reg 100][ss index base] imm8
          assert(index != rsp, &quot;illegal addressing mode&quot;);
<span class="udiff-line-modified-removed">-         emit_int8(0x44 | regenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(disp &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+         emit_int24(0x44 | regenc,</span>
<span class="udiff-line-modified-added">+                    scale &lt;&lt; 6 | indexenc | baseenc,</span>
<span class="udiff-line-modified-added">+                    disp &amp; 0xFF);</span>
        } else {
          // [base + index*scale + disp32]
          // [10 reg 100][ss index base] disp32
          assert(index != rsp, &quot;illegal addressing mode&quot;);
<span class="udiff-line-modified-removed">-         emit_int8(0x84 | regenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
<span class="udiff-line-modified-added">+         emit_int16(0x84 | regenc,</span>
<span class="udiff-line-modified-added">+                    scale &lt;&lt; 6 | indexenc | baseenc);</span>
          emit_data(disp, rspec, disp32_operand);
        }
      } else if (base == rsp LP64_ONLY(|| base == r12)) {
        // [rsp + disp]
<span class="udiff-line-modified-removed">-       if (disp == 0 &amp;&amp; rtype == relocInfo::none) {</span>
<span class="udiff-line-modified-added">+       if (disp == 0 &amp;&amp; no_relocation) {</span>
          // [rsp]
          // [00 reg 100][00 100 100]
<span class="udiff-line-modified-removed">-         emit_int8(0x04 | regenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(0x24);</span>
<span class="udiff-line-modified-removed">-       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
<span class="udiff-line-modified-added">+         emit_int16(0x04 | regenc,</span>
<span class="udiff-line-modified-added">+                    0x24);</span>
<span class="udiff-line-modified-added">+       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
          // [rsp + imm8]
          // [01 reg 100][00 100 100] disp8
<span class="udiff-line-modified-removed">-         emit_int8(0x44 | regenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(0x24);</span>
<span class="udiff-line-modified-removed">-         emit_int8(disp &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+         emit_int24(0x44 | regenc,</span>
<span class="udiff-line-modified-added">+                    0x24,</span>
<span class="udiff-line-modified-added">+                    disp &amp; 0xFF);</span>
        } else {
          // [rsp + imm32]
          // [10 reg 100][00 100 100] disp32
<span class="udiff-line-modified-removed">-         emit_int8(0x84 | regenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(0x24);</span>
<span class="udiff-line-modified-added">+         emit_int16(0x84 | regenc,</span>
<span class="udiff-line-modified-added">+                    0x24);</span>
          emit_data(disp, rspec, disp32_operand);
        }
      } else {
        // [base + disp]
        assert(base != rsp LP64_ONLY(&amp;&amp; base != r12), &quot;illegal addressing mode&quot;);
<span class="udiff-line-modified-removed">-       if (disp == 0 &amp;&amp; rtype == relocInfo::none &amp;&amp;</span>
<span class="udiff-line-modified-added">+       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
            base != rbp LP64_ONLY(&amp;&amp; base != r13)) {
          // [base]
          // [00 reg base]
          emit_int8(0x00 | regenc | baseenc);
<span class="udiff-line-modified-removed">-       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
<span class="udiff-line-modified-added">+       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
          // [base + disp8]
          // [01 reg base] disp8
<span class="udiff-line-modified-removed">-         emit_int8(0x40 | regenc | baseenc);</span>
<span class="udiff-line-modified-removed">-         emit_int8(disp &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+         emit_int16(0x40 | regenc | baseenc,</span>
<span class="udiff-line-modified-added">+                    disp &amp; 0xFF);</span>
        } else {
          // [base + disp32]
          // [10 reg base] disp32
          emit_int8(0x80 | regenc | baseenc);
          emit_data(disp, rspec, disp32_operand);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -558,14 +551,14 @@</span>
      if (index-&gt;is_valid()) {
        assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
        // [index*scale + disp]
        // [00 reg 100][ss index 101] disp32
        assert(index != rsp, &quot;illegal addressing mode&quot;);
<span class="udiff-line-modified-removed">-       emit_int8(0x04 | regenc);</span>
<span class="udiff-line-modified-removed">-       emit_int8(scale &lt;&lt; 6 | indexenc | 0x05);</span>
<span class="udiff-line-modified-added">+       emit_int16(0x04 | regenc,</span>
<span class="udiff-line-modified-added">+                  scale &lt;&lt; 6 | (encode(index) &lt;&lt; 3) | 0x05);</span>
        emit_data(disp, rspec, disp32_operand);
<span class="udiff-line-modified-removed">-     } else if (rtype != relocInfo::none ) {</span>
<span class="udiff-line-modified-added">+     } else if (!no_relocation) {</span>
        // [disp] (64bit) RIP-RELATIVE (32bit) abs
        // [00 000 101] disp32
  
        emit_int8(0x05 | regenc);
        // Note that the RIP-rel. correction applies to the generated
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -585,12 +578,12 @@</span>
  
      } else {
        // 32bit never did this, did everything as the rip-rel/disp code above
        // [disp] ABSOLUTE
        // [00 reg 100][00 100 101] disp32
<span class="udiff-line-modified-removed">-       emit_int8(0x04 | regenc);</span>
<span class="udiff-line-modified-removed">-       emit_int8(0x25);</span>
<span class="udiff-line-modified-added">+       emit_int16(0x04 | regenc,</span>
<span class="udiff-line-modified-added">+                  0x25);</span>
        emit_data(disp, rspec, disp32_operand);
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1146,12 +1139,11 @@</span>
  
  
  void Assembler::emit_farith(int b1, int b2, int i) {
    assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);
    assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);
<span class="udiff-line-modified-removed">-   emit_int8(b1);</span>
<span class="udiff-line-removed">-   emit_int8(b2 + i);</span>
<span class="udiff-line-modified-added">+   emit_int16(b1, b2 + i);</span>
  }
  
  
  // Now the Assembler instructions (identical for 32/64 bits)
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1233,54 +1225,53 @@</span>
  }
  
  void Assembler::addr_nop_4() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 4 bytes: NOP DWORD PTR [EAX+0]
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x1F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x40); // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0);    // 8-bits offset (1 byte)</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F,</span>
<span class="udiff-line-modified-added">+              0x1F,</span>
<span class="udiff-line-modified-added">+              0x40, // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);</span>
<span class="udiff-line-modified-added">+              0);   // 8-bits offset (1 byte)</span>
  }
  
  void Assembler::addr_nop_5() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x1F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x44); // emit_rm(cbuf, 0x1, EAX_enc, 0x4);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0);    // 8-bits offset (1 byte)</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F,</span>
<span class="udiff-line-modified-added">+              0x1F,</span>
<span class="udiff-line-modified-added">+              0x44,  // emit_rm(cbuf, 0x1, EAX_enc, 0x4);</span>
<span class="udiff-line-modified-added">+              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="udiff-line-modified-added">+   emit_int8(0);     // 8-bits offset (1 byte)</span>
  }
  
  void Assembler::addr_nop_7() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x1F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x80);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F,</span>
<span class="udiff-line-modified-added">+              0x1F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0x80);</span>
                     // emit_rm(cbuf, 0x2, EAX_enc, EAX_enc);
    emit_int32(0);   // 32-bits offset (4 bytes)
  }
  
  void Assembler::addr_nop_8() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x1F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x84);</span>
<span class="udiff-line-modified-removed">-                    // emit_rm(cbuf, 0x2, EAX_enc, 0x4);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="udiff-line-modified-removed">-   emit_int32(0);   // 32-bits offset (4 bytes)</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F,</span>
<span class="udiff-line-modified-added">+              0x1F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0x84,</span>
<span class="udiff-line-modified-added">+                     // emit_rm(cbuf, 0x2, EAX_enc, 0x4);</span>
<span class="udiff-line-modified-added">+              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="udiff-line-modified-added">+   emit_int32(0);    // 32-bits offset (4 bytes)</span>
  }
  
  void Assembler::addsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::addsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1294,12 +1285,11 @@</span>
  
  void Assembler::addss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::addss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1321,21 +1311,19 @@</span>
  
  void Assembler::aesdec(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDE);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>
  }
  
  void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>
  }
  
  
  void Assembler::aesdeclast(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1348,21 +1336,19 @@</span>
  
  void Assembler::aesdeclast(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  void Assembler::aesenc(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1374,21 +1360,19 @@</span>
  
  void Assembler::aesenc(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDC);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDC, 0xC0 | encode);</span>
  }
  
  void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDC, (0xC0 | encode));</span>
  }
  
  void Assembler::aesenclast(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1400,21 +1384,19 @@</span>
  
  void Assembler::aesenclast(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>
  }
  
  void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>
  }
  
  void Assembler::andl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1442,12 +1424,11 @@</span>
  
  void Assembler::andnl(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::andnl(Register dst, Register src1, Address src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1457,34 +1438,32 @@</span>
    emit_operand(dst, src2);
  }
  
  void Assembler::bsfl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xBC);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xBC,</span>
<span class="udiff-line-modified-added">+              0xC0 | encode);</span>
  }
  
  void Assembler::bsrl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xBD);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xBD,</span>
<span class="udiff-line-modified-added">+              0xC0 | encode);</span>
  }
  
  void Assembler::bswapl(Register reg) { // bswap
    int encode = prefix_and_encode(reg-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (0xC8 | encode));</span>
  }
  
  void Assembler::blsil(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsil(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1496,12 +1475,12 @@</span>
  
  void Assembler::blsmskl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3,</span>
<span class="udiff-line-modified-added">+              0xC0 | encode);</span>
  }
  
  void Assembler::blsmskl(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1513,12 +1492,11 @@</span>
  
  void Assembler::blsrl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsrl(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1550,12 +1528,11 @@</span>
    }
  }
  
  void Assembler::call(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFF, (0xD0 | encode));</span>
  }
  
  
  void Assembler::call(Address adr) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1586,21 +1563,20 @@</span>
  }
  
  void Assembler::cmovl(Condition cc, Register dst, Register src) {
    NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x40 | cc);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F,</span>
<span class="udiff-line-modified-added">+              0x40 | cc,</span>
<span class="udiff-line-modified-added">+              0xC0 | encode);</span>
  }
  
  
  void Assembler::cmovl(Condition cc, Register dst, Address src) {
    NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x40 | cc);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (0x40 | cc));</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpb(Address dst, int imm8) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1629,42 +1605,39 @@</span>
  }
  
  void Assembler::cmpl(Register dst, Address  src) {
    InstructionMark im(this);
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x3B);</span>
<span class="udiff-line-modified-added">+   emit_int8(0x3B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpw(Address dst, int imm16) {
    InstructionMark im(this);
    assert(!dst.base_needs_rex() &amp;&amp; !dst.index_needs_rex(), &quot;no extended registers&quot;);
<span class="udiff-line-modified-removed">-   emit_int8(0x66);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x81);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x66, (unsigned char)0x81);</span>
    emit_operand(rdi, dst, 2);
    emit_int16(imm16);
  }
  
  // The 32-bit cmpxchg compares the value at adr with the contents of rax,
  // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
  // The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchgl(Register reg, Address adr) { // cmpxchg
    InstructionMark im(this);
    prefix(adr, reg);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB1);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xB1);</span>
    emit_operand(reg, adr);
  }
  
  // The 8-bit cmpxchg compares the value at adr with the contents of rax,
  // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
  // The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchgb(Register reg, Address adr) { // cmpxchg
    InstructionMark im(this);
    prefix(adr, reg, true);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB0);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xB0);</span>
    emit_operand(reg, adr);
  }
  
  void Assembler::comisd(XMMRegister dst, Address src) {
    // NOTE: dbx seems to decode this as comiss even though the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1682,12 +1655,11 @@</span>
  void Assembler::comisd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2F, (0xC0 | encode));</span>
  }
  
  void Assembler::comiss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1700,17 +1672,15 @@</span>
  
  void Assembler::comiss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2F, (0xC0 | encode));</span>
  }
  
  void Assembler::cpuid() {
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xA2);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xA2);</span>
  }
  
  // Opcode / Instruction                      Op /  En  64 - Bit Mode     Compat / Leg Mode Description                  Implemented
  // F2 0F 38 F0 / r       CRC32 r32, r / m8   RM        Valid             Valid             Accumulate CRC32 on r / m8.  v
  // F2 REX 0F 38 F0 / r   CRC32 r32, r / m8*  RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1724,11 +1694,11 @@</span>
  void Assembler::crc32(Register crc, Register v, int8_t sizeInBytes) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    int8_t w = 0x01;
    Prefix p = Prefix_EMPTY;
  
<span class="udiff-line-modified-removed">-   emit_int8((int8_t)0xF2);</span>
<span class="udiff-line-modified-added">+   emit_int8((unsigned char)0xF2);</span>
    switch (sizeInBytes) {
    case 1:
      w = 0;
      break;
    case 2:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1753,14 +1723,14 @@</span>
    default:
      assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
      break;
    }
    LP64_ONLY(prefix(crc, v, p);)
<span class="udiff-line-modified-removed">-   emit_int8((int8_t)0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x38);</span>
<span class="udiff-line-modified-removed">-   emit_int8((int8_t)(0xF0 | w));</span>
<span class="udiff-line-modified-removed">-   emit_int8(0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F,</span>
<span class="udiff-line-modified-added">+              0x38,</span>
<span class="udiff-line-modified-added">+              0xF0 | w,</span>
<span class="udiff-line-modified-added">+              0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));</span>
  }
  
  void Assembler::crc32(Register crc, Address adr, int8_t sizeInBytes) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1782,39 +1752,34 @@</span>
    default:
      assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
      break;
    }
    LP64_ONLY(prefix(crc, adr, p);)
<span class="udiff-line-modified-removed">-   emit_int8((int8_t)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x38);</span>
<span class="udiff-line-removed">-   emit_int8((int8_t)(0xF0 | w));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, 0x38, (0xF0 | w));</span>
    emit_operand(crc, adr);
  }
  
  void Assembler::cvtdq2pd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xE6);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtdq2ps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5B, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsd2ss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1828,12 +1793,11 @@</span>
  
  void Assembler::cvtsi2sdl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2sdl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1846,12 +1810,11 @@</span>
  
  void Assembler::cvtsi2ssl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2ssl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1864,20 +1827,18 @@</span>
  
  void Assembler::cvtsi2ssq(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtss2sd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1891,92 +1852,82 @@</span>
  
  void Assembler::cvttsd2sil(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::cvttss2sil(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::cvttpd2dq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xE6);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>
  }
  
  void Assembler::pabsb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x1C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x1C, (0xC0 | encode));</span>
  }
  
  void Assembler::pabsw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x1D);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x1D, (0xC0 | encode));</span>
  }
  
  void Assembler::pabsd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x1E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x1E, (0xC0 | encode));</span>
  }
  
  void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x1C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x1C, (0xC0 | encode));</span>
  }
  
  void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x1D);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x1D, (0xC0 | encode));</span>
  }
  
  void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x1E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x1E, (0xC0 | encode));</span>
  }
  
  void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x1F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x1F, (0xC0 | encode));</span>
  }
  
  void Assembler::decl(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1999,12 +1950,11 @@</span>
  void Assembler::divsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::divss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2017,68 +1967,59 @@</span>
  
  void Assembler::divss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::emms() {
    NOT_LP64(assert(VM_Version::supports_mmx(), &quot;&quot;));
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x77);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x77);</span>
  }
  
  void Assembler::hlt() {
    emit_int8((unsigned char)0xF4);
  }
  
  void Assembler::idivl(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>
  }
  
  void Assembler::divl(Register src) { // Unsigned
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xF0 | encode));</span>
  }
  
  void Assembler::imull(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xE8 | encode));</span>
  }
  
  void Assembler::imull(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xAF);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xAF,</span>
<span class="udiff-line-modified-added">+              (0xC0 | encode));</span>
  }
  
  
  void Assembler::imull(Register dst, Register src, int value) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    if (is8bit(value)) {
<span class="udiff-line-modified-removed">-     emit_int8(0x6B);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(value &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+     emit_int24(0x6B, (0xC0 | encode), value &amp; 0xFF);</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8(0x69);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16(0x69, (0xC0 | encode));</span>
      emit_int32(value);
    }
  }
  
  void Assembler::imull(Register dst, Address src) {
    InstructionMark im(this);
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char) 0xAF);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xAF);</span>
    emit_operand(dst, src);
  }
  
  
  void Assembler::incl(Address dst) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2099,28 +2040,25 @@</span>
      const int short_size = 2;
      const int long_size = 6;
      intptr_t offs = (intptr_t)dst - (intptr_t)pc();
      if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
        // 0111 tttn #8-bit disp
<span class="udiff-line-modified-removed">-       emit_int8(0x70 | cc);</span>
<span class="udiff-line-removed">-       emit_int8((offs - short_size) &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+       emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>
      } else {
        // 0000 1111 1000 tttn #32-bit disp
        assert(is_simm32(offs - long_size),
               &quot;must be 32bit offset (call4)&quot;);
<span class="udiff-line-modified-removed">-       emit_int8(0x0F);</span>
<span class="udiff-line-removed">-       emit_int8((unsigned char)(0x80 | cc));</span>
<span class="udiff-line-modified-added">+       emit_int16(0x0F, (0x80 | cc));</span>
        emit_int32(offs - long_size);
      }
    } else {
      // Note: could eliminate cond. jumps to this jump if condition
      //       is the same however, seems to be rather unlikely case.
      // Note: use jccb() if label to be bound is very close to get
      //       an 8-bit displacement
      L.add_patch_at(code(), locator());
<span class="udiff-line-modified-removed">-     emit_int8(0x0F);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0x80 | cc));</span>
<span class="udiff-line-modified-added">+     emit_int16(0x0F, (0x80 | cc));</span>
      emit_int32(0);
    }
  }
  
  void Assembler::jccb_0(Condition cc, Label&amp; L, const char* file, int line) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2135,17 +2073,15 @@</span>
      }
      assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
  #endif
      intptr_t offs = (intptr_t)entry - (intptr_t)pc();
      // 0111 tttn #8-bit disp
<span class="udiff-line-modified-removed">-     emit_int8(0x70 | cc);</span>
<span class="udiff-line-removed">-     emit_int8((offs - short_size) &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+     emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>
    } else {
      InstructionMark im(this);
      L.add_patch_at(code(), locator(), file, line);
<span class="udiff-line-modified-removed">-     emit_int8(0x70 | cc);</span>
<span class="udiff-line-removed">-     emit_int8(0);</span>
<span class="udiff-line-modified-added">+     emit_int16(0x70 | cc, 0);</span>
    }
  }
  
  void Assembler::jmp(Address adr) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2161,12 +2097,11 @@</span>
      InstructionMark im(this);
      const int short_size = 2;
      const int long_size = 5;
      intptr_t offs = entry - pc();
      if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
<span class="udiff-line-modified-removed">-       emit_int8((unsigned char)0xEB);</span>
<span class="udiff-line-removed">-       emit_int8((offs - short_size) &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+       emit_int16((unsigned char)0xEB, ((offs - short_size) &amp; 0xFF));</span>
      } else {
        emit_int8((unsigned char)0xE9);
        emit_int32(offs - long_size);
      }
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2181,12 +2116,11 @@</span>
    }
  }
  
  void Assembler::jmp(Register entry) {
    int encode = prefix_and_encode(entry-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFF, (0xE0 | encode));</span>
  }
  
  void Assembler::jmp_literal(address dest, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xE9);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2208,17 +2142,15 @@</span>
        dist += (dist &lt; 0 ? (-delta) :delta);
      }
      assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
  #endif
      intptr_t offs = entry - pc();
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xEB);</span>
<span class="udiff-line-removed">-     emit_int8((offs - short_size) &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xEB, (offs - short_size) &amp; 0xFF);</span>
    } else {
      InstructionMark im(this);
      L.add_patch_at(code(), locator(), file, line);
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xEB);</span>
<span class="udiff-line-removed">-     emit_int8(0);</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xEB, 0);</span>
    }
  }
  
  void Assembler::ldmxcsr( Address src) {
    if (UseAVX &gt; 0 ) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2229,12 +2161,11 @@</span>
      emit_operand(as_Register(2), src);
    } else {
      NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
      InstructionMark im(this);
      prefix(src);
<span class="udiff-line-modified-removed">-     emit_int8(0x0F);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+     emit_int16(0x0F, (unsigned char)0xAE);</span>
      emit_operand(as_Register(2), src);
    }
  }
  
  void Assembler::leal(Register dst, Address src) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2246,42 +2177,34 @@</span>
    emit_int8((unsigned char)0x8D);
    emit_operand(dst, src);
  }
  
  void Assembler::lfence() {
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xE8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xE8);</span>
  }
  
  void Assembler::lock() {
    emit_int8((unsigned char)0xF0);
  }
  
  void Assembler::lzcntl(Register dst, Register src) {
    assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>
  }
  
  // Emit mfence instruction
  void Assembler::mfence() {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF0);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF0);</span>
  }
  
  // Emit sfence instruction
  void Assembler::sfence() {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF8);</span>
  }
  
  void Assembler::mov(Register dst, Register src) {
    LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2290,29 +2213,26 @@</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x28);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x28, (0xC0 | encode));</span>
  }
  
  void Assembler::movaps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x28);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x28, (0xC0 | encode));</span>
  }
  
  void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x16);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x16, (0xC0 | encode));</span>
  }
  
  void Assembler::movb(Register dst, Address src) {
    NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2325,44 +2245,39 @@</span>
    NOT_LP64(assert(VM_Version::supports_sse3(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x12);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x12, 0xC0 | encode);</span>
  }
  
  void Assembler::kmovbl(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x92);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovbl(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x93);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(KRegister dst, Register src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x92);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(Register dst, KRegister src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x93);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(KRegister dst, Address src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2374,28 +2289,25 @@</span>
  
  void Assembler::kmovdl(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x92);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovdl(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x93);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(KRegister dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x90, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(KRegister dst, Address src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2416,89 +2328,79 @@</span>
  
  void Assembler::kmovql(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x92);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x93);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::knotwl(KRegister dst, KRegister src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x44);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x44, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestbl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x98);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestwl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x98);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestdl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x98);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestql(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x98);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::ktestql(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x99);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>
  }
  
  void Assembler::ktestq(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x99);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>
  }
  
  void Assembler::ktestd(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x99);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>
  }
  
  void Assembler::movb(Address dst, int imm8) {
    InstructionMark im(this);
     prefix(dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2518,21 +2420,19 @@</span>
  
  void Assembler::movdl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6E, (0xC0 | encode));</span>
  }
  
  void Assembler::movdl(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    // swap src/dst to get correct prefix
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x7E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x7E, (0xC0 | encode));</span>
  }
  
  void Assembler::movdl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2555,12 +2455,11 @@</span>
  
  void Assembler::movdqa(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::movdqa(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2583,12 +2482,11 @@</span>
  
  void Assembler::movdqu(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::movdqu(Address dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2603,12 +2501,11 @@</span>
  // Move Unaligned 256bit Vector
  void Assembler::vmovdqu(XMMRegister dst, XMMRegister src) {
    assert(UseAVX &gt; 0, &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::vmovdqu(XMMRegister dst, Address src) {
    assert(UseAVX &gt; 0, &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2637,12 +2534,11 @@</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::evmovdqub(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2734,12 +2630,11 @@</span>
  void Assembler::evmovdqul(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::evmovdqul(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2767,12 +2662,11 @@</span>
  void Assembler::evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::evmovdquq(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2799,18 +2693,17 @@</span>
  
  // Uses zero extension on 64bit
  
  void Assembler::movl(Register dst, int32_t imm32) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xB8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8(0xB8 | encode);</span>
    emit_int32(imm32);
  }
  
  void Assembler::movl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x8B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x8B, (0xC0 | encode));</span>
  }
  
  void Assembler::movl(Register dst, Address src) {
    InstructionMark im(this);
    prefix(src, dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2847,19 +2740,17 @@</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movq( MMXRegister dst, Address src ) {
    assert( VM_Version::supports_mmx(), &quot;&quot; );
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x6F);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x6F);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movq( Address dst, MMXRegister src ) {
    assert( VM_Version::supports_mmx(), &quot;&quot; );
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x7F);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x7F);</span>
    // workaround gcc (3.2.1-7a) bug
    // In that version of gcc with only an emit_operand(MMX, Address)
    // gcc will tail jump and try and reverse the parameters completely
    // obliterating dst in the process. By having a version available
    // that doesn&#39;t need to swap the args at the tail jump the bug is
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2890,30 +2781,26 @@</span>
  }
  
  void Assembler::movsbl(Register dst, Address src) { // movsxb
    InstructionMark im(this);
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBE);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xBE);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movsbl(Register dst, Register src) { // movsxb
    NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>
  }
  
  void Assembler::movsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x10);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x10, (0xC0 | encode));</span>
  }
  
  void Assembler::movsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2939,12 +2826,11 @@</span>
  
  void Assembler::movss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x10);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x10, (0xC0 | encode));</span>
  }
  
  void Assembler::movss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2967,20 +2853,17 @@</span>
  }
  
  void Assembler::movswl(Register dst, Address src) { // movsxw
    InstructionMark im(this);
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBF);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xBF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movswl(Register dst, Register src) { // movsxw
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>
  }
  
  void Assembler::movw(Address dst, int imm16) {
    InstructionMark im(this);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3008,36 +2891,30 @@</span>
  }
  
  void Assembler::movzbl(Register dst, Address src) { // movzxb
    InstructionMark im(this);
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB6);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xB6);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzbl(Register dst, Register src) { // movzxb
    NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB6);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xB6, 0xC0 | encode);</span>
  }
  
  void Assembler::movzwl(Register dst, Address src) { // movzxw
    InstructionMark im(this);
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB7);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xB7);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzwl(Register dst, Register src) { // movzxw
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB7);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xB7, 0xC0 | encode);</span>
  }
  
  void Assembler::mull(Address src) {
    InstructionMark im(this);
    prefix(src);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3045,12 +2922,11 @@</span>
    emit_operand(rsp, src);
  }
  
  void Assembler::mull(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>
  }
  
  void Assembler::mulsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3065,12 +2941,11 @@</span>
  void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::mulss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3083,18 +2958,16 @@</span>
  
  void Assembler::mulss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::negl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xD8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>
  }
  
  void Assembler::nop(int i) {
  #ifdef ASSERT
    assert(i &gt; 0, &quot; &quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3131,32 +3004,22 @@</span>
      // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
  
      while(i &gt;= 15) {
        // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)
        i -= 15;
<span class="udiff-line-modified-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-modified-added">+       emit_int24(0x66, 0x66, 0x66);</span>
        addr_nop_8();
<span class="udiff-line-modified-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-removed">-                          // nop</span>
<span class="udiff-line-modified-added">+       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
      }
      switch (i) {
        case 14:
          emit_int8(0x66); // size prefix
        case 13:
          emit_int8(0x66); // size prefix
        case 12:
          addr_nop_8();
<span class="udiff-line-modified-removed">-         emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-         emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-removed">-                          // nop</span>
<span class="udiff-line-modified-added">+         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
          break;
        case 11:
          emit_int8(0x66); // size prefix
        case 10:
          emit_int8(0x66); // size prefix
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3214,13 +3077,11 @@</span>
      // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
      //     Size prefixes (0x66) are added for larger sizes
  
      while(i &gt;= 22) {
        i -= 11;
<span class="udiff-line-modified-removed">-       emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66); // size prefix</span>
<span class="udiff-line-modified-added">+       emit_int24(0x66, 0x66, 0x66);</span>
        addr_nop_8();
      }
      // Generate first nop for size between 21-12
      switch (i) {
        case 21:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3313,32 +3174,22 @@</span>
      // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
  
      while (i &gt;= 15) {
        // For ZX don&#39;t generate consecutive addess nops (mix with regular nops)
        i -= 15;
<span class="udiff-line-modified-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-modified-added">+       emit_int24(0x66, 0x66, 0x66);</span>
        addr_nop_8();
<span class="udiff-line-modified-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="udiff-line-removed">-       emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-removed">-                          // nop</span>
<span class="udiff-line-modified-added">+       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
      }
      switch (i) {
        case 14:
          emit_int8(0x66); // size prefix
        case 13:
          emit_int8(0x66); // size prefix
        case 12:
          addr_nop_8();
<span class="udiff-line-modified-removed">-         emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-         emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-removed">-                          // nop</span>
<span class="udiff-line-modified-added">+         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
          break;
        case 11:
          emit_int8(0x66); // size prefix
        case 10:
          emit_int8(0x66); // size prefix
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3384,39 +3235,31 @@</span>
    //  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
    //  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
    //  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
    // 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
    //
<span class="udiff-line-modified-removed">-   while(i &gt; 12) {</span>
<span class="udiff-line-modified-added">+   while (i &gt; 12) {</span>
      i -= 4;
<span class="udiff-line-modified-removed">-     emit_int8(0x66); // size prefix</span>
<span class="udiff-line-removed">-     emit_int8(0x66);</span>
<span class="udiff-line-removed">-     emit_int8(0x66);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-removed">-                      // nop</span>
<span class="udiff-line-modified-added">+     emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
    }
    // 1 - 12 nops
<span class="udiff-line-modified-removed">-   if(i &gt; 8) {</span>
<span class="udiff-line-modified-removed">-     if(i &gt; 9) {</span>
<span class="udiff-line-modified-added">+   if (i &gt; 8) {</span>
<span class="udiff-line-modified-added">+     if (i &gt; 9) {</span>
        i -= 1;
        emit_int8(0x66);
      }
      i -= 3;
<span class="udiff-line-modified-removed">-     emit_int8(0x66);</span>
<span class="udiff-line-removed">-     emit_int8(0x66);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-modified-added">+     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>
    }
    // 1 - 8 nops
<span class="udiff-line-modified-removed">-   if(i &gt; 4) {</span>
<span class="udiff-line-modified-removed">-     if(i &gt; 6) {</span>
<span class="udiff-line-modified-added">+   if (i &gt; 4) {</span>
<span class="udiff-line-modified-added">+     if (i &gt; 6) {</span>
        i -= 1;
        emit_int8(0x66);
      }
      i -= 3;
<span class="udiff-line-modified-removed">-     emit_int8(0x66);</span>
<span class="udiff-line-removed">-     emit_int8(0x66);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-modified-added">+     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>
    }
    switch (i) {
      case 4:
        emit_int8(0x66);
      case 3:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3431,12 +3274,11 @@</span>
    }
  }
  
  void Assembler::notl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>
  }
  
  void Assembler::orl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3488,76 +3330,64 @@</span>
  
  void Assembler::packuswb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x67);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x67, (0xC0 | encode));</span>
  }
  
  void Assembler::vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;some form of AVX must be enabled&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x67);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x67, (0xC0 | encode));</span>
  }
  
  void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x00);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x00, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x36);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x36, (0xC0 | encode));</span>
  }
  
  void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x46);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x46, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x06);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x06, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x76);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  
  void Assembler::pause() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x90);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (unsigned char)0x90);</span>
  }
  
  void Assembler::ud2() {
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x0B);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x0B);</span>
  }
  
  void Assembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3570,41 +3400,36 @@</span>
  
  void Assembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x61);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x61, (0xC0 | encode), imm8);</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x74);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x74, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x74);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x74, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x74);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x74, (0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3634,25 +3459,21 @@</span>
  void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x3E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(vcc);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x3E, (0xC0 | encode), vcc);</span>
  }
  
  void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
    attributes.reset_is_clear_context();
    attributes.set_embedded_opmask_register_specifier(mask);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x3E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(vcc);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x3E, (0xC0 | encode), vcc);</span>
  }
  
  void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3694,31 +3515,28 @@</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x75);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x75, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x75);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x75, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x75);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x75, (0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3734,32 +3552,29 @@</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x76);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x76);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    attributes.reset_is_clear_context();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x76);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3776,32 +3591,29 @@</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqq(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x29);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x29, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x29);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x29, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.reset_is_clear_context();
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x29);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x29, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3818,29 +3630,25 @@</span>
  
  void Assembler::pmovmskb(Register dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmovmskb(Register dst, XMMRegister src) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>
  }
  
  void Assembler::pextrd(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x16);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x16, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pextrd(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3853,13 +3661,11 @@</span>
  
  void Assembler::pextrq(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x16);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x16, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pextrq(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3872,21 +3678,19 @@</span>
  
  void Assembler::pextrw(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC5);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xC5, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pextrw(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
    simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x15);</span>
<span class="udiff-line-modified-added">+   emit_int8(0x15);</span>
    emit_operand(src, dst);
    emit_int8(imm8);
  }
  
  void Assembler::pextrb(Address dst, XMMRegister src, int imm8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3901,13 +3705,11 @@</span>
  
  void Assembler::pinsrd(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x22);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x22, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pinsrd(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3920,13 +3722,11 @@</span>
  
  void Assembler::pinsrq(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x22);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x22, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pinsrq(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3939,13 +3739,11 @@</span>
  
  void Assembler::pinsrw(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC4);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xC4, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pinsrw(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3978,20 +3776,18 @@</span>
  
  void Assembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x30);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x30, (0xC0 | encode));</span>
  }
  
  void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x20);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x20, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4007,22 +3803,20 @@</span>
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x30);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char) (0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x30, (unsigned char) (0xC0 | encode));</span>
  }
  
  void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x20);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x20, (0xC0 | encode));</span>
  }
  
  void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4077,40 +3871,36 @@</span>
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot; &quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x33);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x33, (0xC0 | encode));</span>
  }
  
  void Assembler::pmaddwd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF5);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
      (vector_len == AVX_256bit ? VM_Version::supports_avx2() :
      (vector_len == AVX_512bit ? VM_Version::supports_evex() : 0)), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF5);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>
  }
  
  void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vnni(), &quot;must support vnni&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vnni(), &quot;must support vnni&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x52);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x52, (0xC0 | encode));</span>
  }
  
  // generic
  void Assembler::pop(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4120,31 +3910,27 @@</span>
  void Assembler::popcntl(Register dst, Address src) {
    assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
    InstructionMark im(this);
    emit_int8((unsigned char)0xF3);
    prefix(src, dst);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xB8);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::popcntl(Register dst, Register src) {
    assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>
  }
  
  void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x55);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x55, (0xC0 | encode));</span>
  }
  
  void Assembler::popf() {
    emit_int8((unsigned char)0x9D);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4157,60 +3943,55 @@</span>
    emit_int8((unsigned char)0x8F);
    emit_operand(rax, dst);
  }
  #endif
  
<span class="udiff-line-removed">- void Assembler::prefetch_prefix(Address src) {</span>
<span class="udiff-line-removed">-   prefix(src);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void Assembler::prefetchnta(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefetch_prefix(src);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x18);</span>
<span class="udiff-line-modified-added">+   prefix(src);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x18);</span>
    emit_operand(rax, src); // 0, src
  }
  
  void Assembler::prefetchr(Address src) {
    assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefetch_prefix(src);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x0D);</span>
<span class="udiff-line-modified-added">+   prefix(src);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x0D);</span>
    emit_operand(rax, src); // 0, src
  }
  
  void Assembler::prefetcht0(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefetch_prefix(src);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x18);</span>
<span class="udiff-line-modified-added">+   prefix(src);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x18);</span>
    emit_operand(rcx, src); // 1, src
  }
  
  void Assembler::prefetcht1(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefetch_prefix(src);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x18);</span>
<span class="udiff-line-modified-added">+   prefix(src);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x18);</span>
    emit_operand(rdx, src); // 2, src
  }
  
  void Assembler::prefetcht2(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefetch_prefix(src);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x18);</span>
<span class="udiff-line-modified-added">+   prefix(src);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x18);</span>
    emit_operand(rbx, src); // 3, src
  }
  
  void Assembler::prefetchw(Address src) {
    assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefetch_prefix(src);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x0D);</span>
<span class="udiff-line-modified-added">+   prefix(src);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x0D);</span>
    emit_operand(rcx, src); // 1, src
  }
  
  void Assembler::prefix(Prefix p) {
    emit_int8(p);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4218,22 +3999,20 @@</span>
  
  void Assembler::pshufb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x00);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x00, (0xC0 | encode));</span>
  }
  
  void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
           vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x00);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x00, (0xC0 | encode));</span>
  }
  
  void Assembler::pshufb(XMMRegister dst, Address src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4248,25 +4027,21 @@</span>
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x70);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(mode &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>
  }
  
  void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           (vector_len == AVX_256bit? VM_Version::supports_avx2() :
           (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x70);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(mode &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>
  }
  
  void Assembler::pshufd(XMMRegister dst, Address src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4283,13 +4058,11 @@</span>
  void Assembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x70);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(mode &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>
  }
  
  void Assembler::pshuflw(XMMRegister dst, Address src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4307,56 +4080,46 @@</span>
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x43);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8 &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x43, (0xC0 | encode), imm8 &amp; 0xFF);</span>
  }
  
  void Assembler::psrldq(XMMRegister dst, int shift) {
    // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(xmm3, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift);</span>
  }
  
  void Assembler::vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
           vector_len == AVX_256bit ? VM_Version::supports_avx2() :
           vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(xmm3-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::pslldq(XMMRegister dst, int shift) {
    // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM7 is for /7 encoding: 66 0F 73 /7 ib
    int encode = simd_prefix_and_encode(xmm7, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift);</span>
  }
  
  void Assembler::vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
           vector_len == AVX_256bit ? VM_Version::supports_avx2() :
           vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(xmm7-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::ptest(XMMRegister dst, Address src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4370,11 +4133,11 @@</span>
  void Assembler::ptest(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1() || VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x17);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::vptest(XMMRegister dst, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4388,12 +4151,11 @@</span>
  
  void Assembler::vptest(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x17);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x17, (0xC0 | encode));</span>
  }
  
  void Assembler::punpcklbw(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4407,12 +4169,11 @@</span>
  
  void Assembler::punpcklbw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x60);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x60, (0xC0 | encode));</span>
  }
  
  void Assembler::punpckldq(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4426,21 +4187,19 @@</span>
  
  void Assembler::punpckldq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x62);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x62, (0xC0 | encode));</span>
  }
  
  void Assembler::punpcklqdq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6C, (0xC0 | encode));</span>
  }
  
  void Assembler::push(int32_t imm32) {
    // in 64bits we push 64bits onto the stack but only
    // take a 32bit immediate
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4448,11 +4207,10 @@</span>
    emit_int32(imm32);
  }
  
  void Assembler::push(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="udiff-line-removed">- </span>
    emit_int8(0x50 | encode);
  }
  
  void Assembler::pushf() {
    emit_int8((unsigned char)0x9C);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4470,80 +4228,74 @@</span>
  
  void Assembler::rcll(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0xD0 | encode);</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>
    }
  }
  
  void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x53);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x53, (0xC0 | encode));</span>
  }
  
  void Assembler::rcpss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x53);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x53, (0xC0 | encode));</span>
  }
  
  void Assembler::rdtsc() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x31);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, 0x31);</span>
  }
  
  // copies data from [esi] to [edi] using rcx pointer sized words
  // generic
  void Assembler::rep_mov() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-modified-added">+   // REP</span>
    // MOVSQ
<span class="udiff-line-modified-removed">-   LP64_ONLY(prefix(REX_W));</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xA5);</span>
<span class="udiff-line-modified-added">+   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xA5);)</span>
<span class="udiff-line-modified-added">+   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xA5);)</span>
  }
  
  // sets rcx bytes with rax, value at [edi]
  void Assembler::rep_stosb() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3); // REP</span>
<span class="udiff-line-modified-removed">-   LP64_ONLY(prefix(REX_W));</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xAA); // STOSB</span>
<span class="udiff-line-modified-added">+   // REP</span>
<span class="udiff-line-modified-added">+   // STOSB</span>
<span class="udiff-line-modified-added">+   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAA);)</span>
<span class="udiff-line-added">+   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAA);)</span>
  }
  
  // sets rcx pointer sized words with rax, value at [edi]
  // generic
  void Assembler::rep_stos() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3); // REP</span>
<span class="udiff-line-modified-removed">-   LP64_ONLY(prefix(REX_W));       // LP64:STOSQ, LP32:STOSD</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xAB);</span>
<span class="udiff-line-modified-added">+   // REP</span>
<span class="udiff-line-modified-added">+   // LP64:STOSQ, LP32:STOSD</span>
<span class="udiff-line-modified-added">+   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAB);)</span>
<span class="udiff-line-added">+   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAB);)</span>
  }
  
  // scans rcx pointer sized words at [edi] for occurance of rax,
  // generic
  void Assembler::repne_scan() { // repne_scan
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF2);</span>
    // SCASQ
<span class="udiff-line-modified-removed">-   LP64_ONLY(prefix(REX_W));</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xAF);</span>
<span class="udiff-line-modified-added">+   LP64_ONLY(emit_int24((unsigned char)0xF2, REX_W, (unsigned char)0xAF);)</span>
<span class="udiff-line-modified-added">+   NOT_LP64( emit_int16((unsigned char)0xF2,        (unsigned char)0xAF);)</span>
  }
  
  #ifdef _LP64
  // scans rcx 4 byte words at [edi] for occurance of rax,
  // generic
  void Assembler::repne_scanl() { // repne_scan
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF2);</span>
    // SCASL
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xAF);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF2, (unsigned char)0xAF);</span>
  }
  #endif
  
  void Assembler::ret(int imm16) {
    if (imm16 == 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4564,23 +4316,19 @@</span>
  
  void Assembler::sarl(Register dst, int imm8) {
    int encode = prefix_and_encode(dst-&gt;encoding());
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    if (imm8 == 1) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>
    }
  }
  
  void Assembler::sarl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>
  }
  
  void Assembler::sbbl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4606,167 +4354,132 @@</span>
  }
  
  void Assembler::setb(Condition cc, Register dst) {
    assert(0 &lt;= cc &amp;&amp; cc &lt; 16, &quot;illegal cc&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding(), true);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x90 | cc);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0x90 | cc, (0xC0 | encode));</span>
  }
  
  void Assembler::palignr(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::vpalignr(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
           0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x3, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pblendw(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0E, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::sha1rnds4(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, /* rex_w */ false);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xCC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xCC, (0xC0 | encode), (unsigned char)imm8);</span>
  }
  
  void Assembler::sha1nexte(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xC8, (0xC0 | encode));</span>
  }
  
  void Assembler::sha1msg1(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xC9, (0xC0 | encode));</span>
  }
  
  void Assembler::sha1msg2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xCA);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xCA, (0xC0 | encode));</span>
  }
  
  // xmm0 is implicit additional source to this instruction.
  void Assembler::sha256rnds2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xCB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xCB, (0xC0 | encode));</span>
  }
  
  void Assembler::sha256msg1(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xCC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xCC, (0xC0 | encode));</span>
  }
  
  void Assembler::sha256msg2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xCD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xCD, (0xC0 | encode));</span>
  }
  
  
  void Assembler::shll(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
    if (imm8 == 1 ) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>
    }
  }
  
  void Assembler::shll(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>
  }
  
  void Assembler::shrl(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>
  }
  
  void Assembler::shrl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, (0xE8 | encode));</span>
  }
  
  void Assembler::shldl(Register dst, Register src) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xA5);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xA5, (0xC0 | encode));</span>
  }
  
  void Assembler::shldl(Register dst, Register src, int8_t imm8) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xA4);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::shrdl(Register dst, Register src) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xAD, (0xC0 | encode));</span>
  }
  
  void Assembler::shrdl(Register dst, Register src, int8_t imm8) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);</span>
  }
  
  // copies a single word from [esi] to [edi]
  void Assembler::smovl() {
    emit_int8((unsigned char)0xA5);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4774,13 +4487,11 @@</span>
  
  void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x0B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)rmode);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0B, (0xC0 | encode), (unsigned char)rmode);</span>
  }
  
  void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4794,12 +4505,11 @@</span>
  void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x51);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::sqrtsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4813,12 +4523,11 @@</span>
  
  void Assembler::sqrtss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x51);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::std() {
    emit_int8((unsigned char)0xFD);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4843,12 +4552,11 @@</span>
      emit_operand(as_Register(3), dst);
    } else {
      NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
      InstructionMark im(this);
      prefix(dst);
<span class="udiff-line-modified-removed">-     emit_int8(0x0F);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+     emit_int16(0x0F, (unsigned char)0xAE);</span>
      emit_operand(as_Register(3), dst);
    }
  }
  
  void Assembler::subl(Address dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4890,12 +4598,11 @@</span>
  void Assembler::subsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::subsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4909,12 +4616,11 @@</span>
  
  void Assembler::subss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::subss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4946,12 +4652,11 @@</span>
    int encode = dst-&gt;encoding();
    if (encode == 0) {
      emit_int8((unsigned char)0xA9);
    } else {
      encode = prefix_and_encode(encode);
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
    }
    emit_int32(imm32);
  }
  
  void Assembler::testl(Register dst, Register src) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4968,22 +4673,20 @@</span>
  
  void Assembler::tzcntl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xBC);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC0 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xBC,</span>
<span class="udiff-line-modified-added">+              0xC0 | encode);</span>
  }
  
  void Assembler::tzcntq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>
  }
  
  void Assembler::ucomisd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4998,12 +4701,11 @@</span>
  void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2E, (0xC0 | encode));</span>
  }
  
  void Assembler::ucomiss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5016,59 +4718,51 @@</span>
  
  void Assembler::ucomiss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2E, (0xC0 | encode));</span>
  }
  
  void Assembler::xabort(int8_t imm8) {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC6);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(imm8 &amp; 0xFF));</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xC6, (unsigned char)0xF8, (imm8 &amp; 0xFF));</span>
  }
  
  void Assembler::xaddb(Address dst, Register src) {
    InstructionMark im(this);
    prefix(dst, src, true);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xC0);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xC0);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xaddw(Address dst, Register src) {
    InstructionMark im(this);
    emit_int8(0x66);
    prefix(dst, src);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xaddl(Address dst, Register src) {
    InstructionMark im(this);
    prefix(dst, src);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xbegin(Label&amp; abort, relocInfo::relocType rtype) {
    InstructionMark im(this);
    relocate(rtype);
    if (abort.is_bound()) {
      address entry = target(abort);
      assert(entry != NULL, &quot;abort entry NULL&quot;);
      intptr_t offset = entry - pc();
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC7);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0xF8);</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>
      emit_int32(offset - 6); // 2 opcode + 4 address
    } else {
      abort.add_patch_at(code(), locator());
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC7);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0xF8);</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>
      emit_int32(0);
    }
  }
  
  void Assembler::xchgb(Register dst, Address src) { // xchg
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5093,24 +4787,19 @@</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xchgl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x87);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x87, (0xC0 | encode));</span>
  }
  
  void Assembler::xend() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x01);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xD5);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, 0x01, (unsigned char)0xD5);</span>
  }
  
  void Assembler::xgetbv() {
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x01);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xD0);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, 0x01, (unsigned char)0xD0);</span>
  }
  
  void Assembler::xorl(Register dst, int32_t imm32) {
    prefix(dst);
    emit_arith(0x81, 0xF0, dst, imm32);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5151,12 +4840,11 @@</span>
  void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5169,12 +4857,11 @@</span>
  
  void Assembler::vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5189,12 +4876,11 @@</span>
  void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5207,28 +4893,25 @@</span>
  
  void Assembler::vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231sd(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xB9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231ss(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xB9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5243,12 +4926,11 @@</span>
  void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5261,12 +4943,11 @@</span>
  
  void Assembler::vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5281,12 +4962,11 @@</span>
  void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5299,12 +4979,11 @@</span>
  
  void Assembler::vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  //====================VECTOR ARITHMETIC=====================================
  
  // Float-point vector arithmetic
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5312,12 +4991,11 @@</span>
  void Assembler::addpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::addpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5332,29 +5010,26 @@</span>
  
  void Assembler::addps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5379,37 +5054,33 @@</span>
  void Assembler::subpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::subps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5434,12 +5105,11 @@</span>
  void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::mulpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5453,29 +5123,26 @@</span>
  
  void Assembler::mulps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5499,20 +5166,18 @@</span>
  
  void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5536,37 +5201,33 @@</span>
  void Assembler::divpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::divps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5590,56 +5251,51 @@</span>
  
  void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x09);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(rmode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x09, (0xC0 | encode), (rmode));</span>
  }
  
  void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x09);
    emit_operand(dst, src);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(rmode));</span>
<span class="udiff-line-modified-added">+   emit_int8((rmode));</span>
  }
  
  void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x09);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(rmode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x09, (0xC0 | encode), (rmode));</span>
  }
  
  void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
    vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x09);</span>
<span class="udiff-line-modified-added">+   emit_int8(0x09);</span>
    emit_operand(dst, src);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(rmode));</span>
<span class="udiff-line-modified-added">+   emit_int8((rmode));</span>
  }
  
  
  void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x51);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::vsqrtpd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5653,12 +5309,11 @@</span>
  
  void Assembler::vsqrtps(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x51);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::vsqrtps(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5672,20 +5327,18 @@</span>
  void Assembler::andpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x54);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::andps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x54);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::andps(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5710,20 +5363,18 @@</span>
  void Assembler::vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x54);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x54);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5749,37 +5400,34 @@</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x15);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::unpcklpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x14);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x14, (0xC0 | encode));</span>
  }
  
  void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x57);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::xorps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x57);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::xorpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5804,20 +5452,18 @@</span>
  void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x57);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x57);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5843,45 +5489,40 @@</span>
  void Assembler::vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
           VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x01);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x01, (0xC0 | encode));</span>
  }
  
  void Assembler::vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
           VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x02);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x02, (0xC0 | encode));</span>
  }
  
  void Assembler::paddb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>
  }
  
  void Assembler::paddw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>
  }
  
  void Assembler::paddd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>
  }
  
  void Assembler::paddd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5894,61 +5535,54 @@</span>
  void Assembler::paddq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD4);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>
  }
  
  void Assembler::phaddw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x01);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x01, (0xC0 | encode));</span>
  }
  
  void Assembler::phaddd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x02);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x02, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD4);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5992,69 +5626,62 @@</span>
  
  void Assembler::psubb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>
  }
  
  void Assembler::psubw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>
  }
  
  void Assembler::psubd(XMMRegister dst, XMMRegister src) {
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFA);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>
  }
  
  void Assembler::psubq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xFB);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFA);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6098,45 +5725,40 @@</span>
  
  void Assembler::pmullw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD5);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>
  }
  
  void Assembler::pmulld(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x40);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x40, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD5);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x40);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x40, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x40);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x40, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6172,359 +5794,306 @@</span>
  void Assembler::psllw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 71 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x71);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::pslld(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 72 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x72);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psllq(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 73 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psllw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>
  }
  
  void Assembler::pslld(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::psllq(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 71 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x71);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 72 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x72);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM6 is for /6 encoding: 66 0F 73 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>
  }
  
  void Assembler::vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  // Shift packed integers logically right by specified number of bits.
  void Assembler::psrlw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 71 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x71);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrld(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 72 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x72);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrlq(XMMRegister dst, int shift) {
    // Do not confuse it with psrldq SSE2 instruction which
    // shifts 128 bit value in xmm register by number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM2 is for /2 encoding: 66 0F 73 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrlw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>
  }
  
  void Assembler::psrld(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>
  }
  
  void Assembler::psrlq(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 71 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x71);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 72 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x72);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM2 is for /2 encoding: 66 0F 73 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>
  }
  
  void Assembler::evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x10);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x10, (0xC0 | encode));</span>
  }
  
  void Assembler::evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x12);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x12, (0xC0 | encode));</span>
  }
  
  // Shift packed integers arithmetically right by specified number of bits.
  void Assembler::psraw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x71);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrad(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 72 /4 ib
    int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x72);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8((0xC0 | encode));</span>
    emit_int8(shift &amp; 0xFF);
  }
  
  void Assembler::psraw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xE1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>
  }
  
  void Assembler::psrad(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xE2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x71);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x72);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xE1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xE2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>
  }
  
  void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
    assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x72);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(shift &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
    assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xE2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>
  }
  
  // logical operations packed integers
  void Assembler::pand(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6537,64 +6106,58 @@</span>
  
  void Assembler::vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x71);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x73);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x73, (0xC0 | encode));</span>
  }
  
  void Assembler::pandn(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  void Assembler::vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  
  void Assembler::por(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xEB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xEB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6607,29 +6170,26 @@</span>
  
  void Assembler::vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xEB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>
  }
  
  
  void Assembler::pxor(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xEF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>
  }
  
  void Assembler::vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xEF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>
  }
  
  void Assembler::vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6644,11 +6204,11 @@</span>
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xEF);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6667,15 +6227,14 @@</span>
  void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x38);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // last byte:</span>
    // 0x00 - insert into lower 128 bits
    // 0x01 - insert into upper 128 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6695,17 +6254,16 @@</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x38);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - insert into q0 128 bits (0..127)
    // 0x01 - insert into q1 128 bits (128..255)
    // 0x02 - insert into q2 128 bits (256..383)
    // 0x03 - insert into q3 128 bits (384..511)
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x03);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6728,30 +6286,28 @@</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x3A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   //imm8:</span>
    // 0x00 - insert into lower 256 bits
    // 0x01 - insert into upper 256 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x3A, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  
  // vinsertf forms
  
  void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x18);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - insert into lower 128 bits
    // 0x01 - insert into upper 128 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6770,17 +6326,16 @@</span>
  void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x18);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - insert into q0 128 bits (0..127)
    // 0x01 - insert into q1 128 bits (128..255)
    // 0x02 - insert into q0 128 bits (256..383)
    // 0x03 - insert into q1 128 bits (384..512)
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x03);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6802,15 +6357,14 @@</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x1A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - insert into lower 256 bits
    // 0x01 - insert into upper 256 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x1A, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6833,15 +6387,14 @@</span>
  void Assembler::vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x39);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from lower 128 bits
    // 0x01 - extract from upper 128 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6862,17 +6415,16 @@</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x39);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x03);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextracti32x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6896,30 +6448,28 @@</span>
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x39);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x03);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x3B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from lower 256 bits
    // 0x01 - extract from upper 256 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x3B, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextracti64x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6941,15 +6491,14 @@</span>
  void Assembler::vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x19);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from lower 128 bits
    // 0x01 - extract from upper 128 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextractf128(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6970,17 +6519,16 @@</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x19);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x03);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextractf32x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7004,30 +6552,28 @@</span>
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x19);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x03);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x1B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   // imm8:</span>
    // 0x00 - extract from lower 256 bits
    // 0x01 - extract from upper 256 bits
<span class="udiff-line-modified-removed">-   emit_int8(imm8 &amp; 0x01);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x1B, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextractf64x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7048,12 +6594,11 @@</span>
  // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x78);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x78, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastb(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7069,12 +6614,11 @@</span>
  // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x79);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x79, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastw(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7092,12 +6636,11 @@</span>
  // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(UseAVX &gt;= 2, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x58);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7114,12 +6657,11 @@</span>
  void Assembler::vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x59);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastq(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7136,12 +6678,11 @@</span>
    assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5A, (0xC0 | encode));</span>
  }
  
  void Assembler::evbroadcasti64x2(XMMRegister dst, Address src, int vector_len) {
    assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7157,19 +6698,18 @@</span>
  }
  
  // scalar single/double precision replicate
  
  // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
<span class="udiff-line-modified-removed">- void Assembler::vpbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+ void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x18);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x18, (0xC0 | encode));</span>
  }
  
<span class="udiff-line-modified-removed">- void Assembler::vpbroadcastss(XMMRegister dst, Address src, int vector_len) {</span>
<span class="udiff-line-modified-added">+ void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7178,21 +6718,22 @@</span>
    emit_int8(0x18);
    emit_operand(dst, src);
  }
  
  // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
<span class="udiff-line-modified-removed">- void Assembler::vpbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
<span class="udiff-line-modified-added">+ void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="udiff-line-modified-added">+   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
<span class="udiff-line-added">+   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x19);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x19, (0xC0 | encode));</span>
  }
  
<span class="udiff-line-modified-removed">- void Assembler::vpbroadcastsd(XMMRegister dst, Address src, int vector_len) {</span>
<span class="udiff-line-modified-added">+ void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {</span>
    assert(VM_Version::supports_avx(), &quot;&quot;);
<span class="udiff-line-added">+   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
    attributes.set_rex_vex_w_reverted();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7209,42 +6750,38 @@</span>
  void Assembler::evpbroadcastb(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x7A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x7A, (0xC0 | encode));</span>
  }
  
  // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::evpbroadcastw(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x7B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x7B, (0xC0 | encode));</span>
  }
  
  // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::evpbroadcastd(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x7C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x7C, (0xC0 | encode));</span>
  }
  
  // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::evpbroadcastq(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x7C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x7C, (0xC0 | encode));</span>
  }
  void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7261,51 +6798,48 @@</span>
  // Carry-Less Multiplication Quadword
  void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
    assert(VM_Version::supports_clmul(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x44);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)mask);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>
  }
  
  // Carry-Less Multiplication Quadword
  void Assembler::vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask) {
    assert(VM_Version::supports_avx() &amp;&amp; VM_Version::supports_clmul(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x44);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)mask);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>
  }
  
  void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
    assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x44);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)mask);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>
  }
  
<span class="udiff-line-modified-removed">- void Assembler::vzeroupper() {</span>
<span class="udiff-line-modified-added">+ void Assembler::vzeroupper_uncached() {</span>
    if (VM_Version::supports_vzeroupper()) {
      InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
      (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
      emit_int8(0x77);
    }
  }
  
  #ifndef _LP64
  // 32bit only pieces of the assembler
  
<span class="udiff-line-added">+ void Assembler::vzeroupper() {</span>
<span class="udiff-line-added">+   vzeroupper_uncached();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x81);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF8 | src1-&gt;encoding()));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x81, (0xF8 | src1-&gt;encoding()));</span>
    emit_data(imm32, rspec, 0);
  }
  
  void Assembler::cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT (not even 32bit versions of 64bit regs
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7318,12 +6852,11 @@</span>
  // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
  // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
  // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchg8(Address adr) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xC7);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xC7);</span>
    emit_operand(rcx, adr);
  }
  
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7331,12 +6864,11 @@</span>
  }
  
  // 64bit doesn&#39;t use the x87
  
  void Assembler::fabs() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xE1);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);</span>
  }
  
  void Assembler::fadd(int i) {
    emit_farith(0xD8, 0xC0, i);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7360,12 +6892,11 @@</span>
  void Assembler::faddp(int i) {
    emit_farith(0xDE, 0xC0, i);
  }
  
  void Assembler::fchs() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xE0);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xE0);</span>
  }
  
  void Assembler::fcom(int i) {
    emit_farith(0xD8, 0xD0, i);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7385,22 +6916,19 @@</span>
    emit_int8((unsigned char)0xD8);
    emit_operand32(rbx, src);
  }
  
  void Assembler::fcompp() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDE, (unsigned char)0xD9);</span>
  }
  
  void Assembler::fcos() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xFF);</span>
  }
  
  void Assembler::fdecstp() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF6);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xF6);</span>
  }
  
  void Assembler::fdiv(int i) {
    emit_farith(0xD8, 0xF0, i);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7467,18 +6995,15 @@</span>
    emit_int8((unsigned char)0xDB);
    emit_operand32(rax, adr);
  }
  
  void Assembler::fincstp() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xF7);</span>
  }
  
  void Assembler::finit() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x9B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xDB);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xE3);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0x9B, (unsigned char)0xDB, (unsigned char)0xE3);</span>
  }
  
  void Assembler::fist_s(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDB);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7496,12 +7021,11 @@</span>
    emit_int8((unsigned char)0xDB);
    emit_operand32(rbx, adr);
  }
  
  void Assembler::fld1() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xE8);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xE8);</span>
  }
  
  void Assembler::fld_d(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7536,22 +7060,19 @@</span>
    emit_int8((unsigned char)0xD9);
    emit_operand32(rsp, src);
  }
  
  void Assembler::fldlg2() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xEC);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xEC);</span>
  }
  
  void Assembler::fldln2() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xED);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xED);</span>
  }
  
  void Assembler::fldz() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xEE);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xEE);</span>
  }
  
  void Assembler::flog() {
    fldln2();
    fxch();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7594,44 +7115,38 @@</span>
    emit_operand32(rsi, dst);
  }
  
  void Assembler::fnstcw(Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x9B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x9B, (unsigned char)0xD9);</span>
    emit_operand32(rdi, src);
  }
  
  void Assembler::fnstsw_ax() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xDF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xE0);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xDF, (unsigned char)0xE0);</span>
  }
  
  void Assembler::fprem() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF8);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xF8);</span>
  }
  
  void Assembler::fprem1() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF5);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xF5);</span>
  }
  
  void Assembler::frstor(Address src) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
    emit_operand32(rsp, src);
  }
  
  void Assembler::fsin() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xFE);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xFE);</span>
  }
  
  void Assembler::fsqrt() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xFA);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xFA);</span>
  }
  
  void Assembler::fst_d(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7713,19 +7228,15 @@</span>
  void Assembler::fsubrp(int i) {
    emit_farith(0xDE, 0xE0, i);                    // ST(0) &lt;- ST(1) - ST(0) and pop (Intel manual wrong)
  }
  
  void Assembler::ftan() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xDD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xD8);</span>
<span class="udiff-line-modified-added">+   emit_int32((unsigned char)0xD9, (unsigned char)0xF2, (unsigned char)0xDD, (unsigned char)0xD8);</span>
  }
  
  void Assembler::ftst() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xE4);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xE4);</span>
  }
  
  void Assembler::fucomi(int i) {
    // make sure the instruction is supported (introduced for P6, together with cmov)
    guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7745,27 +7256,23 @@</span>
  void Assembler::fxch(int i) {
    emit_farith(0xD9, 0xC8, i);
  }
  
  void Assembler::fyl2x() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF1);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xF1);</span>
  }
  
  void Assembler::frndint() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xFC);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xFC);</span>
  }
  
  void Assembler::f2xm1() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF0);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xF0);</span>
  }
  
  void Assembler::fldl2e() {
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD9);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xEA);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD9, (unsigned char)0xEA);</span>
  }
  #endif // !_LP64
  
  // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
  static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7809,35 +7316,32 @@</span>
  
  void Assembler::vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {
    int vector_len = _attributes-&gt;get_vector_len();
    bool vex_w = _attributes-&gt;is_rex_vex_w();
    if (vex_b || vex_x || vex_w || (opc == VEX_OPCODE_0F_38) || (opc == VEX_OPCODE_0F_3A)) {
<span class="udiff-line-removed">-     prefix(VEX_3bytes);</span>
<span class="udiff-line-removed">- </span>
      int byte1 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0);
      byte1 = (~byte1) &amp; 0xE0;
      byte1 |= opc;
<span class="udiff-line-removed">-     emit_int8(byte1);</span>
  
      int byte2 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
      byte2 |= (vex_w ? VEX_W : 0) | ((vector_len &gt; 0) ? 4 : 0) | pre;
<span class="udiff-line-removed">-     emit_int8(byte2);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     prefix(VEX_2bytes);</span>
  
<span class="udiff-line-added">+     emit_int24((unsigned char)VEX_3bytes, byte1, byte2);</span>
<span class="udiff-line-added">+   } else {</span>
      int byte1 = vex_r ? VEX_R : 0;
      byte1 = (~byte1) &amp; 0x80;
      byte1 |= ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
      byte1 |= ((vector_len &gt; 0 ) ? 4 : 0) | pre;
<span class="udiff-line-modified-removed">-     emit_int8(byte1);</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)VEX_2bytes, byte1);</span>
    }
  }
  
  // This is a 4 byte encoding
  void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){
    // EVEX 0x62 prefix
<span class="udiff-line-modified-removed">-   prefix(EVEX_4bytes);</span>
<span class="udiff-line-modified-added">+   // byte1 = EVEX_4bytes;</span>
<span class="udiff-line-added">+ </span>
    bool vex_w = _attributes-&gt;is_rex_vex_w();
    int evex_encoding = (vex_w ? VEX_W : 0);
    // EVEX.b is not currently used for broadcast of single element or data rounding modes
    _attributes-&gt;set_evex_encoding(evex_encoding);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7846,21 +7350,19 @@</span>
    int byte2 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0) | (evex_r ? EVEX_Rb : 0);
    byte2 = (~byte2) &amp; 0xF0;
    // confine opc opcode extensions in mm bits to lower two bits
    // of form {0F, 0F_38, 0F_3A}
    byte2 |= opc;
<span class="udiff-line-removed">-   emit_int8(byte2);</span>
  
    // P1: byte 3 as Wvvvv1pp
    int byte3 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
    // p[10] is always 1
    byte3 |= EVEX_F;
    byte3 |= (vex_w &amp; 1) &lt;&lt; 7;
    // confine pre opcode extensions in pp bits to lower two bits
    // of form {66, F3, F2}
    byte3 |= pre;
<span class="udiff-line-removed">-   emit_int8(byte3);</span>
  
    // P2: byte 4 as zL&#39;Lbv&#39;aaa
    // kregs are implemented in the low 3 bits as aaa
    int byte4 = (_attributes-&gt;is_no_reg_mask()) ?
                0 :
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7873,15 +7375,16 @@</span>
    byte4 |= ((_attributes-&gt;get_vector_len())&amp; 0x3) &lt;&lt; 5;
    // last is EVEX.z for zero/merge actions
    if (_attributes-&gt;is_no_reg_mask() == false) {
      byte4 |= (_attributes-&gt;is_clear_context() ? EVEX_Z : 0);
    }
<span class="udiff-line-modified-removed">-   emit_int8(byte4);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   emit_int32(EVEX_4bytes, byte2, byte3, byte4);</span>
  }
  
  void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="udiff-line-modified-removed">-   bool vex_r = ((xreg_enc &amp; 8) == 8) ? 1 : 0;</span>
<span class="udiff-line-modified-added">+   bool vex_r = (xreg_enc &amp; 8) == 8;</span>
    bool vex_b = adr.base_needs_rex();
    bool vex_x;
    if (adr.isxmmindex()) {
      vex_x = adr.xmmindex_needs_rex();
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7892,11 +7395,11 @@</span>
  
    // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
    // is allowed in legacy mode and has resources which will fit in it.
    // Pure EVEX instructions will have is_evex_instruction set in their definition.
    if (!attributes-&gt;is_legacy_mode()) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
        if ((attributes-&gt;get_vector_len() != AVX_512bit) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (xreg_enc &lt; 16)) {
            attributes-&gt;set_is_legacy_mode();
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7907,11 +7410,11 @@</span>
              (!_legacy_mode_vl) ||
              (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
      assert(((nds_enc &lt; 16 &amp;&amp; xreg_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
    }
  
<span class="udiff-line-modified-removed">-   _is_managed = false;</span>
<span class="udiff-line-modified-added">+   clear_managed();</span>
    if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
    {
      bool evex_r = (xreg_enc &gt;= 16);
      bool evex_v;
      // EVEX.V&#39; is set to true when VSIB is used as we may need to use higher order XMM registers (16-31)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7929,21 +7432,21 @@</span>
      vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
    }
  }
  
  int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="udiff-line-modified-removed">-   bool vex_r = ((dst_enc &amp; 8) == 8) ? 1 : 0;</span>
<span class="udiff-line-modified-removed">-   bool vex_b = ((src_enc &amp; 8) == 8) ? 1 : 0;</span>
<span class="udiff-line-modified-added">+   bool vex_r = (dst_enc &amp; 8) == 8;</span>
<span class="udiff-line-modified-added">+   bool vex_b = (src_enc &amp; 8) == 8;</span>
    bool vex_x = false;
    set_attributes(attributes);
    attributes-&gt;set_current_assembler(this);
  
    // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
    // is allowed in legacy mode and has resources which will fit in it.
    // Pure EVEX instructions will have is_evex_instruction set in their definition.
    if (!attributes-&gt;is_legacy_mode()) {
<span class="udiff-line-modified-removed">-     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {</span>
<span class="udiff-line-modified-added">+     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
        if ((!attributes-&gt;uses_vl() || (attributes-&gt;get_vector_len() != AVX_512bit)) &amp;&amp;
            (dst_enc &lt; 16) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (src_enc &lt; 16)) {
            attributes-&gt;set_is_legacy_mode();
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -7961,11 +7464,11 @@</span>
              (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
      // Instruction with legacy_mode true should have dst, nds and src &lt; 15
      assert(((dst_enc &lt; 16 &amp;&amp; nds_enc &lt; 16 &amp;&amp; src_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
    }
  
<span class="udiff-line-modified-removed">-   _is_managed = false;</span>
<span class="udiff-line-modified-added">+   clear_managed();</span>
    if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
    {
      bool evex_r = (dst_enc &gt;= 16);
      bool evex_v = (nds_enc &gt;= 16);
      // can use vex_x as bank extender on rm encoding
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8011,105 +7514,89 @@</span>
  
  void Assembler::vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5F, (0xC0 | encode));</span>
  }
  
  void Assembler::vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5F, (0xC0 | encode));</span>
  }
  
  void Assembler::vminss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5D);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5D, (0xC0 | encode));</span>
  }
  
  void Assembler::vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x5D);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x5D, (0xC0 | encode));</span>
  }
  
  void Assembler::cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF &amp; cop));</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>
  }
  
  void Assembler::blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x4B);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    int src2_enc = src2-&gt;encoding();
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x4B, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
  }
  
  void Assembler::cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF &amp; cop));</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>
  }
  
  void Assembler::blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x4A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    int src2_enc = src2-&gt;encoding();
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x4A, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
  }
  
  void Assembler::vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x02);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x02, (0xC0 | encode), (unsigned char)imm8);</span>
  }
  
  void Assembler::shlxl(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
  }
  
  void Assembler::shlxq(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
  }
  
  #ifndef _LP64
  
  void Assembler::incl(Register dst) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8129,11 +7616,11 @@</span>
  }
  
  void Assembler::mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xB8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8((0xB8 | encode));</span>
    emit_data((int)imm32, rspec, 0);
  }
  
  void Assembler::popa() { // 32bit
    emit_int8(0x61);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8148,53 +7635,51 @@</span>
  void Assembler::pusha() { // 32bit
    emit_int8(0x60);
  }
  
  void Assembler::set_byte_if_not_zero(Register dst) {
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x95);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE0 | dst-&gt;encoding()));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | dst-&gt;encoding()));</span>
  }
  
  #else // LP64
  
  void Assembler::set_byte_if_not_zero(Register dst) {
    int enc = prefix_and_encode(dst-&gt;encoding(), true);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x95);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE0 | enc));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | enc));</span>
  }
  
  // 64bit only pieces of the assembler
  // This should only be used by 64bit instructions that can use rip-relative
  // it cannot be used by instructions that want an immediate value.
  
  bool Assembler::reachable(AddressLiteral adr) {
    int64_t disp;
<span class="udiff-line-added">+   relocInfo::relocType relocType = adr.reloc();</span>
<span class="udiff-line-added">+ </span>
    // None will force a 64bit literal to the code stream. Likely a placeholder
    // for something that will be patched later and we need to certain it will
    // always be reachable.
<span class="udiff-line-modified-removed">-   if (adr.reloc() == relocInfo::none) {</span>
<span class="udiff-line-modified-added">+   if (relocType == relocInfo::none) {</span>
      return false;
    }
<span class="udiff-line-modified-removed">-   if (adr.reloc() == relocInfo::internal_word_type) {</span>
<span class="udiff-line-modified-added">+   if (relocType == relocInfo::internal_word_type) {</span>
      // This should be rip relative and easily reachable.
      return true;
    }
<span class="udiff-line-modified-removed">-   if (adr.reloc() == relocInfo::virtual_call_type ||</span>
<span class="udiff-line-modified-removed">-       adr.reloc() == relocInfo::opt_virtual_call_type ||</span>
<span class="udiff-line-modified-removed">-       adr.reloc() == relocInfo::static_call_type ||</span>
<span class="udiff-line-modified-removed">-       adr.reloc() == relocInfo::static_stub_type ) {</span>
<span class="udiff-line-modified-added">+   if (relocType == relocInfo::virtual_call_type ||</span>
<span class="udiff-line-modified-added">+       relocType == relocInfo::opt_virtual_call_type ||</span>
<span class="udiff-line-modified-added">+       relocType == relocInfo::static_call_type ||</span>
<span class="udiff-line-modified-added">+       relocType == relocInfo::static_stub_type ) {</span>
      // This should be rip relative within the code cache and easily
      // reachable until we get huge code caches. (At which point
      // ic code is going to have issues).
      return true;
    }
<span class="udiff-line-modified-removed">-   if (adr.reloc() != relocInfo::external_word_type &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       adr.reloc() != relocInfo::poll_return_type &amp;&amp;  // these are really external_word but need special</span>
<span class="udiff-line-modified-removed">-       adr.reloc() != relocInfo::poll_type &amp;&amp;         // relocs to identify them</span>
<span class="udiff-line-modified-removed">-       adr.reloc() != relocInfo::runtime_call_type ) {</span>
<span class="udiff-line-modified-added">+   if (relocType != relocInfo::external_word_type &amp;&amp;</span>
<span class="udiff-line-modified-added">+       relocType != relocInfo::poll_return_type &amp;&amp;  // these are really external_word but need special</span>
<span class="udiff-line-modified-added">+       relocType != relocInfo::poll_type &amp;&amp;         // relocs to identify them</span>
<span class="udiff-line-modified-added">+       relocType != relocInfo::runtime_call_type ) {</span>
      return false;
    }
  
    // Stress the correction code
    if (ForceUnreachable) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8266,70 +7751,10 @@</span>
    check_relocation(rspec, format);
  #endif
    emit_int64(data);
  }
  
<span class="udiff-line-removed">- int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {</span>
<span class="udiff-line-removed">-   if (reg_enc &gt;= 8) {</span>
<span class="udiff-line-removed">-     prefix(REX_B);</span>
<span class="udiff-line-removed">-     reg_enc -= 8;</span>
<span class="udiff-line-removed">-   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {</span>
<span class="udiff-line-removed">-     prefix(REX);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return reg_enc;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- int Assembler::prefixq_and_encode(int reg_enc) {</span>
<span class="udiff-line-removed">-   if (reg_enc &lt; 8) {</span>
<span class="udiff-line-removed">-     prefix(REX_W);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     prefix(REX_WB);</span>
<span class="udiff-line-removed">-     reg_enc -= 8;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return reg_enc;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {</span>
<span class="udiff-line-removed">-   if (dst_enc &lt; 8) {</span>
<span class="udiff-line-removed">-     if (src_enc &gt;= 8) {</span>
<span class="udiff-line-removed">-       prefix(REX_B);</span>
<span class="udiff-line-removed">-       src_enc -= 8;</span>
<span class="udiff-line-removed">-     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {</span>
<span class="udiff-line-removed">-       prefix(REX);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (src_enc &lt; 8) {</span>
<span class="udiff-line-removed">-       prefix(REX_R);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       prefix(REX_RB);</span>
<span class="udiff-line-removed">-       src_enc -= 8;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     dst_enc -= 8;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {</span>
<span class="udiff-line-removed">-   if (dst_enc &lt; 8) {</span>
<span class="udiff-line-removed">-     if (src_enc &lt; 8) {</span>
<span class="udiff-line-removed">-       prefix(REX_W);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       prefix(REX_WB);</span>
<span class="udiff-line-removed">-       src_enc -= 8;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (src_enc &lt; 8) {</span>
<span class="udiff-line-removed">-       prefix(REX_WR);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       prefix(REX_WRB);</span>
<span class="udiff-line-removed">-       src_enc -= 8;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     dst_enc -= 8;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void Assembler::prefix(Register reg) {
    if (reg-&gt;encoding() &gt;= 8) {
      prefix(REX_B);
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8337,11 +7762,11 @@</span>
  void Assembler::prefix(Register dst, Register src, Prefix p) {
    if (src-&gt;encoding() &gt;= 8) {
      p = (Prefix)(p | REX_B);
    }
    if (dst-&gt;encoding() &gt;= 8) {
<span class="udiff-line-modified-removed">-     p = (Prefix)( p | REX_R);</span>
<span class="udiff-line-modified-added">+     p = (Prefix)(p | REX_R);</span>
    }
    if (p != Prefix_EMPTY) {
      // do not generate an empty prefix
      prefix(p);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8380,27 +7805,10 @@</span>
        prefix(REX_X);
      }
    }
  }
  
<span class="udiff-line-removed">- void Assembler::prefixq(Address adr) {</span>
<span class="udiff-line-removed">-   if (adr.base_needs_rex()) {</span>
<span class="udiff-line-removed">-     if (adr.index_needs_rex()) {</span>
<span class="udiff-line-removed">-       prefix(REX_WXB);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       prefix(REX_WB);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     if (adr.index_needs_rex()) {</span>
<span class="udiff-line-removed">-       prefix(REX_WX);</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       prefix(REX_W);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void Assembler::prefix(Address adr, Register reg, bool byteinst) {
    if (reg-&gt;encoding() &lt; 8) {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
          prefix(REX_XB);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8408,11 +7816,11 @@</span>
          prefix(REX_B);
        }
      } else {
        if (adr.index_needs_rex()) {
          prefix(REX_X);
<span class="udiff-line-modified-removed">-       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4 ) {</span>
<span class="udiff-line-modified-added">+       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4) {</span>
          prefix(REX);
        }
      }
    } else {
      if (adr.base_needs_rex()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8429,70 +7837,121 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-modified-removed">- void Assembler::prefixq(Address adr, Register src) {</span>
<span class="udiff-line-modified-removed">-   if (src-&gt;encoding() &lt; 8) {</span>
<span class="udiff-line-modified-added">+ void Assembler::prefix(Address adr, XMMRegister reg) {</span>
<span class="udiff-line-modified-added">+   if (reg-&gt;encoding() &lt; 8) {</span>
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_WXB);</span>
<span class="udiff-line-modified-added">+         prefix(REX_XB);</span>
        } else {
<span class="udiff-line-modified-removed">-         prefix(REX_WB);</span>
<span class="udiff-line-modified-added">+         prefix(REX_B);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_WX);</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         prefix(REX_W);</span>
<span class="udiff-line-modified-added">+         prefix(REX_X);</span>
        }
      }
    } else {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_WRXB);</span>
<span class="udiff-line-modified-added">+         prefix(REX_RXB);</span>
        } else {
<span class="udiff-line-modified-removed">-         prefix(REX_WRB);</span>
<span class="udiff-line-modified-added">+         prefix(REX_RB);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_WRX);</span>
<span class="udiff-line-modified-added">+         prefix(REX_RX);</span>
        } else {
<span class="udiff-line-modified-removed">-         prefix(REX_WR);</span>
<span class="udiff-line-modified-added">+         prefix(REX_R);</span>
        }
      }
    }
  }
  
<span class="udiff-line-modified-removed">- void Assembler::prefix(Address adr, XMMRegister reg) {</span>
<span class="udiff-line-modified-removed">-   if (reg-&gt;encoding() &lt; 8) {</span>
<span class="udiff-line-modified-added">+ int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {</span>
<span class="udiff-line-modified-added">+   if (reg_enc &gt;= 8) {</span>
<span class="udiff-line-added">+     prefix(REX_B);</span>
<span class="udiff-line-added">+     reg_enc -= 8;</span>
<span class="udiff-line-added">+   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {</span>
<span class="udiff-line-added">+     prefix(REX);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return reg_enc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {</span>
<span class="udiff-line-added">+   if (dst_enc &lt; 8) {</span>
<span class="udiff-line-added">+     if (src_enc &gt;= 8) {</span>
<span class="udiff-line-added">+       prefix(REX_B);</span>
<span class="udiff-line-added">+       src_enc -= 8;</span>
<span class="udiff-line-added">+     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {</span>
<span class="udiff-line-added">+       prefix(REX);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     if (src_enc &lt; 8) {</span>
<span class="udiff-line-added">+       prefix(REX_R);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       prefix(REX_RB);</span>
<span class="udiff-line-added">+       src_enc -= 8;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     dst_enc -= 8;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int8_t Assembler::get_prefixq(Address adr) {</span>
<span class="udiff-line-added">+   int8_t prfx = get_prefixq(adr, rax);</span>
<span class="udiff-line-added">+   assert(REX_W &lt;= prfx &amp;&amp; prfx &lt;= REX_WXB, &quot;must be&quot;);</span>
<span class="udiff-line-added">+   return prfx;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int8_t Assembler::get_prefixq(Address adr, Register src) {</span>
<span class="udiff-line-added">+   int8_t prfx = (int8_t)(REX_W +</span>
<span class="udiff-line-added">+                          ((int)adr.base_needs_rex()) +</span>
<span class="udiff-line-added">+                          ((int)adr.index_needs_rex() &lt;&lt; 1) +</span>
<span class="udiff-line-added">+                          ((int)(src-&gt;encoding() &gt;= 8) &lt;&lt; 2));</span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+   if (src-&gt;encoding() &lt; 8) {</span>
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_XB);</span>
<span class="udiff-line-modified-added">+         assert(prfx == REX_WXB, &quot;must be&quot;);</span>
        } else {
<span class="udiff-line-modified-removed">-         prefix(REX_B);</span>
<span class="udiff-line-modified-added">+         assert(prfx == REX_WB, &quot;must be&quot;);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_X);</span>
<span class="udiff-line-modified-added">+         assert(prfx == REX_WX, &quot;must be&quot;);</span>
<span class="udiff-line-added">+       } else {</span>
<span class="udiff-line-added">+         assert(prfx == REX_W, &quot;must be&quot;);</span>
        }
      }
    } else {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_RXB);</span>
<span class="udiff-line-modified-added">+         assert(prfx == REX_WRXB, &quot;must be&quot;);</span>
        } else {
<span class="udiff-line-modified-removed">-         prefix(REX_RB);</span>
<span class="udiff-line-modified-added">+         assert(prfx == REX_WRB, &quot;must be&quot;);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="udiff-line-modified-removed">-         prefix(REX_RX);</span>
<span class="udiff-line-modified-added">+         assert(prfx == REX_WRX, &quot;must be&quot;);</span>
        } else {
<span class="udiff-line-modified-removed">-         prefix(REX_R);</span>
<span class="udiff-line-modified-added">+         assert(prfx == REX_WR, &quot;must be&quot;);</span>
        }
      }
    }
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   return prfx;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Assembler::prefixq(Address adr) {</span>
<span class="udiff-line-added">+   emit_int8(get_prefixq(adr));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Assembler::prefixq(Address adr, Register src) {</span>
<span class="udiff-line-added">+   emit_int8(get_prefixq(adr, src));</span>
  }
  
  void Assembler::prefixq(Address adr, XMMRegister src) {
    if (src-&gt;encoding() &lt; 8) {
      if (adr.base_needs_rex()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8523,19 +7982,48 @@</span>
        }
      }
    }
  }
  
<span class="udiff-line-added">+ int Assembler::prefixq_and_encode(int reg_enc) {</span>
<span class="udiff-line-added">+   if (reg_enc &lt; 8) {</span>
<span class="udiff-line-added">+     prefix(REX_W);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     prefix(REX_WB);</span>
<span class="udiff-line-added">+     reg_enc -= 8;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return reg_enc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {</span>
<span class="udiff-line-added">+   if (dst_enc &lt; 8) {</span>
<span class="udiff-line-added">+     if (src_enc &lt; 8) {</span>
<span class="udiff-line-added">+       prefix(REX_W);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       prefix(REX_WB);</span>
<span class="udiff-line-added">+       src_enc -= 8;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     if (src_enc &lt; 8) {</span>
<span class="udiff-line-added">+       prefix(REX_WR);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       prefix(REX_WRB);</span>
<span class="udiff-line-added">+       src_enc -= 8;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     dst_enc -= 8;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void Assembler::adcq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
    emit_arith(0x81, 0xD0, dst, imm32);
  }
  
  void Assembler::adcq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x13);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x13);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::adcq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8543,61 +8031,58 @@</span>
  }
  
  void Assembler::addq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
<span class="udiff-line-modified-removed">-   emit_arith_operand(0x81, rax, dst,imm32);</span>
<span class="udiff-line-modified-added">+   emit_arith_operand(0x81, rax, dst, imm32);</span>
  }
  
  void Assembler::addq(Address dst, Register src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst, src);</span>
<span class="udiff-line-removed">-   emit_int8(0x01);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst, src), 0x01);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::addq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
    emit_arith(0x81, 0xC0, dst, imm32);
  }
  
  void Assembler::addq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x03);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x03);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::addq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x03, 0xC0, dst, src);
  }
  
  void Assembler::adcxq(Register dst, Register src) {
    //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x66);</span>
<span class="udiff-line-modified-added">+   emit_int8(0x66);</span>
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x38);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF6);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F,</span>
<span class="udiff-line-modified-added">+              0x38,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xF6,</span>
<span class="udiff-line-modified-added">+              (0xC0 | encode));</span>
  }
  
  void Assembler::adoxq(Register dst, Register src) {
    //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x38);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF6);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int32(0x0F,</span>
<span class="udiff-line-modified-added">+              0x38,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xF6,</span>
<span class="udiff-line-modified-added">+              (0xC0 | encode));</span>
  }
  
  void Assembler::andq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x81);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>
    emit_operand(rsp, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::andq(Register dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8605,12 +8090,11 @@</span>
    emit_arith(0x81, 0xE0, dst, imm32);
  }
  
  void Assembler::andq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x23);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x23);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::andq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8619,12 +8103,11 @@</span>
  
  void Assembler::andnq(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF2);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::andnq(Register dst, Register src1, Address src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8634,34 +8117,28 @@</span>
    emit_operand(dst, src2);
  }
  
  void Assembler::bsfq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBC);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>
  }
  
  void Assembler::bsrq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>
  }
  
  void Assembler::bswapq(Register reg) {
    int encode = prefixq_and_encode(reg-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (0xC8 | encode));</span>
  }
  
  void Assembler::blsiq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsiq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8673,12 +8150,11 @@</span>
  
  void Assembler::blsmskq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsmskq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8690,12 +8166,11 @@</span>
  
  void Assembler::blsrq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsrq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8704,19 +8179,17 @@</span>
    emit_int8((unsigned char)0xF3);
    emit_operand(rcx, src);
  }
  
  void Assembler::cdqq() {
<span class="udiff-line-modified-removed">-   prefix(REX_W);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x99);</span>
<span class="udiff-line-modified-added">+   emit_int16(REX_W, (unsigned char)0x99);</span>
  }
  
  void Assembler::clflush(Address adr) {
    assert(VM_Version::supports_clflush(), &quot;should do&quot;);
    prefix(adr);
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xAE);</span>
    emit_operand(rdi, adr);
  }
  
  void Assembler::clflushopt(Address adr) {
    assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8725,13 +8198,12 @@</span>
    assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
    assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
    // instruction prefix is 0x66
    emit_int8(0x66);
    prefix(adr);
<span class="udiff-line-modified-removed">-   // opcode family is 0x0f 0xAE</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+   // opcode family is 0x0F 0xAE</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xAE);</span>
    // extended opcode byte is 7 == rdi
    emit_operand(rdi, adr);
  }
  
  void Assembler::clwb(Address adr) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8742,35 +8214,29 @@</span>
    assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
    // instruction prefix is 0x66
    emit_int8(0x66);
    prefix(adr);
    // opcode family is 0x0f 0xAE
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+   emit_int16(0x0F, (unsigned char)0xAE);</span>
    // extended opcode byte is 6 == rsi
    emit_operand(rsi, adr);
  }
  
  void Assembler::cmovq(Condition cc, Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x40 | cc);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (0x40 | cc), (0xC0 | encode));</span>
  }
  
  void Assembler::cmovq(Condition cc, Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x40 | cc);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src, dst), 0x0F, (0x40 | cc));</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x81);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>
    emit_operand(rdi, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::cmpq(Register dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8778,41 +8244,36 @@</span>
    emit_arith(0x81, 0xF8, dst, imm32);
  }
  
  void Assembler::cmpq(Address dst, Register src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst, src);</span>
<span class="udiff-line-removed">-   emit_int8(0x3B);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst, src), 0x3B);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::cmpq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x3B, 0xC0, dst, src);
  }
  
<span class="udiff-line-modified-removed">- void Assembler::cmpq(Register dst, Address  src) {</span>
<span class="udiff-line-modified-added">+ void Assembler::cmpq(Register dst, Address src) {</span>
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x3B);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x3B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpxchgq(Register reg, Address adr) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(adr, reg);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB1);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(adr, reg), 0x0F, (unsigned char)0xB1);</span>
    emit_operand(reg, adr);
  }
  
  void Assembler::cvtsi2sdq(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2A);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2sdq(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8836,158 +8297,130 @@</span>
  void Assembler::cvttsd2siq(Register dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    // F2 REX.W 0F 2C /r
    // CVTTSD2SI r64, xmm1/m64
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF2);</span>
<span class="udiff-line-removed">-   prefix(REX_W);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8(0x2C);</span>
<span class="udiff-line-modified-added">+   emit_int32((unsigned char)0xF2, REX_W, 0x0F, 0x2C);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::cvttss2siq(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x2C);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
    // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFF, (0xC8 | encode));</span>
  }
  
  void Assembler::decq(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-removed">-   emit_int8(0xC8 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFF, 0xC8 | encode);</span>
  }
  
  void Assembler::decq(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>
    emit_operand(rcx, dst);
  }
  
  void Assembler::fxrstor(Address src) {
<span class="udiff-line-modified-removed">-   prefixq(src);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(1), src);
  }
  
  void Assembler::xrstor(Address src) {
<span class="udiff-line-modified-removed">-   prefixq(src);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(5), src);
  }
  
  void Assembler::fxsave(Address dst) {
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(0), dst);
  }
  
  void Assembler::xsave(Address dst) {
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(4), dst);
  }
  
  void Assembler::idivq(Register src) {
    int encode = prefixq_and_encode(src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>
  }
  
  void Assembler::imulq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xAF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xAF, (0xC0 | encode));</span>
  }
  
  void Assembler::imulq(Register dst, Register src, int value) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    if (is8bit(value)) {
<span class="udiff-line-modified-removed">-     emit_int8(0x6B);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(value &amp; 0xFF);</span>
<span class="udiff-line-modified-added">+     emit_int24(0x6B, (0xC0 | encode), (value &amp; 0xFF));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8(0x69);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16(0x69, (0xC0 | encode));</span>
      emit_int32(value);
    }
  }
  
  void Assembler::imulq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char) 0xAF);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src, dst), 0x0F, (unsigned char)0xAF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::incl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>
  }
  
  void Assembler::incq(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>
  }
  
  void Assembler::incq(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>
    emit_operand(rax, dst);
  }
  
  void Assembler::lea(Register dst, Address src) {
    leaq(dst, src);
  }
  
  void Assembler::leaq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x8D);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), (unsigned char)0x8D);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::mov64(Register dst, int64_t imm64) {
    InstructionMark im(this);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xB8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8(0xB8 | encode);</span>
    emit_int64(imm64);
  }
  
  void Assembler::mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8997,11 +8430,11 @@</span>
  }
  
  void Assembler::mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xB8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8(0xB8 | encode);</span>
    emit_data((int)imm32, rspec, narrow_oop_operand);
  }
  
  void Assembler::mov_narrow_oop(Address dst, int32_t imm32,  RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9012,12 +8445,11 @@</span>
  }
  
  void Assembler::cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(src1-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x81);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x81, (0xF8 | encode));</span>
    emit_data((int)imm32, rspec, narrow_oop_operand);
  }
  
  void Assembler::cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9029,204 +8461,182 @@</span>
  
  void Assembler::lzcntq(Register dst, Register src) {
    assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBD);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>
  }
  
  void Assembler::movdq(XMMRegister dst, Register src) {
    // table D-1 says MMX/SSE2
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x6E);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x6E, (0xC0 | encode));</span>
  }
  
  void Assembler::movdq(Register dst, XMMRegister src) {
    // table D-1 says MMX/SSE2
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    // swap src/dst to get correct prefix
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8(0x7E);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x7E,</span>
<span class="udiff-line-modified-added">+              (0xC0 | encode));</span>
  }
  
  void Assembler::movq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x8B);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x8B,</span>
<span class="udiff-line-modified-added">+              (0xC0 | encode));</span>
  }
  
  void Assembler::movq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x8B);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), (unsigned char)0x8B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movq(Address dst, Register src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst, src);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x89);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst, src), (unsigned char)0x89);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::movsbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xBE);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src, dst),</span>
<span class="udiff-line-modified-added">+              0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xBE);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movsbq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBE);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>
  }
  
  void Assembler::movslq(Register dst, int32_t imm32) {
    // dbx shows movslq(rcx, 3) as movq     $0x0000000049000000,(%rbx)
    // and movslq(r8, 3); as movl     $0x0000000048000000,(%rbx)
    // as a result we shouldn&#39;t use until tested at runtime...
    ShouldNotReachHere();
    InstructionMark im(this);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)(0xC7 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int8(0xC7 | encode);</span>
    emit_int32(imm32);
  }
  
  void Assembler::movslq(Address dst, int32_t imm32) {
    assert(is_simm32(imm32), &quot;lost bits&quot;);
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xC7);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst), (unsigned char)0xC7);</span>
    emit_operand(rax, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::movslq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x63);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x63);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movslq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x63);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16(0x63, (0xC0 | encode));</span>
  }
  
  void Assembler::movswq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xBF);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src, dst),</span>
<span class="udiff-line-modified-added">+              0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xBF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movswq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xBF);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>
  }
  
  void Assembler::movzbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xB6);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src, dst),</span>
<span class="udiff-line-modified-added">+              0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xB6);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzbq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB6);</span>
<span class="udiff-line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xB6, (0xC0 | encode));</span>
  }
  
  void Assembler::movzwq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xB7);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(src, dst),</span>
<span class="udiff-line-modified-added">+              0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xB7);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzwq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int24(0x0F, (unsigned char)0xB7, (0xC0 | encode));</span>
  }
  
  void Assembler::mulq(Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src), (unsigned char)0xF7);</span>
    emit_operand(rsp, src);
  }
  
  void Assembler::mulq(Register src) {
    int encode = prefixq_and_encode(src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>
  }
  
  void Assembler::mulxq(Register dst1, Register dst2, Register src) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst1-&gt;encoding(), dst2-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF6);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF6, (0xC0 | encode));</span>
  }
  
  void Assembler::negq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xD8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>
  }
  
  void Assembler::notq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>
  }
  
  void Assembler::btsq(Address dst, int imm8) {
    assert(isByte(imm8), &quot;not a byte&quot;);
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xBA);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(dst),</span>
<span class="udiff-line-modified-added">+              0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xBA);</span>
    emit_operand(rbp /* 5 */, dst, 1);
    emit_int8(imm8);
  }
  
  void Assembler::btrq(Address dst, int imm8) {
    assert(isByte(imm8), &quot;not a byte&quot;);
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xBA);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(dst),</span>
<span class="udiff-line-modified-added">+              0x0F,</span>
<span class="udiff-line-modified-added">+              (unsigned char)0xBA);</span>
    emit_operand(rsi /* 6 */, dst, 1);
    emit_int8(imm8);
  }
  
  void Assembler::orq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x81);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>
    emit_operand(rcx, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::orq(Register dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9234,21 +8644,114 @@</span>
    emit_arith(0x81, 0xC8, dst, imm32);
  }
  
  void Assembler::orq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x0B);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x0B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::orq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x0B, 0xC0, dst, src);
  }
  
<span class="udiff-line-added">+ void Assembler::popcntq(Register dst, Address src) {</span>
<span class="udiff-line-added">+   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="udiff-line-added">+   InstructionMark im(this);</span>
<span class="udiff-line-added">+   emit_int32((unsigned char)0xF3,</span>
<span class="udiff-line-added">+              get_prefixq(src, dst),</span>
<span class="udiff-line-added">+              0x0F,</span>
<span class="udiff-line-added">+              (unsigned char)0xB8);</span>
<span class="udiff-line-added">+   emit_operand(dst, src);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Assembler::popcntq(Register dst, Register src) {</span>
<span class="udiff-line-added">+   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="udiff-line-added">+   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-added">+   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());</span>
<span class="udiff-line-added">+   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Assembler::popq(Address dst) {</span>
<span class="udiff-line-added">+   InstructionMark im(this);</span>
<span class="udiff-line-added">+   emit_int16(get_prefixq(dst), (unsigned char)0x8F);</span>
<span class="udiff-line-added">+   emit_operand(rax, dst);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Precomputable: popa, pusha, vzeroupper</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // The result of these routines are invariant from one invocation to another</span>
<span class="udiff-line-added">+ // invocation for the duration of a run. Caching the result on bootstrap</span>
<span class="udiff-line-added">+ // and copying it out on subsequent invocations can thus be beneficial</span>
<span class="udiff-line-added">+ static bool     precomputed = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static u_char* popa_code  = NULL;</span>
<span class="udiff-line-added">+ static int     popa_len   = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static u_char* pusha_code = NULL;</span>
<span class="udiff-line-added">+ static int     pusha_len  = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static u_char* vzup_code  = NULL;</span>
<span class="udiff-line-added">+ static int     vzup_len   = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Assembler::precompute_instructions() {</span>
<span class="udiff-line-added">+   assert(!Universe::is_fully_initialized(), &quot;must still be single threaded&quot;);</span>
<span class="udiff-line-added">+   guarantee(!precomputed, &quot;only once&quot;);</span>
<span class="udiff-line-added">+   precomputed = true;</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Make a temporary buffer big enough for the routines we&#39;re capturing</span>
<span class="udiff-line-added">+   int size = 256;</span>
<span class="udiff-line-added">+   char* tmp_code = NEW_RESOURCE_ARRAY(char, size);</span>
<span class="udiff-line-added">+   CodeBuffer buffer((address)tmp_code, size);</span>
<span class="udiff-line-added">+   MacroAssembler masm(&amp;buffer);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   address begin_popa  = masm.code_section()-&gt;end();</span>
<span class="udiff-line-added">+   masm.popa_uncached();</span>
<span class="udiff-line-added">+   address end_popa    = masm.code_section()-&gt;end();</span>
<span class="udiff-line-added">+   masm.pusha_uncached();</span>
<span class="udiff-line-added">+   address end_pusha   = masm.code_section()-&gt;end();</span>
<span class="udiff-line-added">+   masm.vzeroupper_uncached();</span>
<span class="udiff-line-added">+   address end_vzup    = masm.code_section()-&gt;end();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Save the instructions to permanent buffers.</span>
<span class="udiff-line-added">+   popa_len = (int)(end_popa - begin_popa);</span>
<span class="udiff-line-added">+   popa_code = NEW_C_HEAP_ARRAY(u_char, popa_len, mtInternal);</span>
<span class="udiff-line-added">+   memcpy(popa_code, begin_popa, popa_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   pusha_len = (int)(end_pusha - end_popa);</span>
<span class="udiff-line-added">+   pusha_code = NEW_C_HEAP_ARRAY(u_char, pusha_len, mtInternal);</span>
<span class="udiff-line-added">+   memcpy(pusha_code, end_popa, pusha_len);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   vzup_len = (int)(end_vzup - end_pusha);</span>
<span class="udiff-line-added">+   if (vzup_len &gt; 0) {</span>
<span class="udiff-line-added">+     vzup_code = NEW_C_HEAP_ARRAY(u_char, vzup_len, mtInternal);</span>
<span class="udiff-line-added">+     memcpy(vzup_code, end_pusha, vzup_len);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     vzup_code = pusha_code; // dummy</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(masm.code()-&gt;total_oop_size() == 0 &amp;&amp;</span>
<span class="udiff-line-added">+          masm.code()-&gt;total_metadata_size() == 0 &amp;&amp;</span>
<span class="udiff-line-added">+          masm.code()-&gt;total_relocation_size() == 0,</span>
<span class="udiff-line-added">+          &quot;pre-computed code can&#39;t reference oops, metadata or contain relocations&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void emit_copy(CodeSection* code_section, u_char* src, int src_len) {</span>
<span class="udiff-line-added">+   assert(src != NULL, &quot;code to copy must have been pre-computed&quot;);</span>
<span class="udiff-line-added">+   assert(code_section-&gt;limit() - code_section-&gt;end() &gt; src_len, &quot;code buffer not large enough&quot;);</span>
<span class="udiff-line-added">+   address end = code_section-&gt;end();</span>
<span class="udiff-line-added">+   memcpy(end, src, src_len);</span>
<span class="udiff-line-added">+   code_section-&gt;set_end(end + src_len);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void Assembler::popa() { // 64bit
<span class="udiff-line-added">+   emit_copy(code_section(), popa_code, popa_len);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void Assembler::popa_uncached() { // 64bit</span>
    movq(r15, Address(rsp, 0));
    movq(r14, Address(rsp, wordSize));
    movq(r13, Address(rsp, 2 * wordSize));
    movq(r12, Address(rsp, 3 * wordSize));
    movq(r11, Address(rsp, 4 * wordSize));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9265,37 +8768,15 @@</span>
    movq(rax, Address(rsp, 15 * wordSize));
  
    addq(rsp, 16 * wordSize);
  }
  
<span class="udiff-line-modified-removed">- void Assembler::popcntq(Register dst, Address src) {</span>
<span class="udiff-line-modified-removed">-   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="udiff-line-removed">-   InstructionMark im(this);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="udiff-line-removed">-   emit_operand(dst, src);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Assembler::popcntq(Register dst, Register src) {</span>
<span class="udiff-line-removed">-   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="udiff-line-removed">-   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Assembler::popq(Address dst) {</span>
<span class="udiff-line-removed">-   InstructionMark im(this);</span>
<span class="udiff-line-removed">-   prefixq(dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x8F);</span>
<span class="udiff-line-removed">-   emit_operand(rax, dst);</span>
<span class="udiff-line-modified-added">+ void Assembler::pusha() { // 64bit</span>
<span class="udiff-line-modified-added">+   emit_copy(code_section(), pusha_code, pusha_len);</span>
  }
  
<span class="udiff-line-modified-removed">- void Assembler::pusha() { // 64bit</span>
<span class="udiff-line-modified-added">+ void Assembler::pusha_uncached() { // 64bit</span>
    // we have to store original rsp.  ABI says that 128 bytes
    // below rsp are local scratch.
    movq(Address(rsp, -5 * wordSize), rsp);
  
    subq(rsp, 16 * wordSize);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9316,91 +8797,77 @@</span>
    movq(Address(rsp, 2 * wordSize), r13);
    movq(Address(rsp, wordSize), r14);
    movq(Address(rsp, 0), r15);
  }
  
<span class="udiff-line-added">+ void Assembler::vzeroupper() {</span>
<span class="udiff-line-added">+   emit_copy(code_section(), vzup_code, vzup_len);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void Assembler::pushq(Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xFF);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src), (unsigned char)0xFF);</span>
    emit_operand(rsi, src);
  }
  
  void Assembler::rclq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>
    }
  }
  
  void Assembler::rcrq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xD8 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xD8 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xD8 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xD8 | encode), imm8);</span>
    }
  }
  
  void Assembler::rorq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xC8 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xC8 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xc8 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xc8 | encode), imm8);</span>
    }
  }
  
  void Assembler::rorxq(Register dst, Register src, int imm8) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF0);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::rorxd(Register dst, Register src, int imm8) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xF0);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::sarq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>
    }
  }
  
  void Assembler::sarq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>
  }
  
  void Assembler::sbbq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9412,12 +8879,11 @@</span>
    emit_arith(0x81, 0xD8, dst, imm32);
  }
  
  void Assembler::sbbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x1B);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x1B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::sbbq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9426,49 +8892,41 @@</span>
  
  void Assembler::shlq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xD1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>
    } else {
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-removed">-     emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>
    }
  }
  
  void Assembler::shlq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>
  }
  
  void Assembler::shrq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="udiff-line-removed">-   emit_int8(imm8);</span>
<span class="udiff-line-modified-added">+   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>
  }
  
  void Assembler::shrq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0xD3);</span>
<span class="udiff-line-removed">-   emit_int8(0xE8 | encode);</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0xD3, 0xE8 | encode);</span>
  }
  
  void Assembler::subq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
    emit_arith_operand(0x81, rbp, dst, imm32);
  }
  
  void Assembler::subq(Address dst, Register src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst, src);</span>
<span class="udiff-line-removed">-   emit_int8(0x29);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(dst, src), 0x29);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::subq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9481,12 +8939,11 @@</span>
    emit_arith_imm32(0x81, 0xE8, dst, imm32);
  }
  
  void Assembler::subq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x2B);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x2B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::subq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9497,16 +8954,14 @@</span>
    // not using emit_arith because test
    // doesn&#39;t support sign-extension of
    // 8bit operands
    int encode = dst-&gt;encoding();
    if (encode == 0) {
<span class="udiff-line-modified-removed">-     prefix(REX_W);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)0xA9);</span>
<span class="udiff-line-modified-added">+     emit_int16(REX_W, (unsigned char)0xA9);</span>
    } else {
      encode = prefixq_and_encode(encode);
<span class="udiff-line-modified-removed">-     emit_int8((unsigned char)0xF7);</span>
<span class="udiff-line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="udiff-line-modified-added">+     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
    }
    emit_int32(imm32);
  }
  
  void Assembler::testq(Register dst, Register src) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -9514,44 +8969,38 @@</span>
    emit_arith(0x85, 0xC0, dst, src);
  }
  
  void Assembler::testq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x85);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), (unsigned char)0x85);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xaddq(Address dst, Register src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(dst, src);</span>
<span class="udiff-line-removed">-   emit_int8(0x0F);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0xC1);</span>
<span class="udiff-line-modified-added">+   emit_int24(get_prefixq(dst, src), 0x0F, (unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xchgq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)0x87);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), (unsigned char)0x87);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xchgq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="udiff-line-modified-removed">-   emit_int8((unsigned char)0x87);</span>
<span class="udiff-line-removed">-   emit_int8((unsigned char)(0xc0 | encode));</span>
<span class="udiff-line-modified-added">+   emit_int16((unsigned char)0x87, (0xc0 | encode));</span>
  }
  
  void Assembler::xorq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x33, 0xC0, dst, src);
  }
  
  void Assembler::xorq(Register dst, Address src) {
    InstructionMark im(this);
<span class="udiff-line-modified-removed">-   prefixq(src, dst);</span>
<span class="udiff-line-removed">-   emit_int8(0x33);</span>
<span class="udiff-line-modified-added">+   emit_int16(get_prefixq(src, dst), 0x33);</span>
    emit_operand(dst, src);
  }
  
  #endif // !LP64
</pre>
<center><a href="../sparc/vm_version_sparc.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
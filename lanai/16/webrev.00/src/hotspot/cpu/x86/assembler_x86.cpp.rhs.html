<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;asm/assembler.inline.hpp&quot;
  28 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;prims/methodHandles.hpp&quot;
  33 #include &quot;runtime/biasedLocking.hpp&quot;
  34 #include &quot;runtime/objectMonitor.hpp&quot;
  35 #include &quot;runtime/os.hpp&quot;
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/stubRoutines.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 
  40 #ifdef PRODUCT
  41 #define BLOCK_COMMENT(str) /* nothing */
  42 #define STOP(error) stop(error)
  43 #else
  44 #define BLOCK_COMMENT(str) block_comment(str)
  45 #define STOP(error) block_comment(error); stop(error)
  46 #endif
  47 
  48 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  49 // Implementation of AddressLiteral
  50 
  51 // A 2-D table for managing compressed displacement(disp8) on EVEX enabled platforms.
  52 unsigned char tuple_table[Assembler::EVEX_ETUP + 1][Assembler::AVX_512bit + 1] = {
  53   // -----------------Table 4.5 -------------------- //
  54   16, 32, 64,  // EVEX_FV(0)
  55   4,  4,  4,   // EVEX_FV(1) - with Evex.b
  56   16, 32, 64,  // EVEX_FV(2) - with Evex.w
  57   8,  8,  8,   // EVEX_FV(3) - with Evex.w and Evex.b
  58   8,  16, 32,  // EVEX_HV(0)
  59   4,  4,  4,   // EVEX_HV(1) - with Evex.b
  60   // -----------------Table 4.6 -------------------- //
  61   16, 32, 64,  // EVEX_FVM(0)
  62   1,  1,  1,   // EVEX_T1S(0)
  63   2,  2,  2,   // EVEX_T1S(1)
  64   4,  4,  4,   // EVEX_T1S(2)
  65   8,  8,  8,   // EVEX_T1S(3)
  66   4,  4,  4,   // EVEX_T1F(0)
  67   8,  8,  8,   // EVEX_T1F(1)
  68   8,  8,  8,   // EVEX_T2(0)
  69   0,  16, 16,  // EVEX_T2(1)
  70   0,  16, 16,  // EVEX_T4(0)
  71   0,  0,  32,  // EVEX_T4(1)
  72   0,  0,  32,  // EVEX_T8(0)
  73   8,  16, 32,  // EVEX_HVM(0)
  74   4,  8,  16,  // EVEX_QVM(0)
  75   2,  4,  8,   // EVEX_OVM(0)
  76   16, 16, 16,  // EVEX_M128(0)
  77   8,  32, 64,  // EVEX_DUP(0)
  78   0,  0,  0    // EVEX_NTUP
  79 };
  80 
  81 AddressLiteral::AddressLiteral(address target, relocInfo::relocType rtype) {
  82   _is_lval = false;
  83   _target = target;
  84   switch (rtype) {
  85   case relocInfo::oop_type:
  86   case relocInfo::metadata_type:
  87     // Oops are a special case. Normally they would be their own section
  88     // but in cases like icBuffer they are literals in the code stream that
  89     // we don&#39;t have a section for. We use none so that we get a literal address
  90     // which is always patchable.
  91     break;
  92   case relocInfo::external_word_type:
  93     _rspec = external_word_Relocation::spec(target);
  94     break;
  95   case relocInfo::internal_word_type:
  96     _rspec = internal_word_Relocation::spec(target);
  97     break;
  98   case relocInfo::opt_virtual_call_type:
  99     _rspec = opt_virtual_call_Relocation::spec();
 100     break;
 101   case relocInfo::static_call_type:
 102     _rspec = static_call_Relocation::spec();
 103     break;
 104   case relocInfo::runtime_call_type:
 105     _rspec = runtime_call_Relocation::spec();
 106     break;
 107   case relocInfo::poll_type:
 108   case relocInfo::poll_return_type:
 109     _rspec = Relocation::spec_simple(rtype);
 110     break;
 111   case relocInfo::none:
 112     break;
 113   default:
 114     ShouldNotReachHere();
 115     break;
 116   }
 117 }
 118 
 119 // Implementation of Address
 120 
 121 #ifdef _LP64
 122 
 123 Address Address::make_array(ArrayAddress adr) {
 124   // Not implementable on 64bit machines
 125   // Should have been handled higher up the call chain.
 126   ShouldNotReachHere();
 127   return Address();
 128 }
 129 
 130 // exceedingly dangerous constructor
 131 Address::Address(int disp, address loc, relocInfo::relocType rtype) {
 132   _base  = noreg;
 133   _index = noreg;
 134   _scale = no_scale;
 135   _disp  = disp;
 136   _xmmindex = xnoreg;
 137   _isxmmindex = false;
 138   switch (rtype) {
 139     case relocInfo::external_word_type:
 140       _rspec = external_word_Relocation::spec(loc);
 141       break;
 142     case relocInfo::internal_word_type:
 143       _rspec = internal_word_Relocation::spec(loc);
 144       break;
 145     case relocInfo::runtime_call_type:
 146       // HMM
 147       _rspec = runtime_call_Relocation::spec();
 148       break;
 149     case relocInfo::poll_type:
 150     case relocInfo::poll_return_type:
 151       _rspec = Relocation::spec_simple(rtype);
 152       break;
 153     case relocInfo::none:
 154       break;
 155     default:
 156       ShouldNotReachHere();
 157   }
 158 }
 159 #else // LP64
 160 
 161 Address Address::make_array(ArrayAddress adr) {
 162   AddressLiteral base = adr.base();
 163   Address index = adr.index();
 164   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 165   Address array(index._base, index._index, index._scale, (intptr_t) base.target());
 166   array._rspec = base._rspec;
 167   return array;
 168 }
 169 
 170 // exceedingly dangerous constructor
 171 Address::Address(address loc, RelocationHolder spec) {
 172   _base  = noreg;
 173   _index = noreg;
 174   _scale = no_scale;
 175   _disp  = (intptr_t) loc;
 176   _rspec = spec;
 177   _xmmindex = xnoreg;
 178   _isxmmindex = false;
 179 }
 180 
 181 #endif // _LP64
 182 
 183 
 184 
 185 // Convert the raw encoding form into the form expected by the constructor for
 186 // Address.  An index of 4 (rsp) corresponds to having no index, so convert
 187 // that to noreg for the Address constructor.
 188 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
 189   RelocationHolder rspec;
 190   if (disp_reloc != relocInfo::none) {
 191     rspec = Relocation::spec_simple(disp_reloc);
 192   }
 193   bool valid_index = index != rsp-&gt;encoding();
 194   if (valid_index) {
 195     Address madr(as_Register(base), as_Register(index), (Address::ScaleFactor)scale, in_ByteSize(disp));
 196     madr._rspec = rspec;
 197     return madr;
 198   } else {
 199     Address madr(as_Register(base), noreg, Address::no_scale, in_ByteSize(disp));
 200     madr._rspec = rspec;
 201     return madr;
 202   }
 203 }
 204 
 205 // Implementation of Assembler
 206 
 207 int AbstractAssembler::code_fill_byte() {
 208   return (u_char)&#39;\xF4&#39;; // hlt
 209 }
 210 
 211 // make this go away someday
 212 void Assembler::emit_data(jint data, relocInfo::relocType rtype, int format) {
 213   if (rtype == relocInfo::none)
 214     emit_int32(data);
 215   else
 216     emit_data(data, Relocation::spec_simple(rtype), format);
 217 }
 218 
 219 void Assembler::emit_data(jint data, RelocationHolder const&amp; rspec, int format) {
 220   assert(imm_operand == 0, &quot;default format must be immediate in this file&quot;);
 221   assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
 222   if (rspec.type() !=  relocInfo::none) {
 223     #ifdef ASSERT
 224       check_relocation(rspec, format);
 225     #endif
 226     // Do not use AbstractAssembler::relocate, which is not intended for
 227     // embedded words.  Instead, relocate to the enclosing instruction.
 228 
 229     // hack. call32 is too wide for mask so use disp32
 230     if (format == call32_operand)
 231       code_section()-&gt;relocate(inst_mark(), rspec, disp32_operand);
 232     else
 233       code_section()-&gt;relocate(inst_mark(), rspec, format);
 234   }
 235   emit_int32(data);
 236 }
 237 
 238 static int encode(Register r) {
 239   int enc = r-&gt;encoding();
 240   if (enc &gt;= 8) {
 241     enc -= 8;
 242   }
 243   return enc;
 244 }
 245 
 246 void Assembler::emit_arith_b(int op1, int op2, Register dst, int imm8) {
 247   assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;);
 248   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 249   assert(isByte(imm8), &quot;not a byte&quot;);
 250   assert((op1 &amp; 0x01) == 0, &quot;should be 8bit operation&quot;);
<a name="2" id="anc2"></a><span class="line-modified"> 251   emit_int24(op1, (op2 | encode(dst)), imm8);</span>


 252 }
 253 
 254 
 255 void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {
 256   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 257   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 258   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 259   if (is8bit(imm32)) {
<a name="3" id="anc3"></a><span class="line-modified"> 260     emit_int24(op1 | 0x02,        // set sign bit</span>
<span class="line-modified"> 261                op2 | encode(dst),</span>
<span class="line-modified"> 262                imm32 &amp; 0xFF);</span>
 263   } else {
<a name="4" id="anc4"></a><span class="line-modified"> 264     emit_int16(op1, (op2 | encode(dst)));</span>

 265     emit_int32(imm32);
 266   }
 267 }
 268 
 269 // Force generation of a 4 byte immediate value even if it fits into 8bit
 270 void Assembler::emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32) {
 271   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 272   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 273   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 274   emit_int16(op1, (op2 | encode(dst)));</span>

 275   emit_int32(imm32);
 276 }
 277 
 278 // immediate-to-memory forms
 279 void Assembler::emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32) {
 280   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 281   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 282   if (is8bit(imm32)) {
 283     emit_int8(op1 | 0x02); // set sign bit
 284     emit_operand(rm, adr, 1);
 285     emit_int8(imm32 &amp; 0xFF);
 286   } else {
 287     emit_int8(op1);
 288     emit_operand(rm, adr, 4);
 289     emit_int32(imm32);
 290   }
 291 }
 292 
 293 
 294 void Assembler::emit_arith(int op1, int op2, Register dst, Register src) {
 295   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
<a name="6" id="anc6"></a><span class="line-modified"> 296   emit_int16(op1, (op2 | encode(dst) &lt;&lt; 3 | encode(src)));</span>

 297 }
 298 
 299 
 300 bool Assembler::query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 301                                            int cur_tuple_type, int in_size_in_bits, int cur_encoding) {
 302   int mod_idx = 0;
 303   // We will test if the displacement fits the compressed format and if so
 304   // apply the compression to the displacment iff the result is8bit.
 305   if (VM_Version::supports_evex() &amp;&amp; is_evex_inst) {
 306     switch (cur_tuple_type) {
 307     case EVEX_FV:
 308       if ((cur_encoding &amp; VEX_W) == VEX_W) {
 309         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 3 : 2;
 310       } else {
 311         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 312       }
 313       break;
 314 
 315     case EVEX_HV:
 316       mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 317       break;
 318 
 319     case EVEX_FVM:
 320       break;
 321 
 322     case EVEX_T1S:
 323       switch (in_size_in_bits) {
 324       case EVEX_8bit:
 325         break;
 326 
 327       case EVEX_16bit:
 328         mod_idx = 1;
 329         break;
 330 
 331       case EVEX_32bit:
 332         mod_idx = 2;
 333         break;
 334 
 335       case EVEX_64bit:
 336         mod_idx = 3;
 337         break;
 338       }
 339       break;
 340 
 341     case EVEX_T1F:
 342     case EVEX_T2:
 343     case EVEX_T4:
 344       mod_idx = (in_size_in_bits == EVEX_64bit) ? 1 : 0;
 345       break;
 346 
 347     case EVEX_T8:
 348       break;
 349 
 350     case EVEX_HVM:
 351       break;
 352 
 353     case EVEX_QVM:
 354       break;
 355 
 356     case EVEX_OVM:
 357       break;
 358 
 359     case EVEX_M128:
 360       break;
 361 
 362     case EVEX_DUP:
 363       break;
 364 
 365     default:
 366       assert(0, &quot;no valid evex tuple_table entry&quot;);
 367       break;
 368     }
 369 
 370     if (vector_len &gt;= AVX_128bit &amp;&amp; vector_len &lt;= AVX_512bit) {
 371       int disp_factor = tuple_table[cur_tuple_type + mod_idx][vector_len];
 372       if ((disp % disp_factor) == 0) {
 373         int new_disp = disp / disp_factor;
 374         if ((-0x80 &lt;= new_disp &amp;&amp; new_disp &lt; 0x80)) {
 375           disp = new_disp;
 376         }
 377       } else {
 378         return false;
 379       }
 380     }
 381   }
 382   return (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80);
 383 }
 384 
 385 
 386 bool Assembler::emit_compressed_disp_byte(int &amp;disp) {
 387   int mod_idx = 0;
 388   // We will test if the displacement fits the compressed format and if so
 389   // apply the compression to the displacment iff the result is8bit.
 390   if (VM_Version::supports_evex() &amp;&amp; _attributes &amp;&amp; _attributes-&gt;is_evex_instruction()) {
 391     int evex_encoding = _attributes-&gt;get_evex_encoding();
 392     int tuple_type = _attributes-&gt;get_tuple_type();
 393     switch (tuple_type) {
 394     case EVEX_FV:
 395       if ((evex_encoding &amp; VEX_W) == VEX_W) {
 396         mod_idx = ((evex_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 3 : 2;
 397       } else {
 398         mod_idx = ((evex_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 399       }
 400       break;
 401 
 402     case EVEX_HV:
 403       mod_idx = ((evex_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 404       break;
 405 
 406     case EVEX_FVM:
 407       break;
 408 
 409     case EVEX_T1S:
 410       switch (_attributes-&gt;get_input_size()) {
 411       case EVEX_8bit:
 412         break;
 413 
 414       case EVEX_16bit:
 415         mod_idx = 1;
 416         break;
 417 
 418       case EVEX_32bit:
 419         mod_idx = 2;
 420         break;
 421 
 422       case EVEX_64bit:
 423         mod_idx = 3;
 424         break;
 425       }
 426       break;
 427 
 428     case EVEX_T1F:
 429     case EVEX_T2:
 430     case EVEX_T4:
 431       mod_idx = (_attributes-&gt;get_input_size() == EVEX_64bit) ? 1 : 0;
 432       break;
 433 
 434     case EVEX_T8:
 435       break;
 436 
 437     case EVEX_HVM:
 438       break;
 439 
 440     case EVEX_QVM:
 441       break;
 442 
 443     case EVEX_OVM:
 444       break;
 445 
 446     case EVEX_M128:
 447       break;
 448 
 449     case EVEX_DUP:
 450       break;
 451 
 452     default:
 453       assert(0, &quot;no valid evex tuple_table entry&quot;);
 454       break;
 455     }
 456 
 457     int vector_len = _attributes-&gt;get_vector_len();
 458     if (vector_len &gt;= AVX_128bit &amp;&amp; vector_len &lt;= AVX_512bit) {
 459       int disp_factor = tuple_table[tuple_type + mod_idx][vector_len];
 460       if ((disp % disp_factor) == 0) {
 461         int new_disp = disp / disp_factor;
 462         if (is8bit(new_disp)) {
 463           disp = new_disp;
 464         }
 465       } else {
 466         return false;
 467       }
 468     }
 469   }
 470   return is8bit(disp);
 471 }
 472 
 473 
 474 void Assembler::emit_operand(Register reg, Register base, Register index,
 475                              Address::ScaleFactor scale, int disp,
 476                              RelocationHolder const&amp; rspec,
 477                              int rip_relative_correction) {
<a name="7" id="anc7"></a><span class="line-modified"> 478   bool no_relocation = (rspec.type() == relocInfo::none);</span>
 479 
 480   // Encode the registers as needed in the fields they are used in
<a name="8" id="anc8"></a>
 481   int regenc = encode(reg) &lt;&lt; 3;
<a name="9" id="anc9"></a>


 482   if (base-&gt;is_valid()) {
<a name="10" id="anc10"></a><span class="line-added"> 483     int baseenc = encode(base);</span>
 484     if (index-&gt;is_valid()) {
 485       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
 486       // [base + index*scale + disp]
<a name="11" id="anc11"></a><span class="line-modified"> 487       int indexenc = encode(index) &lt;&lt; 3;</span>
<span class="line-added"> 488       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
 489           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {
 490         // [base + index*scale]
 491         // [00 reg 100][ss index base]
 492         assert(index != rsp, &quot;illegal addressing mode&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 493         emit_int16((0x04 | regenc),</span>
<span class="line-modified"> 494                    (scale &lt;&lt; 6 | indexenc | baseenc));</span>
<span class="line-modified"> 495       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
 496         // [base + index*scale + imm8]
 497         // [01 reg 100][ss index base] imm8
 498         assert(index != rsp, &quot;illegal addressing mode&quot;);
<a name="13" id="anc13"></a><span class="line-modified"> 499         emit_int24(0x44 | regenc,</span>
<span class="line-modified"> 500                    scale &lt;&lt; 6 | indexenc | baseenc,</span>
<span class="line-modified"> 501                    disp &amp; 0xFF);</span>
 502       } else {
 503         // [base + index*scale + disp32]
 504         // [10 reg 100][ss index base] disp32
 505         assert(index != rsp, &quot;illegal addressing mode&quot;);
<a name="14" id="anc14"></a><span class="line-modified"> 506         emit_int16(0x84 | regenc,</span>
<span class="line-modified"> 507                    scale &lt;&lt; 6 | indexenc | baseenc);</span>
 508         emit_data(disp, rspec, disp32_operand);
 509       }
 510     } else if (base == rsp LP64_ONLY(|| base == r12)) {
 511       // [rsp + disp]
<a name="15" id="anc15"></a><span class="line-modified"> 512       if (disp == 0 &amp;&amp; no_relocation) {</span>
 513         // [rsp]
 514         // [00 reg 100][00 100 100]
<a name="16" id="anc16"></a><span class="line-modified"> 515         emit_int16(0x04 | regenc,</span>
<span class="line-modified"> 516                    0x24);</span>
<span class="line-modified"> 517       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
 518         // [rsp + imm8]
 519         // [01 reg 100][00 100 100] disp8
<a name="17" id="anc17"></a><span class="line-modified"> 520         emit_int24(0x44 | regenc,</span>
<span class="line-modified"> 521                    0x24,</span>
<span class="line-modified"> 522                    disp &amp; 0xFF);</span>
 523       } else {
 524         // [rsp + imm32]
 525         // [10 reg 100][00 100 100] disp32
<a name="18" id="anc18"></a><span class="line-modified"> 526         emit_int16(0x84 | regenc,</span>
<span class="line-modified"> 527                    0x24);</span>
 528         emit_data(disp, rspec, disp32_operand);
 529       }
 530     } else {
 531       // [base + disp]
 532       assert(base != rsp LP64_ONLY(&amp;&amp; base != r12), &quot;illegal addressing mode&quot;);
<a name="19" id="anc19"></a><span class="line-modified"> 533       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
 534           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {
 535         // [base]
 536         // [00 reg base]
 537         emit_int8(0x00 | regenc | baseenc);
<a name="20" id="anc20"></a><span class="line-modified"> 538       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
 539         // [base + disp8]
 540         // [01 reg base] disp8
<a name="21" id="anc21"></a><span class="line-modified"> 541         emit_int16(0x40 | regenc | baseenc,</span>
<span class="line-modified"> 542                    disp &amp; 0xFF);</span>
 543       } else {
 544         // [base + disp32]
 545         // [10 reg base] disp32
 546         emit_int8(0x80 | regenc | baseenc);
 547         emit_data(disp, rspec, disp32_operand);
 548       }
 549     }
 550   } else {
 551     if (index-&gt;is_valid()) {
 552       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
 553       // [index*scale + disp]
 554       // [00 reg 100][ss index 101] disp32
 555       assert(index != rsp, &quot;illegal addressing mode&quot;);
<a name="22" id="anc22"></a><span class="line-modified"> 556       emit_int16(0x04 | regenc,</span>
<span class="line-modified"> 557                  scale &lt;&lt; 6 | (encode(index) &lt;&lt; 3) | 0x05);</span>
 558       emit_data(disp, rspec, disp32_operand);
<a name="23" id="anc23"></a><span class="line-modified"> 559     } else if (!no_relocation) {</span>
 560       // [disp] (64bit) RIP-RELATIVE (32bit) abs
 561       // [00 000 101] disp32
 562 
 563       emit_int8(0x05 | regenc);
 564       // Note that the RIP-rel. correction applies to the generated
 565       // disp field, but _not_ to the target address in the rspec.
 566 
 567       // disp was created by converting the target address minus the pc
 568       // at the start of the instruction. That needs more correction here.
 569       // intptr_t disp = target - next_ip;
 570       assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
 571       address next_ip = pc() + sizeof(int32_t) + rip_relative_correction;
 572       int64_t adjusted = disp;
 573       // Do rip-rel adjustment for 64bit
 574       LP64_ONLY(adjusted -=  (next_ip - inst_mark()));
 575       assert(is_simm32(adjusted),
 576              &quot;must be 32bit offset (RIP relative address)&quot;);
 577       emit_data((int32_t) adjusted, rspec, disp32_operand);
 578 
 579     } else {
 580       // 32bit never did this, did everything as the rip-rel/disp code above
 581       // [disp] ABSOLUTE
 582       // [00 reg 100][00 100 101] disp32
<a name="24" id="anc24"></a><span class="line-modified"> 583       emit_int16(0x04 | regenc,</span>
<span class="line-modified"> 584                  0x25);</span>
 585       emit_data(disp, rspec, disp32_operand);
 586     }
 587   }
 588 }
 589 
 590 void Assembler::emit_operand(XMMRegister reg, Register base, Register index,
 591                              Address::ScaleFactor scale, int disp,
 592                              RelocationHolder const&amp; rspec) {
 593   if (UseAVX &gt; 2) {
 594     int xreg_enc = reg-&gt;encoding();
 595     if (xreg_enc &gt; 15) {
 596       XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);
 597       emit_operand((Register)new_reg, base, index, scale, disp, rspec);
 598       return;
 599     }
 600   }
 601   emit_operand((Register)reg, base, index, scale, disp, rspec);
 602 }
 603 
 604 void Assembler::emit_operand(XMMRegister reg, Register base, XMMRegister index,
 605                              Address::ScaleFactor scale, int disp,
 606                              RelocationHolder const&amp; rspec) {
 607   if (UseAVX &gt; 2) {
 608     int xreg_enc = reg-&gt;encoding();
 609     int xmmindex_enc = index-&gt;encoding();
 610     XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);
 611     XMMRegister new_index = as_XMMRegister(xmmindex_enc &amp; 0xf);
 612     emit_operand((Register)new_reg, base, (Register)new_index, scale, disp, rspec);
 613   } else {
 614     emit_operand((Register)reg, base, (Register)index, scale, disp, rspec);
 615   }
 616 }
 617 
 618 
 619 // Secret local extension to Assembler::WhichOperand:
 620 #define end_pc_operand (_WhichOperand_limit)
 621 
 622 address Assembler::locate_operand(address inst, WhichOperand which) {
 623   // Decode the given instruction, and return the address of
 624   // an embedded 32-bit operand word.
 625 
 626   // If &quot;which&quot; is disp32_operand, selects the displacement portion
 627   // of an effective address specifier.
 628   // If &quot;which&quot; is imm64_operand, selects the trailing immediate constant.
 629   // If &quot;which&quot; is call32_operand, selects the displacement of a call or jump.
 630   // Caller is responsible for ensuring that there is such an operand,
 631   // and that it is 32/64 bits wide.
 632 
 633   // If &quot;which&quot; is end_pc_operand, find the end of the instruction.
 634 
 635   address ip = inst;
 636   bool is_64bit = false;
 637 
 638   debug_only(bool has_disp32 = false);
 639   int tail_size = 0; // other random bytes (#32, #16, etc.) at end of insn
 640 
 641   again_after_prefix:
 642   switch (0xFF &amp; *ip++) {
 643 
 644   // These convenience macros generate groups of &quot;case&quot; labels for the switch.
 645 #define REP4(x) (x)+0: case (x)+1: case (x)+2: case (x)+3
 646 #define REP8(x) (x)+0: case (x)+1: case (x)+2: case (x)+3: \
 647              case (x)+4: case (x)+5: case (x)+6: case (x)+7
 648 #define REP16(x) REP8((x)+0): \
 649               case REP8((x)+8)
 650 
 651   case CS_segment:
 652   case SS_segment:
 653   case DS_segment:
 654   case ES_segment:
 655   case FS_segment:
 656   case GS_segment:
 657     // Seems dubious
 658     LP64_ONLY(assert(false, &quot;shouldn&#39;t have that prefix&quot;));
 659     assert(ip == inst+1, &quot;only one prefix allowed&quot;);
 660     goto again_after_prefix;
 661 
 662   case 0x67:
 663   case REX:
 664   case REX_B:
 665   case REX_X:
 666   case REX_XB:
 667   case REX_R:
 668   case REX_RB:
 669   case REX_RX:
 670   case REX_RXB:
 671     NOT_LP64(assert(false, &quot;64bit prefixes&quot;));
 672     goto again_after_prefix;
 673 
 674   case REX_W:
 675   case REX_WB:
 676   case REX_WX:
 677   case REX_WXB:
 678   case REX_WR:
 679   case REX_WRB:
 680   case REX_WRX:
 681   case REX_WRXB:
 682     NOT_LP64(assert(false, &quot;64bit prefixes&quot;));
 683     is_64bit = true;
 684     goto again_after_prefix;
 685 
 686   case 0xFF: // pushq a; decl a; incl a; call a; jmp a
 687   case 0x88: // movb a, r
 688   case 0x89: // movl a, r
 689   case 0x8A: // movb r, a
 690   case 0x8B: // movl r, a
 691   case 0x8F: // popl a
 692     debug_only(has_disp32 = true);
 693     break;
 694 
 695   case 0x68: // pushq #32
 696     if (which == end_pc_operand) {
 697       return ip + 4;
 698     }
 699     assert(which == imm_operand &amp;&amp; !is_64bit, &quot;pushl has no disp32 or 64bit immediate&quot;);
 700     return ip;                  // not produced by emit_operand
 701 
 702   case 0x66: // movw ... (size prefix)
 703     again_after_size_prefix2:
 704     switch (0xFF &amp; *ip++) {
 705     case REX:
 706     case REX_B:
 707     case REX_X:
 708     case REX_XB:
 709     case REX_R:
 710     case REX_RB:
 711     case REX_RX:
 712     case REX_RXB:
 713     case REX_W:
 714     case REX_WB:
 715     case REX_WX:
 716     case REX_WXB:
 717     case REX_WR:
 718     case REX_WRB:
 719     case REX_WRX:
 720     case REX_WRXB:
 721       NOT_LP64(assert(false, &quot;64bit prefix found&quot;));
 722       goto again_after_size_prefix2;
 723     case 0x8B: // movw r, a
 724     case 0x89: // movw a, r
 725       debug_only(has_disp32 = true);
 726       break;
 727     case 0xC7: // movw a, #16
 728       debug_only(has_disp32 = true);
 729       tail_size = 2;  // the imm16
 730       break;
 731     case 0x0F: // several SSE/SSE2 variants
 732       ip--;    // reparse the 0x0F
 733       goto again_after_prefix;
 734     default:
 735       ShouldNotReachHere();
 736     }
 737     break;
 738 
 739   case REP8(0xB8): // movl/q r, #32/#64(oop?)
 740     if (which == end_pc_operand)  return ip + (is_64bit ? 8 : 4);
 741     // these asserts are somewhat nonsensical
 742 #ifndef _LP64
 743     assert(which == imm_operand || which == disp32_operand,
 744            &quot;which %d is_64_bit %d ip &quot; INTPTR_FORMAT, which, is_64bit, p2i(ip));
 745 #else
 746     assert((which == call32_operand || which == imm_operand) &amp;&amp; is_64bit ||
 747            which == narrow_oop_operand &amp;&amp; !is_64bit,
 748            &quot;which %d is_64_bit %d ip &quot; INTPTR_FORMAT, which, is_64bit, p2i(ip));
 749 #endif // _LP64
 750     return ip;
 751 
 752   case 0x69: // imul r, a, #32
 753   case 0xC7: // movl a, #32(oop?)
 754     tail_size = 4;
 755     debug_only(has_disp32 = true); // has both kinds of operands!
 756     break;
 757 
 758   case 0x0F: // movx..., etc.
 759     switch (0xFF &amp; *ip++) {
 760     case 0x3A: // pcmpestri
 761       tail_size = 1;
 762     case 0x38: // ptest, pmovzxbw
 763       ip++; // skip opcode
 764       debug_only(has_disp32 = true); // has both kinds of operands!
 765       break;
 766 
 767     case 0x70: // pshufd r, r/a, #8
 768       debug_only(has_disp32 = true); // has both kinds of operands!
 769     case 0x73: // psrldq r, #8
 770       tail_size = 1;
 771       break;
 772 
 773     case 0x12: // movlps
 774     case 0x28: // movaps
 775     case 0x2E: // ucomiss
 776     case 0x2F: // comiss
 777     case 0x54: // andps
 778     case 0x55: // andnps
 779     case 0x56: // orps
 780     case 0x57: // xorps
 781     case 0x58: // addpd
 782     case 0x59: // mulpd
 783     case 0x6E: // movd
 784     case 0x7E: // movd
 785     case 0x6F: // movdq
 786     case 0x7F: // movdq
 787     case 0xAE: // ldmxcsr, stmxcsr, fxrstor, fxsave, clflush
 788     case 0xFE: // paddd
 789       debug_only(has_disp32 = true);
 790       break;
 791 
 792     case 0xAD: // shrd r, a, %cl
 793     case 0xAF: // imul r, a
 794     case 0xBE: // movsbl r, a (movsxb)
 795     case 0xBF: // movswl r, a (movsxw)
 796     case 0xB6: // movzbl r, a (movzxb)
 797     case 0xB7: // movzwl r, a (movzxw)
 798     case REP16(0x40): // cmovl cc, r, a
 799     case 0xB0: // cmpxchgb
 800     case 0xB1: // cmpxchg
 801     case 0xC1: // xaddl
 802     case 0xC7: // cmpxchg8
 803     case REP16(0x90): // setcc a
 804       debug_only(has_disp32 = true);
 805       // fall out of the switch to decode the address
 806       break;
 807 
 808     case 0xC4: // pinsrw r, a, #8
 809       debug_only(has_disp32 = true);
 810     case 0xC5: // pextrw r, r, #8
 811       tail_size = 1;  // the imm8
 812       break;
 813 
 814     case 0xAC: // shrd r, a, #8
 815       debug_only(has_disp32 = true);
 816       tail_size = 1;  // the imm8
 817       break;
 818 
 819     case REP16(0x80): // jcc rdisp32
 820       if (which == end_pc_operand)  return ip + 4;
 821       assert(which == call32_operand, &quot;jcc has no disp32 or imm&quot;);
 822       return ip;
 823     default:
 824       ShouldNotReachHere();
 825     }
 826     break;
 827 
 828   case 0x81: // addl a, #32; addl r, #32
 829     // also: orl, adcl, sbbl, andl, subl, xorl, cmpl
 830     // on 32bit in the case of cmpl, the imm might be an oop
 831     tail_size = 4;
 832     debug_only(has_disp32 = true); // has both kinds of operands!
 833     break;
 834 
 835   case 0x83: // addl a, #8; addl r, #8
 836     // also: orl, adcl, sbbl, andl, subl, xorl, cmpl
 837     debug_only(has_disp32 = true); // has both kinds of operands!
 838     tail_size = 1;
 839     break;
 840 
 841   case 0x9B:
 842     switch (0xFF &amp; *ip++) {
 843     case 0xD9: // fnstcw a
 844       debug_only(has_disp32 = true);
 845       break;
 846     default:
 847       ShouldNotReachHere();
 848     }
 849     break;
 850 
 851   case REP4(0x00): // addb a, r; addl a, r; addb r, a; addl r, a
 852   case REP4(0x10): // adc...
 853   case REP4(0x20): // and...
 854   case REP4(0x30): // xor...
 855   case REP4(0x08): // or...
 856   case REP4(0x18): // sbb...
 857   case REP4(0x28): // sub...
 858   case 0xF7: // mull a
 859   case 0x8D: // lea r, a
 860   case 0x87: // xchg r, a
 861   case REP4(0x38): // cmp...
 862   case 0x85: // test r, a
 863     debug_only(has_disp32 = true); // has both kinds of operands!
 864     break;
 865 
 866   case 0xC1: // sal a, #8; sar a, #8; shl a, #8; shr a, #8
 867   case 0xC6: // movb a, #8
 868   case 0x80: // cmpb a, #8
 869   case 0x6B: // imul r, a, #8
 870     debug_only(has_disp32 = true); // has both kinds of operands!
 871     tail_size = 1; // the imm8
 872     break;
 873 
 874   case 0xC4: // VEX_3bytes
 875   case 0xC5: // VEX_2bytes
 876     assert((UseAVX &gt; 0), &quot;shouldn&#39;t have VEX prefix&quot;);
 877     assert(ip == inst+1, &quot;no prefixes allowed&quot;);
 878     // C4 and C5 are also used as opcodes for PINSRW and PEXTRW instructions
 879     // but they have prefix 0x0F and processed when 0x0F processed above.
 880     //
 881     // In 32-bit mode the VEX first byte C4 and C5 alias onto LDS and LES
 882     // instructions (these instructions are not supported in 64-bit mode).
 883     // To distinguish them bits [7:6] are set in the VEX second byte since
 884     // ModRM byte can not be of the form 11xxxxxx in 32-bit mode. To set
 885     // those VEX bits REX and vvvv bits are inverted.
 886     //
 887     // Fortunately C2 doesn&#39;t generate these instructions so we don&#39;t need
 888     // to check for them in product version.
 889 
 890     // Check second byte
 891     NOT_LP64(assert((0xC0 &amp; *ip) == 0xC0, &quot;shouldn&#39;t have LDS and LES instructions&quot;));
 892 
 893     int vex_opcode;
 894     // First byte
 895     if ((0xFF &amp; *inst) == VEX_3bytes) {
 896       vex_opcode = VEX_OPCODE_MASK &amp; *ip;
 897       ip++; // third byte
 898       is_64bit = ((VEX_W &amp; *ip) == VEX_W);
 899     } else {
 900       vex_opcode = VEX_OPCODE_0F;
 901     }
 902     ip++; // opcode
 903     // To find the end of instruction (which == end_pc_operand).
 904     switch (vex_opcode) {
 905       case VEX_OPCODE_0F:
 906         switch (0xFF &amp; *ip) {
 907         case 0x70: // pshufd r, r/a, #8
 908         case 0x71: // ps[rl|ra|ll]w r, #8
 909         case 0x72: // ps[rl|ra|ll]d r, #8
 910         case 0x73: // ps[rl|ra|ll]q r, #8
 911         case 0xC2: // cmp[ps|pd|ss|sd] r, r, r/a, #8
 912         case 0xC4: // pinsrw r, r, r/a, #8
 913         case 0xC5: // pextrw r/a, r, #8
 914         case 0xC6: // shufp[s|d] r, r, r/a, #8
 915           tail_size = 1;  // the imm8
 916           break;
 917         }
 918         break;
 919       case VEX_OPCODE_0F_3A:
 920         tail_size = 1;
 921         break;
 922     }
 923     ip++; // skip opcode
 924     debug_only(has_disp32 = true); // has both kinds of operands!
 925     break;
 926 
 927   case 0x62: // EVEX_4bytes
 928     assert(VM_Version::supports_evex(), &quot;shouldn&#39;t have EVEX prefix&quot;);
 929     assert(ip == inst+1, &quot;no prefixes allowed&quot;);
 930     // no EVEX collisions, all instructions that have 0x62 opcodes
 931     // have EVEX versions and are subopcodes of 0x66
 932     ip++; // skip P0 and exmaine W in P1
 933     is_64bit = ((VEX_W &amp; *ip) == VEX_W);
 934     ip++; // move to P2
 935     ip++; // skip P2, move to opcode
 936     // To find the end of instruction (which == end_pc_operand).
 937     switch (0xFF &amp; *ip) {
 938     case 0x22: // pinsrd r, r/a, #8
 939     case 0x61: // pcmpestri r, r/a, #8
 940     case 0x70: // pshufd r, r/a, #8
 941     case 0x73: // psrldq r, #8
 942       tail_size = 1;  // the imm8
 943       break;
 944     default:
 945       break;
 946     }
 947     ip++; // skip opcode
 948     debug_only(has_disp32 = true); // has both kinds of operands!
 949     break;
 950 
 951   case 0xD1: // sal a, 1; sar a, 1; shl a, 1; shr a, 1
 952   case 0xD3: // sal a, %cl; sar a, %cl; shl a, %cl; shr a, %cl
 953   case 0xD9: // fld_s a; fst_s a; fstp_s a; fldcw a
 954   case 0xDD: // fld_d a; fst_d a; fstp_d a
 955   case 0xDB: // fild_s a; fistp_s a; fld_x a; fstp_x a
 956   case 0xDF: // fild_d a; fistp_d a
 957   case 0xD8: // fadd_s a; fsubr_s a; fmul_s a; fdivr_s a; fcomp_s a
 958   case 0xDC: // fadd_d a; fsubr_d a; fmul_d a; fdivr_d a; fcomp_d a
 959   case 0xDE: // faddp_d a; fsubrp_d a; fmulp_d a; fdivrp_d a; fcompp_d a
 960     debug_only(has_disp32 = true);
 961     break;
 962 
 963   case 0xE8: // call rdisp32
 964   case 0xE9: // jmp  rdisp32
 965     if (which == end_pc_operand)  return ip + 4;
 966     assert(which == call32_operand, &quot;call has no disp32 or imm&quot;);
 967     return ip;
 968 
 969   case 0xF0:                    // Lock
 970     goto again_after_prefix;
 971 
 972   case 0xF3:                    // For SSE
 973   case 0xF2:                    // For SSE2
 974     switch (0xFF &amp; *ip++) {
 975     case REX:
 976     case REX_B:
 977     case REX_X:
 978     case REX_XB:
 979     case REX_R:
 980     case REX_RB:
 981     case REX_RX:
 982     case REX_RXB:
 983     case REX_W:
 984     case REX_WB:
 985     case REX_WX:
 986     case REX_WXB:
 987     case REX_WR:
 988     case REX_WRB:
 989     case REX_WRX:
 990     case REX_WRXB:
 991       NOT_LP64(assert(false, &quot;found 64bit prefix&quot;));
 992       ip++;
 993     default:
 994       ip++;
 995     }
 996     debug_only(has_disp32 = true); // has both kinds of operands!
 997     break;
 998 
 999   default:
1000     ShouldNotReachHere();
1001 
1002 #undef REP8
1003 #undef REP16
1004   }
1005 
1006   assert(which != call32_operand, &quot;instruction is not a call, jmp, or jcc&quot;);
1007 #ifdef _LP64
1008   assert(which != imm_operand, &quot;instruction is not a movq reg, imm64&quot;);
1009 #else
1010   // assert(which != imm_operand || has_imm32, &quot;instruction has no imm32 field&quot;);
1011   assert(which != imm_operand || has_disp32, &quot;instruction has no imm32 field&quot;);
1012 #endif // LP64
1013   assert(which != disp32_operand || has_disp32, &quot;instruction has no disp32 field&quot;);
1014 
1015   // parse the output of emit_operand
1016   int op2 = 0xFF &amp; *ip++;
1017   int base = op2 &amp; 0x07;
1018   int op3 = -1;
1019   const int b100 = 4;
1020   const int b101 = 5;
1021   if (base == b100 &amp;&amp; (op2 &gt;&gt; 6) != 3) {
1022     op3 = 0xFF &amp; *ip++;
1023     base = op3 &amp; 0x07;   // refetch the base
1024   }
1025   // now ip points at the disp (if any)
1026 
1027   switch (op2 &gt;&gt; 6) {
1028   case 0:
1029     // [00 reg  100][ss index base]
1030     // [00 reg  100][00   100  esp]
1031     // [00 reg base]
1032     // [00 reg  100][ss index  101][disp32]
1033     // [00 reg  101]               [disp32]
1034 
1035     if (base == b101) {
1036       if (which == disp32_operand)
1037         return ip;              // caller wants the disp32
1038       ip += 4;                  // skip the disp32
1039     }
1040     break;
1041 
1042   case 1:
1043     // [01 reg  100][ss index base][disp8]
1044     // [01 reg  100][00   100  esp][disp8]
1045     // [01 reg base]               [disp8]
1046     ip += 1;                    // skip the disp8
1047     break;
1048 
1049   case 2:
1050     // [10 reg  100][ss index base][disp32]
1051     // [10 reg  100][00   100  esp][disp32]
1052     // [10 reg base]               [disp32]
1053     if (which == disp32_operand)
1054       return ip;                // caller wants the disp32
1055     ip += 4;                    // skip the disp32
1056     break;
1057 
1058   case 3:
1059     // [11 reg base]  (not a memory addressing mode)
1060     break;
1061   }
1062 
1063   if (which == end_pc_operand) {
1064     return ip + tail_size;
1065   }
1066 
1067 #ifdef _LP64
1068   assert(which == narrow_oop_operand &amp;&amp; !is_64bit, &quot;instruction is not a movl adr, imm32&quot;);
1069 #else
1070   assert(which == imm_operand, &quot;instruction has only an imm field&quot;);
1071 #endif // LP64
1072   return ip;
1073 }
1074 
1075 address Assembler::locate_next_instruction(address inst) {
1076   // Secretly share code with locate_operand:
1077   return locate_operand(inst, end_pc_operand);
1078 }
1079 
1080 
1081 #ifdef ASSERT
1082 void Assembler::check_relocation(RelocationHolder const&amp; rspec, int format) {
1083   address inst = inst_mark();
1084   assert(inst != NULL &amp;&amp; inst &lt; pc(), &quot;must point to beginning of instruction&quot;);
1085   address opnd;
1086 
1087   Relocation* r = rspec.reloc();
1088   if (r-&gt;type() == relocInfo::none) {
1089     return;
1090   } else if (r-&gt;is_call() || format == call32_operand) {
1091     // assert(format == imm32_operand, &quot;cannot specify a nonzero format&quot;);
1092     opnd = locate_operand(inst, call32_operand);
1093   } else if (r-&gt;is_data()) {
1094     assert(format == imm_operand || format == disp32_operand
1095            LP64_ONLY(|| format == narrow_oop_operand), &quot;format ok&quot;);
1096     opnd = locate_operand(inst, (WhichOperand)format);
1097   } else {
1098     assert(format == imm_operand, &quot;cannot specify a format&quot;);
1099     return;
1100   }
1101   assert(opnd == pc(), &quot;must put operand where relocs can find it&quot;);
1102 }
1103 #endif // ASSERT
1104 
1105 void Assembler::emit_operand32(Register reg, Address adr) {
1106   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);
1107   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);
1108   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1109                adr._rspec);
1110 }
1111 
1112 void Assembler::emit_operand(Register reg, Address adr,
1113                              int rip_relative_correction) {
1114   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1115                adr._rspec,
1116                rip_relative_correction);
1117 }
1118 
1119 void Assembler::emit_operand(XMMRegister reg, Address adr) {
1120     if (adr.isxmmindex()) {
1121        emit_operand(reg, adr._base, adr._xmmindex, adr._scale, adr._disp, adr._rspec);
1122     } else {
1123        emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1124        adr._rspec);
1125     }
1126 }
1127 
1128 // MMX operations
1129 void Assembler::emit_operand(MMXRegister reg, Address adr) {
1130   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);
1131   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);
1132 }
1133 
1134 // work around gcc (3.2.1-7a) bug
1135 void Assembler::emit_operand(Address adr, MMXRegister reg) {
1136   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);
1137   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);
1138 }
1139 
1140 
1141 void Assembler::emit_farith(int b1, int b2, int i) {
1142   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);
1143   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);
<a name="25" id="anc25"></a><span class="line-modified">1144   emit_int16(b1, b2 + i);</span>

1145 }
1146 
1147 
1148 // Now the Assembler instructions (identical for 32/64 bits)
1149 
1150 void Assembler::adcl(Address dst, int32_t imm32) {
1151   InstructionMark im(this);
1152   prefix(dst);
1153   emit_arith_operand(0x81, rdx, dst, imm32);
1154 }
1155 
1156 void Assembler::adcl(Address dst, Register src) {
1157   InstructionMark im(this);
1158   prefix(dst, src);
1159   emit_int8(0x11);
1160   emit_operand(src, dst);
1161 }
1162 
1163 void Assembler::adcl(Register dst, int32_t imm32) {
1164   prefix(dst);
1165   emit_arith(0x81, 0xD0, dst, imm32);
1166 }
1167 
1168 void Assembler::adcl(Register dst, Address src) {
1169   InstructionMark im(this);
1170   prefix(src, dst);
1171   emit_int8(0x13);
1172   emit_operand(dst, src);
1173 }
1174 
1175 void Assembler::adcl(Register dst, Register src) {
1176   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1177   emit_arith(0x13, 0xC0, dst, src);
1178 }
1179 
1180 void Assembler::addl(Address dst, int32_t imm32) {
1181   InstructionMark im(this);
1182   prefix(dst);
1183   emit_arith_operand(0x81, rax, dst, imm32);
1184 }
1185 
1186 void Assembler::addb(Address dst, int imm8) {
1187   InstructionMark im(this);
1188   prefix(dst);
1189   emit_int8((unsigned char)0x80);
1190   emit_operand(rax, dst, 1);
1191   emit_int8(imm8);
1192 }
1193 
1194 void Assembler::addw(Address dst, int imm16) {
1195   InstructionMark im(this);
1196   emit_int8(0x66);
1197   prefix(dst);
1198   emit_int8((unsigned char)0x81);
1199   emit_operand(rax, dst, 2);
1200   emit_int16(imm16);
1201 }
1202 
1203 void Assembler::addl(Address dst, Register src) {
1204   InstructionMark im(this);
1205   prefix(dst, src);
1206   emit_int8(0x01);
1207   emit_operand(src, dst);
1208 }
1209 
1210 void Assembler::addl(Register dst, int32_t imm32) {
1211   prefix(dst);
1212   emit_arith(0x81, 0xC0, dst, imm32);
1213 }
1214 
1215 void Assembler::addl(Register dst, Address src) {
1216   InstructionMark im(this);
1217   prefix(src, dst);
1218   emit_int8(0x03);
1219   emit_operand(dst, src);
1220 }
1221 
1222 void Assembler::addl(Register dst, Register src) {
1223   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1224   emit_arith(0x03, 0xC0, dst, src);
1225 }
1226 
1227 void Assembler::addr_nop_4() {
1228   assert(UseAddressNop, &quot;no CPU support&quot;);
1229   // 4 bytes: NOP DWORD PTR [EAX+0]
<a name="26" id="anc26"></a><span class="line-modified">1230   emit_int32(0x0F,</span>
<span class="line-modified">1231              0x1F,</span>
<span class="line-modified">1232              0x40, // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);</span>
<span class="line-modified">1233              0);   // 8-bits offset (1 byte)</span>
1234 }
1235 
1236 void Assembler::addr_nop_5() {
1237   assert(UseAddressNop, &quot;no CPU support&quot;);
1238   // 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
<a name="27" id="anc27"></a><span class="line-modified">1239   emit_int32(0x0F,</span>
<span class="line-modified">1240              0x1F,</span>
<span class="line-modified">1241              0x44,  // emit_rm(cbuf, 0x1, EAX_enc, 0x4);</span>
<span class="line-modified">1242              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">1243   emit_int8(0);     // 8-bits offset (1 byte)</span>
1244 }
1245 
1246 void Assembler::addr_nop_7() {
1247   assert(UseAddressNop, &quot;no CPU support&quot;);
1248   // 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
<a name="28" id="anc28"></a><span class="line-modified">1249   emit_int24(0x0F,</span>
<span class="line-modified">1250              0x1F,</span>
<span class="line-modified">1251              (unsigned char)0x80);</span>
1252                    // emit_rm(cbuf, 0x2, EAX_enc, EAX_enc);
1253   emit_int32(0);   // 32-bits offset (4 bytes)
1254 }
1255 
1256 void Assembler::addr_nop_8() {
1257   assert(UseAddressNop, &quot;no CPU support&quot;);
1258   // 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
<a name="29" id="anc29"></a><span class="line-modified">1259   emit_int32(0x0F,</span>
<span class="line-modified">1260              0x1F,</span>
<span class="line-modified">1261              (unsigned char)0x84,</span>
<span class="line-modified">1262                     // emit_rm(cbuf, 0x2, EAX_enc, 0x4);</span>
<span class="line-modified">1263              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">1264   emit_int32(0);    // 32-bits offset (4 bytes)</span>
1265 }
1266 
1267 void Assembler::addsd(XMMRegister dst, XMMRegister src) {
1268   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1269   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1270   attributes.set_rex_vex_w_reverted();
1271   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="30" id="anc30"></a><span class="line-modified">1272   emit_int16(0x58, (0xC0 | encode));</span>

1273 }
1274 
1275 void Assembler::addsd(XMMRegister dst, Address src) {
1276   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1277   InstructionMark im(this);
1278   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1279   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1280   attributes.set_rex_vex_w_reverted();
1281   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1282   emit_int8(0x58);
1283   emit_operand(dst, src);
1284 }
1285 
1286 void Assembler::addss(XMMRegister dst, XMMRegister src) {
1287   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1288   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1289   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="31" id="anc31"></a><span class="line-modified">1290   emit_int16(0x58, (0xC0 | encode));</span>

1291 }
1292 
1293 void Assembler::addss(XMMRegister dst, Address src) {
1294   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1295   InstructionMark im(this);
1296   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1297   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1298   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1299   emit_int8(0x58);
1300   emit_operand(dst, src);
1301 }
1302 
1303 void Assembler::aesdec(XMMRegister dst, Address src) {
1304   assert(VM_Version::supports_aes(), &quot;&quot;);
1305   InstructionMark im(this);
1306   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1307   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1308   emit_int8((unsigned char)0xDE);
1309   emit_operand(dst, src);
1310 }
1311 
1312 void Assembler::aesdec(XMMRegister dst, XMMRegister src) {
1313   assert(VM_Version::supports_aes(), &quot;&quot;);
1314   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1315   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="32" id="anc32"></a><span class="line-modified">1316   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>

1317 }
1318 
1319 void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<a name="33" id="anc33"></a><span class="line-modified">1320   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
1321   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1322   attributes.set_is_evex_instruction();
1323   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="34" id="anc34"></a><span class="line-modified">1324   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>

1325 }
1326 
1327 
1328 void Assembler::aesdeclast(XMMRegister dst, Address src) {
1329   assert(VM_Version::supports_aes(), &quot;&quot;);
1330   InstructionMark im(this);
1331   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1332   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1333   emit_int8((unsigned char)0xDF);
1334   emit_operand(dst, src);
1335 }
1336 
1337 void Assembler::aesdeclast(XMMRegister dst, XMMRegister src) {
1338   assert(VM_Version::supports_aes(), &quot;&quot;);
1339   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1340   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="35" id="anc35"></a><span class="line-modified">1341   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

1342 }
1343 
1344 void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<a name="36" id="anc36"></a><span class="line-modified">1345   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
1346   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1347   attributes.set_is_evex_instruction();
1348   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="37" id="anc37"></a><span class="line-modified">1349   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

1350 }
1351 
1352 void Assembler::aesenc(XMMRegister dst, Address src) {
1353   assert(VM_Version::supports_aes(), &quot;&quot;);
1354   InstructionMark im(this);
1355   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1356   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1357   emit_int8((unsigned char)0xDC);
1358   emit_operand(dst, src);
1359 }
1360 
1361 void Assembler::aesenc(XMMRegister dst, XMMRegister src) {
1362   assert(VM_Version::supports_aes(), &quot;&quot;);
1363   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1364   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="38" id="anc38"></a><span class="line-modified">1365   emit_int16((unsigned char)0xDC, 0xC0 | encode);</span>

1366 }
1367 
1368 void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<a name="39" id="anc39"></a><span class="line-modified">1369   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
1370   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1371   attributes.set_is_evex_instruction();
1372   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="40" id="anc40"></a><span class="line-modified">1373   emit_int16((unsigned char)0xDC, (0xC0 | encode));</span>

1374 }
1375 
1376 void Assembler::aesenclast(XMMRegister dst, Address src) {
1377   assert(VM_Version::supports_aes(), &quot;&quot;);
1378   InstructionMark im(this);
1379   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1380   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1381   emit_int8((unsigned char)0xDD);
1382   emit_operand(dst, src);
1383 }
1384 
1385 void Assembler::aesenclast(XMMRegister dst, XMMRegister src) {
1386   assert(VM_Version::supports_aes(), &quot;&quot;);
1387   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1388   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="41" id="anc41"></a><span class="line-modified">1389   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>

1390 }
1391 
1392 void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<a name="42" id="anc42"></a><span class="line-modified">1393   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
1394   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1395   attributes.set_is_evex_instruction();
1396   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="43" id="anc43"></a><span class="line-modified">1397   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>

1398 }
1399 
1400 void Assembler::andl(Address dst, int32_t imm32) {
1401   InstructionMark im(this);
1402   prefix(dst);
1403   emit_int8((unsigned char)0x81);
1404   emit_operand(rsp, dst, 4);
1405   emit_int32(imm32);
1406 }
1407 
1408 void Assembler::andl(Register dst, int32_t imm32) {
1409   prefix(dst);
1410   emit_arith(0x81, 0xE0, dst, imm32);
1411 }
1412 
1413 void Assembler::andl(Register dst, Address src) {
1414   InstructionMark im(this);
1415   prefix(src, dst);
1416   emit_int8(0x23);
1417   emit_operand(dst, src);
1418 }
1419 
1420 void Assembler::andl(Register dst, Register src) {
1421   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1422   emit_arith(0x23, 0xC0, dst, src);
1423 }
1424 
1425 void Assembler::andnl(Register dst, Register src1, Register src2) {
1426   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1427   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1428   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="44" id="anc44"></a><span class="line-modified">1429   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

1430 }
1431 
1432 void Assembler::andnl(Register dst, Register src1, Address src2) {
1433   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1434   InstructionMark im(this);
1435   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1436   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1437   emit_int8((unsigned char)0xF2);
1438   emit_operand(dst, src2);
1439 }
1440 
1441 void Assembler::bsfl(Register dst, Register src) {
1442   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="45" id="anc45"></a><span class="line-modified">1443   emit_int24(0x0F,</span>
<span class="line-modified">1444              (unsigned char)0xBC,</span>
<span class="line-modified">1445              0xC0 | encode);</span>
1446 }
1447 
1448 void Assembler::bsrl(Register dst, Register src) {
1449   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="46" id="anc46"></a><span class="line-modified">1450   emit_int24(0x0F,</span>
<span class="line-modified">1451              (unsigned char)0xBD,</span>
<span class="line-modified">1452              0xC0 | encode);</span>
1453 }
1454 
1455 void Assembler::bswapl(Register reg) { // bswap
1456   int encode = prefix_and_encode(reg-&gt;encoding());
<a name="47" id="anc47"></a><span class="line-modified">1457   emit_int16(0x0F, (0xC8 | encode));</span>

1458 }
1459 
1460 void Assembler::blsil(Register dst, Register src) {
1461   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1462   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1463   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="48" id="anc48"></a><span class="line-modified">1464   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

1465 }
1466 
1467 void Assembler::blsil(Register dst, Address src) {
1468   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1469   InstructionMark im(this);
1470   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1471   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1472   emit_int8((unsigned char)0xF3);
1473   emit_operand(rbx, src);
1474 }
1475 
1476 void Assembler::blsmskl(Register dst, Register src) {
1477   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1478   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1479   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="49" id="anc49"></a><span class="line-modified">1480   emit_int16((unsigned char)0xF3,</span>
<span class="line-modified">1481              0xC0 | encode);</span>
1482 }
1483 
1484 void Assembler::blsmskl(Register dst, Address src) {
1485   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1486   InstructionMark im(this);
1487   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1488   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1489   emit_int8((unsigned char)0xF3);
1490   emit_operand(rdx, src);
1491 }
1492 
1493 void Assembler::blsrl(Register dst, Register src) {
1494   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1495   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1496   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="50" id="anc50"></a><span class="line-modified">1497   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

1498 }
1499 
1500 void Assembler::blsrl(Register dst, Address src) {
1501   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1502   InstructionMark im(this);
1503   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1504   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1505   emit_int8((unsigned char)0xF3);
1506   emit_operand(rcx, src);
1507 }
1508 
1509 void Assembler::call(Label&amp; L, relocInfo::relocType rtype) {
1510   // suspect disp32 is always good
1511   int operand = LP64_ONLY(disp32_operand) NOT_LP64(imm_operand);
1512 
1513   if (L.is_bound()) {
1514     const int long_size = 5;
1515     int offs = (int)( target(L) - pc() );
1516     assert(offs &lt;= 0, &quot;assembler error&quot;);
1517     InstructionMark im(this);
1518     // 1110 1000 #32-bit disp
1519     emit_int8((unsigned char)0xE8);
1520     emit_data(offs - long_size, rtype, operand);
1521   } else {
1522     InstructionMark im(this);
1523     // 1110 1000 #32-bit disp
1524     L.add_patch_at(code(), locator());
1525 
1526     emit_int8((unsigned char)0xE8);
1527     emit_data(int(0), rtype, operand);
1528   }
1529 }
1530 
1531 void Assembler::call(Register dst) {
1532   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="51" id="anc51"></a><span class="line-modified">1533   emit_int16((unsigned char)0xFF, (0xD0 | encode));</span>

1534 }
1535 
1536 
1537 void Assembler::call(Address adr) {
1538   InstructionMark im(this);
1539   prefix(adr);
1540   emit_int8((unsigned char)0xFF);
1541   emit_operand(rdx, adr);
1542 }
1543 
1544 void Assembler::call_literal(address entry, RelocationHolder const&amp; rspec) {
1545   InstructionMark im(this);
1546   emit_int8((unsigned char)0xE8);
1547   intptr_t disp = entry - (pc() + sizeof(int32_t));
1548   // Entry is NULL in case of a scratch emit.
1549   assert(entry == NULL || is_simm32(disp), &quot;disp=&quot; INTPTR_FORMAT &quot; must be 32bit offset (call2)&quot;, disp);
1550   // Technically, should use call32_operand, but this format is
1551   // implied by the fact that we&#39;re emitting a call instruction.
1552 
1553   int operand = LP64_ONLY(disp32_operand) NOT_LP64(call32_operand);
1554   emit_data((int) disp, rspec, operand);
1555 }
1556 
1557 void Assembler::cdql() {
1558   emit_int8((unsigned char)0x99);
1559 }
1560 
1561 void Assembler::cld() {
1562   emit_int8((unsigned char)0xFC);
1563 }
1564 
1565 void Assembler::cmovl(Condition cc, Register dst, Register src) {
1566   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1567   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="52" id="anc52"></a><span class="line-modified">1568   emit_int24(0x0F,</span>
<span class="line-modified">1569              0x40 | cc,</span>
<span class="line-modified">1570              0xC0 | encode);</span>
1571 }
1572 
1573 
1574 void Assembler::cmovl(Condition cc, Register dst, Address src) {
1575   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1576   prefix(src, dst);
<a name="53" id="anc53"></a><span class="line-modified">1577   emit_int16(0x0F, (0x40 | cc));</span>

1578   emit_operand(dst, src);
1579 }
1580 
1581 void Assembler::cmpb(Address dst, int imm8) {
1582   InstructionMark im(this);
1583   prefix(dst);
1584   emit_int8((unsigned char)0x80);
1585   emit_operand(rdi, dst, 1);
1586   emit_int8(imm8);
1587 }
1588 
1589 void Assembler::cmpl(Address dst, int32_t imm32) {
1590   InstructionMark im(this);
1591   prefix(dst);
1592   emit_int8((unsigned char)0x81);
1593   emit_operand(rdi, dst, 4);
1594   emit_int32(imm32);
1595 }
1596 
1597 void Assembler::cmpl(Register dst, int32_t imm32) {
1598   prefix(dst);
1599   emit_arith(0x81, 0xF8, dst, imm32);
1600 }
1601 
1602 void Assembler::cmpl(Register dst, Register src) {
1603   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1604   emit_arith(0x3B, 0xC0, dst, src);
1605 }
1606 
1607 void Assembler::cmpl(Register dst, Address  src) {
1608   InstructionMark im(this);
1609   prefix(src, dst);
<a name="54" id="anc54"></a><span class="line-modified">1610   emit_int8(0x3B);</span>
1611   emit_operand(dst, src);
1612 }
1613 
1614 void Assembler::cmpw(Address dst, int imm16) {
1615   InstructionMark im(this);
1616   assert(!dst.base_needs_rex() &amp;&amp; !dst.index_needs_rex(), &quot;no extended registers&quot;);
<a name="55" id="anc55"></a><span class="line-modified">1617   emit_int16(0x66, (unsigned char)0x81);</span>

1618   emit_operand(rdi, dst, 2);
1619   emit_int16(imm16);
1620 }
1621 
1622 // The 32-bit cmpxchg compares the value at adr with the contents of rax,
1623 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1624 // The ZF is set if the compared values were equal, and cleared otherwise.
1625 void Assembler::cmpxchgl(Register reg, Address adr) { // cmpxchg
1626   InstructionMark im(this);
1627   prefix(adr, reg);
<a name="56" id="anc56"></a><span class="line-modified">1628   emit_int16(0x0F, (unsigned char)0xB1);</span>

1629   emit_operand(reg, adr);
1630 }
1631 
1632 // The 8-bit cmpxchg compares the value at adr with the contents of rax,
1633 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1634 // The ZF is set if the compared values were equal, and cleared otherwise.
1635 void Assembler::cmpxchgb(Register reg, Address adr) { // cmpxchg
1636   InstructionMark im(this);
1637   prefix(adr, reg, true);
<a name="57" id="anc57"></a><span class="line-modified">1638   emit_int16(0x0F, (unsigned char)0xB0);</span>

1639   emit_operand(reg, adr);
1640 }
1641 
1642 void Assembler::comisd(XMMRegister dst, Address src) {
1643   // NOTE: dbx seems to decode this as comiss even though the
1644   // 0x66 is there. Strangly ucomisd comes out correct
1645   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1646   InstructionMark im(this);
1647   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);;
1648   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1649   attributes.set_rex_vex_w_reverted();
1650   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
1651   emit_int8(0x2F);
1652   emit_operand(dst, src);
1653 }
1654 
1655 void Assembler::comisd(XMMRegister dst, XMMRegister src) {
1656   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1657   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1658   attributes.set_rex_vex_w_reverted();
1659   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="58" id="anc58"></a><span class="line-modified">1660   emit_int16(0x2F, (0xC0 | encode));</span>

1661 }
1662 
1663 void Assembler::comiss(XMMRegister dst, Address src) {
1664   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1665   InstructionMark im(this);
1666   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1667   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1668   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
1669   emit_int8(0x2F);
1670   emit_operand(dst, src);
1671 }
1672 
1673 void Assembler::comiss(XMMRegister dst, XMMRegister src) {
1674   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1675   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1676   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="59" id="anc59"></a><span class="line-modified">1677   emit_int16(0x2F, (0xC0 | encode));</span>

1678 }
1679 
1680 void Assembler::cpuid() {
<a name="60" id="anc60"></a><span class="line-modified">1681   emit_int16(0x0F, (unsigned char)0xA2);</span>

1682 }
1683 
1684 // Opcode / Instruction                      Op /  En  64 - Bit Mode     Compat / Leg Mode Description                  Implemented
1685 // F2 0F 38 F0 / r       CRC32 r32, r / m8   RM        Valid             Valid             Accumulate CRC32 on r / m8.  v
1686 // F2 REX 0F 38 F0 / r   CRC32 r32, r / m8*  RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1687 // F2 REX.W 0F 38 F0 / r CRC32 r64, r / m8   RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1688 //
1689 // F2 0F 38 F1 / r       CRC32 r32, r / m16  RM        Valid             Valid             Accumulate CRC32 on r / m16. v
1690 //
1691 // F2 0F 38 F1 / r       CRC32 r32, r / m32  RM        Valid             Valid             Accumulate CRC32 on r / m32. v
1692 //
1693 // F2 REX.W 0F 38 F1 / r CRC32 r64, r / m64  RM        Valid             N.E.              Accumulate CRC32 on r / m64. v
1694 void Assembler::crc32(Register crc, Register v, int8_t sizeInBytes) {
1695   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1696   int8_t w = 0x01;
1697   Prefix p = Prefix_EMPTY;
1698 
<a name="61" id="anc61"></a><span class="line-modified">1699   emit_int8((unsigned char)0xF2);</span>
1700   switch (sizeInBytes) {
1701   case 1:
1702     w = 0;
1703     break;
1704   case 2:
1705   case 4:
1706     break;
1707   LP64_ONLY(case 8:)
1708     // This instruction is not valid in 32 bits
1709     // Note:
1710     // http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf
1711     //
1712     // Page B - 72   Vol. 2C says
1713     // qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2
1714     // mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r / m
1715     //                                                                            F0!!!
1716     // while 3 - 208 Vol. 2A
1717     // F2 REX.W 0F 38 F1 / r       CRC32 r64, r / m64             RM         Valid      N.E.Accumulate CRC32 on r / m64.
1718     //
1719     // the 0 on a last bit is reserved for a different flavor of this instruction :
1720     // F2 REX.W 0F 38 F0 / r       CRC32 r64, r / m8              RM         Valid      N.E.Accumulate CRC32 on r / m8.
1721     p = REX_W;
1722     break;
1723   default:
1724     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1725     break;
1726   }
1727   LP64_ONLY(prefix(crc, v, p);)
<a name="62" id="anc62"></a><span class="line-modified">1728   emit_int32(0x0F,</span>
<span class="line-modified">1729              0x38,</span>
<span class="line-modified">1730              0xF0 | w,</span>
<span class="line-modified">1731              0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));</span>
1732 }
1733 
1734 void Assembler::crc32(Register crc, Address adr, int8_t sizeInBytes) {
1735   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1736   InstructionMark im(this);
1737   int8_t w = 0x01;
1738   Prefix p = Prefix_EMPTY;
1739 
1740   emit_int8((int8_t)0xF2);
1741   switch (sizeInBytes) {
1742   case 1:
1743     w = 0;
1744     break;
1745   case 2:
1746   case 4:
1747     break;
1748   LP64_ONLY(case 8:)
1749     // This instruction is not valid in 32 bits
1750     p = REX_W;
1751     break;
1752   default:
1753     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1754     break;
1755   }
1756   LP64_ONLY(prefix(crc, adr, p);)
<a name="63" id="anc63"></a><span class="line-modified">1757   emit_int24(0x0F, 0x38, (0xF0 | w));</span>


1758   emit_operand(crc, adr);
1759 }
1760 
1761 void Assembler::cvtdq2pd(XMMRegister dst, XMMRegister src) {
1762   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1763   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1764   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="64" id="anc64"></a><span class="line-modified">1765   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>

1766 }
1767 
1768 void Assembler::cvtdq2ps(XMMRegister dst, XMMRegister src) {
1769   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1770   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1771   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="65" id="anc65"></a><span class="line-modified">1772   emit_int16(0x5B, (0xC0 | encode));</span>

1773 }
1774 
1775 void Assembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {
1776   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1777   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1778   attributes.set_rex_vex_w_reverted();
1779   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="66" id="anc66"></a><span class="line-modified">1780   emit_int16(0x5A, (0xC0 | encode));</span>

1781 }
1782 
1783 void Assembler::cvtsd2ss(XMMRegister dst, Address src) {
1784   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1785   InstructionMark im(this);
1786   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1787   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1788   attributes.set_rex_vex_w_reverted();
1789   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1790   emit_int8(0x5A);
1791   emit_operand(dst, src);
1792 }
1793 
1794 void Assembler::cvtsi2sdl(XMMRegister dst, Register src) {
1795   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1796   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1797   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="67" id="anc67"></a><span class="line-modified">1798   emit_int16(0x2A, (0xC0 | encode));</span>

1799 }
1800 
1801 void Assembler::cvtsi2sdl(XMMRegister dst, Address src) {
1802   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1803   InstructionMark im(this);
1804   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1805   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1806   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1807   emit_int8(0x2A);
1808   emit_operand(dst, src);
1809 }
1810 
1811 void Assembler::cvtsi2ssl(XMMRegister dst, Register src) {
1812   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1813   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1814   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="68" id="anc68"></a><span class="line-modified">1815   emit_int16(0x2A, (0xC0 | encode));</span>

1816 }
1817 
1818 void Assembler::cvtsi2ssl(XMMRegister dst, Address src) {
1819   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1820   InstructionMark im(this);
1821   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1822   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1823   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1824   emit_int8(0x2A);
1825   emit_operand(dst, src);
1826 }
1827 
1828 void Assembler::cvtsi2ssq(XMMRegister dst, Register src) {
1829   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1830   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1831   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="69" id="anc69"></a><span class="line-modified">1832   emit_int16(0x2A, (0xC0 | encode));</span>

1833 }
1834 
1835 void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
1836   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1837   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1838   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="70" id="anc70"></a><span class="line-modified">1839   emit_int16(0x5A, (0xC0 | encode));</span>

1840 }
1841 
1842 void Assembler::cvtss2sd(XMMRegister dst, Address src) {
1843   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1844   InstructionMark im(this);
1845   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1846   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1847   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1848   emit_int8(0x5A);
1849   emit_operand(dst, src);
1850 }
1851 
1852 
1853 void Assembler::cvttsd2sil(Register dst, XMMRegister src) {
1854   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1855   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1856   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="71" id="anc71"></a><span class="line-modified">1857   emit_int16(0x2C, (0xC0 | encode));</span>

1858 }
1859 
1860 void Assembler::cvttss2sil(Register dst, XMMRegister src) {
1861   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1862   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1863   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="72" id="anc72"></a><span class="line-modified">1864   emit_int16(0x2C, (0xC0 | encode));</span>

1865 }
1866 
1867 void Assembler::cvttpd2dq(XMMRegister dst, XMMRegister src) {
1868   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1869   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
1870   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1871   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="73" id="anc73"></a><span class="line-modified">1872   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>

1873 }
1874 
1875 void Assembler::pabsb(XMMRegister dst, XMMRegister src) {
1876   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1877   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1878   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="74" id="anc74"></a><span class="line-modified">1879   emit_int16(0x1C, (0xC0 | encode));</span>

1880 }
1881 
1882 void Assembler::pabsw(XMMRegister dst, XMMRegister src) {
1883   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1884   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1885   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="75" id="anc75"></a><span class="line-modified">1886   emit_int16(0x1D, (0xC0 | encode));</span>

1887 }
1888 
1889 void Assembler::pabsd(XMMRegister dst, XMMRegister src) {
1890   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1891   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1892   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="76" id="anc76"></a><span class="line-modified">1893   emit_int16(0x1E, (0xC0 | encode));</span>

1894 }
1895 
1896 void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {
1897   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1898   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1899   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1900   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1901   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="77" id="anc77"></a><span class="line-modified">1902   emit_int16(0x1C, (0xC0 | encode));</span>

1903 }
1904 
1905 void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {
1906   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1907   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1908   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1909   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1910   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="78" id="anc78"></a><span class="line-modified">1911   emit_int16(0x1D, (0xC0 | encode));</span>

1912 }
1913 
1914 void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {
1915   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1916   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1917   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);
1918   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1919   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="79" id="anc79"></a><span class="line-modified">1920   emit_int16(0x1E, (0xC0 | encode));</span>

1921 }
1922 
1923 void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {
1924   assert(UseAVX &gt; 2, &quot;&quot;);
1925   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1926   attributes.set_is_evex_instruction();
1927   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="80" id="anc80"></a><span class="line-modified">1928   emit_int16(0x1F, (0xC0 | encode));</span>

1929 }
1930 
1931 void Assembler::decl(Address dst) {
1932   // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
1933   InstructionMark im(this);
1934   prefix(dst);
1935   emit_int8((unsigned char)0xFF);
1936   emit_operand(rcx, dst);
1937 }
1938 
1939 void Assembler::divsd(XMMRegister dst, Address src) {
1940   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1941   InstructionMark im(this);
1942   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1943   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1944   attributes.set_rex_vex_w_reverted();
1945   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1946   emit_int8(0x5E);
1947   emit_operand(dst, src);
1948 }
1949 
1950 void Assembler::divsd(XMMRegister dst, XMMRegister src) {
1951   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1952   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1953   attributes.set_rex_vex_w_reverted();
1954   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="81" id="anc81"></a><span class="line-modified">1955   emit_int16(0x5E, (0xC0 | encode));</span>

1956 }
1957 
1958 void Assembler::divss(XMMRegister dst, Address src) {
1959   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1960   InstructionMark im(this);
1961   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1962   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1963   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1964   emit_int8(0x5E);
1965   emit_operand(dst, src);
1966 }
1967 
1968 void Assembler::divss(XMMRegister dst, XMMRegister src) {
1969   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1970   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1971   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="82" id="anc82"></a><span class="line-modified">1972   emit_int16(0x5E, (0xC0 | encode));</span>

1973 }
1974 
1975 void Assembler::emms() {
1976   NOT_LP64(assert(VM_Version::supports_mmx(), &quot;&quot;));
<a name="83" id="anc83"></a><span class="line-modified">1977   emit_int16(0x0F, 0x77);</span>

1978 }
1979 
1980 void Assembler::hlt() {
1981   emit_int8((unsigned char)0xF4);
1982 }
1983 
1984 void Assembler::idivl(Register src) {
1985   int encode = prefix_and_encode(src-&gt;encoding());
<a name="84" id="anc84"></a><span class="line-modified">1986   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>

1987 }
1988 
1989 void Assembler::divl(Register src) { // Unsigned
1990   int encode = prefix_and_encode(src-&gt;encoding());
<a name="85" id="anc85"></a><span class="line-modified">1991   emit_int16((unsigned char)0xF7, (0xF0 | encode));</span>

1992 }
1993 
1994 void Assembler::imull(Register src) {
1995   int encode = prefix_and_encode(src-&gt;encoding());
<a name="86" id="anc86"></a><span class="line-modified">1996   emit_int16((unsigned char)0xF7, (0xE8 | encode));</span>

1997 }
1998 
1999 void Assembler::imull(Register dst, Register src) {
2000   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="87" id="anc87"></a><span class="line-modified">2001   emit_int24(0x0F,</span>
<span class="line-modified">2002              (unsigned char)0xAF,</span>
<span class="line-modified">2003              (0xC0 | encode));</span>
2004 }
2005 
2006 
2007 void Assembler::imull(Register dst, Register src, int value) {
2008   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2009   if (is8bit(value)) {
<a name="88" id="anc88"></a><span class="line-modified">2010     emit_int24(0x6B, (0xC0 | encode), value &amp; 0xFF);</span>


2011   } else {
<a name="89" id="anc89"></a><span class="line-modified">2012     emit_int16(0x69, (0xC0 | encode));</span>

2013     emit_int32(value);
2014   }
2015 }
2016 
2017 void Assembler::imull(Register dst, Address src) {
2018   InstructionMark im(this);
2019   prefix(src, dst);
<a name="90" id="anc90"></a><span class="line-modified">2020   emit_int16(0x0F, (unsigned char)0xAF);</span>

2021   emit_operand(dst, src);
2022 }
2023 
2024 
2025 void Assembler::incl(Address dst) {
2026   // Don&#39;t use it directly. Use MacroAssembler::increment() instead.
2027   InstructionMark im(this);
2028   prefix(dst);
2029   emit_int8((unsigned char)0xFF);
2030   emit_operand(rax, dst);
2031 }
2032 
2033 void Assembler::jcc(Condition cc, Label&amp; L, bool maybe_short) {
2034   InstructionMark im(this);
2035   assert((0 &lt;= cc) &amp;&amp; (cc &lt; 16), &quot;illegal cc&quot;);
2036   if (L.is_bound()) {
2037     address dst = target(L);
2038     assert(dst != NULL, &quot;jcc most probably wrong&quot;);
2039 
2040     const int short_size = 2;
2041     const int long_size = 6;
2042     intptr_t offs = (intptr_t)dst - (intptr_t)pc();
2043     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
2044       // 0111 tttn #8-bit disp
<a name="91" id="anc91"></a><span class="line-modified">2045       emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>

2046     } else {
2047       // 0000 1111 1000 tttn #32-bit disp
2048       assert(is_simm32(offs - long_size),
2049              &quot;must be 32bit offset (call4)&quot;);
<a name="92" id="anc92"></a><span class="line-modified">2050       emit_int16(0x0F, (0x80 | cc));</span>

2051       emit_int32(offs - long_size);
2052     }
2053   } else {
2054     // Note: could eliminate cond. jumps to this jump if condition
2055     //       is the same however, seems to be rather unlikely case.
2056     // Note: use jccb() if label to be bound is very close to get
2057     //       an 8-bit displacement
2058     L.add_patch_at(code(), locator());
<a name="93" id="anc93"></a><span class="line-modified">2059     emit_int16(0x0F, (0x80 | cc));</span>

2060     emit_int32(0);
2061   }
2062 }
2063 
2064 void Assembler::jccb_0(Condition cc, Label&amp; L, const char* file, int line) {
2065   if (L.is_bound()) {
2066     const int short_size = 2;
2067     address entry = target(L);
2068 #ifdef ASSERT
2069     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2070     intptr_t delta = short_branch_delta();
2071     if (delta != 0) {
2072       dist += (dist &lt; 0 ? (-delta) :delta);
2073     }
2074     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2075 #endif
2076     intptr_t offs = (intptr_t)entry - (intptr_t)pc();
2077     // 0111 tttn #8-bit disp
<a name="94" id="anc94"></a><span class="line-modified">2078     emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>

2079   } else {
2080     InstructionMark im(this);
2081     L.add_patch_at(code(), locator(), file, line);
<a name="95" id="anc95"></a><span class="line-modified">2082     emit_int16(0x70 | cc, 0);</span>

2083   }
2084 }
2085 
2086 void Assembler::jmp(Address adr) {
2087   InstructionMark im(this);
2088   prefix(adr);
2089   emit_int8((unsigned char)0xFF);
2090   emit_operand(rsp, adr);
2091 }
2092 
2093 void Assembler::jmp(Label&amp; L, bool maybe_short) {
2094   if (L.is_bound()) {
2095     address entry = target(L);
2096     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2097     InstructionMark im(this);
2098     const int short_size = 2;
2099     const int long_size = 5;
2100     intptr_t offs = entry - pc();
2101     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
<a name="96" id="anc96"></a><span class="line-modified">2102       emit_int16((unsigned char)0xEB, ((offs - short_size) &amp; 0xFF));</span>

2103     } else {
2104       emit_int8((unsigned char)0xE9);
2105       emit_int32(offs - long_size);
2106     }
2107   } else {
2108     // By default, forward jumps are always 32-bit displacements, since
2109     // we can&#39;t yet know where the label will be bound.  If you&#39;re sure that
2110     // the forward jump will not run beyond 256 bytes, use jmpb to
2111     // force an 8-bit displacement.
2112     InstructionMark im(this);
2113     L.add_patch_at(code(), locator());
2114     emit_int8((unsigned char)0xE9);
2115     emit_int32(0);
2116   }
2117 }
2118 
2119 void Assembler::jmp(Register entry) {
2120   int encode = prefix_and_encode(entry-&gt;encoding());
<a name="97" id="anc97"></a><span class="line-modified">2121   emit_int16((unsigned char)0xFF, (0xE0 | encode));</span>

2122 }
2123 
2124 void Assembler::jmp_literal(address dest, RelocationHolder const&amp; rspec) {
2125   InstructionMark im(this);
2126   emit_int8((unsigned char)0xE9);
2127   assert(dest != NULL, &quot;must have a target&quot;);
2128   intptr_t disp = dest - (pc() + sizeof(int32_t));
2129   assert(is_simm32(disp), &quot;must be 32bit offset (jmp)&quot;);
2130   emit_data(disp, rspec.reloc(), call32_operand);
2131 }
2132 
2133 void Assembler::jmpb_0(Label&amp; L, const char* file, int line) {
2134   if (L.is_bound()) {
2135     const int short_size = 2;
2136     address entry = target(L);
2137     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2138 #ifdef ASSERT
2139     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2140     intptr_t delta = short_branch_delta();
2141     if (delta != 0) {
2142       dist += (dist &lt; 0 ? (-delta) :delta);
2143     }
2144     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2145 #endif
2146     intptr_t offs = entry - pc();
<a name="98" id="anc98"></a><span class="line-modified">2147     emit_int16((unsigned char)0xEB, (offs - short_size) &amp; 0xFF);</span>

2148   } else {
2149     InstructionMark im(this);
2150     L.add_patch_at(code(), locator(), file, line);
<a name="99" id="anc99"></a><span class="line-modified">2151     emit_int16((unsigned char)0xEB, 0);</span>

2152   }
2153 }
2154 
2155 void Assembler::ldmxcsr( Address src) {
2156   if (UseAVX &gt; 0 ) {
2157     InstructionMark im(this);
2158     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2159     vex_prefix(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2160     emit_int8((unsigned char)0xAE);
2161     emit_operand(as_Register(2), src);
2162   } else {
2163     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2164     InstructionMark im(this);
2165     prefix(src);
<a name="100" id="anc100"></a><span class="line-modified">2166     emit_int16(0x0F, (unsigned char)0xAE);</span>

2167     emit_operand(as_Register(2), src);
2168   }
2169 }
2170 
2171 void Assembler::leal(Register dst, Address src) {
2172   InstructionMark im(this);
2173 #ifdef _LP64
2174   emit_int8(0x67); // addr32
2175   prefix(src, dst);
2176 #endif // LP64
2177   emit_int8((unsigned char)0x8D);
2178   emit_operand(dst, src);
2179 }
2180 
2181 void Assembler::lfence() {
<a name="101" id="anc101"></a><span class="line-modified">2182   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xE8);</span>


2183 }
2184 
2185 void Assembler::lock() {
2186   emit_int8((unsigned char)0xF0);
2187 }
2188 
2189 void Assembler::lzcntl(Register dst, Register src) {
2190   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
2191   emit_int8((unsigned char)0xF3);
2192   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="102" id="anc102"></a><span class="line-modified">2193   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>


2194 }
2195 
2196 // Emit mfence instruction
2197 void Assembler::mfence() {
2198   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<a name="103" id="anc103"></a><span class="line-modified">2199   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF0);</span>


2200 }
2201 
2202 // Emit sfence instruction
2203 void Assembler::sfence() {
2204   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<a name="104" id="anc104"></a><span class="line-modified">2205   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF8);</span>


2206 }
2207 
2208 void Assembler::mov(Register dst, Register src) {
2209   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2210 }
2211 
2212 void Assembler::movapd(XMMRegister dst, XMMRegister src) {
2213   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2214   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2215   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2216   attributes.set_rex_vex_w_reverted();
2217   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="105" id="anc105"></a><span class="line-modified">2218   emit_int16(0x28, (0xC0 | encode));</span>

2219 }
2220 
2221 void Assembler::movaps(XMMRegister dst, XMMRegister src) {
2222   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2223   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2224   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2225   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="106" id="anc106"></a><span class="line-modified">2226   emit_int16(0x28, (0xC0 | encode));</span>

2227 }
2228 
2229 void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
2230   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2231   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2232   int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="107" id="anc107"></a><span class="line-modified">2233   emit_int16(0x16, (0xC0 | encode));</span>

2234 }
2235 
2236 void Assembler::movb(Register dst, Address src) {
2237   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
2238   InstructionMark im(this);
2239   prefix(src, dst, true);
2240   emit_int8((unsigned char)0x8A);
2241   emit_operand(dst, src);
2242 }
2243 
2244 void Assembler::movddup(XMMRegister dst, XMMRegister src) {
2245   NOT_LP64(assert(VM_Version::supports_sse3(), &quot;&quot;));
2246   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2247   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2248   attributes.set_rex_vex_w_reverted();
2249   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="108" id="anc108"></a><span class="line-modified">2250   emit_int16(0x12, 0xC0 | encode);</span>

2251 }
2252 
2253 void Assembler::kmovbl(KRegister dst, Register src) {
2254   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2255   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2256   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="109" id="anc109"></a><span class="line-modified">2257   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2258 }
2259 
2260 void Assembler::kmovbl(Register dst, KRegister src) {
2261   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2262   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2263   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="110" id="anc110"></a><span class="line-modified">2264   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2265 }
2266 
2267 void Assembler::kmovwl(KRegister dst, Register src) {
2268   assert(VM_Version::supports_evex(), &quot;&quot;);
2269   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2270   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="111" id="anc111"></a><span class="line-modified">2271   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2272 }
2273 
2274 void Assembler::kmovwl(Register dst, KRegister src) {
2275   assert(VM_Version::supports_evex(), &quot;&quot;);
2276   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2277   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="112" id="anc112"></a><span class="line-modified">2278   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2279 }
2280 
2281 void Assembler::kmovwl(KRegister dst, Address src) {
2282   assert(VM_Version::supports_evex(), &quot;&quot;);
2283   InstructionMark im(this);
2284   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2285   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2286   emit_int8((unsigned char)0x90);
2287   emit_operand((Register)dst, src);
2288 }
2289 
2290 void Assembler::kmovdl(KRegister dst, Register src) {
2291   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2292   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2293   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="113" id="anc113"></a><span class="line-modified">2294   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2295 }
2296 
2297 void Assembler::kmovdl(Register dst, KRegister src) {
2298   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2299   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2300   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="114" id="anc114"></a><span class="line-modified">2301   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2302 }
2303 
2304 void Assembler::kmovql(KRegister dst, KRegister src) {
2305   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2306   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2307   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="115" id="anc115"></a><span class="line-modified">2308   emit_int16((unsigned char)0x90, (0xC0 | encode));</span>

2309 }
2310 
2311 void Assembler::kmovql(KRegister dst, Address src) {
2312   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2313   InstructionMark im(this);
2314   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2315   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2316   emit_int8((unsigned char)0x90);
2317   emit_operand((Register)dst, src);
2318 }
2319 
2320 void Assembler::kmovql(Address dst, KRegister src) {
2321   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2322   InstructionMark im(this);
2323   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2324   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2325   emit_int8((unsigned char)0x90);
2326   emit_operand((Register)src, dst);
2327 }
2328 
2329 void Assembler::kmovql(KRegister dst, Register src) {
2330   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2331   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2332   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="116" id="anc116"></a><span class="line-modified">2333   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2334 }
2335 
2336 void Assembler::kmovql(Register dst, KRegister src) {
2337   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2338   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2339   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="117" id="anc117"></a><span class="line-modified">2340   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2341 }
2342 
2343 void Assembler::knotwl(KRegister dst, KRegister src) {
2344   assert(VM_Version::supports_evex(), &quot;&quot;);
2345   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2346   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="118" id="anc118"></a><span class="line-modified">2347   emit_int16(0x44, (0xC0 | encode));</span>

2348 }
2349 
2350 // This instruction produces ZF or CF flags
2351 void Assembler::kortestbl(KRegister src1, KRegister src2) {
2352   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2353   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2354   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="119" id="anc119"></a><span class="line-modified">2355   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2356 }
2357 
2358 // This instruction produces ZF or CF flags
2359 void Assembler::kortestwl(KRegister src1, KRegister src2) {
2360   assert(VM_Version::supports_evex(), &quot;&quot;);
2361   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2362   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="120" id="anc120"></a><span class="line-modified">2363   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2364 }
2365 
2366 // This instruction produces ZF or CF flags
2367 void Assembler::kortestdl(KRegister src1, KRegister src2) {
2368   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2369   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2370   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="121" id="anc121"></a><span class="line-modified">2371   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2372 }
2373 
2374 // This instruction produces ZF or CF flags
2375 void Assembler::kortestql(KRegister src1, KRegister src2) {
2376   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2377   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2378   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="122" id="anc122"></a><span class="line-modified">2379   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2380 }
2381 
2382 // This instruction produces ZF or CF flags
2383 void Assembler::ktestql(KRegister src1, KRegister src2) {
2384   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2385   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2386   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="123" id="anc123"></a><span class="line-modified">2387   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>

2388 }
2389 
2390 void Assembler::ktestq(KRegister src1, KRegister src2) {
2391   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2392   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2393   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="124" id="anc124"></a><span class="line-modified">2394   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>

2395 }
2396 
2397 void Assembler::ktestd(KRegister src1, KRegister src2) {
2398   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2399   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2400   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="125" id="anc125"></a><span class="line-modified">2401   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>

2402 }
2403 
2404 void Assembler::movb(Address dst, int imm8) {
2405   InstructionMark im(this);
2406    prefix(dst);
2407   emit_int8((unsigned char)0xC6);
2408   emit_operand(rax, dst, 1);
2409   emit_int8(imm8);
2410 }
2411 
2412 
2413 void Assembler::movb(Address dst, Register src) {
2414   assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;);
2415   InstructionMark im(this);
2416   prefix(dst, src, true);
2417   emit_int8((unsigned char)0x88);
2418   emit_operand(src, dst);
2419 }
2420 
2421 void Assembler::movdl(XMMRegister dst, Register src) {
2422   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2423   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2424   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="126" id="anc126"></a><span class="line-modified">2425   emit_int16(0x6E, (0xC0 | encode));</span>

2426 }
2427 
2428 void Assembler::movdl(Register dst, XMMRegister src) {
2429   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2430   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2431   // swap src/dst to get correct prefix
2432   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="127" id="anc127"></a><span class="line-modified">2433   emit_int16(0x7E, (0xC0 | encode));</span>

2434 }
2435 
2436 void Assembler::movdl(XMMRegister dst, Address src) {
2437   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2438   InstructionMark im(this);
2439   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2440   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2441   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2442   emit_int8(0x6E);
2443   emit_operand(dst, src);
2444 }
2445 
2446 void Assembler::movdl(Address dst, XMMRegister src) {
2447   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2448   InstructionMark im(this);
2449   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2450   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2451   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2452   emit_int8(0x7E);
2453   emit_operand(src, dst);
2454 }
2455 
2456 void Assembler::movdqa(XMMRegister dst, XMMRegister src) {
2457   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2458   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2459   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="128" id="anc128"></a><span class="line-modified">2460   emit_int16(0x6F, (0xC0 | encode));</span>

2461 }
2462 
2463 void Assembler::movdqa(XMMRegister dst, Address src) {
2464   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2465   InstructionMark im(this);
2466   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2467   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2468   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2469   emit_int8(0x6F);
2470   emit_operand(dst, src);
2471 }
2472 
2473 void Assembler::movdqu(XMMRegister dst, Address src) {
2474   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2475   InstructionMark im(this);
2476   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2477   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2478   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2479   emit_int8(0x6F);
2480   emit_operand(dst, src);
2481 }
2482 
2483 void Assembler::movdqu(XMMRegister dst, XMMRegister src) {
2484   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2485   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2486   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="129" id="anc129"></a><span class="line-modified">2487   emit_int16(0x6F, (0xC0 | encode));</span>

2488 }
2489 
2490 void Assembler::movdqu(Address dst, XMMRegister src) {
2491   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2492   InstructionMark im(this);
2493   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2494   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2495   attributes.reset_is_clear_context();
2496   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2497   emit_int8(0x7F);
2498   emit_operand(src, dst);
2499 }
2500 
2501 // Move Unaligned 256bit Vector
2502 void Assembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2503   assert(UseAVX &gt; 0, &quot;&quot;);
2504   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2505   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="130" id="anc130"></a><span class="line-modified">2506   emit_int16(0x6F, (0xC0 | encode));</span>

2507 }
2508 
2509 void Assembler::vmovdqu(XMMRegister dst, Address src) {
2510   assert(UseAVX &gt; 0, &quot;&quot;);
2511   InstructionMark im(this);
2512   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2513   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2514   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2515   emit_int8(0x6F);
2516   emit_operand(dst, src);
2517 }
2518 
2519 void Assembler::vmovdqu(Address dst, XMMRegister src) {
2520   assert(UseAVX &gt; 0, &quot;&quot;);
2521   InstructionMark im(this);
2522   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2523   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2524   attributes.reset_is_clear_context();
2525   // swap src&lt;-&gt;dst for encoding
2526   assert(src != xnoreg, &quot;sanity&quot;);
2527   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2528   emit_int8(0x7F);
2529   emit_operand(src, dst);
2530 }
2531 
2532 // Move Unaligned EVEX enabled Vector (programmable : 8,16,32,64)
2533 void Assembler::evmovdqub(XMMRegister dst, XMMRegister src, int vector_len) {
2534   assert(VM_Version::supports_evex(), &quot;&quot;);
2535   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2536   attributes.set_is_evex_instruction();
2537   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2538   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
<a name="131" id="anc131"></a><span class="line-modified">2539   emit_int16(0x6F, (0xC0 | encode));</span>

2540 }
2541 
2542 void Assembler::evmovdqub(XMMRegister dst, Address src, int vector_len) {
2543   assert(VM_Version::supports_evex(), &quot;&quot;);
2544   InstructionMark im(this);
2545   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2546   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2547   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2548   attributes.set_is_evex_instruction();
2549   vex_prefix(src, 0, dst-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2550   emit_int8(0x6F);
2551   emit_operand(dst, src);
2552 }
2553 
2554 void Assembler::evmovdqub(Address dst, XMMRegister src, int vector_len) {
2555   assert(VM_Version::supports_evex(), &quot;&quot;);
2556   assert(src != xnoreg, &quot;sanity&quot;);
2557   InstructionMark im(this);
2558   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2559   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2560   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2561   attributes.set_is_evex_instruction();
2562   vex_prefix(dst, 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2563   emit_int8(0x7F);
2564   emit_operand(src, dst);
2565 }
2566 
2567 void Assembler::evmovdqub(XMMRegister dst, KRegister mask, Address src, int vector_len) {
2568   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2569   InstructionMark im(this);
2570   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2571   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2572   attributes.set_embedded_opmask_register_specifier(mask);
2573   attributes.set_is_evex_instruction();
2574   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2575   emit_int8(0x6F);
2576   emit_operand(dst, src);
2577 }
2578 
2579 void Assembler::evmovdquw(XMMRegister dst, Address src, int vector_len) {
2580   assert(VM_Version::supports_evex(), &quot;&quot;);
2581   InstructionMark im(this);
2582   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2583   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2584   attributes.set_is_evex_instruction();
2585   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2586   vex_prefix(src, 0, dst-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2587   emit_int8(0x6F);
2588   emit_operand(dst, src);
2589 }
2590 
2591 void Assembler::evmovdquw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
2592   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2593   InstructionMark im(this);
2594   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2595   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2596   attributes.set_embedded_opmask_register_specifier(mask);
2597   attributes.set_is_evex_instruction();
2598   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2599   emit_int8(0x6F);
2600   emit_operand(dst, src);
2601 }
2602 
2603 void Assembler::evmovdquw(Address dst, XMMRegister src, int vector_len) {
2604   assert(VM_Version::supports_evex(), &quot;&quot;);
2605   assert(src != xnoreg, &quot;sanity&quot;);
2606   InstructionMark im(this);
2607   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2608   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2609   attributes.set_is_evex_instruction();
2610   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2611   vex_prefix(dst, 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2612   emit_int8(0x7F);
2613   emit_operand(src, dst);
2614 }
2615 
2616 void Assembler::evmovdquw(Address dst, KRegister mask, XMMRegister src, int vector_len) {
2617   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2618   assert(src != xnoreg, &quot;sanity&quot;);
2619   InstructionMark im(this);
2620   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2621   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2622   attributes.reset_is_clear_context();
2623   attributes.set_embedded_opmask_register_specifier(mask);
2624   attributes.set_is_evex_instruction();
2625   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2626   emit_int8(0x7F);
2627   emit_operand(src, dst);
2628 }
2629 
2630 void Assembler::evmovdqul(XMMRegister dst, XMMRegister src, int vector_len) {
2631   assert(VM_Version::supports_evex(), &quot;&quot;);
2632   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2633   attributes.set_is_evex_instruction();
2634   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="132" id="anc132"></a><span class="line-modified">2635   emit_int16(0x6F, (0xC0 | encode));</span>

2636 }
2637 
2638 void Assembler::evmovdqul(XMMRegister dst, Address src, int vector_len) {
2639   assert(VM_Version::supports_evex(), &quot;&quot;);
2640   InstructionMark im(this);
2641   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ true);
2642   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2643   attributes.set_is_evex_instruction();
2644   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2645   emit_int8(0x6F);
2646   emit_operand(dst, src);
2647 }
2648 
2649 void Assembler::evmovdqul(Address dst, XMMRegister src, int vector_len) {
2650   assert(VM_Version::supports_evex(), &quot;&quot;);
2651   assert(src != xnoreg, &quot;sanity&quot;);
2652   InstructionMark im(this);
2653   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2654   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2655   attributes.reset_is_clear_context();
2656   attributes.set_is_evex_instruction();
2657   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2658   emit_int8(0x7F);
2659   emit_operand(src, dst);
2660 }
2661 
2662 void Assembler::evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) {
2663   assert(VM_Version::supports_evex(), &quot;&quot;);
2664   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2665   attributes.set_is_evex_instruction();
2666   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="133" id="anc133"></a><span class="line-modified">2667   emit_int16(0x6F, (0xC0 | encode));</span>

2668 }
2669 
2670 void Assembler::evmovdquq(XMMRegister dst, Address src, int vector_len) {
2671   assert(VM_Version::supports_evex(), &quot;&quot;);
2672   InstructionMark im(this);
2673   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2674   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2675   attributes.set_is_evex_instruction();
2676   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2677   emit_int8(0x6F);
2678   emit_operand(dst, src);
2679 }
2680 
2681 void Assembler::evmovdquq(Address dst, XMMRegister src, int vector_len) {
2682   assert(VM_Version::supports_evex(), &quot;&quot;);
2683   assert(src != xnoreg, &quot;sanity&quot;);
2684   InstructionMark im(this);
2685   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2686   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2687   attributes.reset_is_clear_context();
2688   attributes.set_is_evex_instruction();
2689   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2690   emit_int8(0x7F);
2691   emit_operand(src, dst);
2692 }
2693 
2694 // Uses zero extension on 64bit
2695 
2696 void Assembler::movl(Register dst, int32_t imm32) {
2697   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="134" id="anc134"></a><span class="line-modified">2698   emit_int8(0xB8 | encode);</span>
2699   emit_int32(imm32);
2700 }
2701 
2702 void Assembler::movl(Register dst, Register src) {
2703   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="135" id="anc135"></a><span class="line-modified">2704   emit_int16((unsigned char)0x8B, (0xC0 | encode));</span>

2705 }
2706 
2707 void Assembler::movl(Register dst, Address src) {
2708   InstructionMark im(this);
2709   prefix(src, dst);
2710   emit_int8((unsigned char)0x8B);
2711   emit_operand(dst, src);
2712 }
2713 
2714 void Assembler::movl(Address dst, int32_t imm32) {
2715   InstructionMark im(this);
2716   prefix(dst);
2717   emit_int8((unsigned char)0xC7);
2718   emit_operand(rax, dst, 4);
2719   emit_int32(imm32);
2720 }
2721 
2722 void Assembler::movl(Address dst, Register src) {
2723   InstructionMark im(this);
2724   prefix(dst, src);
2725   emit_int8((unsigned char)0x89);
2726   emit_operand(src, dst);
2727 }
2728 
2729 // New cpus require to use movsd and movss to avoid partial register stall
2730 // when loading from memory. But for old Opteron use movlpd instead of movsd.
2731 // The selection is done in MacroAssembler::movdbl() and movflt().
2732 void Assembler::movlpd(XMMRegister dst, Address src) {
2733   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2734   InstructionMark im(this);
2735   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2736   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2737   attributes.set_rex_vex_w_reverted();
2738   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2739   emit_int8(0x12);
2740   emit_operand(dst, src);
2741 }
2742 
2743 void Assembler::movq( MMXRegister dst, Address src ) {
2744   assert( VM_Version::supports_mmx(), &quot;&quot; );
<a name="136" id="anc136"></a><span class="line-modified">2745   emit_int16(0x0F, 0x6F);</span>

2746   emit_operand(dst, src);
2747 }
2748 
2749 void Assembler::movq( Address dst, MMXRegister src ) {
2750   assert( VM_Version::supports_mmx(), &quot;&quot; );
<a name="137" id="anc137"></a><span class="line-modified">2751   emit_int16(0x0F, 0x7F);</span>

2752   // workaround gcc (3.2.1-7a) bug
2753   // In that version of gcc with only an emit_operand(MMX, Address)
2754   // gcc will tail jump and try and reverse the parameters completely
2755   // obliterating dst in the process. By having a version available
2756   // that doesn&#39;t need to swap the args at the tail jump the bug is
2757   // avoided.
2758   emit_operand(dst, src);
2759 }
2760 
2761 void Assembler::movq(XMMRegister dst, Address src) {
2762   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2763   InstructionMark im(this);
2764   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2765   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2766   attributes.set_rex_vex_w_reverted();
2767   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2768   emit_int8(0x7E);
2769   emit_operand(dst, src);
2770 }
2771 
2772 void Assembler::movq(Address dst, XMMRegister src) {
2773   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2774   InstructionMark im(this);
2775   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2776   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2777   attributes.set_rex_vex_w_reverted();
2778   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2779   emit_int8((unsigned char)0xD6);
2780   emit_operand(src, dst);
2781 }
2782 
2783 void Assembler::movsbl(Register dst, Address src) { // movsxb
2784   InstructionMark im(this);
2785   prefix(src, dst);
<a name="138" id="anc138"></a><span class="line-modified">2786   emit_int16(0x0F, (unsigned char)0xBE);</span>

2787   emit_operand(dst, src);
2788 }
2789 
2790 void Assembler::movsbl(Register dst, Register src) { // movsxb
2791   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
2792   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<a name="139" id="anc139"></a><span class="line-modified">2793   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>


2794 }
2795 
2796 void Assembler::movsd(XMMRegister dst, XMMRegister src) {
2797   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2798   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2799   attributes.set_rex_vex_w_reverted();
2800   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="140" id="anc140"></a><span class="line-modified">2801   emit_int16(0x10, (0xC0 | encode));</span>

2802 }
2803 
2804 void Assembler::movsd(XMMRegister dst, Address src) {
2805   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2806   InstructionMark im(this);
2807   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2808   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2809   attributes.set_rex_vex_w_reverted();
2810   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2811   emit_int8(0x10);
2812   emit_operand(dst, src);
2813 }
2814 
2815 void Assembler::movsd(Address dst, XMMRegister src) {
2816   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2817   InstructionMark im(this);
2818   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2819   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2820   attributes.reset_is_clear_context();
2821   attributes.set_rex_vex_w_reverted();
2822   simd_prefix(src, xnoreg, dst, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2823   emit_int8(0x11);
2824   emit_operand(src, dst);
2825 }
2826 
2827 void Assembler::movss(XMMRegister dst, XMMRegister src) {
2828   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2829   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2830   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="141" id="anc141"></a><span class="line-modified">2831   emit_int16(0x10, (0xC0 | encode));</span>

2832 }
2833 
2834 void Assembler::movss(XMMRegister dst, Address src) {
2835   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2836   InstructionMark im(this);
2837   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2838   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2839   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2840   emit_int8(0x10);
2841   emit_operand(dst, src);
2842 }
2843 
2844 void Assembler::movss(Address dst, XMMRegister src) {
2845   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2846   InstructionMark im(this);
2847   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2848   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2849   attributes.reset_is_clear_context();
2850   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2851   emit_int8(0x11);
2852   emit_operand(src, dst);
2853 }
2854 
2855 void Assembler::movswl(Register dst, Address src) { // movsxw
2856   InstructionMark im(this);
2857   prefix(src, dst);
<a name="142" id="anc142"></a><span class="line-modified">2858   emit_int16(0x0F, (unsigned char)0xBF);</span>

2859   emit_operand(dst, src);
2860 }
2861 
2862 void Assembler::movswl(Register dst, Register src) { // movsxw
2863   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="143" id="anc143"></a><span class="line-modified">2864   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>


2865 }
2866 
2867 void Assembler::movw(Address dst, int imm16) {
2868   InstructionMark im(this);
2869 
2870   emit_int8(0x66); // switch to 16-bit mode
2871   prefix(dst);
2872   emit_int8((unsigned char)0xC7);
2873   emit_operand(rax, dst, 2);
2874   emit_int16(imm16);
2875 }
2876 
2877 void Assembler::movw(Register dst, Address src) {
2878   InstructionMark im(this);
2879   emit_int8(0x66);
2880   prefix(src, dst);
2881   emit_int8((unsigned char)0x8B);
2882   emit_operand(dst, src);
2883 }
2884 
2885 void Assembler::movw(Address dst, Register src) {
2886   InstructionMark im(this);
2887   emit_int8(0x66);
2888   prefix(dst, src);
2889   emit_int8((unsigned char)0x89);
2890   emit_operand(src, dst);
2891 }
2892 
2893 void Assembler::movzbl(Register dst, Address src) { // movzxb
2894   InstructionMark im(this);
2895   prefix(src, dst);
<a name="144" id="anc144"></a><span class="line-modified">2896   emit_int16(0x0F, (unsigned char)0xB6);</span>

2897   emit_operand(dst, src);
2898 }
2899 
2900 void Assembler::movzbl(Register dst, Register src) { // movzxb
2901   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
2902   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<a name="145" id="anc145"></a><span class="line-modified">2903   emit_int24(0x0F, (unsigned char)0xB6, 0xC0 | encode);</span>


2904 }
2905 
2906 void Assembler::movzwl(Register dst, Address src) { // movzxw
2907   InstructionMark im(this);
2908   prefix(src, dst);
<a name="146" id="anc146"></a><span class="line-modified">2909   emit_int16(0x0F, (unsigned char)0xB7);</span>

2910   emit_operand(dst, src);
2911 }
2912 
2913 void Assembler::movzwl(Register dst, Register src) { // movzxw
2914   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="147" id="anc147"></a><span class="line-modified">2915   emit_int24(0x0F, (unsigned char)0xB7, 0xC0 | encode);</span>


2916 }
2917 
2918 void Assembler::mull(Address src) {
2919   InstructionMark im(this);
2920   prefix(src);
2921   emit_int8((unsigned char)0xF7);
2922   emit_operand(rsp, src);
2923 }
2924 
2925 void Assembler::mull(Register src) {
2926   int encode = prefix_and_encode(src-&gt;encoding());
<a name="148" id="anc148"></a><span class="line-modified">2927   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>

2928 }
2929 
2930 void Assembler::mulsd(XMMRegister dst, Address src) {
2931   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2932   InstructionMark im(this);
2933   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2934   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2935   attributes.set_rex_vex_w_reverted();
2936   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2937   emit_int8(0x59);
2938   emit_operand(dst, src);
2939 }
2940 
2941 void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
2942   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2943   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2944   attributes.set_rex_vex_w_reverted();
2945   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="149" id="anc149"></a><span class="line-modified">2946   emit_int16(0x59, (0xC0 | encode));</span>

2947 }
2948 
2949 void Assembler::mulss(XMMRegister dst, Address src) {
2950   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2951   InstructionMark im(this);
2952   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2953   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2954   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2955   emit_int8(0x59);
2956   emit_operand(dst, src);
2957 }
2958 
2959 void Assembler::mulss(XMMRegister dst, XMMRegister src) {
2960   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2961   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2962   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="150" id="anc150"></a><span class="line-modified">2963   emit_int16(0x59, (0xC0 | encode));</span>

2964 }
2965 
2966 void Assembler::negl(Register dst) {
2967   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="151" id="anc151"></a><span class="line-modified">2968   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>

2969 }
2970 
2971 void Assembler::nop(int i) {
2972 #ifdef ASSERT
2973   assert(i &gt; 0, &quot; &quot;);
2974   // The fancy nops aren&#39;t currently recognized by debuggers making it a
2975   // pain to disassemble code while debugging. If asserts are on clearly
2976   // speed is not an issue so simply use the single byte traditional nop
2977   // to do alignment.
2978 
2979   for (; i &gt; 0 ; i--) emit_int8((unsigned char)0x90);
2980   return;
2981 
2982 #endif // ASSERT
2983 
2984   if (UseAddressNop &amp;&amp; VM_Version::is_intel()) {
2985     //
2986     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for Intel
2987     //  1: 0x90
2988     //  2: 0x66 0x90
2989     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
2990     //  4: 0x0F 0x1F 0x40 0x00
2991     //  5: 0x0F 0x1F 0x44 0x00 0x00
2992     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
2993     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
2994     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2995     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2996     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2997     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2998 
2999     // The rest coding is Intel specific - don&#39;t use consecutive address nops
3000 
3001     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3002     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3003     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3004     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3005 
3006     while(i &gt;= 15) {
3007       // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)
3008       i -= 15;
<a name="152" id="anc152"></a><span class="line-modified">3009       emit_int24(0x66, 0x66, 0x66);</span>


3010       addr_nop_8();
<a name="153" id="anc153"></a><span class="line-modified">3011       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3012     }
3013     switch (i) {
3014       case 14:
3015         emit_int8(0x66); // size prefix
3016       case 13:
3017         emit_int8(0x66); // size prefix
3018       case 12:
3019         addr_nop_8();
<a name="154" id="anc154"></a><span class="line-modified">3020         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3021         break;
3022       case 11:
3023         emit_int8(0x66); // size prefix
3024       case 10:
3025         emit_int8(0x66); // size prefix
3026       case 9:
3027         emit_int8(0x66); // size prefix
3028       case 8:
3029         addr_nop_8();
3030         break;
3031       case 7:
3032         addr_nop_7();
3033         break;
3034       case 6:
3035         emit_int8(0x66); // size prefix
3036       case 5:
3037         addr_nop_5();
3038         break;
3039       case 4:
3040         addr_nop_4();
3041         break;
3042       case 3:
3043         // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding
3044         emit_int8(0x66); // size prefix
3045       case 2:
3046         emit_int8(0x66); // size prefix
3047       case 1:
3048         emit_int8((unsigned char)0x90);
3049                          // nop
3050         break;
3051       default:
3052         assert(i == 0, &quot; &quot;);
3053     }
3054     return;
3055   }
3056   if (UseAddressNop &amp;&amp; VM_Version::is_amd_family()) {
3057     //
3058     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for AMD.
3059     //  1: 0x90
3060     //  2: 0x66 0x90
3061     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3062     //  4: 0x0F 0x1F 0x40 0x00
3063     //  5: 0x0F 0x1F 0x44 0x00 0x00
3064     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3065     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3066     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3067     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3068     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3069     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3070 
3071     // The rest coding is AMD specific - use consecutive address nops
3072 
3073     // 12: 0x66 0x0F 0x1F 0x44 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3074     // 13: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3075     // 14: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3076     // 15: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3077     // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3078     //     Size prefixes (0x66) are added for larger sizes
3079 
3080     while(i &gt;= 22) {
3081       i -= 11;
<a name="155" id="anc155"></a><span class="line-modified">3082       emit_int24(0x66, 0x66, 0x66);</span>


3083       addr_nop_8();
3084     }
3085     // Generate first nop for size between 21-12
3086     switch (i) {
3087       case 21:
3088         i -= 1;
3089         emit_int8(0x66); // size prefix
3090       case 20:
3091       case 19:
3092         i -= 1;
3093         emit_int8(0x66); // size prefix
3094       case 18:
3095       case 17:
3096         i -= 1;
3097         emit_int8(0x66); // size prefix
3098       case 16:
3099       case 15:
3100         i -= 8;
3101         addr_nop_8();
3102         break;
3103       case 14:
3104       case 13:
3105         i -= 7;
3106         addr_nop_7();
3107         break;
3108       case 12:
3109         i -= 6;
3110         emit_int8(0x66); // size prefix
3111         addr_nop_5();
3112         break;
3113       default:
3114         assert(i &lt; 12, &quot; &quot;);
3115     }
3116 
3117     // Generate second nop for size between 11-1
3118     switch (i) {
3119       case 11:
3120         emit_int8(0x66); // size prefix
3121       case 10:
3122         emit_int8(0x66); // size prefix
3123       case 9:
3124         emit_int8(0x66); // size prefix
3125       case 8:
3126         addr_nop_8();
3127         break;
3128       case 7:
3129         addr_nop_7();
3130         break;
3131       case 6:
3132         emit_int8(0x66); // size prefix
3133       case 5:
3134         addr_nop_5();
3135         break;
3136       case 4:
3137         addr_nop_4();
3138         break;
3139       case 3:
3140         // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding
3141         emit_int8(0x66); // size prefix
3142       case 2:
3143         emit_int8(0x66); // size prefix
3144       case 1:
3145         emit_int8((unsigned char)0x90);
3146                          // nop
3147         break;
3148       default:
3149         assert(i == 0, &quot; &quot;);
3150     }
3151     return;
3152   }
3153 
3154   if (UseAddressNop &amp;&amp; VM_Version::is_zx()) {
3155     //
3156     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for ZX
3157     //  1: 0x90
3158     //  2: 0x66 0x90
3159     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3160     //  4: 0x0F 0x1F 0x40 0x00
3161     //  5: 0x0F 0x1F 0x44 0x00 0x00
3162     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3163     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3164     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3165     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3166     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3167     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3168 
3169     // The rest coding is ZX specific - don&#39;t use consecutive address nops
3170 
3171     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3172     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3173     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3174     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3175 
3176     while (i &gt;= 15) {
3177       // For ZX don&#39;t generate consecutive addess nops (mix with regular nops)
3178       i -= 15;
<a name="156" id="anc156"></a><span class="line-modified">3179       emit_int24(0x66, 0x66, 0x66);</span>


3180       addr_nop_8();
<a name="157" id="anc157"></a><span class="line-modified">3181       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3182     }
3183     switch (i) {
3184       case 14:
3185         emit_int8(0x66); // size prefix
3186       case 13:
3187         emit_int8(0x66); // size prefix
3188       case 12:
3189         addr_nop_8();
<a name="158" id="anc158"></a><span class="line-modified">3190         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3191         break;
3192       case 11:
3193         emit_int8(0x66); // size prefix
3194       case 10:
3195         emit_int8(0x66); // size prefix
3196       case 9:
3197         emit_int8(0x66); // size prefix
3198       case 8:
3199         addr_nop_8();
3200         break;
3201       case 7:
3202         addr_nop_7();
3203         break;
3204       case 6:
3205         emit_int8(0x66); // size prefix
3206       case 5:
3207         addr_nop_5();
3208         break;
3209       case 4:
3210         addr_nop_4();
3211         break;
3212       case 3:
3213         // Don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding
3214         emit_int8(0x66); // size prefix
3215       case 2:
3216         emit_int8(0x66); // size prefix
3217       case 1:
3218         emit_int8((unsigned char)0x90);
3219                          // nop
3220         break;
3221       default:
3222         assert(i == 0, &quot; &quot;);
3223     }
3224     return;
3225   }
3226 
3227   // Using nops with size prefixes &quot;0x66 0x90&quot;.
3228   // From AMD Optimization Guide:
3229   //  1: 0x90
3230   //  2: 0x66 0x90
3231   //  3: 0x66 0x66 0x90
3232   //  4: 0x66 0x66 0x66 0x90
3233   //  5: 0x66 0x66 0x90 0x66 0x90
3234   //  6: 0x66 0x66 0x90 0x66 0x66 0x90
3235   //  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
3236   //  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
3237   //  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3238   // 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3239   //
<a name="159" id="anc159"></a><span class="line-modified">3240   while (i &gt; 12) {</span>
3241     i -= 4;
<a name="160" id="anc160"></a><span class="line-modified">3242     emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3243   }
3244   // 1 - 12 nops
<a name="161" id="anc161"></a><span class="line-modified">3245   if (i &gt; 8) {</span>
<span class="line-modified">3246     if (i &gt; 9) {</span>
3247       i -= 1;
3248       emit_int8(0x66);
3249     }
3250     i -= 3;
<a name="162" id="anc162"></a><span class="line-modified">3251     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>


3252   }
3253   // 1 - 8 nops
<a name="163" id="anc163"></a><span class="line-modified">3254   if (i &gt; 4) {</span>
<span class="line-modified">3255     if (i &gt; 6) {</span>
3256       i -= 1;
3257       emit_int8(0x66);
3258     }
3259     i -= 3;
<a name="164" id="anc164"></a><span class="line-modified">3260     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>


3261   }
3262   switch (i) {
3263     case 4:
3264       emit_int8(0x66);
3265     case 3:
3266       emit_int8(0x66);
3267     case 2:
3268       emit_int8(0x66);
3269     case 1:
3270       emit_int8((unsigned char)0x90);
3271       break;
3272     default:
3273       assert(i == 0, &quot; &quot;);
3274   }
3275 }
3276 
3277 void Assembler::notl(Register dst) {
3278   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="165" id="anc165"></a><span class="line-modified">3279   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>

3280 }
3281 
3282 void Assembler::orl(Address dst, int32_t imm32) {
3283   InstructionMark im(this);
3284   prefix(dst);
3285   emit_arith_operand(0x81, rcx, dst, imm32);
3286 }
3287 
3288 void Assembler::orl(Register dst, int32_t imm32) {
3289   prefix(dst);
3290   emit_arith(0x81, 0xC8, dst, imm32);
3291 }
3292 
3293 void Assembler::orl(Register dst, Address src) {
3294   InstructionMark im(this);
3295   prefix(src, dst);
3296   emit_int8(0x0B);
3297   emit_operand(dst, src);
3298 }
3299 
3300 void Assembler::orl(Register dst, Register src) {
3301   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
3302   emit_arith(0x0B, 0xC0, dst, src);
3303 }
3304 
3305 void Assembler::orl(Address dst, Register src) {
3306   InstructionMark im(this);
3307   prefix(dst, src);
3308   emit_int8(0x09);
3309   emit_operand(src, dst);
3310 }
3311 
3312 void Assembler::orb(Address dst, int imm8) {
3313   InstructionMark im(this);
3314   prefix(dst);
3315   emit_int8((unsigned char)0x80);
3316   emit_operand(rcx, dst, 1);
3317   emit_int8(imm8);
3318 }
3319 
3320 void Assembler::packuswb(XMMRegister dst, Address src) {
3321   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3322   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3323   InstructionMark im(this);
3324   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3325   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3326   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3327   emit_int8(0x67);
3328   emit_operand(dst, src);
3329 }
3330 
3331 void Assembler::packuswb(XMMRegister dst, XMMRegister src) {
3332   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3333   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3334   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="166" id="anc166"></a><span class="line-modified">3335   emit_int16(0x67, (0xC0 | encode));</span>

3336 }
3337 
3338 void Assembler::vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3339   assert(UseAVX &gt; 0, &quot;some form of AVX must be enabled&quot;);
3340   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3341   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="167" id="anc167"></a><span class="line-modified">3342   emit_int16(0x67, (0xC0 | encode));</span>

3343 }
3344 
3345 void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
3346   assert(VM_Version::supports_avx2(), &quot;&quot;);
3347   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3348   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="168" id="anc168"></a><span class="line-modified">3349   emit_int24(0x00, (0xC0 | encode), imm8);</span>


3350 }
3351 
3352 void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3353   assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);
3354   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3355   attributes.set_is_evex_instruction();
3356   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="169" id="anc169"></a><span class="line-modified">3357   emit_int16(0x36, (0xC0 | encode));</span>

3358 }
3359 
3360 void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
3361   assert(VM_Version::supports_avx2(), &quot;&quot;);
3362   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3363   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="170" id="anc170"></a><span class="line-modified">3364   emit_int24(0x46, (0xC0 | encode), imm8);</span>


3365 }
3366 
3367 void Assembler::vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {
3368   assert(VM_Version::supports_avx(), &quot;&quot;);
3369   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3370   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="171" id="anc171"></a><span class="line-modified">3371   emit_int24(0x06, (0xC0 | encode), imm8);</span>


3372 }
3373 
3374 void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3375   assert(VM_Version::supports_evex(), &quot;&quot;);
3376   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3377   attributes.set_is_evex_instruction();
3378   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="172" id="anc172"></a><span class="line-modified">3379   emit_int16(0x76, (0xC0 | encode));</span>

3380 }
3381 
3382 
3383 void Assembler::pause() {
<a name="173" id="anc173"></a><span class="line-modified">3384   emit_int16((unsigned char)0xF3, (unsigned char)0x90);</span>

3385 }
3386 
3387 void Assembler::ud2() {
<a name="174" id="anc174"></a><span class="line-modified">3388   emit_int16(0x0F, 0x0B);</span>

3389 }
3390 
3391 void Assembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
3392   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3393   InstructionMark im(this);
3394   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3395   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3396   emit_int8(0x61);
3397   emit_operand(dst, src);
3398   emit_int8(imm8);
3399 }
3400 
3401 void Assembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
3402   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3403   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3404   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="175" id="anc175"></a><span class="line-modified">3405   emit_int24(0x61, (0xC0 | encode), imm8);</span>


3406 }
3407 
3408 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3409 void Assembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
3410   assert(VM_Version::supports_sse2(), &quot;&quot;);
3411   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3412   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="176" id="anc176"></a><span class="line-modified">3413   emit_int16(0x74, (0xC0 | encode));</span>

3414 }
3415 
3416 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3417 void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3418   assert(VM_Version::supports_avx(), &quot;&quot;);
3419   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3420   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="177" id="anc177"></a><span class="line-modified">3421   emit_int16(0x74, (0xC0 | encode));</span>

3422 }
3423 
3424 // In this context, kdst is written the mask used to process the equal components
3425 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3426   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3427   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3428   attributes.set_is_evex_instruction();
3429   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="178" id="anc178"></a><span class="line-modified">3430   emit_int16(0x74, (0xC0 | encode));</span>

3431 }
3432 
3433 void Assembler::evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3434   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3435   InstructionMark im(this);
3436   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3437   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3438   attributes.set_is_evex_instruction();
3439   int dst_enc = kdst-&gt;encoding();
3440   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3441   emit_int8(0x64);
3442   emit_operand(as_Register(dst_enc), src);
3443 }
3444 
3445 void Assembler::evpcmpgtb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3446   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3447   InstructionMark im(this);
3448   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3449   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3450   attributes.reset_is_clear_context();
3451   attributes.set_embedded_opmask_register_specifier(mask);
3452   attributes.set_is_evex_instruction();
3453   int dst_enc = kdst-&gt;encoding();
3454   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3455   emit_int8(0x64);
3456   emit_operand(as_Register(dst_enc), src);
3457 }
3458 
3459 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3460   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3461   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3462   attributes.set_is_evex_instruction();
3463   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="179" id="anc179"></a><span class="line-modified">3464   emit_int24(0x3E, (0xC0 | encode), vcc);</span>


3465 }
3466 
3467 void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3468   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3469   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3470   attributes.reset_is_clear_context();
3471   attributes.set_embedded_opmask_register_specifier(mask);
3472   attributes.set_is_evex_instruction();
3473   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="180" id="anc180"></a><span class="line-modified">3474   emit_int24(0x3E, (0xC0 | encode), vcc);</span>


3475 }
3476 
3477 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len) {
3478   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3479   InstructionMark im(this);
3480   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3481   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3482   attributes.set_is_evex_instruction();
3483   int dst_enc = kdst-&gt;encoding();
3484   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3485   emit_int8(0x3E);
3486   emit_operand(as_Register(dst_enc), src);
3487   emit_int8(vcc);
3488 }
3489 
3490 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3491   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3492   InstructionMark im(this);
3493   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3494   attributes.set_is_evex_instruction();
3495   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3496   int dst_enc = kdst-&gt;encoding();
3497   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3498   emit_int8(0x74);
3499   emit_operand(as_Register(dst_enc), src);
3500 }
3501 
3502 void Assembler::evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3503   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3504   InstructionMark im(this);
3505   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_reg_mask */ false, /* uses_vl */ true);
3506   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3507   attributes.reset_is_clear_context();
3508   attributes.set_embedded_opmask_register_specifier(mask);
3509   attributes.set_is_evex_instruction();
3510   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3511   emit_int8(0x74);
3512   emit_operand(as_Register(kdst-&gt;encoding()), src);
3513 }
3514 
3515 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3516 void Assembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
3517   assert(VM_Version::supports_sse2(), &quot;&quot;);
3518   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3519   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="181" id="anc181"></a><span class="line-modified">3520   emit_int16(0x75, (0xC0 | encode));</span>

3521 }
3522 
3523 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3524 void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3525   assert(VM_Version::supports_avx(), &quot;&quot;);
3526   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3527   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="182" id="anc182"></a><span class="line-modified">3528   emit_int16(0x75, (0xC0 | encode));</span>

3529 }
3530 
3531 // In this context, kdst is written the mask used to process the equal components
3532 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3533   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3534   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3535   attributes.set_is_evex_instruction();
3536   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="183" id="anc183"></a><span class="line-modified">3537   emit_int16(0x75, (0xC0 | encode));</span>

3538 }
3539 
3540 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3541   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3542   InstructionMark im(this);
3543   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3544   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3545   attributes.set_is_evex_instruction();
3546   int dst_enc = kdst-&gt;encoding();
3547   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3548   emit_int8(0x75);
3549   emit_operand(as_Register(dst_enc), src);
3550 }
3551 
3552 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3553 void Assembler::pcmpeqd(XMMRegister dst, XMMRegister src) {
3554   assert(VM_Version::supports_sse2(), &quot;&quot;);
3555   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3556   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="184" id="anc184"></a><span class="line-modified">3557   emit_int16(0x76, (0xC0 | encode));</span>

3558 }
3559 
3560 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3561 void Assembler::vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3562   assert(VM_Version::supports_avx(), &quot;&quot;);
3563   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3564   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="185" id="anc185"></a><span class="line-modified">3565   emit_int16(0x76, (0xC0 | encode));</span>

3566 }
3567 
3568 // In this context, kdst is written the mask used to process the equal components
3569 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3570   assert(VM_Version::supports_evex(), &quot;&quot;);
3571   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3572   attributes.set_is_evex_instruction();
3573   attributes.reset_is_clear_context();
3574   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="186" id="anc186"></a><span class="line-modified">3575   emit_int16(0x76, (0xC0 | encode));</span>

3576 }
3577 
3578 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3579   assert(VM_Version::supports_evex(), &quot;&quot;);
3580   InstructionMark im(this);
3581   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3582   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3583   attributes.reset_is_clear_context();
3584   attributes.set_is_evex_instruction();
3585   int dst_enc = kdst-&gt;encoding();
3586   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3587   emit_int8(0x76);
3588   emit_operand(as_Register(dst_enc), src);
3589 }
3590 
3591 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3592 void Assembler::pcmpeqq(XMMRegister dst, XMMRegister src) {
3593   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3594   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3595   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="187" id="anc187"></a><span class="line-modified">3596   emit_int16(0x29, (0xC0 | encode));</span>

3597 }
3598 
3599 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3600 void Assembler::vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3601   assert(VM_Version::supports_avx(), &quot;&quot;);
3602   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3603   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="188" id="anc188"></a><span class="line-modified">3604   emit_int16(0x29, (0xC0 | encode));</span>

3605 }
3606 
3607 // In this context, kdst is written the mask used to process the equal components
3608 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3609   assert(VM_Version::supports_evex(), &quot;&quot;);
3610   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3611   attributes.reset_is_clear_context();
3612   attributes.set_is_evex_instruction();
3613   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="189" id="anc189"></a><span class="line-modified">3614   emit_int16(0x29, (0xC0 | encode));</span>

3615 }
3616 
3617 // In this context, kdst is written the mask used to process the equal components
3618 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3619   assert(VM_Version::supports_evex(), &quot;&quot;);
3620   InstructionMark im(this);
3621   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3622   attributes.reset_is_clear_context();
3623   attributes.set_is_evex_instruction();
3624   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
3625   int dst_enc = kdst-&gt;encoding();
3626   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3627   emit_int8(0x29);
3628   emit_operand(as_Register(dst_enc), src);
3629 }
3630 
3631 void Assembler::pmovmskb(Register dst, XMMRegister src) {
3632   assert(VM_Version::supports_sse2(), &quot;&quot;);
3633   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3634   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="190" id="anc190"></a><span class="line-modified">3635   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>

3636 }
3637 
3638 void Assembler::vpmovmskb(Register dst, XMMRegister src) {
3639   assert(VM_Version::supports_avx2(), &quot;&quot;);
3640   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3641   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="191" id="anc191"></a><span class="line-modified">3642   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>

3643 }
3644 
3645 void Assembler::pextrd(Register dst, XMMRegister src, int imm8) {
3646   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3647   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3648   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="192" id="anc192"></a><span class="line-modified">3649   emit_int24(0x16, (0xC0 | encode), imm8);</span>


3650 }
3651 
3652 void Assembler::pextrd(Address dst, XMMRegister src, int imm8) {
3653   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3654   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3655   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3656   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3657   emit_int8(0x16);
3658   emit_operand(src, dst);
3659   emit_int8(imm8);
3660 }
3661 
3662 void Assembler::pextrq(Register dst, XMMRegister src, int imm8) {
3663   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3664   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3665   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="193" id="anc193"></a><span class="line-modified">3666   emit_int24(0x16, (0xC0 | encode), imm8);</span>


3667 }
3668 
3669 void Assembler::pextrq(Address dst, XMMRegister src, int imm8) {
3670   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3671   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3672   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3673   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3674   emit_int8(0x16);
3675   emit_operand(src, dst);
3676   emit_int8(imm8);
3677 }
3678 
3679 void Assembler::pextrw(Register dst, XMMRegister src, int imm8) {
3680   assert(VM_Version::supports_sse2(), &quot;&quot;);
3681   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3682   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="194" id="anc194"></a><span class="line-modified">3683   emit_int24((unsigned char)0xC5, (0xC0 | encode), imm8);</span>


3684 }
3685 
3686 void Assembler::pextrw(Address dst, XMMRegister src, int imm8) {
3687   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3688   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3689   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3690   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="195" id="anc195"></a><span class="line-modified">3691   emit_int8(0x15);</span>
3692   emit_operand(src, dst);
3693   emit_int8(imm8);
3694 }
3695 
3696 void Assembler::pextrb(Address dst, XMMRegister src, int imm8) {
3697   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3698   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3699   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3700   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3701   emit_int8(0x14);
3702   emit_operand(src, dst);
3703   emit_int8(imm8);
3704 }
3705 
3706 void Assembler::pinsrd(XMMRegister dst, Register src, int imm8) {
3707   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3708   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3709   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="196" id="anc196"></a><span class="line-modified">3710   emit_int24(0x22, (0xC0 | encode), imm8);</span>


3711 }
3712 
3713 void Assembler::pinsrd(XMMRegister dst, Address src, int imm8) {
3714   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3715   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3716   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3717   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3718   emit_int8(0x22);
3719   emit_operand(dst,src);
3720   emit_int8(imm8);
3721 }
3722 
3723 void Assembler::pinsrq(XMMRegister dst, Register src, int imm8) {
3724   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3725   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3726   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="197" id="anc197"></a><span class="line-modified">3727   emit_int24(0x22, (0xC0 | encode), imm8);</span>


3728 }
3729 
3730 void Assembler::pinsrq(XMMRegister dst, Address src, int imm8) {
3731   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3732   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3733   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3734   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3735   emit_int8(0x22);
3736   emit_operand(dst, src);
3737   emit_int8(imm8);
3738 }
3739 
3740 void Assembler::pinsrw(XMMRegister dst, Register src, int imm8) {
3741   assert(VM_Version::supports_sse2(), &quot;&quot;);
3742   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3743   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="198" id="anc198"></a><span class="line-modified">3744   emit_int24((unsigned char)0xC4, (0xC0 | encode), imm8);</span>


3745 }
3746 
3747 void Assembler::pinsrw(XMMRegister dst, Address src, int imm8) {
3748   assert(VM_Version::supports_sse2(), &quot;&quot;);
3749   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3750   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3751   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3752   emit_int8((unsigned char)0xC4);
3753   emit_operand(dst, src);
3754   emit_int8(imm8);
3755 }
3756 
3757 void Assembler::pinsrb(XMMRegister dst, Address src, int imm8) {
3758   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3759   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3760   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3761   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3762   emit_int8(0x20);
3763   emit_operand(dst, src);
3764   emit_int8(imm8);
3765 }
3766 
3767 void Assembler::pmovzxbw(XMMRegister dst, Address src) {
3768   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3769   InstructionMark im(this);
3770   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3771   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3772   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3773   emit_int8(0x30);
3774   emit_operand(dst, src);
3775 }
3776 
3777 void Assembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
3778   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3779   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3780   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="199" id="anc199"></a><span class="line-modified">3781   emit_int16(0x30, (0xC0 | encode));</span>

3782 }
3783 
3784 void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {
3785   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3786   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3787   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="200" id="anc200"></a><span class="line-modified">3788   emit_int16(0x20, (0xC0 | encode));</span>

3789 }
3790 
3791 void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3792   assert(VM_Version::supports_avx(), &quot;&quot;);
3793   InstructionMark im(this);
3794   assert(dst != xnoreg, &quot;sanity&quot;);
3795   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3796   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3797   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3798   emit_int8(0x30);
3799   emit_operand(dst, src);
3800 }
3801 
3802 void Assembler::vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) {
3803   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
3804   vector_len == AVX_256bit? VM_Version::supports_avx2() :
3805   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
3806   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3807   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="201" id="anc201"></a><span class="line-modified">3808   emit_int16(0x30, (unsigned char) (0xC0 | encode));</span>

3809 }
3810 
3811 void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {
3812   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
3813   vector_len == AVX_256bit? VM_Version::supports_avx2() :
3814   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
3815   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3816   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="202" id="anc202"></a><span class="line-modified">3817   emit_int16(0x20, (0xC0 | encode));</span>

3818 }
3819 
3820 void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
3821   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3822   assert(dst != xnoreg, &quot;sanity&quot;);
3823   InstructionMark im(this);
3824   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3825   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3826   attributes.set_embedded_opmask_register_specifier(mask);
3827   attributes.set_is_evex_instruction();
3828   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3829   emit_int8(0x30);
3830   emit_operand(dst, src);
3831 }
3832 void Assembler::evpmovwb(Address dst, XMMRegister src, int vector_len) {
3833   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3834   assert(src != xnoreg, &quot;sanity&quot;);
3835   InstructionMark im(this);
3836   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3837   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3838   attributes.set_is_evex_instruction();
3839   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
3840   emit_int8(0x30);
3841   emit_operand(src, dst);
3842 }
3843 
3844 void Assembler::evpmovwb(Address dst, KRegister mask, XMMRegister src, int vector_len) {
3845   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3846   assert(src != xnoreg, &quot;sanity&quot;);
3847   InstructionMark im(this);
3848   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3849   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3850   attributes.reset_is_clear_context();
3851   attributes.set_embedded_opmask_register_specifier(mask);
3852   attributes.set_is_evex_instruction();
3853   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
3854   emit_int8(0x30);
3855   emit_operand(src, dst);
3856 }
3857 
3858 void Assembler::evpmovdb(Address dst, XMMRegister src, int vector_len) {
3859   assert(VM_Version::supports_evex(), &quot;&quot;);
3860   assert(src != xnoreg, &quot;sanity&quot;);
3861   InstructionMark im(this);
3862   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3863   attributes.set_address_attributes(/* tuple_type */ EVEX_QVM, /* input_size_in_bits */ EVEX_NObit);
3864   attributes.set_is_evex_instruction();
3865   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
3866   emit_int8(0x31);
3867   emit_operand(src, dst);
3868 }
3869 
3870 void Assembler::vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len) {
3871   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
3872   vector_len == AVX_256bit? VM_Version::supports_avx2() :
3873   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot; &quot;);
3874   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3875   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="203" id="anc203"></a><span class="line-modified">3876   emit_int16(0x33, (0xC0 | encode));</span>

3877 }
3878 
3879 void Assembler::pmaddwd(XMMRegister dst, XMMRegister src) {
3880   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3881   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3882   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="204" id="anc204"></a><span class="line-modified">3883   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>

3884 }
3885 
3886 void Assembler::vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3887   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
3888     (vector_len == AVX_256bit ? VM_Version::supports_avx2() :
3889     (vector_len == AVX_512bit ? VM_Version::supports_evex() : 0)), &quot;&quot;);
3890   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3891   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="205" id="anc205"></a><span class="line-modified">3892   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>

3893 }
3894 
3895 void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3896   assert(VM_Version::supports_evex(), &quot;&quot;);
<a name="206" id="anc206"></a><span class="line-modified">3897   assert(VM_Version::supports_avx512_vnni(), &quot;must support vnni&quot;);</span>
3898   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3899   attributes.set_is_evex_instruction();
3900   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="207" id="anc207"></a><span class="line-modified">3901   emit_int16(0x52, (0xC0 | encode));</span>

3902 }
3903 
3904 // generic
3905 void Assembler::pop(Register dst) {
3906   int encode = prefix_and_encode(dst-&gt;encoding());
3907   emit_int8(0x58 | encode);
3908 }
3909 
3910 void Assembler::popcntl(Register dst, Address src) {
3911   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
3912   InstructionMark im(this);
3913   emit_int8((unsigned char)0xF3);
3914   prefix(src, dst);
<a name="208" id="anc208"></a><span class="line-modified">3915   emit_int16(0x0F, (unsigned char)0xB8);</span>

3916   emit_operand(dst, src);
3917 }
3918 
3919 void Assembler::popcntl(Register dst, Register src) {
3920   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
3921   emit_int8((unsigned char)0xF3);
3922   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="209" id="anc209"></a><span class="line-modified">3923   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>


3924 }
3925 
3926 void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<a name="210" id="anc210"></a><span class="line-modified">3927   assert(VM_Version::supports_avx512_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
3928   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3929   attributes.set_is_evex_instruction();
3930   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="211" id="anc211"></a><span class="line-modified">3931   emit_int16(0x55, (0xC0 | encode));</span>

3932 }
3933 
3934 void Assembler::popf() {
3935   emit_int8((unsigned char)0x9D);
3936 }
3937 
3938 #ifndef _LP64 // no 32bit push/pop on amd64
3939 void Assembler::popl(Address dst) {
3940   // NOTE: this will adjust stack by 8byte on 64bits
3941   InstructionMark im(this);
3942   prefix(dst);
3943   emit_int8((unsigned char)0x8F);
3944   emit_operand(rax, dst);
3945 }
3946 #endif
3947 
<a name="212" id="anc212"></a>




3948 void Assembler::prefetchnta(Address src) {
3949   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3950   InstructionMark im(this);
<a name="213" id="anc213"></a><span class="line-modified">3951   prefix(src);</span>
<span class="line-modified">3952   emit_int16(0x0F, 0x18);</span>
3953   emit_operand(rax, src); // 0, src
3954 }
3955 
3956 void Assembler::prefetchr(Address src) {
3957   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
3958   InstructionMark im(this);
<a name="214" id="anc214"></a><span class="line-modified">3959   prefix(src);</span>
<span class="line-modified">3960   emit_int16(0x0F, 0x0D);</span>
3961   emit_operand(rax, src); // 0, src
3962 }
3963 
3964 void Assembler::prefetcht0(Address src) {
3965   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3966   InstructionMark im(this);
<a name="215" id="anc215"></a><span class="line-modified">3967   prefix(src);</span>
<span class="line-modified">3968   emit_int16(0x0F, 0x18);</span>
3969   emit_operand(rcx, src); // 1, src
3970 }
3971 
3972 void Assembler::prefetcht1(Address src) {
3973   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3974   InstructionMark im(this);
<a name="216" id="anc216"></a><span class="line-modified">3975   prefix(src);</span>
<span class="line-modified">3976   emit_int16(0x0F, 0x18);</span>
3977   emit_operand(rdx, src); // 2, src
3978 }
3979 
3980 void Assembler::prefetcht2(Address src) {
3981   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3982   InstructionMark im(this);
<a name="217" id="anc217"></a><span class="line-modified">3983   prefix(src);</span>
<span class="line-modified">3984   emit_int16(0x0F, 0x18);</span>
3985   emit_operand(rbx, src); // 3, src
3986 }
3987 
3988 void Assembler::prefetchw(Address src) {
3989   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
3990   InstructionMark im(this);
<a name="218" id="anc218"></a><span class="line-modified">3991   prefix(src);</span>
<span class="line-modified">3992   emit_int16(0x0F, 0x0D);</span>
3993   emit_operand(rcx, src); // 1, src
3994 }
3995 
3996 void Assembler::prefix(Prefix p) {
3997   emit_int8(p);
3998 }
3999 
4000 void Assembler::pshufb(XMMRegister dst, XMMRegister src) {
4001   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4002   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4003   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="219" id="anc219"></a><span class="line-modified">4004   emit_int16(0x00, (0xC0 | encode));</span>

4005 }
4006 
4007 void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4008   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4009          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4010          vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4011   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4012   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="220" id="anc220"></a><span class="line-modified">4013   emit_int16(0x00, (0xC0 | encode));</span>

4014 }
4015 
4016 void Assembler::pshufb(XMMRegister dst, Address src) {
4017   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4018   InstructionMark im(this);
4019   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4020   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4021   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4022   emit_int8(0x00);
4023   emit_operand(dst, src);
4024 }
4025 
4026 void Assembler::pshufd(XMMRegister dst, XMMRegister src, int mode) {
4027   assert(isByte(mode), &quot;invalid value&quot;);
4028   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4029   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
4030   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4031   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="221" id="anc221"></a><span class="line-modified">4032   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>


4033 }
4034 
4035 void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
4036   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4037          (vector_len == AVX_256bit? VM_Version::supports_avx2() :
4038          (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);
4039   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4040   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4041   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="222" id="anc222"></a><span class="line-modified">4042   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>


4043 }
4044 
4045 void Assembler::pshufd(XMMRegister dst, Address src, int mode) {
4046   assert(isByte(mode), &quot;invalid value&quot;);
4047   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4048   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4049   InstructionMark im(this);
4050   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4051   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4052   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4053   emit_int8(0x70);
4054   emit_operand(dst, src);
4055   emit_int8(mode &amp; 0xFF);
4056 }
4057 
4058 void Assembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
4059   assert(isByte(mode), &quot;invalid value&quot;);
4060   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4061   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4062   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="223" id="anc223"></a><span class="line-modified">4063   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>


4064 }
4065 
4066 void Assembler::pshuflw(XMMRegister dst, Address src, int mode) {
4067   assert(isByte(mode), &quot;invalid value&quot;);
4068   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4069   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4070   InstructionMark im(this);
4071   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4072   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4073   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4074   emit_int8(0x70);
4075   emit_operand(dst, src);
4076   emit_int8(mode &amp; 0xFF);
4077 }
4078 
4079 void Assembler::evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4080   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
4081   assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
4082   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4083   attributes.set_is_evex_instruction();
4084   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="224" id="anc224"></a><span class="line-modified">4085   emit_int24(0x43, (0xC0 | encode), imm8 &amp; 0xFF);</span>


4086 }
4087 
4088 void Assembler::psrldq(XMMRegister dst, int shift) {
4089   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4090   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4091   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4092   int encode = simd_prefix_and_encode(xmm3, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="225" id="anc225"></a><span class="line-modified">4093   emit_int24(0x73, (0xC0 | encode), shift);</span>


4094 }
4095 
4096 void Assembler::vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4097   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4098          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4099          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4100   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4101   int encode = vex_prefix_and_encode(xmm3-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="226" id="anc226"></a><span class="line-modified">4102   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


4103 }
4104 
4105 void Assembler::pslldq(XMMRegister dst, int shift) {
4106   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4107   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4108   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4109   // XMM7 is for /7 encoding: 66 0F 73 /7 ib
4110   int encode = simd_prefix_and_encode(xmm7, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="227" id="anc227"></a><span class="line-modified">4111   emit_int24(0x73, (0xC0 | encode), shift);</span>


4112 }
4113 
4114 void Assembler::vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4115   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4116          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4117          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4118   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4119   int encode = vex_prefix_and_encode(xmm7-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="228" id="anc228"></a><span class="line-modified">4120   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


4121 }
4122 
4123 void Assembler::ptest(XMMRegister dst, Address src) {
4124   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4125   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4126   InstructionMark im(this);
4127   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4128   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4129   emit_int8(0x17);
4130   emit_operand(dst, src);
4131 }
4132 
4133 void Assembler::ptest(XMMRegister dst, XMMRegister src) {
4134   assert(VM_Version::supports_sse4_1() || VM_Version::supports_avx(), &quot;&quot;);
4135   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4136   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4137   emit_int8(0x17);
<a name="229" id="anc229"></a><span class="line-modified">4138   emit_int8((0xC0 | encode));</span>
4139 }
4140 
4141 void Assembler::vptest(XMMRegister dst, Address src) {
4142   assert(VM_Version::supports_avx(), &quot;&quot;);
4143   InstructionMark im(this);
4144   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4145   assert(dst != xnoreg, &quot;sanity&quot;);
4146   // swap src&lt;-&gt;dst for encoding
4147   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4148   emit_int8(0x17);
4149   emit_operand(dst, src);
4150 }
4151 
4152 void Assembler::vptest(XMMRegister dst, XMMRegister src) {
4153   assert(VM_Version::supports_avx(), &quot;&quot;);
4154   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4155   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="230" id="anc230"></a><span class="line-modified">4156   emit_int16(0x17, (0xC0 | encode));</span>

4157 }
4158 
4159 void Assembler::punpcklbw(XMMRegister dst, Address src) {
4160   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4161   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4162   InstructionMark im(this);
4163   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4164   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4165   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4166   emit_int8(0x60);
4167   emit_operand(dst, src);
4168 }
4169 
4170 void Assembler::punpcklbw(XMMRegister dst, XMMRegister src) {
4171   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4172   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4173   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="231" id="anc231"></a><span class="line-modified">4174   emit_int16(0x60, (0xC0 | encode));</span>

4175 }
4176 
4177 void Assembler::punpckldq(XMMRegister dst, Address src) {
4178   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4179   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4180   InstructionMark im(this);
4181   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4182   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4183   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4184   emit_int8(0x62);
4185   emit_operand(dst, src);
4186 }
4187 
4188 void Assembler::punpckldq(XMMRegister dst, XMMRegister src) {
4189   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4190   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4191   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="232" id="anc232"></a><span class="line-modified">4192   emit_int16(0x62, (0xC0 | encode));</span>

4193 }
4194 
4195 void Assembler::punpcklqdq(XMMRegister dst, XMMRegister src) {
4196   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4197   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4198   attributes.set_rex_vex_w_reverted();
4199   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="233" id="anc233"></a><span class="line-modified">4200   emit_int16(0x6C, (0xC0 | encode));</span>

4201 }
4202 
4203 void Assembler::push(int32_t imm32) {
4204   // in 64bits we push 64bits onto the stack but only
4205   // take a 32bit immediate
4206   emit_int8(0x68);
4207   emit_int32(imm32);
4208 }
4209 
4210 void Assembler::push(Register src) {
4211   int encode = prefix_and_encode(src-&gt;encoding());
<a name="234" id="anc234"></a>
4212   emit_int8(0x50 | encode);
4213 }
4214 
4215 void Assembler::pushf() {
4216   emit_int8((unsigned char)0x9C);
4217 }
4218 
4219 #ifndef _LP64 // no 32bit push/pop on amd64
4220 void Assembler::pushl(Address src) {
4221   // Note this will push 64bit on 64bit
4222   InstructionMark im(this);
4223   prefix(src);
4224   emit_int8((unsigned char)0xFF);
4225   emit_operand(rsi, src);
4226 }
4227 #endif
4228 
4229 void Assembler::rcll(Register dst, int imm8) {
4230   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4231   int encode = prefix_and_encode(dst-&gt;encoding());
4232   if (imm8 == 1) {
<a name="235" id="anc235"></a><span class="line-modified">4233     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>

4234   } else {
<a name="236" id="anc236"></a><span class="line-modified">4235     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>


4236   }
4237 }
4238 
4239 void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
4240   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4241   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4242   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="237" id="anc237"></a><span class="line-modified">4243   emit_int16(0x53, (0xC0 | encode));</span>

4244 }
4245 
4246 void Assembler::rcpss(XMMRegister dst, XMMRegister src) {
4247   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4248   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4249   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="238" id="anc238"></a><span class="line-modified">4250   emit_int16(0x53, (0xC0 | encode));</span>

4251 }
4252 
4253 void Assembler::rdtsc() {
<a name="239" id="anc239"></a><span class="line-modified">4254   emit_int16(0x0F, 0x31);</span>

4255 }
4256 
4257 // copies data from [esi] to [edi] using rcx pointer sized words
4258 // generic
4259 void Assembler::rep_mov() {
<a name="240" id="anc240"></a><span class="line-modified">4260   // REP</span>
4261   // MOVSQ
<a name="241" id="anc241"></a><span class="line-modified">4262   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xA5);)</span>
<span class="line-modified">4263   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xA5);)</span>
4264 }
4265 
4266 // sets rcx bytes with rax, value at [edi]
4267 void Assembler::rep_stosb() {
<a name="242" id="anc242"></a><span class="line-modified">4268   // REP</span>
<span class="line-modified">4269   // STOSB</span>
<span class="line-modified">4270   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAA);)</span>
<span class="line-added">4271   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAA);)</span>
4272 }
4273 
4274 // sets rcx pointer sized words with rax, value at [edi]
4275 // generic
4276 void Assembler::rep_stos() {
<a name="243" id="anc243"></a><span class="line-modified">4277   // REP</span>
<span class="line-modified">4278   // LP64:STOSQ, LP32:STOSD</span>
<span class="line-modified">4279   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAB);)</span>
<span class="line-added">4280   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAB);)</span>
4281 }
4282 
4283 // scans rcx pointer sized words at [edi] for occurance of rax,
4284 // generic
4285 void Assembler::repne_scan() { // repne_scan
<a name="244" id="anc244"></a>
4286   // SCASQ
<a name="245" id="anc245"></a><span class="line-modified">4287   LP64_ONLY(emit_int24((unsigned char)0xF2, REX_W, (unsigned char)0xAF);)</span>
<span class="line-modified">4288   NOT_LP64( emit_int16((unsigned char)0xF2,        (unsigned char)0xAF);)</span>
4289 }
4290 
4291 #ifdef _LP64
4292 // scans rcx 4 byte words at [edi] for occurance of rax,
4293 // generic
4294 void Assembler::repne_scanl() { // repne_scan
<a name="246" id="anc246"></a>
4295   // SCASL
<a name="247" id="anc247"></a><span class="line-modified">4296   emit_int16((unsigned char)0xF2, (unsigned char)0xAF);</span>
4297 }
4298 #endif
4299 
4300 void Assembler::ret(int imm16) {
4301   if (imm16 == 0) {
4302     emit_int8((unsigned char)0xC3);
4303   } else {
4304     emit_int8((unsigned char)0xC2);
4305     emit_int16(imm16);
4306   }
4307 }
4308 
4309 void Assembler::sahf() {
4310 #ifdef _LP64
4311   // Not supported in 64bit mode
4312   ShouldNotReachHere();
4313 #endif
4314   emit_int8((unsigned char)0x9E);
4315 }
4316 
4317 void Assembler::sarl(Register dst, int imm8) {
4318   int encode = prefix_and_encode(dst-&gt;encoding());
4319   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4320   if (imm8 == 1) {
<a name="248" id="anc248"></a><span class="line-modified">4321     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>

4322   } else {
<a name="249" id="anc249"></a><span class="line-modified">4323     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>


4324   }
4325 }
4326 
4327 void Assembler::sarl(Register dst) {
4328   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="250" id="anc250"></a><span class="line-modified">4329   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>

4330 }
4331 
4332 void Assembler::sbbl(Address dst, int32_t imm32) {
4333   InstructionMark im(this);
4334   prefix(dst);
4335   emit_arith_operand(0x81, rbx, dst, imm32);
4336 }
4337 
4338 void Assembler::sbbl(Register dst, int32_t imm32) {
4339   prefix(dst);
4340   emit_arith(0x81, 0xD8, dst, imm32);
4341 }
4342 
4343 
4344 void Assembler::sbbl(Register dst, Address src) {
4345   InstructionMark im(this);
4346   prefix(src, dst);
4347   emit_int8(0x1B);
4348   emit_operand(dst, src);
4349 }
4350 
4351 void Assembler::sbbl(Register dst, Register src) {
4352   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4353   emit_arith(0x1B, 0xC0, dst, src);
4354 }
4355 
4356 void Assembler::setb(Condition cc, Register dst) {
4357   assert(0 &lt;= cc &amp;&amp; cc &lt; 16, &quot;illegal cc&quot;);
4358   int encode = prefix_and_encode(dst-&gt;encoding(), true);
<a name="251" id="anc251"></a><span class="line-modified">4359   emit_int24(0x0F, (unsigned char)0x90 | cc, (0xC0 | encode));</span>


4360 }
4361 
4362 void Assembler::palignr(XMMRegister dst, XMMRegister src, int imm8) {
4363   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4364   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4365   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="252" id="anc252"></a><span class="line-modified">4366   emit_int24(0x0F, (0xC0 | encode), imm8);</span>


4367 }
4368 
4369 void Assembler::vpalignr(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4370   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4371          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4372          0, &quot;&quot;);
4373   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4374   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="253" id="anc253"></a><span class="line-modified">4375   emit_int24(0x0F, (0xC0 | encode), imm8);</span>


4376 }
4377 
4378 void Assembler::evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
4379   assert(VM_Version::supports_evex(), &quot;&quot;);
4380   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4381   attributes.set_is_evex_instruction();
4382   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="254" id="anc254"></a><span class="line-modified">4383   emit_int24(0x3, (0xC0 | encode), imm8);</span>


4384 }
4385 
4386 void Assembler::pblendw(XMMRegister dst, XMMRegister src, int imm8) {
4387   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4388   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4389   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="255" id="anc255"></a><span class="line-modified">4390   emit_int24(0x0E, (0xC0 | encode), imm8);</span>


4391 }
4392 
4393 void Assembler::sha1rnds4(XMMRegister dst, XMMRegister src, int imm8) {
4394   assert(VM_Version::supports_sha(), &quot;&quot;);
4395   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, /* rex_w */ false);
<a name="256" id="anc256"></a><span class="line-modified">4396   emit_int24((unsigned char)0xCC, (0xC0 | encode), (unsigned char)imm8);</span>


4397 }
4398 
4399 void Assembler::sha1nexte(XMMRegister dst, XMMRegister src) {
4400   assert(VM_Version::supports_sha(), &quot;&quot;);
4401   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<a name="257" id="anc257"></a><span class="line-modified">4402   emit_int16((unsigned char)0xC8, (0xC0 | encode));</span>

4403 }
4404 
4405 void Assembler::sha1msg1(XMMRegister dst, XMMRegister src) {
4406   assert(VM_Version::supports_sha(), &quot;&quot;);
4407   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<a name="258" id="anc258"></a><span class="line-modified">4408   emit_int16((unsigned char)0xC9, (0xC0 | encode));</span>

4409 }
4410 
4411 void Assembler::sha1msg2(XMMRegister dst, XMMRegister src) {
4412   assert(VM_Version::supports_sha(), &quot;&quot;);
4413   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<a name="259" id="anc259"></a><span class="line-modified">4414   emit_int16((unsigned char)0xCA, (0xC0 | encode));</span>

4415 }
4416 
4417 // xmm0 is implicit additional source to this instruction.
4418 void Assembler::sha256rnds2(XMMRegister dst, XMMRegister src) {
4419   assert(VM_Version::supports_sha(), &quot;&quot;);
4420   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<a name="260" id="anc260"></a><span class="line-modified">4421   emit_int16((unsigned char)0xCB, (0xC0 | encode));</span>

4422 }
4423 
4424 void Assembler::sha256msg1(XMMRegister dst, XMMRegister src) {
4425   assert(VM_Version::supports_sha(), &quot;&quot;);
4426   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<a name="261" id="anc261"></a><span class="line-modified">4427   emit_int16((unsigned char)0xCC, (0xC0 | encode));</span>

4428 }
4429 
4430 void Assembler::sha256msg2(XMMRegister dst, XMMRegister src) {
4431   assert(VM_Version::supports_sha(), &quot;&quot;);
4432   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<a name="262" id="anc262"></a><span class="line-modified">4433   emit_int16((unsigned char)0xCD, (0xC0 | encode));</span>

4434 }
4435 
4436 
4437 void Assembler::shll(Register dst, int imm8) {
4438   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4439   int encode = prefix_and_encode(dst-&gt;encoding());
4440   if (imm8 == 1 ) {
<a name="263" id="anc263"></a><span class="line-modified">4441     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>

4442   } else {
<a name="264" id="anc264"></a><span class="line-modified">4443     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>


4444   }
4445 }
4446 
4447 void Assembler::shll(Register dst) {
4448   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="265" id="anc265"></a><span class="line-modified">4449   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>

4450 }
4451 
4452 void Assembler::shrl(Register dst, int imm8) {
4453   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4454   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="266" id="anc266"></a><span class="line-modified">4455   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>


4456 }
4457 
4458 void Assembler::shrl(Register dst) {
4459   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="267" id="anc267"></a><span class="line-modified">4460   emit_int16((unsigned char)0xD3, (0xE8 | encode));</span>

4461 }
4462 
4463 void Assembler::shldl(Register dst, Register src) {
4464   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<a name="268" id="anc268"></a><span class="line-modified">4465   emit_int24(0x0F, (unsigned char)0xA5, (0xC0 | encode));</span>


4466 }
4467 
4468 void Assembler::shldl(Register dst, Register src, int8_t imm8) {
4469   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<a name="269" id="anc269"></a><span class="line-modified">4470   emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);</span>



4471 }
4472 
4473 void Assembler::shrdl(Register dst, Register src) {
4474   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<a name="270" id="anc270"></a><span class="line-modified">4475   emit_int24(0x0F, (unsigned char)0xAD, (0xC0 | encode));</span>


4476 }
4477 
4478 void Assembler::shrdl(Register dst, Register src, int8_t imm8) {
4479   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<a name="271" id="anc271"></a><span class="line-modified">4480   emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);</span>



4481 }
4482 
4483 // copies a single word from [esi] to [edi]
4484 void Assembler::smovl() {
4485   emit_int8((unsigned char)0xA5);
4486 }
4487 
4488 void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {
4489   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4490   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4491   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="272" id="anc272"></a><span class="line-modified">4492   emit_int24(0x0B, (0xC0 | encode), (unsigned char)rmode);</span>


4493 }
4494 
4495 void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {
4496   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4497   InstructionMark im(this);
4498   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4499   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4500   emit_int8(0x0B);
4501   emit_operand(dst, src);
4502   emit_int8((unsigned char)rmode);
4503 }
4504 
4505 void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
4506   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4507   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4508   attributes.set_rex_vex_w_reverted();
4509   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="273" id="anc273"></a><span class="line-modified">4510   emit_int16(0x51, (0xC0 | encode));</span>

4511 }
4512 
4513 void Assembler::sqrtsd(XMMRegister dst, Address src) {
4514   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4515   InstructionMark im(this);
4516   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4517   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4518   attributes.set_rex_vex_w_reverted();
4519   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4520   emit_int8(0x51);
4521   emit_operand(dst, src);
4522 }
4523 
4524 void Assembler::sqrtss(XMMRegister dst, XMMRegister src) {
4525   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4526   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4527   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="274" id="anc274"></a><span class="line-modified">4528   emit_int16(0x51, (0xC0 | encode));</span>

4529 }
4530 
4531 void Assembler::std() {
4532   emit_int8((unsigned char)0xFD);
4533 }
4534 
4535 void Assembler::sqrtss(XMMRegister dst, Address src) {
4536   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4537   InstructionMark im(this);
4538   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4539   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4540   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4541   emit_int8(0x51);
4542   emit_operand(dst, src);
4543 }
4544 
4545 void Assembler::stmxcsr( Address dst) {
4546   if (UseAVX &gt; 0 ) {
4547     assert(VM_Version::supports_avx(), &quot;&quot;);
4548     InstructionMark im(this);
4549     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4550     vex_prefix(dst, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
4551     emit_int8((unsigned char)0xAE);
4552     emit_operand(as_Register(3), dst);
4553   } else {
4554     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4555     InstructionMark im(this);
4556     prefix(dst);
<a name="275" id="anc275"></a><span class="line-modified">4557     emit_int16(0x0F, (unsigned char)0xAE);</span>

4558     emit_operand(as_Register(3), dst);
4559   }
4560 }
4561 
4562 void Assembler::subl(Address dst, int32_t imm32) {
4563   InstructionMark im(this);
4564   prefix(dst);
4565   emit_arith_operand(0x81, rbp, dst, imm32);
4566 }
4567 
4568 void Assembler::subl(Address dst, Register src) {
4569   InstructionMark im(this);
4570   prefix(dst, src);
4571   emit_int8(0x29);
4572   emit_operand(src, dst);
4573 }
4574 
4575 void Assembler::subl(Register dst, int32_t imm32) {
4576   prefix(dst);
4577   emit_arith(0x81, 0xE8, dst, imm32);
4578 }
4579 
4580 // Force generation of a 4 byte immediate value even if it fits into 8bit
4581 void Assembler::subl_imm32(Register dst, int32_t imm32) {
4582   prefix(dst);
4583   emit_arith_imm32(0x81, 0xE8, dst, imm32);
4584 }
4585 
4586 void Assembler::subl(Register dst, Address src) {
4587   InstructionMark im(this);
4588   prefix(src, dst);
4589   emit_int8(0x2B);
4590   emit_operand(dst, src);
4591 }
4592 
4593 void Assembler::subl(Register dst, Register src) {
4594   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4595   emit_arith(0x2B, 0xC0, dst, src);
4596 }
4597 
4598 void Assembler::subsd(XMMRegister dst, XMMRegister src) {
4599   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4600   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4601   attributes.set_rex_vex_w_reverted();
4602   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="276" id="anc276"></a><span class="line-modified">4603   emit_int16(0x5C, (0xC0 | encode));</span>

4604 }
4605 
4606 void Assembler::subsd(XMMRegister dst, Address src) {
4607   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4608   InstructionMark im(this);
4609   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4610   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4611   attributes.set_rex_vex_w_reverted();
4612   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4613   emit_int8(0x5C);
4614   emit_operand(dst, src);
4615 }
4616 
4617 void Assembler::subss(XMMRegister dst, XMMRegister src) {
4618   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4619   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ false);
4620   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="277" id="anc277"></a><span class="line-modified">4621   emit_int16(0x5C, (0xC0 | encode));</span>

4622 }
4623 
4624 void Assembler::subss(XMMRegister dst, Address src) {
4625   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4626   InstructionMark im(this);
4627   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4628   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4629   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4630   emit_int8(0x5C);
4631   emit_operand(dst, src);
4632 }
4633 
4634 void Assembler::testb(Register dst, int imm8) {
4635   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
4636   (void) prefix_and_encode(dst-&gt;encoding(), true);
4637   emit_arith_b(0xF6, 0xC0, dst, imm8);
4638 }
4639 
4640 void Assembler::testb(Address dst, int imm8) {
4641   InstructionMark im(this);
4642   prefix(dst);
4643   emit_int8((unsigned char)0xF6);
4644   emit_operand(rax, dst, 1);
4645   emit_int8(imm8);
4646 }
4647 
4648 void Assembler::testl(Register dst, int32_t imm32) {
4649   // not using emit_arith because test
4650   // doesn&#39;t support sign-extension of
4651   // 8bit operands
4652   int encode = dst-&gt;encoding();
4653   if (encode == 0) {
4654     emit_int8((unsigned char)0xA9);
4655   } else {
4656     encode = prefix_and_encode(encode);
<a name="278" id="anc278"></a><span class="line-modified">4657     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

4658   }
4659   emit_int32(imm32);
4660 }
4661 
4662 void Assembler::testl(Register dst, Register src) {
4663   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4664   emit_arith(0x85, 0xC0, dst, src);
4665 }
4666 
4667 void Assembler::testl(Register dst, Address src) {
4668   InstructionMark im(this);
4669   prefix(src, dst);
4670   emit_int8((unsigned char)0x85);
4671   emit_operand(dst, src);
4672 }
4673 
4674 void Assembler::tzcntl(Register dst, Register src) {
4675   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4676   emit_int8((unsigned char)0xF3);
4677   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="279" id="anc279"></a><span class="line-modified">4678   emit_int24(0x0F,</span>
<span class="line-modified">4679              (unsigned char)0xBC,</span>
<span class="line-modified">4680              0xC0 | encode);</span>
4681 }
4682 
4683 void Assembler::tzcntq(Register dst, Register src) {
4684   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4685   emit_int8((unsigned char)0xF3);
4686   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="280" id="anc280"></a><span class="line-modified">4687   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>


4688 }
4689 
4690 void Assembler::ucomisd(XMMRegister dst, Address src) {
4691   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4692   InstructionMark im(this);
4693   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4694   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4695   attributes.set_rex_vex_w_reverted();
4696   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4697   emit_int8(0x2E);
4698   emit_operand(dst, src);
4699 }
4700 
4701 void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
4702   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4703   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4704   attributes.set_rex_vex_w_reverted();
4705   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="281" id="anc281"></a><span class="line-modified">4706   emit_int16(0x2E, (0xC0 | encode));</span>

4707 }
4708 
4709 void Assembler::ucomiss(XMMRegister dst, Address src) {
4710   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4711   InstructionMark im(this);
4712   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4713   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4714   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
4715   emit_int8(0x2E);
4716   emit_operand(dst, src);
4717 }
4718 
4719 void Assembler::ucomiss(XMMRegister dst, XMMRegister src) {
4720   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4721   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4722   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="282" id="anc282"></a><span class="line-modified">4723   emit_int16(0x2E, (0xC0 | encode));</span>

4724 }
4725 
4726 void Assembler::xabort(int8_t imm8) {
<a name="283" id="anc283"></a><span class="line-modified">4727   emit_int24((unsigned char)0xC6, (unsigned char)0xF8, (imm8 &amp; 0xFF));</span>


4728 }
4729 
4730 void Assembler::xaddb(Address dst, Register src) {
4731   InstructionMark im(this);
4732   prefix(dst, src, true);
<a name="284" id="anc284"></a><span class="line-modified">4733   emit_int16(0x0F, (unsigned char)0xC0);</span>

4734   emit_operand(src, dst);
4735 }
4736 
4737 void Assembler::xaddw(Address dst, Register src) {
4738   InstructionMark im(this);
4739   emit_int8(0x66);
4740   prefix(dst, src);
<a name="285" id="anc285"></a><span class="line-modified">4741   emit_int16(0x0F, (unsigned char)0xC1);</span>

4742   emit_operand(src, dst);
4743 }
4744 
4745 void Assembler::xaddl(Address dst, Register src) {
4746   InstructionMark im(this);
4747   prefix(dst, src);
<a name="286" id="anc286"></a><span class="line-modified">4748   emit_int16(0x0F, (unsigned char)0xC1);</span>

4749   emit_operand(src, dst);
4750 }
4751 
4752 void Assembler::xbegin(Label&amp; abort, relocInfo::relocType rtype) {
4753   InstructionMark im(this);
4754   relocate(rtype);
4755   if (abort.is_bound()) {
4756     address entry = target(abort);
4757     assert(entry != NULL, &quot;abort entry NULL&quot;);
4758     intptr_t offset = entry - pc();
<a name="287" id="anc287"></a><span class="line-modified">4759     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>

4760     emit_int32(offset - 6); // 2 opcode + 4 address
4761   } else {
4762     abort.add_patch_at(code(), locator());
<a name="288" id="anc288"></a><span class="line-modified">4763     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>

4764     emit_int32(0);
4765   }
4766 }
4767 
4768 void Assembler::xchgb(Register dst, Address src) { // xchg
4769   InstructionMark im(this);
4770   prefix(src, dst, true);
4771   emit_int8((unsigned char)0x86);
4772   emit_operand(dst, src);
4773 }
4774 
4775 void Assembler::xchgw(Register dst, Address src) { // xchg
4776   InstructionMark im(this);
4777   emit_int8(0x66);
4778   prefix(src, dst);
4779   emit_int8((unsigned char)0x87);
4780   emit_operand(dst, src);
4781 }
4782 
4783 void Assembler::xchgl(Register dst, Address src) { // xchg
4784   InstructionMark im(this);
4785   prefix(src, dst);
4786   emit_int8((unsigned char)0x87);
4787   emit_operand(dst, src);
4788 }
4789 
4790 void Assembler::xchgl(Register dst, Register src) {
4791   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="289" id="anc289"></a><span class="line-modified">4792   emit_int16((unsigned char)0x87, (0xC0 | encode));</span>

4793 }
4794 
4795 void Assembler::xend() {
<a name="290" id="anc290"></a><span class="line-modified">4796   emit_int24(0x0F, 0x01, (unsigned char)0xD5);</span>


4797 }
4798 
4799 void Assembler::xgetbv() {
<a name="291" id="anc291"></a><span class="line-modified">4800   emit_int24(0x0F, 0x01, (unsigned char)0xD0);</span>


4801 }
4802 
4803 void Assembler::xorl(Register dst, int32_t imm32) {
4804   prefix(dst);
4805   emit_arith(0x81, 0xF0, dst, imm32);
4806 }
4807 
4808 void Assembler::xorl(Register dst, Address src) {
4809   InstructionMark im(this);
4810   prefix(src, dst);
4811   emit_int8(0x33);
4812   emit_operand(dst, src);
4813 }
4814 
4815 void Assembler::xorl(Register dst, Register src) {
4816   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4817   emit_arith(0x33, 0xC0, dst, src);
4818 }
4819 
4820 void Assembler::xorb(Register dst, Address src) {
4821   InstructionMark im(this);
4822   prefix(src, dst);
4823   emit_int8(0x32);
4824   emit_operand(dst, src);
4825 }
4826 
4827 // AVX 3-operands scalar float-point arithmetic instructions
4828 
4829 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, Address src) {
4830   assert(VM_Version::supports_avx(), &quot;&quot;);
4831   InstructionMark im(this);
4832   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4833   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4834   attributes.set_rex_vex_w_reverted();
4835   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4836   emit_int8(0x58);
4837   emit_operand(dst, src);
4838 }
4839 
4840 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4841   assert(VM_Version::supports_avx(), &quot;&quot;);
4842   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4843   attributes.set_rex_vex_w_reverted();
4844   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="292" id="anc292"></a><span class="line-modified">4845   emit_int16(0x58, (0xC0 | encode));</span>

4846 }
4847 
4848 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, Address src) {
4849   assert(VM_Version::supports_avx(), &quot;&quot;);
4850   InstructionMark im(this);
4851   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4852   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4853   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4854   emit_int8(0x58);
4855   emit_operand(dst, src);
4856 }
4857 
4858 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4859   assert(VM_Version::supports_avx(), &quot;&quot;);
4860   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4861   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="293" id="anc293"></a><span class="line-modified">4862   emit_int16(0x58, (0xC0 | encode));</span>

4863 }
4864 
4865 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, Address src) {
4866   assert(VM_Version::supports_avx(), &quot;&quot;);
4867   InstructionMark im(this);
4868   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4869   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4870   attributes.set_rex_vex_w_reverted();
4871   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4872   emit_int8(0x5E);
4873   emit_operand(dst, src);
4874 }
4875 
4876 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4877   assert(VM_Version::supports_avx(), &quot;&quot;);
4878   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4879   attributes.set_rex_vex_w_reverted();
4880   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="294" id="anc294"></a><span class="line-modified">4881   emit_int16(0x5E, (0xC0 | encode));</span>

4882 }
4883 
4884 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, Address src) {
4885   assert(VM_Version::supports_avx(), &quot;&quot;);
4886   InstructionMark im(this);
4887   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4888   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4889   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4890   emit_int8(0x5E);
4891   emit_operand(dst, src);
4892 }
4893 
4894 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4895   assert(VM_Version::supports_avx(), &quot;&quot;);
4896   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4897   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="295" id="anc295"></a><span class="line-modified">4898   emit_int16(0x5E, (0xC0 | encode));</span>

4899 }
4900 
4901 void Assembler::vfmadd231sd(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
4902   assert(VM_Version::supports_fma(), &quot;&quot;);
4903   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4904   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="296" id="anc296"></a><span class="line-modified">4905   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>

4906 }
4907 
4908 void Assembler::vfmadd231ss(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
4909   assert(VM_Version::supports_fma(), &quot;&quot;);
4910   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4911   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="297" id="anc297"></a><span class="line-modified">4912   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>

4913 }
4914 
4915 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, Address src) {
4916   assert(VM_Version::supports_avx(), &quot;&quot;);
4917   InstructionMark im(this);
4918   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4919   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4920   attributes.set_rex_vex_w_reverted();
4921   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4922   emit_int8(0x59);
4923   emit_operand(dst, src);
4924 }
4925 
4926 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4927   assert(VM_Version::supports_avx(), &quot;&quot;);
4928   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4929   attributes.set_rex_vex_w_reverted();
4930   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="298" id="anc298"></a><span class="line-modified">4931   emit_int16(0x59, (0xC0 | encode));</span>

4932 }
4933 
4934 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, Address src) {
4935   assert(VM_Version::supports_avx(), &quot;&quot;);
4936   InstructionMark im(this);
4937   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4938   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4939   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4940   emit_int8(0x59);
4941   emit_operand(dst, src);
4942 }
4943 
4944 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4945   assert(VM_Version::supports_avx(), &quot;&quot;);
4946   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4947   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="299" id="anc299"></a><span class="line-modified">4948   emit_int16(0x59, (0xC0 | encode));</span>

4949 }
4950 
4951 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, Address src) {
4952   assert(VM_Version::supports_avx(), &quot;&quot;);
4953   InstructionMark im(this);
4954   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4955   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4956   attributes.set_rex_vex_w_reverted();
4957   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4958   emit_int8(0x5C);
4959   emit_operand(dst, src);
4960 }
4961 
4962 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4963   assert(VM_Version::supports_avx(), &quot;&quot;);
4964   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4965   attributes.set_rex_vex_w_reverted();
4966   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="300" id="anc300"></a><span class="line-modified">4967   emit_int16(0x5C, (0xC0 | encode));</span>

4968 }
4969 
4970 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, Address src) {
4971   assert(VM_Version::supports_avx(), &quot;&quot;);
4972   InstructionMark im(this);
4973   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4974   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4975   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4976   emit_int8(0x5C);
4977   emit_operand(dst, src);
4978 }
4979 
4980 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4981   assert(VM_Version::supports_avx(), &quot;&quot;);
4982   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4983   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="301" id="anc301"></a><span class="line-modified">4984   emit_int16(0x5C, (0xC0 | encode));</span>

4985 }
4986 
4987 //====================VECTOR ARITHMETIC=====================================
4988 
4989 // Float-point vector arithmetic
4990 
4991 void Assembler::addpd(XMMRegister dst, XMMRegister src) {
4992   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4993   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4994   attributes.set_rex_vex_w_reverted();
4995   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="302" id="anc302"></a><span class="line-modified">4996   emit_int16(0x58, (0xC0 | encode));</span>

4997 }
4998 
4999 void Assembler::addpd(XMMRegister dst, Address src) {
5000   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5001   InstructionMark im(this);
5002   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5003   attributes.set_rex_vex_w_reverted();
5004   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5005   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5006   emit_int8(0x58);
5007   emit_operand(dst, src);
5008 }
5009 
5010 
5011 void Assembler::addps(XMMRegister dst, XMMRegister src) {
5012   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5013   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5014   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="303" id="anc303"></a><span class="line-modified">5015   emit_int16(0x58, (0xC0 | encode));</span>

5016 }
5017 
5018 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5019   assert(VM_Version::supports_avx(), &quot;&quot;);
5020   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5021   attributes.set_rex_vex_w_reverted();
5022   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="304" id="anc304"></a><span class="line-modified">5023   emit_int16(0x58, (0xC0 | encode));</span>

5024 }
5025 
5026 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5027   assert(VM_Version::supports_avx(), &quot;&quot;);
5028   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5029   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="305" id="anc305"></a><span class="line-modified">5030   emit_int16(0x58, (0xC0 | encode));</span>

5031 }
5032 
5033 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5034   assert(VM_Version::supports_avx(), &quot;&quot;);
5035   InstructionMark im(this);
5036   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5037   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5038   attributes.set_rex_vex_w_reverted();
5039   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5040   emit_int8(0x58);
5041   emit_operand(dst, src);
5042 }
5043 
5044 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5045   assert(VM_Version::supports_avx(), &quot;&quot;);
5046   InstructionMark im(this);
5047   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5048   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5049   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5050   emit_int8(0x58);
5051   emit_operand(dst, src);
5052 }
5053 
5054 void Assembler::subpd(XMMRegister dst, XMMRegister src) {
5055   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5056   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5057   attributes.set_rex_vex_w_reverted();
5058   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="306" id="anc306"></a><span class="line-modified">5059   emit_int16(0x5C, (0xC0 | encode));</span>

5060 }
5061 
5062 void Assembler::subps(XMMRegister dst, XMMRegister src) {
5063   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5064   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5065   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="307" id="anc307"></a><span class="line-modified">5066   emit_int16(0x5C, (0xC0 | encode));</span>

5067 }
5068 
5069 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5070   assert(VM_Version::supports_avx(), &quot;&quot;);
5071   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5072   attributes.set_rex_vex_w_reverted();
5073   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="308" id="anc308"></a><span class="line-modified">5074   emit_int16(0x5C, (0xC0 | encode));</span>

5075 }
5076 
5077 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5078   assert(VM_Version::supports_avx(), &quot;&quot;);
5079   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5080   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="309" id="anc309"></a><span class="line-modified">5081   emit_int16(0x5C, (0xC0 | encode));</span>

5082 }
5083 
5084 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5085   assert(VM_Version::supports_avx(), &quot;&quot;);
5086   InstructionMark im(this);
5087   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5088   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5089   attributes.set_rex_vex_w_reverted();
5090   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5091   emit_int8(0x5C);
5092   emit_operand(dst, src);
5093 }
5094 
5095 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5096   assert(VM_Version::supports_avx(), &quot;&quot;);
5097   InstructionMark im(this);
5098   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5099   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5100   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5101   emit_int8(0x5C);
5102   emit_operand(dst, src);
5103 }
5104 
5105 void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
5106   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5107   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5108   attributes.set_rex_vex_w_reverted();
5109   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="310" id="anc310"></a><span class="line-modified">5110   emit_int16(0x59, (0xC0 | encode));</span>

5111 }
5112 
5113 void Assembler::mulpd(XMMRegister dst, Address src) {
5114   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5115   InstructionMark im(this);
5116   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5117   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5118   attributes.set_rex_vex_w_reverted();
5119   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5120   emit_int8(0x59);
5121   emit_operand(dst, src);
5122 }
5123 
5124 void Assembler::mulps(XMMRegister dst, XMMRegister src) {
5125   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5126   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5127   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="311" id="anc311"></a><span class="line-modified">5128   emit_int16(0x59, (0xC0 | encode));</span>

5129 }
5130 
5131 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5132   assert(VM_Version::supports_avx(), &quot;&quot;);
5133   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5134   attributes.set_rex_vex_w_reverted();
5135   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="312" id="anc312"></a><span class="line-modified">5136   emit_int16(0x59, (0xC0 | encode));</span>

5137 }
5138 
5139 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5140   assert(VM_Version::supports_avx(), &quot;&quot;);
5141   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5142   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="313" id="anc313"></a><span class="line-modified">5143   emit_int16(0x59, (0xC0 | encode));</span>

5144 }
5145 
5146 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5147   assert(VM_Version::supports_avx(), &quot;&quot;);
5148   InstructionMark im(this);
5149   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5150   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5151   attributes.set_rex_vex_w_reverted();
5152   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5153   emit_int8(0x59);
5154   emit_operand(dst, src);
5155 }
5156 
5157 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5158   assert(VM_Version::supports_avx(), &quot;&quot;);
5159   InstructionMark im(this);
5160   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5161   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5162   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5163   emit_int8(0x59);
5164   emit_operand(dst, src);
5165 }
5166 
5167 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5168   assert(VM_Version::supports_fma(), &quot;&quot;);
5169   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5170   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="314" id="anc314"></a><span class="line-modified">5171   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>

5172 }
5173 
5174 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5175   assert(VM_Version::supports_fma(), &quot;&quot;);
5176   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5177   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="315" id="anc315"></a><span class="line-modified">5178   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>

5179 }
5180 
5181 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5182   assert(VM_Version::supports_fma(), &quot;&quot;);
5183   InstructionMark im(this);
5184   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5185   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5186   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5187   emit_int8((unsigned char)0xB8);
5188   emit_operand(dst, src2);
5189 }
5190 
5191 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5192   assert(VM_Version::supports_fma(), &quot;&quot;);
5193   InstructionMark im(this);
5194   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5195   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5196   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5197   emit_int8((unsigned char)0xB8);
5198   emit_operand(dst, src2);
5199 }
5200 
5201 void Assembler::divpd(XMMRegister dst, XMMRegister src) {
5202   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5203   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5204   attributes.set_rex_vex_w_reverted();
5205   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="316" id="anc316"></a><span class="line-modified">5206   emit_int16(0x5E, (0xC0 | encode));</span>

5207 }
5208 
5209 void Assembler::divps(XMMRegister dst, XMMRegister src) {
5210   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5211   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5212   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="317" id="anc317"></a><span class="line-modified">5213   emit_int16(0x5E, (0xC0 | encode));</span>

5214 }
5215 
5216 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5217   assert(VM_Version::supports_avx(), &quot;&quot;);
5218   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5219   attributes.set_rex_vex_w_reverted();
5220   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="318" id="anc318"></a><span class="line-modified">5221   emit_int16(0x5E, (0xC0 | encode));</span>

5222 }
5223 
5224 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5225   assert(VM_Version::supports_avx(), &quot;&quot;);
5226   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5227   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="319" id="anc319"></a><span class="line-modified">5228   emit_int16(0x5E, (0xC0 | encode));</span>

5229 }
5230 
5231 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5232   assert(VM_Version::supports_avx(), &quot;&quot;);
5233   InstructionMark im(this);
5234   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5235   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5236   attributes.set_rex_vex_w_reverted();
5237   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5238   emit_int8(0x5E);
5239   emit_operand(dst, src);
5240 }
5241 
5242 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5243   assert(VM_Version::supports_avx(), &quot;&quot;);
5244   InstructionMark im(this);
5245   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5246   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5247   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5248   emit_int8(0x5E);
5249   emit_operand(dst, src);
5250 }
5251 
5252 void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
5253   assert(VM_Version::supports_avx(), &quot;&quot;);
5254   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5255   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="320" id="anc320"></a><span class="line-modified">5256   emit_int24(0x09, (0xC0 | encode), (rmode));</span>


5257 }
5258 
5259 void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {
5260   assert(VM_Version::supports_avx(), &quot;&quot;);
5261   InstructionMark im(this);
5262   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5263   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
5264   emit_int8(0x09);
5265   emit_operand(dst, src);
<a name="321" id="anc321"></a><span class="line-modified">5266   emit_int8((rmode));</span>
5267 }
5268 
5269 void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {
5270   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5271   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5272   attributes.set_is_evex_instruction();
5273   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="322" id="anc322"></a><span class="line-modified">5274   emit_int24(0x09, (0xC0 | encode), (rmode));</span>


5275 }
5276 
5277 void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {
5278   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5279   assert(dst != xnoreg, &quot;sanity&quot;);
5280   InstructionMark im(this);
5281   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5282   attributes.set_is_evex_instruction();
5283   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5284   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="323" id="anc323"></a><span class="line-modified">5285   emit_int8(0x09);</span>
5286   emit_operand(dst, src);
<a name="324" id="anc324"></a><span class="line-modified">5287   emit_int8((rmode));</span>
5288 }
5289 
5290 
5291 void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
5292   assert(VM_Version::supports_avx(), &quot;&quot;);
5293   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5294   attributes.set_rex_vex_w_reverted();
5295   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="325" id="anc325"></a><span class="line-modified">5296   emit_int16(0x51, (0xC0 | encode));</span>

5297 }
5298 
5299 void Assembler::vsqrtpd(XMMRegister dst, Address src, int vector_len) {
5300   assert(VM_Version::supports_avx(), &quot;&quot;);
5301   InstructionMark im(this);
5302   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5303   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5304   attributes.set_rex_vex_w_reverted();
5305   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5306   emit_int8(0x51);
5307   emit_operand(dst, src);
5308 }
5309 
5310 void Assembler::vsqrtps(XMMRegister dst, XMMRegister src, int vector_len) {
5311   assert(VM_Version::supports_avx(), &quot;&quot;);
5312   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5313   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="326" id="anc326"></a><span class="line-modified">5314   emit_int16(0x51, (0xC0 | encode));</span>

5315 }
5316 
5317 void Assembler::vsqrtps(XMMRegister dst, Address src, int vector_len) {
5318   assert(VM_Version::supports_avx(), &quot;&quot;);
5319   InstructionMark im(this);
5320   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5321   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5322   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5323   emit_int8(0x51);
5324   emit_operand(dst, src);
5325 }
5326 
5327 void Assembler::andpd(XMMRegister dst, XMMRegister src) {
5328   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5329   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5330   attributes.set_rex_vex_w_reverted();
5331   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="327" id="anc327"></a><span class="line-modified">5332   emit_int16(0x54, (0xC0 | encode));</span>

5333 }
5334 
5335 void Assembler::andps(XMMRegister dst, XMMRegister src) {
5336   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5337   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5338   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="328" id="anc328"></a><span class="line-modified">5339   emit_int16(0x54, (0xC0 | encode));</span>

5340 }
5341 
5342 void Assembler::andps(XMMRegister dst, Address src) {
5343   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5344   InstructionMark im(this);
5345   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5346   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5347   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5348   emit_int8(0x54);
5349   emit_operand(dst, src);
5350 }
5351 
5352 void Assembler::andpd(XMMRegister dst, Address src) {
5353   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5354   InstructionMark im(this);
5355   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5356   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5357   attributes.set_rex_vex_w_reverted();
5358   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5359   emit_int8(0x54);
5360   emit_operand(dst, src);
5361 }
5362 
5363 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5364   assert(VM_Version::supports_avx(), &quot;&quot;);
5365   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5366   attributes.set_rex_vex_w_reverted();
5367   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="329" id="anc329"></a><span class="line-modified">5368   emit_int16(0x54, (0xC0 | encode));</span>

5369 }
5370 
5371 void Assembler::vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5372   assert(VM_Version::supports_avx(), &quot;&quot;);
5373   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5374   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="330" id="anc330"></a><span class="line-modified">5375   emit_int16(0x54, (0xC0 | encode));</span>

5376 }
5377 
5378 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5379   assert(VM_Version::supports_avx(), &quot;&quot;);
5380   InstructionMark im(this);
5381   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5382   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5383   attributes.set_rex_vex_w_reverted();
5384   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5385   emit_int8(0x54);
5386   emit_operand(dst, src);
5387 }
5388 
5389 void Assembler::vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5390   assert(VM_Version::supports_avx(), &quot;&quot;);
5391   InstructionMark im(this);
5392   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5393   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5394   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5395   emit_int8(0x54);
5396   emit_operand(dst, src);
5397 }
5398 
5399 void Assembler::unpckhpd(XMMRegister dst, XMMRegister src) {
5400   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5401   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5402   attributes.set_rex_vex_w_reverted();
5403   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5404   emit_int8(0x15);
<a name="331" id="anc331"></a><span class="line-modified">5405   emit_int8((0xC0 | encode));</span>
5406 }
5407 
5408 void Assembler::unpcklpd(XMMRegister dst, XMMRegister src) {
5409   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5410   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5411   attributes.set_rex_vex_w_reverted();
5412   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="332" id="anc332"></a><span class="line-modified">5413   emit_int16(0x14, (0xC0 | encode));</span>

5414 }
5415 
5416 void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
5417   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5418   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5419   attributes.set_rex_vex_w_reverted();
5420   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="333" id="anc333"></a><span class="line-modified">5421   emit_int16(0x57, (0xC0 | encode));</span>

5422 }
5423 
5424 void Assembler::xorps(XMMRegister dst, XMMRegister src) {
5425   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5426   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5427   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="334" id="anc334"></a><span class="line-modified">5428   emit_int16(0x57, (0xC0 | encode));</span>

5429 }
5430 
5431 void Assembler::xorpd(XMMRegister dst, Address src) {
5432   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5433   InstructionMark im(this);
5434   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5435   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5436   attributes.set_rex_vex_w_reverted();
5437   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5438   emit_int8(0x57);
5439   emit_operand(dst, src);
5440 }
5441 
5442 void Assembler::xorps(XMMRegister dst, Address src) {
5443   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5444   InstructionMark im(this);
5445   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5446   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5447   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5448   emit_int8(0x57);
5449   emit_operand(dst, src);
5450 }
5451 
5452 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5453   assert(VM_Version::supports_avx(), &quot;&quot;);
5454   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5455   attributes.set_rex_vex_w_reverted();
5456   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="335" id="anc335"></a><span class="line-modified">5457   emit_int16(0x57, (0xC0 | encode));</span>

5458 }
5459 
5460 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5461   assert(VM_Version::supports_avx(), &quot;&quot;);
5462   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5463   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="336" id="anc336"></a><span class="line-modified">5464   emit_int16(0x57, (0xC0 | encode));</span>

5465 }
5466 
5467 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5468   assert(VM_Version::supports_avx(), &quot;&quot;);
5469   InstructionMark im(this);
5470   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5471   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5472   attributes.set_rex_vex_w_reverted();
5473   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5474   emit_int8(0x57);
5475   emit_operand(dst, src);
5476 }
5477 
5478 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5479   assert(VM_Version::supports_avx(), &quot;&quot;);
5480   InstructionMark im(this);
5481   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5482   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5483   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5484   emit_int8(0x57);
5485   emit_operand(dst, src);
5486 }
5487 
5488 // Integer vector arithmetic
5489 void Assembler::vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5490   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5491          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5492   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5493   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="337" id="anc337"></a><span class="line-modified">5494   emit_int16(0x01, (0xC0 | encode));</span>

5495 }
5496 
5497 void Assembler::vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5498   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5499          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5500   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5501   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="338" id="anc338"></a><span class="line-modified">5502   emit_int16(0x02, (0xC0 | encode));</span>

5503 }
5504 
5505 void Assembler::paddb(XMMRegister dst, XMMRegister src) {
5506   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5507   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5508   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="339" id="anc339"></a><span class="line-modified">5509   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>

5510 }
5511 
5512 void Assembler::paddw(XMMRegister dst, XMMRegister src) {
5513   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5514   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5515   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="340" id="anc340"></a><span class="line-modified">5516   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>

5517 }
5518 
5519 void Assembler::paddd(XMMRegister dst, XMMRegister src) {
5520   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5521   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5522   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="341" id="anc341"></a><span class="line-modified">5523   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>

5524 }
5525 
5526 void Assembler::paddd(XMMRegister dst, Address src) {
5527   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5528   InstructionMark im(this);
5529   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5530   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5531   emit_int8((unsigned char)0xFE);
5532   emit_operand(dst, src);
5533 }
5534 
5535 void Assembler::paddq(XMMRegister dst, XMMRegister src) {
5536   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5537   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5538   attributes.set_rex_vex_w_reverted();
5539   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="342" id="anc342"></a><span class="line-modified">5540   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>

5541 }
5542 
5543 void Assembler::phaddw(XMMRegister dst, XMMRegister src) {
5544   assert(VM_Version::supports_sse3(), &quot;&quot;);
5545   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5546   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="343" id="anc343"></a><span class="line-modified">5547   emit_int16(0x01, (0xC0 | encode));</span>

5548 }
5549 
5550 void Assembler::phaddd(XMMRegister dst, XMMRegister src) {
5551   assert(VM_Version::supports_sse3(), &quot;&quot;);
5552   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5553   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="344" id="anc344"></a><span class="line-modified">5554   emit_int16(0x02, (0xC0 | encode));</span>

5555 }
5556 
5557 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5558   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5559   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5560   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="345" id="anc345"></a><span class="line-modified">5561   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>

5562 }
5563 
5564 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5565   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5566   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5567   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="346" id="anc346"></a><span class="line-modified">5568   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>

5569 }
5570 
5571 void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5572   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5573   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5574   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="347" id="anc347"></a><span class="line-modified">5575   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>

5576 }
5577 
5578 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5579   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5580   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5581   attributes.set_rex_vex_w_reverted();
5582   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="348" id="anc348"></a><span class="line-modified">5583   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>

5584 }
5585 
5586 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5587   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5588   InstructionMark im(this);
5589   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5590   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5591   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5592   emit_int8((unsigned char)0xFC);
5593   emit_operand(dst, src);
5594 }
5595 
5596 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5597   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5598   InstructionMark im(this);
5599   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5600   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5601   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5602   emit_int8((unsigned char)0xFD);
5603   emit_operand(dst, src);
5604 }
5605 
5606 void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5607   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5608   InstructionMark im(this);
5609   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5610   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5611   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5612   emit_int8((unsigned char)0xFE);
5613   emit_operand(dst, src);
5614 }
5615 
5616 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5617   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5618   InstructionMark im(this);
5619   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5620   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5621   attributes.set_rex_vex_w_reverted();
5622   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5623   emit_int8((unsigned char)0xD4);
5624   emit_operand(dst, src);
5625 }
5626 
5627 void Assembler::psubb(XMMRegister dst, XMMRegister src) {
5628   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5629   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5630   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="349" id="anc349"></a><span class="line-modified">5631   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>

5632 }
5633 
5634 void Assembler::psubw(XMMRegister dst, XMMRegister src) {
5635   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5636   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5637   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="350" id="anc350"></a><span class="line-modified">5638   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>

5639 }
5640 
5641 void Assembler::psubd(XMMRegister dst, XMMRegister src) {
5642   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5643   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="351" id="anc351"></a><span class="line-modified">5644   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>

5645 }
5646 
5647 void Assembler::psubq(XMMRegister dst, XMMRegister src) {
5648   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5649   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5650   attributes.set_rex_vex_w_reverted();
5651   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5652   emit_int8((unsigned char)0xFB);
<a name="352" id="anc352"></a><span class="line-modified">5653   emit_int8((0xC0 | encode));</span>
5654 }
5655 
5656 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5657   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5658   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5659   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="353" id="anc353"></a><span class="line-modified">5660   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>

5661 }
5662 
5663 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5664   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5665   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5666   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="354" id="anc354"></a><span class="line-modified">5667   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>

5668 }
5669 
5670 void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5671   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5672   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5673   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="355" id="anc355"></a><span class="line-modified">5674   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>

5675 }
5676 
5677 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5678   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5679   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5680   attributes.set_rex_vex_w_reverted();
5681   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="356" id="anc356"></a><span class="line-modified">5682   emit_int16((unsigned char)0xFB, (0xC0 | encode));</span>

5683 }
5684 
5685 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5686   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5687   InstructionMark im(this);
5688   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5689   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5690   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5691   emit_int8((unsigned char)0xF8);
5692   emit_operand(dst, src);
5693 }
5694 
5695 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5696   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5697   InstructionMark im(this);
5698   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5699   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5700   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5701   emit_int8((unsigned char)0xF9);
5702   emit_operand(dst, src);
5703 }
5704 
5705 void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5706   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5707   InstructionMark im(this);
5708   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5709   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5710   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5711   emit_int8((unsigned char)0xFA);
5712   emit_operand(dst, src);
5713 }
5714 
5715 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5716   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5717   InstructionMark im(this);
5718   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5719   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5720   attributes.set_rex_vex_w_reverted();
5721   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5722   emit_int8((unsigned char)0xFB);
5723   emit_operand(dst, src);
5724 }
5725 
5726 void Assembler::pmullw(XMMRegister dst, XMMRegister src) {
5727   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5728   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5729   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="357" id="anc357"></a><span class="line-modified">5730   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>

5731 }
5732 
5733 void Assembler::pmulld(XMMRegister dst, XMMRegister src) {
5734   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
5735   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5736   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="358" id="anc358"></a><span class="line-modified">5737   emit_int16(0x40, (0xC0 | encode));</span>

5738 }
5739 
5740 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5741   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5742   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5743   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="359" id="anc359"></a><span class="line-modified">5744   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>

5745 }
5746 
5747 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5748   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5749   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5750   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="360" id="anc360"></a><span class="line-modified">5751   emit_int16(0x40, (0xC0 | encode));</span>

5752 }
5753 
5754 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5755   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
5756   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5757   attributes.set_is_evex_instruction();
5758   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="361" id="anc361"></a><span class="line-modified">5759   emit_int16(0x40, (0xC0 | encode));</span>

5760 }
5761 
5762 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5763   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5764   InstructionMark im(this);
5765   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5766   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5767   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5768   emit_int8((unsigned char)0xD5);
5769   emit_operand(dst, src);
5770 }
5771 
5772 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5773   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5774   InstructionMark im(this);
5775   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5776   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5777   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5778   emit_int8(0x40);
5779   emit_operand(dst, src);
5780 }
5781 
5782 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5783   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
5784   InstructionMark im(this);
5785   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5786   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5787   attributes.set_is_evex_instruction();
5788   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5789   emit_int8(0x40);
5790   emit_operand(dst, src);
5791 }
5792 
5793 // Shift packed integers left by specified number of bits.
5794 void Assembler::psllw(XMMRegister dst, int shift) {
5795   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5796   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5797   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
5798   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="362" id="anc362"></a><span class="line-modified">5799   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5800 }
5801 
5802 void Assembler::pslld(XMMRegister dst, int shift) {
5803   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5804   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5805   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
5806   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="363" id="anc363"></a><span class="line-modified">5807   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5808 }
5809 
5810 void Assembler::psllq(XMMRegister dst, int shift) {
5811   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5812   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5813   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
5814   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="364" id="anc364"></a><span class="line-modified">5815   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5816 }
5817 
5818 void Assembler::psllw(XMMRegister dst, XMMRegister shift) {
5819   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5820   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5821   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="365" id="anc365"></a><span class="line-modified">5822   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>

5823 }
5824 
5825 void Assembler::pslld(XMMRegister dst, XMMRegister shift) {
5826   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5827   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5828   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="366" id="anc366"></a><span class="line-modified">5829   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

5830 }
5831 
5832 void Assembler::psllq(XMMRegister dst, XMMRegister shift) {
5833   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5834   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5835   attributes.set_rex_vex_w_reverted();
5836   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="367" id="anc367"></a><span class="line-modified">5837   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

5838 }
5839 
5840 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5841   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5842   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5843   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
5844   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="368" id="anc368"></a><span class="line-modified">5845   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5846 }
5847 
5848 void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5849   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5850   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5851   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5852   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
5853   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="369" id="anc369"></a><span class="line-modified">5854   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5855 }
5856 
5857 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5858   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5859   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5860   attributes.set_rex_vex_w_reverted();
5861   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
5862   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="370" id="anc370"></a><span class="line-modified">5863   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5864 }
5865 
5866 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5867   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5868   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5869   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="371" id="anc371"></a><span class="line-modified">5870   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>

5871 }
5872 
5873 void Assembler::vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5874   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5875   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5876   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="372" id="anc372"></a><span class="line-modified">5877   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

5878 }
5879 
5880 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5881   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5882   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5883   attributes.set_rex_vex_w_reverted();
5884   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="373" id="anc373"></a><span class="line-modified">5885   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

5886 }
5887 
5888 // Shift packed integers logically right by specified number of bits.
5889 void Assembler::psrlw(XMMRegister dst, int shift) {
5890   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5891   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5892   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
5893   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="374" id="anc374"></a><span class="line-modified">5894   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5895 }
5896 
5897 void Assembler::psrld(XMMRegister dst, int shift) {
5898   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5899   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5900   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
5901   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="375" id="anc375"></a><span class="line-modified">5902   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5903 }
5904 
5905 void Assembler::psrlq(XMMRegister dst, int shift) {
5906   // Do not confuse it with psrldq SSE2 instruction which
5907   // shifts 128 bit value in xmm register by number of bytes.
5908   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5909   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5910   attributes.set_rex_vex_w_reverted();
5911   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
5912   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="376" id="anc376"></a><span class="line-modified">5913   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5914 }
5915 
5916 void Assembler::psrlw(XMMRegister dst, XMMRegister shift) {
5917   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5918   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5919   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="377" id="anc377"></a><span class="line-modified">5920   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>

5921 }
5922 
5923 void Assembler::psrld(XMMRegister dst, XMMRegister shift) {
5924   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5925   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5926   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="378" id="anc378"></a><span class="line-modified">5927   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>

5928 }
5929 
5930 void Assembler::psrlq(XMMRegister dst, XMMRegister shift) {
5931   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5932   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5933   attributes.set_rex_vex_w_reverted();
5934   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="379" id="anc379"></a><span class="line-modified">5935   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>

5936 }
5937 
5938 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5939   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5940   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5941   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
5942   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="380" id="anc380"></a><span class="line-modified">5943   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5944 }
5945 
5946 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5947   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5948   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5949   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
5950   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="381" id="anc381"></a><span class="line-modified">5951   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5952 }
5953 
5954 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5955   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5956   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5957   attributes.set_rex_vex_w_reverted();
5958   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
5959   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="382" id="anc382"></a><span class="line-modified">5960   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5961 }
5962 
5963 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5964   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5965   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5966   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="383" id="anc383"></a><span class="line-modified">5967   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>

5968 }
5969 
5970 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5971   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5972   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5973   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="384" id="anc384"></a><span class="line-modified">5974   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>

5975 }
5976 
5977 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5978   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5979   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5980   attributes.set_rex_vex_w_reverted();
5981   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="385" id="anc385"></a><span class="line-modified">5982   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>

5983 }
5984 
5985 void Assembler::evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5986   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
5987   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5988   attributes.set_is_evex_instruction();
5989   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="386" id="anc386"></a><span class="line-modified">5990   emit_int16(0x10, (0xC0 | encode));</span>

5991 }
5992 
5993 void Assembler::evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5994   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
5995   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5996   attributes.set_is_evex_instruction();
5997   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="387" id="anc387"></a><span class="line-modified">5998   emit_int16(0x12, (0xC0 | encode));</span>

5999 }
6000 
6001 // Shift packed integers arithmetically right by specified number of bits.
6002 void Assembler::psraw(XMMRegister dst, int shift) {
6003   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6004   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6005   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6006   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="388" id="anc388"></a><span class="line-modified">6007   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


6008 }
6009 
6010 void Assembler::psrad(XMMRegister dst, int shift) {
6011   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6012   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6013   // XMM4 is for /4 encoding: 66 0F 72 /4 ib
6014   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6015   emit_int8(0x72);
<a name="389" id="anc389"></a><span class="line-modified">6016   emit_int8((0xC0 | encode));</span>
6017   emit_int8(shift &amp; 0xFF);
6018 }
6019 
6020 void Assembler::psraw(XMMRegister dst, XMMRegister shift) {
6021   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6022   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6023   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="390" id="anc390"></a><span class="line-modified">6024   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>

6025 }
6026 
6027 void Assembler::psrad(XMMRegister dst, XMMRegister shift) {
6028   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6029   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6030   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="391" id="anc391"></a><span class="line-modified">6031   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>

6032 }
6033 
6034 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6035   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6036   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6037   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6038   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="392" id="anc392"></a><span class="line-modified">6039   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


6040 }
6041 
6042 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6043   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6044   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6045   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6046   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="393" id="anc393"></a><span class="line-modified">6047   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


6048 }
6049 
6050 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6051   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6052   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6053   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="394" id="anc394"></a><span class="line-modified">6054   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>

6055 }
6056 
6057 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6058   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6059   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6060   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="395" id="anc395"></a><span class="line-modified">6061   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>

6062 }
6063 
6064 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6065   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6066   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6067   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6068   attributes.set_is_evex_instruction();
6069   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="396" id="anc396"></a><span class="line-modified">6070   emit_int24((unsigned char)0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


6071 }
6072 
6073 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6074   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6075   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6076   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6077   attributes.set_is_evex_instruction();
6078   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="397" id="anc397"></a><span class="line-modified">6079   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>

6080 }
6081 
6082 // logical operations packed integers
6083 void Assembler::pand(XMMRegister dst, XMMRegister src) {
6084   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6085   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6086   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="398" id="anc398"></a><span class="line-modified">6087   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>

6088 }
6089 
6090 void Assembler::vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6091   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6092   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6093   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="399" id="anc399"></a><span class="line-modified">6094   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>

6095 }
6096 
6097 void Assembler::vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6098   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6099   InstructionMark im(this);
6100   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6101   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6102   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6103   emit_int8((unsigned char)0xDB);
6104   emit_operand(dst, src);
6105 }
6106 
6107 void Assembler::vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6108   assert(VM_Version::supports_evex(), &quot;&quot;);
6109   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6110   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="400" id="anc400"></a><span class="line-modified">6111   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>

6112 }
6113 
6114 void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<a name="401" id="anc401"></a><span class="line-modified">6115   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
6116   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6117   attributes.set_is_evex_instruction();
6118   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6119   emit_int8(0x71);
<a name="402" id="anc402"></a><span class="line-modified">6120   emit_int8((0xC0 | encode));</span>
6121 }
6122 
6123 void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<a name="403" id="anc403"></a><span class="line-modified">6124   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
6125   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6126   attributes.set_is_evex_instruction();
6127   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="404" id="anc404"></a><span class="line-modified">6128   emit_int16(0x73, (0xC0 | encode));</span>

6129 }
6130 
6131 void Assembler::pandn(XMMRegister dst, XMMRegister src) {
6132   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6133   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6134   attributes.set_rex_vex_w_reverted();
6135   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="405" id="anc405"></a><span class="line-modified">6136   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

6137 }
6138 
6139 void Assembler::vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6140   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6141   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6142   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="406" id="anc406"></a><span class="line-modified">6143   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

6144 }
6145 
6146 
6147 void Assembler::por(XMMRegister dst, XMMRegister src) {
6148   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6149   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6150   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="407" id="anc407"></a><span class="line-modified">6151   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>

6152 }
6153 
6154 void Assembler::vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6155   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6156   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6157   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="408" id="anc408"></a><span class="line-modified">6158   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>

6159 }
6160 
6161 void Assembler::vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6162   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6163   InstructionMark im(this);
6164   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6165   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6166   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6167   emit_int8((unsigned char)0xEB);
6168   emit_operand(dst, src);
6169 }
6170 
6171 void Assembler::vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6172   assert(VM_Version::supports_evex(), &quot;&quot;);
6173   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6174   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="409" id="anc409"></a><span class="line-modified">6175   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>

6176 }
6177 
6178 
6179 void Assembler::pxor(XMMRegister dst, XMMRegister src) {
6180   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6181   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6182   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="410" id="anc410"></a><span class="line-modified">6183   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>

6184 }
6185 
6186 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6187   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6188   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6189   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="411" id="anc411"></a><span class="line-modified">6190   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>

6191 }
6192 
6193 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6194   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6195   InstructionMark im(this);
6196   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6197   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6198   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6199   emit_int8((unsigned char)0xEF);
6200   emit_operand(dst, src);
6201 }
6202 
6203 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6204   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6205   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6206   attributes.set_is_evex_instruction();
6207   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6208   emit_int8((unsigned char)0xEF);
<a name="412" id="anc412"></a><span class="line-modified">6209   emit_int8((0xC0 | encode));</span>
6210 }
6211 
6212 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6213   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6214   assert(dst != xnoreg, &quot;sanity&quot;);
6215   InstructionMark im(this);
6216   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6217   attributes.set_is_evex_instruction();
6218   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6219   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6220   emit_int8((unsigned char)0xEF);
6221   emit_operand(dst, src);
6222 }
6223 
6224 
6225 // vinserti forms
6226 
6227 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6228   assert(VM_Version::supports_avx2(), &quot;&quot;);
6229   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6230   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6231   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="413" id="anc413"></a><span class="line-modified">6232   // last byte:</span>

6233   // 0x00 - insert into lower 128 bits
6234   // 0x01 - insert into upper 128 bits
<a name="414" id="anc414"></a><span class="line-modified">6235   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x01);</span>
6236 }
6237 
6238 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6239   assert(VM_Version::supports_avx2(), &quot;&quot;);
6240   assert(dst != xnoreg, &quot;sanity&quot;);
6241   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6242   InstructionMark im(this);
6243   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6244   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6245   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6246   emit_int8(0x38);
6247   emit_operand(dst, src);
6248   // 0x00 - insert into lower 128 bits
6249   // 0x01 - insert into upper 128 bits
6250   emit_int8(imm8 &amp; 0x01);
6251 }
6252 
6253 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6254   assert(VM_Version::supports_evex(), &quot;&quot;);
6255   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6256   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6257   attributes.set_is_evex_instruction();
6258   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="415" id="anc415"></a><span class="line-modified">6259   // imm8:</span>

6260   // 0x00 - insert into q0 128 bits (0..127)
6261   // 0x01 - insert into q1 128 bits (128..255)
6262   // 0x02 - insert into q2 128 bits (256..383)
6263   // 0x03 - insert into q3 128 bits (384..511)
<a name="416" id="anc416"></a><span class="line-modified">6264   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x03);</span>
6265 }
6266 
6267 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6268   assert(VM_Version::supports_avx(), &quot;&quot;);
6269   assert(dst != xnoreg, &quot;sanity&quot;);
6270   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6271   InstructionMark im(this);
6272   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6273   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6274   attributes.set_is_evex_instruction();
6275   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6276   emit_int8(0x18);
6277   emit_operand(dst, src);
6278   // 0x00 - insert into q0 128 bits (0..127)
6279   // 0x01 - insert into q1 128 bits (128..255)
6280   // 0x02 - insert into q2 128 bits (256..383)
6281   // 0x03 - insert into q3 128 bits (384..511)
6282   emit_int8(imm8 &amp; 0x03);
6283 }
6284 
6285 void Assembler::vinserti64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6286   assert(VM_Version::supports_evex(), &quot;&quot;);
6287   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6288   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6289   attributes.set_is_evex_instruction();
6290   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="417" id="anc417"></a><span class="line-modified">6291   //imm8:</span>

6292   // 0x00 - insert into lower 256 bits
6293   // 0x01 - insert into upper 256 bits
<a name="418" id="anc418"></a><span class="line-modified">6294   emit_int24(0x3A, (0xC0 | encode), imm8 &amp; 0x01);</span>
6295 }
6296 
6297 
6298 // vinsertf forms
6299 
6300 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6301   assert(VM_Version::supports_avx(), &quot;&quot;);
6302   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6303   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6304   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="419" id="anc419"></a><span class="line-modified">6305   // imm8:</span>

6306   // 0x00 - insert into lower 128 bits
6307   // 0x01 - insert into upper 128 bits
<a name="420" id="anc420"></a><span class="line-modified">6308   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x01);</span>
6309 }
6310 
6311 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6312   assert(VM_Version::supports_avx(), &quot;&quot;);
6313   assert(dst != xnoreg, &quot;sanity&quot;);
6314   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6315   InstructionMark im(this);
6316   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6317   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6318   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6319   emit_int8(0x18);
6320   emit_operand(dst, src);
6321   // 0x00 - insert into lower 128 bits
6322   // 0x01 - insert into upper 128 bits
6323   emit_int8(imm8 &amp; 0x01);
6324 }
6325 
6326 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6327   assert(VM_Version::supports_avx2(), &quot;&quot;);
6328   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6329   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6330   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="421" id="anc421"></a><span class="line-modified">6331   // imm8:</span>

6332   // 0x00 - insert into q0 128 bits (0..127)
6333   // 0x01 - insert into q1 128 bits (128..255)
6334   // 0x02 - insert into q0 128 bits (256..383)
6335   // 0x03 - insert into q1 128 bits (384..512)
<a name="422" id="anc422"></a><span class="line-modified">6336   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x03);</span>
6337 }
6338 
6339 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6340   assert(VM_Version::supports_avx(), &quot;&quot;);
6341   assert(dst != xnoreg, &quot;sanity&quot;);
6342   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6343   InstructionMark im(this);
6344   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6345   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6346   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6347   emit_int8(0x18);
6348   emit_operand(dst, src);
6349   // 0x00 - insert into q0 128 bits (0..127)
6350   // 0x01 - insert into q1 128 bits (128..255)
6351   // 0x02 - insert into q0 128 bits (256..383)
6352   // 0x03 - insert into q1 128 bits (384..512)
6353   emit_int8(imm8 &amp; 0x03);
6354 }
6355 
6356 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6357   assert(VM_Version::supports_evex(), &quot;&quot;);
6358   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6359   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6360   attributes.set_is_evex_instruction();
6361   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="423" id="anc423"></a><span class="line-modified">6362   // imm8:</span>

6363   // 0x00 - insert into lower 256 bits
6364   // 0x01 - insert into upper 256 bits
<a name="424" id="anc424"></a><span class="line-modified">6365   emit_int24(0x1A, (0xC0 | encode), imm8 &amp; 0x01);</span>
6366 }
6367 
6368 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6369   assert(VM_Version::supports_evex(), &quot;&quot;);
6370   assert(dst != xnoreg, &quot;sanity&quot;);
6371   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6372   InstructionMark im(this);
6373   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6374   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6375   attributes.set_is_evex_instruction();
6376   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6377   emit_int8(0x1A);
6378   emit_operand(dst, src);
6379   // 0x00 - insert into lower 256 bits
6380   // 0x01 - insert into upper 256 bits
6381   emit_int8(imm8 &amp; 0x01);
6382 }
6383 
6384 
6385 // vextracti forms
6386 
6387 void Assembler::vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6388   assert(VM_Version::supports_avx2(), &quot;&quot;);
6389   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6390   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6391   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="425" id="anc425"></a><span class="line-modified">6392   // imm8:</span>

6393   // 0x00 - extract from lower 128 bits
6394   // 0x01 - extract from upper 128 bits
<a name="426" id="anc426"></a><span class="line-modified">6395   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x01);</span>
6396 }
6397 
6398 void Assembler::vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
6399   assert(VM_Version::supports_avx2(), &quot;&quot;);
6400   assert(src != xnoreg, &quot;sanity&quot;);
6401   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6402   InstructionMark im(this);
6403   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6404   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6405   attributes.reset_is_clear_context();
6406   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6407   emit_int8(0x39);
6408   emit_operand(src, dst);
6409   // 0x00 - extract from lower 128 bits
6410   // 0x01 - extract from upper 128 bits
6411   emit_int8(imm8 &amp; 0x01);
6412 }
6413 
6414 void Assembler::vextracti32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6415   assert(VM_Version::supports_evex(), &quot;&quot;);
6416   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6417   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6418   attributes.set_is_evex_instruction();
6419   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="427" id="anc427"></a><span class="line-modified">6420   // imm8:</span>

6421   // 0x00 - extract from bits 127:0
6422   // 0x01 - extract from bits 255:128
6423   // 0x02 - extract from bits 383:256
6424   // 0x03 - extract from bits 511:384
<a name="428" id="anc428"></a><span class="line-modified">6425   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
6426 }
6427 
6428 void Assembler::vextracti32x4(Address dst, XMMRegister src, uint8_t imm8) {
6429   assert(VM_Version::supports_evex(), &quot;&quot;);
6430   assert(src != xnoreg, &quot;sanity&quot;);
6431   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6432   InstructionMark im(this);
6433   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6434   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6435   attributes.reset_is_clear_context();
6436   attributes.set_is_evex_instruction();
6437   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6438   emit_int8(0x39);
6439   emit_operand(src, dst);
6440   // 0x00 - extract from bits 127:0
6441   // 0x01 - extract from bits 255:128
6442   // 0x02 - extract from bits 383:256
6443   // 0x03 - extract from bits 511:384
6444   emit_int8(imm8 &amp; 0x03);
6445 }
6446 
6447 void Assembler::vextracti64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6448   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6449   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6450   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6451   attributes.set_is_evex_instruction();
6452   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="429" id="anc429"></a><span class="line-modified">6453   // imm8:</span>

6454   // 0x00 - extract from bits 127:0
6455   // 0x01 - extract from bits 255:128
6456   // 0x02 - extract from bits 383:256
6457   // 0x03 - extract from bits 511:384
<a name="430" id="anc430"></a><span class="line-modified">6458   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
6459 }
6460 
6461 void Assembler::vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6462   assert(VM_Version::supports_evex(), &quot;&quot;);
6463   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6464   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6465   attributes.set_is_evex_instruction();
6466   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="431" id="anc431"></a><span class="line-modified">6467   // imm8:</span>

6468   // 0x00 - extract from lower 256 bits
6469   // 0x01 - extract from upper 256 bits
<a name="432" id="anc432"></a><span class="line-modified">6470   emit_int24(0x3B, (0xC0 | encode), imm8 &amp; 0x01);</span>
6471 }
6472 
6473 void Assembler::vextracti64x4(Address dst, XMMRegister src, uint8_t imm8) {
6474   assert(VM_Version::supports_evex(), &quot;&quot;);
6475   assert(src != xnoreg, &quot;sanity&quot;);
6476   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6477   InstructionMark im(this);
6478   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6479   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6480   attributes.reset_is_clear_context();
6481   attributes.set_is_evex_instruction();
6482   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6483   emit_int8(0x38);
6484   emit_operand(src, dst);
6485   // 0x00 - extract from lower 256 bits
6486   // 0x01 - extract from upper 256 bits
6487   emit_int8(imm8 &amp; 0x01);
6488 }
6489 // vextractf forms
6490 
6491 void Assembler::vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6492   assert(VM_Version::supports_avx(), &quot;&quot;);
6493   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6494   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6495   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="433" id="anc433"></a><span class="line-modified">6496   // imm8:</span>

6497   // 0x00 - extract from lower 128 bits
6498   // 0x01 - extract from upper 128 bits
<a name="434" id="anc434"></a><span class="line-modified">6499   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x01);</span>
6500 }
6501 
6502 void Assembler::vextractf128(Address dst, XMMRegister src, uint8_t imm8) {
6503   assert(VM_Version::supports_avx(), &quot;&quot;);
6504   assert(src != xnoreg, &quot;sanity&quot;);
6505   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6506   InstructionMark im(this);
6507   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6508   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6509   attributes.reset_is_clear_context();
6510   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6511   emit_int8(0x19);
6512   emit_operand(src, dst);
6513   // 0x00 - extract from lower 128 bits
6514   // 0x01 - extract from upper 128 bits
6515   emit_int8(imm8 &amp; 0x01);
6516 }
6517 
6518 void Assembler::vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6519   assert(VM_Version::supports_evex(), &quot;&quot;);
6520   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6521   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6522   attributes.set_is_evex_instruction();
6523   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="435" id="anc435"></a><span class="line-modified">6524   // imm8:</span>

6525   // 0x00 - extract from bits 127:0
6526   // 0x01 - extract from bits 255:128
6527   // 0x02 - extract from bits 383:256
6528   // 0x03 - extract from bits 511:384
<a name="436" id="anc436"></a><span class="line-modified">6529   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
6530 }
6531 
6532 void Assembler::vextractf32x4(Address dst, XMMRegister src, uint8_t imm8) {
6533   assert(VM_Version::supports_evex(), &quot;&quot;);
6534   assert(src != xnoreg, &quot;sanity&quot;);
6535   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6536   InstructionMark im(this);
6537   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6538   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6539   attributes.reset_is_clear_context();
6540   attributes.set_is_evex_instruction();
6541   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6542   emit_int8(0x19);
6543   emit_operand(src, dst);
6544   // 0x00 - extract from bits 127:0
6545   // 0x01 - extract from bits 255:128
6546   // 0x02 - extract from bits 383:256
6547   // 0x03 - extract from bits 511:384
6548   emit_int8(imm8 &amp; 0x03);
6549 }
6550 
6551 void Assembler::vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6552   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6553   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6554   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6555   attributes.set_is_evex_instruction();
6556   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="437" id="anc437"></a><span class="line-modified">6557   // imm8:</span>

6558   // 0x00 - extract from bits 127:0
6559   // 0x01 - extract from bits 255:128
6560   // 0x02 - extract from bits 383:256
6561   // 0x03 - extract from bits 511:384
<a name="438" id="anc438"></a><span class="line-modified">6562   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
6563 }
6564 
6565 void Assembler::vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6566   assert(VM_Version::supports_evex(), &quot;&quot;);
6567   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6568   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6569   attributes.set_is_evex_instruction();
6570   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="439" id="anc439"></a><span class="line-modified">6571   // imm8:</span>

6572   // 0x00 - extract from lower 256 bits
6573   // 0x01 - extract from upper 256 bits
<a name="440" id="anc440"></a><span class="line-modified">6574   emit_int24(0x1B, (0xC0 | encode), imm8 &amp; 0x01);</span>
6575 }
6576 
6577 void Assembler::vextractf64x4(Address dst, XMMRegister src, uint8_t imm8) {
6578   assert(VM_Version::supports_evex(), &quot;&quot;);
6579   assert(src != xnoreg, &quot;sanity&quot;);
6580   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6581   InstructionMark im(this);
6582   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6583   attributes.set_address_attributes(/* tuple_type */ EVEX_T4,/* input_size_in_bits */  EVEX_64bit);
6584   attributes.reset_is_clear_context();
6585   attributes.set_is_evex_instruction();
6586   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6587   emit_int8(0x1B);
6588   emit_operand(src, dst);
6589   // 0x00 - extract from lower 256 bits
6590   // 0x01 - extract from upper 256 bits
6591   emit_int8(imm8 &amp; 0x01);
6592 }
6593 
6594 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6595 void Assembler::vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len) {
6596   assert(VM_Version::supports_avx2(), &quot;&quot;);
6597   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6598   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="441" id="anc441"></a><span class="line-modified">6599   emit_int16(0x78, (0xC0 | encode));</span>

6600 }
6601 
6602 void Assembler::vpbroadcastb(XMMRegister dst, Address src, int vector_len) {
6603   assert(VM_Version::supports_avx2(), &quot;&quot;);
6604   assert(dst != xnoreg, &quot;sanity&quot;);
6605   InstructionMark im(this);
6606   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6607   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
6608   // swap src&lt;-&gt;dst for encoding
6609   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6610   emit_int8(0x78);
6611   emit_operand(dst, src);
6612 }
6613 
6614 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6615 void Assembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
6616   assert(VM_Version::supports_avx2(), &quot;&quot;);
6617   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6618   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="442" id="anc442"></a><span class="line-modified">6619   emit_int16(0x79, (0xC0 | encode));</span>

6620 }
6621 
6622 void Assembler::vpbroadcastw(XMMRegister dst, Address src, int vector_len) {
6623   assert(VM_Version::supports_avx2(), &quot;&quot;);
6624   assert(dst != xnoreg, &quot;sanity&quot;);
6625   InstructionMark im(this);
6626   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6627   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
6628   // swap src&lt;-&gt;dst for encoding
6629   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6630   emit_int8(0x79);
6631   emit_operand(dst, src);
6632 }
6633 
6634 // xmm/mem sourced byte/word/dword/qword replicate
6635 
6636 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
6637 void Assembler::vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len) {
6638   assert(UseAVX &gt;= 2, &quot;&quot;);
6639   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6640   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="443" id="anc443"></a><span class="line-modified">6641   emit_int16(0x58, (0xC0 | encode));</span>

6642 }
6643 
6644 void Assembler::vpbroadcastd(XMMRegister dst, Address src, int vector_len) {
6645   assert(VM_Version::supports_avx2(), &quot;&quot;);
6646   assert(dst != xnoreg, &quot;sanity&quot;);
6647   InstructionMark im(this);
6648   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6649   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
6650   // swap src&lt;-&gt;dst for encoding
6651   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6652   emit_int8(0x58);
6653   emit_operand(dst, src);
6654 }
6655 
6656 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
6657 void Assembler::vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) {
6658   assert(VM_Version::supports_avx2(), &quot;&quot;);
6659   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6660   attributes.set_rex_vex_w_reverted();
6661   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="444" id="anc444"></a><span class="line-modified">6662   emit_int16(0x59, (0xC0 | encode));</span>

6663 }
6664 
6665 void Assembler::vpbroadcastq(XMMRegister dst, Address src, int vector_len) {
6666   assert(VM_Version::supports_avx2(), &quot;&quot;);
6667   assert(dst != xnoreg, &quot;sanity&quot;);
6668   InstructionMark im(this);
6669   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6670   attributes.set_rex_vex_w_reverted();
6671   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
6672   // swap src&lt;-&gt;dst for encoding
6673   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6674   emit_int8(0x59);
6675   emit_operand(dst, src);
6676 }
6677 void Assembler::evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len) {
6678   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
6679   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6680   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6681   attributes.set_rex_vex_w_reverted();
6682   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="445" id="anc445"></a><span class="line-modified">6683   emit_int16(0x5A, (0xC0 | encode));</span>

6684 }
6685 
6686 void Assembler::evbroadcasti64x2(XMMRegister dst, Address src, int vector_len) {
6687   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
6688   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6689   assert(dst != xnoreg, &quot;sanity&quot;);
6690   InstructionMark im(this);
6691   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6692   attributes.set_rex_vex_w_reverted();
6693   attributes.set_address_attributes(/* tuple_type */ EVEX_T2, /* input_size_in_bits */ EVEX_64bit);
6694   // swap src&lt;-&gt;dst for encoding
6695   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6696   emit_int8(0x5A);
6697   emit_operand(dst, src);
6698 }
6699 
6700 // scalar single/double precision replicate
6701 
6702 // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
<a name="446" id="anc446"></a><span class="line-modified">6703 void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-modified">6704   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
6705   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6706   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="447" id="anc447"></a><span class="line-modified">6707   emit_int16(0x18, (0xC0 | encode));</span>

6708 }
6709 
<a name="448" id="anc448"></a><span class="line-modified">6710 void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {</span>
6711   assert(VM_Version::supports_avx(), &quot;&quot;);
6712   assert(dst != xnoreg, &quot;sanity&quot;);
6713   InstructionMark im(this);
6714   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6715   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
6716   // swap src&lt;-&gt;dst for encoding
6717   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6718   emit_int8(0x18);
6719   emit_operand(dst, src);
6720 }
6721 
6722 // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
<a name="449" id="anc449"></a><span class="line-modified">6723 void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-modified">6724   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
<span class="line-added">6725   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
6726   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6727   attributes.set_rex_vex_w_reverted();
6728   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="450" id="anc450"></a><span class="line-modified">6729   emit_int16(0x19, (0xC0 | encode));</span>

6730 }
6731 
<a name="451" id="anc451"></a><span class="line-modified">6732 void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {</span>
6733   assert(VM_Version::supports_avx(), &quot;&quot;);
<a name="452" id="anc452"></a><span class="line-added">6734   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
6735   assert(dst != xnoreg, &quot;sanity&quot;);
6736   InstructionMark im(this);
6737   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6738   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
6739   attributes.set_rex_vex_w_reverted();
6740   // swap src&lt;-&gt;dst for encoding
6741   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6742   emit_int8(0x19);
6743   emit_operand(dst, src);
6744 }
6745 
6746 
6747 // gpr source broadcast forms
6748 
6749 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6750 void Assembler::evpbroadcastb(XMMRegister dst, Register src, int vector_len) {
6751   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6752   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6753   attributes.set_is_evex_instruction();
6754   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="453" id="anc453"></a><span class="line-modified">6755   emit_int16(0x7A, (0xC0 | encode));</span>

6756 }
6757 
6758 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6759 void Assembler::evpbroadcastw(XMMRegister dst, Register src, int vector_len) {
6760   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6761   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6762   attributes.set_is_evex_instruction();
6763   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="454" id="anc454"></a><span class="line-modified">6764   emit_int16(0x7B, (0xC0 | encode));</span>

6765 }
6766 
6767 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
6768 void Assembler::evpbroadcastd(XMMRegister dst, Register src, int vector_len) {
6769   assert(VM_Version::supports_evex(), &quot;&quot;);
6770   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6771   attributes.set_is_evex_instruction();
6772   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="455" id="anc455"></a><span class="line-modified">6773   emit_int16(0x7C, (0xC0 | encode));</span>

6774 }
6775 
6776 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
6777 void Assembler::evpbroadcastq(XMMRegister dst, Register src, int vector_len) {
6778   assert(VM_Version::supports_evex(), &quot;&quot;);
6779   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6780   attributes.set_is_evex_instruction();
6781   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="456" id="anc456"></a><span class="line-modified">6782   emit_int16(0x7C, (0xC0 | encode));</span>

6783 }
6784 void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
6785   assert(VM_Version::supports_evex(), &quot;&quot;);
6786   assert(dst != xnoreg, &quot;sanity&quot;);
6787   InstructionMark im(this);
6788   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
6789   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
6790   attributes.reset_is_clear_context();
6791   attributes.set_embedded_opmask_register_specifier(mask);
6792   attributes.set_is_evex_instruction();
6793   // swap src&lt;-&gt;dst for encoding
6794   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6795   emit_int8((unsigned char)0x90);
6796   emit_operand(dst, src);
6797 }
6798 // Carry-Less Multiplication Quadword
6799 void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
6800   assert(VM_Version::supports_clmul(), &quot;&quot;);
6801   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
6802   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="457" id="anc457"></a><span class="line-modified">6803   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>


6804 }
6805 
6806 // Carry-Less Multiplication Quadword
6807 void Assembler::vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask) {
6808   assert(VM_Version::supports_avx() &amp;&amp; VM_Version::supports_clmul(), &quot;&quot;);
6809   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
6810   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="458" id="anc458"></a><span class="line-modified">6811   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>


6812 }
6813 
6814 void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
6815   assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);
6816   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6817   attributes.set_is_evex_instruction();
6818   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="459" id="anc459"></a><span class="line-modified">6819   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>


6820 }
6821 
<a name="460" id="anc460"></a><span class="line-modified">6822 void Assembler::vzeroupper_uncached() {</span>
6823   if (VM_Version::supports_vzeroupper()) {
6824     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
6825     (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
6826     emit_int8(0x77);
6827   }
6828 }
6829 
6830 #ifndef _LP64
6831 // 32bit only pieces of the assembler
6832 
<a name="461" id="anc461"></a><span class="line-added">6833 void Assembler::vzeroupper() {</span>
<span class="line-added">6834   vzeroupper_uncached();</span>
<span class="line-added">6835 }</span>
<span class="line-added">6836 </span>
6837 void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
6838   // NO PREFIX AS NEVER 64BIT
6839   InstructionMark im(this);
<a name="462" id="anc462"></a><span class="line-modified">6840   emit_int16((unsigned char)0x81, (0xF8 | src1-&gt;encoding()));</span>

6841   emit_data(imm32, rspec, 0);
6842 }
6843 
6844 void Assembler::cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
6845   // NO PREFIX AS NEVER 64BIT (not even 32bit versions of 64bit regs
6846   InstructionMark im(this);
6847   emit_int8((unsigned char)0x81);
6848   emit_operand(rdi, src1);
6849   emit_data(imm32, rspec, 0);
6850 }
6851 
6852 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
6853 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
6854 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
6855 void Assembler::cmpxchg8(Address adr) {
6856   InstructionMark im(this);
<a name="463" id="anc463"></a><span class="line-modified">6857   emit_int16(0x0F, (unsigned char)0xC7);</span>

6858   emit_operand(rcx, adr);
6859 }
6860 
6861 void Assembler::decl(Register dst) {
6862   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
6863  emit_int8(0x48 | dst-&gt;encoding());
6864 }
6865 
6866 // 64bit doesn&#39;t use the x87
6867 
6868 void Assembler::fabs() {
<a name="464" id="anc464"></a><span class="line-modified">6869   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);</span>

6870 }
6871 
6872 void Assembler::fadd(int i) {
6873   emit_farith(0xD8, 0xC0, i);
6874 }
6875 
6876 void Assembler::fadd_d(Address src) {
6877   InstructionMark im(this);
6878   emit_int8((unsigned char)0xDC);
6879   emit_operand32(rax, src);
6880 }
6881 
6882 void Assembler::fadd_s(Address src) {
6883   InstructionMark im(this);
6884   emit_int8((unsigned char)0xD8);
6885   emit_operand32(rax, src);
6886 }
6887 
6888 void Assembler::fadda(int i) {
6889   emit_farith(0xDC, 0xC0, i);
6890 }
6891 
6892 void Assembler::faddp(int i) {
6893   emit_farith(0xDE, 0xC0, i);
6894 }
6895 
6896 void Assembler::fchs() {
<a name="465" id="anc465"></a><span class="line-modified">6897   emit_int16((unsigned char)0xD9, (unsigned char)0xE0);</span>

6898 }
6899 
6900 void Assembler::fcom(int i) {
6901   emit_farith(0xD8, 0xD0, i);
6902 }
6903 
6904 void Assembler::fcomp(int i) {
6905   emit_farith(0xD8, 0xD8, i);
6906 }
6907 
6908 void Assembler::fcomp_d(Address src) {
6909   InstructionMark im(this);
6910   emit_int8((unsigned char)0xDC);
6911   emit_operand32(rbx, src);
6912 }
6913 
6914 void Assembler::fcomp_s(Address src) {
6915   InstructionMark im(this);
6916   emit_int8((unsigned char)0xD8);
6917   emit_operand32(rbx, src);
6918 }
6919 
6920 void Assembler::fcompp() {
<a name="466" id="anc466"></a><span class="line-modified">6921   emit_int16((unsigned char)0xDE, (unsigned char)0xD9);</span>

6922 }
6923 
6924 void Assembler::fcos() {
<a name="467" id="anc467"></a><span class="line-modified">6925   emit_int16((unsigned char)0xD9, (unsigned char)0xFF);</span>

6926 }
6927 
6928 void Assembler::fdecstp() {
<a name="468" id="anc468"></a><span class="line-modified">6929   emit_int16((unsigned char)0xD9, (unsigned char)0xF6);</span>

6930 }
6931 
6932 void Assembler::fdiv(int i) {
6933   emit_farith(0xD8, 0xF0, i);
6934 }
6935 
6936 void Assembler::fdiv_d(Address src) {
6937   InstructionMark im(this);
6938   emit_int8((unsigned char)0xDC);
6939   emit_operand32(rsi, src);
6940 }
6941 
6942 void Assembler::fdiv_s(Address src) {
6943   InstructionMark im(this);
6944   emit_int8((unsigned char)0xD8);
6945   emit_operand32(rsi, src);
6946 }
6947 
6948 void Assembler::fdiva(int i) {
6949   emit_farith(0xDC, 0xF8, i);
6950 }
6951 
6952 // Note: The Intel manual (Pentium Processor User&#39;s Manual, Vol.3, 1994)
6953 //       is erroneous for some of the floating-point instructions below.
6954 
6955 void Assembler::fdivp(int i) {
6956   emit_farith(0xDE, 0xF8, i);                    // ST(0) &lt;- ST(0) / ST(1) and pop (Intel manual wrong)
6957 }
6958 
6959 void Assembler::fdivr(int i) {
6960   emit_farith(0xD8, 0xF8, i);
6961 }
6962 
6963 void Assembler::fdivr_d(Address src) {
6964   InstructionMark im(this);
6965   emit_int8((unsigned char)0xDC);
6966   emit_operand32(rdi, src);
6967 }
6968 
6969 void Assembler::fdivr_s(Address src) {
6970   InstructionMark im(this);
6971   emit_int8((unsigned char)0xD8);
6972   emit_operand32(rdi, src);
6973 }
6974 
6975 void Assembler::fdivra(int i) {
6976   emit_farith(0xDC, 0xF0, i);
6977 }
6978 
6979 void Assembler::fdivrp(int i) {
6980   emit_farith(0xDE, 0xF0, i);                    // ST(0) &lt;- ST(1) / ST(0) and pop (Intel manual wrong)
6981 }
6982 
6983 void Assembler::ffree(int i) {
6984   emit_farith(0xDD, 0xC0, i);
6985 }
6986 
6987 void Assembler::fild_d(Address adr) {
6988   InstructionMark im(this);
6989   emit_int8((unsigned char)0xDF);
6990   emit_operand32(rbp, adr);
6991 }
6992 
6993 void Assembler::fild_s(Address adr) {
6994   InstructionMark im(this);
6995   emit_int8((unsigned char)0xDB);
6996   emit_operand32(rax, adr);
6997 }
6998 
6999 void Assembler::fincstp() {
<a name="469" id="anc469"></a><span class="line-modified">7000   emit_int16((unsigned char)0xD9, (unsigned char)0xF7);</span>

7001 }
7002 
7003 void Assembler::finit() {
<a name="470" id="anc470"></a><span class="line-modified">7004   emit_int24((unsigned char)0x9B, (unsigned char)0xDB, (unsigned char)0xE3);</span>


7005 }
7006 
7007 void Assembler::fist_s(Address adr) {
7008   InstructionMark im(this);
7009   emit_int8((unsigned char)0xDB);
7010   emit_operand32(rdx, adr);
7011 }
7012 
7013 void Assembler::fistp_d(Address adr) {
7014   InstructionMark im(this);
7015   emit_int8((unsigned char)0xDF);
7016   emit_operand32(rdi, adr);
7017 }
7018 
7019 void Assembler::fistp_s(Address adr) {
7020   InstructionMark im(this);
7021   emit_int8((unsigned char)0xDB);
7022   emit_operand32(rbx, adr);
7023 }
7024 
7025 void Assembler::fld1() {
<a name="471" id="anc471"></a><span class="line-modified">7026   emit_int16((unsigned char)0xD9, (unsigned char)0xE8);</span>

7027 }
7028 
7029 void Assembler::fld_d(Address adr) {
7030   InstructionMark im(this);
7031   emit_int8((unsigned char)0xDD);
7032   emit_operand32(rax, adr);
7033 }
7034 
7035 void Assembler::fld_s(Address adr) {
7036   InstructionMark im(this);
7037   emit_int8((unsigned char)0xD9);
7038   emit_operand32(rax, adr);
7039 }
7040 
7041 
7042 void Assembler::fld_s(int index) {
7043   emit_farith(0xD9, 0xC0, index);
7044 }
7045 
7046 void Assembler::fld_x(Address adr) {
7047   InstructionMark im(this);
7048   emit_int8((unsigned char)0xDB);
7049   emit_operand32(rbp, adr);
7050 }
7051 
7052 void Assembler::fldcw(Address src) {
7053   InstructionMark im(this);
7054   emit_int8((unsigned char)0xD9);
7055   emit_operand32(rbp, src);
7056 }
7057 
7058 void Assembler::fldenv(Address src) {
7059   InstructionMark im(this);
7060   emit_int8((unsigned char)0xD9);
7061   emit_operand32(rsp, src);
7062 }
7063 
7064 void Assembler::fldlg2() {
<a name="472" id="anc472"></a><span class="line-modified">7065   emit_int16((unsigned char)0xD9, (unsigned char)0xEC);</span>

7066 }
7067 
7068 void Assembler::fldln2() {
<a name="473" id="anc473"></a><span class="line-modified">7069   emit_int16((unsigned char)0xD9, (unsigned char)0xED);</span>

7070 }
7071 
7072 void Assembler::fldz() {
<a name="474" id="anc474"></a><span class="line-modified">7073   emit_int16((unsigned char)0xD9, (unsigned char)0xEE);</span>

7074 }
7075 
7076 void Assembler::flog() {
7077   fldln2();
7078   fxch();
7079   fyl2x();
7080 }
7081 
7082 void Assembler::flog10() {
7083   fldlg2();
7084   fxch();
7085   fyl2x();
7086 }
7087 
7088 void Assembler::fmul(int i) {
7089   emit_farith(0xD8, 0xC8, i);
7090 }
7091 
7092 void Assembler::fmul_d(Address src) {
7093   InstructionMark im(this);
7094   emit_int8((unsigned char)0xDC);
7095   emit_operand32(rcx, src);
7096 }
7097 
7098 void Assembler::fmul_s(Address src) {
7099   InstructionMark im(this);
7100   emit_int8((unsigned char)0xD8);
7101   emit_operand32(rcx, src);
7102 }
7103 
7104 void Assembler::fmula(int i) {
7105   emit_farith(0xDC, 0xC8, i);
7106 }
7107 
7108 void Assembler::fmulp(int i) {
7109   emit_farith(0xDE, 0xC8, i);
7110 }
7111 
7112 void Assembler::fnsave(Address dst) {
7113   InstructionMark im(this);
7114   emit_int8((unsigned char)0xDD);
7115   emit_operand32(rsi, dst);
7116 }
7117 
7118 void Assembler::fnstcw(Address src) {
7119   InstructionMark im(this);
<a name="475" id="anc475"></a><span class="line-modified">7120   emit_int16((unsigned char)0x9B, (unsigned char)0xD9);</span>

7121   emit_operand32(rdi, src);
7122 }
7123 
7124 void Assembler::fnstsw_ax() {
<a name="476" id="anc476"></a><span class="line-modified">7125   emit_int16((unsigned char)0xDF, (unsigned char)0xE0);</span>

7126 }
7127 
7128 void Assembler::fprem() {
<a name="477" id="anc477"></a><span class="line-modified">7129   emit_int16((unsigned char)0xD9, (unsigned char)0xF8);</span>

7130 }
7131 
7132 void Assembler::fprem1() {
<a name="478" id="anc478"></a><span class="line-modified">7133   emit_int16((unsigned char)0xD9, (unsigned char)0xF5);</span>

7134 }
7135 
7136 void Assembler::frstor(Address src) {
7137   InstructionMark im(this);
7138   emit_int8((unsigned char)0xDD);
7139   emit_operand32(rsp, src);
7140 }
7141 
7142 void Assembler::fsin() {
<a name="479" id="anc479"></a><span class="line-modified">7143   emit_int16((unsigned char)0xD9, (unsigned char)0xFE);</span>

7144 }
7145 
7146 void Assembler::fsqrt() {
<a name="480" id="anc480"></a><span class="line-modified">7147   emit_int16((unsigned char)0xD9, (unsigned char)0xFA);</span>

7148 }
7149 
7150 void Assembler::fst_d(Address adr) {
7151   InstructionMark im(this);
7152   emit_int8((unsigned char)0xDD);
7153   emit_operand32(rdx, adr);
7154 }
7155 
7156 void Assembler::fst_s(Address adr) {
7157   InstructionMark im(this);
7158   emit_int8((unsigned char)0xD9);
7159   emit_operand32(rdx, adr);
7160 }
7161 
7162 void Assembler::fstp_d(Address adr) {
7163   InstructionMark im(this);
7164   emit_int8((unsigned char)0xDD);
7165   emit_operand32(rbx, adr);
7166 }
7167 
7168 void Assembler::fstp_d(int index) {
7169   emit_farith(0xDD, 0xD8, index);
7170 }
7171 
7172 void Assembler::fstp_s(Address adr) {
7173   InstructionMark im(this);
7174   emit_int8((unsigned char)0xD9);
7175   emit_operand32(rbx, adr);
7176 }
7177 
7178 void Assembler::fstp_x(Address adr) {
7179   InstructionMark im(this);
7180   emit_int8((unsigned char)0xDB);
7181   emit_operand32(rdi, adr);
7182 }
7183 
7184 void Assembler::fsub(int i) {
7185   emit_farith(0xD8, 0xE0, i);
7186 }
7187 
7188 void Assembler::fsub_d(Address src) {
7189   InstructionMark im(this);
7190   emit_int8((unsigned char)0xDC);
7191   emit_operand32(rsp, src);
7192 }
7193 
7194 void Assembler::fsub_s(Address src) {
7195   InstructionMark im(this);
7196   emit_int8((unsigned char)0xD8);
7197   emit_operand32(rsp, src);
7198 }
7199 
7200 void Assembler::fsuba(int i) {
7201   emit_farith(0xDC, 0xE8, i);
7202 }
7203 
7204 void Assembler::fsubp(int i) {
7205   emit_farith(0xDE, 0xE8, i);                    // ST(0) &lt;- ST(0) - ST(1) and pop (Intel manual wrong)
7206 }
7207 
7208 void Assembler::fsubr(int i) {
7209   emit_farith(0xD8, 0xE8, i);
7210 }
7211 
7212 void Assembler::fsubr_d(Address src) {
7213   InstructionMark im(this);
7214   emit_int8((unsigned char)0xDC);
7215   emit_operand32(rbp, src);
7216 }
7217 
7218 void Assembler::fsubr_s(Address src) {
7219   InstructionMark im(this);
7220   emit_int8((unsigned char)0xD8);
7221   emit_operand32(rbp, src);
7222 }
7223 
7224 void Assembler::fsubra(int i) {
7225   emit_farith(0xDC, 0xE0, i);
7226 }
7227 
7228 void Assembler::fsubrp(int i) {
7229   emit_farith(0xDE, 0xE0, i);                    // ST(0) &lt;- ST(1) - ST(0) and pop (Intel manual wrong)
7230 }
7231 
7232 void Assembler::ftan() {
<a name="481" id="anc481"></a><span class="line-modified">7233   emit_int32((unsigned char)0xD9, (unsigned char)0xF2, (unsigned char)0xDD, (unsigned char)0xD8);</span>



7234 }
7235 
7236 void Assembler::ftst() {
<a name="482" id="anc482"></a><span class="line-modified">7237   emit_int16((unsigned char)0xD9, (unsigned char)0xE4);</span>

7238 }
7239 
7240 void Assembler::fucomi(int i) {
7241   // make sure the instruction is supported (introduced for P6, together with cmov)
7242   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7243   emit_farith(0xDB, 0xE8, i);
7244 }
7245 
7246 void Assembler::fucomip(int i) {
7247   // make sure the instruction is supported (introduced for P6, together with cmov)
7248   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7249   emit_farith(0xDF, 0xE8, i);
7250 }
7251 
7252 void Assembler::fwait() {
7253   emit_int8((unsigned char)0x9B);
7254 }
7255 
7256 void Assembler::fxch(int i) {
7257   emit_farith(0xD9, 0xC8, i);
7258 }
7259 
7260 void Assembler::fyl2x() {
<a name="483" id="anc483"></a><span class="line-modified">7261   emit_int16((unsigned char)0xD9, (unsigned char)0xF1);</span>

7262 }
7263 
7264 void Assembler::frndint() {
<a name="484" id="anc484"></a><span class="line-modified">7265   emit_int16((unsigned char)0xD9, (unsigned char)0xFC);</span>

7266 }
7267 
7268 void Assembler::f2xm1() {
<a name="485" id="anc485"></a><span class="line-modified">7269   emit_int16((unsigned char)0xD9, (unsigned char)0xF0);</span>

7270 }
7271 
7272 void Assembler::fldl2e() {
<a name="486" id="anc486"></a><span class="line-modified">7273   emit_int16((unsigned char)0xD9, (unsigned char)0xEA);</span>

7274 }
7275 #endif // !_LP64
7276 
7277 // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
7278 static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
7279 // SSE opcode second byte values (first is 0x0F) corresponding to VexOpcode encoding.
7280 static int simd_opc[4] = { 0,    0, 0x38, 0x3A };
7281 
7282 // Generate SSE legacy REX prefix and SIMD opcode based on VEX encoding.
7283 void Assembler::rex_prefix(Address adr, XMMRegister xreg, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7284   if (pre &gt; 0) {
7285     emit_int8(simd_pre[pre]);
7286   }
7287   if (rex_w) {
7288     prefixq(adr, xreg);
7289   } else {
7290     prefix(adr, xreg);
7291   }
7292   if (opc &gt; 0) {
7293     emit_int8(0x0F);
7294     int opc2 = simd_opc[opc];
7295     if (opc2 &gt; 0) {
7296       emit_int8(opc2);
7297     }
7298   }
7299 }
7300 
7301 int Assembler::rex_prefix_and_encode(int dst_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7302   if (pre &gt; 0) {
7303     emit_int8(simd_pre[pre]);
7304   }
7305   int encode = (rex_w) ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);
7306   if (opc &gt; 0) {
7307     emit_int8(0x0F);
7308     int opc2 = simd_opc[opc];
7309     if (opc2 &gt; 0) {
7310       emit_int8(opc2);
7311     }
7312   }
7313   return encode;
7314 }
7315 
7316 
7317 void Assembler::vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {
7318   int vector_len = _attributes-&gt;get_vector_len();
7319   bool vex_w = _attributes-&gt;is_rex_vex_w();
7320   if (vex_b || vex_x || vex_w || (opc == VEX_OPCODE_0F_38) || (opc == VEX_OPCODE_0F_3A)) {
<a name="487" id="anc487"></a>

7321     int byte1 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0);
7322     byte1 = (~byte1) &amp; 0xE0;
7323     byte1 |= opc;
<a name="488" id="anc488"></a>
7324 
7325     int byte2 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7326     byte2 |= (vex_w ? VEX_W : 0) | ((vector_len &gt; 0) ? 4 : 0) | pre;
<a name="489" id="anc489"></a>


7327 
<a name="490" id="anc490"></a><span class="line-added">7328     emit_int24((unsigned char)VEX_3bytes, byte1, byte2);</span>
<span class="line-added">7329   } else {</span>
7330     int byte1 = vex_r ? VEX_R : 0;
7331     byte1 = (~byte1) &amp; 0x80;
7332     byte1 |= ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7333     byte1 |= ((vector_len &gt; 0 ) ? 4 : 0) | pre;
<a name="491" id="anc491"></a><span class="line-modified">7334     emit_int16((unsigned char)VEX_2bytes, byte1);</span>
7335   }
7336 }
7337 
7338 // This is a 4 byte encoding
7339 void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){
7340   // EVEX 0x62 prefix
<a name="492" id="anc492"></a><span class="line-modified">7341   // byte1 = EVEX_4bytes;</span>
<span class="line-added">7342 </span>
7343   bool vex_w = _attributes-&gt;is_rex_vex_w();
7344   int evex_encoding = (vex_w ? VEX_W : 0);
7345   // EVEX.b is not currently used for broadcast of single element or data rounding modes
7346   _attributes-&gt;set_evex_encoding(evex_encoding);
7347 
7348   // P0: byte 2, initialized to RXBR`00mm
7349   // instead of not&#39;d
7350   int byte2 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0) | (evex_r ? EVEX_Rb : 0);
7351   byte2 = (~byte2) &amp; 0xF0;
7352   // confine opc opcode extensions in mm bits to lower two bits
7353   // of form {0F, 0F_38, 0F_3A}
7354   byte2 |= opc;
<a name="493" id="anc493"></a>
7355 
7356   // P1: byte 3 as Wvvvv1pp
7357   int byte3 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7358   // p[10] is always 1
7359   byte3 |= EVEX_F;
7360   byte3 |= (vex_w &amp; 1) &lt;&lt; 7;
7361   // confine pre opcode extensions in pp bits to lower two bits
7362   // of form {66, F3, F2}
7363   byte3 |= pre;
<a name="494" id="anc494"></a>
7364 
7365   // P2: byte 4 as zL&#39;Lbv&#39;aaa
7366   // kregs are implemented in the low 3 bits as aaa
7367   int byte4 = (_attributes-&gt;is_no_reg_mask()) ?
7368               0 :
7369               _attributes-&gt;get_embedded_opmask_register_specifier();
7370   // EVEX.v` for extending EVEX.vvvv or VIDX
7371   byte4 |= (evex_v ? 0: EVEX_V);
7372   // third EXEC.b for broadcast actions
7373   byte4 |= (_attributes-&gt;is_extended_context() ? EVEX_Rb : 0);
7374   // fourth EVEX.L&#39;L for vector length : 0 is 128, 1 is 256, 2 is 512, currently we do not support 1024
7375   byte4 |= ((_attributes-&gt;get_vector_len())&amp; 0x3) &lt;&lt; 5;
7376   // last is EVEX.z for zero/merge actions
7377   if (_attributes-&gt;is_no_reg_mask() == false) {
7378     byte4 |= (_attributes-&gt;is_clear_context() ? EVEX_Z : 0);
7379   }
<a name="495" id="anc495"></a><span class="line-modified">7380 </span>
<span class="line-added">7381   emit_int32(EVEX_4bytes, byte2, byte3, byte4);</span>
7382 }
7383 
7384 void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<a name="496" id="anc496"></a><span class="line-modified">7385   bool vex_r = (xreg_enc &amp; 8) == 8;</span>
7386   bool vex_b = adr.base_needs_rex();
7387   bool vex_x;
7388   if (adr.isxmmindex()) {
7389     vex_x = adr.xmmindex_needs_rex();
7390   } else {
7391     vex_x = adr.index_needs_rex();
7392   }
7393   set_attributes(attributes);
7394   attributes-&gt;set_current_assembler(this);
7395 
7396   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7397   // is allowed in legacy mode and has resources which will fit in it.
7398   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7399   if (!attributes-&gt;is_legacy_mode()) {
<a name="497" id="anc497"></a><span class="line-modified">7400     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
7401       if ((attributes-&gt;get_vector_len() != AVX_512bit) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (xreg_enc &lt; 16)) {
7402           attributes-&gt;set_is_legacy_mode();
7403       }
7404     }
7405   }
7406 
7407   if (UseAVX &gt; 2) {
7408     assert(((!attributes-&gt;uses_vl()) ||
7409             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7410             (!_legacy_mode_vl) ||
7411             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7412     assert(((nds_enc &lt; 16 &amp;&amp; xreg_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7413   }
7414 
<a name="498" id="anc498"></a><span class="line-modified">7415   clear_managed();</span>
7416   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7417   {
7418     bool evex_r = (xreg_enc &gt;= 16);
7419     bool evex_v;
7420     // EVEX.V&#39; is set to true when VSIB is used as we may need to use higher order XMM registers (16-31)
7421     if (adr.isxmmindex())  {
7422       evex_v = ((adr._xmmindex-&gt;encoding() &gt; 15) ? true : false);
7423     } else {
7424       evex_v = (nds_enc &gt;= 16);
7425     }
7426     attributes-&gt;set_is_evex_instruction();
7427     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7428   } else {
7429     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7430       attributes-&gt;set_rex_vex_w(false);
7431     }
7432     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7433   }
7434 }
7435 
7436 int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<a name="499" id="anc499"></a><span class="line-modified">7437   bool vex_r = (dst_enc &amp; 8) == 8;</span>
<span class="line-modified">7438   bool vex_b = (src_enc &amp; 8) == 8;</span>
7439   bool vex_x = false;
7440   set_attributes(attributes);
7441   attributes-&gt;set_current_assembler(this);
7442 
7443   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7444   // is allowed in legacy mode and has resources which will fit in it.
7445   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7446   if (!attributes-&gt;is_legacy_mode()) {
<a name="500" id="anc500"></a><span class="line-modified">7447     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
7448       if ((!attributes-&gt;uses_vl() || (attributes-&gt;get_vector_len() != AVX_512bit)) &amp;&amp;
7449           (dst_enc &lt; 16) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (src_enc &lt; 16)) {
7450           attributes-&gt;set_is_legacy_mode();
7451       }
7452     }
7453   }
7454 
7455   if (UseAVX &gt; 2) {
7456     // All the scalar fp instructions (with uses_vl as false) can have legacy_mode as false
7457     // Instruction with uses_vl true are vector instructions
7458     // All the vector instructions with AVX_512bit length can have legacy_mode as false
7459     // All the vector instructions with &lt; AVX_512bit length can have legacy_mode as false if AVX512vl() is supported
7460     // Rest all should have legacy_mode set as true
7461     assert(((!attributes-&gt;uses_vl()) ||
7462             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7463             (!_legacy_mode_vl) ||
7464             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7465     // Instruction with legacy_mode true should have dst, nds and src &lt; 15
7466     assert(((dst_enc &lt; 16 &amp;&amp; nds_enc &lt; 16 &amp;&amp; src_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7467   }
7468 
<a name="501" id="anc501"></a><span class="line-modified">7469   clear_managed();</span>
7470   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7471   {
7472     bool evex_r = (dst_enc &gt;= 16);
7473     bool evex_v = (nds_enc &gt;= 16);
7474     // can use vex_x as bank extender on rm encoding
7475     vex_x = (src_enc &gt;= 16);
7476     attributes-&gt;set_is_evex_instruction();
7477     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7478   } else {
7479     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7480       attributes-&gt;set_rex_vex_w(false);
7481     }
7482     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7483   }
7484 
7485   // return modrm byte components for operands
7486   return (((dst_enc &amp; 7) &lt;&lt; 3) | (src_enc &amp; 7));
7487 }
7488 
7489 
7490 void Assembler::simd_prefix(XMMRegister xreg, XMMRegister nds, Address adr, VexSimdPrefix pre,
7491                             VexOpcode opc, InstructionAttr *attributes) {
7492   if (UseAVX &gt; 0) {
7493     int xreg_enc = xreg-&gt;encoding();
7494     int nds_enc = nds-&gt;is_valid() ? nds-&gt;encoding() : 0;
7495     vex_prefix(adr, nds_enc, xreg_enc, pre, opc, attributes);
7496   } else {
7497     assert((nds == xreg) || (nds == xnoreg), &quot;wrong sse encoding&quot;);
7498     rex_prefix(adr, xreg, pre, opc, attributes-&gt;is_rex_vex_w());
7499   }
7500 }
7501 
7502 int Assembler::simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
7503                                       VexOpcode opc, InstructionAttr *attributes) {
7504   int dst_enc = dst-&gt;encoding();
7505   int src_enc = src-&gt;encoding();
7506   if (UseAVX &gt; 0) {
7507     int nds_enc = nds-&gt;is_valid() ? nds-&gt;encoding() : 0;
7508     return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes);
7509   } else {
7510     assert((nds == dst) || (nds == src) || (nds == xnoreg), &quot;wrong sse encoding&quot;);
7511     return rex_prefix_and_encode(dst_enc, src_enc, pre, opc, attributes-&gt;is_rex_vex_w());
7512   }
7513 }
7514 
7515 void Assembler::vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7516   assert(VM_Version::supports_avx(), &quot;&quot;);
7517   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7518   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="502" id="anc502"></a><span class="line-modified">7519   emit_int16(0x5F, (0xC0 | encode));</span>

7520 }
7521 
7522 void Assembler::vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7523   assert(VM_Version::supports_avx(), &quot;&quot;);
7524   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7525   attributes.set_rex_vex_w_reverted();
7526   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="503" id="anc503"></a><span class="line-modified">7527   emit_int16(0x5F, (0xC0 | encode));</span>

7528 }
7529 
7530 void Assembler::vminss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7531   assert(VM_Version::supports_avx(), &quot;&quot;);
7532   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7533   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="504" id="anc504"></a><span class="line-modified">7534   emit_int16(0x5D, (0xC0 | encode));</span>

7535 }
7536 
7537 void Assembler::vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7538   assert(VM_Version::supports_avx(), &quot;&quot;);
7539   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7540   attributes.set_rex_vex_w_reverted();
7541   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="505" id="anc505"></a><span class="line-modified">7542   emit_int16(0x5D, (0xC0 | encode));</span>

7543 }
7544 
7545 void Assembler::cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
7546   assert(VM_Version::supports_avx(), &quot;&quot;);
7547   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7548   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7549   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="506" id="anc506"></a><span class="line-modified">7550   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>


7551 }
7552 
7553 void Assembler::blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
7554   assert(VM_Version::supports_avx(), &quot;&quot;);
7555   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7556   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7557   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="507" id="anc507"></a>

7558   int src2_enc = src2-&gt;encoding();
<a name="508" id="anc508"></a><span class="line-modified">7559   emit_int24(0x4B, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
7560 }
7561 
7562 void Assembler::cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
7563   assert(VM_Version::supports_avx(), &quot;&quot;);
7564   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7565   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7566   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<a name="509" id="anc509"></a><span class="line-modified">7567   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>


7568 }
7569 
7570 void Assembler::blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
7571   assert(VM_Version::supports_avx(), &quot;&quot;);
7572   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7573   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7574   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="510" id="anc510"></a>

7575   int src2_enc = src2-&gt;encoding();
<a name="511" id="anc511"></a><span class="line-modified">7576   emit_int24(0x4A, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
7577 }
7578 
7579 void Assembler::vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
7580   assert(VM_Version::supports_avx2(), &quot;&quot;);
7581   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7582   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="512" id="anc512"></a><span class="line-modified">7583   emit_int24(0x02, (0xC0 | encode), (unsigned char)imm8);</span>


7584 }
7585 
7586 void Assembler::shlxl(Register dst, Register src1, Register src2) {
7587   assert(VM_Version::supports_bmi2(), &quot;&quot;);
7588   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7589   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="513" id="anc513"></a><span class="line-modified">7590   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

7591 }
7592 
7593 void Assembler::shlxq(Register dst, Register src1, Register src2) {
7594   assert(VM_Version::supports_bmi2(), &quot;&quot;);
7595   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7596   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<a name="514" id="anc514"></a><span class="line-modified">7597   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

7598 }
7599 
7600 #ifndef _LP64
7601 
7602 void Assembler::incl(Register dst) {
7603   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
7604   emit_int8(0x40 | dst-&gt;encoding());
7605 }
7606 
7607 void Assembler::lea(Register dst, Address src) {
7608   leal(dst, src);
7609 }
7610 
7611 void Assembler::mov_literal32(Address dst, int32_t imm32, RelocationHolder const&amp; rspec) {
7612   InstructionMark im(this);
7613   emit_int8((unsigned char)0xC7);
7614   emit_operand(rax, dst);
7615   emit_data((int)imm32, rspec, 0);
7616 }
7617 
7618 void Assembler::mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
7619   InstructionMark im(this);
7620   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="515" id="anc515"></a><span class="line-modified">7621   emit_int8((0xB8 | encode));</span>
7622   emit_data((int)imm32, rspec, 0);
7623 }
7624 
7625 void Assembler::popa() { // 32bit
7626   emit_int8(0x61);
7627 }
7628 
7629 void Assembler::push_literal32(int32_t imm32, RelocationHolder const&amp; rspec) {
7630   InstructionMark im(this);
7631   emit_int8(0x68);
7632   emit_data(imm32, rspec, 0);
7633 }
7634 
7635 void Assembler::pusha() { // 32bit
7636   emit_int8(0x60);
7637 }
7638 
7639 void Assembler::set_byte_if_not_zero(Register dst) {
<a name="516" id="anc516"></a><span class="line-modified">7640   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | dst-&gt;encoding()));</span>


7641 }
7642 
7643 #else // LP64
7644 
7645 void Assembler::set_byte_if_not_zero(Register dst) {
7646   int enc = prefix_and_encode(dst-&gt;encoding(), true);
<a name="517" id="anc517"></a><span class="line-modified">7647   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | enc));</span>


7648 }
7649 
7650 // 64bit only pieces of the assembler
7651 // This should only be used by 64bit instructions that can use rip-relative
7652 // it cannot be used by instructions that want an immediate value.
7653 
7654 bool Assembler::reachable(AddressLiteral adr) {
7655   int64_t disp;
<a name="518" id="anc518"></a><span class="line-added">7656   relocInfo::relocType relocType = adr.reloc();</span>
<span class="line-added">7657 </span>
7658   // None will force a 64bit literal to the code stream. Likely a placeholder
7659   // for something that will be patched later and we need to certain it will
7660   // always be reachable.
<a name="519" id="anc519"></a><span class="line-modified">7661   if (relocType == relocInfo::none) {</span>
7662     return false;
7663   }
<a name="520" id="anc520"></a><span class="line-modified">7664   if (relocType == relocInfo::internal_word_type) {</span>
7665     // This should be rip relative and easily reachable.
7666     return true;
7667   }
<a name="521" id="anc521"></a><span class="line-modified">7668   if (relocType == relocInfo::virtual_call_type ||</span>
<span class="line-modified">7669       relocType == relocInfo::opt_virtual_call_type ||</span>
<span class="line-modified">7670       relocType == relocInfo::static_call_type ||</span>
<span class="line-modified">7671       relocType == relocInfo::static_stub_type ) {</span>
7672     // This should be rip relative within the code cache and easily
7673     // reachable until we get huge code caches. (At which point
7674     // ic code is going to have issues).
7675     return true;
7676   }
<a name="522" id="anc522"></a><span class="line-modified">7677   if (relocType != relocInfo::external_word_type &amp;&amp;</span>
<span class="line-modified">7678       relocType != relocInfo::poll_return_type &amp;&amp;  // these are really external_word but need special</span>
<span class="line-modified">7679       relocType != relocInfo::poll_type &amp;&amp;         // relocs to identify them</span>
<span class="line-modified">7680       relocType != relocInfo::runtime_call_type ) {</span>
7681     return false;
7682   }
7683 
7684   // Stress the correction code
7685   if (ForceUnreachable) {
7686     // Must be runtimecall reloc, see if it is in the codecache
7687     // Flipping stuff in the codecache to be unreachable causes issues
7688     // with things like inline caches where the additional instructions
7689     // are not handled.
7690     if (CodeCache::find_blob(adr._target) == NULL) {
7691       return false;
7692     }
7693   }
7694   // For external_word_type/runtime_call_type if it is reachable from where we
7695   // are now (possibly a temp buffer) and where we might end up
7696   // anywhere in the codeCache then we are always reachable.
7697   // This would have to change if we ever save/restore shared code
7698   // to be more pessimistic.
7699   disp = (int64_t)adr._target - ((int64_t)CodeCache::low_bound() + sizeof(int));
7700   if (!is_simm32(disp)) return false;
7701   disp = (int64_t)adr._target - ((int64_t)CodeCache::high_bound() + sizeof(int));
7702   if (!is_simm32(disp)) return false;
7703 
7704   disp = (int64_t)adr._target - ((int64_t)pc() + sizeof(int));
7705 
7706   // Because rip relative is a disp + address_of_next_instruction and we
7707   // don&#39;t know the value of address_of_next_instruction we apply a fudge factor
7708   // to make sure we will be ok no matter the size of the instruction we get placed into.
7709   // We don&#39;t have to fudge the checks above here because they are already worst case.
7710 
7711   // 12 == override/rex byte, opcode byte, rm byte, sib byte, a 4-byte disp , 4-byte literal
7712   // + 4 because better safe than sorry.
7713   const int fudge = 12 + 4;
7714   if (disp &lt; 0) {
7715     disp -= fudge;
7716   } else {
7717     disp += fudge;
7718   }
7719   return is_simm32(disp);
7720 }
7721 
7722 // Check if the polling page is not reachable from the code cache using rip-relative
7723 // addressing.
7724 bool Assembler::is_polling_page_far() {
7725   intptr_t addr = (intptr_t)os::get_polling_page();
7726   return ForceUnreachable ||
7727          !is_simm32(addr - (intptr_t)CodeCache::low_bound()) ||
7728          !is_simm32(addr - (intptr_t)CodeCache::high_bound());
7729 }
7730 
7731 void Assembler::emit_data64(jlong data,
7732                             relocInfo::relocType rtype,
7733                             int format) {
7734   if (rtype == relocInfo::none) {
7735     emit_int64(data);
7736   } else {
7737     emit_data64(data, Relocation::spec_simple(rtype), format);
7738   }
7739 }
7740 
7741 void Assembler::emit_data64(jlong data,
7742                             RelocationHolder const&amp; rspec,
7743                             int format) {
7744   assert(imm_operand == 0, &quot;default format must be immediate in this file&quot;);
7745   assert(imm_operand == format, &quot;must be immediate&quot;);
7746   assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
7747   // Do not use AbstractAssembler::relocate, which is not intended for
7748   // embedded words.  Instead, relocate to the enclosing instruction.
7749   code_section()-&gt;relocate(inst_mark(), rspec, format);
7750 #ifdef ASSERT
7751   check_relocation(rspec, format);
7752 #endif
7753   emit_int64(data);
7754 }
7755 
<a name="523" id="anc523"></a>



























































7756 void Assembler::prefix(Register reg) {
7757   if (reg-&gt;encoding() &gt;= 8) {
7758     prefix(REX_B);
7759   }
7760 }
7761 
7762 void Assembler::prefix(Register dst, Register src, Prefix p) {
7763   if (src-&gt;encoding() &gt;= 8) {
7764     p = (Prefix)(p | REX_B);
7765   }
7766   if (dst-&gt;encoding() &gt;= 8) {
<a name="524" id="anc524"></a><span class="line-modified">7767     p = (Prefix)(p | REX_R);</span>
7768   }
7769   if (p != Prefix_EMPTY) {
7770     // do not generate an empty prefix
7771     prefix(p);
7772   }
7773 }
7774 
7775 void Assembler::prefix(Register dst, Address adr, Prefix p) {
7776   if (adr.base_needs_rex()) {
7777     if (adr.index_needs_rex()) {
7778       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);
7779     } else {
7780       prefix(REX_B);
7781     }
7782   } else {
7783     if (adr.index_needs_rex()) {
7784       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);
7785     }
7786   }
7787   if (dst-&gt;encoding() &gt;= 8) {
7788     p = (Prefix)(p | REX_R);
7789   }
7790   if (p != Prefix_EMPTY) {
7791     // do not generate an empty prefix
7792     prefix(p);
7793   }
7794 }
7795 
7796 void Assembler::prefix(Address adr) {
7797   if (adr.base_needs_rex()) {
7798     if (adr.index_needs_rex()) {
7799       prefix(REX_XB);
7800     } else {
7801       prefix(REX_B);
7802     }
7803   } else {
7804     if (adr.index_needs_rex()) {
7805       prefix(REX_X);
7806     }
7807   }
7808 }
7809 
<a name="525" id="anc525"></a>
















7810 void Assembler::prefix(Address adr, Register reg, bool byteinst) {
7811   if (reg-&gt;encoding() &lt; 8) {
7812     if (adr.base_needs_rex()) {
7813       if (adr.index_needs_rex()) {
7814         prefix(REX_XB);
7815       } else {
7816         prefix(REX_B);
7817       }
7818     } else {
7819       if (adr.index_needs_rex()) {
7820         prefix(REX_X);
<a name="526" id="anc526"></a><span class="line-modified">7821       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4) {</span>
7822         prefix(REX);
7823       }
7824     }
7825   } else {
7826     if (adr.base_needs_rex()) {
7827       if (adr.index_needs_rex()) {
7828         prefix(REX_RXB);
7829       } else {
7830         prefix(REX_RB);
7831       }
7832     } else {
7833       if (adr.index_needs_rex()) {
7834         prefix(REX_RX);
7835       } else {
7836         prefix(REX_R);
7837       }
7838     }
7839   }
7840 }
7841 
<a name="527" id="anc527"></a><span class="line-modified">7842 void Assembler::prefix(Address adr, XMMRegister reg) {</span>
<span class="line-modified">7843   if (reg-&gt;encoding() &lt; 8) {</span>
7844     if (adr.base_needs_rex()) {
7845       if (adr.index_needs_rex()) {
<a name="528" id="anc528"></a><span class="line-modified">7846         prefix(REX_XB);</span>
7847       } else {
<a name="529" id="anc529"></a><span class="line-modified">7848         prefix(REX_B);</span>
7849       }
7850     } else {
7851       if (adr.index_needs_rex()) {
<a name="530" id="anc530"></a><span class="line-modified">7852         prefix(REX_X);</span>


7853       }
7854     }
7855   } else {
7856     if (adr.base_needs_rex()) {
7857       if (adr.index_needs_rex()) {
<a name="531" id="anc531"></a><span class="line-modified">7858         prefix(REX_RXB);</span>
7859       } else {
<a name="532" id="anc532"></a><span class="line-modified">7860         prefix(REX_RB);</span>
7861       }
7862     } else {
7863       if (adr.index_needs_rex()) {
<a name="533" id="anc533"></a><span class="line-modified">7864         prefix(REX_RX);</span>
7865       } else {
<a name="534" id="anc534"></a><span class="line-modified">7866         prefix(REX_R);</span>
7867       }
7868     }
7869   }
7870 }
7871 
<a name="535" id="anc535"></a><span class="line-modified">7872 int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {</span>
<span class="line-modified">7873   if (reg_enc &gt;= 8) {</span>
<span class="line-added">7874     prefix(REX_B);</span>
<span class="line-added">7875     reg_enc -= 8;</span>
<span class="line-added">7876   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {</span>
<span class="line-added">7877     prefix(REX);</span>
<span class="line-added">7878   }</span>
<span class="line-added">7879   return reg_enc;</span>
<span class="line-added">7880 }</span>
<span class="line-added">7881 </span>
<span class="line-added">7882 int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {</span>
<span class="line-added">7883   if (dst_enc &lt; 8) {</span>
<span class="line-added">7884     if (src_enc &gt;= 8) {</span>
<span class="line-added">7885       prefix(REX_B);</span>
<span class="line-added">7886       src_enc -= 8;</span>
<span class="line-added">7887     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {</span>
<span class="line-added">7888       prefix(REX);</span>
<span class="line-added">7889     }</span>
<span class="line-added">7890   } else {</span>
<span class="line-added">7891     if (src_enc &lt; 8) {</span>
<span class="line-added">7892       prefix(REX_R);</span>
<span class="line-added">7893     } else {</span>
<span class="line-added">7894       prefix(REX_RB);</span>
<span class="line-added">7895       src_enc -= 8;</span>
<span class="line-added">7896     }</span>
<span class="line-added">7897     dst_enc -= 8;</span>
<span class="line-added">7898   }</span>
<span class="line-added">7899   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-added">7900 }</span>
<span class="line-added">7901 </span>
<span class="line-added">7902 int8_t Assembler::get_prefixq(Address adr) {</span>
<span class="line-added">7903   int8_t prfx = get_prefixq(adr, rax);</span>
<span class="line-added">7904   assert(REX_W &lt;= prfx &amp;&amp; prfx &lt;= REX_WXB, &quot;must be&quot;);</span>
<span class="line-added">7905   return prfx;</span>
<span class="line-added">7906 }</span>
<span class="line-added">7907 </span>
<span class="line-added">7908 int8_t Assembler::get_prefixq(Address adr, Register src) {</span>
<span class="line-added">7909   int8_t prfx = (int8_t)(REX_W +</span>
<span class="line-added">7910                          ((int)adr.base_needs_rex()) +</span>
<span class="line-added">7911                          ((int)adr.index_needs_rex() &lt;&lt; 1) +</span>
<span class="line-added">7912                          ((int)(src-&gt;encoding() &gt;= 8) &lt;&lt; 2));</span>
<span class="line-added">7913 #ifdef ASSERT</span>
<span class="line-added">7914   if (src-&gt;encoding() &lt; 8) {</span>
7915     if (adr.base_needs_rex()) {
7916       if (adr.index_needs_rex()) {
<a name="536" id="anc536"></a><span class="line-modified">7917         assert(prfx == REX_WXB, &quot;must be&quot;);</span>
7918       } else {
<a name="537" id="anc537"></a><span class="line-modified">7919         assert(prfx == REX_WB, &quot;must be&quot;);</span>
7920       }
7921     } else {
7922       if (adr.index_needs_rex()) {
<a name="538" id="anc538"></a><span class="line-modified">7923         assert(prfx == REX_WX, &quot;must be&quot;);</span>
<span class="line-added">7924       } else {</span>
<span class="line-added">7925         assert(prfx == REX_W, &quot;must be&quot;);</span>
7926       }
7927     }
7928   } else {
7929     if (adr.base_needs_rex()) {
7930       if (adr.index_needs_rex()) {
<a name="539" id="anc539"></a><span class="line-modified">7931         assert(prfx == REX_WRXB, &quot;must be&quot;);</span>
7932       } else {
<a name="540" id="anc540"></a><span class="line-modified">7933         assert(prfx == REX_WRB, &quot;must be&quot;);</span>
7934       }
7935     } else {
7936       if (adr.index_needs_rex()) {
<a name="541" id="anc541"></a><span class="line-modified">7937         assert(prfx == REX_WRX, &quot;must be&quot;);</span>
7938       } else {
<a name="542" id="anc542"></a><span class="line-modified">7939         assert(prfx == REX_WR, &quot;must be&quot;);</span>
7940       }
7941     }
7942   }
<a name="543" id="anc543"></a><span class="line-added">7943 #endif</span>
<span class="line-added">7944   return prfx;</span>
<span class="line-added">7945 }</span>
<span class="line-added">7946 </span>
<span class="line-added">7947 void Assembler::prefixq(Address adr) {</span>
<span class="line-added">7948   emit_int8(get_prefixq(adr));</span>
<span class="line-added">7949 }</span>
<span class="line-added">7950 </span>
<span class="line-added">7951 void Assembler::prefixq(Address adr, Register src) {</span>
<span class="line-added">7952   emit_int8(get_prefixq(adr, src));</span>
7953 }
7954 
7955 void Assembler::prefixq(Address adr, XMMRegister src) {
7956   if (src-&gt;encoding() &lt; 8) {
7957     if (adr.base_needs_rex()) {
7958       if (adr.index_needs_rex()) {
7959         prefix(REX_WXB);
7960       } else {
7961         prefix(REX_WB);
7962       }
7963     } else {
7964       if (adr.index_needs_rex()) {
7965         prefix(REX_WX);
7966       } else {
7967         prefix(REX_W);
7968       }
7969     }
7970   } else {
7971     if (adr.base_needs_rex()) {
7972       if (adr.index_needs_rex()) {
7973         prefix(REX_WRXB);
7974       } else {
7975         prefix(REX_WRB);
7976       }
7977     } else {
7978       if (adr.index_needs_rex()) {
7979         prefix(REX_WRX);
7980       } else {
7981         prefix(REX_WR);
7982       }
7983     }
7984   }
7985 }
7986 
<a name="544" id="anc544"></a><span class="line-added">7987 int Assembler::prefixq_and_encode(int reg_enc) {</span>
<span class="line-added">7988   if (reg_enc &lt; 8) {</span>
<span class="line-added">7989     prefix(REX_W);</span>
<span class="line-added">7990   } else {</span>
<span class="line-added">7991     prefix(REX_WB);</span>
<span class="line-added">7992     reg_enc -= 8;</span>
<span class="line-added">7993   }</span>
<span class="line-added">7994   return reg_enc;</span>
<span class="line-added">7995 }</span>
<span class="line-added">7996 </span>
<span class="line-added">7997 int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {</span>
<span class="line-added">7998   if (dst_enc &lt; 8) {</span>
<span class="line-added">7999     if (src_enc &lt; 8) {</span>
<span class="line-added">8000       prefix(REX_W);</span>
<span class="line-added">8001     } else {</span>
<span class="line-added">8002       prefix(REX_WB);</span>
<span class="line-added">8003       src_enc -= 8;</span>
<span class="line-added">8004     }</span>
<span class="line-added">8005   } else {</span>
<span class="line-added">8006     if (src_enc &lt; 8) {</span>
<span class="line-added">8007       prefix(REX_WR);</span>
<span class="line-added">8008     } else {</span>
<span class="line-added">8009       prefix(REX_WRB);</span>
<span class="line-added">8010       src_enc -= 8;</span>
<span class="line-added">8011     }</span>
<span class="line-added">8012     dst_enc -= 8;</span>
<span class="line-added">8013   }</span>
<span class="line-added">8014   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-added">8015 }</span>
<span class="line-added">8016 </span>
8017 void Assembler::adcq(Register dst, int32_t imm32) {
8018   (void) prefixq_and_encode(dst-&gt;encoding());
8019   emit_arith(0x81, 0xD0, dst, imm32);
8020 }
8021 
8022 void Assembler::adcq(Register dst, Address src) {
8023   InstructionMark im(this);
<a name="545" id="anc545"></a><span class="line-modified">8024   emit_int16(get_prefixq(src, dst), 0x13);</span>

8025   emit_operand(dst, src);
8026 }
8027 
8028 void Assembler::adcq(Register dst, Register src) {
8029   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8030   emit_arith(0x13, 0xC0, dst, src);
8031 }
8032 
8033 void Assembler::addq(Address dst, int32_t imm32) {
8034   InstructionMark im(this);
8035   prefixq(dst);
<a name="546" id="anc546"></a><span class="line-modified">8036   emit_arith_operand(0x81, rax, dst, imm32);</span>
8037 }
8038 
8039 void Assembler::addq(Address dst, Register src) {
8040   InstructionMark im(this);
<a name="547" id="anc547"></a><span class="line-modified">8041   emit_int16(get_prefixq(dst, src), 0x01);</span>

8042   emit_operand(src, dst);
8043 }
8044 
8045 void Assembler::addq(Register dst, int32_t imm32) {
8046   (void) prefixq_and_encode(dst-&gt;encoding());
8047   emit_arith(0x81, 0xC0, dst, imm32);
8048 }
8049 
8050 void Assembler::addq(Register dst, Address src) {
8051   InstructionMark im(this);
<a name="548" id="anc548"></a><span class="line-modified">8052   emit_int16(get_prefixq(src, dst), 0x03);</span>

8053   emit_operand(dst, src);
8054 }
8055 
8056 void Assembler::addq(Register dst, Register src) {
8057   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8058   emit_arith(0x03, 0xC0, dst, src);
8059 }
8060 
8061 void Assembler::adcxq(Register dst, Register src) {
8062   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
<a name="549" id="anc549"></a><span class="line-modified">8063   emit_int8(0x66);</span>
8064   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="550" id="anc550"></a><span class="line-modified">8065   emit_int32(0x0F,</span>
<span class="line-modified">8066              0x38,</span>
<span class="line-modified">8067              (unsigned char)0xF6,</span>
<span class="line-modified">8068              (0xC0 | encode));</span>
8069 }
8070 
8071 void Assembler::adoxq(Register dst, Register src) {
8072   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
8073   emit_int8((unsigned char)0xF3);
8074   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="551" id="anc551"></a><span class="line-modified">8075   emit_int32(0x0F,</span>
<span class="line-modified">8076              0x38,</span>
<span class="line-modified">8077              (unsigned char)0xF6,</span>
<span class="line-modified">8078              (0xC0 | encode));</span>
8079 }
8080 
8081 void Assembler::andq(Address dst, int32_t imm32) {
8082   InstructionMark im(this);
<a name="552" id="anc552"></a><span class="line-modified">8083   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>

8084   emit_operand(rsp, dst, 4);
8085   emit_int32(imm32);
8086 }
8087 
8088 void Assembler::andq(Register dst, int32_t imm32) {
8089   (void) prefixq_and_encode(dst-&gt;encoding());
8090   emit_arith(0x81, 0xE0, dst, imm32);
8091 }
8092 
8093 void Assembler::andq(Register dst, Address src) {
8094   InstructionMark im(this);
<a name="553" id="anc553"></a><span class="line-modified">8095   emit_int16(get_prefixq(src, dst), 0x23);</span>

8096   emit_operand(dst, src);
8097 }
8098 
8099 void Assembler::andq(Register dst, Register src) {
8100   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8101   emit_arith(0x23, 0xC0, dst, src);
8102 }
8103 
8104 void Assembler::andnq(Register dst, Register src1, Register src2) {
8105   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8106   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8107   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="554" id="anc554"></a><span class="line-modified">8108   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

8109 }
8110 
8111 void Assembler::andnq(Register dst, Register src1, Address src2) {
8112   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8113   InstructionMark im(this);
8114   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8115   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8116   emit_int8((unsigned char)0xF2);
8117   emit_operand(dst, src2);
8118 }
8119 
8120 void Assembler::bsfq(Register dst, Register src) {
8121   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="555" id="anc555"></a><span class="line-modified">8122   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>


8123 }
8124 
8125 void Assembler::bsrq(Register dst, Register src) {
8126   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="556" id="anc556"></a><span class="line-modified">8127   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>


8128 }
8129 
8130 void Assembler::bswapq(Register reg) {
8131   int encode = prefixq_and_encode(reg-&gt;encoding());
<a name="557" id="anc557"></a><span class="line-modified">8132   emit_int16(0x0F, (0xC8 | encode));</span>

8133 }
8134 
8135 void Assembler::blsiq(Register dst, Register src) {
8136   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8137   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8138   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="558" id="anc558"></a><span class="line-modified">8139   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

8140 }
8141 
8142 void Assembler::blsiq(Register dst, Address src) {
8143   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8144   InstructionMark im(this);
8145   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8146   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8147   emit_int8((unsigned char)0xF3);
8148   emit_operand(rbx, src);
8149 }
8150 
8151 void Assembler::blsmskq(Register dst, Register src) {
8152   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8153   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8154   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="559" id="anc559"></a><span class="line-modified">8155   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

8156 }
8157 
8158 void Assembler::blsmskq(Register dst, Address src) {
8159   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8160   InstructionMark im(this);
8161   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8162   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8163   emit_int8((unsigned char)0xF3);
8164   emit_operand(rdx, src);
8165 }
8166 
8167 void Assembler::blsrq(Register dst, Register src) {
8168   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8169   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8170   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<a name="560" id="anc560"></a><span class="line-modified">8171   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

8172 }
8173 
8174 void Assembler::blsrq(Register dst, Address src) {
8175   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8176   InstructionMark im(this);
8177   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8178   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8179   emit_int8((unsigned char)0xF3);
8180   emit_operand(rcx, src);
8181 }
8182 
8183 void Assembler::cdqq() {
<a name="561" id="anc561"></a><span class="line-modified">8184   emit_int16(REX_W, (unsigned char)0x99);</span>

8185 }
8186 
8187 void Assembler::clflush(Address adr) {
8188   assert(VM_Version::supports_clflush(), &quot;should do&quot;);
8189   prefix(adr);
<a name="562" id="anc562"></a><span class="line-modified">8190   emit_int16(0x0F, (unsigned char)0xAE);</span>

8191   emit_operand(rdi, adr);
8192 }
8193 
8194 void Assembler::clflushopt(Address adr) {
8195   assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);
8196   // adr should be base reg only with no index or offset
8197   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8198   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8199   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8200   // instruction prefix is 0x66
8201   emit_int8(0x66);
8202   prefix(adr);
<a name="563" id="anc563"></a><span class="line-modified">8203   // opcode family is 0x0F 0xAE</span>
<span class="line-modified">8204   emit_int16(0x0F, (unsigned char)0xAE);</span>

8205   // extended opcode byte is 7 == rdi
8206   emit_operand(rdi, adr);
8207 }
8208 
8209 void Assembler::clwb(Address adr) {
8210   assert(VM_Version::supports_clwb(), &quot;should do!&quot;);
8211   // adr should be base reg only with no index or offset
8212   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8213   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8214   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8215   // instruction prefix is 0x66
8216   emit_int8(0x66);
8217   prefix(adr);
8218   // opcode family is 0x0f 0xAE
<a name="564" id="anc564"></a><span class="line-modified">8219   emit_int16(0x0F, (unsigned char)0xAE);</span>

8220   // extended opcode byte is 6 == rsi
8221   emit_operand(rsi, adr);
8222 }
8223 
8224 void Assembler::cmovq(Condition cc, Register dst, Register src) {
8225   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="565" id="anc565"></a><span class="line-modified">8226   emit_int24(0x0F, (0x40 | cc), (0xC0 | encode));</span>


8227 }
8228 
8229 void Assembler::cmovq(Condition cc, Register dst, Address src) {
8230   InstructionMark im(this);
<a name="566" id="anc566"></a><span class="line-modified">8231   emit_int24(get_prefixq(src, dst), 0x0F, (0x40 | cc));</span>


8232   emit_operand(dst, src);
8233 }
8234 
8235 void Assembler::cmpq(Address dst, int32_t imm32) {
8236   InstructionMark im(this);
<a name="567" id="anc567"></a><span class="line-modified">8237   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>

8238   emit_operand(rdi, dst, 4);
8239   emit_int32(imm32);
8240 }
8241 
8242 void Assembler::cmpq(Register dst, int32_t imm32) {
8243   (void) prefixq_and_encode(dst-&gt;encoding());
8244   emit_arith(0x81, 0xF8, dst, imm32);
8245 }
8246 
8247 void Assembler::cmpq(Address dst, Register src) {
8248   InstructionMark im(this);
<a name="568" id="anc568"></a><span class="line-modified">8249   emit_int16(get_prefixq(dst, src), 0x3B);</span>

8250   emit_operand(src, dst);
8251 }
8252 
8253 void Assembler::cmpq(Register dst, Register src) {
8254   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8255   emit_arith(0x3B, 0xC0, dst, src);
8256 }
8257 
<a name="569" id="anc569"></a><span class="line-modified">8258 void Assembler::cmpq(Register dst, Address src) {</span>
8259   InstructionMark im(this);
<a name="570" id="anc570"></a><span class="line-modified">8260   emit_int16(get_prefixq(src, dst), 0x3B);</span>

8261   emit_operand(dst, src);
8262 }
8263 
8264 void Assembler::cmpxchgq(Register reg, Address adr) {
8265   InstructionMark im(this);
<a name="571" id="anc571"></a><span class="line-modified">8266   emit_int24(get_prefixq(adr, reg), 0x0F, (unsigned char)0xB1);</span>


8267   emit_operand(reg, adr);
8268 }
8269 
8270 void Assembler::cvtsi2sdq(XMMRegister dst, Register src) {
8271   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8272   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8273   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="572" id="anc572"></a><span class="line-modified">8274   emit_int16(0x2A, (0xC0 | encode));</span>

8275 }
8276 
8277 void Assembler::cvtsi2sdq(XMMRegister dst, Address src) {
8278   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8279   InstructionMark im(this);
8280   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8281   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8282   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8283   emit_int8(0x2A);
8284   emit_operand(dst, src);
8285 }
8286 
8287 void Assembler::cvtsi2ssq(XMMRegister dst, Address src) {
8288   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8289   InstructionMark im(this);
8290   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8291   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8292   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
8293   emit_int8(0x2A);
8294   emit_operand(dst, src);
8295 }
8296 
8297 void Assembler::cvttsd2siq(Register dst, Address src) {
8298   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8299   // F2 REX.W 0F 2C /r
8300   // CVTTSD2SI r64, xmm1/m64
8301   InstructionMark im(this);
<a name="573" id="anc573"></a><span class="line-modified">8302   emit_int32((unsigned char)0xF2, REX_W, 0x0F, 0x2C);</span>



8303   emit_operand(dst, src);
8304 }
8305 
8306 void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
8307   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8308   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8309   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<a name="574" id="anc574"></a><span class="line-modified">8310   emit_int16(0x2C, (0xC0 | encode));</span>

8311 }
8312 
8313 void Assembler::cvttss2siq(Register dst, XMMRegister src) {
8314   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8315   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8316   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<a name="575" id="anc575"></a><span class="line-modified">8317   emit_int16(0x2C, (0xC0 | encode));</span>

8318 }
8319 
8320 void Assembler::decl(Register dst) {
8321   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
8322   // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
8323   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="576" id="anc576"></a><span class="line-modified">8324   emit_int16((unsigned char)0xFF, (0xC8 | encode));</span>

8325 }
8326 
8327 void Assembler::decq(Register dst) {
8328   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8329   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8330   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="577" id="anc577"></a><span class="line-modified">8331   emit_int16((unsigned char)0xFF, 0xC8 | encode);</span>

8332 }
8333 
8334 void Assembler::decq(Address dst) {
8335   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8336   InstructionMark im(this);
<a name="578" id="anc578"></a><span class="line-modified">8337   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>

8338   emit_operand(rcx, dst);
8339 }
8340 
8341 void Assembler::fxrstor(Address src) {
<a name="579" id="anc579"></a><span class="line-modified">8342   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>


8343   emit_operand(as_Register(1), src);
8344 }
8345 
8346 void Assembler::xrstor(Address src) {
<a name="580" id="anc580"></a><span class="line-modified">8347   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>


8348   emit_operand(as_Register(5), src);
8349 }
8350 
8351 void Assembler::fxsave(Address dst) {
<a name="581" id="anc581"></a><span class="line-modified">8352   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>


8353   emit_operand(as_Register(0), dst);
8354 }
8355 
8356 void Assembler::xsave(Address dst) {
<a name="582" id="anc582"></a><span class="line-modified">8357   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>


8358   emit_operand(as_Register(4), dst);
8359 }
8360 
8361 void Assembler::idivq(Register src) {
8362   int encode = prefixq_and_encode(src-&gt;encoding());
<a name="583" id="anc583"></a><span class="line-modified">8363   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>

8364 }
8365 
8366 void Assembler::imulq(Register dst, Register src) {
8367   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="584" id="anc584"></a><span class="line-modified">8368   emit_int24(0x0F, (unsigned char)0xAF, (0xC0 | encode));</span>


8369 }
8370 
8371 void Assembler::imulq(Register dst, Register src, int value) {
8372   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8373   if (is8bit(value)) {
<a name="585" id="anc585"></a><span class="line-modified">8374     emit_int24(0x6B, (0xC0 | encode), (value &amp; 0xFF));</span>


8375   } else {
<a name="586" id="anc586"></a><span class="line-modified">8376     emit_int16(0x69, (0xC0 | encode));</span>

8377     emit_int32(value);
8378   }
8379 }
8380 
8381 void Assembler::imulq(Register dst, Address src) {
8382   InstructionMark im(this);
<a name="587" id="anc587"></a><span class="line-modified">8383   emit_int24(get_prefixq(src, dst), 0x0F, (unsigned char)0xAF);</span>


8384   emit_operand(dst, src);
8385 }
8386 
8387 void Assembler::incl(Register dst) {
8388   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
8389   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8390   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="588" id="anc588"></a><span class="line-modified">8391   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>

8392 }
8393 
8394 void Assembler::incq(Register dst) {
8395   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8396   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8397   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="589" id="anc589"></a><span class="line-modified">8398   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>

8399 }
8400 
8401 void Assembler::incq(Address dst) {
8402   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8403   InstructionMark im(this);
<a name="590" id="anc590"></a><span class="line-modified">8404   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>

8405   emit_operand(rax, dst);
8406 }
8407 
8408 void Assembler::lea(Register dst, Address src) {
8409   leaq(dst, src);
8410 }
8411 
8412 void Assembler::leaq(Register dst, Address src) {
8413   InstructionMark im(this);
<a name="591" id="anc591"></a><span class="line-modified">8414   emit_int16(get_prefixq(src, dst), (unsigned char)0x8D);</span>

8415   emit_operand(dst, src);
8416 }
8417 
8418 void Assembler::mov64(Register dst, int64_t imm64) {
8419   InstructionMark im(this);
8420   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="592" id="anc592"></a><span class="line-modified">8421   emit_int8(0xB8 | encode);</span>
8422   emit_int64(imm64);
8423 }
8424 
8425 void Assembler::mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec) {
8426   InstructionMark im(this);
8427   int encode = prefixq_and_encode(dst-&gt;encoding());
8428   emit_int8(0xB8 | encode);
8429   emit_data64(imm64, rspec);
8430 }
8431 
8432 void Assembler::mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
8433   InstructionMark im(this);
8434   int encode = prefix_and_encode(dst-&gt;encoding());
<a name="593" id="anc593"></a><span class="line-modified">8435   emit_int8(0xB8 | encode);</span>
8436   emit_data((int)imm32, rspec, narrow_oop_operand);
8437 }
8438 
8439 void Assembler::mov_narrow_oop(Address dst, int32_t imm32,  RelocationHolder const&amp; rspec) {
8440   InstructionMark im(this);
8441   prefix(dst);
8442   emit_int8((unsigned char)0xC7);
8443   emit_operand(rax, dst, 4);
8444   emit_data((int)imm32, rspec, narrow_oop_operand);
8445 }
8446 
8447 void Assembler::cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
8448   InstructionMark im(this);
8449   int encode = prefix_and_encode(src1-&gt;encoding());
<a name="594" id="anc594"></a><span class="line-modified">8450   emit_int16((unsigned char)0x81, (0xF8 | encode));</span>

8451   emit_data((int)imm32, rspec, narrow_oop_operand);
8452 }
8453 
8454 void Assembler::cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
8455   InstructionMark im(this);
8456   prefix(src1);
8457   emit_int8((unsigned char)0x81);
8458   emit_operand(rax, src1, 4);
8459   emit_data((int)imm32, rspec, narrow_oop_operand);
8460 }
8461 
8462 void Assembler::lzcntq(Register dst, Register src) {
8463   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
8464   emit_int8((unsigned char)0xF3);
8465   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="595" id="anc595"></a><span class="line-modified">8466   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>


8467 }
8468 
8469 void Assembler::movdq(XMMRegister dst, Register src) {
8470   // table D-1 says MMX/SSE2
8471   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8472   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8473   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="596" id="anc596"></a><span class="line-modified">8474   emit_int16(0x6E, (0xC0 | encode));</span>

8475 }
8476 
8477 void Assembler::movdq(Register dst, XMMRegister src) {
8478   // table D-1 says MMX/SSE2
8479   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8480   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8481   // swap src/dst to get correct prefix
8482   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<a name="597" id="anc597"></a><span class="line-modified">8483   emit_int16(0x7E,</span>
<span class="line-modified">8484              (0xC0 | encode));</span>
8485 }
8486 
8487 void Assembler::movq(Register dst, Register src) {
8488   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="598" id="anc598"></a><span class="line-modified">8489   emit_int16((unsigned char)0x8B,</span>
<span class="line-modified">8490              (0xC0 | encode));</span>
8491 }
8492 
8493 void Assembler::movq(Register dst, Address src) {
8494   InstructionMark im(this);
<a name="599" id="anc599"></a><span class="line-modified">8495   emit_int16(get_prefixq(src, dst), (unsigned char)0x8B);</span>

8496   emit_operand(dst, src);
8497 }
8498 
8499 void Assembler::movq(Address dst, Register src) {
8500   InstructionMark im(this);
<a name="600" id="anc600"></a><span class="line-modified">8501   emit_int16(get_prefixq(dst, src), (unsigned char)0x89);</span>

8502   emit_operand(src, dst);
8503 }
8504 
8505 void Assembler::movsbq(Register dst, Address src) {
8506   InstructionMark im(this);
<a name="601" id="anc601"></a><span class="line-modified">8507   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8508              0x0F,</span>
<span class="line-modified">8509              (unsigned char)0xBE);</span>
8510   emit_operand(dst, src);
8511 }
8512 
8513 void Assembler::movsbq(Register dst, Register src) {
8514   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="602" id="anc602"></a><span class="line-modified">8515   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>


8516 }
8517 
8518 void Assembler::movslq(Register dst, int32_t imm32) {
8519   // dbx shows movslq(rcx, 3) as movq     $0x0000000049000000,(%rbx)
8520   // and movslq(r8, 3); as movl     $0x0000000048000000,(%rbx)
8521   // as a result we shouldn&#39;t use until tested at runtime...
8522   ShouldNotReachHere();
8523   InstructionMark im(this);
8524   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="603" id="anc603"></a><span class="line-modified">8525   emit_int8(0xC7 | encode);</span>
8526   emit_int32(imm32);
8527 }
8528 
8529 void Assembler::movslq(Address dst, int32_t imm32) {
8530   assert(is_simm32(imm32), &quot;lost bits&quot;);
8531   InstructionMark im(this);
<a name="604" id="anc604"></a><span class="line-modified">8532   emit_int16(get_prefixq(dst), (unsigned char)0xC7);</span>

8533   emit_operand(rax, dst, 4);
8534   emit_int32(imm32);
8535 }
8536 
8537 void Assembler::movslq(Register dst, Address src) {
8538   InstructionMark im(this);
<a name="605" id="anc605"></a><span class="line-modified">8539   emit_int16(get_prefixq(src, dst), 0x63);</span>

8540   emit_operand(dst, src);
8541 }
8542 
8543 void Assembler::movslq(Register dst, Register src) {
8544   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="606" id="anc606"></a><span class="line-modified">8545   emit_int16(0x63, (0xC0 | encode));</span>

8546 }
8547 
8548 void Assembler::movswq(Register dst, Address src) {
8549   InstructionMark im(this);
<a name="607" id="anc607"></a><span class="line-modified">8550   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8551              0x0F,</span>
<span class="line-modified">8552              (unsigned char)0xBF);</span>
8553   emit_operand(dst, src);
8554 }
8555 
8556 void Assembler::movswq(Register dst, Register src) {
8557   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="608" id="anc608"></a><span class="line-modified">8558   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>


8559 }
8560 
8561 void Assembler::movzbq(Register dst, Address src) {
8562   InstructionMark im(this);
<a name="609" id="anc609"></a><span class="line-modified">8563   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8564              0x0F,</span>
<span class="line-modified">8565              (unsigned char)0xB6);</span>
8566   emit_operand(dst, src);
8567 }
8568 
8569 void Assembler::movzbq(Register dst, Register src) {
8570   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="610" id="anc610"></a><span class="line-modified">8571   emit_int24(0x0F, (unsigned char)0xB6, (0xC0 | encode));</span>


8572 }
8573 
8574 void Assembler::movzwq(Register dst, Address src) {
8575   InstructionMark im(this);
<a name="611" id="anc611"></a><span class="line-modified">8576   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8577              0x0F,</span>
<span class="line-modified">8578              (unsigned char)0xB7);</span>
8579   emit_operand(dst, src);
8580 }
8581 
8582 void Assembler::movzwq(Register dst, Register src) {
8583   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="612" id="anc612"></a><span class="line-modified">8584   emit_int24(0x0F, (unsigned char)0xB7, (0xC0 | encode));</span>


8585 }
8586 
8587 void Assembler::mulq(Address src) {
8588   InstructionMark im(this);
<a name="613" id="anc613"></a><span class="line-modified">8589   emit_int16(get_prefixq(src), (unsigned char)0xF7);</span>

8590   emit_operand(rsp, src);
8591 }
8592 
8593 void Assembler::mulq(Register src) {
8594   int encode = prefixq_and_encode(src-&gt;encoding());
<a name="614" id="anc614"></a><span class="line-modified">8595   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>

8596 }
8597 
8598 void Assembler::mulxq(Register dst1, Register dst2, Register src) {
8599   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
8600   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8601   int encode = vex_prefix_and_encode(dst1-&gt;encoding(), dst2-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &amp;attributes);
<a name="615" id="anc615"></a><span class="line-modified">8602   emit_int16((unsigned char)0xF6, (0xC0 | encode));</span>

8603 }
8604 
8605 void Assembler::negq(Register dst) {
8606   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="616" id="anc616"></a><span class="line-modified">8607   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>

8608 }
8609 
8610 void Assembler::notq(Register dst) {
8611   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="617" id="anc617"></a><span class="line-modified">8612   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>

8613 }
8614 
8615 void Assembler::btsq(Address dst, int imm8) {
8616   assert(isByte(imm8), &quot;not a byte&quot;);
8617   InstructionMark im(this);
<a name="618" id="anc618"></a><span class="line-modified">8618   emit_int24(get_prefixq(dst),</span>
<span class="line-modified">8619              0x0F,</span>
<span class="line-modified">8620              (unsigned char)0xBA);</span>
8621   emit_operand(rbp /* 5 */, dst, 1);
8622   emit_int8(imm8);
8623 }
8624 
8625 void Assembler::btrq(Address dst, int imm8) {
8626   assert(isByte(imm8), &quot;not a byte&quot;);
8627   InstructionMark im(this);
<a name="619" id="anc619"></a><span class="line-modified">8628   emit_int24(get_prefixq(dst),</span>
<span class="line-modified">8629              0x0F,</span>
<span class="line-modified">8630              (unsigned char)0xBA);</span>
8631   emit_operand(rsi /* 6 */, dst, 1);
8632   emit_int8(imm8);
8633 }
8634 
8635 void Assembler::orq(Address dst, int32_t imm32) {
8636   InstructionMark im(this);
<a name="620" id="anc620"></a><span class="line-modified">8637   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>

8638   emit_operand(rcx, dst, 4);
8639   emit_int32(imm32);
8640 }
8641 
8642 void Assembler::orq(Register dst, int32_t imm32) {
8643   (void) prefixq_and_encode(dst-&gt;encoding());
8644   emit_arith(0x81, 0xC8, dst, imm32);
8645 }
8646 
8647 void Assembler::orq(Register dst, Address src) {
8648   InstructionMark im(this);
<a name="621" id="anc621"></a><span class="line-modified">8649   emit_int16(get_prefixq(src, dst), 0x0B);</span>

8650   emit_operand(dst, src);
8651 }
8652 
8653 void Assembler::orq(Register dst, Register src) {
8654   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8655   emit_arith(0x0B, 0xC0, dst, src);
8656 }
8657 
<a name="622" id="anc622"></a><span class="line-added">8658 void Assembler::popcntq(Register dst, Address src) {</span>
<span class="line-added">8659   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-added">8660   InstructionMark im(this);</span>
<span class="line-added">8661   emit_int32((unsigned char)0xF3,</span>
<span class="line-added">8662              get_prefixq(src, dst),</span>
<span class="line-added">8663              0x0F,</span>
<span class="line-added">8664              (unsigned char)0xB8);</span>
<span class="line-added">8665   emit_operand(dst, src);</span>
<span class="line-added">8666 }</span>
<span class="line-added">8667 </span>
<span class="line-added">8668 void Assembler::popcntq(Register dst, Register src) {</span>
<span class="line-added">8669   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-added">8670   emit_int8((unsigned char)0xF3);</span>
<span class="line-added">8671   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());</span>
<span class="line-added">8672   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>
<span class="line-added">8673 }</span>
<span class="line-added">8674 </span>
<span class="line-added">8675 void Assembler::popq(Address dst) {</span>
<span class="line-added">8676   InstructionMark im(this);</span>
<span class="line-added">8677   emit_int16(get_prefixq(dst), (unsigned char)0x8F);</span>
<span class="line-added">8678   emit_operand(rax, dst);</span>
<span class="line-added">8679 }</span>
<span class="line-added">8680 </span>
<span class="line-added">8681 // Precomputable: popa, pusha, vzeroupper</span>
<span class="line-added">8682 </span>
<span class="line-added">8683 // The result of these routines are invariant from one invocation to another</span>
<span class="line-added">8684 // invocation for the duration of a run. Caching the result on bootstrap</span>
<span class="line-added">8685 // and copying it out on subsequent invocations can thus be beneficial</span>
<span class="line-added">8686 static bool     precomputed = false;</span>
<span class="line-added">8687 </span>
<span class="line-added">8688 static u_char* popa_code  = NULL;</span>
<span class="line-added">8689 static int     popa_len   = 0;</span>
<span class="line-added">8690 </span>
<span class="line-added">8691 static u_char* pusha_code = NULL;</span>
<span class="line-added">8692 static int     pusha_len  = 0;</span>
<span class="line-added">8693 </span>
<span class="line-added">8694 static u_char* vzup_code  = NULL;</span>
<span class="line-added">8695 static int     vzup_len   = 0;</span>
<span class="line-added">8696 </span>
<span class="line-added">8697 void Assembler::precompute_instructions() {</span>
<span class="line-added">8698   assert(!Universe::is_fully_initialized(), &quot;must still be single threaded&quot;);</span>
<span class="line-added">8699   guarantee(!precomputed, &quot;only once&quot;);</span>
<span class="line-added">8700   precomputed = true;</span>
<span class="line-added">8701   ResourceMark rm;</span>
<span class="line-added">8702 </span>
<span class="line-added">8703   // Make a temporary buffer big enough for the routines we&#39;re capturing</span>
<span class="line-added">8704   int size = 256;</span>
<span class="line-added">8705   char* tmp_code = NEW_RESOURCE_ARRAY(char, size);</span>
<span class="line-added">8706   CodeBuffer buffer((address)tmp_code, size);</span>
<span class="line-added">8707   MacroAssembler masm(&amp;buffer);</span>
<span class="line-added">8708 </span>
<span class="line-added">8709   address begin_popa  = masm.code_section()-&gt;end();</span>
<span class="line-added">8710   masm.popa_uncached();</span>
<span class="line-added">8711   address end_popa    = masm.code_section()-&gt;end();</span>
<span class="line-added">8712   masm.pusha_uncached();</span>
<span class="line-added">8713   address end_pusha   = masm.code_section()-&gt;end();</span>
<span class="line-added">8714   masm.vzeroupper_uncached();</span>
<span class="line-added">8715   address end_vzup    = masm.code_section()-&gt;end();</span>
<span class="line-added">8716 </span>
<span class="line-added">8717   // Save the instructions to permanent buffers.</span>
<span class="line-added">8718   popa_len = (int)(end_popa - begin_popa);</span>
<span class="line-added">8719   popa_code = NEW_C_HEAP_ARRAY(u_char, popa_len, mtInternal);</span>
<span class="line-added">8720   memcpy(popa_code, begin_popa, popa_len);</span>
<span class="line-added">8721 </span>
<span class="line-added">8722   pusha_len = (int)(end_pusha - end_popa);</span>
<span class="line-added">8723   pusha_code = NEW_C_HEAP_ARRAY(u_char, pusha_len, mtInternal);</span>
<span class="line-added">8724   memcpy(pusha_code, end_popa, pusha_len);</span>
<span class="line-added">8725 </span>
<span class="line-added">8726   vzup_len = (int)(end_vzup - end_pusha);</span>
<span class="line-added">8727   if (vzup_len &gt; 0) {</span>
<span class="line-added">8728     vzup_code = NEW_C_HEAP_ARRAY(u_char, vzup_len, mtInternal);</span>
<span class="line-added">8729     memcpy(vzup_code, end_pusha, vzup_len);</span>
<span class="line-added">8730   } else {</span>
<span class="line-added">8731     vzup_code = pusha_code; // dummy</span>
<span class="line-added">8732   }</span>
<span class="line-added">8733 </span>
<span class="line-added">8734   assert(masm.code()-&gt;total_oop_size() == 0 &amp;&amp;</span>
<span class="line-added">8735          masm.code()-&gt;total_metadata_size() == 0 &amp;&amp;</span>
<span class="line-added">8736          masm.code()-&gt;total_relocation_size() == 0,</span>
<span class="line-added">8737          &quot;pre-computed code can&#39;t reference oops, metadata or contain relocations&quot;);</span>
<span class="line-added">8738 }</span>
<span class="line-added">8739 </span>
<span class="line-added">8740 static void emit_copy(CodeSection* code_section, u_char* src, int src_len) {</span>
<span class="line-added">8741   assert(src != NULL, &quot;code to copy must have been pre-computed&quot;);</span>
<span class="line-added">8742   assert(code_section-&gt;limit() - code_section-&gt;end() &gt; src_len, &quot;code buffer not large enough&quot;);</span>
<span class="line-added">8743   address end = code_section-&gt;end();</span>
<span class="line-added">8744   memcpy(end, src, src_len);</span>
<span class="line-added">8745   code_section-&gt;set_end(end + src_len);</span>
<span class="line-added">8746 }</span>
<span class="line-added">8747 </span>
8748 void Assembler::popa() { // 64bit
<a name="623" id="anc623"></a><span class="line-added">8749   emit_copy(code_section(), popa_code, popa_len);</span>
<span class="line-added">8750 }</span>
<span class="line-added">8751 </span>
<span class="line-added">8752 void Assembler::popa_uncached() { // 64bit</span>
8753   movq(r15, Address(rsp, 0));
8754   movq(r14, Address(rsp, wordSize));
8755   movq(r13, Address(rsp, 2 * wordSize));
8756   movq(r12, Address(rsp, 3 * wordSize));
8757   movq(r11, Address(rsp, 4 * wordSize));
8758   movq(r10, Address(rsp, 5 * wordSize));
8759   movq(r9,  Address(rsp, 6 * wordSize));
8760   movq(r8,  Address(rsp, 7 * wordSize));
8761   movq(rdi, Address(rsp, 8 * wordSize));
8762   movq(rsi, Address(rsp, 9 * wordSize));
8763   movq(rbp, Address(rsp, 10 * wordSize));
8764   // skip rsp
8765   movq(rbx, Address(rsp, 12 * wordSize));
8766   movq(rdx, Address(rsp, 13 * wordSize));
8767   movq(rcx, Address(rsp, 14 * wordSize));
8768   movq(rax, Address(rsp, 15 * wordSize));
8769 
8770   addq(rsp, 16 * wordSize);
8771 }
8772 
<a name="624" id="anc624"></a><span class="line-modified">8773 void Assembler::pusha() { // 64bit</span>
<span class="line-modified">8774   emit_copy(code_section(), pusha_code, pusha_len);</span>






















8775 }
8776 
<a name="625" id="anc625"></a><span class="line-modified">8777 void Assembler::pusha_uncached() { // 64bit</span>
8778   // we have to store original rsp.  ABI says that 128 bytes
8779   // below rsp are local scratch.
8780   movq(Address(rsp, -5 * wordSize), rsp);
8781 
8782   subq(rsp, 16 * wordSize);
8783 
8784   movq(Address(rsp, 15 * wordSize), rax);
8785   movq(Address(rsp, 14 * wordSize), rcx);
8786   movq(Address(rsp, 13 * wordSize), rdx);
8787   movq(Address(rsp, 12 * wordSize), rbx);
8788   // skip rsp
8789   movq(Address(rsp, 10 * wordSize), rbp);
8790   movq(Address(rsp, 9 * wordSize), rsi);
8791   movq(Address(rsp, 8 * wordSize), rdi);
8792   movq(Address(rsp, 7 * wordSize), r8);
8793   movq(Address(rsp, 6 * wordSize), r9);
8794   movq(Address(rsp, 5 * wordSize), r10);
8795   movq(Address(rsp, 4 * wordSize), r11);
8796   movq(Address(rsp, 3 * wordSize), r12);
8797   movq(Address(rsp, 2 * wordSize), r13);
8798   movq(Address(rsp, wordSize), r14);
8799   movq(Address(rsp, 0), r15);
8800 }
8801 
<a name="626" id="anc626"></a><span class="line-added">8802 void Assembler::vzeroupper() {</span>
<span class="line-added">8803   emit_copy(code_section(), vzup_code, vzup_len);</span>
<span class="line-added">8804 }</span>
<span class="line-added">8805 </span>
8806 void Assembler::pushq(Address src) {
8807   InstructionMark im(this);
<a name="627" id="anc627"></a><span class="line-modified">8808   emit_int16(get_prefixq(src), (unsigned char)0xFF);</span>

8809   emit_operand(rsi, src);
8810 }
8811 
8812 void Assembler::rclq(Register dst, int imm8) {
8813   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8814   int encode = prefixq_and_encode(dst-&gt;encoding());
8815   if (imm8 == 1) {
<a name="628" id="anc628"></a><span class="line-modified">8816     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>

8817   } else {
<a name="629" id="anc629"></a><span class="line-modified">8818     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>


8819   }
8820 }
8821 
8822 void Assembler::rcrq(Register dst, int imm8) {
8823   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8824   int encode = prefixq_and_encode(dst-&gt;encoding());
8825   if (imm8 == 1) {
<a name="630" id="anc630"></a><span class="line-modified">8826     emit_int16((unsigned char)0xD1, (0xD8 | encode));</span>

8827   } else {
<a name="631" id="anc631"></a><span class="line-modified">8828     emit_int24((unsigned char)0xC1, (0xD8 | encode), imm8);</span>


8829   }
8830 }
8831 
8832 void Assembler::rorq(Register dst, int imm8) {
8833   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8834   int encode = prefixq_and_encode(dst-&gt;encoding());
8835   if (imm8 == 1) {
<a name="632" id="anc632"></a><span class="line-modified">8836     emit_int16((unsigned char)0xD1, (0xC8 | encode));</span>

8837   } else {
<a name="633" id="anc633"></a><span class="line-modified">8838     emit_int24((unsigned char)0xC1, (0xc8 | encode), imm8);</span>


8839   }
8840 }
8841 
8842 void Assembler::rorxq(Register dst, Register src, int imm8) {
8843   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
8844   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8845   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="634" id="anc634"></a><span class="line-modified">8846   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>


8847 }
8848 
8849 void Assembler::rorxd(Register dst, Register src, int imm8) {
8850   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
8851   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8852   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<a name="635" id="anc635"></a><span class="line-modified">8853   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>


8854 }
8855 
8856 void Assembler::sarq(Register dst, int imm8) {
8857   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8858   int encode = prefixq_and_encode(dst-&gt;encoding());
8859   if (imm8 == 1) {
<a name="636" id="anc636"></a><span class="line-modified">8860     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>

8861   } else {
<a name="637" id="anc637"></a><span class="line-modified">8862     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>


8863   }
8864 }
8865 
8866 void Assembler::sarq(Register dst) {
8867   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="638" id="anc638"></a><span class="line-modified">8868   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>

8869 }
8870 
8871 void Assembler::sbbq(Address dst, int32_t imm32) {
8872   InstructionMark im(this);
8873   prefixq(dst);
8874   emit_arith_operand(0x81, rbx, dst, imm32);
8875 }
8876 
8877 void Assembler::sbbq(Register dst, int32_t imm32) {
8878   (void) prefixq_and_encode(dst-&gt;encoding());
8879   emit_arith(0x81, 0xD8, dst, imm32);
8880 }
8881 
8882 void Assembler::sbbq(Register dst, Address src) {
8883   InstructionMark im(this);
<a name="639" id="anc639"></a><span class="line-modified">8884   emit_int16(get_prefixq(src, dst), 0x1B);</span>

8885   emit_operand(dst, src);
8886 }
8887 
8888 void Assembler::sbbq(Register dst, Register src) {
8889   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8890   emit_arith(0x1B, 0xC0, dst, src);
8891 }
8892 
8893 void Assembler::shlq(Register dst, int imm8) {
8894   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8895   int encode = prefixq_and_encode(dst-&gt;encoding());
8896   if (imm8 == 1) {
<a name="640" id="anc640"></a><span class="line-modified">8897     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>

8898   } else {
<a name="641" id="anc641"></a><span class="line-modified">8899     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>


8900   }
8901 }
8902 
8903 void Assembler::shlq(Register dst) {
8904   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="642" id="anc642"></a><span class="line-modified">8905   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>

8906 }
8907 
8908 void Assembler::shrq(Register dst, int imm8) {
8909   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8910   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="643" id="anc643"></a><span class="line-modified">8911   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>


8912 }
8913 
8914 void Assembler::shrq(Register dst) {
8915   int encode = prefixq_and_encode(dst-&gt;encoding());
<a name="644" id="anc644"></a><span class="line-modified">8916   emit_int16((unsigned char)0xD3, 0xE8 | encode);</span>

8917 }
8918 
8919 void Assembler::subq(Address dst, int32_t imm32) {
8920   InstructionMark im(this);
8921   prefixq(dst);
8922   emit_arith_operand(0x81, rbp, dst, imm32);
8923 }
8924 
8925 void Assembler::subq(Address dst, Register src) {
8926   InstructionMark im(this);
<a name="645" id="anc645"></a><span class="line-modified">8927   emit_int16(get_prefixq(dst, src), 0x29);</span>

8928   emit_operand(src, dst);
8929 }
8930 
8931 void Assembler::subq(Register dst, int32_t imm32) {
8932   (void) prefixq_and_encode(dst-&gt;encoding());
8933   emit_arith(0x81, 0xE8, dst, imm32);
8934 }
8935 
8936 // Force generation of a 4 byte immediate value even if it fits into 8bit
8937 void Assembler::subq_imm32(Register dst, int32_t imm32) {
8938   (void) prefixq_and_encode(dst-&gt;encoding());
8939   emit_arith_imm32(0x81, 0xE8, dst, imm32);
8940 }
8941 
8942 void Assembler::subq(Register dst, Address src) {
8943   InstructionMark im(this);
<a name="646" id="anc646"></a><span class="line-modified">8944   emit_int16(get_prefixq(src, dst), 0x2B);</span>

8945   emit_operand(dst, src);
8946 }
8947 
8948 void Assembler::subq(Register dst, Register src) {
8949   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8950   emit_arith(0x2B, 0xC0, dst, src);
8951 }
8952 
8953 void Assembler::testq(Register dst, int32_t imm32) {
8954   // not using emit_arith because test
8955   // doesn&#39;t support sign-extension of
8956   // 8bit operands
8957   int encode = dst-&gt;encoding();
8958   if (encode == 0) {
<a name="647" id="anc647"></a><span class="line-modified">8959     emit_int16(REX_W, (unsigned char)0xA9);</span>

8960   } else {
8961     encode = prefixq_and_encode(encode);
<a name="648" id="anc648"></a><span class="line-modified">8962     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

8963   }
8964   emit_int32(imm32);
8965 }
8966 
8967 void Assembler::testq(Register dst, Register src) {
8968   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8969   emit_arith(0x85, 0xC0, dst, src);
8970 }
8971 
8972 void Assembler::testq(Register dst, Address src) {
8973   InstructionMark im(this);
<a name="649" id="anc649"></a><span class="line-modified">8974   emit_int16(get_prefixq(src, dst), (unsigned char)0x85);</span>

8975   emit_operand(dst, src);
8976 }
8977 
8978 void Assembler::xaddq(Address dst, Register src) {
8979   InstructionMark im(this);
<a name="650" id="anc650"></a><span class="line-modified">8980   emit_int24(get_prefixq(dst, src), 0x0F, (unsigned char)0xC1);</span>


8981   emit_operand(src, dst);
8982 }
8983 
8984 void Assembler::xchgq(Register dst, Address src) {
8985   InstructionMark im(this);
<a name="651" id="anc651"></a><span class="line-modified">8986   emit_int16(get_prefixq(src, dst), (unsigned char)0x87);</span>

8987   emit_operand(dst, src);
8988 }
8989 
8990 void Assembler::xchgq(Register dst, Register src) {
8991   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<a name="652" id="anc652"></a><span class="line-modified">8992   emit_int16((unsigned char)0x87, (0xc0 | encode));</span>

8993 }
8994 
8995 void Assembler::xorq(Register dst, Register src) {
8996   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8997   emit_arith(0x33, 0xC0, dst, src);
8998 }
8999 
9000 void Assembler::xorq(Register dst, Address src) {
9001   InstructionMark im(this);
<a name="653" id="anc653"></a><span class="line-modified">9002   emit_int16(get_prefixq(src, dst), 0x33);</span>

9003   emit_operand(dst, src);
9004 }
9005 
9006 #endif // !LP64
<a name="654" id="anc654"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="654" type="hidden" />
</body>
</html>
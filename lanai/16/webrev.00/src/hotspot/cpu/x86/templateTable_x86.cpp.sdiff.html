<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3726 
3727   // It&#39;s final, need a null check here!
3728   __ null_check(recv);
3729 
3730   // profile this call
3731   __ profile_final_call(rax);
3732   __ profile_arguments_type(rax, method, rbcp, true);
3733 
3734   __ jump_from_interpreted(method, rax);
3735 
3736   __ bind(notFinal);
3737 
3738   // get receiver klass
3739   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3740   __ load_klass(rax, recv);
3741 
3742   // profile this call
3743   __ profile_virtual_call(rax, rlocals, rdx);
3744   // get target Method* &amp; entry point
3745   __ lookup_virtual_method(rax, index, method);
<span class="line-removed">3746   __ profile_called_method(method, rdx, rbcp);</span>
3747 
3748   __ profile_arguments_type(rdx, method, rbcp, true);
3749   __ jump_from_interpreted(method, rdx);
3750 }
3751 
3752 void TemplateTable::invokevirtual(int byte_no) {
3753   transition(vtos, vtos);
3754   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3755   prepare_invoke(byte_no,
3756                  rbx,    // method or vtable index
3757                  noreg,  // unused itable index
3758                  rcx, rdx); // recv, flags
3759 
3760   // rbx: index
3761   // rcx: receiver
3762   // rdx: flags
3763 
3764   invokevirtual_helper(rbx, rcx, rdx);
3765 }
3766 
</pre>
<hr />
<pre>
3878   __ subl(rbx, Method::itable_index_max);
3879   __ negl(rbx);
3880 
3881   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3882   __ mov(rlocals, rdx);
3883   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3884                              rlocals, rax, rbx,
3885                              // outputs: method, scan temp. reg
3886                              rbx, rbcp,
3887                              no_such_interface);
3888 
3889   // rbx: Method* to call
3890   // rcx: receiver
3891   // Check for abstract method error
3892   // Note: This should be done more efficiently via a throw_abstract_method_error
3893   //       interpreter entry point and a conditional jump to it in case of a null
3894   //       method.
3895   __ testptr(rbx, rbx);
3896   __ jcc(Assembler::zero, no_such_method);
3897 
<span class="line-removed">3898   __ profile_called_method(rbx, rbcp, rdx);</span>
3899   __ profile_arguments_type(rdx, rbx, rbcp, true);
3900 
3901   // do the call
3902   // rcx: receiver
3903   // rbx,: Method*
3904   __ jump_from_interpreted(rbx, rdx);
3905   __ should_not_reach_here();
3906 
3907   // exception handling code follows...
3908   // note: must restore interpreter registers to canonical
3909   //       state for exception handling to work correctly!
3910 
3911   __ bind(no_such_method);
3912   // throw exception
3913   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
3914   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
3915   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3916   // Pass arguments for generating a verbose error message.
3917 #ifdef _LP64
3918   recvKlass = c_rarg1;
</pre>
</td>
<td>
<hr />
<pre>
3726 
3727   // It&#39;s final, need a null check here!
3728   __ null_check(recv);
3729 
3730   // profile this call
3731   __ profile_final_call(rax);
3732   __ profile_arguments_type(rax, method, rbcp, true);
3733 
3734   __ jump_from_interpreted(method, rax);
3735 
3736   __ bind(notFinal);
3737 
3738   // get receiver klass
3739   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3740   __ load_klass(rax, recv);
3741 
3742   // profile this call
3743   __ profile_virtual_call(rax, rlocals, rdx);
3744   // get target Method* &amp; entry point
3745   __ lookup_virtual_method(rax, index, method);

3746 
3747   __ profile_arguments_type(rdx, method, rbcp, true);
3748   __ jump_from_interpreted(method, rdx);
3749 }
3750 
3751 void TemplateTable::invokevirtual(int byte_no) {
3752   transition(vtos, vtos);
3753   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3754   prepare_invoke(byte_no,
3755                  rbx,    // method or vtable index
3756                  noreg,  // unused itable index
3757                  rcx, rdx); // recv, flags
3758 
3759   // rbx: index
3760   // rcx: receiver
3761   // rdx: flags
3762 
3763   invokevirtual_helper(rbx, rcx, rdx);
3764 }
3765 
</pre>
<hr />
<pre>
3877   __ subl(rbx, Method::itable_index_max);
3878   __ negl(rbx);
3879 
3880   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
3881   __ mov(rlocals, rdx);
3882   __ lookup_interface_method(// inputs: rec. class, interface, itable index
3883                              rlocals, rax, rbx,
3884                              // outputs: method, scan temp. reg
3885                              rbx, rbcp,
3886                              no_such_interface);
3887 
3888   // rbx: Method* to call
3889   // rcx: receiver
3890   // Check for abstract method error
3891   // Note: This should be done more efficiently via a throw_abstract_method_error
3892   //       interpreter entry point and a conditional jump to it in case of a null
3893   //       method.
3894   __ testptr(rbx, rbx);
3895   __ jcc(Assembler::zero, no_such_method);
3896 

3897   __ profile_arguments_type(rdx, rbx, rbcp, true);
3898 
3899   // do the call
3900   // rcx: receiver
3901   // rbx,: Method*
3902   __ jump_from_interpreted(rbx, rdx);
3903   __ should_not_reach_here();
3904 
3905   // exception handling code follows...
3906   // note: must restore interpreter registers to canonical
3907   //       state for exception handling to work correctly!
3908 
3909   __ bind(no_such_method);
3910   // throw exception
3911   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
3912   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
3913   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
3914   // Pass arguments for generating a verbose error message.
3915 #ifdef _LP64
3916   recvKlass = c_rarg1;
</pre>
</td>
</tr>
</table>
<center><a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>